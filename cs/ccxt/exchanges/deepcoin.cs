namespace ccxt;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

public partial class deepcoin : Exchange
{
    public override object describe()
    {
        return this.deepExtend(base.describe(), new Dictionary<string, object>() {
            { "id", "deepcoin" },
            { "name", "DeepCoin" },
            { "countries", new List<object>() {"SG"} },
            { "rateLimit", 200 },
            { "version", "v1" },
            { "certified", false },
            { "pro", true },
            { "has", new Dictionary<string, object>() {
                { "CORS", null },
                { "spot", true },
                { "margin", true },
                { "swap", true },
                { "future", false },
                { "option", false },
                { "addMargin", false },
                { "cancelAllOrders", true },
                { "cancelAllOrdersAfter", false },
                { "cancelOrder", true },
                { "cancelOrders", true },
                { "cancelWithdraw", false },
                { "closePosition", true },
                { "createConvertTrade", false },
                { "createDepositAddress", false },
                { "createLimitBuyOrder", true },
                { "createLimitOrder", true },
                { "createLimitSellOrder", true },
                { "createMarketBuyOrder", true },
                { "createMarketBuyOrderWithCost", true },
                { "createMarketOrder", true },
                { "createMarketOrderWithCost", true },
                { "createMarketSellOrder", true },
                { "createMarketSellOrderWithCost", true },
                { "createOrder", true },
                { "createOrders", false },
                { "createOrderWithTakeProfitAndStopLoss", true },
                { "createPostOnlyOrder", true },
                { "createReduceOnlyOrder", true },
                { "createStopLossOrder", false },
                { "createTakeProfitOrder", false },
                { "createTrailingAmountOrder", false },
                { "createTrailingPercentOrder", false },
                { "createTriggerOrder", true },
                { "editOrder", true },
                { "fetchAccounts", false },
                { "fetchBalance", true },
                { "fetchCanceledAndClosedOrders", true },
                { "fetchCanceledOrders", true },
                { "fetchClosedOrder", true },
                { "fetchClosedOrders", true },
                { "fetchConvertCurrencies", false },
                { "fetchConvertQuote", false },
                { "fetchConvertTrade", false },
                { "fetchConvertTradeHistory", false },
                { "fetchCurrencies", false },
                { "fetchDepositAddress", true },
                { "fetchDepositAddresses", true },
                { "fetchDeposits", true },
                { "fetchDepositsWithdrawals", false },
                { "fetchDepositWithdrawFees", false },
                { "fetchFundingHistory", false },
                { "fetchFundingRate", true },
                { "fetchFundingRateHistory", true },
                { "fetchFundingRates", true },
                { "fetchIndexOHLCV", true },
                { "fetchLedger", true },
                { "fetchLeverage", false },
                { "fetchLeverageTiers", false },
                { "fetchMarginAdjustmentHistory", false },
                { "fetchMarginMode", false },
                { "fetchMarkets", true },
                { "fetchMarkOHLCV", true },
                { "fetchMyTrades", true },
                { "fetchOHLCV", true },
                { "fetchOpenInterest", false },
                { "fetchOpenInterestHistory", false },
                { "fetchOpenOrder", true },
                { "fetchOpenOrders", true },
                { "fetchOrder", false },
                { "fetchOrderBook", true },
                { "fetchOrders", false },
                { "fetchOrderTrades", true },
                { "fetchPosition", true },
                { "fetchPositionHistory", false },
                { "fetchPositionMode", false },
                { "fetchPositions", true },
                { "fetchPositionsForSymbol", true },
                { "fetchPositionsHistory", true },
                { "fetchPremiumIndexOHLCV", false },
                { "fetchStatus", false },
                { "fetchTicker", false },
                { "fetchTickers", true },
                { "fetchTime", false },
                { "fetchTrades", true },
                { "fetchTradingFee", false },
                { "fetchTradingFees", false },
                { "fetchTransactions", false },
                { "fetchTransfers", false },
                { "fetchWithdrawals", true },
                { "reduceMargin", false },
                { "sandbox", false },
                { "setLeverage", true },
                { "setMargin", false },
                { "setMarginMode", false },
                { "setPositionMode", false },
                { "transfer", true },
                { "withdraw", false },
            } },
            { "timeframes", new Dictionary<string, object>() {
                { "1m", "1m" },
                { "5m", "5m" },
                { "15m", "15m" },
                { "30m", "30m" },
                { "1h", "1H" },
                { "4h", "4H" },
                { "12h", "12H" },
                { "1d", "1D" },
                { "1w", "1W" },
                { "1M", "1M" },
                { "1y", "1Y" },
            } },
            { "urls", new Dictionary<string, object>() {
                { "logo", "https://github.com/user-attachments/assets/ddf3e178-c3b6-409d-8f9f-af8b7cf80454" },
                { "api", new Dictionary<string, object>() {
                    { "public", "https://api.deepcoin.com" },
                    { "private", "https://api.deepcoin.com" },
                } },
                { "www", "https://www.deepcoin.com/" },
                { "doc", "https://www.deepcoin.com/docs" },
                { "referral", new Dictionary<string, object>() {
                    { "url", "https://s.deepcoin.com/UzkyODgy" },
                    { "discount", 0.1 },
                } },
            } },
            { "api", new Dictionary<string, object>() {
                { "public", new Dictionary<string, object>() {
                    { "get", new Dictionary<string, object>() {
                        { "deepcoin/market/books", 1 },
                        { "deepcoin/market/candles", 1 },
                        { "deepcoin/market/instruments", 1 },
                        { "deepcoin/market/tickers", 1 },
                        { "deepcoin/market/index-candles", 1 },
                        { "deepcoin/market/trades", 1 },
                        { "deepcoin/market/mark-price-candles", 1 },
                        { "deepcoin/market/step-margin", 5 },
                        { "deepcoin/trade/funding-rate", 5 },
                        { "deepcoin/trade/fund-rate/current-funding-rate", 5 },
                        { "deepcoin/trade/fund-rate/history", 5 },
                    } },
                } },
                { "private", new Dictionary<string, object>() {
                    { "get", new Dictionary<string, object>() {
                        { "deepcoin/account/balances", 5 },
                        { "deepcoin/account/bills", 5 },
                        { "deepcoin/account/positions", 5 },
                        { "deepcoin/trade/fills", 5 },
                        { "deepcoin/trade/orderByID", 5 },
                        { "deepcoin/trade/finishOrderByID", 5 },
                        { "deepcoin/trade/orders-history", 5 },
                        { "deepcoin/trade/v2/orders-pending", 5 },
                        { "deepcoin/trade/trigger-orders-pending", 5 },
                        { "deepcoin/trade/trigger-orders-history", 5 },
                        { "deepcoin/copytrading/support-contracts", 5 },
                        { "deepcoin/copytrading/leader-position", 5 },
                        { "deepcoin/copytrading/estimate-profit", 5 },
                        { "deepcoin/copytrading/history-profit", 5 },
                        { "deepcoin/copytrading/follower-rank", 5 },
                        { "deepcoin/internal-transfer/support", 5 },
                        { "deepcoin/internal-transfer/history-order", 5 },
                        { "deepcoin/rebate/config", 5 },
                        { "deepcoin/agents/users", 5 },
                        { "deepcoin/agents/users/rebate-list", 5 },
                        { "deepcoin/agents/users/rebates", 5 },
                        { "deepcoin/asset/deposit-list", 5 },
                        { "deepcoin/asset/withdraw-list", 5 },
                        { "deepcoin/asset/recharge-chain-list", 5 },
                        { "deepcoin/listenkey/acquire", 5 },
                        { "deepcoin/listenkey/extend", 5 },
                    } },
                    { "post", new Dictionary<string, object>() {
                        { "deepcoin/account/set-leverage", 5 },
                        { "deepcoin/trade/order", 5 },
                        { "deepcoin/trade/replace-order", 5 },
                        { "deepcoin/trade/cancel-order", 5 },
                        { "deepcoin/trade/batch-cancel-order", 5 },
                        { "deepcoin/trade/cancel-trigger-order", divide(1, 6) },
                        { "deepcoin/trade/swap/cancel-all", 5 },
                        { "deepcoin/trade/trigger-order", 5 },
                        { "deepcoin/trade/batch-close-position", 5 },
                        { "deepcoin/trade/replace-order-sltp", 5 },
                        { "deepcoin/trade/close-position-by-ids", 5 },
                        { "deepcoin/copytrading/leader-settings", 5 },
                        { "deepcoin/copytrading/set-contracts", 5 },
                        { "deepcoin/internal-transfer", 5 },
                        { "deepcoin/rebate/config", 5 },
                        { "deepcoin/asset/transfer", 5 },
                    } },
                } },
            } },
            { "fees", new Dictionary<string, object>() {
                { "trading", new Dictionary<string, object>() {
                    { "taker", this.parseNumber("0.0015") },
                    { "maker", this.parseNumber("0.0010") },
                } },
            } },
            { "features", new Dictionary<string, object>() {
                { "spot", new Dictionary<string, object>() {
                    { "sandbox", false },
                    { "createOrder", new Dictionary<string, object>() {
                        { "marginMode", true },
                        { "triggerPrice", true },
                        { "triggerPriceType", new Dictionary<string, object>() {
                            { "last", true },
                            { "mark", false },
                            { "index", false },
                        } },
                        { "triggerDirection", false },
                        { "stopLossPrice", true },
                        { "takeProfitPrice", true },
                        { "attachedStopLossTakeProfit", new Dictionary<string, object>() {
                            { "triggerPriceType", new Dictionary<string, object>() {
                                { "last", false },
                                { "mark", false },
                                { "index", false },
                            } },
                            { "price", true },
                        } },
                        { "timeInForce", new Dictionary<string, object>() {
                            { "IOC", true },
                            { "FOK", true },
                            { "PO", true },
                            { "GTD", false },
                        } },
                        { "hedged", true },
                        { "trailing", false },
                        { "marketBuyRequiresPrice", false },
                    } },
                    { "createOrders", null },
                    { "fetchMyTrades", new Dictionary<string, object>() {
                        { "marginMode", false },
                        { "limit", 100 },
                        { "daysBack", 60 },
                        { "untilDays", null },
                        { "symbolRequired", true },
                    } },
                    { "fetchOrder", null },
                    { "fetchOpenOrders", new Dictionary<string, object>() {
                        { "marginMode", false },
                        { "limit", 100 },
                        { "trigger", true },
                        { "trailing", false },
                        { "symbolRequired", true },
                    } },
                    { "fetchOrders", null },
                    { "fetchClosedOrders", new Dictionary<string, object>() {
                        { "marginMode", false },
                        { "limit", 100 },
                        { "daysBack", null },
                        { "daysBackCanceled", null },
                        { "untilDays", null },
                        { "trigger", true },
                        { "trailing", false },
                        { "symbolRequired", true },
                    } },
                    { "fetchOHLCV", new Dictionary<string, object>() {
                        { "limit", 300 },
                    } },
                } },
                { "swap", new Dictionary<string, object>() {
                    { "linear", new Dictionary<string, object>() {
                        { "extends", "spot" },
                    } },
                    { "inverse", new Dictionary<string, object>() {
                        { "extends", "spot" },
                    } },
                } },
            } },
            { "requiredCredentials", new Dictionary<string, object>() {
                { "apiKey", true },
                { "secret", true },
                { "password", true },
            } },
            { "precisionMode", TICK_SIZE },
            { "options", new Dictionary<string, object>() {
                { "recvWindow", 5000 },
                { "defaultNetworks", new Dictionary<string, object>() {
                    { "ETH", "ERC20" },
                    { "USDT", "TRC20" },
                    { "USDC", "ERC20" },
                } },
                { "networks", new Dictionary<string, object>() {
                    { "ERC20", "ERC20" },
                    { "TRC20", "TRC20" },
                    { "ARB", "ARBITRUM" },
                    { "BSC", "BSC(BEP20)" },
                    { "SOL", "SOL" },
                    { "BTC", "Bitcoin" },
                    { "ADA", "Cardano" },
                } },
                { "networksById", new Dictionary<string, object>() {} },
                { "fetchMarkets", new Dictionary<string, object>() {
                    { "types", new List<object>() {"spot", "swap"} },
                } },
                { "timeInForce", new Dictionary<string, object>() {
                    { "GTC", "GTC" },
                    { "IOC", "IOC" },
                    { "PO", "PO" },
                } },
                { "exchangeType", new Dictionary<string, object>() {
                    { "spot", "SPOT" },
                    { "swap", "SWAP" },
                    { "SPOT", "SPOT" },
                    { "SWAP", "SWAP" },
                } },
                { "accountsByType", new Dictionary<string, object>() {
                    { "spot", 1 },
                    { "fund", 2 },
                    { "rebate", 3 },
                    { "inverse", 5 },
                    { "linear", 7 },
                    { "demo", 10 },
                } },
            } },
            { "commonCurrencies", new Dictionary<string, object>() {} },
            { "exceptions", new Dictionary<string, object>() {
                { "exact", new Dictionary<string, object>() {
                    { "24", typeof(OrderNotFound) },
                    { "31", typeof(InsufficientFunds) },
                    { "36", typeof(InsufficientFunds) },
                    { "44", typeof(BadRequest) },
                    { "49", typeof(InvalidOrder) },
                    { "194", typeof(InvalidOrder) },
                    { "195", typeof(InvalidOrder) },
                    { "199", typeof(BadRequest) },
                    { "100010", typeof(InsufficientFunds) },
                    { "unsupportedAction", typeof(BadRequest) },
                    { "localIDNotExist", typeof(BadRequest) },
                } },
                { "broad", new Dictionary<string, object>() {
                    { "no available", typeof(NotSupported) },
                    { "field is required", typeof(ArgumentsRequired) },
                    { "not in acceptable range", typeof(BadRequest) },
                    { "subscription cluster does not \"exist\"", typeof(BadRequest) },
                    { "must be equal or lesser than", typeof(BadRequest) },
                } },
            } },
        });
    }

    public override object handleMarketTypeAndParams(object methodName, object market = null, object parameters = null, object defaultValue = null)
    {
        parameters ??= new Dictionary<string, object>();
        object instType = this.safeString(parameters, "instType");
        parameters = this.omit(parameters, "instType");
        object type = this.safeString(parameters, "type");
        if (isTrue(isTrue((isEqual(type, null))) && isTrue((!isEqual(instType, null)))))
        {
            parameters = this.extend(parameters, new Dictionary<string, object>() {
                { "type", instType },
            });
        }
        return base.handleMarketTypeAndParams(methodName, market, parameters, defaultValue);
    }

    public virtual object convertToInstrumentType(object type)
    {
        object exchangeTypes = this.safeDict(this.options, "exchangeType", new Dictionary<string, object>() {});
        return this.safeString(exchangeTypes, type, type);
    }

    /**
     * @method
     * @name deepcoin#fetchMarkets
     * @see https://www.deepcoin.com/docs/DeepCoinMarket/getBaseInfo
     * @description retrieves data on all markets for okcoin
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} an array of objects representing market data
     */
    public async override Task<object> fetchMarkets(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object types = new List<object>() {"spot", "swap"};
        object fetchMarketsOption = this.safeDict(this.options, "fetchMarkets");
        if (isTrue(!isEqual(fetchMarketsOption, null)))
        {
            types = this.safeList(fetchMarketsOption, "types", types);
        } else
        {
            types = this.safeList(this.options, "fetchMarkets", types); // backward-support
        }
        object promises = new List<object>() {};
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(types)); postFixIncrement(ref i))
        {
            ((IList<object>)promises).Add(this.fetchMarketsByType(getValue(types, i), parameters));
        }
        promises = await promiseAll(promises);
        for (object i = 0; isLessThan(i, getArrayLength(promises)); postFixIncrement(ref i))
        {
            result = this.arrayConcat(result, getValue(promises, i));
        }
        return result;
    }

    public async virtual Task<object> fetchMarketsByType(object type, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object request = new Dictionary<string, object>() {
            { "instType", this.convertToInstrumentType(type) },
        };
        object response = await this.publicGetDeepcoinMarketInstruments(this.extend(request, parameters));
        //
        // spot
        //
        //     {
        //         "code": "0",
        //         "msg": "",
        //         "data": [
        //             {
        //                 "instType": "SPOT",
        //                 "instId": "A-USDT",
        //                 "uly": "",
        //                 "baseCcy": "A",
        //                 "quoteCcy": "USDT",
        //                 "ctVal": "1",
        //                 "ctValCcy": "",
        //                 "listTime": "0",
        //                 "lever": "1",
        //                 "tickSz": "0.0001",
        //                 "lotSz": "0.001",
        //                 "minSz": "0.5",
        //                 "ctType": "",
        //                 "alias": "",
        //                 "state": "live",
        //                 "maxLmtSz": "7692307",
        //                 "maxMktSz": "7692307"
        //             }
        //         ]
        //     }
        //
        object dataResponse = this.safeList(response, "data", new List<object>() {});
        return this.parseMarkets(dataResponse);
    }

    public override object parseMarket(object market)
    {
        //
        // spot markets
        //
        //     {
        //         "instType": "SPOT",
        //         "instId": "A-USDT",
        //         "uly": "",
        //         "baseCcy": "A",
        //         "quoteCcy": "USDT",
        //         "ctVal": "1",
        //         "ctValCcy": "",
        //         "listTime": "0",
        //         "lever": "1",
        //         "tickSz": "0.0001",
        //         "lotSz": "0.001",
        //         "minSz": "0.5",
        //         "ctType": "",
        //         "alias": "",
        //         "state": "live",
        //         "maxLmtSz": "7692307",
        //         "maxMktSz": "7692307"
        //     }
        //
        // swap markets
        //
        //     {
        //         "instType": "SWAP",
        //         "instId": "ZORA-USDT-SWAP",
        //         "uly": "",
        //         "baseCcy": "ZORA",
        //         "quoteCcy": "USDT",
        //         "ctVal": "1",
        //         "ctValCcy": "",
        //         "listTime": "0",
        //         "lever": "20",
        //         "tickSz": "0.00001",
        //         "lotSz": "1",
        //         "minSz": "1685",
        //         "ctType": "",
        //         "alias": "",
        //         "state": "live",
        //         "maxLmtSz": "10000000",
        //         "maxMktSz": "10000000"
        //     }
        //
        object id = this.safeString(market, "instId");
        object type = this.safeStringLower(market, "instType");
        object spot = (isEqual(type, "spot"));
        object swap = (isEqual(type, "swap"));
        object baseId = this.safeString(market, "baseCcy");
        object quoteId = this.safeString(market, "quoteCcy", "");
        object settleId = null;
        object settle = null;
        object bs = this.safeCurrencyCode(baseId);
        object quote = this.safeCurrencyCode(quoteId);
        object symbol = add(add(bs, "/"), quote);
        object isLinear = null;
        if (isTrue(swap))
        {
            isLinear = (!isEqual(quoteId, "USD"));
            settleId = ((bool) isTrue(isLinear)) ? quoteId : baseId;
            settle = this.safeCurrencyCode(settleId);
            symbol = add(add(symbol, ":"), settle);
        }
        object fees = this.safeDict2(this.fees, type, "trading", new Dictionary<string, object>() {});
        object maxLeverage = this.safeString(market, "lever", "1");
        maxLeverage = Precise.stringMax(maxLeverage, "1");
        object maxMarketSize = this.safeString(market, "maxMktSz");
        object maxLimitSize = this.safeString(market, "maxLmtSz");
        object maxAmount = this.parseNumber(Precise.stringMax(maxMarketSize, maxLimitSize));
        object state = this.safeString(market, "state");
        return this.extend(fees, new Dictionary<string, object>() {
            { "id", id },
            { "symbol", symbol },
            { "base", bs },
            { "quote", quote },
            { "settle", settle },
            { "baseId", baseId },
            { "quoteId", quoteId },
            { "settleId", settleId },
            { "type", type },
            { "spot", spot },
            { "margin", isTrue(spot) && isTrue((Precise.stringGt(maxLeverage, "1"))) },
            { "swap", swap },
            { "future", false },
            { "option", false },
            { "active", isEqual(state, "live") },
            { "contract", swap },
            { "linear", isLinear },
            { "inverse", ((bool) isTrue(swap)) ? (!isTrue(isLinear)) : null },
            { "contractSize", ((bool) isTrue(swap)) ? this.safeNumber(market, "ctVal") : null },
            { "expiry", null },
            { "expiryDatetime", null },
            { "strike", null },
            { "optionType", null },
            { "created", null },
            { "precision", new Dictionary<string, object>() {
                { "amount", this.safeNumber(market, "lotSz") },
                { "price", this.safeNumber(market, "tickSz") },
            } },
            { "limits", new Dictionary<string, object>() {
                { "leverage", new Dictionary<string, object>() {
                    { "min", this.parseNumber("1") },
                    { "max", this.parseNumber(maxLeverage) },
                } },
                { "amount", new Dictionary<string, object>() {
                    { "min", this.safeNumber(market, "minSz") },
                    { "max", maxAmount },
                } },
                { "price", new Dictionary<string, object>() {
                    { "min", null },
                    { "max", null },
                } },
                { "cost", new Dictionary<string, object>() {
                    { "min", null },
                    { "max", null },
                } },
            } },
            { "info", market },
        });
    }

    public override object setMarkets(object markets, object currencies = null)
    {
        markets = base.setMarkets(markets, currencies);
        object symbols = new List<object>(((IDictionary<string,object>)markets).Keys);
        for (object i = 0; isLessThan(i, getArrayLength(symbols)); postFixIncrement(ref i))
        {
            object symbol = getValue(symbols, i);
            object market = getValue(markets, symbol);
            if (isTrue(getValue(market, "swap")))
            {
                object additionalId = add(getValue(market, "baseId"), getValue(market, "quoteId"));
                ((IDictionary<string,object>)this.markets_by_id)[(string)additionalId] = new List<object>() {market}; // some endpoints return swap market id as base+quote
            }
        }
        return this.markets;
    }

    /**
     * @method
     * @name deepcoin#fetchOrderBook
     * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
     * @see https://www.deepcoin.com/docs/DeepCoinMarket/marketBooks
     * @param {string} symbol unified symbol of the market to fetch the order book for
     * @param {int} [limit] the maximum amount of order book entries to return
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/?id=order-book-structure} indexed by market symbols
     */
    public async override Task<object> fetchOrderBook(object symbol, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        if (isTrue(isEqual(limit, null)))
        {
            limit = 400;
        }
        object request = new Dictionary<string, object>() {
            { "instId", getValue(market, "id") },
            { "sz", limit },
        };
        object response = await this.publicGetDeepcoinMarketBooks(this.extend(request, parameters));
        //
        //     {
        //         "code": "0",
        //         "msg": "",
        //         "data": {
        //             "bids": [
        //                 ["3732.21", "99.6"],
        //                 ["3732.2", "54.7"]
        //             ],
        //             "asks": [
        //                 ["3732.22", "85.1"],
        //                 ["3732.23", "49.4"]
        //             ]
        //         }
        //     }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        return this.parseOrderBook(data, symbol, null, "bids", "asks", 0, 1);
    }

    /**
     * @method
     * @name deepcoin#fetchOHLCV
     * @description fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
     * @see https://www.deepcoin.com/docs/DeepCoinMarket/getKlineData
     * @see https://www.deepcoin.com/docs/DeepCoinMarket/getIndexKlineData
     * @see https://www.deepcoin.com/docs/DeepCoinMarket/getMarkKlineData
     * @param {string} symbol unified symbol of the market to fetch OHLCV data for
     * @param {string} timeframe the length of time each candle represents
     * @param {int} [since] timestamp in ms of the earliest candle to fetch
     * @param {int} [limit] the maximum amount of candles to fetch
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {int} [params.until] timestamp in ms of the latest candle to fetch
     * @param {string} [params.price] "mark" or "index" for mark price and index price candles
     * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [available parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
     * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
     */
    public async override Task<object> fetchOHLCV(object symbol, object timeframe = null, object since = null, object limit = null, object parameters = null)
    {
        timeframe ??= "1m";
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object maxLimit = 300;
        object paginate = false;
        var paginateparametersVariable = this.handleOptionAndParams(parameters, "fetchOHLCV", "paginate", false);
        paginate = ((IList<object>)paginateparametersVariable)[0];
        parameters = ((IList<object>)paginateparametersVariable)[1];
        if (isTrue(paginate))
        {
            parameters = this.extend(parameters, new Dictionary<string, object>() {
                { "calculateUntil", true },
            });
            return await this.fetchPaginatedCallDeterministic("fetchOHLCV", symbol, since, limit, timeframe, parameters, maxLimit);
        }
        object market = this.market(symbol);
        object price = this.safeString(parameters, "price");
        parameters = this.omit(parameters, "price");
        object bar = this.safeString(this.timeframes, timeframe, timeframe);
        object request = new Dictionary<string, object>() {
            { "instId", getValue(market, "id") },
            { "bar", bar },
        };
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        object until = this.safeInteger(parameters, "until");
        if (isTrue(!isEqual(until, null)))
        {
            ((IDictionary<string,object>)request)["after"] = until;
            parameters = this.omit(parameters, "until");
        }
        object calculateUntil = this.safeBool(parameters, "calculateUntil", false);
        if (isTrue(calculateUntil))
        {
            parameters = this.omit(parameters, "calculateUntil");
            if (isTrue(!isEqual(since, null)))
            {
                // the exchange do not have a since param for this endpoint
                // we canlculate until (after) for correct pagination
                object duration = this.parseTimeframe(timeframe);
                object numberOfCandles = ((bool) isTrue((isEqual(limit, null)))) ? maxLimit : limit;
                object endTime = add(since, multiply((multiply(duration, numberOfCandles)), 1000));
                if (isTrue(!isEqual(until, null)))
                {
                    endTime = mathMin(endTime, until);
                }
                object now = this.milliseconds();
                ((IDictionary<string,object>)request)["after"] = mathMin(endTime, now);
            }
        }
        object response = null;
        if (isTrue(isEqual(price, "mark")))
        {
            response = await this.publicGetDeepcoinMarketMarkPriceCandles(this.extend(request, parameters));
        } else if (isTrue(isEqual(price, "index")))
        {
            response = await this.publicGetDeepcoinMarketIndexCandles(this.extend(request, parameters));
        } else
        {
            response = await this.publicGetDeepcoinMarketCandles(this.extend(request, parameters));
        }
        //
        //     {
        //         "code": "0",
        //         "msg": "",
        //         "data":[
        //             [
        //                 "1760221800000",
        //                 "3739.08",
        //                 "3741.95",
        //                 "3737.75",
        //                 "3740.1",
        //                 "2849",
        //                 "1065583.744"
        //             ],
        //             [
        //                 "1760221740000",
        //                 "3742.36",
        //                 "3743.01",
        //                 "3736.83",
        //                 "3739.08",
        //                 "2723",
        //                 "1018290.723"
        //             ]
        //         ]
        //     }
        //
        object data = this.safeList(response, "data", new List<object>() {});
        return this.parseOHLCVs(data, market, timeframe, since, limit);
    }

    /**
     * @method
     * @name deepcoin#fetchTickers
     * @description fetches price tickers for multiple markets, statistical information calculated over the past 24 hours for each market
     * @see https://www.deepcoin.com/docs/DeepCoinMarket/getMarketTickers
     * @param {string[]} [symbols] unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/?id=ticker-structure}
     */
    public async override Task<object> fetchTickers(object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        symbols = this.marketSymbols(symbols);
        object market = this.getMarketFromSymbols(symbols);
        object marketType = null;
        var marketTypeparametersVariable = this.handleMarketTypeAndParams("fetchTickers", market, parameters);
        marketType = ((IList<object>)marketTypeparametersVariable)[0];
        parameters = ((IList<object>)marketTypeparametersVariable)[1];
        object request = new Dictionary<string, object>() {
            { "instType", this.convertToInstrumentType(marketType) },
        };
        object response = await this.publicGetDeepcoinMarketTickers(this.extend(request, parameters));
        object tickers = this.safeList(response, "data", new List<object>() {});
        return this.parseTickers(tickers, symbols);
    }

    public override object parseTicker(object ticker, object market = null)
    {
        //
        //     {
        //         "instType": "SWAP",
        //         "instId": "BTC-USD-SWAP",
        //         "last": "114113.3",
        //         "lastSz": "",
        //         "askPx": "114113.5",
        //         "askSz": "56280",
        //         "bidPx": "114113.2",
        //         "bidSz": "63220",
        //         "open24h": "113214.7",
        //         "high24h": "116039.2",
        //         "low24h": "113214.7",
        //         "volCcy24h": "73.31475724",
        //         "vol24h": "8406739",
        //         "sodUtc0": "",
        //         "sodUtc8": "",
        //         "ts": "1760367816000"
        //     }
        //
        object timestamp = this.safeInteger(ticker, "ts");
        object marketId = this.safeString(ticker, "instId");
        market = this.safeMarket(marketId, market, "-");
        object symbol = getValue(market, "symbol");
        object last = this.safeString(ticker, "last");
        object open = this.safeString(ticker, "open24h");
        object quoteVolume = this.safeString(ticker, "volCcy24h");
        object baseVolume = this.safeString(ticker, "vol24h");
        if (isTrue(isTrue(getValue(market, "swap")) && isTrue(getValue(market, "inverse"))))
        {
            object temp = baseVolume;
            baseVolume = quoteVolume;
            quoteVolume = temp;
        }
        object high = this.safeString(ticker, "high24h");
        object low = this.safeString(ticker, "low24h");
        return this.safeTicker(new Dictionary<string, object>() {
            { "symbol", symbol },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "high", high },
            { "low", low },
            { "bid", this.safeString(ticker, "bidPx") },
            { "bidVolume", this.safeString(ticker, "bidSz") },
            { "ask", this.safeString(ticker, "askPx") },
            { "askVolume", this.safeString(ticker, "askSz") },
            { "vwap", null },
            { "open", open },
            { "close", last },
            { "last", last },
            { "previousClose", null },
            { "change", null },
            { "percentage", null },
            { "average", null },
            { "baseVolume", baseVolume },
            { "quoteVolume", quoteVolume },
            { "markPrice", null },
            { "indexPrice", null },
            { "info", ticker },
        }, market);
    }

    /**
     * @method
     * @name deepcoin#fetchTrades
     * @description get the list of most recent trades for a particular symbol
     * @see https://www.deepcoin.com/docs/DeepCoinMarket/getTrades
     * @param {string} symbol unified symbol of the market to fetch trades for
     * @param {int} [since] timestamp in ms of the earliest trade to fetch
     * @param {int} [limit] the maximum amount of trades to fetch (default 100, max 500)
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/?id=public-trades}
     */
    public async override Task<object> fetchTrades(object symbol, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "instId", getValue(market, "id") },
        };
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit; // default 100, max 500
        }
        object productGroup = this.getProductGroupFromMarket(market);
        ((IDictionary<string,object>)request)["productGroup"] = productGroup;
        object response = await this.publicGetDeepcoinMarketTrades(this.extend(request, parameters));
        object data = this.safeList(response, "data", new List<object>() {});
        return this.parseTrades(data, market, since, limit);
    }

    public virtual object getProductGroupFromMarket(object market)
    {
        object productGroup = "Spot";
        if (isTrue(getValue(market, "swap")))
        {
            if (isTrue(getValue(market, "linear")))
            {
                productGroup = "SwapU";
            } else
            {
                productGroup = "Swap";
            }
        }
        return productGroup;
    }

    public override object parseTrade(object trade, object market = null)
    {
        //
        // public fetchTrades
        //
        //     {
        //         "instId": "ETH-USDT",
        //         "tradeId": "1001056388761321",
        //         "px": "4095.66",
        //         "sz": "0.01311251",
        //         "side": "sell",
        //         "ts": "1760367870000"
        //     }
        //
        // private fetchMyTrades
        //     {
        //         "instType": "SPOT",
        //         "instId": "ETH-USDT",
        //         "tradeId": "1001056429613610",
        //         "ordId": "1001435238208686",
        //         "clOrdId": "",
        //         "billId": "10010564296136101",
        //         "tag": "",
        //         "fillPx": "3791.15",
        //         "fillSz": "0.004",
        //         "side": "sell",
        //         "posSide": "",
        //         "execType": "",
        //         "feeCcy": "USDT",
        //         "fee": "0.0151646",
        //         "ts": "1760704540000"
        //     }
        //
        object marketId = this.safeString(trade, "instId");
        market = this.safeMarket(marketId, market);
        object timestamp = this.safeInteger(trade, "ts");
        object side = this.safeString(trade, "side");
        object execType = this.safeString(trade, "execType");
        object fee = null;
        object feeCost = this.safeString(trade, "fee");
        if (isTrue(!isEqual(feeCost, null)))
        {
            object feeCurrencyId = this.safeString(trade, "feeCcy");
            object feeCurrencyCode = this.safeCurrencyCode(feeCurrencyId);
            fee = new Dictionary<string, object>() {
                { "cost", feeCost },
                { "currency", feeCurrencyCode },
            };
        }
        return this.safeTrade(new Dictionary<string, object>() {
            { "info", trade },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "symbol", getValue(market, "symbol") },
            { "id", this.safeString(trade, "tradeId") },
            { "order", this.safeString(trade, "ordId") },
            { "type", null },
            { "takerOrMaker", this.parseTakerOrMaker(execType) },
            { "side", side },
            { "price", this.safeString2(trade, "fillPx", "px") },
            { "amount", this.safeString2(trade, "fillSz", "sz") },
            { "cost", null },
            { "fee", fee },
        }, market);
    }

    public virtual object parseTakerOrMaker(object execType)
    {
        object types = new Dictionary<string, object>() {
            { "T", "taker" },
            { "M", "maker" },
        };
        return this.safeString(types, execType, execType);
    }

    /**
     * @method
     * @name deepcoin#fetchBalance
     * @description query for balance and get the amount of funds available for trading or funds locked in orders
     * @see https://www.deepcoin.com/docs/DeepCoinAccount/getAccountBalance
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.type] "spot" or "swap", the market type for the balance
     * @returns {object} a [balance structure]{@link https://docs.ccxt.com/?id=balance-structure}
     */
    public async override Task<object> fetchBalance(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object marketType = "spot";
        var marketTypeparametersVariable = this.handleMarketTypeAndParams("fetchBalance", null, parameters, marketType);
        marketType = ((IList<object>)marketTypeparametersVariable)[0];
        parameters = ((IList<object>)marketTypeparametersVariable)[1];
        object request = new Dictionary<string, object>() {
            { "instType", this.convertToInstrumentType(marketType) },
        };
        object response = await this.privateGetDeepcoinAccountBalances(this.extend(request, parameters));
        return this.parseBalance(response);
    }

    public override object parseBalance(object response)
    {
        //
        //     {
        //         "code": "0",
        //         "msg": "",
        //         "data": [
        //             {
        //                 "ccy": "USDT",
        //                 "bal": "74",
        //                 "frozenBal": "0",
        //                 "availBal": "74"
        //             }
        //         ]
        //     }
        //
        object result = new Dictionary<string, object>() {
            { "info", response },
            { "timestamp", null },
            { "datetime", null },
        };
        object balances = this.safeList(response, "data", new List<object>() {});
        for (object i = 0; isLessThan(i, getArrayLength(balances)); postFixIncrement(ref i))
        {
            object balance = getValue(balances, i);
            object symbol = this.safeString(balance, "ccy");
            object code = this.safeCurrencyCode(symbol);
            object account = this.account();
            ((IDictionary<string,object>)account)["total"] = this.safeString(balance, "bal");
            ((IDictionary<string,object>)account)["used"] = this.safeString(balance, "frozenBal");
            ((IDictionary<string,object>)account)["free"] = this.safeString(balance, "availBal");
            ((IDictionary<string,object>)result)[(string)code] = account;
        }
        return this.safeBalance(result);
    }

    /**
     * @method
     * @name deepcoin#fetchDeposits
     * @description fetch all deposits made to an account
     * @see https://www.deepcoin.com/docs/assets/deposit
     * @param {string} code unified currency code
     * @param {int} [since] the earliest time in ms to fetch deposits for
     * @param {int} [limit] the maximum number of deposits structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {int} [params.until] the latest time in ms to fetch entries for
     * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [available parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
     * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/?id=transaction-structure}
     */
    public async override Task<object> fetchDeposits(object code = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object paginate = false;
        var paginateparametersVariable = this.handleOptionAndParams(parameters, "fetchDeposits", "paginate", false);
        paginate = ((IList<object>)paginateparametersVariable)[0];
        parameters = ((IList<object>)paginateparametersVariable)[1];
        if (isTrue(paginate))
        {
            return await this.fetchPaginatedCallCursor("fetchDeposits", code, since, limit, parameters, "code", null, 1, 50);
        }
        object request = new Dictionary<string, object>() {};
        object currency = null;
        if (isTrue(!isEqual(code, null)))
        {
            currency = this.currency(code);
            ((IDictionary<string,object>)request)["coin"] = getValue(currency, "id");
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["startTime"] = since;
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["size"] = limit;
        }
        object until = this.safeInteger(parameters, "until");
        if (isTrue(!isEqual(until, null)))
        {
            ((IDictionary<string,object>)request)["endTime"] = until;
            parameters = this.omit(parameters, "until");
        }
        object response = await this.privateGetDeepcoinAssetDepositList(this.extend(request, parameters));
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        object items = this.safeList(data, "data", new List<object>() {});
        object transactionParams = new Dictionary<string, object>() {
            { "type", "deposit" },
        };
        return this.parseTransactions(items, currency, since, limit, transactionParams);
    }

    /**
     * @method
     * @name deepcoin#fetchWithdrawals
     * @description fetch all withdrawals made from an account
     * @see https://www.deepcoin.com/docs/assets/withdraw
     * @param {string} code unified currency code of the currency transferred
     * @param {int} [since] the earliest time in ms to fetch transfers for (default 24 hours ago)
     * @param {int} [limit] the maximum number of transfer structures to retrieve (default 50, max 200)
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {int} [params.until] the latest time in ms to fetch transfers for (default time now)
     * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [available parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
     * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/?id=transaction-structure}
     */
    public async override Task<object> fetchWithdrawals(object code = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object paginate = false;
        var paginateparametersVariable = this.handleOptionAndParams(parameters, "fetchDeposits", "paginate", false);
        paginate = ((IList<object>)paginateparametersVariable)[0];
        parameters = ((IList<object>)paginateparametersVariable)[1];
        if (isTrue(paginate))
        {
            return await this.fetchPaginatedCallCursor("fetchDeposits", code, since, limit, parameters, "code", null, 1, 50);
        }
        object request = new Dictionary<string, object>() {};
        object currency = null;
        if (isTrue(!isEqual(code, null)))
        {
            currency = this.currency(code);
            ((IDictionary<string,object>)request)["coin"] = getValue(currency, "id");
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["startTime"] = since;
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["size"] = limit;
        }
        object until = this.safeInteger(parameters, "until");
        if (isTrue(!isEqual(until, null)))
        {
            ((IDictionary<string,object>)request)["endTime"] = until;
            parameters = this.omit(parameters, "until");
        }
        object response = await this.privateGetDeepcoinAssetWithdrawList(this.extend(request, parameters));
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        object items = this.safeList(data, "data", new List<object>() {});
        object transactionParams = new Dictionary<string, object>() {
            { "type", "withdrawal" },
        };
        return this.parseTransactions(items, currency, since, limit, transactionParams);
    }

    public override object parseTransaction(object transaction, object currency = null)
    {
        //
        // fetchDeposits
        //     {
        //         "createTime": 1760368656,
        //         "txHash": "03fe3244d89e794586222413c61779380da9e9fe5baaa253c38d01a4199a3499",
        //         "chainName": "TRC20",
        //         "amount": "149",
        //         "coin": "USDT",
        //         "status": "succeed"
        //     }
        //
        object txid = this.safeString(transaction, "txHash");
        object currencyId = this.safeString(transaction, "coin");
        object code = this.safeCurrencyCode(currencyId, currency);
        object amount = this.safeNumber(transaction, "amount");
        object timestamp = this.safeTimestamp(transaction, "createTime");
        object networkId = this.safeString(transaction, "chainName");
        object network = this.networkIdToCode(networkId);
        object status = this.parseTransactionStatus(this.safeString(transaction, "status"));
        return new Dictionary<string, object>() {
            { "info", transaction },
            { "id", null },
            { "currency", code },
            { "amount", amount },
            { "network", network },
            { "addressFrom", null },
            { "addressTo", null },
            { "address", this.safeString(transaction, "address") },
            { "tagFrom", null },
            { "tagTo", null },
            { "tag", null },
            { "status", status },
            { "type", null },
            { "updated", null },
            { "txid", txid },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "internal", null },
            { "comment", null },
            { "fee", new Dictionary<string, object>() {
                { "currency", null },
                { "cost", null },
            } },
        };
    }

    public virtual object parseTransactionStatus(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "confirming", "pending" },
            { "succeed", "ok" },
        };
        return this.safeString(statuses, status, status);
    }

    /**
     * @method
     * @name deepcoin#fetchDepositAddresses
     * @description fetch deposit addresses for multiple currencies and chain types
     * @see https://www.deepcoin.com/docs/assets/chainlist
     * @param {string[]|undefined} codes list of unified currency codes, default is undefined
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a list of [address structures]{@link https://docs.ccxt.com/?id=address-structure}
     */
    public async override Task<object> fetchDepositAddresses(object codes = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        if (isTrue(isEqual(codes, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchDepositAddresses requires a list with one currency code")) ;
        }
        object length = getArrayLength(codes);
        if (isTrue(!isEqual(length, 1)))
        {
            throw new NotSupported ((string)add(this.id, " fetchDepositAddresses requires a list with one currency code")) ;
        }
        object code = getValue(codes, 0);
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "currency_id", getValue(currency, "id") },
            { "lang", "en" },
        };
        object response = await this.privateGetDeepcoinAssetRechargeChainList(this.extend(request, parameters));
        //
        //     {
        //         "code": "0",
        //         "msg": "",
        //         "data": {
        //             "list": [
        //                 {
        //                     "chain": "TRC20",
        //                     "state": 1,
        //                     "remind": "Only support deposits and withdrawals via TRC20 network. If you send it via other address by mistake, it will not be credited and will result in the permanent loss of your deposit.",
        //                     "inNotice": "",
        //                     "actLogo": "",
        //                     "address": "TNJYDW9Bk87VwfA6s7FtxURLEMHesQbYgF",
        //                     "hasMemo": false,
        //                     "memo": "",
        //                     "estimatedTime": 1,
        //                     "fastConfig": {
        //                         "fastLimitNum": 0,
        //                         "fastBlock": 10,
        //                         "realBlock": 1
        //                     }
        //                 }
        //             ]
        //         }
        //     }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        object list = this.safeList(data, "list", new List<object>() {});
        object additionalParams = new Dictionary<string, object>() {
            { "currency", code },
        };
        return this.parseDepositAddresses(list, codes, false, additionalParams);
    }

    /**
     * @method
     * @name deepcoin#fetchDepositAddress
     * @description fetch the deposit address for a currency associated with this account
     * @see https://www.deepcoin.com/docs/assets/chainlist
     * @param {string} code unified currency code
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.network] unified network code for deposit chain
     * @returns {object} an [address structure]{@link https://docs.ccxt.com/?id=address-structure}
     */
    public async override Task<object> fetchDepositAddress(object code, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object network = this.safeString(parameters, "network");
        object defaultNetworks = this.safeDict(this.options, "defaultNetworks", new Dictionary<string, object>() {});
        object defaultNetwork = this.safeString(defaultNetworks, code);
        network = ((bool) isTrue(network)) ? network : defaultNetwork;
        if (isTrue(!isEqual(network, null)))
        {
            parameters = this.omit(parameters, "network");
        }
        object addressess = await this.fetchDepositAddresses(new List<object>() {code}, parameters);
        object length = getArrayLength(addressess);
        object address = this.safeDict(addressess, 0, new Dictionary<string, object>() {});
        if (isTrue(isTrue((!isEqual(network, null))) && isTrue((isGreaterThan(length, 1)))))
        {
            for (object i = 0; isLessThan(i, length); postFixIncrement(ref i))
            {
                object entry = getValue(addressess, i);
                if (isTrue(isEqual(getValue(entry, "network"), network)))
                {
                    address = entry;
                }
            }
        }
        return address;
    }

    public override object parseDepositAddress(object response, object currency = null)
    {
        //
        //     {
        //         "chain": "TRC20",
        //         "state": 1,
        //         "remind": "Only support deposits and withdrawals via TRC20 network. If you send it via other address by mistake, it will not be credited and will result in the permanent loss of your deposit.",
        //         "inNotice": "",
        //         "actLogo": "",
        //         "address": "TNJYDW9Bk87VwfA6s7FtxURLEMHesQbYgF",
        //         "hasMemo": false,
        //         "memo": "",
        //         "estimatedTime": 1,
        //         "fastConfig": {
        //             "fastLimitNum": 0,
        //             "fastBlock": 10,
        //             "realBlock": 1
        //         }
        //     }
        //
        object chain = this.safeString(response, "chain");
        object address = this.safeString(response, "address");
        this.checkAddress(address);
        return new Dictionary<string, object>() {
            { "info", response },
            { "currency", null },
            { "network", this.networkIdToCode(chain) },
            { "address", address },
            { "tag", this.safeString(response, "memo") },
        };
    }

    /**
     * @method
     * @name deepcoin#fetchLedger
     * @description fetch the history of changes, actions done by the user or operations that altered the balance of the user
     * @see https://www.deepcoin.com/docs/DeepCoinAccount/getAccountBills
     * @param {string} [code] unified currency code
     * @param {int} [since] timestamp in ms of the earliest ledger entry
     * @param {int} [limit] max number of ledger entries to return
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {int} [params.until] timestamp in ms of the latest ledger entry
     * @param {string} [params.type] 'spot' or 'swap', the market type for the ledger (default 'spot')
     * @returns {object[]} a list of [ledger structures]{@link https://docs.ccxt.com/?id=ledger}
     */
    public async override Task<object> fetchLedger(object code = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object marketType = "spot";
        var marketTypeparametersVariable = this.handleMarketTypeAndParams("fetchLedger", null, parameters, marketType);
        marketType = ((IList<object>)marketTypeparametersVariable)[0];
        parameters = ((IList<object>)marketTypeparametersVariable)[1];
        object request = new Dictionary<string, object>() {
            { "instType", this.convertToInstrumentType(marketType) },
        };
        object currency = null;
        if (isTrue(!isEqual(code, null)))
        {
            currency = this.currency(code);
            ((IDictionary<string,object>)request)["ccy"] = getValue(currency, "id");
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["after"] = since;
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        object until = this.safeInteger(parameters, "until");
        if (isTrue(!isEqual(until, null)))
        {
            ((IDictionary<string,object>)request)["before"] = until;
            parameters = this.omit(parameters, "until");
        }
        object response = await this.privateGetDeepcoinAccountBills(this.extend(request, parameters));
        //
        //     {
        //         "code": "0",
        //         "msg": "",
        //         "data": [
        //             {
        //                 "billId": "1001044652247714",
        //                 "ccy": "USDT",
        //                 "clientId": "",
        //                 "balChg": "-0.03543537",
        //                 "bal": "72.41881427",
        //                 "type": "5",
        //                 "ts": "1761047448000"
        //             },
        //             {
        //                 "billId": "1001044652258368",
        //                 "ccy": "DOGE",
        //                 "clientId": "",
        //                 "balChg": "76",
        //                 "bal": "76",
        //                 "type": "2",
        //                 "ts": "1761051006000"
        //             }
        //         ]
        //     }
        //
        object data = this.safeList(response, "data", new List<object>() {});
        return this.parseLedger(data, currency, since, limit);
    }

    public override object parseLedgerEntry(object item, object currency = null)
    {
        //
        //     {
        //         "billId": "1001044652247714",
        //         "ccy": "USDT",
        //         "clientId": "",
        //         "balChg": "-0.03543537",
        //         "bal": "72.41881427",
        //         "type": "5",
        //         "ts": "1761047448000"
        //     }
        //
        object timestamp = this.safeInteger(item, "ts");
        object change = this.safeString(item, "balChg");
        object amount = Precise.stringAbs(change);
        object direction = ((bool) isTrue(Precise.stringLt(change, "0"))) ? "out" : "in";
        object currencyId = this.safeString(item, "ccy");
        currency = this.safeCurrency(currencyId, currency);
        object type = this.safeString(item, "type");
        return this.safeLedgerEntry(new Dictionary<string, object>() {
            { "info", item },
            { "id", this.safeString(item, "billId") },
            { "direction", direction },
            { "account", null },
            { "referenceAccount", null },
            { "referenceId", null },
            { "type", this.parseLedgerEntryType(type) },
            { "currency", getValue(currency, "code") },
            { "amount", amount },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "before", null },
            { "after", this.safeString(item, "bal") },
            { "status", null },
            { "fee", null },
        }, currency);
    }

    public virtual object parseLedgerEntryType(object type)
    {
        object ledgerType = new Dictionary<string, object>() {
            { "1", "trade" },
            { "2", "trade" },
            { "3", "transfer" },
            { "4", "transfer" },
            { "5", "fee" },
        };
        return this.safeString(ledgerType, type, type);
    }

    /**
     * @method
     * @name deepcoin#transfer
     * @description transfer currency internally between wallets on the same account
     * @see https://www.deepcoin.com/docs/assets/transfer
     * @param {string} code unified currency code
     * @param {float} amount amount to transfer
     * @param {string} fromAccount account to transfer from ('spot', 'inverse', 'linear', 'fund', 'rebate' or 'demo')
     * @param {string} toAccount account to transfer to ('spot', 'inverse', 'linear', 'fund', 'rebate' or 'demo')
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.userId] user id
     * @returns {object} a [transfer structure]{@link https://docs.ccxt.com/?id=transfer-structure}
     */
    public async override Task<object> transfer(object code, object amount, object fromAccount, object toAccount, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object userId = null;
        var userIdparametersVariable = this.handleOptionAndParams(parameters, "transfer", "userId");
        userId = ((IList<object>)userIdparametersVariable)[0];
        parameters = ((IList<object>)userIdparametersVariable)[1];
        userId = ((bool) isTrue(userId)) ? userId : this.safeString(parameters, "uid");
        if (isTrue(isEqual(userId, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " transfer() requires a userId parameter")) ;
        }
        await this.loadMarkets();
        object currency = this.currency(code);
        object accountsByType = this.safeDict(this.options, "accountsByType", new Dictionary<string, object>() {});
        object fromId = this.safeString(accountsByType, fromAccount, fromAccount);
        object toId = this.safeString(accountsByType, toAccount, toAccount);
        object request = new Dictionary<string, object>() {
            { "currency_id", getValue(currency, "id") },
            { "amount", this.currencyToPrecision(code, amount) },
            { "from_id", fromId },
            { "to_id", toId },
            { "uid", userId },
        };
        object response = await this.privatePostDeepcoinAssetTransfer(this.extend(request, parameters));
        //
        //     {
        //         "code": "0",
        //         "msg": "",
        //         "data": {
        //             "retCode": 0,
        //             "retMsg": "",
        //             "retData": {}
        //         }
        //     }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        object transfer = this.parseTransfer(data, currency);
        object transferOptions = this.safeDict(this.options, "transfer", new Dictionary<string, object>() {});
        object fillResponseFromRequest = this.safeBool(transferOptions, "fillResponseFromRequest", true);
        if (isTrue(fillResponseFromRequest))
        {
            ((IDictionary<string,object>)transfer)["fromAccount"] = fromAccount;
            ((IDictionary<string,object>)transfer)["toAccount"] = toAccount;
            ((IDictionary<string,object>)transfer)["amount"] = amount;
        }
        return transfer;
    }

    public override object parseTransfer(object transfer, object currency = null)
    {
        //
        //     {
        //         "retCode": 0,
        //         "retMsg": "",
        //         "retData": {}
        //     }
        //
        object status = this.safeString(transfer, "retCode");
        object currencyCode = this.safeCurrencyCode(null, currency);
        return new Dictionary<string, object>() {
            { "info", transfer },
            { "id", null },
            { "timestamp", null },
            { "datetime", null },
            { "currency", currencyCode },
            { "amount", null },
            { "fromAccount", null },
            { "toAccount", null },
            { "status", this.parseTransferStatus(status) },
        };
    }

    public virtual object parseTransferStatus(object status)
    {
        if (isTrue(isEqual(status, "0")))
        {
            return "ok";
        }
        return "failed";
    }

    /**
     * @method
     * @name deepcoin#createOrder
     * @description create a trade order
     * @see https://www.deepcoin.com/docs/DeepCoinTrade/order
     * @see https://www.deepcoin.com/docs/DeepCoinTrade/triggerOrder
     * @param {string} symbol unified symbol of the market to create an order in
     * @param {string} type 'market' or 'limit'
     * @param {string} side 'buy' or 'sell'
     * @param {float} amount how much of currency you want to trade in units of base currency
     * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.clientOrderId] a unique id for the order
     * @param {string} [params.timeInForce] *non trigger orders only* 'GTC' (Good Till Cancel), 'IOC' (Immediate Or Cancel) or 'PO' (Post Only)
     * @param {bool} [params.postOnly] *non trigger orders only* true to place a post only order
     * @param {bool} [params.reduceOnly] *non trigger orders only* a mark to reduce the position size for margin, swap and future orders
     * @param {float} [params.triggerPrice] the price a trigger order is triggered at
     * @param {float} [params.stopLoss.triggerPrice] the price that a stop loss order is triggered at
     * @param {float} [params.takeProfit.triggerPrice] the price that a take profit order is triggered at
     * @param {string} [params.positionSide] if position mode is one-way: set to 'net', if position mode is hedge-mode: set to 'long' or 'short'
     * @param {bool} [params.hedged] *swap only* true for hedged mode, false for one way mode
     * @param {string} [params.marginMode] *swap only*'cross' or 'isolated', the default is 'cash' for spot and 'cross' for swap
     * @returns {object} an [order structure]{@link https://docs.ccxt.com/?id=order-structure}
     */
    public async override Task<object> createOrder(object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object triggerPrice = this.safeString(parameters, "triggerPrice");
        object request = this.createOrderRequest(symbol, type, side, amount, price, parameters);
        object response = null;
        if (isTrue(!isEqual(triggerPrice, null)))
        {
            // trigger orders
            response = await this.privatePostDeepcoinTradeTriggerOrder(request);
        } else
        {
            // regular orders
            //
            //     {
            //         "code": "0",
            //         "msg": "",
            //         "data": {
            //             "ordId": "1001434570213727",
            //             "clOrdId": "",
            //             "tag": "",
            //             "sCode": "0",
            //             "sMsg": ""
            //         }
            //     }
            //
            response = await this.privatePostDeepcoinTradeOrder(request);
        }
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        return this.parseOrder(data, market);
    }

    public virtual object createOrderRequest(object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        /**
        * @method
        * @ignore
        * @name deepcoin#createOrderRequest
        * @description helper function to build request
        */
        parameters ??= new Dictionary<string, object>();
        object market = this.market(symbol);
        object triggerPrice = this.safeString(parameters, "triggerPrice");
        // const isTriggerOrder = (triggerPrice !== undefined) || this.safeString2 (params, 'stopLossPrice', 'takeProfitPrice') !== undefined;
        object isTriggerOrder = (!isEqual(triggerPrice, null));
        object cost = this.safeString(parameters, "cost");
        if (isTrue(!isEqual(cost, null)))
        {
            if (isTrue(!isTrue(getValue(market, "spot")) || isTrue((!isEqual(triggerPrice, null)))))
            {
                throw new BadRequest ((string)add(this.id, " createOrder() accepts a cost parameter for spot non-trigger market orders only")) ;
            }
        }
        if (isTrue(isTriggerOrder))
        {
            return this.createTriggerOrderRequest(symbol, type, side, amount, price, parameters);
        } else
        {
            return this.createRegularOrderRequest(symbol, type, side, amount, price, parameters);
        }
    }

    public virtual object createRegularOrderRequest(object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        /**
        * @method
        * @ignore
        * @name deepcoin#createRegularOrderRequest
        * @description helper function to build request
        * @param {string} symbol unified symbol of the market to create an order in
        * @param {string} type 'market' or 'limit'
        * @param {string} side 'buy' or 'sell'
        * @param {float} amount how much you want to trade in units of the base currency
        * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {float} [params.cost] *spot only* the cost of the order in units of the quote currency, for market orders only
        * @param {string} [params.clientOrderId] a unique id for the order
        * @param {string} [params.timeInForce] 'GTC' (Good Till Cancel), 'IOC' (Immediate Or Cancel) or 'PO' (Post Only)
        * @param {bool} [params.postOnly] true to place a post only order
        * @param {bool} [params.reduceOnly] a mark to reduce the position size for margin and swap orders
        * @param {float} [params.stopLossPrice] the price that a stop loss order is triggered at
        * @param {float} [params.takeProfitPrice] the price that a take profit order is triggered at
        * @param {string} [params.marginMode] *swap only* 'cross' or 'isolated', the default is 'cash' for spot and 'cross' for swap
        * @param {string} [params.mrgPosition] *swap only* 'merge' or 'split', the default is 'merge'
        */
        parameters ??= new Dictionary<string, object>();
        object market = this.market(symbol);
        object orderType = type;
        var orderTypeparametersVariable = this.handleTypePostOnlyAndTimeInForce(type, parameters);
        orderType = ((IList<object>)orderTypeparametersVariable)[0];
        parameters = ((IList<object>)orderTypeparametersVariable)[1];
        object request = new Dictionary<string, object>() {
            { "instId", getValue(market, "id") },
            { "side", side },
            { "ordType", orderType },
        };
        object clientOrderId = this.safeString(parameters, "clientOrderId");
        if (isTrue(!isEqual(clientOrderId, null)))
        {
            ((IDictionary<string,object>)request)["clOrdId"] = clientOrderId;
            parameters = this.omit(parameters, "clientOrderId");
        }
        object stopLoss = this.safeDict(parameters, "stopLoss", new Dictionary<string, object>() {});
        object stopLossPrice = this.safeString(stopLoss, "triggerPrice");
        if (isTrue(!isEqual(stopLossPrice, null)))
        {
            parameters = this.omit(parameters, new List<object>() {"stopLoss"});
            ((IDictionary<string,object>)request)["slTriggerPx"] = this.priceToPrecision(symbol, stopLossPrice);
        }
        object takeProfit = this.safeDict(parameters, "takeProfit", new Dictionary<string, object>() {});
        object takeProfitPrice = this.safeString(takeProfit, "triggerPrice");
        if (isTrue(!isEqual(takeProfitPrice, null)))
        {
            parameters = this.omit(parameters, new List<object>() {"takeProfit"});
            ((IDictionary<string,object>)request)["tpTriggerPx"] = this.priceToPrecision(symbol, takeProfitPrice);
        }
        object isMarketOrder = (isEqual(type, "market"));
        if (isTrue(!isEqual(price, null)))
        {
            if (isTrue(isMarketOrder))
            {
                throw new BadRequest ((string)add(this.id, " createOrder() does not require a price argument for market orders")) ;
            }
            ((IDictionary<string,object>)request)["px"] = this.priceToPrecision(symbol, price);
        } else if (!isTrue(isMarketOrder))
        {
            throw new BadRequest ((string)add(this.id, " createOrder() requires a price argument for limit orders")) ;
        }
        if (isTrue(getValue(market, "spot")))
        {
            object cost = this.safeString(parameters, "cost");
            if (isTrue(!isEqual(cost, null)))
            {
                if (!isTrue(isMarketOrder))
                {
                    throw new BadRequest ((string)add(this.id, " createOrder() accepts a cost parameter for spot market orders only")) ;
                }
                parameters = this.omit(parameters, "cost");
                ((IDictionary<string,object>)request)["sz"] = this.costToPrecision(symbol, cost);
                ((IDictionary<string,object>)request)["tgtCcy"] = "quote_ccy";
            } else
            {
                ((IDictionary<string,object>)request)["sz"] = this.amountToPrecision(symbol, amount);
                ((IDictionary<string,object>)request)["tgtCcy"] = "base_ccy";
            }
            ((IDictionary<string,object>)request)["side"] = side;
            ((IDictionary<string,object>)request)["tdMode"] = "cash";
        } else
        {
            ((IDictionary<string,object>)request)["sz"] = this.amountToPrecision(symbol, amount);
            object marginMode = "cross";
            var marginModeparametersVariable = this.handleMarginModeAndParams("createOrder", parameters, marginMode);
            marginMode = ((IList<object>)marginModeparametersVariable)[0];
            parameters = ((IList<object>)marginModeparametersVariable)[1];
            ((IDictionary<string,object>)request)["tdMode"] = marginMode;
            object mrgPosition = "merge";
            var mrgPositionparametersVariable = this.handleOptionAndParams(parameters, "createOrder", "mrgPosition", mrgPosition);
            mrgPosition = ((IList<object>)mrgPositionparametersVariable)[0];
            parameters = ((IList<object>)mrgPositionparametersVariable)[1];
            ((IDictionary<string,object>)request)["mrgPosition"] = mrgPosition;
            object posSide = null;
            object reduceOnly = this.safeBool(parameters, "reduceOnly", false);
            if (isTrue(reduceOnly))
            {
                if (isTrue(isEqual(side, "buy")))
                {
                    posSide = "short";
                } else if (isTrue(isEqual(side, "sell")))
                {
                    posSide = "long";
                }
            } else
            {
                if (isTrue(isEqual(side, "buy")))
                {
                    posSide = "long";
                } else if (isTrue(isEqual(side, "sell")))
                {
                    posSide = "short";
                }
            }
            ((IDictionary<string,object>)request)["posSide"] = posSide;
        }
        return this.extend(request, parameters);
    }

    public virtual object createTriggerOrderRequest(object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        /**
        * @method
        * @ignore
        * @name deepcoin#createTriggerOrderRequest
        * @description helper function to build request
        * @param {string} symbol unified symbol of the market to create an order in
        * @param {string} type 'market' or 'limit'
        * @param {string} side 'buy' or 'sell'
        * @param {float} amount how much you want to trade in units of the base currency
        * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {bool} [params.reduceOnly] a mark to reduce the position size for margin orders
        * @param {string} [params.marginMode] *swap only* 'cross' or 'isolated', the default is 'cash' for spot and 'cross' for swap
        */
        parameters ??= new Dictionary<string, object>();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "instId", getValue(market, "id") },
            { "productGroup", this.capitalize(getValue(market, "type")) },
            { "sz", this.amountToPrecision(symbol, amount) },
            { "side", side },
            { "orderType", type },
        };
        object triggerPrice = this.safeString(parameters, "triggerPrice");
        // const takeProfitPrice = this.safeString (params, 'takeProfitPrice');
        // const stopLossPrice = this.safeString (params, 'stopLossPrice');
        // const isTpOrSlOrder = (takeProfitPrice !== undefined) || (stopLossPrice !== undefined);
        // if (isTpOrSlOrder) {
        //     if (takeProfitPrice !== undefined) {
        //         request['triggerPrice'] = this.priceToPrecision (symbol, takeProfitPrice);
        //     } else {
        //         request['triggerPrice'] = this.priceToPrecision (symbol, stopLossPrice);
        //     }
        // } else {
        ((IDictionary<string,object>)request)["triggerPrice"] = this.priceToPrecision(symbol, triggerPrice);
        // }
        if (isTrue(!isEqual(price, null)))
        {
            ((IDictionary<string,object>)request)["price"] = this.priceToPrecision(symbol, price);
        } else if (isTrue(isEqual(type, "limit")))
        {
            throw new ArgumentsRequired ((string)add(this.id, " createOrder() requires a price argument for limit trigger orders")) ;
        }
        object marginMode = "cross";
        var marginModeparametersVariable = this.handleMarginModeAndParams("createOrder", parameters, marginMode);
        marginMode = ((IList<object>)marginModeparametersVariable)[0];
        parameters = ((IList<object>)marginModeparametersVariable)[1];
        object isCrossMargin = 1;
        if (isTrue(isEqual(marginMode, "isolated")))
        {
            isCrossMargin = 0;
        }
        object reduceOnly = this.safeBool(parameters, "reduceOnly", false);
        parameters = this.omit(parameters, "reduceOnly");
        ((IDictionary<string,object>)request)["isCrossMargin"] = isCrossMargin;
        ((IDictionary<string,object>)request)["tdMode"] = marginMode;
        if (isTrue(getValue(market, "swap")))
        {
            if (isTrue(reduceOnly))
            {
                if (isTrue(isEqual(side, "buy")))
                {
                    ((IDictionary<string,object>)request)["posSide"] = "short";
                } else if (isTrue(isEqual(side, "sell")))
                {
                    ((IDictionary<string,object>)request)["posSide"] = "long";
                }
            } else
            {
                if (isTrue(isEqual(side, "buy")))
                {
                    ((IDictionary<string,object>)request)["posSide"] = "long";
                } else if (isTrue(isEqual(side, "sell")))
                {
                    ((IDictionary<string,object>)request)["posSide"] = "short";
                }
            }
        }
        object mrgPosition = "merge";
        var mrgPositionparametersVariable = this.handleOptionAndParams(parameters, "createOrder", "mrgPosition", mrgPosition);
        mrgPosition = ((IList<object>)mrgPositionparametersVariable)[0];
        parameters = ((IList<object>)mrgPositionparametersVariable)[1];
        ((IDictionary<string,object>)request)["mrgPosition"] = mrgPosition;
        return this.extend(request, parameters);
    }

    public virtual object handleTypePostOnlyAndTimeInForce(object type, object parameters)
    {
        object postOnly = false;
        var postOnlyparametersVariable = this.handlePostOnly(isEqual(type, "market"), isEqual(type, "post_only"), parameters);
        postOnly = ((IList<object>)postOnlyparametersVariable)[0];
        parameters = ((IList<object>)postOnlyparametersVariable)[1];
        if (isTrue(postOnly))
        {
            type = "post_only";
        }
        object timeInForce = this.handleTimeInForce(parameters);
        parameters = this.omit(parameters, "timeInForce");
        if (isTrue(isTrue((!isEqual(timeInForce, null))) && isTrue((isEqual(timeInForce, "IOC")))))
        {
            type = "ioc";
        }
        return new List<object>() {type, parameters};
    }

    /**
     * @method
     * @name deepcoin#createMarketOrderWithCost
     * @description create a market order by providing the symbol, side and cost
     * @param {string} symbol unified symbol of the market to create an order in
     * @param {string} side 'buy' or 'sell'
     * @param {float} cost how much you want to trade in units of the quote currency
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} an [order structure]{@link https://docs.ccxt.com/?id=order-structure}
     */
    public async override Task<object> createMarketOrderWithCost(object symbol, object side, object cost, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        parameters = this.extend(parameters, new Dictionary<string, object>() {
            { "cost", cost },
        });
        return await this.createOrder(symbol, "market", side, 0, null, parameters);
    }

    /**
     * @method
     * @name deepcoin#createMarketBuyOrderWithCost
     * @description create a market buy order by providing the symbol and cost
     * @param {string} symbol unified symbol of the market to create an order in
     * @param {float} cost how much you want to trade in units of the quote currency
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} an [order structure]{@link https://docs.ccxt.com/?id=order-structure}
     */
    public async override Task<object> createMarketBuyOrderWithCost(object symbol, object cost, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        parameters = this.extend(parameters, new Dictionary<string, object>() {
            { "cost", cost },
        });
        return await this.createOrder(symbol, "market", "buy", 0, null, parameters);
    }

    /**
     * @method
     * @name deepcoin#createMarketSellOrderWithCost
     * @description create a market sell order by providing the symbol and cost
     * @param {string} symbol unified symbol of the market to create an order in
     * @param {float} cost how much you want to trade in units of the quote currency
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} an [order structure]{@link https://docs.ccxt.com/?id=order-structure}
     */
    public async override Task<object> createMarketSellOrderWithCost(object symbol, object cost, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        parameters = this.extend(parameters, new Dictionary<string, object>() {
            { "cost", cost },
        });
        return await this.createOrder(symbol, "market", "sell", 0, null, parameters);
    }

    /**
     * @method
     * @name deepcoin#fetchClosedOrder
     * @description fetches information on a closed order made by the user
     * @see https://www.deepcoin.com/docs/DeepCoinTrade/finishOrderByID
     * @param {string} id order id
     * @param {string} symbol unified symbol of the market the order was made in
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} an [order structure]{@link https://docs.ccxt.com/?id=order-structure}
     */
    public async virtual Task<object> fetchClosedOrder(object id, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchClosedOrder() requires a symbol argument")) ;
        }
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "instId", getValue(market, "id") },
            { "ordId", id },
        };
        object response = await this.privateGetDeepcoinTradeFinishOrderByID(this.extend(request, parameters));
        //
        //     {
        //         "code": "0",
        //         "msg": "",
        //         "data": [
        //             {
        //                 "instType": "SPOT",
        //                 "instId": "ETH-USDT",
        //                 "tgtCcy": "",
        //                 "ccy": "",
        //                 "ordId": "1001434573319675",
        //                 "clOrdId": "",
        //                 "tag": "",
        //                 "px": "4056.620000000000",
        //                 "sz": "0.004000",
        //                 "pnl": "0.000000",
        //                 "ordType": "market",
        //                 "side": "buy",
        //                 "posSide": "",
        //                 "tdMode": "cash",
        //                 "accFillSz": "0.004000",
        //                 "fillPx": "",
        //                 "tradeId": "",
        //                 "fillSz": "0.004000",
        //                 "fillTime": "1760619119000",
        //                 "avgPx": "",
        //                 "state": "filled",
        //                 "lever": "1.000000",
        //                 "tpTriggerPx": "",
        //                 "tpTriggerPxType": "",
        //                 "tpOrdPx": "",
        //                 "slTriggerPx": "",
        //                 "slTriggerPxType": "",
        //                 "slOrdPx": "",
        //                 "feeCcy": "USDT",
        //                 "fee": "0.000004",
        //                 "rebateCcy": "",
        //                 "source": "",
        //                 "rebate": "",
        //                 "category": "normal",
        //                 "uTime": "1760619119000",
        //                 "cTime": "1760619119000"
        //             }
        //         ]
        //     }
        //
        object data = this.safeList(response, "data", new List<object>() {});
        object entry = this.safeDict(data, 0, new Dictionary<string, object>() {});
        return this.parseOrder(entry, market);
    }

    /**
     * @method
     * @name deepcoin#fetchOpenOrder
     * @description fetch an open order by it's id
     * @see https://www.deepcoin.com/docs/DeepCoinTrade/orderByID
     * @param {string} id order id
     * @param {string} symbol unified market symbol, default is undefined
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} an [order structure]{@link https://docs.ccxt.com/?id=order-structure}
     */
    public async virtual Task<object> fetchOpenOrder(object id, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchClosedOrder() requires a symbol argument")) ;
        }
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "instId", getValue(market, "id") },
            { "ordId", id },
        };
        object response = await this.privateGetDeepcoinTradeOrderByID(this.extend(request, parameters));
        object data = this.safeList(response, "data", new List<object>() {});
        object length = getArrayLength(data);
        if (isTrue(isEqual(length, 0)))
        {
            return null;
        }
        object entry = this.safeDict(data, 0, new Dictionary<string, object>() {});
        return this.parseOrder(entry, market);
    }

    /**
     * @method
     * @name deepcoin#fetchCanceledAndClosedOrders
     * @see https://www.deepcoin.com/docs/DeepCoinTrade/ordersHistory
     * @see https://www.deepcoin.com/docs/DeepCoinTrade/triggerOrdersHistory
     * @description fetches information on multiple canceled and closed orders made by the user
     * @param {string} [symbol] unified market symbol of the market orders were made in
     * @param {int} [since] the earliest time in ms to fetch orders for
     * @param {int} [limit] the maximum number of order structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {bool} [params.trigger] whether to fetch trigger/algo orders (default false)
     * @param {string} [params.type] *non trigger orders only* 'spot' or 'swap', the market type for the orders
     * @param {string} [params.state] *non trigger orders only* 'canceled' or 'filled', the order state to filter by
     * @param {string} [params.OrderType] *trigger orders only* 'limit' or 'market'
     * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [available parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
     * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/?id=order-structure}
     */
    public async override Task<object> fetchCanceledAndClosedOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object paginate = false;
        var paginateparametersVariable = this.handleOptionAndParams(parameters, "fetchCanceledAndClosedOrders", "paginate");
        paginate = ((IList<object>)paginateparametersVariable)[0];
        parameters = ((IList<object>)paginateparametersVariable)[1];
        if (isTrue(paginate))
        {
            return await this.fetchPaginatedCallDynamic("fetchCanceledAndClosedOrders", symbol, since, limit, parameters);
        }
        object trigger = this.safeBool(parameters, "trigger", false);
        object methodName = "fetchCanceledAndClosedOrders";
        var methodNameparametersVariable = this.handleParamString(parameters, "methodName", methodName);
        methodName = ((IList<object>)methodNameparametersVariable)[0];
        parameters = ((IList<object>)methodNameparametersVariable)[1];
        object market = null;
        object request = new Dictionary<string, object>() {};
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            ((IDictionary<string,object>)request)["instId"] = getValue(market, "id");
        }
        object marketType = "spot";
        var marketTypeparametersVariable = this.handleMarketTypeAndParams(methodName, market, parameters, marketType);
        marketType = ((IList<object>)marketTypeparametersVariable)[0];
        parameters = ((IList<object>)marketTypeparametersVariable)[1];
        ((IDictionary<string,object>)request)["instType"] = this.convertToInstrumentType(marketType);
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit; // default 100
        }
        object response = null;
        if (isTrue(trigger))
        {
            if (isTrue(!isEqual(methodName, "fetchCanceledAndClosedOrders")))
            {
                throw new BadRequest ((string)add(add(add(this.id, " "), methodName), "() does not support trigger orders")) ;
            }
            if (isTrue(isEqual(market, null)))
            {
                throw new ArgumentsRequired ((string)add(this.id, " fetchCanceledAndClosedOrders() requires a symbol argument for trigger orders")) ;
            }
            parameters = this.omit(parameters, "trigger");
            //
            //     {
            //         "code": "0",
            //         "msg": "",
            //         "data": [
            //             {
            //                 "instType": "SWAP",
            //                 "instId": "DOGE-USDT-SWAP",
            //                 "ordId": "1001110510915416",
            //                 "px": "0",
            //                 "sz": "76",
            //                 "triggerPx": "0",
            //                 "triggerPxType": "last",
            //                 "ordType": "TPSL",
            //                 "side": "sell",
            //                 "posSide": "long",
            //                 "tdMode": "cross",
            //                 "lever": "2",
            //                 "triggerTime": "0",
            //                 "uTime": "1761059366000",
            //                 "cTime": "1761059218",
            //                 "errorCode": "0",
            //                 "errorMsg": ""
            //             }
            //         ]
            //     }
            //
            response = await this.privateGetDeepcoinTradeTriggerOrdersHistory(this.extend(request, parameters));
        } else
        {
            //
            //     {
            //         "code": "0",
            //         "msg": "",
            //         "data": [
            //             {
            //                 "instType": "SPOT",
            //                 "instId": "ETH-USDT",
            //                 "tgtCcy": "",
            //                 "ccy": "",
            //                 "ordId": "1001434573319675",
            //                 "clOrdId": "",
            //                 "tag": "",
            //                 "px": "4056.620000000000",
            //                 "sz": "0.004000",
            //                 "pnl": "0.000000",
            //                 "ordType": "market",
            //                 "side": "buy",
            //                 "posSide": "",
            //                 "tdMode": "cash",
            //                 "accFillSz": "0.004000",
            //                 "fillPx": "",
            //                 "tradeId": "",
            //                 "fillSz": "0.004000",
            //                 "fillTime": "1760619119000",
            //                 "avgPx": "",
            //                 "state": "filled",
            //                 "lever": "1.000000",
            //                 "tpTriggerPx": "",
            //                 "tpTriggerPxType": "",
            //                 "tpOrdPx": "",
            //                 "slTriggerPx": "",
            //                 "slTriggerPxType": "",
            //                 "slOrdPx": "",
            //                 "feeCcy": "USDT",
            //                 "fee": "0.000004",
            //                 "rebateCcy": "",
            //                 "source": "",
            //                 "rebate": "",
            //                 "category": "normal",
            //                 "uTime": "1760619119000",
            //                 "cTime": "1760619119000"
            //             }
            //         ]
            //     }
            //
            response = await this.privateGetDeepcoinTradeOrdersHistory(this.extend(request, parameters));
        }
        // todo handle with since, until and pagination
        object data = this.safeList(response, "data", new List<object>() {});
        return this.parseOrders(data, market, since, limit);
    }

    /**
     * @method
     * @name deepcoin#fetchCanceledOrders
     * @description fetches information on multiple canceled orders made by the user
     * @see https://www.deepcoin.com/docs/DeepCoinTrade/ordersHistory
     * @param {string} symbol unified market symbol of the market the orders were made in
     * @param {int} [since] the earliest time in ms to fetch orders for
     * @param {int} [limit] the maximum number of order structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.type] 'spot' or 'swap', the market type for the orders
     * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/?id=order-structure}
     */
    public async virtual Task<object> fetchCanceledOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object methodName = "fetchCanceledOrders";
        parameters = this.extend(parameters, new Dictionary<string, object>() {
            { "methodName", methodName },
        });
        parameters = this.extend(parameters, new Dictionary<string, object>() {
            { "state", "canceled" },
        });
        return await this.fetchCanceledAndClosedOrders(symbol, since, limit, parameters);
    }

    /**
     * @method
     * @name deepcoin#fetchClosedOrders
     * @description fetches information on multiple closed orders made by the user
     * @see https://www.deepcoin.com/docs/DeepCoinTrade/ordersHistory
     * @param {string} symbol unified market symbol of the market the orders were made in
     * @param {int} [since] the earliest time in ms to fetch orders for
     * @param {int} [limit] the maximum number of order structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.type] 'spot' or 'swap', the market type for the orders
     * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/?id=order-structure}
     */
    public async override Task<object> fetchClosedOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object methodName = "fetchClosedOrders";
        parameters = this.extend(parameters, new Dictionary<string, object>() {
            { "methodName", methodName },
        });
        parameters = this.extend(parameters, new Dictionary<string, object>() {
            { "state", "filled" },
        });
        return await this.fetchCanceledAndClosedOrders(symbol, since, limit, parameters);
    }

    /**
     * @method
     * @name deepcoin#fetchOpenOrders
     * @description fetch all unfilled currently open orders
     * @see https://www.deepcoin.com/docs/DeepCoinTrade/ordersPendingV2
     * @see https://www.deepcoin.com/docs/DeepCoinTrade/triggerOrdersPending
     * @param {string} symbol unified market symbol of the market orders were made in
     * @param {int} [since] the earliest time in ms to fetch orders for
     * @param {int} [limit] the maximum number of order structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {bool} [params.trigger] whether to fetch trigger/algo orders (default false)
     * @param {int} [params.index] *non trigger orders only* pagination index, default is 1
     * @param {string} [params.orderType] *trigger orders only* 'limit' or 'market'
     * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/?id=order-structure}
     */
    public async override Task<object> fetchOpenOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchOpenOrders() requires a symbol argument")) ;
        }
        object market = this.market(symbol);
        object index = this.safeInteger(parameters, "index", 1); // todo add pagination handling
        object request = new Dictionary<string, object>() {
            { "instId", getValue(market, "id") },
        };
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        object trigger = this.safeBool(parameters, "trigger", false);
        object response = null;
        if (isTrue(trigger))
        {
            parameters = this.omit(parameters, "trigger");
            ((IDictionary<string,object>)request)["instType"] = this.convertToInstrumentType(getValue(market, "type"));
            //
            //     {
            //         "code": "0",
            //         "msg": "",
            //         "data": [
            //             {
            //                 "instType": "SPOT",
            //                 "instId": "DOGE-USDT",
            //                 "ordId": "1001442305797142",
            //                 "triggerPx": "0.01",
            //                 "ordPx": "0.01",
            //                 "sz": "20",
            //                 "ordType": "",
            //                 "side": "buy",
            //                 "posSide": "",
            //                 "tdMode": "cash",
            //                 "triggerOrderType": "Conditional",
            //                 "triggerPxType": "last",
            //                 "lever": "",
            //                 "slPrice": "",
            //                 "slTriggerPrice": "",
            //                 "tpPrice": "",
            //                 "tpTriggerPrice": "",
            //                 "closeSLTriggerPrice": "",
            //                 "closeTPTriggerPrice": "",
            //                 "cTime": "1761814167000",
            //                 "uTime": "1761814167000"
            //             }
            //         ]
            //     }
            //
            response = await this.privateGetDeepcoinTradeTriggerOrdersPending(this.extend(request, parameters));
        } else
        {
            ((IDictionary<string,object>)request)["index"] = index;
            //
            //     {
            //         "code": "0",
            //         "msg": "",
            //         "data": [
            //             {
            //                 "instType": "SPOT",
            //                 "instId": "ETH-USDT",
            //                 "tgtCcy": "",
            //                 "ccy": "",
            //                 "ordId": "1001435158096314",
            //                 "clOrdId": "",
            //                 "tag": "",
            //                 "px": "1000.000000000000",
            //                 "sz": "0.004000",
            //                 "pnl": "0.000000",
            //                 "ordType": "limit",
            //                 "side": "buy",
            //                 "posSide": "",
            //                 "tdMode": "cash",
            //                 "accFillSz": "0.000000",
            //                 "fillPx": "",
            //                 "tradeId": "",
            //                 "fillSz": "0.000000",
            //                 "fillTime": "1760695267000",
            //                 "avgPx": "",
            //                 "state": "live",
            //                 "lever": "1",
            //                 "tpTriggerPx": "",
            //                 "tpTriggerPxType": "",
            //                 "tpOrdPx": "",
            //                 "slTriggerPx": "",
            //                 "slTriggerPxType": "",
            //                 "slOrdPx": "",
            //                 "feeCcy": "USDT",
            //                 "fee": "0.000000",
            //                 "rebateCcy": "",
            //                 "source": "",
            //                 "rebate": "",
            //                 "category": "normal",
            //                 "uTime": "1760695267000",
            //                 "cTime": "1760695267000"
            //             }
            //         ]
            //     }
            //
            response = await this.privateGetDeepcoinTradeV2OrdersPending(this.extend(request, parameters));
        }
        object data = this.safeList(response, "data", new List<object>() {});
        return this.parseOrders(data, market, since, limit, new Dictionary<string, object>() {
            { "status", "open" },
        });
    }

    /**
     * @method
     * @name deepcoin#cancelOrder
     * @description cancels an open order
     * @see https://www.deepcoin.com/docs/DeepCoinTrade/cancelOrder
     * @param {string} id order id
     * @param {string} symbol unified symbol of the market the order was made in
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {bool} [params.trigger] whether the order is a trigger/algo order (default false)
     * @returns {object} An [order structure]{@link https://docs.ccxt.com/?id=order-structure}
     */
    public async override Task<object> cancelOrder(object id, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " cancelOrder() requires a symbol argument")) ;
        }
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "instId", getValue(market, "id") },
            { "ordId", id },
        };
        object response = null;
        object trigger = this.safeBool(parameters, "trigger", false);
        if (isTrue(trigger))
        {
            parameters = this.omit(parameters, "trigger");
            response = await this.privatePostDeepcoinTradeCancelTriggerOrder(this.extend(request, parameters));
        } else
        {
            response = await this.privatePostDeepcoinTradeCancelOrder(this.extend(request, parameters));
        }
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        return this.parseOrder(data, market);
    }

    /**
     * @method
     * @name deepcoin#cancelAllOrders
     * @description cancel all open orders in a market
     * @see https://www.deepcoin.com/docs/DeepCoinTrade/cancelAllOrder
     * @param {string} symbol unified market symbol of the market to cancel orders in
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.marginMode] *swap only* 'cross' or 'isolated', the default is 'cash' for spot and 'cross' for swap
     * @param {bool} [params.merged] *swap only* true for merged positions, false for split positions (default true)
     * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/?id=order-structure}
     */
    public async override Task<object> cancelAllOrders(object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " cancelAllOrders() requires a symbol argument")) ;
        }
        object market = this.market(symbol);
        if (isTrue(getValue(market, "spot")))
        {
            throw new NotSupported ((string)add(this.id, " cancelAllOrders() is not supported for spot markets")) ;
        }
        object productGroup = this.getProductGroupFromMarket(market);
        object marginMode = this.safeString(parameters, "marginMode");
        object encodedMarginMode = 1;
        if (isTrue(!isEqual(marginMode, null)))
        {
            parameters = this.omit(parameters, "marginMode");
            if (isTrue(isEqual(marginMode, "isolated")))
            {
                encodedMarginMode = 0;
            }
        }
        object merged = true;
        var mergedparametersVariable = this.handleOptionAndParams(parameters, "cancelAllOrders", "merged", merged);
        merged = ((IList<object>)mergedparametersVariable)[0];
        parameters = ((IList<object>)mergedparametersVariable)[1];
        object request = new Dictionary<string, object>() {
            { "InstrumentID", getValue(market, "id") },
            { "ProductGroup", productGroup },
            { "IsCrossMargin", encodedMarginMode },
            { "IsMergeMode", ((bool) isTrue(merged)) ? 1 : 0 },
        };
        object response = await this.privatePostDeepcoinTradeSwapCancelAll(this.extend(request, parameters));
        object data = this.safeList(response, "data", new List<object>() {});
        return this.parseOrders(data, market);
    }

    /**
     * @method
     * @name deepcoin#editOrder
     * @description edit a trade order
     * @see https://www.deepcoin.com/docs/DeepCoinTrade/replaceOrder
     * @see https://www.deepcoin.com/docs/DeepCoinTrade/replaceTPSL
     * @param {string} id cancel order id
     * @param {string} [symbol] unified symbol of the market to create an order in (not used in deepcoin editOrder)
     * @param {string} [type] 'market' or 'limit' (not used in deepcoin editOrder)
     * @param {string} [side] 'buy' or 'sell' (not used in deepcoin editOrder)
     * @param {float} [amount] how much of currency you want to trade in units of base currency
     * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {float} [params.stopLossPrice] the price that a stop loss order is triggered at
     * @param {float} [params.takeProfitPrice] the price that a take profit order is triggered at
     * @returns {object} an [order structure]{@link https://docs.ccxt.com/?id=order-structure}
     */
    public async override Task<object> editOrder(object id, object symbol, object type, object side, object amount = null, object price = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {
            { "OrderSysID", id },
        };
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            if (isTrue(getValue(market, "spot")))
            {
                throw new NotSupported ((string)add(this.id, " editOrder() is not supported for spot markets")) ;
            }
            symbol = getValue(market, "symbol");
        }
        object stopLossPrice = this.safeNumber(parameters, "stopLossPrice");
        object takeProfitPrice = this.safeNumber(parameters, "takeProfitPrice");
        object isTPSL = isTrue((!isEqual(stopLossPrice, null))) || isTrue((!isEqual(takeProfitPrice, null)));
        object response = null;
        if (isTrue(isTPSL))
        {
            if (isTrue(isTrue((!isEqual(price, null))) || isTrue((!isEqual(amount, null)))))
            {
                throw new BadRequest ((string)add(this.id, " editOrder() with stopLossPrice or takeProfitPrice cannot have price or amount. Either use stopLossPrice/takeProfitPrice or price/amount to edit order.")) ;
            }
            if (isTrue(!isEqual(stopLossPrice, null)))
            {
                ((IDictionary<string,object>)request)["slTriggerPx"] = ((bool) isTrue(symbol)) ? this.priceToPrecision(symbol, stopLossPrice) : this.numberToString(stopLossPrice);
            }
            if (isTrue(!isEqual(takeProfitPrice, null)))
            {
                ((IDictionary<string,object>)request)["tpTriggerPx"] = ((bool) isTrue(symbol)) ? this.priceToPrecision(symbol, takeProfitPrice) : this.numberToString(takeProfitPrice);
            }
            parameters = this.omit(parameters, new List<object>() {"stopLossPrice", "takeProfitPrice"});
            response = await this.privatePostDeepcoinTradeReplaceOrderSltp(this.extend(request, parameters));
        } else
        {
            if (isTrue(!isEqual(price, null)))
            {
                if (isTrue(!isEqual(symbol, null)))
                {
                    ((IDictionary<string,object>)request)["price"] = this.priceToPrecision(symbol, price);
                } else
                {
                    ((IDictionary<string,object>)request)["price"] = this.numberToString(price);
                }
            }
            if (isTrue(!isEqual(amount, null)))
            {
                if (isTrue(!isEqual(symbol, null)))
                {
                    ((IDictionary<string,object>)request)["volume"] = this.amountToPrecision(symbol, amount);
                } else
                {
                    ((IDictionary<string,object>)request)["volume"] = this.numberToString(amount);
                }
            }
            response = await this.privatePostDeepcoinTradeReplaceOrder(this.extend(request, parameters));
        }
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        return this.parseOrder(data);
    }

    /**
     * @method
     * @name deepcoin#cancelOrders
     * @description cancel multiple orders
     * @param {string[]} ids order ids
     * @param {string} [symbol] unified market symbol, default is undefined
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} an list of [order structures]{@link https://docs.ccxt.com/?id=order-structure}
     */
    public async override Task<object> cancelOrders(object ids, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            if (isTrue(getValue(market, "spot")))
            {
                throw new NotSupported ((string)add(this.id, " cancelOrders() is not supported for spot markets")) ;
            }
        }
        object request = new Dictionary<string, object>() {
            { "OrderSysIDs", ids },
        };
        object response = await this.privatePostDeepcoinTradeBatchCancelOrder(this.extend(request, parameters));
        object data = this.safeList(response, "data", new List<object>() {});
        return this.parseOrders(data, market);
    }

    public override object parseOrder(object order, object market = null)
    {
        //
        // regular order
        //     {
        //         "instType": "SPOT",
        //         "instId": "ETH-USDT",
        //         "tgtCcy": "",
        //         "ccy": "",
        //         "ordId": "1001434573319675",
        //         "clOrdId": "",
        //         "tag": "",
        //         "px": "4056.620000000000",
        //         "sz": "0.004000",
        //         "pnl": "0.000000",
        //         "ordType": "market",
        //         "side": "buy",
        //         "posSide": "",
        //         "tdMode": "cash",
        //         "accFillSz": "0.004000",
        //         "fillPx": "",
        //         "tradeId": "",
        //         "fillSz": "0.004000",
        //         "fillTime": "1760619119000",
        //         "avgPx": "",
        //         "state": "filled",
        //         "lever": "1.000000",
        //         "tpTriggerPx": "",
        //         "tpTriggerPxType": "",
        //         "tpOrdPx": "",
        //         "slTriggerPx": "",
        //         "slTriggerPxType": "",
        //         "slOrdPx": "",
        //         "feeCcy": "USDT",
        //         "fee": "0.000004",
        //         "rebateCcy": "",
        //         "source": "",
        //         "rebate": "",
        //         "category": "normal",
        //         "uTime": "1760619119000",
        //         "cTime": "1760619119000"
        //     }
        //
        // trigger order
        //     {
        //         "instType": "SPOT",
        //         "instId": "DOGE-USDT",
        //         "ordId": "1001442305797142",
        //         "triggerPx": "0.01",
        //         "ordPx": "0.01",
        //         "sz": "20",
        //         "ordType": "",
        //         "side": "buy",
        //         "posSide": "",
        //         "tdMode": "cash",
        //         "triggerOrderType": "Conditional",
        //         "triggerPxType": "last",
        //         "lever": "",
        //         "slPrice": "",
        //         "slTriggerPrice": "",
        //         "tpPrice": "",
        //         "tpTriggerPrice": "",
        //         "closeSLTriggerPrice": "",
        //         "closeTPTriggerPrice": "",
        //         "cTime": "1761814167000",
        //         "uTime": "1761814167000"
        //     }
        //
        object marketId = this.safeString(order, "instId");
        market = this.safeMarket(marketId, market);
        object timestamp = this.safeInteger(order, "cTime");
        object timestampString = this.safeString(order, "cTime", "");
        if (isTrue(isLessThan(((string)timestampString).Length, 13)))
        {
            timestamp = this.safeTimestamp(order, "cTime");
        }
        object state = this.safeString(order, "state");
        object orderType = this.safeString(order, "ordType");
        object average = this.safeString(order, "avgPx");
        if (isTrue(isEqual(average, "")))
        {
            average = null;
        }
        object feeCurrencyId = this.safeString(order, "feeCcy");
        object fee = null;
        if (isTrue(!isEqual(feeCurrencyId, null)))
        {
            object feeCost = this.safeString(order, "fee");
            fee = new Dictionary<string, object>() {
                { "cost", this.parseNumber(feeCost) },
                { "currency", this.safeCurrencyCode(feeCurrencyId) },
            };
        }
        return this.safeOrder(new Dictionary<string, object>() {
            { "id", this.safeString(order, "ordId") },
            { "clientOrderId", this.safeString(order, "clOrdId") },
            { "datetime", this.iso8601(timestamp) },
            { "timestamp", timestamp },
            { "lastTradeTimestamp", null },
            { "lastUpdateTimestamp", this.safeInteger(order, "uTime") },
            { "status", this.parseOrderStatus(state) },
            { "symbol", getValue(market, "symbol") },
            { "type", this.parseOrderType(orderType) },
            { "timeInForce", this.parseOrderTimeInForce(orderType) },
            { "side", this.safeString(order, "side") },
            { "price", this.safeString2(order, "px", "ordPx") },
            { "average", average },
            { "amount", this.safeString(order, "sz") },
            { "filled", this.safeString(order, "accFillSz") },
            { "remaining", null },
            { "triggerPrice", this.omitZero(this.safeString(order, "triggerPx")) },
            { "takeProfitPrice", this.safeString2(order, "tpTriggerPx", "tpTriggerPrice") },
            { "stopLossPrice", this.safeString2(order, "slTriggerPx", "slTriggerPrice") },
            { "cost", null },
            { "trades", null },
            { "fee", fee },
            { "reduceOnly", null },
            { "postOnly", ((bool) isTrue(orderType)) ? (isEqual(orderType, "post_only")) : null },
            { "info", order },
        }, market);
    }

    public virtual object parseOrderStatus(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "live", "open" },
            { "filled", "closed" },
            { "canceled", "canceled" },
            { "partially_filled", "open" },
        };
        return this.safeString(statuses, status, status);
    }

    public virtual object parseOrderType(object type)
    {
        object types = new Dictionary<string, object>() {
            { "limit", "limit" },
            { "market", "market" },
            { "post_only", "limit" },
            { "ioc", "market" },
            { "TPSL", "market" },
        };
        return this.safeString(types, type, type);
    }

    public virtual object parseOrderTimeInForce(object type)
    {
        object timeInForces = new Dictionary<string, object>() {
            { "post_only", "PO" },
            { "ioc", "IOC" },
            { "limit", "GTC" },
            { "market", "GTC" },
        };
        return this.safeString(timeInForces, type, type);
    }

    /**
     * @method
     * @description fetch open positions for a single market
     * @name deepcoin#fetchPositionsForSymbol
     * @see https://www.deepcoin.com/docs/DeepCoinAccount/accountPositions
     * @description fetch all open positions for specific symbol
     * @param {string} symbol unified market symbol
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} a list of [position structure]{@link https://docs.ccxt.com/?id=position-structure}
     */
    public async override Task<object> fetchPositionsForSymbol(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object instrumentType = this.convertToInstrumentType(getValue(market, "type"));
        object request = new Dictionary<string, object>() {
            { "instType", instrumentType },
            { "instId", getValue(market, "id") },
        };
        object response = await this.privateGetDeepcoinAccountPositions(this.extend(request, parameters));
        object data = this.safeList(response, "data", new List<object>() {});
        return this.parsePositions(data, new List<object>() {getValue(market, "symbol")});
    }

    /**
     * @method
     * @name deepcoin#fetchPositions
     * @description fetch all open positions
     * @see https://www.deepcoin.com/docs/DeepCoinAccount/accountPositions
     * @param {string[]} [symbols] list of unified market symbols
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} a list of [position structure]{@link https://docs.ccxt.com/?id=position-structure}
     */
    public async override Task<object> fetchPositions(object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        symbols = this.marketSymbols(symbols, null, true, true);
        object marketType = "swap";
        object market = null;
        if (isTrue(!isEqual(symbols, null)))
        {
            object firstSymbol = this.safeString(symbols, 0);
            market = this.market(firstSymbol);
        }
        var marketTypeparametersVariable = this.handleMarketTypeAndParams("fetchPositions", market, parameters, marketType);
        marketType = ((IList<object>)marketTypeparametersVariable)[0];
        parameters = ((IList<object>)marketTypeparametersVariable)[1];
        object instrumentType = this.convertToInstrumentType(marketType);
        object request = new Dictionary<string, object>() {
            { "instType", instrumentType },
        };
        object response = await this.privateGetDeepcoinAccountPositions(this.extend(request, parameters));
        //
        //     {
        //         "code": "0",
        //         "msg": "",
        //         "data": [
        //             {
        //                 "instType": "SWAP",
        //                 "mgnMode": "cross",
        //                 "instId": "DOGE-USDT-SWAP",
        //                 "posId": "1001110099878275",
        //                 "posSide": "long",
        //                 "pos": "20",
        //                 "avgPx": "0.18408",
        //                 "lever": "75",
        //                 "liqPx": "0.00001",
        //                 "useMargin": "0.049088",
        //                 "mrgPosition": "merge",
        //                 "ccy": "USDT",
        //                 "uTime": "1760709419000",
        //                 "cTime": "1760709419000"
        //             }
        //         ]
        //     }
        //
        object data = this.safeList(response, "data", new List<object>() {});
        return this.parsePositions(data, symbols);
    }

    public override object parsePosition(object position, object market = null)
    {
        //
        //     {
        //         "instType": "SWAP",
        //         "mgnMode": "cross",
        //         "instId": "DOGE-USDT-SWAP",
        //         "posId": "1001110099878275",
        //         "posSide": "long",
        //         "pos": "20",
        //         "avgPx": "0.18408",
        //         "lever": "75",
        //         "liqPx": "0.00001",
        //         "useMargin": "0.049088",
        //         "mrgPosition": "merge",
        //         "ccy": "USDT",
        //         "uTime": "1760709419000",
        //         "cTime": "1760709419000"
        //     }
        //
        object marketId = this.safeString(position, "instId");
        market = this.safeMarket(marketId, market);
        object timestamp = this.safeInteger(position, "cTime");
        return this.safePosition(new Dictionary<string, object>() {
            { "symbol", getValue(market, "symbol") },
            { "id", this.safeString(position, "posId") },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "contracts", this.safeString(position, "pos") },
            { "contractSize", null },
            { "side", this.safeString(position, "posSide") },
            { "notional", null },
            { "leverage", this.omitZero(this.safeString(position, "lever")) },
            { "unrealizedPnl", null },
            { "realizedPnl", null },
            { "collateral", null },
            { "entryPrice", this.safeString(position, "avgPx") },
            { "markPrice", null },
            { "liquidationPrice", this.safeString(position, "liqPx") },
            { "marginMode", this.safeString(position, "mgnMode") },
            { "hedged", true },
            { "maintenanceMargin", this.safeString(position, "useMargin") },
            { "maintenanceMarginPercentage", null },
            { "initialMargin", null },
            { "initialMarginPercentage", null },
            { "marginRatio", null },
            { "lastUpdateTimestamp", this.safeInteger(position, "uTime") },
            { "lastPrice", null },
            { "stopLossPrice", null },
            { "takeProfitPrice", null },
            { "percentage", null },
            { "info", position },
        });
    }

    /**
     * @method
     * @name deepcoin#setLeverage
     * @description set the level of leverage for a market
     * @see https://www.deepcoin.com/docs/DeepCoinAccount/accountSetLeverage
     * @param {float} leverage the rate of leverage
     * @param {string} symbol unified market symbol
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.marginMode] 'cross' or 'isolated' (default is cross)
     * @param {string} [params.mrgPosition] 'merge' or 'split', default is merge
     * @returns {object} response from the exchange
     */
    public async override Task<object> setLeverage(object leverage, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " setLeverage() requires a symbol argument")) ;
        }
        // WARNING: THIS WILL INCREASE LIQUIDATION PRICE FOR OPEN ISOLATED LONG POSITIONS
        // AND DECREASE LIQUIDATION PRICE FOR OPEN ISOLATED SHORT POSITIONS
        if (isTrue(isLessThan(leverage, 1)))
        {
            throw new BadRequest ((string)add(this.id, " setLeverage() leverage should be minimum 1")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object marginMode = "cross";
        var marginModeparametersVariable = this.handleMarginModeAndParams("setLeverage", parameters, marginMode);
        marginMode = ((IList<object>)marginModeparametersVariable)[0];
        parameters = ((IList<object>)marginModeparametersVariable)[1];
        if (isTrue(isTrue((!isEqual(marginMode, "cross"))) && isTrue((!isEqual(marginMode, "isolated")))))
        {
            throw new BadRequest ((string)add(this.id, " setLeverage() requires a marginMode parameter that must be either cross or isolated")) ;
        }
        object mrgPosition = "merge";
        var mrgPositionparametersVariable = this.handleOptionAndParams(parameters, "setLeverage", "mrgPosition", mrgPosition);
        mrgPosition = ((IList<object>)mrgPositionparametersVariable)[0];
        parameters = ((IList<object>)mrgPositionparametersVariable)[1];
        if (isTrue(isTrue(!isEqual(mrgPosition, "merge")) && isTrue(!isEqual(mrgPosition, "split"))))
        {
            throw new BadRequest ((string)add(this.id, " setLeverage() mrgPosition parameter must be either merge or split")) ;
        }
        object request = new Dictionary<string, object>() {
            { "lever", leverage },
            { "mgnMode", marginMode },
            { "instId", getValue(market, "id") },
            { "mrgPosition", mrgPosition },
        };
        object response = await this.privatePostDeepcoinAccountSetLeverage(this.extend(request, parameters));
        //
        //     {
        //         code: '0',
        //         msg: '',
        //         data: {
        //             instId: 'ETH-USDT-SWAP',
        //             lever: '2',
        //             mgnMode: 'cross',
        //             mrgPosition: 'merge',
        //             sCode: '0',
        //             sMsg: ''
        //         }
        //     }
        //
        return response;
    }

    /**
     * @method
     * @name deepcoin#fetchFundingRates
     * @description fetch the funding rate for multiple markets
     * @see https://www.deepcoin.com/docs/DeepCoinTrade/currentFundRate
     * @param {string[]|undefined} symbols list of unified market symbols
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.subType] "linear" or "inverse"
     * @returns {object[]} a list of [funding rate structures]{@link https://docs.ccxt.com/?id=funding-rates-structure}, indexed by market symbols
     */
    public async override Task<object> fetchFundingRates(object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        symbols = this.marketSymbols(symbols, "swap", true, true, true);
        object subType = "linear";
        object firstMarket = null;
        if (isTrue(!isEqual(symbols, null)))
        {
            object firstSymbol = this.safeString(symbols, 0);
            firstMarket = this.market(firstSymbol);
        }
        var subTypeparametersVariable = this.handleSubTypeAndParams("fetchFundingRates", firstMarket, parameters, subType);
        subType = ((IList<object>)subTypeparametersVariable)[0];
        parameters = ((IList<object>)subTypeparametersVariable)[1];
        object instType = "SwapU";
        if (isTrue(isEqual(subType, "inverse")))
        {
            instType = "Swap";
        } else if (isTrue(!isEqual(subType, "linear")))
        {
            throw new BadRequest ((string)add(this.id, " fetchFundingRates() subType parameter must be either linear or inverse")) ;
        }
        object request = new Dictionary<string, object>() {
            { "instType", instType },
        };
        object response = await this.publicGetDeepcoinTradeFundRateCurrentFundingRate(this.extend(request, parameters));
        //
        //     {
        //         "code": "0",
        //         "msg": "",
        //         "data": {
        //             "current_fund_rates": [
        //                 {
        //                     "instrumentId": "SPKUSDT",
        //                     "fundingRate": 0.00005
        //                 },
        //                 {
        //                     "instrumentId": "LAUNCHCOINUSDT",
        //                     "fundingRate": 0.00005
        //                 }
        //             ]
        //         }
        //     }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        object rates = this.safeList(data, "current_fund_rates", new List<object>() {});
        return this.parseFundingRates(rates, symbols);
    }

    /**
     * @method
     * @name deepcoin#fetchFundingRate
     * @description fetch the current funding rate
     * @see https://www.deepcoin.com/docs/DeepCoinTrade/currentFundRate
     * @param {string} symbol unified market symbol
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [funding rate structure]{@link https://docs.ccxt.com/?id=funding-rate-structure}
     */
    public async override Task<object> fetchFundingRate(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        if (!isTrue(getValue(market, "swap")))
        {
            throw new ExchangeError ((string)add(this.id, " fetchFundingRate() is only valid for swap markets")) ;
        }
        object request = new Dictionary<string, object>() {
            { "instId", getValue(market, "id") },
            { "instType", this.getProductGroupFromMarket(market) },
        };
        object response = await this.publicGetDeepcoinTradeFundRateCurrentFundingRate(this.extend(request, parameters));
        //
        //     {
        //         "code": "0",
        //         "msg": "",
        //         "data": {
        //             "current_fund_rates": [
        //                 {
        //                     "instrumentId": "ETHUSDT",
        //                     "fundingRate": 0.0000402356250176
        //                 }
        //             ]
        //         }
        //     }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        object rates = this.safeList(data, "current_fund_rates", new List<object>() {});
        object entry = this.safeDict(rates, 0, new Dictionary<string, object>() {});
        return this.parseFundingRate(entry, market);
    }

    public override object parseFundingRate(object contract, object market = null)
    {
        //
        //     {
        //         "instrumentId": "ETHUSDT",
        //         "fundingRate": 0.0000402356250176
        //     }
        //
        object marketId = this.safeString2(contract, "instrumentId", "instrumentID");
        object symbol = this.safeSymbol(marketId, market);
        return new Dictionary<string, object>() {
            { "info", contract },
            { "symbol", symbol },
            { "markPrice", null },
            { "indexPrice", null },
            { "interestRate", null },
            { "estimatedSettlePrice", null },
            { "timestamp", null },
            { "datetime", null },
            { "fundingRate", this.safeNumber(contract, "fundingRate") },
            { "fundingTimestamp", null },
            { "fundingDatetime", null },
            { "nextFundingRate", null },
            { "nextFundingTimestamp", null },
            { "nextFundingDatetime", null },
            { "previousFundingRate", null },
            { "previousFundingTimestamp", null },
            { "previousFundingDatetime", null },
            { "interval", null },
        };
    }

    /**
     * @method
     * @name deepcoin#fetchFundingRateHistory
     * @description fetches historical funding rate prices
     * @see https://www.deepcoin.com/docs/DeepCoinTrade/fundingRateHistory
     * @param {string} symbol unified symbol of the market to fetch the funding rate history for
     * @param {int} [since] timestamp in ms of the earliest funding rate to fetch
     * @param {int} [limit] the maximum amount of [funding rate structures]{@link https://docs.ccxt.com/?id=funding-rate-history-structure} to fetch
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {int} [params.page] pagination page number
     * @returns {object[]} a list of [funding rate structures]{@link https://docs.ccxt.com/?id=funding-rate-history-structure}
     */
    public async override Task<object> fetchFundingRateHistory(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchFundingRateHistory() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "instId", getValue(market, "id") },
        };
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["size"] = limit; // default 20, max 100
        }
        object response = await this.publicGetDeepcoinTradeFundRateHistory(this.extend(request, parameters));
        //
        //     {
        //         "code": "0",
        //         "msg": "",
        //         "data": {
        //             "rows": [
        //                 {
        //                     "instrumentID": "ETHUSD",
        //                     "rate": "0.00046493",
        //                     "CreateTime": 1760860800,
        //                     "ratePeriodSec": 0
        //                 },
        //                 {
        //                     "instrumentID": "ETHUSD",
        //                     "rate": "0.00047949",
        //                     "CreateTime": 1760832000,
        //                     "ratePeriodSec": 0
        //                 }
        //             ]
        //         }
        //     }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        object rows = this.safeList(data, "rows", new List<object>() {});
        return this.parseFundingRateHistories(rows, market, since, limit);
    }

    public override object parseFundingRateHistory(object info, object market = null)
    {
        //
        //     {
        //         "instrumentID": "ETHUSD",
        //         "rate": "0.00047949",
        //         "CreateTime": 1760832000,
        //         "ratePeriodSec": 0
        //     }
        //
        object timestamp = this.safeTimestamp(info, "CreateTime");
        object instrumentID = this.safeString2(info, "instrumentID", "instrumentId");
        market = this.safeMarket(instrumentID, market, null, "swap");
        return new Dictionary<string, object>() {
            { "info", info },
            { "symbol", getValue(market, "symbol") },
            { "fundingRate", this.safeNumber(info, "rate") },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
        };
    }

    /**
     * @method
     * @name deepcoin#fetchMyTrades
     * @description fetch all trades made by the user
     * @see https://www.deepcoin.com/docs/DeepCoinTrade/tradeFills
     * @param {string} symbol unified market symbol
     * @param {int} [since] the earliest time in ms to fetch trades for
     * @param {int} [limit] the maximum number of trades structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {int} [params.until] timestamp in ms of the latest trade to fetch
     * @param {string} [params.type] 'spot' or 'swap', the market type for the trades (default is 'spot')
     * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [available parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
     * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/?id=trade-structure}
     */
    public async override Task<object> fetchMyTrades(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object paginate = false;
        var paginateparametersVariable = this.handleOptionAndParams(parameters, "fetchMyTrades", "paginate");
        paginate = ((IList<object>)paginateparametersVariable)[0];
        parameters = ((IList<object>)paginateparametersVariable)[1];
        if (isTrue(paginate))
        {
            return await this.fetchPaginatedCallDynamic("fetchMyTrades", symbol, since, limit, parameters);
        }
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
        }
        object marketType = "spot";
        var marketTypeparametersVariable = this.handleMarketTypeAndParams("fetchMyTrades", market, parameters, marketType);
        marketType = ((IList<object>)marketTypeparametersVariable)[0];
        parameters = ((IList<object>)marketTypeparametersVariable)[1];
        object request = new Dictionary<string, object>() {
            { "instType", this.convertToInstrumentType(marketType) },
        };
        if (isTrue(!isEqual(market, null)))
        {
            ((IDictionary<string,object>)request)["instId"] = getValue(market, "id");
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["begin"] = since;
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit; // default 100, max 100
        }
        object until = this.safeInteger(parameters, "until");
        if (isTrue(!isEqual(until, null)))
        {
            parameters = this.omit(parameters, "until");
            ((IDictionary<string,object>)request)["end"] = until;
        }
        object response = await this.privateGetDeepcoinTradeFills(this.extend(request, parameters));
        //
        //     {
        //         "code": "0",
        //         "msg": "",
        //         "data": [
        //             {
        //                 "instType": "SPOT",
        //                 "instId": "ETH-USDT",
        //                 "tradeId": "1001056429613610",
        //                 "ordId": "1001435238208686",
        //                 "clOrdId": "",
        //                 "billId": "10010564296136101",
        //                 "tag": "",
        //                 "fillPx": "3791.15",
        //                 "fillSz": "0.004",
        //                 "side": "sell",
        //                 "posSide": "",
        //                 "execType": "",
        //                 "feeCcy": "USDT",
        //                 "fee": "0.0151646",
        //                 "ts": "1760704540000"
        //             }
        //         ]
        //     }
        //
        object data = this.safeList(response, "data", new List<object>() {});
        return this.parseTrades(data, market, since, limit);
    }

    /**
     * @method
     * @name deepcoin#fetchOrderTrades
     * @description fetch all the trades made from a single order
     * @see https://www.deepcoin.com/docs/DeepCoinTrade/tradeFills
     * @param {string} id order id
     * @param {string} symbol unified market symbol
     * @param {int} [since] the earliest time in ms to fetch trades for
     * @param {int} [limit] the maximum number of trades to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.type] 'spot' or 'swap', the market type for the trades
     * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/?id=trade-structure}
     */
    public async override Task<object> fetchOrderTrades(object id, object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object marketType = this.safeString(parameters, "type");
        if (isTrue(isTrue(isEqual(symbol, null)) && isTrue(isEqual(marketType, null))))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchOrderTrades requires a symbol argument or a market type in the params")) ;
        }
        parameters = this.extend(new Dictionary<string, object>() {
            { "ordId", id },
        }, parameters);
        return await this.fetchMyTrades(symbol, since, limit, parameters);
    }

    /**
     * @method
     * @name deepcoin#closePosition
     * @description closes open positions for a market
     * @see https://www.deepcoin.com/docs/DeepCoinTrade/batchClosePosition
     * @see https://www.deepcoin.com/docs/DeepCoinTrade/closePositionByIds
     * @param {string} symbol Unified CCXT market symbol
     * @param {string} [side] not used by deepcoin
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string|undefined} [params.positionId] the id of the position you would like to close
     * @param {string[]|undefined} [params.positionIds] list of position ids to close (for batch closing)
     * @returns {object} an [order structure]{@link https://docs.ccxt.com/?id=order-structure}
     */
    public async override Task<object> closePosition(object symbol, object side = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object productGroup = this.getProductGroupFromMarket(market);
        object positionId = this.safeString(parameters, "positionId");
        object positionIds = this.safeList(parameters, "positionIds");
        object request = new Dictionary<string, object>() {
            { "instId", getValue(market, "id") },
            { "productGroup", productGroup },
        };
        object response = null;
        if (isTrue(isTrue(isEqual(positionId, null)) && isTrue(isEqual(positionIds, null))))
        {
            response = await this.privatePostDeepcoinTradeBatchClosePosition(this.extend(request, parameters));
        } else
        {
            if (isTrue(!isEqual(positionId, null)))
            {
                parameters = this.omit(parameters, "positionId");
                ((IDictionary<string,object>)request)["positionIds"] = new List<object>() {positionId};
            }
            response = await this.privatePostDeepcoinTradeClosePositionByIds(this.extend(request, parameters));
        }
        object data = this.safeList(response, "data", new List<object>() {});
        return this.parseOrder(data, market);
    }

    public override object sign(object path, object api = null, object method = null, object parameters = null, object headers = null, object body = null)
    {
        api ??= "public";
        method ??= "GET";
        parameters ??= new Dictionary<string, object>();
        object requestPath = path;
        if (isTrue(isEqual(method, "GET")))
        {
            object query = this.urlencode(parameters);
            if (isTrue(getArrayLength(query)))
            {
                requestPath = add(requestPath, add("?", query));
            }
        }
        object url = add(add(getValue(getValue(this.urls, "api"), api), "/"), requestPath);
        if (isTrue(isEqual(api, "private")))
        {
            this.checkRequiredCredentials();
            object timestamp = this.milliseconds();
            object dateTime = this.iso8601(timestamp);
            object payload = add(add(add(dateTime, method), "/"), requestPath);
            headers = new Dictionary<string, object>() {
                { "DC-ACCESS-KEY", this.apiKey },
                { "DC-ACCESS-TIMESTAMP", dateTime },
                { "DC-ACCESS-PASSPHRASE", this.password },
                { "appid", "200103" },
            };
            if (isTrue(!isEqual(method, "GET")))
            {
                body = this.json(parameters);
                ((IDictionary<string,object>)headers)["Content-Type"] = "application/json";
                payload = add(payload, body);
            }
            object signature = this.hmac(this.encode(payload), this.encode(this.secret), sha256, "base64");
            ((IDictionary<string,object>)headers)["DC-ACCESS-SIGN"] = signature;
        }
        return new Dictionary<string, object>() {
            { "url", url },
            { "method", method },
            { "body", body },
            { "headers", headers },
        };
    }

    public override object handleErrors(object code, object reason, object url, object method, object headers, object body, object response, object requestHeaders, object requestBody)
    {
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        object msg = this.safeString(response, "msg");
        object messageCode = this.safeString(response, "code");
        object sCode = this.safeString(data, "sCode");
        object sMsg = this.safeString(data, "sMsg");
        object errorCode = this.safeString(data, "errorCode");
        if (isTrue(isTrue(isTrue((!isEqual(msg, null))) && isTrue((isEqual(msg, "")))) && isTrue((!isEqual(sMsg, null)))))
        {
            msg = sMsg;
        }
        object errorList = this.safeList(data, "errorList");
        if (isTrue(!isEqual(errorList, null)))
        {
            for (object i = 0; isLessThan(i, getArrayLength(errorList)); postFixIncrement(ref i))
            {
                object entry = this.safeDict(errorList, i, new Dictionary<string, object>() {});
                errorCode = this.safeString(entry, "errorCode");
            }
        }
        object feedback = add(add(this.id, " "), body);
        if (isTrue(isTrue((isEqual(sCode, null))) && isTrue((!isEqual(errorCode, null)))))
        {
            sCode = errorCode;
        }
        object retCode = this.safeString(data, "retCode");
        if (isTrue(isTrue((isEqual(sCode, null))) && isTrue((!isEqual(retCode, null)))))
        {
            sCode = retCode;
        }
        if (isTrue(isTrue(isTrue((!isEqual(code, 200))) || isTrue((!isEqual(messageCode, "0")))) || isTrue((isTrue(!isEqual(sCode, null)) && isTrue(!isEqual(sCode, "0"))))))
        {
            this.throwExactlyMatchedException(getValue(this.exceptions, "exact"), messageCode, feedback);
            this.throwExactlyMatchedException(getValue(this.exceptions, "exact"), sCode, feedback);
            this.throwExactlyMatchedException(getValue(this.exceptions, "exact"), msg, feedback);
            this.throwBroadlyMatchedException(getValue(this.exceptions, "broad"), msg, feedback);
            throw new ExchangeError ((string)feedback) ;
        } else
        {
            object list = this.safeList(data, "list", new List<object>() {});
            if (isTrue(isTrue((inOp(data, "list"))) && isTrue((isEqual(list, null)))))
            {
                throw new NullResponse ((string)feedback) ;
            }
        }
        return null;
    }
}
