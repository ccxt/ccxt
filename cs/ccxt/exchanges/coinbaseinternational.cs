namespace ccxt;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

public partial class coinbaseinternational : Exchange
{
    public override object describe()
    {
        return this.deepExtend(base.describe(), new Dictionary<string, object>() {
            { "id", "coinbaseinternational" },
            { "name", "Coinbase International" },
            { "countries", new List<object>() {"US"} },
            { "certified", true },
            { "pro", true },
            { "rateLimit", 100 },
            { "version", "v1" },
            { "userAgent", getValue(this.userAgents, "chrome") },
            { "headers", new Dictionary<string, object>() {
                { "CB-VERSION", "2018-05-30" },
            } },
            { "has", new Dictionary<string, object>() {
                { "CORS", true },
                { "spot", true },
                { "margin", true },
                { "swap", true },
                { "future", true },
                { "option", false },
                { "addMargin", false },
                { "cancelAllOrders", true },
                { "cancelOrder", true },
                { "cancelOrders", false },
                { "closeAllPositions", false },
                { "closePosition", false },
                { "createDepositAddress", true },
                { "createLimitBuyOrder", true },
                { "createLimitSellOrder", true },
                { "createMarketBuyOrder", true },
                { "createMarketBuyOrderWithCost", false },
                { "createMarketOrderWithCost", false },
                { "createMarketSellOrder", true },
                { "createMarketSellOrderWithCost", false },
                { "createOrder", true },
                { "createPostOnlyOrder", true },
                { "createReduceOnlyOrder", false },
                { "createStopLimitOrder", true },
                { "createStopMarketOrder", true },
                { "createStopOrder", true },
                { "editOrder", true },
                { "fetchAccounts", true },
                { "fetchBalance", true },
                { "fetchBidsAsks", false },
                { "fetchBorrowRateHistories", false },
                { "fetchBorrowRateHistory", false },
                { "fetchCanceledOrders", false },
                { "fetchClosedOrders", false },
                { "fetchCrossBorrowRate", false },
                { "fetchCrossBorrowRates", false },
                { "fetchCurrencies", true },
                { "fetchDeposits", true },
                { "fetchFundingHistory", false },
                { "fetchFundingRate", false },
                { "fetchFundingRateHistory", true },
                { "fetchFundingRates", false },
                { "fetchIndexOHLCV", false },
                { "fetchIsolatedBorrowRate", false },
                { "fetchIsolatedBorrowRates", false },
                { "fetchL2OrderBook", false },
                { "fetchLedger", false },
                { "fetchLeverage", false },
                { "fetchLeverageTiers", false },
                { "fetchMarginAdjustmentHistory", false },
                { "fetchMarginMode", false },
                { "fetchMarkets", true },
                { "fetchMarkOHLCV", false },
                { "fetchMyBuys", true },
                { "fetchMySells", true },
                { "fetchMyTrades", true },
                { "fetchOHLCV", false },
                { "fetchOpenInterestHistory", false },
                { "fetchOpenOrders", true },
                { "fetchOrder", true },
                { "fetchOrderBook", false },
                { "fetchOrders", false },
                { "fetchPosition", true },
                { "fetchPositionHistory", false },
                { "fetchPositionMode", false },
                { "fetchPositions", true },
                { "fetchPositionsHistory", false },
                { "fetchPositionsRisk", false },
                { "fetchPremiumIndexOHLCV", false },
                { "fetchTicker", true },
                { "fetchTickers", true },
                { "fetchTime", false },
                { "fetchTrades", false },
                { "fetchTradingFee", false },
                { "fetchTradingFees", false },
                { "fetchWithdrawals", true },
                { "reduceMargin", false },
                { "sandbox", true },
                { "setLeverage", false },
                { "setMargin", true },
                { "setMarginMode", false },
                { "setPositionMode", false },
                { "withdraw", true },
            } },
            { "urls", new Dictionary<string, object>() {
                { "logo", "https://github.com/ccxt/ccxt/assets/43336371/866ae638-6ab5-4ebf-ab2c-cdcce9545625" },
                { "api", new Dictionary<string, object>() {
                    { "rest", "https://api.international.coinbase.com/api" },
                } },
                { "test", new Dictionary<string, object>() {
                    { "rest", "https://api-n5e1.coinbase.com/api" },
                } },
                { "www", "https://international.coinbase.com" },
                { "doc", new List<object>() {"https://docs.cloud.coinbase.com/intx/docs"} },
                { "fees", new List<object>() {"https://help.coinbase.com/en/international-exchange/trading-deposits-withdrawals/international-exchange-fees"} },
                { "referral", "" },
            } },
            { "requiredCredentials", new Dictionary<string, object>() {
                { "apiKey", true },
                { "secret", true },
                { "password", true },
            } },
            { "api", new Dictionary<string, object>() {
                { "v1", new Dictionary<string, object>() {
                    { "public", new Dictionary<string, object>() {
                        { "get", new List<object>() {"assets", "assets/{assets}", "assets/{asset}/networks", "instruments", "instruments/{instrument}", "instruments/{instrument}/quote", "instruments/{instrument}/funding", ""} },
                    } },
                    { "private", new Dictionary<string, object>() {
                        { "get", new List<object>() {"orders", "orders/{id}", "portfolios", "portfolios/{portfolio}", "portfolios/{portfolio}/detail", "portfolios/{portfolio}/summary", "portfolios/{portfolio}/balances", "portfolios/{portfolio}/balances/{asset}", "portfolios/{portfolio}/positions", "portfolios/{portfolio}/positions/{instrument}", "portfolios/fills", "portfolios/{portfolio}/fills", "transfers", "transfers/{transfer_uuid}"} },
                        { "post", new List<object>() {"orders", "portfolios", "portfolios/margin", "portfolios/transfer", "transfers/withdraw", "transfers/address", "transfers/create-counterparty-id", "transfers/validate-counterparty-id", "transfers/withdraw/counterparty"} },
                        { "put", new List<object>() {"orders/{id}", "portfolios/{portfolio}"} },
                        { "delete", new List<object>() {"orders", "orders/{id}"} },
                    } },
                } },
            } },
            { "fees", new Dictionary<string, object>() {
                { "trading", new Dictionary<string, object>() {
                    { "taker", this.parseNumber("0.004") },
                    { "maker", this.parseNumber("0.002") },
                    { "tierBased", true },
                    { "percentage", true },
                    { "tiers", new Dictionary<string, object>() {
                        { "taker", new List<object>() {new List<object> {this.parseNumber("0"), this.parseNumber("0.004")}, new List<object> {this.parseNumber("1000000"), this.parseNumber("0.004")}, new List<object> {this.parseNumber("5000000"), this.parseNumber("0.0035")}, new List<object> {this.parseNumber("10000000"), this.parseNumber("0.0035")}, new List<object> {this.parseNumber("50000000"), this.parseNumber("0.003")}, new List<object> {this.parseNumber("250000000"), this.parseNumber("0.0025")}} },
                        { "maker", new List<object>() {new List<object> {this.parseNumber("0"), this.parseNumber("0.002")}, new List<object> {this.parseNumber("1000000"), this.parseNumber("0.0016")}, new List<object> {this.parseNumber("5000000"), this.parseNumber("0.001")}, new List<object> {this.parseNumber("10000000"), this.parseNumber("0.0008")}, new List<object> {this.parseNumber("50000000"), this.parseNumber("0.0005")}, new List<object> {this.parseNumber("250000000"), this.parseNumber("0")}} },
                    } },
                } },
            } },
            { "precisionMode", TICK_SIZE },
            { "exceptions", new Dictionary<string, object>() {
                { "exact", new Dictionary<string, object>() {} },
                { "broad", new Dictionary<string, object>() {
                    { "DUPLICATE_CLIENT_ORDER_ID", typeof(DuplicateOrderId) },
                    { "Order rejected", typeof(InvalidOrder) },
                    { "market orders must be IoC", typeof(InvalidOrder) },
                    { "tif is required", typeof(InvalidOrder) },
                    { "Invalid replace order request", typeof(InvalidOrder) },
                    { "Unauthorized", typeof(PermissionDenied) },
                    { "invalid result_limit", typeof(BadRequest) },
                    { "is a required field", typeof(BadRequest) },
                    { "Not Found", typeof(BadRequest) },
                    { "ip not allowed", typeof(AuthenticationError) },
                } },
            } },
            { "timeframes", new Dictionary<string, object>() {
                { "1m", "ONE_MINUTE" },
                { "5m", "FIVE_MINUTE" },
                { "15m", "FIFTEEN_MINUTE" },
                { "30m", "THIRTY_MINUTE" },
                { "1h", "ONE_HOUR" },
                { "2h", "TWO_HOUR" },
                { "6h", "SIX_HOUR" },
                { "1d", "ONE_DAY" },
            } },
            { "options", new Dictionary<string, object>() {
                { "brokerId", "nfqkvdjp" },
                { "portfolio", "" },
                { "withdraw", new Dictionary<string, object>() {
                    { "method", "v1PrivatePostTransfersWithdraw" },
                } },
                { "networksById", new Dictionary<string, object>() {
                    { "ethereum", "ETH" },
                    { "arbitrum", "ARBITRUM" },
                    { "avacchain", "AVAX" },
                    { "optimism", "OPTIMISM" },
                    { "polygon", "MATIC" },
                    { "solana", "SOL" },
                    { "bitcoin", "BTC" },
                } },
            } },
        });
    }

    public async virtual Task<object> handlePortfolioAndParams(object methodName, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object portfolio = null;
        var portfolioparametersVariable = this.handleOptionAndParams(parameters, methodName, "portfolio");
        portfolio = ((IList<object>)portfolioparametersVariable)[0];
        parameters = ((IList<object>)portfolioparametersVariable)[1];
        if (isTrue(isTrue((!isEqual(portfolio, null))) && isTrue((!isEqual(portfolio, "")))))
        {
            return new List<object>() {portfolio, parameters};
        }
        object defaultPortfolio = this.safeString(this.options, "portfolio");
        if (isTrue(isTrue((!isEqual(defaultPortfolio, null))) && isTrue((!isEqual(defaultPortfolio, "")))))
        {
            return new List<object>() {defaultPortfolio, parameters};
        }
        object accounts = await this.fetchAccounts();
        for (object i = 0; isLessThan(i, getArrayLength(accounts)); postFixIncrement(ref i))
        {
            object account = getValue(accounts, i);
            object info = this.safeDict(account, "info", new Dictionary<string, object>() {});
            if (isTrue(this.safeBool(info, "is_default")))
            {
                object portfolioId = this.safeString(info, "portfolio_id");
                ((IDictionary<string,object>)this.options)["portfolio"] = portfolioId;
                return new List<object>() {portfolioId, parameters};
            }
        }
        throw new ArgumentsRequired ((string)add(add(add(this.id, " "), methodName), "() requires a portfolio parameter or set the default portfolio with this.options[\"portfolio\"]")) ;
    }

    public async virtual Task<object> handleNetworkIdAndParams(object currencyCode, object methodName, object parameters)
    {
        object networkId = null;
        var networkIdparametersVariable = this.handleOptionAndParams(parameters, methodName, "network_arn_id");
        networkId = ((IList<object>)networkIdparametersVariable)[0];
        parameters = ((IList<object>)networkIdparametersVariable)[1];
        if (isTrue(isEqual(networkId, null)))
        {
            await this.loadCurrencyNetworks(currencyCode);
            object networks = getValue(getValue(this.currencies, currencyCode), "networks");
            object network = this.safeString2(parameters, "networkCode", "network");
            if (isTrue(isEqual(network, null)))
            {
                // find default network
                if (isTrue(this.isEmpty(networks)))
                {
                    throw new BadRequest ((string)add(add(add(this.id, " createDepositAddress network not found for currency "), currencyCode), " please specify networkId in params")) ;
                }
                object defaultNetwork = this.findDefaultNetwork(networks);
                networkId = getValue(defaultNetwork, "id");
            } else
            {
                networkId = this.networkCodeToId(network, currencyCode);
            }
        }
        return new List<object>() {networkId, parameters};
    }

    public async override Task<object> fetchAccounts(object parameters = null)
    {
        /**
        * @method
        * @name coinbaseinternational#fetchAccounts
        * @description fetch all the accounts associated with a profile
        * @see https://docs.cloud.coinbase.com/intx/reference/getportfolios
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a dictionary of [account structures]{@link https://docs.ccxt.com/#/?id=account-structure} indexed by the account type
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.v1PrivateGetPortfolios(parameters);
        //
        //    [
        //        {
        //           "portfolio_id":"1ap32qsc-1-0",
        //           "portfolio_uuid":"028d7f6c-b92c-7361-8b7e-2932711e5a22",
        //           "name":"CCXT Portfolio 030624-17:16",
        //           "user_uuid":"e6cf46b6-a32f-5fa7-addb-3324d4526fbd",
        //           "maker_fee_rate":"0",
        //           "taker_fee_rate":"0.0002",
        //           "trading_lock":false,
        //           "borrow_disabled":false,
        //           "is_lsp":false,
        //           "is_default":true,
        //           "cross_collateral_enabled":false
        //        }
        //    ]
        //
        return this.parseAccounts(response, parameters);
    }

    public override object parseAccount(object account)
    {
        //
        //    {
        //       "portfolio_id":"1ap32qsc-1-0",
        //       "portfolio_uuid":"028d7f6c-b92c-7361-8b7e-2932711e5a22",
        //       "name":"CCXT Portfolio 030624-17:16",
        //       "user_uuid":"e6cf46b6-a32f-5fa7-addb-3324d4526fbd",
        //       "maker_fee_rate":"0",
        //       "taker_fee_rate":"0.0002",
        //       "trading_lock":false,
        //       "borrow_disabled":false,
        //       "is_lsp":false,
        //       "is_default":true,
        //       "cross_collateral_enabled":false
        //    }
        //
        return new Dictionary<string, object>() {
            { "id", this.safeString2(account, "portfolio_id", "portfolio_uuid") },
            { "type", null },
            { "code", null },
            { "info", account },
        };
    }

    public async override Task<object> fetchFundingRateHistory(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name coinbaseinternational#fetchFundingRateHistory
        * @description fetches historical funding rate prices
        * @see https://docs.cloud.coinbase.com/intx/reference/getinstrumentfunding
        * @param {string} symbol unified symbol of the market to fetch the funding rate history for
        * @param {int} [since] timestamp in ms of the earliest funding rate to fetch
        * @param {int} [limit] the maximum amount of [funding rate structures]{@link https://docs.ccxt.com/#/?id=funding-rate-history-structure} to fetch
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [availble parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
        */
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchFundingRateHistory() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object paginate = false;
        var paginateparametersVariable = this.handleOptionAndParams(parameters, "fetchFundingRateHistory", "paginate");
        paginate = ((IList<object>)paginateparametersVariable)[0];
        parameters = ((IList<object>)paginateparametersVariable)[1];
        object maxEntriesPerRequest = null;
        var maxEntriesPerRequestparametersVariable = this.handleOptionAndParams(parameters, "fetchFundingRateHistory", "maxEntriesPerRequest", 100);
        maxEntriesPerRequest = ((IList<object>)maxEntriesPerRequestparametersVariable)[0];
        parameters = ((IList<object>)maxEntriesPerRequestparametersVariable)[1];
        object pageKey = "ccxtPageKey";
        if (isTrue(paginate))
        {
            return await this.fetchPaginatedCallIncremental("fetchFundingRateHistory", symbol, since, limit, parameters, pageKey, maxEntriesPerRequest);
        }
        object market = this.market(symbol);
        object page = subtract(this.safeInteger(parameters, pageKey, 1), 1);
        object request = new Dictionary<string, object>() {
            { "instrument", getValue(market, "id") },
            { "result_offset", this.safeInteger2(parameters, "offset", "result_offset", multiply(page, maxEntriesPerRequest)) },
        };
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["result_limit"] = limit;
        }
        object response = await this.v1PublicGetInstrumentsInstrumentFunding(this.extend(request, parameters));
        //
        //    {
        //        "pagination":{
        //           "result_limit":"25",
        //           "result_offset":"0"
        //        },
        //        "results":[
        //           {
        //              "instrument_id":"149264167780483072",
        //              "funding_rate":"0.000011",
        //              "mark_price":"47388.1",
        //              "event_time":"2024-02-10T16:00:00Z"
        //           },
        //           ...
        //        ]
        //    }
        //
        object rawRates = this.safeList(response, "results", new List<object>() {});
        return this.parseFundingRateHistories(rawRates, market, since, limit);
    }

    public override object parseFundingRateHistory(object info, object market = null)
    {
        return this.parseFundingRate(info, market);
    }

    public override object parseFundingRate(object contract, object market = null)
    {
        //
        //    {
        //       "instrument_id":"149264167780483072",
        //       "funding_rate":"0.000011",
        //       "mark_price":"47388.1",
        //       "event_time":"2024-02-10T16:00:00Z"
        //    }
        //
        object fundingDatetime = this.safeString2(contract, "event_time", "time");
        return new Dictionary<string, object>() {
            { "info", contract },
            { "symbol", this.safeSymbol(null, market) },
            { "markPrice", this.safeNumber(contract, "mark_price") },
            { "indexPrice", null },
            { "interestRate", null },
            { "estimatedSettlePrice", null },
            { "timestamp", this.parse8601(fundingDatetime) },
            { "datetime", fundingDatetime },
            { "fundingRate", this.safeNumber(contract, "funding_rate") },
            { "fundingTimestamp", this.parse8601(fundingDatetime) },
            { "fundingDatetime", fundingDatetime },
            { "nextFundingRate", null },
            { "nextFundingTimestamp", null },
            { "nextFundingDatetime", null },
            { "previousFundingRate", null },
            { "previousFundingTimestamp", null },
            { "previousFundingDatetime", null },
        };
    }

    public async override Task<object> createDepositAddress(object code, object parameters = null)
    {
        /**
        * @method
        * @name coinbaseinternational#createDepositAddress
        * @description create a currency deposit address
        * @see https://docs.cloud.coinbase.com/intx/reference/createaddress
        * @see https://docs.cloud.coinbase.com/intx/reference/createcounterpartyid
        * @param {string} code unified currency code of the currency for the deposit address
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {string} [params.network_arn_id] Identifies the blockchain network (e.g., networks/ethereum-mainnet/assets/313ef8a9-ae5a-5f2f-8a56-572c0e2a4d5a) if not provided will pick default
        * @param {string} [params.network] unified network code to identify the blockchain network
        * @returns {object} an [address structure]{@link https://docs.ccxt.com/#/?id=address-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object method = null;
        var methodparametersVariable = this.handleOptionAndParams(parameters, "createDepositAddress", "method", "v1PrivatePostTransfersAddress");
        method = ((IList<object>)methodparametersVariable)[0];
        parameters = ((IList<object>)methodparametersVariable)[1];
        object portfolio = null;
        var portfolioparametersVariable = await this.handlePortfolioAndParams("createDepositAddress", parameters);
        portfolio = ((IList<object>)portfolioparametersVariable)[0];
        parameters = ((IList<object>)portfolioparametersVariable)[1];
        object request = new Dictionary<string, object>() {
            { "portfolio", portfolio },
        };
        if (isTrue(isEqual(method, "v1PrivatePostTransfersAddress")))
        {
            object currency = this.currency(code);
            ((IDictionary<string,object>)request)["asset"] = getValue(currency, "id");
            object networkId = null;
            var networkIdparametersVariable = await this.handleNetworkIdAndParams(code, "createDepositAddress", parameters);
            networkId = ((IList<object>)networkIdparametersVariable)[0];
            parameters = ((IList<object>)networkIdparametersVariable)[1];
            ((IDictionary<string,object>)request)["network_arn_id"] = networkId;
        }
        object response = await ((Task<object>)callDynamically(this, method, new object[] { this.extend(request, parameters) }));
        //
        // v1PrivatePostTransfersAddress
        //    {
        //        address: "3LkwYscRyh6tUR1XTqXSJQoJnK7ucC1F4n",
        //        network_arn_id: "networks/bitcoin-mainnet/assets/6ecc0dcc-10a2-500e-b315-a3b9abae19ce",
        //        destination_tag: "",
        //    }
        // v1PrivatePostTransfersCreateCounterpartyId
        //    {
        //        "portfolio_uuid":"018e0a8b-6b6b-70e0-9689-1e7926c2c8bc",
        //        "counterparty_id":"CB2ZPUCZBE"
        //    }
        //
        object tag = this.safeString(response, "destination_tag");
        object address = this.safeString2(response, "address", "counterparty_id");
        return new Dictionary<string, object>() {
            { "currency", code },
            { "tag", tag },
            { "address", address },
            { "info", response },
        };
    }

    public virtual object findDefaultNetwork(object networks)
    {
        object networksArray = this.toArray(networks);
        for (object i = 0; isLessThan(i, getArrayLength(networksArray)); postFixIncrement(ref i))
        {
            object info = getValue(getValue(networksArray, i), "info");
            object is_default = this.safeBool(info, "is_default", false);
            if (isTrue(isEqual(is_default, true)))
            {
                return getValue(networksArray, i);
            }
        }
        return getValue(networksArray, 0);
    }

    public async virtual Task loadCurrencyNetworks(object code, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object currency = this.currency(code);
        object networks = this.safeDict(currency, "networks");
        if (isTrue(!isEqual(networks, null)))
        {
            return;
        }
        object request = new Dictionary<string, object>() {
            { "asset", getValue(currency, "id") },
        };
        object rawNetworks = await this.v1PublicGetAssetsAssetNetworks(request);
        //
        //    [
        //        {
        //            "asset_id":"1",
        //            "asset_uuid":"2b92315d-eab7-5bef-84fa-089a131333f5",
        //            "asset_name":"USDC",
        //            "network_arn_id":"networks/ethereum-mainnet/assets/9bc140b4-69c3-5fc9-bd0d-b041bcf40039",
        //            "min_withdrawal_amt":"1",
        //            "max_withdrawal_amt":"100000000",
        //            "network_confirms":35,
        //            "processing_time":485,
        //            "is_default":true,
        //            "network_name":"ethereum",
        //            "display_name":"Ethereum"
        //        },
        //        ....
        //    ]
        //
        ((IDictionary<string,object>)currency)["networks"] = this.parseNetworks(rawNetworks);
    }

    public virtual object parseNetworks(object networks, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object result = new Dictionary<string, object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(networks)); postFixIncrement(ref i))
        {
            object network = this.extend(this.parseNetwork(getValue(networks, i)), parameters);
            ((IDictionary<string,object>)result)[(string)getValue(network, "network")] = network;
        }
        return result;
    }

    public virtual object parseNetwork(object network, object parameters = null)
    {
        //
        //    {
        //        "asset_id":"1",
        //        "asset_uuid":"2b92315d-eab7-5bef-84fa-089a131333f5",
        //        "asset_name":"USDC",
        //        "network_arn_id":"networks/ethereum-mainnet/assets/9bc140b4-69c3-5fc9-bd0d-b041bcf40039",
        //        "min_withdrawal_amt":"1",
        //        "max_withdrawal_amt":"100000000",
        //        "network_confirms":35,
        //        "processing_time":485,
        //        "is_default":true,
        //        "network_name":"ethereum",
        //        "display_name":"Ethereum"
        //    }
        //
        parameters ??= new Dictionary<string, object>();
        object currencyId = this.safeString(network, "asset_name");
        object currencyCode = this.safeCurrencyCode(currencyId);
        object networkId = this.safeString(network, "network_arn_id");
        return this.safeNetwork(new Dictionary<string, object>() {
            { "info", network },
            { "id", networkId },
            { "name", this.safeString(network, "display_name") },
            { "network", this.networkIdToCode(this.safeStringN(network, new List<object>() {"network_name", "display_name", "network_arn_id"}, ""), currencyCode) },
            { "active", null },
            { "deposit", null },
            { "withdraw", null },
            { "precision", null },
            { "fee", null },
            { "limits", new Dictionary<string, object>() {
                { "withdraw", new Dictionary<string, object>() {
                    { "min", this.safeNumber(network, "min_withdrawal_amt") },
                    { "max", this.safeNumber(network, "max_withdrawal_amt") },
                } },
                { "deposit", new Dictionary<string, object>() {
                    { "min", null },
                    { "max", null },
                } },
            } },
        });
    }

    public async override Task<object> setMargin(object symbol, object amount, object parameters = null)
    {
        /**
        * @method
        * @name coinbaseinternational#setMargin
        * @description Either adds or reduces margin in order to set the margin to a specific value
        * @see https://docs.cloud.coinbase.com/intx/reference/setportfoliomarginoverride
        * @param {string} symbol unified market symbol of the market to set margin in
        * @param {float} amount the amount to set the margin to
        * @param {object} [params] parameters specific to the exchange API endpoint
        * @returns {object} A [margin structure]{@link https://github.com/ccxt/ccxt/wiki/Manual#add-margin-structure}
        */
        parameters ??= new Dictionary<string, object>();
        object portfolio = null;
        var portfolioparametersVariable = await this.handlePortfolioAndParams("setMargin", parameters);
        portfolio = ((IList<object>)portfolioparametersVariable)[0];
        parameters = ((IList<object>)portfolioparametersVariable)[1];
        if (isTrue(!isEqual(symbol, null)))
        {
            throw new BadRequest ((string)add(this.id, " setMargin() only allows setting margin to full portfolio")) ;
        }
        object request = new Dictionary<string, object>() {
            { "portfolio", portfolio },
            { "margin_override", amount },
        };
        return await this.v1PrivatePostPortfoliosMargin(this.extend(request, parameters));
    }

    public async override Task<object> fetchDepositsWithdrawals(object code = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name exchange#fetchDepositsWithdrawals
        * @description fetch history of deposits and withdrawals
        * @see https://docs.cloud.coinbase.com/intx/reference/gettransfers
        * @param {string} [code] unified currency code for the currency of the deposit/withdrawals, default is undefined
        * @param {int} [since] timestamp in ms of the earliest deposit/withdrawal, default is undefined
        * @param {int} [limit] max number of deposit/withdrawals to return, default is undefined
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {string} [params.portfolios] Identifies the portfolios by UUID (e.g., 892e8c7c-e979-4cad-b61b-55a197932cf1) or portfolio ID (e.g., 5189861793641175). Can provide single or multiple portfolios to filter by or fetches transfers for all portfolios if none are provided.
        * @param {int} [params.until] Only find transfers updated before this time. Use timestamp format
        * @param {string} [params.status] The current status of transfer. Possible values: [PROCESSED, NEW, FAILED, STARTED]
        * @param {string} [params.type] The type of transfer Possible values: [DEPOSIT, WITHDRAW, REBATE, STIPEND, INTERNAL, FUNDING]
        * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [availble parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
        * @returns {object} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object paginate = null;
        var paginateparametersVariable = this.handleOptionAndParams(parameters, "fetchDepositsWithdrawals", "paginate");
        paginate = ((IList<object>)paginateparametersVariable)[0];
        parameters = ((IList<object>)paginateparametersVariable)[1];
        object maxEntriesPerRequest = null;
        var maxEntriesPerRequestparametersVariable = this.handleOptionAndParams(parameters, "fetchDepositsWithdrawals", "maxEntriesPerRequest", 100);
        maxEntriesPerRequest = ((IList<object>)maxEntriesPerRequestparametersVariable)[0];
        parameters = ((IList<object>)maxEntriesPerRequestparametersVariable)[1];
        object pageKey = "ccxtPageKey";
        if (isTrue(paginate))
        {
            return await this.fetchPaginatedCallIncremental("fetchDepositsWithdrawals", code, since, limit, parameters, pageKey, maxEntriesPerRequest);
        }
        object page = subtract(this.safeInteger(parameters, pageKey, 1), 1);
        object request = new Dictionary<string, object>() {
            { "result_offset", this.safeInteger2(parameters, "offset", "result_offset", multiply(page, maxEntriesPerRequest)) },
        };
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["time_from"] = this.iso8601(since);
        }
        if (isTrue(!isEqual(limit, null)))
        {
            object newLimit = mathMin(limit, 100);
            ((IDictionary<string,object>)request)["result_limit"] = newLimit;
        }
        object portfolios = null;
        var portfoliosparametersVariable = this.handleOptionAndParams(parameters, "fetchDepositsWithdrawals", "portfolios");
        portfolios = ((IList<object>)portfoliosparametersVariable)[0];
        parameters = ((IList<object>)portfoliosparametersVariable)[1];
        if (isTrue(!isEqual(portfolios, null)))
        {
            ((IDictionary<string,object>)request)["portfolios"] = portfolios;
        }
        object until = null;
        var untilparametersVariable = this.handleOptionAndParams(parameters, "fetchDepositsWithdrawals", "until");
        until = ((IList<object>)untilparametersVariable)[0];
        parameters = ((IList<object>)untilparametersVariable)[1];
        if (isTrue(!isEqual(until, null)))
        {
            ((IDictionary<string,object>)request)["time_to"] = this.iso8601(until);
        }
        object response = await this.v1PrivateGetTransfers(this.extend(request, parameters));
        //
        //    {
        //        "pagination":{
        //           "result_limit":25,
        //           "result_offset":0
        //        },
        //        "results":[
        //           {
        //              "transfer_uuid":"8e471d77-4208-45a8-9e5b-f3bd8a2c1fc3",
        //              "transfer_type":"WITHDRAW",
        //              "amount":"1.000000",
        //              "asset":"USDC",
        //              "status":"PROCESSED",
        //              "network_name":"ethereum",
        //              "created_at":"2024-03-14T02:32:18.497795Z",
        //              "updated_at":"2024-03-14T02:35:38.514588Z",
        //              "from_portfolio":{
        //                 "id":"1yun54bb-1-6",
        //                 "uuid":"018e0a8b-6b6b-70e0-9689-1e7926c2c8bc",
        //                 "name":"fungus technology o?Portfolio"
        //              },
        //              "to_address":"0xcdcE79F820BE9d6C5033db5c31d1AE3A8c2399bB"
        //           }
        //        ]
        //    }
        //
        object rawTransactions = this.safeList(response, "results", new List<object>() {});
        return this.parseTransactions(rawTransactions);
    }

    public async override Task<object> fetchPosition(object symbol, object parameters = null)
    {
        /**
        * @method
        * @name coinbaseinternational#fetchPosition
        * @see https://docs.cloud.coinbase.com/intx/reference/getportfolioposition
        * @description fetch data on an open position
        * @param {string} symbol unified market symbol of the market the position is held in
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [position structure]{@link https://docs.ccxt.com/#/?id=position-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        symbol = this.symbol(symbol);
        object portfolio = null;
        var portfolioparametersVariable = await this.handlePortfolioAndParams("fetchPosition", parameters);
        portfolio = ((IList<object>)portfolioparametersVariable)[0];
        parameters = ((IList<object>)portfolioparametersVariable)[1];
        object request = new Dictionary<string, object>() {
            { "portfolio", portfolio },
            { "instrument", this.marketId(symbol) },
        };
        object position = await this.v1PrivateGetPortfoliosPortfolioPositionsInstrument(this.extend(request, parameters));
        //
        //    {
        //        "symbol":"BTC-PERP",
        //        "instrument_id":"114jqr89-0-0",
        //        "instrument_uuid":"b3469e0b-222c-4f8a-9f68-1f9e44d7e5e0",
        //        "vwap":"52482.3",
        //        "net_size":"0",
        //        "buy_order_size":"0.001",
        //        "sell_order_size":"0",
        //        "im_contribution":"0.2",
        //        "unrealized_pnl":"0",
        //        "mark_price":"52406.8",
        //        "entry_vwap":"52472.9"
        //    }
        //
        return this.parsePosition(position);
    }

    public override object parsePosition(object position, object market = null)
    {
        //
        //    {
        //       "symbol":"BTC-PERP",
        //       "instrument_id":"114jqr89-0-0",
        //       "instrument_uuid":"b3469e0b-222c-4f8a-9f68-1f9e44d7e5e0",
        //       "vwap":"52482.3",
        //       "net_size":"0",
        //       "buy_order_size":"0.001",
        //       "sell_order_size":"0",
        //       "im_contribution":"0.2",
        //       "unrealized_pnl":"0",
        //       "mark_price":"52406.8",
        //       "entry_vwap":"52472.9"
        //    }
        //
        object marketId = this.safeString(position, "symbol");
        object quantity = this.safeString(position, "net_size");
        market = this.safeMarket(marketId, market, "-");
        object side = "long";
        if (isTrue(Precise.stringLe(quantity, "0")))
        {
            side = "short";
            quantity = Precise.stringMul("-1", quantity);
        }
        return this.safePosition(new Dictionary<string, object>() {
            { "info", position },
            { "id", this.safeString(position, "id") },
            { "symbol", getValue(market, "symbol") },
            { "entryPrice", null },
            { "markPrice", this.safeNumber(position, "mark_price") },
            { "notional", null },
            { "collateral", null },
            { "unrealizedPnl", this.safeNumber(position, "unrealized_pnl") },
            { "side", side },
            { "contracts", this.parseNumber(quantity) },
            { "contractSize", this.safeNumber(market, "contractSize") },
            { "timestamp", null },
            { "datetime", null },
            { "hedged", null },
            { "maintenanceMargin", null },
            { "maintenanceMarginPercentage", null },
            { "initialMargin", this.safeNumber(position, "im_contribution") },
            { "initialMarginPercentage", null },
            { "leverage", null },
            { "liquidationPrice", null },
            { "marginRatio", null },
            { "marginMode", null },
            { "percentage", null },
        });
    }

    public async override Task<object> fetchPositions(object symbols = null, object parameters = null)
    {
        /**
        * @method
        * @name coinbaseinternational#fetchPositions
        * @see https://docs.cloud.coinbase.com/intx/reference/getportfoliopositions
        * @description fetch all open positions
        * @param {string[]} [symbols] list of unified market symbols
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {string} [method] method name to call, "positionRisk", "account" or "option", default is "positionRisk"
        * @returns {object[]} a list of [position structure]{@link https://docs.ccxt.com/#/?id=position-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object portfolio = null;
        var portfolioparametersVariable = await this.handlePortfolioAndParams("fetchPositions", parameters);
        portfolio = ((IList<object>)portfolioparametersVariable)[0];
        parameters = ((IList<object>)portfolioparametersVariable)[1];
        object request = new Dictionary<string, object>() {
            { "portfolio", portfolio },
        };
        object response = await this.v1PrivateGetPortfoliosPortfolioPositions(this.extend(request, parameters));
        //
        //    [
        //        {
        //           "symbol":"BTC-PERP",
        //           "instrument_id":"114jqr89-0-0",
        //           "instrument_uuid":"b3469e0b-222c-4f8a-9f68-1f9e44d7e5e0",
        //           "vwap":"52482.3",
        //           "net_size":"0",
        //           "buy_order_size":"0.001",
        //           "sell_order_size":"0",
        //           "im_contribution":"0.2",
        //           "unrealized_pnl":"0",
        //           "mark_price":"52406.8",
        //           "entry_vwap":"52472.9"
        //        }
        //    ]
        //
        object positions = this.parsePositions(response);
        if (isTrue(this.isEmpty(symbols)))
        {
            return positions;
        }
        symbols = this.marketSymbols(symbols);
        return this.filterByArrayPositions(positions, "symbol", symbols, false);
    }

    public async override Task<object> fetchWithdrawals(object code = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name coinbaseinternational#fetchWithdrawals
        * @description fetch all withdrawals made from an account
        * @see https://docs.cloud.coinbase.com/intx/reference/gettransfers
        * @param {string} code unified currency code
        * @param {int} [since] the earliest time in ms to fetch withdrawals for
        * @param {int} [limit] the maximum number of withdrawals structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {string} [params.portfolios] Identifies the portfolios by UUID (e.g., 892e8c7c-e979-4cad-b61b-55a197932cf1) or portfolio ID (e.g., 5189861793641175). Can provide single or multiple portfolios to filter by or fetches transfers for all portfolios if none are provided.
        * @param {int} [params.until] Only find transfers updated before this time. Use timestamp format
        * @param {string} [params.status] The current status of transfer. Possible values: [PROCESSED, NEW, FAILED, STARTED]
        * @param {string} [params.type] The type of transfer Possible values: [DEPOSIT, WITHDRAW, REBATE, STIPEND, INTERNAL, FUNDING]
        * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [availble parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
        * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        ((IDictionary<string,object>)parameters)["type"] = "WITHDRAW";
        return await this.fetchDepositsWithdrawals(code, since, limit, parameters);
    }

    public async override Task<object> fetchDeposits(object code = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name coinbaseinternational#fetchDeposits
        * @description fetch all deposits made to an account
        * @param {string} code unified currency code
        * @param {int} [since] the earliest time in ms to fetch deposits for
        * @param {int} [limit] the maximum number of deposits structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {string} [params.portfolios] Identifies the portfolios by UUID (e.g., 892e8c7c-e979-4cad-b61b-55a197932cf1) or portfolio ID (e.g., 5189861793641175). Can provide single or multiple portfolios to filter by or fetches transfers for all portfolios if none are provided.
        * @param {int} [params.until] Only find transfers updated before this time. Use timestamp format
        * @param {string} [params.status] The current status of transfer. Possible values: [PROCESSED, NEW, FAILED, STARTED]
        * @param {string} [params.type] The type of transfer Possible values: [DEPOSIT, WITHDRAW, REBATE, STIPEND, INTERNAL, FUNDING]
        * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [availble parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
        * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        ((IDictionary<string,object>)parameters)["type"] = "DEPOSIT";
        return await this.fetchDepositsWithdrawals(code, since, limit, parameters);
    }

    public virtual object parseTransactionStatus(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "PROCESSED", "ok" },
            { "NEW", "pending" },
            { "STARTED", "pending" },
            { "FAILED", "canceled" },
        };
        return this.safeString(statuses, status, status);
    }

    public override object parseTransaction(object transaction, object currency = null)
    {
        //
        //    {
        //        "idem":"8e471d77-4208-45a8-9e5b-f3bd8a2c1fc3"
        //    }
        // const transactionType = this.safeString (transaction, 'type');
        object datetime = this.safeString(transaction, "updated_at");
        object fromPorfolio = this.safeDict(transaction, "from_portfolio", new Dictionary<string, object>() {});
        object addressFrom = this.safeStringN(transaction, new List<object>() {"from_address", "from_cb_account", this.safeStringN(fromPorfolio, new List<object>() {"id", "uuid", "name"}), "from_counterparty_id"});
        object toPorfolio = this.safeDict(transaction, "from_portfolio", new Dictionary<string, object>() {});
        object addressTo = this.safeStringN(transaction, new List<object>() {"to_address", "to_cb_account", this.safeStringN(toPorfolio, new List<object>() {"id", "uuid", "name"}), "to_counterparty_id"});
        return new Dictionary<string, object>() {
            { "info", transaction },
            { "id", this.safeString(transaction, "transfer_uuid") },
            { "txid", this.safeString(transaction, "transaction_uuid") },
            { "timestamp", this.parse8601(datetime) },
            { "datetime", datetime },
            { "network", this.networkIdToCode(this.safeString(transaction, "network_name")) },
            { "address", null },
            { "addressTo", addressTo },
            { "addressFrom", addressFrom },
            { "tag", null },
            { "tagTo", null },
            { "tagFrom", null },
            { "type", this.safeString(transaction, "resource") },
            { "amount", this.safeNumber(transaction, "amount") },
            { "currency", this.safeCurrencyCode(this.safeString(transaction, "asset"), currency) },
            { "status", this.parseTransactionStatus(this.safeString(transaction, "status")) },
            { "updated", this.parse8601(datetime) },
            { "fee", new Dictionary<string, object>() {
                { "cost", null },
                { "currency", null },
            } },
        };
    }

    public override object parseTrade(object trade, object market = null)
    {
        //
        //    {
        //       "portfolio_id":"1wp37qsc-1-0",
        //       "portfolio_uuid":"018d7f6c-b92c-7361-8b7e-2932711e5a22",
        //       "portfolio_name":"CCXT Portfolio 020624-17:16",
        //       "fill_id":"1xbfy19y-1-184",
        //       "exec_id":"280841526207070392",
        //       "order_id":"1xbfv8yw-1-0",
        //       "instrument_id":"114jqr89-0-0",
        //       "instrument_uuid":"b3469e0b-222c-4f8a-9f68-1f9e44d7e5e0",
        //       "symbol":"BTC-PERP",
        //       "match_id":"280841526207053840",
        //       "fill_price":"52500",
        //       "fill_qty":"0.01",
        //       "client_id":"1x59ctku-1-1",
        //       "client_order_id":"ccxt3e4e2a5f-4a89-",
        //       "order_qty":"0.01",
        //       "limit_price":"52500",
        //       "total_filled":"0.01",
        //       "filled_vwap":"52500",
        //       "expire_time":"",
        //       "stop_price":"",
        //       "side":"BUY",
        //       "tif":"GTC",
        //       "stp_mode":"BOTH",
        //       "flags":"",
        //       "fee":"0.105",
        //       "fee_asset":"USDC",
        //       "order_status":"DONE",
        //       "event_time":"2024-02-15T00:43:57.631Z"
        //    }
        //
        object marketId = this.safeString(trade, "symbol");
        object datetime = this.safeString(trade, "event_time");
        return this.safeTrade(new Dictionary<string, object>() {
            { "info", trade },
            { "id", this.safeString2(trade, "fill_id", "exec_id") },
            { "order", this.safeString(trade, "order_id") },
            { "timestamp", this.parse8601(datetime) },
            { "datetime", datetime },
            { "symbol", this.safeSymbol(marketId, market) },
            { "type", null },
            { "side", this.safeStringLower(trade, "side") },
            { "takerOrMaker", null },
            { "price", this.safeNumber(trade, "fill_price") },
            { "amount", this.safeNumber(trade, "fill_qty") },
            { "cost", null },
            { "fee", new Dictionary<string, object>() {
                { "cost", this.safeNumber(trade, "fee") },
                { "currency", this.safeCurrencyCode(this.safeString(trade, "fee_asset")) },
            } },
        });
    }

    public async override Task<object> fetchMarkets(object parameters = null)
    {
        /**
        * @method
        * @name coinbaseinternational#fetchMarkets
        * @see https://docs.cloud.coinbase.com/intx/reference/getinstruments
        * @description retrieves data on all markets for coinbaseinternational
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} an array of objects representing market data
        */
        parameters ??= new Dictionary<string, object>();
        object response = await this.v1PublicGetInstruments(parameters);
        //
        //    [
        //        {
        //           "instrument_id":"149264164756389888",
        //           "instrument_uuid":"e9360798-6a10-45d6-af05-67c30eb91e2d",
        //           "symbol":"ETH-PERP",
        //           "type":"PERP",
        //           "base_asset_id":"118059611793145856",
        //           "base_asset_uuid":"d85dce9b-5b73-5c3c-8978-522ce1d1c1b4",
        //           "base_asset_name":"ETH",
        //           "quote_asset_id":"1",
        //           "quote_asset_uuid":"2b92315d-eab7-5bef-84fa-089a131333f5",
        //           "quote_asset_name":"USDC",
        //           "base_increment":"0.0001",
        //           "quote_increment":"0.01",
        //           "price_band_percent":"0.02",
        //           "market_order_percent":"0.0075",
        //           "qty_24hr":"44434.8131",
        //           "notional_24hr":"110943454.279785",
        //           "avg_daily_qty":"1099171.6025",
        //           "avg_daily_notional":"2637240145.456987",
        //           "previous_day_qty":"78909.3939",
        //           "open_interest":"1270.749",
        //           "position_limit_qty":"1831.9527",
        //           "position_limit_adq_pct":"0.05",
        //           "replacement_cost":"0.23",
        //           "base_imf":"0.1",
        //           "min_notional_value":"10",
        //           "funding_interval":"3600000000000",
        //           "trading_state":"TRADING",
        //           "quote":{
        //              "best_bid_price":"2490.8",
        //              "best_bid_size":"9.0515",
        //              "best_ask_price":"2490.81",
        //              "best_ask_size":"4.8486",
        //              "trade_price":"2490.39",
        //              "trade_qty":"0.9508",
        //              "index_price":"2490.5",
        //              "mark_price":"2490.8",
        //              "settlement_price":"2490.81",
        //              "limit_up":"2615.42",
        //              "limit_down":"2366.34",
        //              "predicted_funding":"0.000009",
        //              "timestamp":"2024-02-10T16:07:39.454Z"
        //           }
        //        },
        //        ...
        //    ]
        //
        return this.parseMarkets(response);
    }

    public override object parseMarket(object market)
    {
        //
        //   {
        //       "instrument_id":"149264164756389888",
        //       "instrument_uuid":"e9360798-6a10-45d6-af05-67c30eb91e2d",
        //       "symbol":"ETH-PERP",
        //       "type":"PERP",
        //       "base_asset_id":"118059611793145856",
        //       "base_asset_uuid":"d85dce9b-5b73-5c3c-8978-522ce1d1c1b4",
        //       "base_asset_name":"ETH",
        //       "quote_asset_id":"1",
        //       "quote_asset_uuid":"2b92315d-eab7-5bef-84fa-089a131333f5",
        //       "quote_asset_name":"USDC",
        //       "base_increment":"0.0001",
        //       "quote_increment":"0.01",
        //       "price_band_percent":"0.02",
        //       "market_order_percent":"0.0075",
        //       "qty_24hr":"44434.8131",
        //       "notional_24hr":"110943454.279785",
        //       "avg_daily_qty":"1099171.6025",
        //       "avg_daily_notional":"2637240145.456987",
        //       "previous_day_qty":"78909.3939",
        //       "open_interest":"1270.749",
        //       "position_limit_qty":"1831.9527",
        //       "position_limit_adq_pct":"0.05",
        //       "replacement_cost":"0.23",
        //       "base_imf":"0.1",
        //       "min_notional_value":"10",
        //       "funding_interval":"3600000000000",
        //       "trading_state":"TRADING",
        //       "quote":{
        //          "best_bid_price":"2490.8",
        //          "best_bid_size":"9.0515",
        //          "best_ask_price":"2490.81",
        //          "best_ask_size":"4.8486",
        //          "trade_price":"2490.39",
        //          "trade_qty":"0.9508",
        //          "index_price":"2490.5",
        //          "mark_price":"2490.8",
        //          "settlement_price":"2490.81",
        //          "limit_up":"2615.42",
        //          "limit_down":"2366.34",
        //          "predicted_funding":"0.000009",
        //          "timestamp":"2024-02-10T16:07:39.454Z"
        //       }
        //    }
        //
        object marketId = this.safeString(market, "symbol");
        object baseId = this.safeString(market, "base_asset_name");
        object quoteId = this.safeString(market, "quote_asset_name");
        object typeId = this.safeString(market, "type"); // 'SPOT', 'PERP'
        object isSpot = (isEqual(typeId, "SPOT"));
        object fees = this.fees;
        object symbol = add(add(baseId, "/"), quoteId);
        object settleId = null;
        if (!isTrue(isSpot))
        {
            settleId = quoteId;
            symbol = add(symbol, add(":", quoteId));
        }
        return new Dictionary<string, object>() {
            { "id", marketId },
            { "lowercaseId", ((string)marketId).ToLower() },
            { "symbol", symbol },
            { "base", baseId },
            { "quote", quoteId },
            { "settle", ((bool) isTrue(settleId)) ? settleId : null },
            { "baseId", baseId },
            { "quoteId", quoteId },
            { "settleId", ((bool) isTrue(settleId)) ? settleId : null },
            { "type", ((bool) isTrue(isSpot)) ? "spot" : "swap" },
            { "spot", isSpot },
            { "margin", false },
            { "swap", !isTrue(isSpot) },
            { "future", false },
            { "option", false },
            { "active", isEqual(this.safeString(market, "trading_state"), "TRADING") },
            { "contract", !isTrue(isSpot) },
            { "linear", ((bool) isTrue(isSpot)) ? null : (isEqual(settleId, quoteId)) },
            { "inverse", ((bool) isTrue(isSpot)) ? null : (!isEqual(settleId, quoteId)) },
            { "taker", getValue(getValue(fees, "trading"), "taker") },
            { "maker", getValue(getValue(fees, "trading"), "maker") },
            { "contractSize", ((bool) isTrue(isSpot)) ? null : 1 },
            { "expiry", null },
            { "expiryDatetime", null },
            { "strike", null },
            { "optionType", null },
            { "precision", new Dictionary<string, object>() {
                { "amount", this.safeNumber(market, "base_increment") },
                { "price", this.safeNumber(market, "quote_increment") },
                { "cost", this.safeNumber(market, "quote_increment") },
            } },
            { "limits", new Dictionary<string, object>() {
                { "leverage", new Dictionary<string, object>() {
                    { "min", null },
                    { "max", this.safeNumber(market, "base_imf") },
                } },
                { "amount", new Dictionary<string, object>() {
                    { "min", null },
                    { "max", ((bool) isTrue(isSpot)) ? null : this.safeNumber(market, "position_limit_qty") },
                } },
                { "price", new Dictionary<string, object>() {
                    { "min", null },
                    { "max", null },
                } },
                { "cost", new Dictionary<string, object>() {
                    { "min", this.safeNumber(market, "min_notional_value") },
                    { "max", null },
                } },
            } },
            { "info", market },
            { "created", null },
        };
    }

    public async override Task<object> fetchCurrencies(object parameters = null)
    {
        /**
        * @method
        * @name coinbaseinternational#fetchCurrencies
        * @description fetches all available currencies on an exchange
        * @see https://docs.cloud.coinbase.com/intx/reference/getassets
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} an associative dictionary of currencies
        */
        parameters ??= new Dictionary<string, object>();
        object currencies = await this.v1PublicGetAssets(parameters);
        //
        //    [
        //        {
        //           "asset_id":"1",
        //           "asset_uuid":"2b92315d-eab7-5bef-84fa-089a131333f5",
        //           "asset_name":"USDC",
        //           "status":"ACTIVE",
        //           "collateral_weight":1.0,
        //           "supported_networks_enabled":true
        //        },
        //        ...
        //    ]
        //
        object result = new Dictionary<string, object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(currencies)); postFixIncrement(ref i))
        {
            object currency = this.parseCurrency(getValue(currencies, i));
            ((IDictionary<string,object>)result)[(string)getValue(currency, "code")] = currency;
        }
        return result;
    }

    public virtual object parseCurrency(object currency)
    {
        //
        //    {
        //       "asset_id":"1",
        //       "asset_uuid":"2b92315d-eab7-5bef-84fa-089a131333f5",
        //       "asset_name":"USDC",
        //       "status":"ACTIVE",
        //       "collateral_weight":1.0,
        //       "supported_networks_enabled":true
        //    }
        //
        object id = this.safeString(currency, "asset_name");
        object code = this.safeCurrencyCode(id);
        object statusId = this.safeString(currency, "status");
        return new Dictionary<string, object>() {
            { "id", id },
            { "name", code },
            { "code", code },
            { "precision", null },
            { "info", currency },
            { "active", (isEqual(statusId, "ACTIVE")) },
            { "deposit", null },
            { "withdraw", null },
            { "networks", null },
            { "fee", null },
            { "fees", null },
            { "limits", this.limits },
        };
    }

    public async override Task<object> fetchTickers(object symbols = null, object parameters = null)
    {
        /**
        * @method
        * @name coinbaseinternational#fetchTickers
        * @description fetches price tickers for multiple markets, statistical information calculated over the past 24 hours for each market
        * @see https://docs.cloud.coinbase.com/intx/reference/getinstruments
        * @param {string[]|undefined} symbols unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/#/?id=ticker-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        symbols = this.marketSymbols(symbols);
        object instruments = await this.v1PublicGetInstruments(parameters);
        object tickers = new Dictionary<string, object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(instruments)); postFixIncrement(ref i))
        {
            object instrument = getValue(instruments, i);
            object marketId = this.safeString(instrument, "symbol");
            object symbol = this.safeSymbol(marketId);
            object quote = this.safeDict(instrument, "quote", new Dictionary<string, object>() {});
            ((IDictionary<string,object>)tickers)[(string)symbol] = this.parseTicker(quote, this.safeMarket(marketId));
        }
        return this.filterByArray(tickers, "symbol", symbols, true);
    }

    public async override Task<object> fetchTicker(object symbol, object parameters = null)
    {
        /**
        * @method
        * @name coinbaseinternational#fetchTicker
        * @description fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
        * @see https://docs.cloud.coinbase.com/intx/reference/getinstrumentquote
        * @param {string} symbol unified symbol of the market to fetch the ticker for
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "instrument", this.marketId(symbol) },
        };
        object ticker = await this.v1PublicGetInstrumentsInstrumentQuote(this.extend(request, parameters));
        return this.parseTicker(ticker, market);
    }

    public override object parseTicker(object ticker, object market = null)
    {
        //
        //    {
        //        "best_bid_price":"2490.8",
        //        "best_bid_size":"9.0515",
        //        "best_ask_price":"2490.81",
        //        "best_ask_size":"4.8486",
        //        "trade_price":"2490.39",
        //        "trade_qty":"0.9508",
        //        "index_price":"2490.5",
        //        "mark_price":"2490.8",
        //        "settlement_price":"2490.81",
        //        "limit_up":"2615.42",
        //        "limit_down":"2366.34",
        //        "predicted_funding":"0.000009",
        //        "timestamp":"2024-02-10T16:07:39.454Z"
        //    }
        //
        object datetime = this.safeString(ticker, "timestamp");
        return this.safeTicker(new Dictionary<string, object>() {
            { "info", ticker },
            { "symbol", this.safeSymbol(null, market) },
            { "timestamp", this.parse8601(datetime) },
            { "datetime", datetime },
            { "bid", this.safeNumber(ticker, "best_bid_price") },
            { "bidVolume", this.safeNumber(ticker, "best_bid_size") },
            { "ask", this.safeNumber(ticker, "best_ask_price") },
            { "askVolume", this.safeNumber(ticker, "best_ask_size") },
            { "high", null },
            { "low", null },
            { "open", null },
            { "close", null },
            { "last", null },
            { "change", null },
            { "percentage", null },
            { "average", null },
            { "vwap", null },
            { "baseVolume", null },
            { "quoteVolume", null },
            { "previousClose", null },
        });
    }

    public async override Task<object> fetchBalance(object parameters = null)
    {
        /**
        * @method
        * @name coinbaseinternational#fetchBalance
        * @description query for balance and get the amount of funds available for trading or funds locked in orders
        * @see https://docs.cloud.coinbase.com/intx/reference/getportfoliobalances
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {boolean} [params.v3] default false, set true to use v3 api endpoint
        * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object portfolio = null;
        var portfolioparametersVariable = await this.handlePortfolioAndParams("fetchBalance", parameters);
        portfolio = ((IList<object>)portfolioparametersVariable)[0];
        parameters = ((IList<object>)portfolioparametersVariable)[1];
        object request = new Dictionary<string, object>() {
            { "portfolio", portfolio },
        };
        object balances = await this.v1PrivateGetPortfoliosPortfolioBalances(this.extend(request, parameters));
        //
        //    [
        //        {
        //           "asset_id":"0-0-1",
        //           "asset_name":"USDC",
        //           "asset_uuid":"2b92315d-eab7-5bef-84fa-089a131333f5",
        //           "quantity":"500000.0000000000",
        //           "hold":"0",
        //           "hold_available_for_collateral":"0",
        //           "transfer_hold":"0",
        //           "collateral_value":"500000.0",
        //           "max_withdraw_amount":"500000.0000000000",
        //           "loan":"0",
        //           "loan_collateral_requirement":"0.0"
        //        }
        //    ]
        //
        return this.parseBalance(balances);
    }

    public override object parseBalance(object response)
    {
        //
        //    {
        //       "asset_id":"0-0-1",
        //       "asset_name":"USDC",
        //       "asset_uuid":"2b92315d-eab7-5bef-84fa-089a131333f5",
        //       "quantity":"500000.0000000000",
        //       "hold":"0",
        //       "hold_available_for_collateral":"0",
        //       "transfer_hold":"0",
        //       "collateral_value":"500000.0",
        //       "max_withdraw_amount":"500000.0000000000",
        //       "loan":"0",
        //       "loan_collateral_requirement":"0.0"
        //    }
        //
        object result = new Dictionary<string, object>() {
            { "info", response },
        };
        for (object i = 0; isLessThan(i, getArrayLength(response)); postFixIncrement(ref i))
        {
            object rawBalance = getValue(response, i);
            object currencyId = this.safeString(rawBalance, "asset_name");
            object code = this.safeCurrencyCode(currencyId);
            object account = this.account();
            ((IDictionary<string,object>)account)["total"] = this.safeString(rawBalance, "quantity");
            ((IDictionary<string,object>)account)["used"] = this.safeString(rawBalance, "hold");
            ((IDictionary<string,object>)result)[(string)code] = account;
        }
        return this.safeBalance(result);
    }

    public async override Task<object> transfer(object code, object amount, object fromAccount, object toAccount, object parameters = null)
    {
        /**
        * @method
        * @name coinbaseinternational#transfer
        * @description Transfer an amount of asset from one portfolio to another.
        * @see https://docs.cloud.coinbase.com/intx/reference/createportfolioassettransfer
        * @param {string} code unified currency code
        * @param {float} amount amount to transfer
        * @param {string} fromAccount account to transfer from
        * @param {string} toAccount account to transfer to
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [transfer structure]{@link https://github.com/ccxt/ccxt/wiki/Manual#transfer-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "asset", getValue(currency, "id") },
            { "ammount", amount },
            { "from", fromAccount },
            { "to", toAccount },
        };
        object response = await this.v1PrivatePostPortfoliosTransfer(this.extend(request, parameters));
        object success = this.safeBool(response, "success");
        return new Dictionary<string, object>() {
            { "info", response },
            { "id", null },
            { "timestamp", null },
            { "datetime", null },
            { "currency", code },
            { "amount", amount },
            { "fromAccount", fromAccount },
            { "toAccount", toAccount },
            { "status", ((bool) isTrue(success)) ? "ok" : "failed" },
        };
    }

    public async override Task<object> createOrder(object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        /**
        * @method
        * @name coinbaseinternational#createOrder
        * @description create a trade order
        * @see https://docs.cloud.coinbase.com/intx/reference/createorder
        * @param {string} symbol unified symbol of the market to create an order in
        * @param {string} type 'market' or 'limit'
        * @param {string} side 'buy' or 'sell'
        * @param {float} amount how much you want to trade in units of the base currency, quote currency for 'market' 'buy' orders
        * @param {float} [price] the price to fulfill the order, in units of the quote currency, ignored in market orders
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {float} [params.stopPrice] price to trigger stop orders
        * @param {float} [params.triggerPrice] price to trigger stop orders
        * @param {float} [params.stopLossPrice] price to trigger stop-loss orders
        * @param {bool} [params.postOnly] true or false
        * @param {string} [params.tif] 'GTC', 'IOC', 'GTD' default is 'GTC' for limit orders and 'IOC' for market orders
        * @param {string} [params.expire_time] The expiration time required for orders with the time in force set to GTT. Must not go beyond 30 days of the current time. Uses ISO-8601 format (e.g., 2023-03-16T23:59:53Z)
        * @param {string} [params.stp_mode] Possible values: [NONE, AGGRESSING, BOTH] Specifies the behavior for self match handling. None disables the functionality, new cancels the newest order, and both cancels both orders.
        * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object typeId = ((string)type).ToUpper();
        object stopPrice = this.safeNumberN(parameters, new List<object>() {"triggerPrice", "stopPrice", "stop_price"});
        object clientOrderIdprefix = this.safeString(this.options, "brokerId", "nfqkvdjp");
        object clientOrderId = add(add(clientOrderIdprefix, "-"), this.uuid());
        clientOrderId = slice(clientOrderId, 0, 17);
        object request = new Dictionary<string, object>() {
            { "client_order_id", clientOrderId },
            { "side", ((string)side).ToUpper() },
            { "instrument", getValue(market, "id") },
            { "size", this.amountToPrecision(getValue(market, "symbol"), amount) },
        };
        if (isTrue(!isEqual(stopPrice, null)))
        {
            if (isTrue(isEqual(type, "limit")))
            {
                typeId = "STOP_LIMIT";
            } else
            {
                typeId = "STOP";
            }
            ((IDictionary<string,object>)request)["stop_price"] = stopPrice;
        }
        ((IDictionary<string,object>)request)["type"] = typeId;
        if (isTrue(isEqual(type, "limit")))
        {
            if (isTrue(isEqual(price, null)))
            {
                throw new InvalidOrder ((string)add(this.id, "createOrder() requires a price parameter for a limit order types")) ;
            }
            ((IDictionary<string,object>)request)["price"] = price;
        }
        object portfolio = null;
        var portfolioparametersVariable = await this.handlePortfolioAndParams("createOrder", parameters);
        portfolio = ((IList<object>)portfolioparametersVariable)[0];
        parameters = ((IList<object>)portfolioparametersVariable)[1];
        if (isTrue(!isEqual(portfolio, null)))
        {
            ((IDictionary<string,object>)request)["portfolio"] = portfolio;
        }
        object postOnly = this.safeBool2(parameters, "postOnly", "post_only");
        object tif = this.safeString2(parameters, "tif", "timeInForce");
        // market orders must be IOC
        if (isTrue(isEqual(typeId, "MARKET")))
        {
            if (isTrue(isTrue(!isEqual(tif, null)) && isTrue(!isEqual(tif, "IOC"))))
            {
                throw new InvalidOrder ((string)add(this.id, "createOrder() market orders must have tif set to \"IOC\"")) ;
            }
            tif = "IOC";
        } else
        {
            tif = ((bool) isTrue((isEqual(tif, null)))) ? "GTC" : tif;
        }
        if (isTrue(!isEqual(postOnly, null)))
        {
            ((IDictionary<string,object>)request)["post_only"] = postOnly;
        }
        ((IDictionary<string,object>)request)["tif"] = tif;
        parameters = this.omit(parameters, new List<object>() {"client_order_id", "user", "postOnly", "timeInForce"});
        object response = await this.v1PrivatePostOrders(this.extend(request, parameters));
        //
        //    {
        //        "order_id":"1x96skvg-1-0",
        //        "client_order_id":"ccxt",
        //        "side":"BUY",
        //        "instrument_id":"114jqr89-0-0",
        //        "instrument_uuid":"b3469e0b-222c-4f8a-9f68-1f9e44d7e5e0",
        //        "symbol":"BTC-PERP",
        //        "portfolio_id":"1wp37qsc-1-0",
        //        "portfolio_uuid":"018d7f6c-b92c-7361-8b7e-2932711e5a22",
        //        "type":"LIMIT",
        //        "price":"10000",
        //        "size":"0.001",
        //        "tif":"GTC",
        //        "stp_mode":"BOTH",
        //        "event_type":"NEW",
        //        "order_status":"WORKING",
        //        "leaves_qty":"0.001",
        //        "exec_qty":"0",
        //        "avg_price":"0",
        //        "fee":"0"
        //    }
        //
        return this.parseOrder(response, market);
    }

    public override object parseOrder(object order, object market = null)
    {
        //
        //    {
        //        "order_id":"1x96skvg-1-0",
        //        "client_order_id":"ccxt",
        //        "side":"BUY",
        //        "instrument_id":"114jqr89-0-0",
        //        "instrument_uuid":"b3469e0b-222c-4f8a-9f68-1f9e44d7e5e0",
        //        "symbol":"BTC-PERP",
        //        "portfolio_id":"1wp37qsc-1-0",
        //        "portfolio_uuid":"018d7f6c-b92c-7361-8b7e-2932711e5a22",
        //        "type":"LIMIT",
        //        "price":"10000",
        //        "size":"0.001",
        //        "tif":"GTC",
        //        "stp_mode":"BOTH",
        //        "event_type":"NEW",
        //        "order_status":"WORKING",
        //        "leaves_qty":"0.001",
        //        "exec_qty":"0",
        //        "avg_price":"0",
        //        "fee":"0"
        //    }
        //
        object marketId = this.safeString(order, "symbol");
        object feeCost = this.safeNumber(order, "fee");
        object fee = null;
        if (isTrue(!isEqual(feeCost, null)))
        {
            fee = new Dictionary<string, object>() {
                { "cost", feeCost },
            };
        }
        object datetime = this.safeString2(order, "submit_time", "event_time");
        return this.safeOrder(new Dictionary<string, object>() {
            { "info", order },
            { "id", this.safeString(order, "order_id") },
            { "clientOrderId", this.safeString(order, "client_order_id") },
            { "timestamp", this.parse8601(datetime) },
            { "datetime", datetime },
            { "lastTradeTimestamp", null },
            { "symbol", this.safeSymbol(marketId, market) },
            { "type", this.parseOrderType(this.safeString(order, "type")) },
            { "timeInForce", this.safeString(order, "tif") },
            { "postOnly", null },
            { "side", this.safeStringLower(order, "side") },
            { "price", this.safeString(order, "price") },
            { "stopPrice", this.safeString(order, "stop_price") },
            { "triggerPrice", this.safeString(order, "stop_price") },
            { "amount", this.safeString(order, "size") },
            { "filled", this.safeString(order, "exec_qty") },
            { "remaining", this.safeString(order, "leaves_qty") },
            { "cost", null },
            { "average", this.safeString(order, "avg_price") },
            { "status", this.parseOrderStatus(this.safeString(order, "order_status")) },
            { "fee", fee },
            { "trades", null },
        }, market);
    }

    public virtual object parseOrderStatus(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "NEW", "open" },
            { "PARTIAL_FILLED", "open" },
            { "FILLED", "closed" },
            { "CANCELED", "canceled" },
            { "REPLACED", "canceled" },
            { "PENDING_CANCEL", "open" },
            { "REJECTED", "rejected" },
            { "PENDING_NEW", "open" },
            { "EXPIRED", "expired" },
            { "PENDING_REPLACE", "open" },
        };
        return this.safeString(statuses, status, status);
    }

    public virtual object parseOrderType(object type)
    {
        if (isTrue(isEqual(type, "UNKNOWN_ORDER_TYPE")))
        {
            return null;
        }
        object types = new Dictionary<string, object>() {
            { "MARKET", "market" },
            { "LIMIT", "limit" },
            { "STOP", "limit" },
            { "STOP_LIMIT", "limit" },
        };
        return this.safeString(types, type, type);
    }

    public async override Task<object> cancelOrder(object id, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name coinbaseinternational#cancelOrder
        * @description cancels an open order
        * @see https://docs.cloud.coinbase.com/intx/reference/cancelorder
        * @param {string} id order id
        * @param {string} symbol not used by coinbaseinternational cancelOrder()
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object portfolio = null;
        var portfolioparametersVariable = await this.handlePortfolioAndParams("cancelOrder", parameters);
        portfolio = ((IList<object>)portfolioparametersVariable)[0];
        parameters = ((IList<object>)portfolioparametersVariable)[1];
        object request = new Dictionary<string, object>() {
            { "portfolio", portfolio },
            { "id", id },
        };
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
        }
        object orders = await this.v1PrivateDeleteOrdersId(this.extend(request, parameters));
        //
        //    {
        //        "order_id":"1x96skvg-1-0",
        //        "client_order_id":"ccxt",
        //        "side":"BUY",
        //        "instrument_id":"114jqr89-0-0",
        //        "instrument_uuid":"b3469e0b-222c-4f8a-9f68-1f9e44d7e5e0",
        //        "symbol":"BTC-PERP",
        //        "portfolio_id":"1wp37qsc-1-0",
        //        "portfolio_uuid":"018d7f6c-b92c-7361-8b7e-2932711e5a22",
        //        "type":"LIMIT",
        //        "price":"10000",
        //        "size":"0.001",
        //        "tif":"GTC",
        //        "stp_mode":"BOTH",
        //        "event_type":"CANCELED",
        //        "order_status":"DONE",
        //        "leaves_qty":"0.001",
        //        "exec_qty":"0",
        //        "avg_price":"0",
        //        "fee":"0"
        //    }
        //
        return this.parseOrder(orders, market);
    }

    public async override Task<object> cancelAllOrders(object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name coinbaseinternational#cancelAllOrders
        * @description cancel all open orders
        * @param {string} symbol unified market symbol, only orders in the market of this symbol are cancelled when symbol is not undefined
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object portfolio = null;
        var portfolioparametersVariable = await this.handlePortfolioAndParams("cancelAllOrders", parameters);
        portfolio = ((IList<object>)portfolioparametersVariable)[0];
        parameters = ((IList<object>)portfolioparametersVariable)[1];
        object request = new Dictionary<string, object>() {
            { "portfolio", portfolio },
        };
        object market = null;
        if (isTrue(symbol))
        {
            market = this.market(symbol);
            ((IDictionary<string,object>)request)["instrument"] = getValue(market, "id");
        }
        object orders = await this.v1PrivateDeleteOrders(this.extend(request, parameters));
        return this.parseOrders(orders, market);
    }

    public async override Task<object> editOrder(object id, object symbol, object type, object side, object amount = null, object price = null, object parameters = null)
    {
        /**
        * @method
        * @name coinbaseinternational#editOrder
        * @description edit a trade order
        * @see https://docs.cloud.coinbase.com/intx/reference/modifyorder
        * @param {string} id cancel order id
        * @param {string} symbol unified symbol of the market to create an order in
        * @param {string} type 'market' or 'limit'
        * @param {string} side 'buy' or 'sell'
        * @param {float} amount how much of currency you want to trade in units of base currency
        * @param {float} [price] the price at which the order is to be fullfilled, in units of the base currency, ignored in market orders
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {string} params.clientOrderId client order id
        * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "id", id },
        };
        object portfolio = null;
        var portfolioparametersVariable = await this.handlePortfolioAndParams("editOrder", parameters);
        portfolio = ((IList<object>)portfolioparametersVariable)[0];
        parameters = ((IList<object>)portfolioparametersVariable)[1];
        if (isTrue(!isEqual(portfolio, null)))
        {
            ((IDictionary<string,object>)request)["portfolio"] = portfolio;
        }
        if (isTrue(!isEqual(amount, null)))
        {
            ((IDictionary<string,object>)request)["size"] = this.amountToPrecision(symbol, amount);
        }
        if (isTrue(!isEqual(price, null)))
        {
            ((IDictionary<string,object>)request)["price"] = this.priceToPrecision(symbol, price);
        }
        object stopPrice = this.safeNumberN(parameters, new List<object>() {"stopPrice", "stop_price", "triggerPrice"});
        if (isTrue(!isEqual(stopPrice, null)))
        {
            ((IDictionary<string,object>)request)["stop_price"] = stopPrice;
        }
        object clientOrderId = this.safeString2(parameters, "client_order_id", "clientOrderId");
        if (isTrue(isEqual(clientOrderId, null)))
        {
            throw new BadRequest ((string)add(this.id, " editOrder() requires a clientOrderId parameter")) ;
        }
        ((IDictionary<string,object>)request)["client_order_id"] = clientOrderId;
        object order = await this.v1PrivatePutOrdersId(this.extend(request, parameters));
        return this.parseOrder(order, market);
    }

    public async override Task<object> fetchOrder(object id, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name coinbaseinternational#fetchOrder
        * @description fetches information on an order made by the user
        * @see https://docs.cloud.coinbase.com/intx/reference/modifyorder
        * @param {string} id the order id
        * @param {string} symbol unified market symbol that the order was made in
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
        }
        object portfolio = null;
        var portfolioparametersVariable = await this.handlePortfolioAndParams("fetchOrder", parameters);
        portfolio = ((IList<object>)portfolioparametersVariable)[0];
        parameters = ((IList<object>)portfolioparametersVariable)[1];
        object request = new Dictionary<string, object>() {
            { "id", id },
            { "portfolio", portfolio },
        };
        object order = await this.v1PrivateGetOrdersId(this.extend(request, parameters));
        //
        //    {
        //        "order_id":"1x96skvg-1-0",
        //        "client_order_id":"ccxt",
        //        "side":"BUY",
        //        "instrument_id":"114jqr89-0-0",
        //        "instrument_uuid":"b3469e0b-222c-4f8a-9f68-1f9e44d7e5e0",
        //        "symbol":"BTC-PERP",
        //        "portfolio_id":"1wp37qsc-1-0",
        //        "portfolio_uuid":"018d7f6c-b92c-7361-8b7e-2932711e5a22",
        //        "type":"LIMIT",
        //        "price":"10000",
        //        "size":"0.001",
        //        "tif":"GTC",
        //        "stp_mode":"BOTH",
        //        "event_type":"NEW",
        //        "event_time":"2024-02-14T03:25:14Z",
        //        "submit_time":"2024-02-14T03:25:13.999Z",
        //        "order_status":"WORKING",
        //        "leaves_qty":"0.001",
        //        "exec_qty":"0",
        //        "avg_price":"0",
        //        "fee":"0"
        //    }
        //
        return this.parseOrder(order, market);
    }

    public async override Task<object> fetchOpenOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name coinbaseinternational#fetchOpenOrders
        * @description fetches information on all currently open orders
        * @see https://docs.cloud.coinbase.com/intx/reference/getorders
        * @param {string} symbol unified market symbol of the orders
        * @param {int} [since] timestamp in ms of the earliest order, default is undefined
        * @param {int} [limit] the maximum number of open order structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [availble parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
        * @param {int} [params.offset] offset
        * @param {string} [params.event_type] The most recent type of event that happened to the order. Allowed values: NEW, TRADE, REPLACED
        * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object portfolio = null;
        var portfolioparametersVariable = await this.handlePortfolioAndParams("fetchOpenOrders", parameters);
        portfolio = ((IList<object>)portfolioparametersVariable)[0];
        parameters = ((IList<object>)portfolioparametersVariable)[1];
        object paginate = false;
        var paginateparametersVariable = this.handleOptionAndParams(parameters, "fetchOpenOrders", "paginate");
        paginate = ((IList<object>)paginateparametersVariable)[0];
        parameters = ((IList<object>)paginateparametersVariable)[1];
        object maxEntriesPerRequest = null;
        var maxEntriesPerRequestparametersVariable = this.handleOptionAndParams(parameters, "fetchOpenOrders", "maxEntriesPerRequest", 100);
        maxEntriesPerRequest = ((IList<object>)maxEntriesPerRequestparametersVariable)[0];
        parameters = ((IList<object>)maxEntriesPerRequestparametersVariable)[1];
        object pageKey = "ccxtPageKey";
        if (isTrue(paginate))
        {
            return await this.fetchPaginatedCallIncremental("fetchOpenOrders", symbol, since, limit, parameters, pageKey, maxEntriesPerRequest);
        }
        object page = subtract(this.safeInteger(parameters, pageKey, 1), 1);
        object request = new Dictionary<string, object>() {
            { "portfolio", portfolio },
            { "result_offset", this.safeInteger2(parameters, "offset", "result_offset", multiply(page, maxEntriesPerRequest)) },
        };
        object market = null;
        if (isTrue(symbol))
        {
            market = this.market(symbol);
            ((IDictionary<string,object>)request)["instrument"] = symbol;
        }
        if (isTrue(!isEqual(limit, null)))
        {
            if (isTrue(isGreaterThan(limit, 100)))
            {
                throw new BadRequest ((string)add(this.id, " fetchOpenOrders() maximum limit is 100")) ;
            }
            ((IDictionary<string,object>)request)["result_limit"] = limit;
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["ref_datetime"] = this.iso8601(since);
        }
        object response = await this.v1PrivateGetOrders(this.extend(request, parameters));
        //
        //    {
        //        "pagination":{
        //           "result_limit":25,
        //           "result_offset":0
        //        },
        //        "results":[
        //           {
        //              "order_id":"1y4cm6b4-1-0",
        //              "client_order_id":"ccxtd0dd4b5d-8e5f-",
        //              "side":"SELL",
        //              "instrument_id":"114jqr89-0-0",
        //              "instrument_uuid":"b3469e0b-222c-4f8a-9f68-1f9e44d7e5e0",
        //              "symbol":"BTC-PERP",
        //              "portfolio_id":"1wp37qsc-1-0",
        //              "portfolio_uuid":"018d7f6c-b92c-7361-8b7e-2932711e5a22",
        //              "type":"LIMIT",
        //              "price":"54000",
        //              "size":"0.01",
        //              "tif":"GTC",
        //              "stp_mode":"BOTH",
        //              "event_type":"NEW",
        //              "event_time":"2024-02-24T16:46:37.413Z",
        //              "submit_time":"2024-02-24T16:46:37.412Z",
        //              "order_status":"WORKING",
        //              "leaves_qty":"0.01",
        //              "exec_qty":"0",
        //              "avg_price":"0",
        //              "fee":"0"
        //           },
        //           ...
        //        ]
        //    }
        //
        object rawOrders = this.safeList(response, "results", new List<object>() {});
        return this.parseOrders(rawOrders, market, since, limit);
    }

    public async override Task<object> fetchMyTrades(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name coinbaseinternational#fetchMyTrades
        * @description fetch all trades made by the user
        * @see https://docs.cloud.coinbase.com/intx/reference/getmultiportfoliofills
        * @param {string} symbol unified market symbol of the trades
        * @param {int} [since] timestamp in ms of the earliest order, default is undefined
        * @param {int} [limit] the maximum number of trade structures to fetch
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {int} [params.until] the latest time in ms to fetch trades for
        * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [availble parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
        * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object paginate = false;
        var paginateparametersVariable = this.handleOptionAndParams(parameters, "fetchMyTrades", "paginate");
        paginate = ((IList<object>)paginateparametersVariable)[0];
        parameters = ((IList<object>)paginateparametersVariable)[1];
        object pageKey = "ccxtPageKey";
        object maxEntriesPerRequest = null;
        var maxEntriesPerRequestparametersVariable = this.handleOptionAndParams(parameters, "fetchMyTrades", "maxEntriesPerRequest", 100);
        maxEntriesPerRequest = ((IList<object>)maxEntriesPerRequestparametersVariable)[0];
        parameters = ((IList<object>)maxEntriesPerRequestparametersVariable)[1];
        if (isTrue(paginate))
        {
            return await this.fetchPaginatedCallIncremental("fetchMyTrades", symbol, since, limit, parameters, pageKey, maxEntriesPerRequest);
        }
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
        }
        object page = subtract(this.safeInteger(parameters, pageKey, 1), 1);
        object request = new Dictionary<string, object>() {
            { "result_offset", this.safeInteger2(parameters, "offset", "result_offset", multiply(page, maxEntriesPerRequest)) },
        };
        if (isTrue(!isEqual(limit, null)))
        {
            if (isTrue(isGreaterThan(limit, 100)))
            {
                throw new BadRequest ((string)add(this.id, " fetchMyTrades() maximum limit is 100. Consider setting paginate to true to fetch more trades.")) ;
            }
            ((IDictionary<string,object>)request)["result_limit"] = limit;
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["time_from"] = this.iso8601(since);
        }
        object until = this.safeStringN(parameters, new List<object>() {"until"});
        if (isTrue(!isEqual(until, null)))
        {
            parameters = this.omit(parameters, new List<object>() {"until"});
            ((IDictionary<string,object>)request)["ref_datetime"] = this.iso8601(until);
        }
        object response = await this.v1PrivateGetPortfoliosFills(this.extend(request, parameters));
        //
        //    {
        //        "pagination":{
        //           "result_limit":25,
        //           "result_offset":0
        //        },
        //        "results":[
        //           {
        //              "portfolio_id":"1wp37qsc-1-0",
        //              "portfolio_uuid":"018d7f6c-b92c-7361-8b7e-2932711e5a22",
        //              "portfolio_name":"CCXT Portfolio 020624-17:16",
        //              "fill_id":"1xbfy19y-1-184",
        //              "exec_id":"280841526207070392",
        //              "order_id":"1xbfv8yw-1-0",
        //              "instrument_id":"114jqr89-0-0",
        //              "instrument_uuid":"b3469e0b-222c-4f8a-9f68-1f9e44d7e5e0",
        //              "symbol":"BTC-PERP",
        //              "match_id":"280841526207053840",
        //              "fill_price":"52500",
        //              "fill_qty":"0.01",
        //              "client_id":"1x59ctku-1-1",
        //              "client_order_id":"ccxt3e4e2a5f-4a89-",
        //              "order_qty":"0.01",
        //              "limit_price":"52500",
        //              "total_filled":"0.01",
        //              "filled_vwap":"52500",
        //              "expire_time":"",
        //              "stop_price":"",
        //              "side":"BUY",
        //              "tif":"GTC",
        //              "stp_mode":"BOTH",
        //              "flags":"",
        //              "fee":"0.105",
        //              "fee_asset":"USDC",
        //              "order_status":"DONE",
        //              "event_time":"2024-02-15T00:43:57.631Z"
        //           },
        //        ]
        //    }
        //
        object trades = this.safeList(response, "results", new List<object>() {});
        return this.parseTrades(trades, market, since, limit);
    }

    public async override Task<object> withdraw(object code, object amount, object address, object tag = null, object parameters = null)
    {
        /**
        * @method
        * @name coinbaseinternational#withdraw
        * @description make a withdrawal
        * @see https://docs.cloud.coinbase.com/intx/reference/withdraw
        * @see https://docs.cloud.coinbase.com/intx/reference/counterpartywithdraw
        * @param {string} code unified currency code
        * @param {float} amount the amount to withdraw
        * @param {string} address the address to withdraw to
        * @param {string} [tag] an optional tag for the withdrawal
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {boolean} [params.add_network_fee_to_total] if true, deducts network fee from the portfolio, otherwise deduct fee from the withdrawal
        * @param {string} [params.network_arn_id] Identifies the blockchain network (e.g., networks/ethereum-mainnet/assets/313ef8a9-ae5a-5f2f-8a56-572c0e2a4d5a)
        * @param {string} [params.nonce] a unique integer representing the withdrawal request
        * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
        */
        parameters ??= new Dictionary<string, object>();
        var tagparametersVariable = this.handleWithdrawTagAndParams(tag, parameters);
        tag = ((IList<object>)tagparametersVariable)[0];
        parameters = ((IList<object>)tagparametersVariable)[1];
        this.checkAddress(address);
        await this.loadMarkets();
        object currency = this.currency(code);
        object portfolio = null;
        var portfolioparametersVariable = await this.handlePortfolioAndParams("withdraw", parameters);
        portfolio = ((IList<object>)portfolioparametersVariable)[0];
        parameters = ((IList<object>)portfolioparametersVariable)[1];
        object method = null;
        var methodparametersVariable = this.handleOptionAndParams(parameters, "withdraw", "method", "v1PrivatePostTransfersWithdraw");
        method = ((IList<object>)methodparametersVariable)[0];
        parameters = ((IList<object>)methodparametersVariable)[1];
        object networkId = null;
        var networkIdparametersVariable = await this.handleNetworkIdAndParams(code, "withdraw", parameters);
        networkId = ((IList<object>)networkIdparametersVariable)[0];
        parameters = ((IList<object>)networkIdparametersVariable)[1];
        object request = new Dictionary<string, object>() {
            { "portfolio", portfolio },
            { "type", "send" },
            { "asset", getValue(currency, "id") },
            { "address", address },
            { "amount", amount },
            { "currency", getValue(currency, "id") },
            { "network_arn_id", networkId },
            { "nonce", this.nonce() },
        };
        object response = await ((Task<object>)callDynamically(this, method, new object[] { this.extend(request, parameters) }));
        //
        //    {
        //        "idem":"8e471d77-4208-45a8-9e5b-f3bd8a2c1fc3"
        //    }
        //
        return this.parseTransaction(response, currency);
    }

    public virtual object safeNetwork(object network)
    {
        object withdrawEnabled = this.safeBool(network, "withdraw");
        object depositEnabled = this.safeBool(network, "deposit");
        object limits = this.safeDict(network, "limits");
        object withdraw = this.safeDict(limits, "withdraw");
        object withdrawMax = this.safeNumber(withdraw, "max");
        object deposit = this.safeDict(limits, "deposit");
        object depositMax = this.safeNumber(deposit, "max");
        if (isTrue(isTrue(isEqual(withdrawEnabled, null)) && isTrue(!isEqual(withdrawMax, null))))
        {
            withdrawEnabled = (isGreaterThan(withdrawMax, 0));
        }
        if (isTrue(isTrue(isEqual(depositEnabled, null)) && isTrue(!isEqual(depositMax, null))))
        {
            depositEnabled = (isGreaterThan(depositMax, 0));
        }
        object networkId = this.safeString(network, "id");
        object isEnabled = (isTrue(withdrawEnabled) && isTrue(depositEnabled));
        return new Dictionary<string, object>() {
            { "info", getValue(network, "info") },
            { "id", networkId },
            { "name", this.safeString(network, "name") },
            { "network", this.safeString(network, "network") },
            { "active", this.safeBool(network, "active", isEnabled) },
            { "deposit", depositEnabled },
            { "withdraw", withdrawEnabled },
            { "fee", this.safeNumber(network, "fee") },
            { "precision", this.safeNumber(network, "precision") },
            { "limits", new Dictionary<string, object>() {
                { "withdraw", new Dictionary<string, object>() {
                    { "min", this.safeNumber(withdraw, "min") },
                    { "max", withdrawMax },
                } },
                { "deposit", new Dictionary<string, object>() {
                    { "min", this.safeNumber(deposit, "min") },
                    { "max", depositMax },
                } },
            } },
        };
    }

    public override object sign(object path, object api = null, object method = null, object parameters = null, object headers = null, object body = null)
    {
        api ??= new List<object>();
        method ??= "GET";
        parameters ??= new Dictionary<string, object>();
        object version = getValue(api, 0);
        object signed = isEqual(getValue(api, 1), "private");
        object fullPath = add(add(add("/", version), "/"), this.implodeParams(path, parameters));
        object query = this.omit(parameters, this.extractParams(path));
        object savedPath = add("/api", fullPath);
        if (isTrue(isTrue(isEqual(method, "GET")) || isTrue(isEqual(method, "DELETE"))))
        {
            if (isTrue(getArrayLength(new List<object>(((IDictionary<string,object>)query).Keys))))
            {
                fullPath = add(fullPath, add("?", this.urlencodeWithArrayRepeat(query)));
            }
        }
        object url = add(getValue(getValue(this.urls, "api"), "rest"), fullPath);
        if (isTrue(signed))
        {
            this.checkRequiredCredentials();
            object nonce = ((object)this.nonce()).ToString();
            object payload = "";
            if (isTrue(!isEqual(method, "GET")))
            {
                if (isTrue(getArrayLength(new List<object>(((IDictionary<string,object>)query).Keys))))
                {
                    body = this.json(query);
                    payload = body;
                }
            }
            object auth = add(add(add(nonce, method), savedPath), payload);
            object signature = this.hmac(this.encode(auth), this.base64ToBinary(this.secret), sha256, "base64");
            headers = new Dictionary<string, object>() {
                { "CB-ACCESS-TIMESTAMP", nonce },
                { "CB-ACCESS-SIGN", signature },
                { "CB-ACCESS-PASSPHRASE", this.password },
                { "CB-ACCESS-KEY", this.apiKey },
            };
        }
        return new Dictionary<string, object>() {
            { "url", url },
            { "method", method },
            { "body", body },
            { "headers", headers },
        };
    }

    public override object handleErrors(object code, object reason, object url, object method, object headers, object body, object response, object requestHeaders, object requestBody)
    {
        //
        //    {
        //        "title":"io.javalin.http.BadRequestResponse: Order rejected (DUPLICATE_CLIENT_ORDER_ID - duplicate client order id detected)",
        //        "status":400
        //    }
        //
        if (isTrue(isEqual(response, null)))
        {
            return null;  // fallback to default error handler
        }
        object feedback = add(add(this.id, " "), body);
        object errMsg = this.safeString(response, "title");
        if (isTrue(!isEqual(errMsg, null)))
        {
            this.throwExactlyMatchedException(getValue(this.exceptions, "exact"), errMsg, feedback);
            this.throwBroadlyMatchedException(getValue(this.exceptions, "broad"), errMsg, feedback);
            throw new ExchangeError ((string)feedback) ;
        }
        return null;
    }
}
