namespace ccxt;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

public partial class bitstamp : Exchange
{
    public override object describe()
    {
        return this.deepExtend(base.describe(), new Dictionary<string, object>() {
            { "id", "bitstamp" },
            { "name", "Bitstamp" },
            { "countries", new List<object>() {"GB"} },
            { "rateLimit", 75 },
            { "version", "v2" },
            { "userAgent", getValue(this.userAgents, "chrome") },
            { "pro", true },
            { "has", new Dictionary<string, object>() {
                { "CORS", true },
                { "spot", true },
                { "margin", false },
                { "swap", false },
                { "future", false },
                { "option", false },
                { "addMargin", false },
                { "cancelAllOrders", true },
                { "cancelOrder", true },
                { "closeAllPositions", false },
                { "closePosition", false },
                { "createOrder", true },
                { "createReduceOnlyOrder", false },
                { "createStopLimitOrder", false },
                { "createStopMarketOrder", false },
                { "createStopOrder", false },
                { "fetchBalance", true },
                { "fetchBorrowRateHistories", false },
                { "fetchBorrowRateHistory", false },
                { "fetchCrossBorrowRate", false },
                { "fetchCrossBorrowRates", false },
                { "fetchCurrencies", true },
                { "fetchDepositAddress", true },
                { "fetchDepositsWithdrawals", true },
                { "fetchDepositWithdrawFee", "emulated" },
                { "fetchDepositWithdrawFees", true },
                { "fetchFundingHistory", false },
                { "fetchFundingRate", false },
                { "fetchFundingRateHistory", false },
                { "fetchFundingRates", false },
                { "fetchIndexOHLCV", false },
                { "fetchIsolatedBorrowRate", false },
                { "fetchIsolatedBorrowRates", false },
                { "fetchLedger", true },
                { "fetchLeverage", false },
                { "fetchMarginMode", false },
                { "fetchMarkets", true },
                { "fetchMarkOHLCV", false },
                { "fetchMyTrades", true },
                { "fetchOHLCV", true },
                { "fetchOpenInterestHistory", false },
                { "fetchOpenOrders", true },
                { "fetchOrder", true },
                { "fetchOrderBook", true },
                { "fetchPosition", false },
                { "fetchPositionHistory", false },
                { "fetchPositionMode", false },
                { "fetchPositions", false },
                { "fetchPositionsForSymbol", false },
                { "fetchPositionsHistory", false },
                { "fetchPositionsRisk", false },
                { "fetchPremiumIndexOHLCV", false },
                { "fetchTicker", true },
                { "fetchTickers", true },
                { "fetchTrades", true },
                { "fetchTradingFee", true },
                { "fetchTradingFees", true },
                { "fetchTransactionFees", true },
                { "fetchTransactions", "emulated" },
                { "fetchWithdrawals", true },
                { "reduceMargin", false },
                { "setLeverage", false },
                { "setMarginMode", false },
                { "setPositionMode", false },
                { "transfer", true },
                { "withdraw", true },
            } },
            { "urls", new Dictionary<string, object>() {
                { "logo", "https://user-images.githubusercontent.com/1294454/27786377-8c8ab57e-5fe9-11e7-8ea4-2b05b6bcceec.jpg" },
                { "api", new Dictionary<string, object>() {
                    { "public", "https://www.bitstamp.net/api" },
                    { "private", "https://www.bitstamp.net/api" },
                } },
                { "www", "https://www.bitstamp.net" },
                { "doc", "https://www.bitstamp.net/api" },
            } },
            { "timeframes", new Dictionary<string, object>() {
                { "1m", "60" },
                { "3m", "180" },
                { "5m", "300" },
                { "15m", "900" },
                { "30m", "1800" },
                { "1h", "3600" },
                { "2h", "7200" },
                { "4h", "14400" },
                { "6h", "21600" },
                { "12h", "43200" },
                { "1d", "86400" },
                { "1w", "259200" },
            } },
            { "requiredCredentials", new Dictionary<string, object>() {
                { "apiKey", true },
                { "secret", true },
            } },
            { "api", new Dictionary<string, object>() {
                { "public", new Dictionary<string, object>() {
                    { "get", new Dictionary<string, object>() {
                        { "ohlc/{pair}/", 1 },
                        { "order_book/{pair}/", 1 },
                        { "ticker/", 1 },
                        { "ticker_hour/{pair}/", 1 },
                        { "ticker/{pair}/", 1 },
                        { "transactions/{pair}/", 1 },
                        { "trading-pairs-info/", 1 },
                        { "currencies/", 1 },
                        { "eur_usd/", 1 },
                        { "travel_rule/vasps/", 1 },
                    } },
                } },
                { "private", new Dictionary<string, object>() {
                    { "get", new Dictionary<string, object>() {
                        { "travel_rule/contacts/", 1 },
                        { "contacts/{contact_uuid}/", 1 },
                        { "earn/subscriptions/", 1 },
                        { "earn/transactions/", 1 },
                    } },
                    { "post", new Dictionary<string, object>() {
                        { "account_balances/", 1 },
                        { "account_balances/{currency}/", 1 },
                        { "balance/", 1 },
                        { "balance/{pair}/", 1 },
                        { "bch_withdrawal/", 1 },
                        { "bch_address/", 1 },
                        { "user_transactions/", 1 },
                        { "user_transactions/{pair}/", 1 },
                        { "crypto-transactions/", 1 },
                        { "open_orders/all/", 1 },
                        { "open_orders/{pair}/", 1 },
                        { "order_status/", 1 },
                        { "cancel_order/", 1 },
                        { "cancel_all_orders/", 1 },
                        { "cancel_all_orders/{pair}/", 1 },
                        { "buy/{pair}/", 1 },
                        { "buy/market/{pair}/", 1 },
                        { "buy/instant/{pair}/", 1 },
                        { "sell/{pair}/", 1 },
                        { "sell/market/{pair}/", 1 },
                        { "sell/instant/{pair}/", 1 },
                        { "transfer-to-main/", 1 },
                        { "transfer-from-main/", 1 },
                        { "my_trading_pairs/", 1 },
                        { "fees/trading/", 1 },
                        { "fees/trading/{market_symbol}", 1 },
                        { "fees/withdrawal/", 1 },
                        { "fees/withdrawal/{currency}/", 1 },
                        { "withdrawal-requests/", 1 },
                        { "withdrawal/open/", 1 },
                        { "withdrawal/status/", 1 },
                        { "withdrawal/cancel/", 1 },
                        { "liquidation_address/new/", 1 },
                        { "liquidation_address/info/", 1 },
                        { "btc_unconfirmed/", 1 },
                        { "websockets_token/", 1 },
                        { "btc_withdrawal/", 1 },
                        { "btc_address/", 1 },
                        { "ripple_withdrawal/", 1 },
                        { "ripple_address/", 1 },
                        { "ltc_withdrawal/", 1 },
                        { "ltc_address/", 1 },
                        { "eth_withdrawal/", 1 },
                        { "eth_address/", 1 },
                        { "xrp_withdrawal/", 1 },
                        { "xrp_address/", 1 },
                        { "xlm_withdrawal/", 1 },
                        { "xlm_address/", 1 },
                        { "pax_withdrawal/", 1 },
                        { "pax_address/", 1 },
                        { "link_withdrawal/", 1 },
                        { "link_address/", 1 },
                        { "usdc_withdrawal/", 1 },
                        { "usdc_address/", 1 },
                        { "omg_withdrawal/", 1 },
                        { "omg_address/", 1 },
                        { "dai_withdrawal/", 1 },
                        { "dai_address/", 1 },
                        { "knc_withdrawal/", 1 },
                        { "knc_address/", 1 },
                        { "mkr_withdrawal/", 1 },
                        { "mkr_address/", 1 },
                        { "zrx_withdrawal/", 1 },
                        { "zrx_address/", 1 },
                        { "gusd_withdrawal/", 1 },
                        { "gusd_address/", 1 },
                        { "aave_withdrawal/", 1 },
                        { "aave_address/", 1 },
                        { "bat_withdrawal/", 1 },
                        { "bat_address/", 1 },
                        { "uma_withdrawal/", 1 },
                        { "uma_address/", 1 },
                        { "snx_withdrawal/", 1 },
                        { "snx_address/", 1 },
                        { "uni_withdrawal/", 1 },
                        { "uni_address/", 1 },
                        { "yfi_withdrawal/", 1 },
                        { "yfi_address", 1 },
                        { "audio_withdrawal/", 1 },
                        { "audio_address/", 1 },
                        { "crv_withdrawal/", 1 },
                        { "crv_address/", 1 },
                        { "algo_withdrawal/", 1 },
                        { "algo_address/", 1 },
                        { "comp_withdrawal/", 1 },
                        { "comp_address/", 1 },
                        { "grt_withdrawal", 1 },
                        { "grt_address/", 1 },
                        { "usdt_withdrawal/", 1 },
                        { "usdt_address/", 1 },
                        { "eurt_withdrawal/", 1 },
                        { "eurt_address/", 1 },
                        { "matic_withdrawal/", 1 },
                        { "matic_address/", 1 },
                        { "sushi_withdrawal/", 1 },
                        { "sushi_address/", 1 },
                        { "chz_withdrawal/", 1 },
                        { "chz_address/", 1 },
                        { "enj_withdrawal/", 1 },
                        { "enj_address/", 1 },
                        { "alpha_withdrawal/", 1 },
                        { "alpha_address/", 1 },
                        { "ftt_withdrawal/", 1 },
                        { "ftt_address/", 1 },
                        { "storj_withdrawal/", 1 },
                        { "storj_address/", 1 },
                        { "axs_withdrawal/", 1 },
                        { "axs_address/", 1 },
                        { "sand_withdrawal/", 1 },
                        { "sand_address/", 1 },
                        { "hbar_withdrawal/", 1 },
                        { "hbar_address/", 1 },
                        { "rgt_withdrawal/", 1 },
                        { "rgt_address/", 1 },
                        { "fet_withdrawal/", 1 },
                        { "fet_address/", 1 },
                        { "skl_withdrawal/", 1 },
                        { "skl_address/", 1 },
                        { "cel_withdrawal/", 1 },
                        { "cel_address/", 1 },
                        { "sxp_withdrawal/", 1 },
                        { "sxp_address/", 1 },
                        { "ada_withdrawal/", 1 },
                        { "ada_address/", 1 },
                        { "slp_withdrawal/", 1 },
                        { "slp_address/", 1 },
                        { "ftm_withdrawal/", 1 },
                        { "ftm_address/", 1 },
                        { "perp_withdrawal/", 1 },
                        { "perp_address/", 1 },
                        { "dydx_withdrawal/", 1 },
                        { "dydx_address/", 1 },
                        { "gala_withdrawal/", 1 },
                        { "gala_address/", 1 },
                        { "shib_withdrawal/", 1 },
                        { "shib_address/", 1 },
                        { "amp_withdrawal/", 1 },
                        { "amp_address/", 1 },
                        { "sgb_withdrawal/", 1 },
                        { "sgb_address/", 1 },
                        { "avax_withdrawal/", 1 },
                        { "avax_address/", 1 },
                        { "wbtc_withdrawal/", 1 },
                        { "wbtc_address/", 1 },
                        { "ctsi_withdrawal/", 1 },
                        { "ctsi_address/", 1 },
                        { "cvx_withdrawal/", 1 },
                        { "cvx_address/", 1 },
                        { "imx_withdrawal/", 1 },
                        { "imx_address/", 1 },
                        { "nexo_withdrawal/", 1 },
                        { "nexo_address/", 1 },
                        { "ust_withdrawal/", 1 },
                        { "ust_address/", 1 },
                        { "ant_withdrawal/", 1 },
                        { "ant_address/", 1 },
                        { "gods_withdrawal/", 1 },
                        { "gods_address/", 1 },
                        { "rad_withdrawal/", 1 },
                        { "rad_address/", 1 },
                        { "band_withdrawal/", 1 },
                        { "band_address/", 1 },
                        { "inj_withdrawal/", 1 },
                        { "inj_address/", 1 },
                        { "rly_withdrawal/", 1 },
                        { "rly_address/", 1 },
                        { "rndr_withdrawal/", 1 },
                        { "rndr_address/", 1 },
                        { "vega_withdrawal/", 1 },
                        { "vega_address/", 1 },
                        { "1inch_withdrawal/", 1 },
                        { "1inch_address/", 1 },
                        { "ens_withdrawal/", 1 },
                        { "ens_address/", 1 },
                        { "mana_withdrawal/", 1 },
                        { "mana_address/", 1 },
                        { "lrc_withdrawal/", 1 },
                        { "lrc_address/", 1 },
                        { "ape_withdrawal/", 1 },
                        { "ape_address/", 1 },
                        { "mpl_withdrawal/", 1 },
                        { "mpl_address/", 1 },
                        { "euroc_withdrawal/", 1 },
                        { "euroc_address/", 1 },
                        { "sol_withdrawal/", 1 },
                        { "sol_address/", 1 },
                        { "dot_withdrawal/", 1 },
                        { "dot_address/", 1 },
                        { "near_withdrawal/", 1 },
                        { "near_address/", 1 },
                        { "doge_withdrawal/", 1 },
                        { "doge_address/", 1 },
                        { "flr_withdrawal/", 1 },
                        { "flr_address/", 1 },
                        { "dgld_withdrawal/", 1 },
                        { "dgld_address/", 1 },
                        { "ldo_withdrawal/", 1 },
                        { "ldo_address/", 1 },
                        { "travel_rule/contacts/", 1 },
                        { "earn/subscribe/", 1 },
                        { "earn/subscriptions/setting/", 1 },
                        { "earn/unsubscribe", 1 },
                        { "wecan_withdrawal/", 1 },
                        { "wecan_address/", 1 },
                        { "trac_withdrawal/", 1 },
                        { "trac_address/", 1 },
                        { "eurcv_withdrawal/", 1 },
                        { "eurcv_address/", 1 },
                        { "pyusd_withdrawal/", 1 },
                        { "pyusd_address/", 1 },
                        { "lmwr_withdrawal/", 1 },
                        { "lmwr_address/", 1 },
                        { "pepe_withdrawal/", 1 },
                        { "pepe_address/", 1 },
                        { "blur_withdrawal/", 1 },
                        { "blur_address/", 1 },
                        { "vext_withdrawal/", 1 },
                        { "vext_address/", 1 },
                        { "cspr_withdrawal/", 1 },
                        { "cspr_address/", 1 },
                        { "vchf_withdrawal/", 1 },
                        { "vchf_address/", 1 },
                        { "veur_withdrawal/", 1 },
                        { "veur_address/", 1 },
                    } },
                } },
            } },
            { "fees", new Dictionary<string, object>() {
                { "trading", new Dictionary<string, object>() {
                    { "tierBased", true },
                    { "percentage", true },
                    { "taker", this.parseNumber("0.005") },
                    { "maker", this.parseNumber("0.005") },
                    { "tiers", new Dictionary<string, object>() {
                        { "taker", new List<object>() {new List<object> {this.parseNumber("0"), this.parseNumber("0.005")}, new List<object> {this.parseNumber("20000"), this.parseNumber("0.0025")}, new List<object> {this.parseNumber("100000"), this.parseNumber("0.0024")}, new List<object> {this.parseNumber("200000"), this.parseNumber("0.0022")}, new List<object> {this.parseNumber("400000"), this.parseNumber("0.0020")}, new List<object> {this.parseNumber("600000"), this.parseNumber("0.0015")}, new List<object> {this.parseNumber("1000000"), this.parseNumber("0.0014")}, new List<object> {this.parseNumber("2000000"), this.parseNumber("0.0013")}, new List<object> {this.parseNumber("4000000"), this.parseNumber("0.0012")}, new List<object> {this.parseNumber("20000000"), this.parseNumber("0.0011")}, new List<object> {this.parseNumber("50000000"), this.parseNumber("0.0010")}, new List<object> {this.parseNumber("100000000"), this.parseNumber("0.0007")}, new List<object> {this.parseNumber("500000000"), this.parseNumber("0.0005")}, new List<object> {this.parseNumber("2000000000"), this.parseNumber("0.0003")}, new List<object> {this.parseNumber("6000000000"), this.parseNumber("0.0001")}, new List<object> {this.parseNumber("20000000000"), this.parseNumber("0.00005")}, new List<object> {this.parseNumber("20000000001"), this.parseNumber("0")}} },
                        { "maker", new List<object>() {new List<object> {this.parseNumber("0"), this.parseNumber("0.005")}, new List<object> {this.parseNumber("20000"), this.parseNumber("0.0025")}, new List<object> {this.parseNumber("100000"), this.parseNumber("0.0024")}, new List<object> {this.parseNumber("200000"), this.parseNumber("0.0022")}, new List<object> {this.parseNumber("400000"), this.parseNumber("0.0020")}, new List<object> {this.parseNumber("600000"), this.parseNumber("0.0015")}, new List<object> {this.parseNumber("1000000"), this.parseNumber("0.0014")}, new List<object> {this.parseNumber("2000000"), this.parseNumber("0.0013")}, new List<object> {this.parseNumber("4000000"), this.parseNumber("0.0012")}, new List<object> {this.parseNumber("20000000"), this.parseNumber("0.0011")}, new List<object> {this.parseNumber("50000000"), this.parseNumber("0.0010")}, new List<object> {this.parseNumber("100000000"), this.parseNumber("0.0007")}, new List<object> {this.parseNumber("500000000"), this.parseNumber("0.0005")}, new List<object> {this.parseNumber("2000000000"), this.parseNumber("0.0003")}, new List<object> {this.parseNumber("6000000000"), this.parseNumber("0.0001")}, new List<object> {this.parseNumber("20000000000"), this.parseNumber("0.00005")}, new List<object> {this.parseNumber("20000000001"), this.parseNumber("0")}} },
                    } },
                } },
                { "funding", new Dictionary<string, object>() {
                    { "tierBased", false },
                    { "percentage", false },
                    { "withdraw", new Dictionary<string, object>() {} },
                    { "deposit", new Dictionary<string, object>() {
                        { "BTC", 0 },
                        { "BCH", 0 },
                        { "LTC", 0 },
                        { "ETH", 0 },
                        { "XRP", 0 },
                        { "XLM", 0 },
                        { "PAX", 0 },
                        { "USD", 7.5 },
                        { "EUR", 0 },
                    } },
                } },
            } },
            { "precisionMode", TICK_SIZE },
            { "commonCurrencies", new Dictionary<string, object>() {
                { "UST", "USTC" },
            } },
            { "options", new Dictionary<string, object>() {
                { "networksById", new Dictionary<string, object>() {
                    { "bitcoin-cash", "BCH" },
                    { "bitcoin", "BTC" },
                    { "ethereum", "ERC20" },
                    { "litecoin", "LTC" },
                    { "stellar", "XLM" },
                    { "xrpl", "XRP" },
                    { "tron", "TRC20" },
                    { "algorand", "ALGO" },
                    { "flare", "FLR" },
                    { "hedera", "HBAR" },
                    { "cardana", "ADA" },
                    { "songbird", "FLR" },
                    { "avalanche-c-chain", "AVAX" },
                    { "solana", "SOL" },
                    { "polkadot", "DOT" },
                    { "near", "NEAR" },
                    { "doge", "DOGE" },
                    { "sui", "SUI" },
                    { "casper", "CSRP" },
                } },
            } },
            { "exceptions", new Dictionary<string, object>() {
                { "exact", new Dictionary<string, object>() {
                    { "No permission found", typeof(PermissionDenied) },
                    { "API key not found", typeof(AuthenticationError) },
                    { "IP address not allowed", typeof(PermissionDenied) },
                    { "Invalid nonce", typeof(InvalidNonce) },
                    { "Invalid signature", typeof(AuthenticationError) },
                    { "Authentication failed", typeof(AuthenticationError) },
                    { "Missing key, signature and nonce parameters", typeof(AuthenticationError) },
                    { "Wrong API key format", typeof(AuthenticationError) },
                    { "Your account is frozen", typeof(PermissionDenied) },
                    { "Please update your profile with your FATCA information, before using API.", typeof(PermissionDenied) },
                    { "Order not found.", typeof(OrderNotFound) },
                    { "Price is more than 20% below market price.", typeof(InvalidOrder) },
                    { "Bitstamp.net is under scheduled maintenance. We\'ll be back soon.", typeof(OnMaintenance) },
                    { "Order could not be placed.", typeof(ExchangeNotAvailable) },
                    { "Invalid offset.", typeof(BadRequest) },
                } },
                { "broad", new Dictionary<string, object>() {
                    { "Minimum order size is", typeof(InvalidOrder) },
                    { "Check your account balance for details.", typeof(InsufficientFunds) },
                    { "Ensure this value has at least", typeof(InvalidAddress) },
                    { "Ensure that there are no more than", typeof(InvalidOrder) },
                } },
            } },
        });
    }

    public async override Task<object> fetchMarkets(object parameters = null)
    {
        /**
        * @method
        * @name bitstamp#fetchMarkets
        * @description retrieves data on all markets for bitstamp
        * @see https://www.bitstamp.net/api/#tag/Market-info/operation/GetTradingPairsInfo
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} an array of objects representing market data
        */
        parameters ??= new Dictionary<string, object>();
        object response = await this.fetchMarketsFromCache(parameters);
        //
        //     [
        //         {
        //             "trading": "Enabled",
        //             "base_decimals": 8,
        //             "url_symbol": "btcusd",
        //             "name": "BTC/USD",
        //             "instant_and_market_orders": "Enabled",
        //             "minimum_order": "20.0 USD",
        //             "counter_decimals": 2,
        //             "description": "Bitcoin / U.S. dollar"
        //         }
        //     ]
        //
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(response)); postFixIncrement(ref i))
        {
            object market = getValue(response, i);
            object name = this.safeString(market, "name");
            var bsquoteVariable = ((string)name).Split(new [] {((string)"/")}, StringSplitOptions.None).ToList<object>();
            var bs = ((IList<object>) bsquoteVariable)[0];
            var quote = ((IList<object>) bsquoteVariable)[1];
            object baseId = ((string)bs).ToLower();
            object quoteId = ((string)quote).ToLower();
            bs = this.safeCurrencyCode(bs);
            quote = this.safeCurrencyCode(quote);
            object minimumOrder = this.safeString(market, "minimum_order");
            object parts = ((string)minimumOrder).Split(new [] {((string)" ")}, StringSplitOptions.None).ToList<object>();
            object status = this.safeString(market, "trading");
            ((IList<object>)result).Add(new Dictionary<string, object>() {
                { "id", this.safeString(market, "url_symbol") },
                { "marketId", add(add(baseId, "_"), quoteId) },
                { "symbol", add(add(bs, "/"), quote) },
                { "base", bs },
                { "quote", quote },
                { "settle", null },
                { "baseId", baseId },
                { "quoteId", quoteId },
                { "settleId", null },
                { "type", "spot" },
                { "spot", true },
                { "margin", false },
                { "future", false },
                { "swap", false },
                { "option", false },
                { "active", (isEqual(status, "Enabled")) },
                { "contract", false },
                { "linear", null },
                { "inverse", null },
                { "contractSize", null },
                { "expiry", null },
                { "expiryDatetime", null },
                { "strike", null },
                { "optionType", null },
                { "precision", new Dictionary<string, object>() {
                    { "amount", this.parseNumber(this.parsePrecision(this.safeString(market, "base_decimals"))) },
                    { "price", this.parseNumber(this.parsePrecision(this.safeString(market, "counter_decimals"))) },
                } },
                { "limits", new Dictionary<string, object>() {
                    { "leverage", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                    { "amount", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                    { "price", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                    { "cost", new Dictionary<string, object>() {
                        { "min", this.safeNumber(parts, 0) },
                        { "max", null },
                    } },
                } },
                { "created", null },
                { "info", market },
            });
        }
        return result;
    }

    public virtual object constructCurrencyObject(object id, object code, object name, object precision, object minCost, object originalPayload)
    {
        object currencyType = "crypto";
        object description = this.describe();
        if (isTrue(this.isFiat(code)))
        {
            currencyType = "fiat";
        }
        object tickSize = this.parseNumber(this.parsePrecision(this.numberToString(precision)));
        return new Dictionary<string, object>() {
            { "id", id },
            { "code", code },
            { "info", originalPayload },
            { "type", currencyType },
            { "name", name },
            { "active", true },
            { "deposit", null },
            { "withdraw", null },
            { "fee", this.safeNumber(getValue(getValue(getValue(description, "fees"), "funding"), "withdraw"), code) },
            { "precision", tickSize },
            { "limits", new Dictionary<string, object>() {
                { "amount", new Dictionary<string, object>() {
                    { "min", tickSize },
                    { "max", null },
                } },
                { "price", new Dictionary<string, object>() {
                    { "min", tickSize },
                    { "max", null },
                } },
                { "cost", new Dictionary<string, object>() {
                    { "min", minCost },
                    { "max", null },
                } },
                { "withdraw", new Dictionary<string, object>() {
                    { "min", null },
                    { "max", null },
                } },
            } },
            { "networks", new Dictionary<string, object>() {} },
        };
    }

    public async virtual Task<object> fetchMarketsFromCache(object parameters = null)
    {
        // this method is now redundant
        // currencies are now fetched before markets
        parameters ??= new Dictionary<string, object>();
        object options = this.safeValue(this.options, "fetchMarkets", new Dictionary<string, object>() {});
        object timestamp = this.safeInteger(options, "timestamp");
        object expires = this.safeInteger(options, "expires", 1000);
        object now = this.milliseconds();
        if (isTrue(isTrue((isEqual(timestamp, null))) || isTrue((isGreaterThan((subtract(now, timestamp)), expires)))))
        {
            object response = await this.publicGetTradingPairsInfo(parameters);
            ((IDictionary<string,object>)this.options)["fetchMarkets"] = this.extend(options, new Dictionary<string, object>() {
                { "response", response },
                { "timestamp", now },
            });
        }
        return this.safeValue(getValue(this.options, "fetchMarkets"), "response");
    }

    public async override Task<object> fetchCurrencies(object parameters = null)
    {
        /**
        * @method
        * @name bitstamp#fetchCurrencies
        * @description fetches all available currencies on an exchange
        * @see https://www.bitstamp.net/api/#tag/Market-info/operation/GetTradingPairsInfo
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} an associative dictionary of currencies
        */
        parameters ??= new Dictionary<string, object>();
        object response = await this.fetchMarketsFromCache(parameters);
        //
        //     [
        //         {
        //             "trading": "Enabled",
        //             "base_decimals": 8,
        //             "url_symbol": "btcusd",
        //             "name": "BTC/USD",
        //             "instant_and_market_orders": "Enabled",
        //             "minimum_order": "20.0 USD",
        //             "counter_decimals": 2,
        //             "description": "Bitcoin / U.S. dollar"
        //         },
        //     ]
        //
        object result = new Dictionary<string, object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(response)); postFixIncrement(ref i))
        {
            object market = getValue(response, i);
            object name = this.safeString(market, "name");
            var bsquoteVariable = ((string)name).Split(new [] {((string)"/")}, StringSplitOptions.None).ToList<object>();
            var bs = ((IList<object>) bsquoteVariable)[0];
            var quote = ((IList<object>) bsquoteVariable)[1];
            object baseId = ((string)bs).ToLower();
            object quoteId = ((string)quote).ToLower();
            bs = this.safeCurrencyCode(bs);
            quote = this.safeCurrencyCode(quote);
            object description = this.safeString(market, "description");
            var baseDescriptionquoteDescriptionVariable = ((string)description).Split(new [] {((string)" / ")}, StringSplitOptions.None).ToList<object>();
            var baseDescription = ((IList<object>) baseDescriptionquoteDescriptionVariable)[0];
            var quoteDescription = ((IList<object>) baseDescriptionquoteDescriptionVariable)[1];
            object minimumOrder = this.safeString(market, "minimum_order");
            object parts = ((string)minimumOrder).Split(new [] {((string)" ")}, StringSplitOptions.None).ToList<object>();
            object cost = getValue(parts, 0);
            if (!isTrue((inOp(result, bs))))
            {
                object baseDecimals = this.safeInteger(market, "base_decimals");
                ((IDictionary<string,object>)result)[(string)bs] = this.constructCurrencyObject(baseId, bs, baseDescription, baseDecimals, null, market);
            }
            if (!isTrue((inOp(result, quote))))
            {
                object counterDecimals = this.safeInteger(market, "counter_decimals");
                ((IDictionary<string,object>)result)[(string)quote] = this.constructCurrencyObject(quoteId, quote, quoteDescription, counterDecimals, this.parseNumber(cost), market);
            }
        }
        return result;
    }

    public async override Task<object> fetchOrderBook(object symbol, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bitstamp#fetchOrderBook
        * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
        * @see https://www.bitstamp.net/api/#tag/Order-book/operation/GetOrderBook
        * @param {string} symbol unified symbol of the market to fetch the order book for
        * @param {int} [limit] the maximum amount of order book entries to return
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "pair", getValue(market, "id") },
        };
        object response = await this.publicGetOrderBookPair(this.extend(request, parameters));
        //
        //     {
        //         "timestamp": "1583652948",
        //         "microtimestamp": "1583652948955826",
        //         "bids": [
        //             [ "8750.00", "1.33685271" ],
        //             [ "8749.39", "0.07700000" ],
        //             [ "8746.98", "0.07400000" ],
        //         ]
        //         "asks": [
        //             [ "8754.10", "1.51995636" ],
        //             [ "8754.71", "1.40000000" ],
        //             [ "8754.72", "2.50000000" ],
        //         ]
        //     }
        //
        object microtimestamp = this.safeInteger(response, "microtimestamp");
        object timestamp = this.parseToInt(divide(microtimestamp, 1000));
        object orderbook = this.parseOrderBook(response, getValue(market, "symbol"), timestamp);
        ((IDictionary<string,object>)orderbook)["nonce"] = microtimestamp;
        return orderbook;
    }

    public override object parseTicker(object ticker, object market = null)
    {
        //
        // {
        //     "timestamp": "1686068944",
        //     "high": "26252",
        //     "last": "26216",
        //     "bid": "26208",
        //     "vwap": "25681",
        //     "volume": "3563.13819902",
        //     "low": "25350",
        //     "ask": "26211",
        //     "open": "25730",
        //     "open_24": "25895",
        //     "percent_change_24": "1.24",
        //     "pair": "BTC/USD"
        // }
        //
        object marketId = this.safeString(ticker, "pair");
        object symbol = this.safeSymbol(marketId, market, null);
        object timestamp = this.safeTimestamp(ticker, "timestamp");
        object vwap = this.safeString(ticker, "vwap");
        object baseVolume = this.safeString(ticker, "volume");
        object quoteVolume = Precise.stringMul(baseVolume, vwap);
        object last = this.safeString(ticker, "last");
        return this.safeTicker(new Dictionary<string, object>() {
            { "symbol", symbol },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "high", this.safeString(ticker, "high") },
            { "low", this.safeString(ticker, "low") },
            { "bid", this.safeString(ticker, "bid") },
            { "bidVolume", null },
            { "ask", this.safeString(ticker, "ask") },
            { "askVolume", null },
            { "vwap", vwap },
            { "open", this.safeString(ticker, "open") },
            { "close", last },
            { "last", last },
            { "previousClose", null },
            { "change", null },
            { "percentage", null },
            { "average", null },
            { "baseVolume", baseVolume },
            { "quoteVolume", quoteVolume },
            { "info", ticker },
        }, market);
    }

    public async override Task<object> fetchTicker(object symbol, object parameters = null)
    {
        /**
        * @method
        * @name bitstamp#fetchTicker
        * @description fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
        * @see https://www.bitstamp.net/api/#tag/Tickers/operation/GetMarketTicker
        * @param {string} symbol unified symbol of the market to fetch the ticker for
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "pair", getValue(market, "id") },
        };
        object ticker = await this.publicGetTickerPair(this.extend(request, parameters));
        //
        // {
        //     "timestamp": "1686068944",
        //     "high": "26252",
        //     "last": "26216",
        //     "bid": "26208",
        //     "vwap": "25681",
        //     "volume": "3563.13819902",
        //     "low": "25350",
        //     "ask": "26211",
        //     "open": "25730",
        //     "open_24": "25895",
        //     "percent_change_24": "1.24"
        // }
        //
        return this.parseTicker(ticker, market);
    }

    public async override Task<object> fetchTickers(object symbols = null, object parameters = null)
    {
        /**
        * @method
        * @name bitstamp#fetchTickers
        * @description fetches price tickers for multiple markets, statistical information calculated over the past 24 hours for each market
        * @see https://www.bitstamp.net/api/#tag/Tickers/operation/GetCurrencyPairTickers
        * @param {string[]|undefined} symbols unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/#/?id=ticker-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.publicGetTicker(parameters);
        //
        // {
        //     "timestamp": "1686068944",
        //     "high": "26252",
        //     "last": "26216",
        //     "bid": "26208",
        //     "vwap": "25681",
        //     "volume": "3563.13819902",
        //     "low": "25350",
        //     "ask": "26211",
        //     "open": "25730",
        //     "open_24": "25895",
        //     "percent_change_24": "1.24",
        //     "pair": "BTC/USD"
        // }
        //
        return this.parseTickers(response, symbols);
    }

    public virtual object getCurrencyIdFromTransaction(object transaction)
    {
        //
        //     {
        //         "fee": "0.00000000",
        //         "btc_usd": "0.00",
        //         "datetime": XXX,
        //         "usd": 0.0,
        //         "btc": 0.0,
        //         "eth": "0.05000000",
        //         "type": "0",
        //         "id": XXX,
        //         "eur": 0.0
        //     }
        //
        object currencyId = this.safeStringLower(transaction, "currency");
        if (isTrue(!isEqual(currencyId, null)))
        {
            return currencyId;
        }
        transaction = this.omit(transaction, new List<object>() {"fee", "price", "datetime", "type", "status", "id"});
        object ids = new List<object>(((IDictionary<string,object>)transaction).Keys);
        for (object i = 0; isLessThan(i, getArrayLength(ids)); postFixIncrement(ref i))
        {
            object id = getValue(ids, i);
            if (isTrue(isLessThan(getIndexOf(id, "_"), 0)))
            {
                object value = this.safeInteger(transaction, id);
                if (isTrue(isTrue((!isEqual(value, null))) && isTrue((!isEqual(value, 0)))))
                {
                    return id;
                }
            }
        }
        return null;
    }

    public virtual object getMarketFromTrade(object trade)
    {
        trade = this.omit(trade, new List<object>() {"fee", "price", "datetime", "tid", "type", "order_id", "side"});
        object currencyIds = new List<object>(((IDictionary<string,object>)trade).Keys);
        object numCurrencyIds = getArrayLength(currencyIds);
        if (isTrue(isGreaterThan(numCurrencyIds, 2)))
        {
            throw new ExchangeError ((string)add(add(add(add(this.id, " getMarketFromTrade() too many keys: "), this.json(currencyIds)), " in the trade: "), this.json(trade))) ;
        }
        if (isTrue(isEqual(numCurrencyIds, 2)))
        {
            object marketId = add(getValue(currencyIds, 0), getValue(currencyIds, 1));
            if (isTrue(inOp(this.markets_by_id, marketId)))
            {
                return this.safeMarket(marketId);
            }
            marketId = add(getValue(currencyIds, 1), getValue(currencyIds, 0));
            if (isTrue(inOp(this.markets_by_id, marketId)))
            {
                return this.safeMarket(marketId);
            }
        }
        return null;
    }

    public override object parseTrade(object trade, object market = null)
    {
        //
        // fetchTrades (public)
        //
        //      {
        //          "date": "1637845199",
        //          "tid": "209895701",
        //          "amount": "0.00500000",
        //          "type": "0",             // Transaction type: 0 - buy; 1 - sell
        //          "price": "4451.25"
        //      }
        //
        // fetchMyTrades, trades returned within fetchOrder (private)
        //
        //      {
        //          "fee": "0.11128",
        //          "eth_usdt":  4451.25,
        //          "datetime": "2021-11-25 12:59:59.322000",
        //          "usdt": "-22.26",
        //          "order_id":  1429545880227846,
        //          "usd":  0,
        //          "btc":  0,
        //          "eth": "0.00500000",
        //          "type": "2",                    // Transaction type: 0 - deposit; 1 - withdrawal; 2 - market trade; 14 - sub account transfer; 25 - credited with staked assets; 26 - sent assets to staking; 27 - staking reward; 32 - referral reward; 35 - inter account transfer.
        //          "id":  209895701,
        //          "eur":  0
        //      }
        //
        // from fetchOrder (private)
        //
        //      {
        //          "fee": "0.11128",
        //          "price": "4451.25000000",
        //          "datetime": "2021-11-25 12:59:59.322000",
        //          "usdt": "22.25625000",
        //          "tid": 209895701,
        //          "eth": "0.00500000",
        //          "type": 2                       // Transaction type: 0 - deposit; 1 - withdrawal; 2 - market trade
        //      }
        //
        object id = this.safeString2(trade, "id", "tid");
        object symbol = null;
        object side = null;
        object priceString = this.safeString(trade, "price");
        object amountString = this.safeString(trade, "amount");
        object orderId = this.safeString(trade, "order_id");
        object type = null;
        object costString = this.safeString(trade, "cost");
        object rawMarketId = null;
        if (isTrue(isEqual(market, null)))
        {
            object keys = new List<object>(((IDictionary<string,object>)trade).Keys);
            for (object i = 0; isLessThan(i, getArrayLength(keys)); postFixIncrement(ref i))
            {
                object currentKey = getValue(keys, i);
                if (isTrue(isTrue(!isEqual(currentKey, "order_id")) && isTrue(isGreaterThanOrEqual(getIndexOf(currentKey, "_"), 0))))
                {
                    rawMarketId = currentKey;
                    market = this.safeMarket(rawMarketId, market, "_");
                }
            }
        }
        // if the market is still not defined
        // try to deduce it from used keys
        if (isTrue(isEqual(market, null)))
        {
            market = this.getMarketFromTrade(trade);
        }
        object feeCostString = this.safeString(trade, "fee");
        object feeCurrency = getValue(market, "quote");
        object priceId = ((bool) isTrue((!isEqual(rawMarketId, null)))) ? rawMarketId : getValue(market, "marketId");
        priceString = this.safeString(trade, priceId, priceString);
        amountString = this.safeString(trade, getValue(market, "baseId"), amountString);
        costString = this.safeString(trade, getValue(market, "quoteId"), costString);
        symbol = getValue(market, "symbol");
        object datetimeString = this.safeString2(trade, "date", "datetime");
        object timestamp = null;
        if (isTrue(!isEqual(datetimeString, null)))
        {
            if (isTrue(isGreaterThanOrEqual(getIndexOf(datetimeString, " "), 0)))
            {
                // iso8601
                timestamp = this.parse8601(datetimeString);
            } else
            {
                // string unix epoch in seconds
                timestamp = parseInt(datetimeString);
                timestamp = multiply(timestamp, 1000);
            }
        }
        // if it is a private trade
        if (isTrue(inOp(trade, "id")))
        {
            if (isTrue(!isEqual(amountString, null)))
            {
                object isAmountNeg = Precise.stringLt(amountString, "0");
                if (isTrue(isAmountNeg))
                {
                    side = "sell";
                    amountString = Precise.stringNeg(amountString);
                } else
                {
                    side = "buy";
                }
            }
        } else
        {
            side = this.safeString(trade, "type");
            if (isTrue(isEqual(side, "1")))
            {
                side = "sell";
            } else if (isTrue(isEqual(side, "0")))
            {
                side = "buy";
            } else
            {
                side = null;
            }
        }
        if (isTrue(!isEqual(costString, null)))
        {
            costString = Precise.stringAbs(costString);
        }
        object fee = null;
        if (isTrue(!isEqual(feeCostString, null)))
        {
            fee = new Dictionary<string, object>() {
                { "cost", feeCostString },
                { "currency", feeCurrency },
            };
        }
        return this.safeTrade(new Dictionary<string, object>() {
            { "id", id },
            { "info", trade },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "symbol", symbol },
            { "order", orderId },
            { "type", type },
            { "side", side },
            { "takerOrMaker", null },
            { "price", priceString },
            { "amount", amountString },
            { "cost", costString },
            { "fee", fee },
        }, market);
    }

    public async override Task<object> fetchTrades(object symbol, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bitstamp#fetchTrades
        * @description get the list of most recent trades for a particular symbol
        * @see https://www.bitstamp.net/api/#tag/Transactions-public/operation/GetTransactions
        * @param {string} symbol unified symbol of the market to fetch trades for
        * @param {int} [since] timestamp in ms of the earliest trade to fetch
        * @param {int} [limit] the maximum amount of trades to fetch
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "pair", getValue(market, "id") },
            { "time", "hour" },
        };
        object response = await this.publicGetTransactionsPair(this.extend(request, parameters));
        //
        //     [
        //         {
        //             "date": "1551814435",
        //             "tid": "83581898",
        //             "price": "0.03532850",
        //             "type": "1",
        //             "amount": "0.85945907"
        //         },
        //         {
        //             "date": "1551814434",
        //             "tid": "83581896",
        //             "price": "0.03532851",
        //             "type": "1",
        //             "amount": "11.34130961"
        //         },
        //     ]
        //
        return this.parseTrades(response, market, since, limit);
    }

    public override object parseOHLCV(object ohlcv, object market = null)
    {
        //
        //     {
        //         "high": "9064.77",
        //         "timestamp": "1593961440",
        //         "volume": "18.49436608",
        //         "low": "9040.87",
        //         "close": "9064.77",
        //         "open": "9040.87"
        //     }
        //
        return new List<object> {this.safeTimestamp(ohlcv, "timestamp"), this.safeNumber(ohlcv, "open"), this.safeNumber(ohlcv, "high"), this.safeNumber(ohlcv, "low"), this.safeNumber(ohlcv, "close"), this.safeNumber(ohlcv, "volume")};
    }

    public async override Task<object> fetchOHLCV(object symbol, object timeframe = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bitstamp#fetchOHLCV
        * @description fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
        * @see https://www.bitstamp.net/api/#tag/Market-info/operation/GetOHLCData
        * @param {string} symbol unified symbol of the market to fetch OHLCV data for
        * @param {string} timeframe the length of time each candle represents
        * @param {int} [since] timestamp in ms of the earliest candle to fetch
        * @param {int} [limit] the maximum amount of candles to fetch
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
        */
        timeframe ??= "1m";
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "pair", getValue(market, "id") },
            { "step", this.safeString(this.timeframes, timeframe, timeframe) },
        };
        object duration = this.parseTimeframe(timeframe);
        if (isTrue(isEqual(limit, null)))
        {
            if (isTrue(isEqual(since, null)))
            {
                ((IDictionary<string,object>)request)["limit"] = 1000; // we need to specify an allowed amount of `limit` if no `since` is set and there is no default limit by exchange
            } else
            {
                limit = 1000;
                object start = this.parseToInt(divide(since, 1000));
                ((IDictionary<string,object>)request)["start"] = start;
                ((IDictionary<string,object>)request)["end"] = this.sum(start, multiply(duration, (subtract(limit, 1))));
                ((IDictionary<string,object>)request)["limit"] = limit;
            }
        } else
        {
            if (isTrue(!isEqual(since, null)))
            {
                object start = this.parseToInt(divide(since, 1000));
                ((IDictionary<string,object>)request)["start"] = start;
                ((IDictionary<string,object>)request)["end"] = this.sum(start, multiply(duration, (subtract(limit, 1))));
            }
            ((IDictionary<string,object>)request)["limit"] = mathMin(limit, 1000); // min 1, max 1000
        }
        object response = await this.publicGetOhlcPair(this.extend(request, parameters));
        //
        //     {
        //         "data": {
        //             "pair": "BTC/USD",
        //             "ohlc": [
        //                 {"high": "9064.77", "timestamp": "1593961440", "volume": "18.49436608", "low": "9040.87", "close": "9064.77", "open": "9040.87"},
        //                 {"high": "9071.59", "timestamp": "1593961500", "volume": "3.48631711", "low": "9058.76", "close": "9061.07", "open": "9064.66"},
        //                 {"high": "9067.33", "timestamp": "1593961560", "volume": "0.04142833", "low": "9061.94", "close": "9061.94", "open": "9067.33"},
        //             ],
        //         }
        //     }
        //
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        object ohlc = this.safeList(data, "ohlc", new List<object>() {});
        return this.parseOHLCVs(ohlc, market, timeframe, since, limit);
    }

    public override object parseBalance(object response)
    {
        object result = new Dictionary<string, object>() {
            { "info", response },
            { "timestamp", null },
            { "datetime", null },
        };
        if (isTrue(isEqual(response, null)))
        {
            response = new List<object>() {};
        }
        for (object i = 0; isLessThan(i, getArrayLength(response)); postFixIncrement(ref i))
        {
            object currencyBalance = getValue(response, i);
            object currencyId = this.safeString(currencyBalance, "currency");
            object currencyCode = this.safeCurrencyCode(currencyId);
            object account = this.account();
            ((IDictionary<string,object>)account)["free"] = this.safeString(currencyBalance, "available");
            ((IDictionary<string,object>)account)["used"] = this.safeString(currencyBalance, "reserved");
            ((IDictionary<string,object>)account)["total"] = this.safeString(currencyBalance, "total");
            ((IDictionary<string,object>)result)[(string)currencyCode] = account;
        }
        return this.safeBalance(result);
    }

    public async override Task<object> fetchBalance(object parameters = null)
    {
        /**
        * @method
        * @name bitstamp#fetchBalance
        * @description query for balance and get the amount of funds available for trading or funds locked in orders
        * @see https://www.bitstamp.net/api/#tag/Account-balances/operation/GetAccountBalances
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.privatePostAccountBalances(parameters);
        //
        //     [
        //         {
        //             "currency": "usdt",
        //             "total": "7.00000",
        //             "available": "7.00000",
        //             "reserved": "0.00000"
        //         },
        //         ...
        //     ]
        //
        return this.parseBalance(response);
    }

    public async override Task<object> fetchTradingFee(object symbol, object parameters = null)
    {
        /**
        * @method
        * @name bitstamp#fetchTradingFee
        * @description fetch the trading fees for a market
        * @see https://www.bitstamp.net/api/#tag/Fees/operation/GetTradingFeesForCurrency
        * @param {string} symbol unified market symbol
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [fee structure]{@link https://docs.ccxt.com/#/?id=fee-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "market_symbol", getValue(market, "id") },
        };
        object response = await this.privatePostFeesTrading(this.extend(request, parameters));
        //
        //     [
        //         {
        //             "currency_pair": "btcusd",
        //             "fees":
        //                 {
        //                     "maker": "0.15000",
        //                     "taker": "0.16000"
        //                 },
        //             "market": "btcusd"
        //         }
        //         ...
        //     ]
        //
        object tradingFeesByMarketId = this.indexBy(response, "currency_pair");
        object tradingFee = this.safeDict(tradingFeesByMarketId, getValue(market, "id"));
        return this.parseTradingFee(tradingFee, market);
    }

    public virtual object parseTradingFee(object fee, object market = null)
    {
        object marketId = this.safeString(fee, "market");
        object fees = this.safeDict(fee, "fees", new Dictionary<string, object>() {});
        return new Dictionary<string, object>() {
            { "info", fee },
            { "symbol", this.safeSymbol(marketId, market) },
            { "maker", this.safeNumber(fees, "maker") },
            { "taker", this.safeNumber(fees, "taker") },
            { "percentage", null },
            { "tierBased", null },
        };
    }

    public virtual object parseTradingFees(object fees)
    {
        object result = new Dictionary<string, object>() {
            { "info", fees },
        };
        object symbols = this.symbols;
        for (object i = 0; isLessThan(i, getArrayLength(symbols)); postFixIncrement(ref i))
        {
            object symbol = getValue(symbols, i);
            object fee = this.parseTradingFee(getValue(fees, i));
            ((IDictionary<string,object>)result)[(string)symbol] = fee;
        }
        return result;
    }

    public async override Task<object> fetchTradingFees(object parameters = null)
    {
        /**
        * @method
        * @name bitstamp#fetchTradingFees
        * @description fetch the trading fees for multiple markets
        * @see https://www.bitstamp.net/api/#tag/Fees/operation/GetAllTradingFees
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a dictionary of [fee structures]{@link https://docs.ccxt.com/#/?id=fee-structure} indexed by market symbols
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.privatePostFeesTrading(parameters);
        //
        //     [
        //         {
        //             "currency_pair": "btcusd",
        //             "fees":
        //                 {
        //                     "maker": "0.15000",
        //                     "taker": "0.16000"
        //                 },
        //             "market": "btcusd"
        //         }
        //         ...
        //     ]
        //
        return this.parseTradingFees(response);
    }

    public async override Task<object> fetchTransactionFees(object codes = null, object parameters = null)
    {
        /**
        * @method
        * @name bitstamp#fetchTransactionFees
        * @deprecated
        * @description please use fetchDepositWithdrawFees instead
        * @see https://www.bitstamp.net/api/#tag/Fees
        * @param {string[]|undefined} codes list of unified currency codes
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} a list of [fee structures]{@link https://docs.ccxt.com/#/?id=fee-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.privatePostFeesWithdrawal(parameters);
        //
        //     [
        //         {
        //             "currency": "btc",
        //             "fee": "0.00015000",
        //             "network": "bitcoin"
        //         }
        //         ...
        //     ]
        //
        return this.parseTransactionFees(response);
    }

    public virtual object parseTransactionFees(object response, object codes = null)
    {
        object result = new Dictionary<string, object>() {};
        object currencies = this.indexBy(response, "currency");
        object ids = new List<object>(((IDictionary<string,object>)currencies).Keys);
        for (object i = 0; isLessThan(i, getArrayLength(ids)); postFixIncrement(ref i))
        {
            object id = getValue(ids, i);
            object fees = this.safeValue(response, i, new Dictionary<string, object>() {});
            object code = this.safeCurrencyCode(id);
            if (isTrue(isTrue((!isEqual(codes, null))) && !isTrue(this.inArray(code, codes))))
            {
                continue;
            }
            ((IDictionary<string,object>)result)[(string)code] = new Dictionary<string, object>() {
                { "withdraw_fee", this.safeNumber(fees, "fee") },
                { "deposit", new Dictionary<string, object>() {} },
                { "info", this.safeDict(currencies, id) },
            };
        }
        return result;
    }

    public async override Task<object> fetchDepositWithdrawFees(object codes = null, object parameters = null)
    {
        /**
        * @method
        * @name bitstamp#fetchDepositWithdrawFees
        * @description fetch deposit and withdraw fees
        * @see https://www.bitstamp.net/api/#tag/Fees/operation/GetAllWithdrawalFees
        * @param {string[]|undefined} codes list of unified currency codes
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} a list of [fee structures]{@link https://docs.ccxt.com/#/?id=fee-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.privatePostFeesWithdrawal(parameters);
        //
        //     [
        //         {
        //             "currency": "btc",
        //             "fee": "0.00015000",
        //             "network": "bitcoin"
        //         }
        //         ...
        //     ]
        //
        object responseByCurrencyId = this.groupBy(response, "currency");
        return this.parseDepositWithdrawFees(responseByCurrencyId, codes);
    }

    public override object parseDepositWithdrawFee(object fee, object currency = null)
    {
        object result = this.depositWithdrawFee(fee);
        for (object j = 0; isLessThan(j, getArrayLength(fee)); postFixIncrement(ref j))
        {
            object networkEntry = getValue(fee, j);
            object networkId = this.safeString(networkEntry, "network");
            object networkCode = this.networkIdToCode(networkId);
            object withdrawFee = this.safeNumber(networkEntry, "fee");
            ((IDictionary<string,object>)result)["withdraw"] = new Dictionary<string, object>() {
                { "fee", withdrawFee },
                { "percentage", null },
            };
            ((IDictionary<string,object>)getValue(result, "networks"))[(string)networkCode] = new Dictionary<string, object>() {
                { "withdraw", new Dictionary<string, object>() {
                    { "fee", withdrawFee },
                    { "percentage", null },
                } },
                { "deposit", new Dictionary<string, object>() {
                    { "fee", null },
                    { "percentage", null },
                } },
            };
        }
        return result;
    }

    public async override Task<object> createOrder(object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        /**
        * @method
        * @name bitstamp#createOrder
        * @description create a trade order
        * @see https://www.bitstamp.net/api/#tag/Orders/operation/OpenInstantBuyOrder
        * @see https://www.bitstamp.net/api/#tag/Orders/operation/OpenMarketBuyOrder
        * @see https://www.bitstamp.net/api/#tag/Orders/operation/OpenLimitBuyOrder
        * @see https://www.bitstamp.net/api/#tag/Orders/operation/OpenInstantSellOrder
        * @see https://www.bitstamp.net/api/#tag/Orders/operation/OpenMarketSellOrder
        * @see https://www.bitstamp.net/api/#tag/Orders/operation/OpenLimitSellOrder
        * @param {string} symbol unified symbol of the market to create an order in
        * @param {string} type 'market' or 'limit'
        * @param {string} side 'buy' or 'sell'
        * @param {float} amount how much of currency you want to trade in units of base currency
        * @param {float} [price] the price at which the order is to be fullfilled, in units of the quote currency, ignored in market orders
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "pair", getValue(market, "id") },
            { "amount", this.amountToPrecision(symbol, amount) },
        };
        object clientOrderId = this.safeString2(parameters, "client_order_id", "clientOrderId");
        if (isTrue(!isEqual(clientOrderId, null)))
        {
            ((IDictionary<string,object>)request)["client_order_id"] = clientOrderId;
            parameters = this.omit(parameters, new List<object>() {"clientOrderId"});
        }
        object response = null;
        object capitalizedSide = this.capitalize(side);
        if (isTrue(isEqual(type, "market")))
        {
            if (isTrue(isEqual(capitalizedSide, "Buy")))
            {
                response = await this.privatePostBuyMarketPair(this.extend(request, parameters));
            } else
            {
                response = await this.privatePostSellMarketPair(this.extend(request, parameters));
            }
        } else if (isTrue(isEqual(type, "instant")))
        {
            if (isTrue(isEqual(capitalizedSide, "Buy")))
            {
                response = await this.privatePostBuyInstantPair(this.extend(request, parameters));
            } else
            {
                response = await this.privatePostSellInstantPair(this.extend(request, parameters));
            }
        } else
        {
            ((IDictionary<string,object>)request)["price"] = this.priceToPrecision(symbol, price);
            if (isTrue(isEqual(capitalizedSide, "Buy")))
            {
                response = await this.privatePostBuyPair(this.extend(request, parameters));
            } else
            {
                response = await this.privatePostSellPair(this.extend(request, parameters));
            }
        }
        object order = this.parseOrder(response, market);
        ((IDictionary<string,object>)order)["type"] = type;
        return order;
    }

    public async override Task<object> cancelOrder(object id, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name bitstamp#cancelOrder
        * @description cancels an open order
        * @see https://www.bitstamp.net/api/#tag/Orders/operation/CancelOrder
        * @param {string} id order id
        * @param {string} symbol unified symbol of the market the order was made in
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {
            { "id", id },
        };
        return await this.privatePostCancelOrder(this.extend(request, parameters));
    }

    public async override Task<object> cancelAllOrders(object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name bitstamp#cancelAllOrders
        * @description cancel all open orders
        * @see https://www.bitstamp.net/api/#tag/Orders/operation/CancelAllOrders
        * @see https://www.bitstamp.net/api/#tag/Orders/operation/CancelOrdersForMarket
        * @param {string} symbol unified market symbol, only orders in the market of this symbol are cancelled when symbol is not undefined
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = null;
        object request = new Dictionary<string, object>() {};
        object response = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            ((IDictionary<string,object>)request)["pair"] = getValue(market, "id");
            response = await this.privatePostCancelAllOrdersPair(this.extend(request, parameters));
        } else
        {
            response = await this.privatePostCancelAllOrders(this.extend(request, parameters));
        }
        return response;
    }

    public virtual object parseOrderStatus(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "In Queue", "open" },
            { "Open", "open" },
            { "Finished", "closed" },
            { "Canceled", "canceled" },
        };
        return this.safeString(statuses, status, status);
    }

    public async override Task<object> fetchOrderStatus(object id, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object clientOrderId = this.safeValue2(parameters, "client_order_id", "clientOrderId");
        object request = new Dictionary<string, object>() {};
        if (isTrue(!isEqual(clientOrderId, null)))
        {
            ((IDictionary<string,object>)request)["client_order_id"] = clientOrderId;
            parameters = this.omit(parameters, new List<object>() {"client_order_id", "clientOrderId"});
        } else
        {
            ((IDictionary<string,object>)request)["id"] = id;
        }
        object response = await this.privatePostOrderStatus(this.extend(request, parameters));
        return this.parseOrderStatus(this.safeString(response, "status"));
    }

    public async override Task<object> fetchOrder(object id, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name bitstamp#fetchOrder
        * @description fetches information on an order made by the user
        * @see https://www.bitstamp.net/api/#tag/Orders/operation/GetOrderStatus
        * @param {string} symbol unified symbol of the market the order was made in
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
        }
        object clientOrderId = this.safeValue2(parameters, "client_order_id", "clientOrderId");
        object request = new Dictionary<string, object>() {};
        if (isTrue(!isEqual(clientOrderId, null)))
        {
            ((IDictionary<string,object>)request)["client_order_id"] = clientOrderId;
            parameters = this.omit(parameters, new List<object>() {"client_order_id", "clientOrderId"});
        } else
        {
            ((IDictionary<string,object>)request)["id"] = id;
        }
        object response = await this.privatePostOrderStatus(this.extend(request, parameters));
        //
        //      {
        //          "status": "Finished",
        //          "id": 1429545880227846,
        //          "amount_remaining": "0.00000000",
        //          "transactions": [
        //              {
        //                  "fee": "0.11128",
        //                  "price": "4451.25000000",
        //                  "datetime": "2021-11-25 12:59:59.322000",
        //                  "usdt": "22.25625000",
        //                  "tid": 209895701,
        //                  "eth": "0.00500000",
        //                  "type": 2
        //              }
        //         ]
        //     }
        //
        return this.parseOrder(response, market);
    }

    public async override Task<object> fetchMyTrades(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bitstamp#fetchMyTrades
        * @description fetch all trades made by the user
        * @see https://www.bitstamp.net/api/#tag/Transactions-private/operation/GetUserTransactions
        * @see https://www.bitstamp.net/api/#tag/Transactions-private/operation/GetUserTransactionsForMarket
        * @param {string} symbol unified market symbol
        * @param {int} [since] the earliest time in ms to fetch trades for
        * @param {int} [limit] the maximum number of trades structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object method = "privatePostUserTransactions";
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            ((IDictionary<string,object>)request)["pair"] = getValue(market, "id");
            method = add(method, "Pair");
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        object response = await ((Task<object>)callDynamically(this, method, new object[] { this.extend(request, parameters) }));
        object result = this.filterBy(response, "type", "2");
        return this.parseTrades(result, market, since, limit);
    }

    public async override Task<object> fetchDepositsWithdrawals(object code = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bitstamp#fetchDepositsWithdrawals
        * @description fetch history of deposits and withdrawals
        * @see https://www.bitstamp.net/api/#tag/Transactions-private/operation/GetUserTransactions
        * @param {string} [code] unified currency code for the currency of the deposit/withdrawals, default is undefined
        * @param {int} [since] timestamp in ms of the earliest deposit/withdrawal, default is undefined
        * @param {int} [limit] max number of deposit/withdrawals to return, default is undefined
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a list of [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        object response = await this.privatePostUserTransactions(this.extend(request, parameters));
        //
        //     [
        //         {
        //             "fee": "0.00000000",
        //             "btc_usd": "0.00",
        //             "id": 1234567894,
        //             "usd": 0,
        //             "btc": 0,
        //             "datetime": "2018-09-08 09:00:31",
        //             "type": "1",
        //             "xrp": "-20.00000000",
        //             "eur": 0,
        //         },
        //         {
        //             "fee": "0.00000000",
        //             "btc_usd": "0.00",
        //             "id": 1134567891,
        //             "usd": 0,
        //             "btc": 0,
        //             "datetime": "2018-09-07 18:47:52",
        //             "type": "0",
        //             "xrp": "20.00000000",
        //             "eur": 0,
        //         },
        //     ]
        //
        object currency = null;
        if (isTrue(!isEqual(code, null)))
        {
            currency = this.currency(code);
        }
        object transactions = this.filterByArray(response, "type", new List<object>() {"0", "1"}, false);
        return this.parseTransactions(transactions, currency, since, limit);
    }

    public async override Task<object> fetchWithdrawals(object code = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bitstamp#fetchWithdrawals
        * @description fetch all withdrawals made from an account
        * @see https://www.bitstamp.net/api/#tag/Withdrawals/operation/GetWithdrawalRequests
        * @param {string} code unified currency code
        * @param {int} [since] the earliest time in ms to fetch withdrawals for
        * @param {int} [limit] the maximum number of withdrawals structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["timedelta"] = subtract(this.milliseconds(), since);
        } else
        {
            ((IDictionary<string,object>)request)["timedelta"] = 50000000; // use max bitstamp approved value
        }
        object response = await this.privatePostWithdrawalRequests(this.extend(request, parameters));
        //
        //     [
        //         {
        //             "status": 2,
        //             "datetime": "2018-10-17 10:58:13",
        //             "currency": "BTC",
        //             "amount": "0.29669259",
        //             "address": "aaaaa",
        //             "type": 1,
        //             "id": 111111,
        //             "transaction_id": "xxxx",
        //         },
        //         {
        //             "status": 2,
        //             "datetime": "2018-10-17 10:55:17",
        //             "currency": "ETH",
        //             "amount": "1.11010664",
        //             "address": "aaaa",
        //             "type": 16,
        //             "id": 222222,
        //             "transaction_id": "xxxxx",
        //         },
        //     ]
        //
        return this.parseTransactions(response, null, since, limit);
    }

    public override object parseTransaction(object transaction, object currency = null)
    {
        //
        // fetchDepositsWithdrawals
        //
        //     {
        //         "fee": "0.00000000",
        //         "btc_usd": "0.00",
        //         "id": 1234567894,
        //         "usd": 0,
        //         "btc": 0,
        //         "datetime": "2018-09-08 09:00:31",
        //         "type": "1",
        //         "xrp": "-20.00000000",
        //         "eur": 0,
        //     }
        //
        // fetchWithdrawals
        //
        //     {
        //         "status": 2,
        //         "datetime": "2018-10-17 10:58:13",
        //         "currency": "BTC",
        //         "amount": "0.29669259",
        //         "address": "aaaaa",
        //         "type": 1,
        //         "id": 111111,
        //         "transaction_id": "xxxx",
        //     }
        //
        //     {
        //         "id": 3386432,
        //         "type": 14,
        //         "amount": "863.21332500",
        //         "status": 2,
        //         "address": "rE1sdh25BJQ3qFwngiTBwaq3zPGGYcrjp1?dt=1455",
        //         "currency": "XRP",
        //         "datetime": "2018-01-05 15:27:55",
        //         "transaction_id": "001743B03B0C79BA166A064AC0142917B050347B4CB23BA2AB4B91B3C5608F4C"
        //     }
        //
        object timestamp = this.parse8601(this.safeString(transaction, "datetime"));
        object currencyId = this.getCurrencyIdFromTransaction(transaction);
        object code = this.safeCurrencyCode(currencyId, currency);
        object feeCost = this.safeString(transaction, "fee");
        object feeCurrency = null;
        object amount = null;
        if (isTrue(inOp(transaction, "amount")))
        {
            amount = this.safeString(transaction, "amount");
        } else if (isTrue(!isEqual(currency, null)))
        {
            amount = this.safeString(transaction, getValue(currency, "id"), amount);
            feeCurrency = getValue(currency, "code");
        } else if (isTrue(isTrue((!isEqual(code, null))) && isTrue((!isEqual(currencyId, null)))))
        {
            amount = this.safeString(transaction, currencyId, amount);
            feeCurrency = code;
        }
        if (isTrue(!isEqual(amount, null)))
        {
            // withdrawals have a negative amount
            amount = Precise.stringAbs(amount);
        }
        object status = "ok";
        if (isTrue(inOp(transaction, "status")))
        {
            status = this.parseTransactionStatus(this.safeString(transaction, "status"));
        }
        object type = null;
        if (isTrue(inOp(transaction, "type")))
        {
            // from fetchDepositsWithdrawals
            object rawType = this.safeString(transaction, "type");
            if (isTrue(isEqual(rawType, "0")))
            {
                type = "deposit";
            } else if (isTrue(isEqual(rawType, "1")))
            {
                type = "withdrawal";
            }
        } else
        {
            // from fetchWithdrawals
            type = "withdrawal";
        }
        object tag = null;
        object address = this.safeString(transaction, "address");
        if (isTrue(!isEqual(address, null)))
        {
            // dt (destination tag) is embedded into the address field
            object addressParts = ((string)address).Split(new [] {((string)"?dt=")}, StringSplitOptions.None).ToList<object>();
            object numParts = getArrayLength(addressParts);
            if (isTrue(isGreaterThan(numParts, 1)))
            {
                address = getValue(addressParts, 0);
                tag = getValue(addressParts, 1);
            }
        }
        object fee = new Dictionary<string, object>() {
            { "currency", null },
            { "cost", null },
            { "rate", null },
        };
        if (isTrue(!isEqual(feeCost, null)))
        {
            fee = new Dictionary<string, object>() {
                { "currency", feeCurrency },
                { "cost", feeCost },
                { "rate", null },
            };
        }
        return new Dictionary<string, object>() {
            { "info", transaction },
            { "id", this.safeString(transaction, "id") },
            { "txid", this.safeString(transaction, "transaction_id") },
            { "type", type },
            { "currency", code },
            { "network", null },
            { "amount", this.parseNumber(amount) },
            { "status", status },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "address", address },
            { "addressFrom", null },
            { "addressTo", address },
            { "tag", tag },
            { "tagFrom", null },
            { "tagTo", tag },
            { "updated", null },
            { "comment", null },
            { "internal", null },
            { "fee", fee },
        };
    }

    public virtual object parseTransactionStatus(object status)
    {
        //
        //   withdrawals:
        //   0 (open), 1 (in process), 2 (finished), 3 (canceled) or 4 (failed).
        //
        object statuses = new Dictionary<string, object>() {
            { "0", "pending" },
            { "1", "pending" },
            { "2", "ok" },
            { "3", "canceled" },
            { "4", "failed" },
        };
        return this.safeString(statuses, status, status);
    }

    public override object parseOrder(object order, object market = null)
    {
        //
        //   from fetch order:
        //     { status: "Finished",
        //       "id": 731693945,
        //       "client_order_id": '',
        //       "transactions":
        //       [ { fee: "0.000019",
        //           "price": "0.00015803",
        //           "datetime": "2018-01-07 10:45:34.132551",
        //           "btc": "0.0079015000000000",
        //           "tid": 42777395,
        //           "type": 2,
        //           "xrp": "50.00000000" } ] }
        //
        //   partially filled order:
        //     { "id": 468646390,
        //       "client_order_id": "",
        //       "status": "Canceled",
        //       "transactions": [{
        //           "eth": "0.23000000",
        //           "fee": "0.09",
        //           "tid": 25810126,
        //           "usd": "69.8947000000000000",
        //           "type": 2,
        //           "price": "303.89000000",
        //           "datetime": "2017-11-11 07:22:20.710567"
        //       }]}
        //
        //   from create order response:
        //       {
        //           "price": "0.00008012",
        //           "client_order_id": '',
        //           "currency_pair": "XRP/BTC",
        //           "datetime": "2019-01-31 21:23:36",
        //           "amount": "15.00000000",
        //           "type": "0",
        //           "id": "2814205012"
        //       }
        //
        object id = this.safeString(order, "id");
        object clientOrderId = this.safeString(order, "client_order_id");
        object side = this.safeString(order, "type");
        if (isTrue(!isEqual(side, null)))
        {
            side = ((bool) isTrue((isEqual(side, "1")))) ? "sell" : "buy";
        }
        // there is no timestamp from fetchOrder
        object timestamp = this.parse8601(this.safeString(order, "datetime"));
        object marketId = this.safeStringLower(order, "currency_pair");
        object symbol = this.safeSymbol(marketId, market, "/");
        object status = this.parseOrderStatus(this.safeString(order, "status"));
        object amount = this.safeString(order, "amount");
        object transactions = this.safeValue(order, "transactions", new List<object>() {});
        object price = this.safeString(order, "price");
        return this.safeOrder(new Dictionary<string, object>() {
            { "id", id },
            { "clientOrderId", clientOrderId },
            { "datetime", this.iso8601(timestamp) },
            { "timestamp", timestamp },
            { "lastTradeTimestamp", null },
            { "status", status },
            { "symbol", symbol },
            { "type", null },
            { "timeInForce", null },
            { "postOnly", null },
            { "side", side },
            { "price", price },
            { "stopPrice", null },
            { "triggerPrice", null },
            { "cost", null },
            { "amount", amount },
            { "filled", null },
            { "remaining", null },
            { "trades", transactions },
            { "fee", null },
            { "info", order },
            { "average", null },
        }, market);
    }

    public virtual object parseLedgerEntryType(object type)
    {
        object types = new Dictionary<string, object>() {
            { "0", "transaction" },
            { "1", "transaction" },
            { "2", "trade" },
            { "14", "transfer" },
        };
        return this.safeString(types, type, type);
    }

    public override object parseLedgerEntry(object item, object currency = null)
    {
        //
        //     [
        //         {
        //             "fee": "0.00000000",
        //             "btc_usd": "0.00",
        //             "id": 1234567894,
        //             "usd": 0,
        //             "btc": 0,
        //             "datetime": "2018-09-08 09:00:31",
        //             "type": "1",
        //             "xrp": "-20.00000000",
        //             "eur": 0,
        //         },
        //         {
        //             "fee": "0.00000000",
        //             "btc_usd": "0.00",
        //             "id": 1134567891,
        //             "usd": 0,
        //             "btc": 0,
        //             "datetime": "2018-09-07 18:47:52",
        //             "type": "0",
        //             "xrp": "20.00000000",
        //             "eur": 0,
        //         },
        //     ]
        //
        object type = this.parseLedgerEntryType(this.safeString(item, "type"));
        if (isTrue(isEqual(type, "trade")))
        {
            object parsedTrade = this.parseTrade(item);
            object market = null;
            object keys = new List<object>(((IDictionary<string,object>)item).Keys);
            for (object i = 0; isLessThan(i, getArrayLength(keys)); postFixIncrement(ref i))
            {
                if (isTrue(isGreaterThanOrEqual(getIndexOf(getValue(keys, i), "_"), 0)))
                {
                    object marketId = ((string)getValue(keys, i)).Replace((string)"_", (string)"");
                    market = this.safeMarket(marketId, market);
                }
            }
            // if the market is still not defined
            // try to deduce it from used keys
            if (isTrue(isEqual(market, null)))
            {
                market = this.getMarketFromTrade(item);
            }
            object direction = ((bool) isTrue((isEqual(getValue(parsedTrade, "side"), "buy")))) ? "in" : "out";
            return new Dictionary<string, object>() {
                { "id", getValue(parsedTrade, "id") },
                { "info", item },
                { "timestamp", getValue(parsedTrade, "timestamp") },
                { "datetime", getValue(parsedTrade, "datetime") },
                { "direction", direction },
                { "account", null },
                { "referenceId", getValue(parsedTrade, "order") },
                { "referenceAccount", null },
                { "type", type },
                { "currency", getValue(market, "base") },
                { "amount", getValue(parsedTrade, "amount") },
                { "before", null },
                { "after", null },
                { "status", "ok" },
                { "fee", getValue(parsedTrade, "fee") },
            };
        } else
        {
            object parsedTransaction = this.parseTransaction(item, currency);
            object direction = null;
            if (isTrue(inOp(item, "amount")))
            {
                object amount = this.safeString(item, "amount");
                direction = ((bool) isTrue(Precise.stringGt(amount, "0"))) ? "in" : "out";
            } else if (isTrue(isTrue((inOp(parsedTransaction, "currency"))) && isTrue(!isEqual(getValue(parsedTransaction, "currency"), null))))
            {
                object currencyCode = this.safeString(parsedTransaction, "currency");
                currency = this.currency(currencyCode);
                object amount = this.safeString(item, getValue(currency, "id"));
                direction = ((bool) isTrue(Precise.stringGt(amount, "0"))) ? "in" : "out";
            }
            return new Dictionary<string, object>() {
                { "id", getValue(parsedTransaction, "id") },
                { "info", item },
                { "timestamp", getValue(parsedTransaction, "timestamp") },
                { "datetime", getValue(parsedTransaction, "datetime") },
                { "direction", direction },
                { "account", null },
                { "referenceId", getValue(parsedTransaction, "txid") },
                { "referenceAccount", null },
                { "type", type },
                { "currency", getValue(parsedTransaction, "currency") },
                { "amount", getValue(parsedTransaction, "amount") },
                { "before", null },
                { "after", null },
                { "status", getValue(parsedTransaction, "status") },
                { "fee", getValue(parsedTransaction, "fee") },
            };
        }
    }

    public async override Task<object> fetchLedger(object code = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bitstamp#fetchLedger
        * @description fetch the history of changes, actions done by the user or operations that altered balance of the user
        * @see https://www.bitstamp.net/api/#tag/Transactions-private/operation/GetUserTransactions
        * @param {string} code unified currency code, default is undefined
        * @param {int} [since] timestamp in ms of the earliest ledger entry, default is undefined
        * @param {int} [limit] max number of ledger entrys to return, default is undefined
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [ledger structure]{@link https://docs.ccxt.com/#/?id=ledger-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        object response = await this.privatePostUserTransactions(this.extend(request, parameters));
        object currency = null;
        if (isTrue(!isEqual(code, null)))
        {
            currency = this.currency(code);
        }
        return this.parseLedger(response, currency, since, limit);
    }

    public async override Task<object> fetchOpenOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bitstamp#fetchOpenOrders
        * @description fetch all unfilled currently open orders
        * @see https://www.bitstamp.net/api/#tag/Orders/operation/GetAllOpenOrders
        * @see https://www.bitstamp.net/api/#tag/Orders/operation/GetOpenOrdersForMarket
        * @param {string} symbol unified market symbol
        * @param {int} [since] the earliest time in ms to fetch open orders for
        * @param {int} [limit] the maximum number of  open orders structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        object market = null;
        await this.loadMarkets();
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
        }
        object response = await this.privatePostOpenOrdersAll(parameters);
        //
        //     [
        //         {
        //             "price": "0.00008012",
        //             "currency_pair": "XRP/BTC",
        //             "client_order_id": '',
        //             "datetime": "2019-01-31 21:23:36",
        //             "amount": "15.00000000",
        //             "type": "0",
        //             "id": "2814205012",
        //         }
        //     ]
        //
        return this.parseOrders(response, market, since, limit, new Dictionary<string, object>() {
            { "status", "open" },
            { "type", "limit" },
        });
    }

    public virtual object getCurrencyName(object code)
    {
        /**
         * @ignore
         * @method
         * @param {string} code Unified currency code
         * @returns {string} lowercase version of code
         */
        return ((string)code).ToLower();
    }

    public virtual object isFiat(object code)
    {
        return isTrue(isTrue(isEqual(code, "USD")) || isTrue(isEqual(code, "EUR"))) || isTrue(isEqual(code, "GBP"));
    }

    public async override Task<object> fetchDepositAddress(object code, object parameters = null)
    {
        /**
        * @method
        * @name bitstamp#fetchDepositAddress
        * @description fetch the deposit address for a currency associated with this account
        * @see https://www.bitstamp.net/api/#tag/Deposits/operation/GetCryptoDepositAddress
        * @param {string} code unified currency code
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} an [address structure]{@link https://docs.ccxt.com/#/?id=address-structure}
        */
        parameters ??= new Dictionary<string, object>();
        if (isTrue(this.isFiat(code)))
        {
            throw new NotSupported ((string)add(add(add(this.id, " fiat fetchDepositAddress() for "), code), " is not supported!")) ;
        }
        object name = this.getCurrencyName(code);
        object method = add(add("privatePost", this.capitalize(name)), "Address");
        object response = await ((Task<object>)callDynamically(this, method, new object[] { parameters }));
        object address = this.safeString(response, "address");
        object tag = this.safeString2(response, "memo_id", "destination_tag");
        this.checkAddress(address);
        return new Dictionary<string, object>() {
            { "currency", code },
            { "address", address },
            { "tag", tag },
            { "network", null },
            { "info", response },
        };
    }

    public async override Task<object> withdraw(object code, object amount, object address, object tag = null, object parameters = null)
    {
        /**
        * @method
        * @name bitstamp#withdraw
        * @description make a withdrawal
        * @see https://www.bitstamp.net/api/#tag/Withdrawals/operation/RequestFiatWithdrawal
        * @see https://www.bitstamp.net/api/#tag/Withdrawals/operation/RequestCryptoWithdrawal
        * @param {string} code unified currency code
        * @param {float} amount the amount to withdraw
        * @param {string} address the address to withdraw to
        * @param {string} tag
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
        */
        // For fiat withdrawals please provide all required additional parameters in the 'params'
        // Check https://www.bitstamp.net/api/ under 'Open bank withdrawal' for list and description.
        parameters ??= new Dictionary<string, object>();
        var tagparametersVariable = this.handleWithdrawTagAndParams(tag, parameters);
        tag = ((IList<object>)tagparametersVariable)[0];
        parameters = ((IList<object>)tagparametersVariable)[1];
        await this.loadMarkets();
        this.checkAddress(address);
        object request = new Dictionary<string, object>() {
            { "amount", amount },
        };
        object currency = null;
        object method = null;
        if (!isTrue(this.isFiat(code)))
        {
            object name = this.getCurrencyName(code);
            method = add(add("privatePost", this.capitalize(name)), "Withdrawal");
            if (isTrue(isEqual(code, "XRP")))
            {
                if (isTrue(!isEqual(tag, null)))
                {
                    ((IDictionary<string,object>)request)["destination_tag"] = tag;
                }
            } else if (isTrue(isTrue(isEqual(code, "XLM")) || isTrue(isEqual(code, "HBAR"))))
            {
                if (isTrue(!isEqual(tag, null)))
                {
                    ((IDictionary<string,object>)request)["memo_id"] = tag;
                }
            }
            ((IDictionary<string,object>)request)["address"] = address;
        } else
        {
            method = "privatePostWithdrawalOpen";
            currency = this.currency(code);
            ((IDictionary<string,object>)request)["iban"] = address;
            ((IDictionary<string,object>)request)["account_currency"] = getValue(currency, "id");
        }
        object response = await ((Task<object>)callDynamically(this, method, new object[] { this.extend(request, parameters) }));
        return this.parseTransaction(response, currency);
    }

    public async override Task<object> transfer(object code, object amount, object fromAccount, object toAccount, object parameters = null)
    {
        /**
        * @method
        * @name bitstamp#transfer
        * @description transfer currency internally between wallets on the same account
        * @see https://www.bitstamp.net/api/#tag/Sub-account/operation/TransferFromMainToSub
        * @see https://www.bitstamp.net/api/#tag/Sub-account/operation/TransferFromSubToMain
        * @param {string} code unified currency code
        * @param {float} amount amount to transfer
        * @param {string} fromAccount account to transfer from
        * @param {string} toAccount account to transfer to
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [transfer structure]{@link https://docs.ccxt.com/#/?id=transfer-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "amount", this.parseToNumeric(this.currencyToPrecision(code, amount)) },
            { "currency", ((string)getValue(currency, "id")).ToUpper() },
        };
        object response = null;
        if (isTrue(isEqual(fromAccount, "main")))
        {
            ((IDictionary<string,object>)request)["subAccount"] = toAccount;
            response = await this.privatePostTransferFromMain(this.extend(request, parameters));
        } else if (isTrue(isEqual(toAccount, "main")))
        {
            ((IDictionary<string,object>)request)["subAccount"] = fromAccount;
            response = await this.privatePostTransferToMain(this.extend(request, parameters));
        } else
        {
            throw new BadRequest ((string)add(this.id, " transfer() only supports from or to main")) ;
        }
        //
        //    { status: 'ok' }
        //
        object transfer = this.parseTransfer(response, currency);
        ((IDictionary<string,object>)transfer)["amount"] = amount;
        ((IDictionary<string,object>)transfer)["fromAccount"] = fromAccount;
        ((IDictionary<string,object>)transfer)["toAccount"] = toAccount;
        return transfer;
    }

    public override object parseTransfer(object transfer, object currency = null)
    {
        //
        //    { status: 'ok' }
        //
        object status = this.safeString(transfer, "status");
        return new Dictionary<string, object>() {
            { "info", transfer },
            { "id", null },
            { "timestamp", null },
            { "datetime", null },
            { "currency", getValue(currency, "code") },
            { "amount", null },
            { "fromAccount", null },
            { "toAccount", null },
            { "status", this.parseTransferStatus(status) },
        };
    }

    public virtual object parseTransferStatus(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "ok", "ok" },
            { "error", "failed" },
        };
        return this.safeString(statuses, status, status);
    }

    public override object nonce()
    {
        return this.milliseconds();
    }

    public override object sign(object path, object api = null, object method = null, object parameters = null, object headers = null, object body = null)
    {
        api ??= "public";
        method ??= "GET";
        parameters ??= new Dictionary<string, object>();
        object url = add(getValue(getValue(this.urls, "api"), api), "/");
        url = add(url, add(this.version, "/"));
        url = add(url, this.implodeParams(path, parameters));
        object query = this.omit(parameters, this.extractParams(path));
        if (isTrue(isEqual(api, "public")))
        {
            if (isTrue(getArrayLength(new List<object>(((IDictionary<string,object>)query).Keys))))
            {
                url = add(url, add("?", this.urlencode(query)));
            }
        } else
        {
            this.checkRequiredCredentials();
            object xAuth = add("BITSTAMP ", this.apiKey);
            object xAuthNonce = this.uuid();
            object xAuthTimestamp = ((object)this.milliseconds()).ToString();
            object xAuthVersion = "v2";
            object contentType = "";
            headers = new Dictionary<string, object>() {
                { "X-Auth", xAuth },
                { "X-Auth-Nonce", xAuthNonce },
                { "X-Auth-Timestamp", xAuthTimestamp },
                { "X-Auth-Version", xAuthVersion },
            };
            if (isTrue(isEqual(method, "POST")))
            {
                if (isTrue(getArrayLength(new List<object>(((IDictionary<string,object>)query).Keys))))
                {
                    body = this.urlencode(query);
                    contentType = "application/x-www-form-urlencoded";
                    ((IDictionary<string,object>)headers)["Content-Type"] = contentType;
                } else
                {
                    // sending an empty POST request will trigger
                    // an API0020 error returned by the exchange
                    // therefore for empty requests we send a dummy object
                    // https://github.com/ccxt/ccxt/issues/6846
                    body = this.urlencode(new Dictionary<string, object>() {
                        { "foo", "bar" },
                    });
                    contentType = "application/x-www-form-urlencoded";
                    ((IDictionary<string,object>)headers)["Content-Type"] = contentType;
                }
            }
            object authBody = ((bool) isTrue(body)) ? body : "";
            object auth = add(add(add(add(add(add(add(xAuth, method), ((string)url).Replace((string)"https://", (string)"")), contentType), xAuthNonce), xAuthTimestamp), xAuthVersion), authBody);
            object signature = this.hmac(this.encode(auth), this.encode(this.secret), sha256);
            ((IDictionary<string,object>)headers)["X-Auth-Signature"] = signature;
        }
        return new Dictionary<string, object>() {
            { "url", url },
            { "method", method },
            { "body", body },
            { "headers", headers },
        };
    }

    public override object handleErrors(object httpCode, object reason, object url, object method, object headers, object body, object response, object requestHeaders, object requestBody)
    {
        if (isTrue(isEqual(response, null)))
        {
            return null;
        }
        //
        //     {"error": "No permission found"} // fetchDepositAddress returns this on apiKeys that don't have the permission required
        //     {"status": "error", "reason": {"__all__": ["Minimum order size is 5.0 EUR."]}}
        //     reuse of a nonce gives: { status: 'error', reason: 'Invalid nonce', code: 'API0004' }
        //
        object status = this.safeString(response, "status");
        object error = this.safeValue(response, "error");
        if (isTrue(isTrue((isEqual(status, "error"))) || isTrue((!isEqual(error, null)))))
        {
            object errors = new List<object>() {};
            if (isTrue((error is string)))
            {
                ((IList<object>)errors).Add(error);
            } else if (isTrue(!isEqual(error, null)))
            {
                object keys = new List<object>(((IDictionary<string,object>)error).Keys);
                for (object i = 0; isLessThan(i, getArrayLength(keys)); postFixIncrement(ref i))
                {
                    object key = getValue(keys, i);
                    object value = this.safeValue(error, key);
                    if (isTrue(((value is IList<object>) || (value.GetType().IsGenericType && value.GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>))))))
                    {
                        errors = this.arrayConcat(errors, value);
                    } else
                    {
                        ((IList<object>)errors).Add(value);
                    }
                }
            }
            object reasonInner = this.safeValue(response, "reason", new Dictionary<string, object>() {});
            if (isTrue((reasonInner is string)))
            {
                ((IList<object>)errors).Add(reasonInner);
            } else
            {
                object all = this.safeValue(reasonInner, "__all__", new List<object>() {});
                for (object i = 0; isLessThan(i, getArrayLength(all)); postFixIncrement(ref i))
                {
                    ((IList<object>)errors).Add(getValue(all, i));
                }
            }
            object code = this.safeString(response, "code");
            if (isTrue(isEqual(code, "API0005")))
            {
                throw new AuthenticationError ((string)add(this.id, " invalid signature, use the uid for the main account if you have subaccounts")) ;
            }
            object feedback = add(add(this.id, " "), body);
            for (object i = 0; isLessThan(i, getArrayLength(errors)); postFixIncrement(ref i))
            {
                object value = getValue(errors, i);
                this.throwExactlyMatchedException(getValue(this.exceptions, "exact"), value, feedback);
                this.throwBroadlyMatchedException(getValue(this.exceptions, "broad"), value, feedback);
            }
            throw new ExchangeError ((string)feedback) ;
        }
        return null;
    }
}
