namespace ccxt;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

public partial class bitteam : Exchange
{
    public override object describe()
    {
        return this.deepExtend(base.describe(), new Dictionary<string, object>() {
            { "id", "bitteam" },
            { "name", "BIT.TEAM" },
            { "countries", new List<object>() {"UK"} },
            { "version", "v2.0.6" },
            { "rateLimit", 1 },
            { "certified", false },
            { "pro", false },
            { "has", new Dictionary<string, object>() {
                { "CORS", null },
                { "spot", true },
                { "margin", false },
                { "swap", false },
                { "future", false },
                { "option", false },
                { "addMargin", false },
                { "borrowMargin", false },
                { "cancelAllOrders", true },
                { "cancelOrder", true },
                { "cancelOrders", false },
                { "createDepositAddress", false },
                { "createOrder", true },
                { "createPostOnlyOrder", false },
                { "createReduceOnlyOrder", false },
                { "createStopLimitOrder", false },
                { "createStopMarketOrder", false },
                { "createStopOrder", false },
                { "deposit", false },
                { "editOrder", false },
                { "fetchAccounts", false },
                { "fetchBalance", true },
                { "fetchBidsAsks", false },
                { "fetchBorrowInterest", false },
                { "fetchBorrowRateHistories", false },
                { "fetchBorrowRateHistory", false },
                { "fetchCanceledOrders", true },
                { "fetchClosedOrder", false },
                { "fetchClosedOrders", true },
                { "fetchCrossBorrowRate", false },
                { "fetchCrossBorrowRates", false },
                { "fetchCurrencies", true },
                { "fetchDeposit", false },
                { "fetchDepositAddress", false },
                { "fetchDepositAddresses", false },
                { "fetchDepositAddressesByNetwork", false },
                { "fetchDeposits", false },
                { "fetchDepositsWithdrawals", true },
                { "fetchDepositWithdrawFee", false },
                { "fetchDepositWithdrawFees", false },
                { "fetchFundingHistory", false },
                { "fetchFundingRate", false },
                { "fetchFundingRateHistory", false },
                { "fetchFundingRates", false },
                { "fetchIndexOHLCV", false },
                { "fetchIsolatedBorrowRate", false },
                { "fetchIsolatedBorrowRates", false },
                { "fetchL3OrderBook", false },
                { "fetchLedger", false },
                { "fetchLeverage", false },
                { "fetchLeverageTiers", false },
                { "fetchMarketLeverageTiers", false },
                { "fetchMarkets", true },
                { "fetchMarkOHLCV", false },
                { "fetchMyTrades", true },
                { "fetchOHLCV", true },
                { "fetchOpenInterestHistory", false },
                { "fetchOpenOrder", false },
                { "fetchOpenOrders", true },
                { "fetchOrder", true },
                { "fetchOrderBook", true },
                { "fetchOrderBooks", false },
                { "fetchOrders", true },
                { "fetchOrderTrades", false },
                { "fetchPosition", false },
                { "fetchPositionHistory", false },
                { "fetchPositionMode", false },
                { "fetchPositions", false },
                { "fetchPositionsForSymbol", false },
                { "fetchPositionsHistory", false },
                { "fetchPositionsRisk", false },
                { "fetchPremiumIndexOHLCV", false },
                { "fetchStatus", false },
                { "fetchTicker", true },
                { "fetchTickers", true },
                { "fetchTime", false },
                { "fetchTrades", true },
                { "fetchTradingFee", false },
                { "fetchTradingFees", false },
                { "fetchTradingLimits", false },
                { "fetchTransactionFee", false },
                { "fetchTransactionFees", false },
                { "fetchTransactions", true },
                { "fetchTransfers", false },
                { "fetchWithdrawal", false },
                { "fetchWithdrawals", false },
                { "fetchWithdrawalWhitelist", false },
                { "reduceMargin", false },
                { "repayMargin", false },
                { "setLeverage", false },
                { "setMargin", false },
                { "setMarginMode", false },
                { "setPositionMode", false },
                { "signIn", false },
                { "transfer", false },
                { "withdraw", false },
                { "ws", false },
            } },
            { "timeframes", new Dictionary<string, object>() {
                { "1m", "1" },
                { "5m", "5" },
                { "15m", "15" },
                { "1h", "60" },
                { "1d", "1D" },
            } },
            { "urls", new Dictionary<string, object>() {
                { "logo", "https://github.com/ccxt/ccxt/assets/43336371/cf71fe3d-b8b4-40f2-a906-907661b28793" },
                { "api", new Dictionary<string, object>() {
                    { "history", "https://history.bit.team" },
                    { "public", "https://bit.team" },
                    { "private", "https://bit.team" },
                } },
                { "www", "https://bit.team/" },
                { "referral", "https://bit.team/auth/sign-up?ref=bitboy2023" },
                { "doc", new List<object>() {"https://bit.team/trade/api/documentation"} },
            } },
            { "api", new Dictionary<string, object>() {
                { "history", new Dictionary<string, object>() {
                    { "get", new Dictionary<string, object>() {
                        { "api/tw/history/{pairName}/{resolution}", 1 },
                    } },
                } },
                { "public", new Dictionary<string, object>() {
                    { "get", new Dictionary<string, object>() {
                        { "trade/api/asset", 1 },
                        { "trade/api/currencies", 1 },
                        { "trade/api/orderbooks/{symbol}", 1 },
                        { "trade/api/orders", 1 },
                        { "trade/api/pair/{name}", 1 },
                        { "trade/api/pairs", 1 },
                        { "trade/api/pairs/precisions", 1 },
                        { "trade/api/rates", 1 },
                        { "trade/api/trade/{id}", 1 },
                        { "trade/api/trades", 1 },
                        { "trade/api/ccxt/pairs", 1 },
                        { "trade/api/cmc/assets", 1 },
                        { "trade/api/cmc/orderbook/{pair}", 1 },
                        { "trade/api/cmc/summary", 1 },
                        { "trade/api/cmc/ticker", 1 },
                        { "trade/api/cmc/trades/{pair}", 1 },
                    } },
                } },
                { "private", new Dictionary<string, object>() {
                    { "get", new Dictionary<string, object>() {
                        { "trade/api/ccxt/balance", 1 },
                        { "trade/api/ccxt/order/{id}", 1 },
                        { "trade/api/ccxt/ordersOfUser", 1 },
                        { "trade/api/ccxt/tradesOfUser", 1 },
                        { "trade/api/transactionsOfUser", 1 },
                    } },
                    { "post", new Dictionary<string, object>() {
                        { "trade/api/ccxt/cancel-all-order", 1 },
                        { "trade/api/ccxt/cancelorder", 1 },
                        { "trade/api/ccxt/ordercreate", 1 },
                    } },
                } },
            } },
            { "fees", new Dictionary<string, object>() {
                { "trading", new Dictionary<string, object>() {
                    { "feeSide", "get" },
                    { "tierBased", false },
                    { "percentage", true },
                    { "taker", this.parseNumber("0.002") },
                    { "maker", this.parseNumber("0.002") },
                } },
            } },
            { "precisionMode", DECIMAL_PLACES },
            { "options", new Dictionary<string, object>() {
                { "networksById", new Dictionary<string, object>() {
                    { "Ethereum", "ERC20" },
                    { "ethereum", "ERC20" },
                    { "Tron", "TRC20" },
                    { "tron", "TRC20" },
                    { "Binance", "BSC" },
                    { "binance", "BSC" },
                    { "Binance Smart Chain", "BSC" },
                    { "bscscan", "BSC" },
                    { "Bitcoin", "BTC" },
                    { "bitcoin", "BTC" },
                    { "Litecoin", "LTC" },
                    { "litecoin", "LTC" },
                    { "Polygon", "POLYGON" },
                    { "polygon", "POLYGON" },
                    { "PRIZM", "PRIZM" },
                    { "Decimal", "Decimal" },
                    { "ufobject", "ufobject" },
                    { "tonchain", "tonchain" },
                } },
                { "currenciesValuedInUsd", new Dictionary<string, object>() {
                    { "USDT", true },
                    { "BUSD", true },
                } },
            } },
            { "exceptions", new Dictionary<string, object>() {
                { "exact", new Dictionary<string, object>() {
                    { "400002", typeof(BadSymbol) },
                    { "401000", typeof(AuthenticationError) },
                    { "403002", typeof(BadRequest) },
                    { "404200", typeof(BadSymbol) },
                } },
                { "broad", new Dictionary<string, object>() {
                    { "is not allowed", typeof(BadRequest) },
                    { "Insufficient funds", typeof(InsufficientFunds) },
                    { "Invalid request params input", typeof(BadRequest) },
                    { "must be a number", typeof(BadRequest) },
                    { "must be a string", typeof(BadRequest) },
                    { "must be of type", typeof(BadRequest) },
                    { "must be one of", typeof(BadRequest) },
                    { "Order not found", typeof(OrderNotFound) },
                    { "Pair with pair name", typeof(BadSymbol) },
                    { "pairName", typeof(BadSymbol) },
                    { "Service Unavailable", typeof(ExchangeNotAvailable) },
                    { "Symbol ", typeof(BadSymbol) },
                } },
            } },
        });
    }

    public async override Task<object> fetchMarkets(object parameters = null)
    {
        /**
        * @method
        * @name bitteam#fetchMarkets
        * @description retrieves data on all markets for bitteam
        * @see https://bit.team/trade/api/documentation#/CCXT/getTradeApiCcxtPairs
        * @param {object} [params] extra parameters specific to the exchange api endpoint
        * @returns {object[]} an array of objects representing market data
        */
        parameters ??= new Dictionary<string, object>();
        object response = await this.publicGetTradeApiCcxtPairs(parameters);
        //
        //     {
        //         "ok": true,
        //         "result": {
        //             "count": 28,
        //             "pairs": [
        //                 {
        //                     "id": 2,
        //                     "name": "eth_usdt",
        //                     "baseAssetId": 2,
        //                     "quoteAssetId": 3,
        //                     "fullName": "ETH USDT",
        //                     "description": "ETH   USDT",
        //                     "lastBuy": 1964.665001,
        //                     "lastSell": 1959.835005,
        //                     "lastPrice": 1964.665001,
        //                     "change24": 1.41,
        //                     "volume24": 28.22627543,
        //                     "volume24USD": 55662.35636401598,
        //                     "active": true,
        //                     "baseStep": 8,
        //                     "quoteStep": 6,
        //                     "status": 1,
        //                     "settings": {
        //                         "limit_usd": "0.1",
        //                         "price_max": "10000000000000",
        //                         "price_min": "1",
        //                         "price_tick": "1",
        //                         "pricescale": 10000,
        //                         "lot_size_max": "1000000000000000",
        //                         "lot_size_min": "1",
        //                         "lot_size_tick": "1",
        //                         "price_view_min": 6,
        //                         "default_slippage": 10,
        //                         "lot_size_view_min": 6
        //                     },
        //                     "updateId": "50620",
        //                     "timeStart": "2021-01-28T09:19:30.706Z",
        //                     "makerFee": 200,
        //                     "takerFee": 200,
        //                     "quoteVolume24": 54921.93404134529,
        //                     "lowPrice24": 1919.355,
        //                     "highPrice24": 1971.204995
        //                 },
        //                 {
        //                     "id": 27,
        //                     "name": "ltc_usdt",
        //                     "baseAssetId": 13,
        //                     "quoteAssetId": 3,
        //                     "fullName": "LTC USDT",
        //                     "description": "This is LTC USDT",
        //                     "lastBuy": 53.14,
        //                     "lastSell": 53.58,
        //                     "lastPrice": 53.58,
        //                     "change24": -6.72,
        //                     "volume24": 0,
        //                     "volume24USD": null,
        //                     "active": true,
        //                     "baseStep": 8,
        //                     "quoteStep": 6,
        //                     "status": 0,
        //                     "settings": {
        //                         "limit_usd": "0.1",
        //                         "price_max": "1000000000000",
        //                         "price_min": "1",
        //                         "price_tick": "1",
        //                         "pricescale": 10000,
        //                         "lot_size_max": "1000000000000",
        //                         "lot_size_min": "1",
        //                         "lot_size_tick": "1",
        //                         "price_view_min": 6,
        //                         "default_slippage": 10,
        //                         "lot_size_view_min": 6
        //                     },
        //                     "updateId": "30",
        //                     "timeStart": "2021-10-13T12:11:05.359Z",
        //                     "makerFee": 200,
        //                     "takerFee": 200,
        //                     "quoteVolume24": 0,
        //                     "lowPrice24": null,
        //                     "highPrice24": null
        //                 }
        //             ]
        //         }
        //     }
        //
        object result = this.safeValue(response, "result", new Dictionary<string, object>() {});
        object markets = this.safeValue(result, "pairs", new List<object>() {});
        return this.parseMarkets(markets);
    }

    public override object parseMarket(object market)
    {
        object id = this.safeString(market, "name");
        object numericId = this.safeInteger(market, "id");
        object parts = ((string)id).Split(new [] {((string)"_")}, StringSplitOptions.None).ToList<object>();
        object baseId = this.safeString(parts, 0);
        object quoteId = this.safeString(parts, 1);
        object bs = this.safeCurrencyCode(baseId);
        object quote = this.safeCurrencyCode(quoteId);
        object active = this.safeValue(market, "active");
        object amountPrecision = this.safeInteger(market, "baseStep");
        object pricePrecision = this.safeInteger(market, "quoteStep");
        object timeStart = this.safeString(market, "timeStart");
        object created = this.parse8601(timeStart);
        object minCost = null;
        object currenciesValuedInUsd = this.safeValue(this.options, "currenciesValuedInUsd", new Dictionary<string, object>() {});
        object quoteInUsd = this.safeBool(currenciesValuedInUsd, quote, false);
        if (isTrue(quoteInUsd))
        {
            object settings = this.safeValue(market, "settings", new Dictionary<string, object>() {});
            minCost = this.safeNumber(settings, "limit_usd");
        }
        return this.safeMarketStructure(new Dictionary<string, object>() {
            { "id", id },
            { "numericId", numericId },
            { "symbol", add(add(bs, "/"), quote) },
            { "base", bs },
            { "quote", quote },
            { "settle", null },
            { "baseId", baseId },
            { "quoteId", quoteId },
            { "settleId", null },
            { "type", "spot" },
            { "spot", true },
            { "margin", false },
            { "swap", false },
            { "future", false },
            { "option", false },
            { "active", active },
            { "contract", false },
            { "linear", null },
            { "inverse", null },
            { "contractSize", null },
            { "expiry", null },
            { "expiryDatetime", null },
            { "strike", null },
            { "optionType", null },
            { "precision", new Dictionary<string, object>() {
                { "amount", amountPrecision },
                { "price", pricePrecision },
            } },
            { "limits", new Dictionary<string, object>() {
                { "leverage", new Dictionary<string, object>() {
                    { "min", null },
                    { "max", null },
                } },
                { "amount", new Dictionary<string, object>() {
                    { "min", null },
                    { "max", null },
                } },
                { "price", new Dictionary<string, object>() {
                    { "min", null },
                    { "max", null },
                } },
                { "cost", new Dictionary<string, object>() {
                    { "min", minCost },
                    { "max", null },
                } },
            } },
            { "created", created },
            { "info", market },
        });
    }

    public async override Task<object> fetchCurrencies(object parameters = null)
    {
        /**
        * @method
        * @name bitteam#fetchCurrencies
        * @description fetches all available currencies on an exchange
        * @see https://bit.team/trade/api/documentation#/PUBLIC/getTradeApiCurrencies
        * @param {object} [params] extra parameters specific to the bitteam api endpoint
        * @returns {object} an associative dictionary of currencies
        */
        parameters ??= new Dictionary<string, object>();
        object response = await this.publicGetTradeApiCurrencies(parameters);
        //
        //     {
        //         "ok": true,
        //         "result": {
        //             "count": 24,
        //             "currencies": [
        //                 {
        //                     "txLimits": {
        //                         "minDeposit": "0.0001",
        //                         "minWithdraw": "0.02",
        //                         "maxWithdraw": "10000",
        //                         "withdrawCommissionPercentage": "NaN",
        //                         "withdrawCommissionFixed": "0.005"
        //                     },
        //                     "id": 2,
        //                     "status": 1,
        //                     "symbol": "eth",
        //                     "title": "Ethereum",
        //                     "logoURL": "https://ethereum.org/static/6b935ac0e6194247347855dc3d328e83/34ca5/eth-diamond-black.png",
        //                     "isDiscount": false,
        //                     "address": "https://ethereum.org/",
        //                     "description": "Ethereum ETH",
        //                     "decimals": 18,
        //                     "blockChain": "Ethereum",
        //                     "precision": 8,
        //                     "currentRate": null,
        //                     "active": true,
        //                     "timeStart": "2021-01-28T08:57:41.719Z",
        //                     "type": "crypto",
        //                     "typeNetwork": "internalGW",
        //                     "idSorting": 2,
        //                     "links": [
        //                         {
        //                             "tx": "https://etherscan.io/tx/",
        //                             "address": "https://etherscan.io/address/",
        //                             "blockChain": "Ethereum"
        //                         }
        //                     ]
        //                 },
        //                 {
        //                     "txLimits": {
        //                         "minDeposit": "0.001",
        //                         "minWithdraw": "1",
        //                         "maxWithdraw": "100000",
        //                         "withdrawCommissionPercentage": "NaN",
        //                         "withdrawCommissionFixed": {
        //                             "Tron": "2",
        //                             "Binance": "2",
        //                             "Ethereum": "20"
        //                         }
        //                     },
        //                     "id": 3,
        //                     "status": 1,
        //                     "symbol": "usdt",
        //                     "title": "Tether USD",
        //                     "logoURL": "https://cryptologos.cc/logos/tether-usdt-logo.png?v=010",
        //                     "isDiscount": false,
        //                     "address": "https://tether.to/",
        //                     "description": "Tether USD",
        //                     "decimals": 6,
        //                     "blockChain": "",
        //                     "precision": 6,
        //                     "currentRate": null,
        //                     "active": true,
        //                     "timeStart": "2021-01-28T09:04:17.170Z",
        //                     "type": "crypto",
        //                     "typeNetwork": "internalGW",
        //                     "idSorting": 0,
        //                     "links": [
        //                         {
        //                             "tx": "https://etherscan.io/tx/",
        //                             "address": "https://etherscan.io/address/",
        //                             "blockChain": "Ethereum"
        //                         },
        //                         {
        //                             "tx": "https://tronscan.org/#/transaction/",
        //                             "address": "https://tronscan.org/#/address/",
        //                             "blockChain": "Tron"
        //                         },
        //                         {
        //                             "tx": "https://bscscan.com/tx/",
        //                             "address": "https://bscscan.com/address/",
        //                             "blockChain": "Binance"
        //                         }
        //                     ]
        //                 }
        //             ]
        //         }
        //     }
        //
        object responseResult = this.safeValue(response, "result", new Dictionary<string, object>() {});
        object currencies = this.safeValue(responseResult, "currencies", new List<object>() {});
        // usding another endpoint to fetch statuses of deposits and withdrawals
        object statusesResponse = await this.publicGetTradeApiCmcAssets();
        //
        //     {
        //         "ZNX": {
        //             "name": "ZeNeX Coin",
        //             "unified_cryptoasset_id": 30,
        //             "withdrawStatus": true,
        //             "depositStatus": true,
        //             "min_withdraw": 0.00001,
        //             "max_withdraw": 10000
        //         },
        //         "USDT": {
        //             "name": "Tether USD",
        //             "unified_cryptoasset_id": 3,
        //             "withdrawStatus": true,
        //             "depositStatus": true,
        //             "min_withdraw": 1,
        //             "max_withdraw": 100000
        //         },
        //     }
        //
        statusesResponse = this.indexBy(statusesResponse, "unified_cryptoasset_id");
        object result = new Dictionary<string, object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(currencies)); postFixIncrement(ref i))
        {
            object currency = getValue(currencies, i);
            object id = this.safeString(currency, "symbol");
            object numericId = this.safeInteger(currency, "id");
            object code = this.safeCurrencyCode(id);
            object active = this.safeBool(currency, "active", false);
            object precision = this.safeInteger(currency, "precision");
            object txLimits = this.safeValue(currency, "txLimits", new Dictionary<string, object>() {});
            object minWithdraw = this.safeString(txLimits, "minWithdraw");
            object maxWithdraw = this.safeString(txLimits, "maxWithdraw");
            object minDeposit = this.safeString(txLimits, "minDeposit");
            object fee = null;
            object withdrawCommissionFixed = ((object)this.safeValue(txLimits, "withdrawCommissionFixed", new Dictionary<string, object>() {}));
            object feesByNetworkId = new Dictionary<string, object>() {};
            object blockChain = this.safeString(currency, "blockChain");
            // if only one blockChain
            if (isTrue(isTrue((!isEqual(blockChain, null))) && isTrue((!isEqual(blockChain, "")))))
            {
                fee = this.parseNumber(withdrawCommissionFixed);
                ((IDictionary<string,object>)feesByNetworkId)[(string)blockChain] = fee;
            } else
            {
                feesByNetworkId = withdrawCommissionFixed;
            }
            object statuses = this.safeValue(statusesResponse, numericId, new Dictionary<string, object>() {});
            object deposit = this.safeValue(statuses, "depositStatus");
            object withdraw = this.safeValue(statuses, "withdrawStatus");
            object networkIds = new List<object>(((IDictionary<string,object>)feesByNetworkId).Keys);
            object networks = new Dictionary<string, object>() {};
            object networkPrecision = this.safeInteger(currency, "decimals");
            for (object j = 0; isLessThan(j, getArrayLength(networkIds)); postFixIncrement(ref j))
            {
                object networkId = getValue(networkIds, j);
                object networkCode = this.networkIdToCode(networkId, code);
                object networkFee = this.safeNumber(feesByNetworkId, networkId);
                ((IDictionary<string,object>)networks)[(string)networkCode] = new Dictionary<string, object>() {
                    { "id", networkId },
                    { "network", networkCode },
                    { "deposit", deposit },
                    { "withdraw", withdraw },
                    { "active", active },
                    { "fee", networkFee },
                    { "precision", networkPrecision },
                    { "limits", new Dictionary<string, object>() {
                        { "amount", new Dictionary<string, object>() {
                            { "min", null },
                            { "max", null },
                        } },
                        { "withdraw", new Dictionary<string, object>() {
                            { "min", this.parseNumber(minWithdraw) },
                            { "max", this.parseNumber(maxWithdraw) },
                        } },
                        { "deposit", new Dictionary<string, object>() {
                            { "min", this.parseNumber(minDeposit) },
                            { "max", null },
                        } },
                    } },
                    { "info", currency },
                };
            }
            ((IDictionary<string,object>)result)[(string)code] = new Dictionary<string, object>() {
                { "id", id },
                { "numericId", numericId },
                { "code", code },
                { "name", code },
                { "info", currency },
                { "active", active },
                { "deposit", deposit },
                { "withdraw", withdraw },
                { "fee", fee },
                { "precision", precision },
                { "limits", new Dictionary<string, object>() {
                    { "amount", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                    { "withdraw", new Dictionary<string, object>() {
                        { "min", this.parseNumber(minWithdraw) },
                        { "max", this.parseNumber(maxWithdraw) },
                    } },
                    { "deposit", new Dictionary<string, object>() {
                        { "min", this.parseNumber(minDeposit) },
                        { "max", null },
                    } },
                } },
                { "networks", networks },
            };
        }
        return result;
    }

    public async override Task<object> fetchOHLCV(object symbol, object timeframe = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bitteam#fetchOHLCV
        * @description fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
        * @param {string} symbol unified symbol of the market to fetch OHLCV data for
        * @param {string} timeframe the length of time each candle represents
        * @param {int} [since] timestamp in ms of the earliest candle to fetch
        * @param {int} [limit] the maximum amount of candles to fetch
        * @param {object} [params] extra parameters specific to the bitteam api endpoint
        * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
        */
        timeframe ??= "1m";
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object resolution = this.safeString(this.timeframes, timeframe, timeframe);
        object request = new Dictionary<string, object>() {
            { "pairName", getValue(market, "id") },
            { "resolution", resolution },
        };
        object response = await this.historyGetApiTwHistoryPairNameResolution(this.extend(request, parameters));
        //
        //     {
        //         "ok": true,
        //         "result": {
        //             "count": 364,
        //             "data": [
        //                 {
        //                     "t": 1669593600,
        //                     "o": 16211.259266,
        //                     "h": 16476.985001,
        //                     "l": 16023.714999,
        //                     "c": 16430.636894,
        //                     "v": 2.60150368999999
        //                 },
        //                 {
        //                     "t": 1669680000,
        //                     "o": 16430.636894,
        //                     "h": 17065.229582,
        //                     "l": 16346.114155,
        //                     "c": 16882.297736,
        //                     "v": 3.0872548400000115
        //                 },
        //                 ...
        //             ]
        //         }
        //     }
        //
        object result = this.safeValue(response, "result", new Dictionary<string, object>() {});
        object data = this.safeList(result, "data", new List<object>() {});
        return this.parseOHLCVs(data, market, timeframe, since, limit);
    }

    public override object parseOHLCV(object ohlcv, object market = null)
    {
        //
        //     {
        //         "t": 1669680000,
        //         "o": 16430.636894,
        //         "h": 17065.229582,
        //         "l": 16346.114155,
        //         "c": 16882.297736,
        //         "v": 3.0872548400000115
        //     },
        //
        return new List<object> {this.safeTimestamp(ohlcv, "t"), this.safeNumber(ohlcv, "o"), this.safeNumber(ohlcv, "h"), this.safeNumber(ohlcv, "l"), this.safeNumber(ohlcv, "c"), this.safeNumber(ohlcv, "v")};
    }

    public async override Task<object> fetchOrderBook(object symbol, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bitteam#fetchOrderBook
        * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
        * @see https://bit.team/trade/api/documentation#/CMC/getTradeApiCmcOrderbookPair
        * @param {string} symbol unified symbol of the market to fetch the order book for
        * @param {int} [limit] the maximum amount of order book entries to return (default 100, max 200)
        * @param {object} [params] extra parameters specific to the bitteam api endpoint
        * @returns {object} A dictionary of [order book structures]{@link https://github.com/ccxt/ccxt/wiki/Manual#order-book-structure} indexed by market symbols
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "pair", getValue(market, "id") },
        };
        object response = await this.publicGetTradeApiCmcOrderbookPair(this.extend(request, parameters));
        //
        //     {
        //         "timestamp": 1701166703285,
        //         "bids": [
        //             [
        //                 2019.334988,
        //                 0.09048525
        //             ],
        //             [
        //                 1999.860002,
        //                 0.0225
        //             ],
        //             ...
        //         ],
        //         "asks": [
        //             [
        //                 2019.334995,
        //                 0.00899078
        //             ],
        //             [
        //                 2019.335013,
        //                 0.09833052
        //             ],
        //             ...
        //         ]
        //     }
        //
        object timestamp = this.safeInteger(response, "timestamp");
        object orderbook = this.parseOrderBook(response, symbol, timestamp);
        return orderbook;
    }

    public async override Task<object> fetchOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bitteam#fetchOrders
        * @description fetches information on multiple orders made by the user
        * @see https://bit.team/trade/api/documentation#/PRIVATE/getTradeApiCcxtOrdersofuser
        * @param {string} symbol unified market symbol of the market orders were made in
        * @param {int} [since] the earliest time in ms to fetch orders for
        * @param {int} [limit] the maximum number of  orde structures to retrieve (default 10)
        * @param {object} [params] extra parameters specific to the bitteam api endpoint
        * @param {string} [params.type] the status of the order - 'active', 'closed', 'cancelled', 'all', 'history' (default 'all')
        * @returns {Order[]} a list of [order structures]{@link https://github.com/ccxt/ccxt/wiki/Manual#order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object type = this.safeString(parameters, "type", "all");
        object request = new Dictionary<string, object>() {
            { "type", type },
        };
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            ((IDictionary<string,object>)request)["pair"] = getValue(market, "id");
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        object response = await this.privateGetTradeApiCcxtOrdersOfUser(this.extend(request, parameters));
        //
        //     {
        //         "ok": true,
        //         "result": {
        //             "count": 3,
        //             "orders": [
        //                 {
        //                     "id": 106733026,
        //                     "orderId": null,
        //                     "userId": 21639,
        //                     "pair": "btc_usdt",
        //                     "pairId": 22,
        //                     "quantity": "0.00001",
        //                     "price": "40",
        //                     "executedPrice": "0",
        //                     "fee": null,
        //                     "orderCid": null,
        //                     "executed": "0",
        //                     "expires": null,
        //                     "baseDecimals": 8,
        //                     "quoteDecimals": 6,
        //                     "timestamp": 1700594804,
        //                     "status": "inactive",
        //                     "side": "buy",
        //                     "type": "limit",
        //                     "createdAt": "2023-11-21T19:26:43.868Z",
        //                     "updatedAt": "2023-11-21T19:26:43.868Z"
        //                 },
        //                 {
        //                     "id": 106733308,
        //                     "orderId": "13074362",
        //                     "userId": 21639,
        //                     "pair": "btc_usdt",
        //                     "pairId": 22,
        //                     "quantity": "0.00001",
        //                     "price": "50000",
        //                     "executedPrice": "37017.495008",
        //                     "fee": {
        //                         "amount": "0.00000002",
        //                         "symbol": "btc",
        //                         "userId": 21639,
        //                         "decimals": 8,
        //                         "symbolId": 11
        //                     },
        //                     "orderCid": null,
        //                     "executed": "0.00001",
        //                     "expires": null,
        //                     "baseDecimals": 8,
        //                     "quoteDecimals": 6,
        //                     "timestamp": 1700594959,
        //                     "status": "executed",
        //                     "side": "buy",
        //                     "type": "limit",
        //                     "createdAt": "2023-11-21T19:29:19.946Z",
        //                     "updatedAt": "2023-11-21T19:29:19.946Z"
        //                 },
        //                 {
        //                     "id": 106734455,
        //                     "orderId": "13248984",
        //                     "userId": 21639,
        //                     "pair": "eth_usdt",
        //                     "pairId": 2,
        //                     "quantity": "0.001",
        //                     "price": "1750",
        //                     "executedPrice": "0",
        //                     "fee": null,
        //                     "orderCid": null,
        //                     "executed": "0",
        //                     "expires": null,
        //                     "baseDecimals": 18,
        //                     "quoteDecimals": 6,
        //                     "timestamp": 1700595523,
        //                     "status": "accepted",
        //                     "side": "buy",
        //                     "type": "limit",
        //                     "createdAt": "2023-11-21T19:38:43.530Z",
        //                     "updatedAt": "2023-11-21T19:38:43.530Z"
        //                 }
        //             ]
        //         }
        //     }
        //
        object result = this.safeValue(response, "result", new Dictionary<string, object>() {});
        object orders = this.safeList(result, "orders", new List<object>() {});
        return this.parseOrders(orders, market, since, limit);
    }

    public async override Task<object> fetchOrder(object id, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name bitteam#fetchOrder
        * @description fetches information on an order
        * @see https://bit.team/trade/api/documentation#/PRIVATE/getTradeApiCcxtOrderId
        * @param {int|string} id order id
        * @param {string} symbol not used by bitteam fetchOrder ()
        * @param {object} [params] extra parameters specific to the bitteam api endpoint
        * @returns {object} An [order structure]{@link https://github.com/ccxt/ccxt/wiki/Manual#order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {
            { "id", id },
        };
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
        }
        object response = await this.privateGetTradeApiCcxtOrderId(this.extend(request, parameters));
        //
        //     {
        //         "ok": true,
        //         "result": {
        //             "id": 106494347,
        //             "orderId": "13214332",
        //             "userId": 15912,
        //             "pair": "eth_usdt",
        //             "pairId": 2,
        //             "quantity": "0.00448598",
        //             "price": "2015.644995",
        //             "executedPrice": "2015.644995",
        //             "fee": {
        //                 "amount": "0",
        //                 "symbol": "eth",
        //                 "userId": 15912,
        //                 "decimals": 18,
        //                 "symbolId": 2,
        //                 "discountAmount": "0",
        //                 "discountSymbol": "btt",
        //                 "discountDecimals": 18,
        //                 "discountSymbolId": 5
        //             },
        //             "orderCid": null,
        //             "executed": "0.00448598",
        //             "expires": null,
        //             "baseDecimals": 18,
        //             "quoteDecimals": 6,
        //             "timestamp": 1700470476,
        //             "status": "executed",
        //             "side": "buy",
        //             "type": "limit",
        //             "stopPrice": null,
        //             "slippage": null
        //         }
        //     }
        //
        object result = this.safeDict(response, "result");
        return this.parseOrder(result, market);
    }

    public async override Task<object> fetchOpenOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bitteam#fetchOpenOrders
        * @description fetch all unfilled currently open orders
        * @see https://bit.team/trade/api/documentation#/PRIVATE/getTradeApiCcxtOrdersofuser
        * @param {string} symbol unified market symbol
        * @param {int} [since] the earliest time in ms to fetch open orders for
        * @param {int} [limit] the maximum number of open order structures to retrieve (default 10)
        * @param {object} [params] extra parameters specific to the bitteam api endpoint
        * @returns {Order[]} a list of [order structures]{@link https://github.com/ccxt/ccxt/wiki/Manual#order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {
            { "type", "active" },
        };
        return await this.fetchOrders(symbol, since, limit, this.extend(request, parameters));
    }

    public async override Task<object> fetchClosedOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bitteam#fetchClosedOrders
        * @description fetches information on multiple closed orders made by the user
        * @see https://bit.team/trade/api/documentation#/PRIVATE/getTradeApiCcxtOrdersofuser
        * @param {string} symbol unified market symbol of the market orders were made in
        * @param {int} [since] the earliest time in ms to fetch orders for
        * @param {int} [limit] the maximum number of closed order structures to retrieve (default 10)
        * @param {object} [params] extra parameters specific to the bitteam api endpoint
        * @returns {Order[]} a list of [order structures]{@link https://github.com/ccxt/ccxt/wiki/Manual#order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {
            { "type", "closed" },
        };
        return await this.fetchOrders(symbol, since, limit, this.extend(request, parameters));
    }

    public async virtual Task<object> fetchCanceledOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bitteam#fetchCanceledOrders
        * @description fetches information on multiple canceled orders made by the user
        * @see https://bit.team/trade/api/documentation#/PRIVATE/getTradeApiCcxtOrdersofuser
        * @param {string} symbol unified market symbol of the market orders were made in
        * @param {int} [since] the earliest time in ms to fetch orders for
        * @param {int} [limit] the maximum number of canceled order structures to retrieve (default 10)
        * @param {object} [params] extra parameters specific to the bitteam api endpoint
        * @returns {object} a list of [order structures]{@link https://github.com/ccxt/ccxt/wiki/Manual#order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {
            { "type", "cancelled" },
        };
        return await this.fetchOrders(symbol, since, limit, this.extend(request, parameters));
    }

    public async override Task<object> createOrder(object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        /**
        * @method
        * @name bitteam#createOrder
        * @description create a trade order
        * @see https://bit.team/trade/api/documentation#/PRIVATE/postTradeApiCcxtOrdercreate
        * @param {string} symbol unified symbol of the market to create an order in
        * @param {string} type 'market' or 'limit'
        * @param {string} side 'buy' or 'sell'
        * @param {float} amount how much of currency you want to trade in units of base currency
        * @param {float} [price] the price at which the order is to be fullfilled, in units of the quote currency, ignored in market orders
        * @param {object} [params] extra parameters specific to the bitteam api endpoint
        * @returns {object} an [order structure]{@link https://github.com/ccxt/ccxt/wiki/Manual#order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "pairId", ((object)getValue(market, "numericId")).ToString() },
            { "type", type },
            { "side", side },
            { "amount", this.amountToPrecision(symbol, amount) },
        };
        if (isTrue(isEqual(type, "limit")))
        {
            if (isTrue(isEqual(price, null)))
            {
                throw new ArgumentsRequired ((string)add(add(add(this.id, " createOrder() requires a price argument for a "), type), " order")) ;
            } else
            {
                ((IDictionary<string,object>)request)["price"] = this.priceToPrecision(symbol, price);
            }
        }
        object response = await this.privatePostTradeApiCcxtOrdercreate(this.extend(request, parameters));
        //
        //     {
        //         "ok": true,
        //         "result": {
        //             "id": 106733308,
        //             "userId": 21639,
        //             "quantity": "0.00001",
        //             "pair": "btc_usdt",
        //             "side": "buy",
        //             "price": "50000",
        //             "executed": "0",
        //             "executedPrice": "0",
        //             "status": "created",
        //             "baseDecimals": 8,
        //             "quoteDecimals": 6,
        //             "pairId": 22,
        //             "type": "limit",
        //             "stopPrice": null,
        //             "slippage": null,
        //             "timestamp": "1700594959"
        //         }
        //     }
        //
        object order = this.safeDict(response, "result", new Dictionary<string, object>() {});
        return this.parseOrder(order, market);
    }

    public async override Task<object> cancelOrder(object id, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name bitteam#cancelOrder
        * @description cancels an open order
        * @see https://bit.team/trade/api/documentation#/PRIVATE/postTradeApiCcxtCancelorder
        * @param {string} id order id
        * @param {string} symbol not used by bitteam cancelOrder ()
        * @param {object} [params] extra parameters specific to the bitteam api endpoint
        * @returns {object} An [order structure]{@link https://github.com/ccxt/ccxt/wiki/Manual#order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {
            { "id", id },
        };
        object response = await this.privatePostTradeApiCcxtCancelorder(this.extend(request, parameters));
        //
        //     {
        //         "ok": true,
        //         "result": {
        //             "message": "The request to cancel your order was received"
        //         }
        //     }
        //
        object result = this.safeDict(response, "result", new Dictionary<string, object>() {});
        return this.parseOrder(result);
    }

    public async override Task<object> cancelAllOrders(object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name bitteam#cancelAllOrders
        * @description cancel open orders of market
        * @see https://bit.team/trade/api/documentation#/PRIVATE/postTradeApiCcxtCancelallorder
        * @param {string} symbol unified market symbol
        * @param {object} [params] extra parameters specific to the bitteam api endpoint
        * @returns {object[]} a list of [order structures]{@link https://github.com/ccxt/ccxt/wiki/Manual#order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = null;
        object request = new Dictionary<string, object>() {};
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            ((IDictionary<string,object>)request)["pairId"] = ((object)getValue(market, "numericId")).ToString();
        } else
        {
            ((IDictionary<string,object>)request)["pairId"] = "0"; // '0' for all markets
        }
        object response = await this.privatePostTradeApiCcxtCancelAllOrder(this.extend(request, parameters));
        //
        //     {
        //         "ok": true,
        //         "result": {
        //             "message":"The request to cancel all your orders was received"
        //         }
        //     }
        //
        object result = this.safeValue(response, "result", new Dictionary<string, object>() {});
        object orders = new List<object>() {result};
        return this.parseOrders(orders, market);
    }

    public override object parseOrder(object order, object market = null)
    {
        //
        // fetchOrders
        //     {
        //         "id": 106733308,
        //         "orderId": "13074362",
        //         "userId": 21639,
        //         "pair": "btc_usdt",
        //         "pairId": 22,
        //         "quantity": "0.00001",
        //         "price": "50000",
        //         "executedPrice": "37017.495008",
        //         "fee": {
        //             "amount": "0.00000002",
        //             "symbol": "btc",
        //             "userId": 21639,
        //             "decimals": 8,
        //             "symbolId": 11
        //         },
        //         "orderCid": null,
        //         "executed": "0.00001",
        //         "expires": null,
        //         "baseDecimals": 8,
        //         "quoteDecimals": 6,
        //         "timestamp": 1700594959,
        //         "status": "executed",
        //         "side": "buy",
        //         "type": "limit",
        //         "createdAt": "2023-11-21T19:29:19.946Z",
        //         "updatedAt": "2023-11-21T19:29:19.946Z"
        //     },
        //
        // fetchOrder
        //     {
        //         "id": 106494347,
        //         "orderId": "13214332",
        //         "userId": 15912,
        //         "pair": "eth_usdt",
        //         "pairId": 2,
        //         "quantity": "0.00448598",
        //         "price": "2015.644995",
        //         "executedPrice": "2015.644995",
        //         "fee": {
        //             "amount": "0",
        //             "symbol": "eth",
        //             "userId": 15912,
        //             "decimals": 18,
        //             "symbolId": 2,
        //             "discountAmount": "0",
        //             "discountSymbol": "btt",
        //             "discountDecimals": 18,
        //             "discountSymbolId": 5
        //         },
        //         "orderCid": null,
        //         "executed": "0.00448598",
        //         "expires": null,
        //         "baseDecimals": 18,
        //         "quoteDecimals": 6,
        //         "timestamp": 1700470476,
        //         "status": "executed",
        //         "side": "buy",
        //         "type": "limit",
        //         "stopPrice": null,
        //         "slippage": null
        //     }
        //
        // createOrder
        //     {
        //         "id": 106733308,
        //         "userId": 21639,
        //         "quantity": "0.00001",
        //         "pair": "btc_usdt",
        //         "side": "buy",
        //         "price": "50000",
        //         "executed": "0",
        //         "executedPrice": "0",
        //         "status": "created",
        //         "baseDecimals": 8,
        //         "quoteDecimals": 6,
        //         "pairId": 22,
        //         "type": "limit",
        //         "stopPrice": null,
        //         "slippage": null,
        //         "timestamp": "1700594959"
        //     }
        //
        object id = this.safeString(order, "id");
        object marketId = this.safeString(order, "pair");
        market = this.safeMarket(marketId, market);
        object clientOrderId = this.safeString(order, "orderCid");
        object timestamp = null;
        object createdAt = this.safeString(order, "createdAt");
        if (isTrue(!isEqual(createdAt, null)))
        {
            timestamp = this.parse8601(createdAt);
        } else
        {
            timestamp = this.safeTimestamp(order, "timestamp");
        }
        object updatedAt = this.safeString(order, "updatedAt");
        object lastUpdateTimestamp = this.parse8601(updatedAt);
        object status = this.parseOrderStatus(this.safeString(order, "status"));
        object type = this.parseOrderType(this.safeString(order, "type"));
        object side = this.safeString(order, "side");
        object feeRaw = this.safeValue(order, "fee");
        object price = this.safeString(order, "price");
        object stopPrice = this.safeString(order, "stopPrice");
        object amount = this.safeString(order, "quantity");
        object filled = this.safeString(order, "executed");
        object fee = null;
        if (isTrue(!isEqual(feeRaw, null)))
        {
            object feeCost = this.safeString(feeRaw, "amount");
            object feeCurrencyId = this.safeString(feeRaw, "symbol");
            fee = new Dictionary<string, object>() {
                { "currency", this.safeCurrencyCode(feeCurrencyId) },
                { "cost", feeCost },
                { "rate", null },
            };
        }
        return this.safeOrder(new Dictionary<string, object>() {
            { "id", id },
            { "clientOrderId", clientOrderId },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "lastTradeTimestamp", null },
            { "lastUpdateTimestamp", lastUpdateTimestamp },
            { "status", status },
            { "symbol", getValue(market, "symbol") },
            { "type", type },
            { "timeInForce", "GTC" },
            { "side", side },
            { "price", price },
            { "stopPrice", stopPrice },
            { "triggerPrice", stopPrice },
            { "average", null },
            { "amount", amount },
            { "cost", null },
            { "filled", filled },
            { "remaining", null },
            { "fee", fee },
            { "trades", null },
            { "info", order },
            { "postOnly", false },
        }, market);
    }

    public virtual object parseOrderStatus(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "accepted", "open" },
            { "executed", "closed" },
            { "cancelled", "canceled" },
            { "partiallyCancelled", "canceled" },
            { "delete", "rejected" },
            { "inactive", "rejected" },
            { "executing", "open" },
            { "created", "open" },
        };
        return this.safeString(statuses, status, status);
    }

    public virtual object parseOrderType(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "market", "market" },
            { "limit", "limit" },
        };
        return this.safeString(statuses, status, status);
    }

    public virtual object parseValueToPricision(object valueObject, object valueKey, object preciseObject, object precisionKey)
    {
        object valueRawString = this.safeString(valueObject, valueKey);
        object precisionRawString = this.safeString(preciseObject, precisionKey);
        if (isTrue(isTrue(isEqual(valueRawString, null)) || isTrue(isEqual(precisionRawString, null))))
        {
            return null;
        }
        object precisionString = this.parsePrecision(precisionRawString);
        return Precise.stringMul(valueRawString, precisionString);
    }

    public async override Task<object> fetchTickers(object symbols = null, object parameters = null)
    {
        /**
        * @method
        * @name bitteam#fetchTickers
        * @description fetches price tickers for multiple markets, statistical calculations with the information calculated over the past 24 hours each market
        * @see https://bit.team/trade/api/documentation#/CMC/getTradeApiCmcSummary
        * @param {string[]|undefined} symbols unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
        * @param {object} [params] extra parameters specific to the bitteam api endpoint
        * @returns {object} a dictionary of [ticker structures]{@link https://github.com/ccxt/ccxt/wiki/Manual#ticker-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.publicGetTradeApiCmcSummary();
        //
        //     [
        //         {
        //             "trading_pairs": "BTC_USDT",
        //             "base_currency": "BTC",
        //             "quote_currency": "USDT",
        //             "last_price": 37669.955001,
        //             "lowest_ask": 37670.055,
        //             "highest_bid": 37669.955,
        //             "base_volume": 6.81156888,
        //             "quote_volume": 257400.516878529,
        //             "price_change_percent_24h": -0.29,
        //             "highest_price_24h": 38389.994463,
        //             "lowest_price_24h": 37574.894999
        //         },
        //         {
        //             "trading_pairs": "BNB_USDT",
        //             "base_currency": "BNB",
        //             "quote_currency": "USDT",
        //             "last_price": 233.525142,
        //             "lowest_ask": 233.675,
        //             "highest_bid": 233.425,
        //             "base_volume": 245.0199339,
        //             "quote_volume": 57356.91823827642,
        //             "price_change_percent_24h": -0.32,
        //             "highest_price_24h": 236.171123,
        //             "lowest_price_24h": 231.634637
        //         },
        //         ...
        //     ]
        //
        object tickers = new List<object>() {};
        if (!isTrue(((response is IList<object>) || (response.GetType().IsGenericType && response.GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>))))))
        {
            response = new List<object>() {};
        }
        for (object i = 0; isLessThan(i, getArrayLength(response)); postFixIncrement(ref i))
        {
            object rawTicker = getValue(response, i);
            object ticker = this.parseTicker(rawTicker);
            ((IList<object>)tickers).Add(ticker);
        }
        return this.filterByArrayTickers(tickers, "symbol", symbols);
    }

    public async override Task<object> fetchTicker(object symbol, object parameters = null)
    {
        /**
        * @method
        * @name bitteam#fetchTicker
        * @description fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
        * @see https://bit.team/trade/api/documentation#/PUBLIC/getTradeApiPairName
        * @param {string} symbol unified symbol of the market to fetch the ticker for
        * @param {object} [params] extra parameters specific to the bitteam api endpoint
        * @returns {object} a [ticker structure]{@link https://github.com/ccxt/ccxt/wiki/Manual#ticker-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "name", getValue(market, "id") },
        };
        object response = await this.publicGetTradeApiPairName(this.extend(request, parameters));
        //
        //     {
        //         "ok": true,
        //         "result": {
        //             "pair": {
        //                 "id": 2,
        //                 "name": "eth_usdt",
        //                 "baseAssetId": 2,
        //                 "quoteAssetId": 3,
        //                 "fullName": "ETH USDT",
        //                 "description": "ETH   USDT",
        //                 "lastBuy": "1976.715012",
        //                 "lastSell": "1971.995006",
        //                 "lastPrice": "1976.715012",
        //                 "change24": "1.02",
        //                 "volume24": 24.0796457,
        //                 "volume24USD": 44282.347995912205,
        //                 "active": true,
        //                 "baseStep": 8,
        //                 "quoteStep": 6,
        //                 "status": 1,
        //                 "settings": {
        //                     "limit_usd": "0.1",
        //                     "price_max": "10000000000000",
        //                     "price_min": "1",
        //                     "price_tick": "1",
        //                     "pricescale": 10000,
        //                     "lot_size_max": "1000000000000000",
        //                     "lot_size_min": "1",
        //                     "lot_size_tick": "1",
        //                     "price_view_min": 6,
        //                     "default_slippage": 10,
        //                     "lot_size_view_min": 6
        //                 },
        //                 "asks": [
        //                     {
        //                     "price": "1976.405003",
        //                     "quantity": "0.0051171",
        //                     "amount": "10.1134620408513"
        //                     },
        //                     {
        //                     "price": "1976.405013",
        //                     "quantity": "0.09001559",
        //                     "amount": "177.90726332415267"
        //                     },
        //                     {
        //                     "price": "2010.704988",
        //                     "quantity": "0.00127892",
        //                     "amount": "2.57153082325296"
        //                     }
        //                 ],
        //                 "bids": [
        //                     {
        //                     "price": "1976.404988",
        //                     "quantity": "0.09875861",
        //                     "amount": "195.18700941194668"
        //                     },
        //                     {
        //                     "price": "1905.472973",
        //                     "quantity": "0.00263591",
        //                     "amount": "5.02265526426043"
        //                     },
        //                     {
        //                     "price": "1904.274973",
        //                     "quantity": "0.09425304",
        //                     "amount": "179.48370520116792"
        //                     }
        //                 ],
        //                 "updateId": "78",
        //                 "timeStart": "2021-01-28T09:19:30.706Z",
        //                 "makerFee": 200,
        //                 "takerFee": 200,
        //                 "quoteVolume24": 49125.1374009045,
        //                 "lowPrice24": 1966.704999,
        //                 "highPrice24": 2080.354997,
        //                 "baseCurrency": {
        //                     "id": 2,
        //                     "status": 1,
        //                     "symbol": "eth",
        //                     "title": "Ethereum",
        //                     "logoURL": "https://ethereum.org/static/6b935ac0e6194247347855dc3d328e83/34ca5/eth-diamond-black.png",
        //                     "isDiscount": false,
        //                     "address": "https://ethereum.org/",
        //                     "description": "Ethereum ETH",
        //                     "decimals": 18,
        //                     "blockChain": "Ethereum",
        //                     "precision": 8,
        //                     "currentRate": null,
        //                     "active": true,
        //                     "timeStart": "2021-01-28T08:57:41.719Z",
        //                     "txLimits": {
        //                         "minDeposit": "100000000000000",
        //                         "maxWithdraw": "10000000000000000000000",
        //                         "minWithdraw": "20000000000000000",
        //                         "withdrawCommissionFixed": "5000000000000000",
        //                         "withdrawCommissionPercentage": "NaN"
        //                     },
        //                     "type": "crypto",
        //                     "typeNetwork": "internalGW",
        //                     "icon": "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzAiIGhlaWdodD0iMzAiIHZpZXdCb3g9IjAgMCAzMCAzMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggZD0iTTAgMTVDMCA2LjcxNTczIDYuNzE1NzMgMCAxNSAwVjBDMjMuMjg0MyAwIDMwIDYuNzE1NzMgMzAgMTVWMTVDMzAgMjMuMjg0MyAyMy4yODQzIDMwIDE1IDMwVjMwQzYuNzE1NzMgMzAgMCAyMy4yODQzIDAgMTVWMTVaIiBmaWxsPSJibGFjayIvPgo8cGF0aCBkPSJNMTQuOTU1NyAxOS45NzM5TDkgMTYuMzUwOUwxNC45NTIxIDI1TDIwLjkxMDkgMTYuMzUwOUwxNC45NTIxIDE5Ljk3MzlIMTQuOTU1N1pNMTUuMDQ0MyA1TDkuMDkwOTUgMTUuMTg1M0wxNS4wNDQzIDE4LjgxNDZMMjEgMTUuMTg5MUwxNS4wNDQzIDVaIiBmaWxsPSJ3aGl0ZSIvPgo8L3N2Zz4K",
        //                     "idSorting": 2,
        //                     "links": [
        //                         {
        //                             "tx": "https://etherscan.io/tx/",
        //                             "address": "https://etherscan.io/address/",
        //                             "blockChain": "Ethereum"
        //                         }
        //                     ],
        //                     "clientTxLimits": {
        //                         "minDeposit": "0.0001",
        //                         "minWithdraw": "0.02",
        //                         "maxWithdraw": "10000",
        //                         "withdrawCommissionPercentage": "NaN",
        //                         "withdrawCommissionFixed": "0.005"
        //                     }
        //                 },
        //                 "quoteCurrency": {
        //                     "id": 3,
        //                     "status": 1,
        //                     "symbol": "usdt",
        //                     "title": "Tether USD",
        //                     "logoURL": "https://cryptologos.cc/logos/tether-usdt-logo.png?v=010",
        //                     "isDiscount": false,
        //                     "address": "https://tether.to/",
        //                     "description": "Tether USD",
        //                     "decimals": 6,
        //                     "blockChain": "",
        //                     "precision": 6,
        //                     "currentRate": null,
        //                     "active": true,
        //                     "timeStart": "2021-01-28T09:04:17.170Z",
        //                     "txLimits": {
        //                         "minDeposit": "1000",
        //                         "maxWithdraw": "100000000000",
        //                         "minWithdraw": "1000000",
        //                         "withdrawCommissionFixed": {
        //                             "Tron": "2000000",
        //                             "Binance": "2000000000000000000",
        //                             "Ethereum": "20000000"
        //                         },
        //                         "withdrawCommissionPercentage": "NaN"
        //                     },
        //                     "type": "crypto",
        //                     "typeNetwork": "internalGW",
        //                     "icon": "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzAiIGhlaWdodD0iMzAiIHZpZXdCb3g9IjAgMCAzMCAzMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggZD0iTTAgMTVDMCA2LjcxNTczIDYuNzE1NzMgMCAxNSAwVjBDMjMuMjg0MyAwIDMwIDYuNzE1NzMgMzAgMTVWMTVDMzAgMjMuMjg0MyAyMy4yODQzIDMwIDE1IDMwVjMwQzYuNzE1NzMgMzAgMCAyMy4yODQzIDAgMTVWMTVaIiBmaWxsPSIjNkZBNjg4Ii8+CjxwYXRoIGZpbGwtcnVsZT0iZXZlbm9kZCIgY2xpcC1ydWxlPSJldmVub2RkIiBkPSJNMjMgN0g3VjExSDEzVjEyLjA2MkM4Ljk5MjAyIDEyLjMxNDYgNiAxMy4zMTAyIDYgMTQuNUM2IDE1LjY4OTggOC45OTIwMiAxNi42ODU0IDEzIDE2LjkzOFYyM0gxN1YxNi45MzhDMjEuMDA4IDE2LjY4NTQgMjQgMTUuNjg5OCAyNCAxNC41QzI0IDEzLjMxMDIgMjEuMDA4IDEyLjMxNDYgMTcgMTIuMDYyVjExSDIzVjdaTTcuNSAxNC41QzcuNSAxMy40NjA2IDkuMzMzMzMgMTIuMzY4IDEzIDEyLjA3NTZWMTUuNUgxN1YxMi4wNzU5QzIwLjkzODQgMTIuMzkyNyAyMi41IDEzLjYzMzkgMjIuNSAxNC41QzIyLjUgMTUuMzIyIDIwLjAwMDggMTUuODA2MSAxNyAxNS45NTI1QzE1LjcwODIgMTYuMDQ2MiAxMy43OTUxIDE1Ljk4MjYgMTMgMTUuOTM5MUM5Ljk5OTIxIDE1Ljc1NTkgNy41IDE1LjE4MDkgNy41IDE0LjVaIiBmaWxsPSJ3aGl0ZSIvPgo8L3N2Zz4K",
        //                     "idSorting": 0,
        //                     "links": [
        //                         {
        //                             "tx": "https://etherscan.io/tx/",
        //                             "address": "https://etherscan.io/address/",
        //                             "blockChain": "Ethereum"
        //                         },
        //                         {
        //                             "tx": "https://tronscan.org/#/transaction/",
        //                             "address": "https://tronscan.org/#/address/",
        //                             "blockChain": "Tron"
        //                         },
        //                         {
        //                             "tx": "https://bscscan.com/tx/",
        //                             "address": "https://bscscan.com/address/",
        //                             "blockChain": "Binance"
        //                         }
        //                     ],
        //                     "clientTxLimits": {
        //                         "minDeposit": "0.001",
        //                         "minWithdraw": "1",
        //                         "maxWithdraw": "100000",
        //                         "withdrawCommissionPercentage": "NaN",
        //                         "withdrawCommissionFixed": {
        //                             "Tron": "2",
        //                             "Binance": "2",
        //                             "Ethereum": "20"
        //                         }
        //                     }
        //                 },
        //                 "quantities": {
        //                     "asks": "5.58760757",
        //                     "bids": "2226.98663823032198"
        //                 }
        //             }
        //         }
        //     }
        //
        object result = this.safeValue(response, "result", new Dictionary<string, object>() {});
        object pair = this.safeDict(result, "pair", new Dictionary<string, object>() {});
        return this.parseTicker(pair, market);
    }

    public override object parseTicker(object ticker, object market = null)
    {
        //
        // fetchTicker
        //     {
        //         "id": 2,
        //         "name": "eth_usdt",
        //         "baseAssetId": 2,
        //         "quoteAssetId": 3,
        //         "fullName": "ETH USDT",
        //         "description": "ETH   USDT",
        //         "lastBuy": "1976.715012",
        //         "lastSell": "1971.995006",
        //         "lastPrice": "1976.715012",
        //         "change24": "1.02",
        //         "volume24": 24.0796457,
        //         "volume24USD": 44282.347995912205,
        //         "active": true,
        //         "baseStep": 8,
        //         "quoteStep": 6,
        //         "status": 1,
        //         "asks": [
        //             {
        //             "price": "1976.405003",
        //             "quantity": "0.0051171",
        //             "amount": "10.1134620408513"
        //             },
        //             {
        //             "price": "1976.405013",
        //             "quantity": "0.09001559",
        //             "amount": "177.90726332415267"
        //             },
        //             {
        //             "price": "2010.704988",
        //             "quantity": "0.00127892",
        //             "amount": "2.57153082325296"
        //             }
        //                ...
        //         ],
        //         "bids": [
        //             {
        //             "price": "1976.404988",
        //             "quantity": "0.09875861",
        //             "amount": "195.18700941194668"
        //             },
        //             {
        //             "price": "1905.472973",
        //             "quantity": "0.00263591",
        //             "amount": "5.02265526426043"
        //             },
        //             {
        //             "price": "1904.274973",
        //             "quantity": "0.09425304",
        //             "amount": "179.48370520116792"
        //             }
        //                ...
        //         ],
        //         "updateId": "78",
        //         "timeStart": "2021-01-28T09:19:30.706Z",
        //         "makerFee": 200,
        //         "takerFee": 200,
        //         "quoteVolume24": 49125.1374009045,
        //         "lowPrice24": 1966.704999,
        //         "highPrice24": 2080.354997,
        //         ...
        //     }
        //
        // fetchTickers
        //     {
        //         "trading_pairs": "BTC_USDT",
        //         "base_currency": "BTC",
        //         "quote_currency": "USDT",
        //         "last_price": 37669.955001,
        //         "lowest_ask": 37670.055,
        //         "highest_bid": 37669.955,
        //         "base_volume": 6.81156888,
        //         "quote_volume": 257400.516878529,
        //         "price_change_percent_24h": -0.29,
        //         "highest_price_24h": 38389.994463,
        //         "lowest_price_24h": 37574.894999
        //     }
        object marketId = this.safeStringLower(ticker, "trading_pairs");
        market = this.safeMarket(marketId, market);
        object bestBidPrice = null;
        object bestAskPrice = null;
        object bestBidVolume = null;
        object bestAskVolume = null;
        object bids = this.safeValue(ticker, "bids");
        object asks = this.safeValue(ticker, "asks");
        if (isTrue(isTrue(isTrue(isTrue((!isEqual(bids, null))) && isTrue((((bids is IList<object>) || (bids.GetType().IsGenericType && bids.GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>))))))) && isTrue((!isEqual(asks, null)))) && isTrue((((asks is IList<object>) || (asks.GetType().IsGenericType && asks.GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>))))))))
        {
            object bestBid = this.safeValue(bids, 0, new Dictionary<string, object>() {});
            bestBidPrice = this.safeString(bestBid, "price");
            bestBidVolume = this.safeString(bestBid, "quantity");
            object bestAsk = this.safeValue(asks, 0, new Dictionary<string, object>() {});
            bestAskPrice = this.safeString(bestAsk, "price");
            bestAskVolume = this.safeString(bestAsk, "quantity");
        } else
        {
            bestBidPrice = this.safeString(ticker, "highest_bid");
            bestAskPrice = this.safeString(ticker, "lowest_ask");
        }
        object baseVolume = this.safeString2(ticker, "volume24", "base_volume");
        object quoteVolume = this.safeString2(ticker, "quoteVolume24", "quote_volume");
        object high = this.safeString2(ticker, "highPrice24", "highest_price_24h");
        object low = this.safeString2(ticker, "lowPrice24", "lowest_price_24h");
        object close = this.safeString2(ticker, "lastPrice", "last_price");
        object changePcnt = this.safeString2(ticker, "change24", "price_change_percent_24h");
        return this.safeTicker(new Dictionary<string, object>() {
            { "symbol", getValue(market, "symbol") },
            { "timestamp", null },
            { "datetime", null },
            { "open", null },
            { "high", high },
            { "low", low },
            { "close", close },
            { "bid", bestBidPrice },
            { "bidVolume", bestBidVolume },
            { "ask", bestAskPrice },
            { "askVolume", bestAskVolume },
            { "vwap", null },
            { "previousClose", null },
            { "change", null },
            { "percentage", changePcnt },
            { "average", null },
            { "baseVolume", baseVolume },
            { "quoteVolume", quoteVolume },
            { "info", ticker },
        }, market);
    }

    public async override Task<object> fetchTrades(object symbol, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bitteam#fetchTrades
        * @description get the list of most recent trades for a particular symbol
        * @see https://bit.team/trade/api/documentation#/CMC/getTradeApiCmcTradesPair
        * @param {string} symbol unified symbol of the market to fetch trades for
        * @param {int} [since] timestamp in ms of the earliest trade to fetch
        * @param {int} [limit] the maximum amount of trades to fetch
        * @param {object} [params] extra parameters specific to the bitteam api endpoint
        * @returns {Trade[]} a list of [trade structures]{@link https://github.com/ccxt/ccxt/wiki/Manual#public-trades}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "pair", getValue(market, "id") },
        };
        object response = await this.publicGetTradeApiCmcTradesPair(this.extend(request, parameters));
        //
        //     [
        //         {
        //             "trade_id": 34970337,
        //             "price": 37769.994793,
        //             "base_volume": 0.00119062,
        //             "quote_volume": 44.96971120044166,
        //             "timestamp": 1700827234000,
        //             "type": "buy"
        //         },
        //         {
        //             "trade_id": 34970347,
        //             "price": 37769.634497,
        //             "base_volume": 0.00104009,
        //             "quote_volume": 39.28381914398473,
        //             "timestamp": 1700827248000,
        //             "type": "buy"
        //         },
        //         ...
        //     ]
        //
        return this.parseTrades(response, market, since, limit);
    }

    public async override Task<object> fetchMyTrades(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bitteam#fetchMyTrades
        * @description fetch all trades made by the user
        * @see https://bit.team/trade/api/documentation#/PRIVATE/getTradeApiCcxtTradesofuser
        * @param {string} symbol unified market symbol
        * @param {int} [since] the earliest time in ms to fetch trades for
        * @param {int} [limit] the maximum number of trades structures to retrieve (default 10)
        * @param {object} [params] extra parameters specific to the bitteam api endpoint
        * @returns {Trade[]} a list of [trade structures]{@link https://github.com/ccxt/ccxt/wiki/Manual#trade-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            ((IDictionary<string,object>)request)["pairId"] = getValue(market, "numericId");
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        object response = await this.privateGetTradeApiCcxtTradesOfUser(this.extend(request, parameters));
        //
        //     {
        //         "ok": true,
        //         "result": {
        //             "count": 3,
        //             "trades": [
        //                 {
        //                     "id": 34880724,
        //                     "tradeId": "4368041",
        //                     "makerOrderId": 106742914,
        //                     "takerOrderId": 106761614,
        //                     "pairId": 2,
        //                     "quantity": "0.00955449",
        //                     "price": "1993.674994",
        //                     "isBuyerMaker": true,
        //                     "baseDecimals": 18,
        //                     "quoteDecimals": 6,
        //                     "side": "sell",
        //                     "timestamp": 1700615250,
        //                     "rewarded": true,
        //                     "makerUserId": 21639,
        //                     "takerUserId": 15913,
        //                     "baseCurrencyId": 2,
        //                     "quoteCurrencyId": 3,
        //                     "feeMaker": {
        //                         "amount": "0.0000191",
        //                         "symbol": "eth",
        //                         "userId": 21639,
        //                         "decimals": 18,
        //                         "symbolId": 2
        //                     },
        //                     "feeTaker": {
        //                         "amount": "0",
        //                         "symbol": "usdt",
        //                         "userId": 15913,
        //                         "decimals": 6,
        //                         "symbolId": 3,
        //                         "discountAmount": "0",
        //                         "discountSymbol": "btt",
        //                         "discountDecimals": 18,
        //                         "discountSymbolId": 5
        //                     },
        //                     "pair": "eth_usdt",
        //                     "createdAt": "2023-11-22T01:07:30.593Z",
        //                     "updatedAt": "2023-11-22T01:10:00.117Z",
        //                     "isCurrentSide": "maker"
        //                 },
        //                 {
        //                     "id": 34875793,
        //                     "tradeId": "4368010",
        //                     "makerOrderId": 106742914,
        //                     "takerOrderId": 106745926,
        //                     "pairId": 2,
        //                     "quantity": "0.0027193",
        //                     "price": "1993.674994",
        //                     "isBuyerMaker": true,
        //                     "baseDecimals": 18,
        //                     "quoteDecimals": 6,
        //                     "side": "sell",
        //                     "timestamp": 1700602983,
        //                     "rewarded": true,
        //                     "makerUserId": 21639,
        //                     "takerUserId": 15912,
        //                     "baseCurrencyId": 2,
        //                     "quoteCurrencyId": 3,
        //                     "feeMaker": {
        //                         "amount": "0.00000543",
        //                         "symbol": "eth",
        //                         "userId": 21639,
        //                         "decimals": 18,
        //                         "symbolId": 2
        //                     },
        //                     "feeTaker": {
        //                         "amount": "0",
        //                         "symbol": "usdt",
        //                         "userId": 15912,
        //                         "decimals": 6,
        //                         "symbolId": 3,
        //                         "discountAmount": "0",
        //                         "discountSymbol": "btt",
        //                         "discountDecimals": 18,
        //                         "discountSymbolId": 5
        //                     },
        //                     "pair": "eth_usdt",
        //                     "createdAt": "2023-11-21T21:43:02.758Z",
        //                     "updatedAt": "2023-11-21T21:45:00.147Z",
        //                     "isCurrentSide": "maker"
        //                 },
        //                 {
        //                     "id": 34871727,
        //                     "tradeId": "3441840",
        //                     "makerOrderId": 106733299,
        //                     "takerOrderId": 106733308,
        //                     "pairId": 22,
        //                     "quantity": "0.00001",
        //                     "price": "37017.495008",
        //                     "isBuyerMaker": false,
        //                     "baseDecimals": 8,
        //                     "quoteDecimals": 6,
        //                     "side": "buy",
        //                     "timestamp": 1700594960,
        //                     "rewarded": true,
        //                     "makerUserId": 15909,
        //                     "takerUserId": 21639,
        //                     "baseCurrencyId": 11,
        //                     "quoteCurrencyId": 3,
        //                     "feeMaker": {
        //                         "amount": "0",
        //                         "symbol": "usdt",
        //                         "userId": 15909,
        //                         "decimals": 6,
        //                         "symbolId": 3,
        //                         "discountAmount": "0",
        //                         "discountSymbol": "btt",
        //                         "discountDecimals": 18,
        //                         "discountSymbolId": 5
        //                     },
        //                     "feeTaker": {
        //                         "amount": "0.00000002",
        //                         "symbol": "btc",
        //                         "userId": 21639,
        //                         "decimals": 8,
        //                         "symbolId": 11
        //                     },
        //                     "pair": "btc_usdt",
        //                     "createdAt": "2023-11-21T19:29:20.092Z",
        //                     "updatedAt": "2023-11-21T19:30:00.159Z"
        //                     "isCurrentSide": "taker"
        //                 }
        //             ]
        //         }
        //     }
        //
        object result = this.safeValue(response, "result", new Dictionary<string, object>() {});
        object trades = this.safeList(result, "trades", new List<object>() {});
        return this.parseTrades(trades, market, since, limit);
    }

    public override object parseTrade(object trade, object market = null)
    {
        //
        // fetchTrades
        //     {
        //         "trade_id": 34970337,
        //         "price": 37769.994793,
        //         "base_volume": 0.00119062,
        //         "quote_volume": 44.96971120044166,
        //         "timestamp": 1700827234000,
        //         "type": "buy"
        //     },
        //
        // fetchMyTrades
        //     {
        //         "id": 34875793,
        //         "tradeId": "4368010",
        //         "makerOrderId": 106742914,
        //         "takerOrderId": 106745926,
        //         "pairId": 2,
        //         "quantity": "0.0027193",
        //         "price": "1993.674994",
        //         "isBuyerMaker": true,
        //         "baseDecimals": 18,
        //         "quoteDecimals": 6,
        //         "side": "sell",
        //         "timestamp": 1700602983,
        //         "rewarded": true,
        //         "makerUserId": 21639,
        //         "takerUserId": 15912,
        //         "baseCurrencyId": 2,
        //         "quoteCurrencyId": 3,
        //         "feeMaker": {
        //             "amount": "0.00000543",
        //             "symbol": "eth",
        //             "userId": 21639,
        //             "decimals": 18,
        //             "symbolId": 2
        //         },
        //         "feeTaker": {
        //             "amount": "0",
        //             "symbol": "usdt",
        //             "userId": 15912,
        //             "decimals": 6,
        //             "symbolId": 3,
        //             "discountAmount": "0",
        //             "discountSymbol": "btt",
        //             "discountDecimals": 18,
        //             "discountSymbolId": 5
        //         },
        //         "pair": "eth_usdt",
        //         "createdAt": "2023-11-21T21:43:02.758Z",
        //         "updatedAt": "2023-11-21T21:45:00.147Z",
        //         "isCurrentSide": "maker"
        //     }
        //
        object marketId = this.safeString(trade, "pair");
        market = this.safeMarket(marketId, market);
        object symbol = getValue(market, "symbol");
        object id = this.safeString2(trade, "id", "trade_id");
        object price = this.safeString(trade, "price");
        object amount = this.safeString2(trade, "quantity", "base_volume");
        object cost = this.safeString(trade, "quote_volume");
        object takerOrMaker = this.safeString(trade, "isCurrentSide");
        object timestamp = this.safeString(trade, "timestamp");
        if (isTrue(!isEqual(takerOrMaker, null)))
        {
            timestamp = Precise.stringMul(timestamp, "1000");
        }
        // the exchange returns the side of the taker
        object side = this.safeString2(trade, "side", "type");
        object feeInfo = null;
        object order = null;
        if (isTrue(isEqual(takerOrMaker, "maker")))
        {
            if (isTrue(isEqual(side, "sell")))
            {
                side = "buy";
            } else if (isTrue(isEqual(side, "buy")))
            {
                side = "sell";
            }
            order = this.safeString(trade, "makerOrderId");
            feeInfo = this.safeValue(trade, "feeMaker", new Dictionary<string, object>() {});
        } else if (isTrue(isEqual(takerOrMaker, "taker")))
        {
            order = this.safeString(trade, "takerOrderId");
            feeInfo = this.safeValue(trade, "feeTaker", new Dictionary<string, object>() {});
        }
        object feeCurrencyId = this.safeString(feeInfo, "symbol");
        object feeCost = this.safeString(feeInfo, "amount");
        object fee = new Dictionary<string, object>() {
            { "currency", this.safeCurrencyCode(feeCurrencyId) },
            { "cost", feeCost },
            { "rate", null },
        };
        object intTs = this.parseToInt(timestamp);
        return this.safeTrade(new Dictionary<string, object>() {
            { "id", id },
            { "order", order },
            { "timestamp", intTs },
            { "datetime", this.iso8601(intTs) },
            { "symbol", symbol },
            { "type", null },
            { "side", side },
            { "takerOrMaker", takerOrMaker },
            { "price", price },
            { "amount", amount },
            { "cost", cost },
            { "fee", fee },
            { "info", trade },
        }, market);
    }

    public async override Task<object> fetchBalance(object parameters = null)
    {
        /**
        * @method
        * @name betteam#fetchBalance
        * @description query for balance and get the amount of funds available for trading or funds locked in orders
        * @see https://bit.team/trade/api/documentation#/PRIVATE/getTradeApiCcxtBalance
        * @param {object} [params] extra parameters specific to the betteam api endpoint
        * @returns {object} a [balance structure]{@link https://github.com/ccxt/ccxt/wiki/Manual#balance-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.privateGetTradeApiCcxtBalance(parameters);
        return this.parseBalance(response);
    }

    public override object parseBalance(object response)
    {
        //
        //     {
        //         "ok": true,
        //         "result": {
        //             "free": {
        //                 "USDT": "0",
        //                 "DEL": "0",
        //                 "BTC": "0",
        //                 ...
        //             },
        //                 "used": {
        //                 "USDT": "0",
        //                 "DEL": "0",
        //                 "BTC": "0",
        //                 ...
        //             },
        //             "total": {
        //                 "USDT": "0",
        //                 "DEL": "0",
        //                 "BTC": "0",
        //                 ...
        //             },
        //             "USDT": {
        //                 "free": "0",
        //                 "used": "0",
        //                 "total": "0",
        //             },
        //             "DEL": {
        //                 "free": "0",
        //                 "used": "0",
        //                 "total": "0",
        //             },
        //             "BTC": {
        //                 "free": "0",
        //                 "used": "0",
        //                 "total": "0",
        //             }
        //             ...
        //         }
        //     }
        //
        object timestamp = this.milliseconds();
        object balance = new Dictionary<string, object>() {
            { "info", response },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
        };
        object result = this.safeValue(response, "result", new Dictionary<string, object>() {});
        object balanceByCurrencies = this.omit(result, new List<object>() {"free", "used", "total"});
        object rawCurrencyIds = new List<object>(((IDictionary<string,object>)balanceByCurrencies).Keys);
        for (object i = 0; isLessThan(i, getArrayLength(rawCurrencyIds)); postFixIncrement(ref i))
        {
            object rawCurrencyId = getValue(rawCurrencyIds, i);
            object currencyBalance = this.safeValue(result, rawCurrencyId);
            object free = this.safeString(currencyBalance, "free");
            object used = this.safeString(currencyBalance, "used");
            object total = this.safeString(currencyBalance, "total");
            object currencyCode = this.safeCurrencyCode(((string)rawCurrencyId).ToLower());
            ((IDictionary<string,object>)balance)[(string)currencyCode] = new Dictionary<string, object>() {
                { "free", free },
                { "used", used },
                { "total", total },
            };
        }
        return this.safeBalance(balance);
    }

    public async override Task<object> fetchDepositsWithdrawals(object code = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bitteam#fetchDepositsWithdrawals
        * @description fetch history of deposits and withdrawals from external wallets and between CoinList Pro trading account and CoinList wallet
        * @see https://bit.team/trade/api/documentation#/PRIVATE/getTradeApiTransactionsofuser
        * @param {string} [code] unified currency code for the currency of the deposit/withdrawals
        * @param {int} [since] timestamp in ms of the earliest deposit/withdrawal
        * @param {int} [limit] max number of deposit/withdrawals to return (default 10)
        * @param {object} [params] extra parameters specific to the bitteam api endpoint
        * @returns {object} a list of [transaction structure]{@link https://github.com/ccxt/ccxt/wiki/Manual#transaction-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = null;
        object request = new Dictionary<string, object>() {};
        if (isTrue(!isEqual(code, null)))
        {
            currency = this.currency(code);
            ((IDictionary<string,object>)request)["currency"] = getValue(currency, "numericId");
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        object response = await this.privateGetTradeApiTransactionsOfUser(this.extend(request, parameters));
        //
        //     {
        //         "ok": true,
        //         "result": {
        //             "count": 2,
        //             "transactions": [
        //                 {
        //                     "id": 1329686,
        //                     "orderId": "2f060ad5-30f7-4f2b-ac5f-1bb8f5fd34dc",
        //                     "transactionCoreId": "561863",
        //                     "userId": 21639,
        //                     "recipient": "0x9050dfA063D1bE7cA711c750b18D51fDD13e90Ee",
        //                     "sender": "0x6894a93B6fea044584649278621723cac51443Cd",
        //                     "symbolId": 2,
        //                     "CommissionId": 17571,
        //                     "amount": "44000000000000000",
        //                     "params": {},
        //                     "reason": null,
        //                     "timestamp": 1700715341743,
        //                     "status": "approving",
        //                     "statusDescription": null,
        //                     "type": "withdraw",
        //                     "message": null,
        //                     "blockChain": "",
        //                     "before": null,
        //                     "after": null,
        //                     "currency": {
        //                         "symbol": "eth",
        //                         "decimals": 18,
        //                         "blockChain": "Ethereum",
        //                         "links": [
        //                             {
        //                                 "tx": "https://etherscan.io/tx/",
        //                                 "address": "https://etherscan.io/address/",
        //                                 "blockChain": "Ethereum"
        //                             }
        //                         ]
        //                     }
        //                 },
        //                 {
        //                     "id": 1329229,
        //                     "orderId": null,
        //                     "transactionCoreId": "561418",
        //                     "userId": 21639,
        //                     "recipient": "0x7d6a797f2406e06b2f9b41d067df324affa315dd",
        //                     "sender": null,
        //                     "symbolId": 3,
        //                     "CommissionId": null,
        //                     "amount": "100000000",
        //                     "params": {
        //                         "tx_id": "0x2253823c828d838acd983fe6a348fb0e034efe3874b081871d8b80da76ec758b"
        //                     },
        //                     "reason": null,
        //                     "timestamp": 1700594180417,
        //                     "status": "success",
        //                     "statusDescription": null,
        //                     "type": "deposit",
        //                     "message": null,
        //                     "blockChain": "Ethereum",
        //                     "before": 0,
        //                     "after": 100000000,
        //                     "currency": {
        //                         "symbol": "usdt",
        //                         "decimals": 6,
        //                         "blockChain": "",
        //                         "links": [
        //                             {
        //                                 "tx": "https://etherscan.io/tx/",
        //                                 "address": "https://etherscan.io/address/",
        //                                 "blockChain": "Ethereum"
        //                             },
        //                             {
        //                                 "tx": "https://tronscan.org/#/transaction/",
        //                                 "address": "https://tronscan.org/#/address/",
        //                                 "blockChain": "Tron"
        //                             },
        //                             {
        //                                 "tx": "https://bscscan.com/tx/",
        //                                 "address": "https://bscscan.com/address/",
        //                                 "blockChain": "Binance"
        //                             }
        //                         ]
        //                     }
        //                 }
        //             ]
        //         }
        //     }
        //
        object result = this.safeValue(response, "result", new Dictionary<string, object>() {});
        object transactions = this.safeList(result, "transactions", new List<object>() {});
        return this.parseTransactions(transactions, currency, since, limit);
    }

    public override object parseTransaction(object transaction, object currency = null)
    {
        //
        //     {
        //         "id": 1329229,
        //         "orderId": null,
        //         "transactionCoreId": "561418",
        //         "userId": 21639,
        //         "recipient": "0x7d6a797f2406e06b2f9b41d067df324affa315dd",
        //         "sender": null,
        //         "symbolId": 3,
        //         "CommissionId": null,
        //         "amount": "100000000",
        //         "params": {
        //             "tx_id": "0x2253823c828d838acd983fe6a348fb0e034efe3874b081871d8b80da76ec758b"
        //         },
        //         "reason": null,
        //         "timestamp": 1700594180417,
        //         "status": "success",
        //         "statusDescription": null,
        //         "type": "deposit",
        //         "message": null,
        //         "blockChain": "Ethereum",
        //         "before": 0,
        //         "after": 100000000,
        //         "currency": {
        //             "symbol": "usdt",
        //             "decimals": 6,
        //             "blockChain": "",
        //             "links": [
        //                 {
        //                     "tx": "https://etherscan.io/tx/",
        //                     "address": "https://etherscan.io/address/",
        //                     "blockChain": "Ethereum"
        //                 },
        //                 {
        //                     "tx": "https://tronscan.org/#/transaction/",
        //                     "address": "https://tronscan.org/#/address/",
        //                     "blockChain": "Tron"
        //                 },
        //                 {
        //                     "tx": "https://bscscan.com/tx/",
        //                     "address": "https://bscscan.com/address/",
        //                     "blockChain": "Binance"
        //                 }
        //             ]
        //         }
        //     }
        //
        object currencyObject = this.safeValue(transaction, "currency");
        object currencyId = this.safeString(currencyObject, "symbol");
        object code = this.safeCurrencyCode(currencyId, currency);
        object id = this.safeString(transaction, "id");
        object parameters = this.safeValue(transaction, "params");
        object txid = this.safeString(parameters, "tx_id");
        object timestamp = this.safeInteger(transaction, "timestamp");
        object networkId = this.safeString(transaction, "blockChain");
        if (isTrue(isEqual(networkId, null)))
        {
            object links = this.safeValue(currencyObject, "links", new List<object>() {});
            object blockChain = this.safeValue(links, 0, new Dictionary<string, object>() {});
            networkId = this.safeString(blockChain, "blockChain");
        }
        object addressFrom = this.safeString(transaction, "sender");
        object addressTo = this.safeString(transaction, "recipient");
        object tag = this.safeString(transaction, "message");
        object type = this.parseTransactionType(this.safeString(transaction, "type"));
        object amount = this.parseValueToPricision(transaction, "amount", currencyObject, "decimals");
        object status = this.parseTransactionStatus(this.safeValue(transaction, "status"));
        return new Dictionary<string, object>() {
            { "info", transaction },
            { "id", id },
            { "txid", txid },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "network", this.networkIdToCode(networkId) },
            { "addressFrom", addressFrom },
            { "address", null },
            { "addressTo", addressTo },
            { "tagFrom", null },
            { "tag", tag },
            { "tagTo", null },
            { "type", type },
            { "amount", this.parseNumber(amount) },
            { "currency", code },
            { "status", status },
            { "updated", null },
            { "fee", null },
            { "comment", this.safeString(transaction, "description") },
            { "internal", false },
        };
    }

    public virtual object parseTransactionType(object type)
    {
        object types = new Dictionary<string, object>() {
            { "deposit", "deposit" },
            { "withdraw", "withdrawal" },
        };
        return this.safeString(types, type, type);
    }

    public virtual object parseTransactionStatus(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "approving", "pending" },
            { "success", "ok" },
        };
        return this.safeString(statuses, status, status);
    }

    public override object sign(object path, object api = null, object method = null, object parameters = null, object headers = null, object body = null)
    {
        api ??= "public";
        method ??= "GET";
        parameters ??= new Dictionary<string, object>();
        object request = this.omit(parameters, this.extractParams(path));
        object endpoint = add("/", this.implodeParams(path, parameters));
        object url = add(getValue(getValue(this.urls, "api"), api), endpoint);
        object query = this.urlencode(request);
        if (isTrue(isEqual(api, "private")))
        {
            this.checkRequiredCredentials();
            if (isTrue(isEqual(method, "POST")))
            {
                body = this.json(request);
            } else if (isTrue(!isEqual(getArrayLength(query), 0)))
            {
                url = add(url, add("?", query));
            }
            object auth = add(add(this.apiKey, ":"), this.secret);
            object auth64 = this.stringToBase64(auth);
            object signature = add("Basic ", auth64);
            headers = new Dictionary<string, object>() {
                { "Authorization", signature },
                { "Content-Type", "application/json" },
            };
        } else if (isTrue(!isEqual(getArrayLength(query), 0)))
        {
            url = add(url, add("?", query));
        }
        return new Dictionary<string, object>() {
            { "url", url },
            { "method", method },
            { "body", body },
            { "headers", headers },
        };
    }

    public override object handleErrors(object code, object reason, object url, object method, object headers, object body, object response, object requestHeaders, object requestBody)
    {
        if (isTrue(isEqual(response, null)))
        {
            return null;
        }
        if (isTrue(!isEqual(code, 200)))
        {
            if (isTrue(isEqual(code, 404)))
            {
                if (isTrue(isTrue((isGreaterThanOrEqual(getIndexOf(url, "/ccxt/order/"), 0))) && isTrue((isEqual(method, "GET")))))
                {
                    object parts = ((string)url).Split(new [] {((string)"/order/")}, StringSplitOptions.None).ToList<object>();
                    object orderId = this.safeString(parts, 1);
                    throw new OrderNotFound ((string)add(add(add(this.id, " order "), orderId), " not found")) ;
                }
                if (isTrue(isGreaterThanOrEqual(getIndexOf(url, "/cmc/orderbook/"), 0)))
                {
                    object parts = ((string)url).Split(new [] {((string)"/cmc/orderbook/")}, StringSplitOptions.None).ToList<object>();
                    object symbolId = this.safeString(parts, 1);
                    throw new BadSymbol ((string)add(add(add(this.id, " symbolId "), symbolId), " not found")) ;
                }
            }
            object feedback = add(add(this.id, " "), body);
            object message = this.safeString(response, "message");
            object responseCode = this.safeString(response, "code");
            this.throwBroadlyMatchedException(getValue(this.exceptions, "broad"), message, feedback);
            this.throwExactlyMatchedException(getValue(this.exceptions, "exact"), responseCode, feedback);
            throw new ExchangeError ((string)feedback) ;
        }
        return null;
    }
}
