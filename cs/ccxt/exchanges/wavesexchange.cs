namespace ccxt;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

public partial class wavesexchange : Exchange
{
    public override object describe()
    {
        return this.deepExtend(base.describe(), new Dictionary<string, object>() {
            { "id", "wavesexchange" },
            { "name", "Waves.Exchange" },
            { "countries", new List<object>() {"CH"} },
            { "certified", false },
            { "pro", false },
            { "has", new Dictionary<string, object>() {
                { "CORS", null },
                { "spot", true },
                { "margin", false },
                { "swap", false },
                { "future", false },
                { "option", false },
                { "addMargin", false },
                { "cancelOrder", true },
                { "closeAllPositions", false },
                { "closePosition", false },
                { "createMarketOrder", true },
                { "createOrder", true },
                { "createReduceOnlyOrder", false },
                { "createStopLimitOrder", false },
                { "createStopMarketOrder", false },
                { "createStopOrder", false },
                { "fetchBalance", true },
                { "fetchBorrowRateHistories", false },
                { "fetchBorrowRateHistory", false },
                { "fetchClosedOrders", true },
                { "fetchCrossBorrowRate", false },
                { "fetchCrossBorrowRates", false },
                { "fetchDepositAddress", true },
                { "fetchDepositWithdrawFee", "emulated" },
                { "fetchDepositWithdrawFees", true },
                { "fetchFundingHistory", false },
                { "fetchFundingRate", false },
                { "fetchFundingRateHistory", false },
                { "fetchFundingRates", false },
                { "fetchIndexOHLCV", false },
                { "fetchIsolatedBorrowRate", false },
                { "fetchIsolatedBorrowRates", false },
                { "fetchLeverage", false },
                { "fetchLeverageTiers", false },
                { "fetchMarginMode", false },
                { "fetchMarkets", true },
                { "fetchMarkOHLCV", false },
                { "fetchMyTrades", true },
                { "fetchOHLCV", true },
                { "fetchOpenInterestHistory", false },
                { "fetchOpenOrders", true },
                { "fetchOrder", true },
                { "fetchOrderBook", true },
                { "fetchOrders", true },
                { "fetchPosition", false },
                { "fetchPositionHistory", false },
                { "fetchPositionMode", false },
                { "fetchPositions", false },
                { "fetchPositionsForSymbol", false },
                { "fetchPositionsHistory", false },
                { "fetchPositionsRisk", false },
                { "fetchPremiumIndexOHLCV", false },
                { "fetchTicker", true },
                { "fetchTickers", true },
                { "fetchTrades", true },
                { "fetchTransfer", false },
                { "fetchTransfers", false },
                { "reduceMargin", false },
                { "setLeverage", false },
                { "setMarginMode", false },
                { "setPositionMode", false },
                { "signIn", true },
                { "transfer", false },
                { "withdraw", true },
                { "ws", false },
            } },
            { "timeframes", new Dictionary<string, object>() {
                { "1m", "1m" },
                { "5m", "5m" },
                { "15m", "15m" },
                { "30m", "30m" },
                { "1h", "1h" },
                { "2h", "2h" },
                { "3h", "3h" },
                { "4h", "4h" },
                { "6h", "6h" },
                { "12h", "12h" },
                { "1d", "1d" },
                { "1w", "1w" },
                { "1M", "1M" },
            } },
            { "urls", new Dictionary<string, object>() {
                { "logo", "https://user-images.githubusercontent.com/1294454/84547058-5fb27d80-ad0b-11ea-8711-78ac8b3c7f31.jpg" },
                { "test", new Dictionary<string, object>() {
                    { "matcher", "https://matcher-testnet.wx.network" },
                    { "node", "https://nodes-testnet.wavesnodes.com" },
                    { "public", "https://api-testnet.wavesplatform.com/v0" },
                    { "private", "https://api-testnet.wx.network/v1" },
                    { "forward", "https://testnet.wx.network/api/v1/forward/matcher" },
                    { "market", "https://testnet.wx.network/api/v1/forward/marketdata/api/v1" },
                } },
                { "api", new Dictionary<string, object>() {
                    { "matcher", "https://matcher.wx.network" },
                    { "node", "https://nodes.wx.network" },
                    { "public", "https://api.wavesplatform.com/v0" },
                    { "private", "https://api.wx.network/v1" },
                    { "forward", "https://wx.network/api/v1/forward/matcher" },
                    { "market", "https://wx.network/api/v1/forward/marketdata/api/v1" },
                } },
                { "doc", "https://docs.wx.network" },
                { "www", "https://wx.network" },
            } },
            { "api", new Dictionary<string, object>() {
                { "matcher", new Dictionary<string, object>() {
                    { "get", new List<object>() {"matcher", "matcher/settings", "matcher/settings/rates", "matcher/balance/reserved/{publicKey}", "matcher/debug/allSnashotOffsets", "matcher/debug/currentOffset", "matcher/debug/lastOffset", "matcher/debug/oldestSnapshotOffset", "matcher/debug/config", "matcher/debug/address/{address}", "matcher/debug/status", "matcher/debug/address/{address}/check", "matcher/orderbook", "matcher/orderbook/{baseId}/{quoteId}", "matcher/orderbook/{baseId}/{quoteId}/publicKey/{publicKey}", "matcher/orderbook/{baseId}/{quoteId}/{orderId}", "matcher/orderbook/{baseId}/{quoteId}/info", "matcher/orderbook/{baseId}/{quoteId}/status", "matcher/orderbook/{baseId}/{quoteId}/tradableBalance/{address}", "matcher/orderbook/{publicKey}", "matcher/orderbook/{publicKey}/{orderId}", "matcher/orders/{address}", "matcher/orders/{address}/{orderId}", "matcher/transactions/{orderId}", "api/v1/orderbook/{baseId}/{quoteId}"} },
                    { "post", new List<object>() {"matcher/orderbook", "matcher/orderbook/market", "matcher/orderbook/cancel", "matcher/orderbook/{baseId}/{quoteId}/cancel", "matcher/orderbook/{baseId}/{quoteId}/calculateFee", "matcher/orderbook/{baseId}/{quoteId}/delete", "matcher/orderbook/{baseId}/{quoteId}/cancelAll", "matcher/debug/saveSnapshots", "matcher/orders/{address}/cancel", "matcher/orders/cancel/{orderId}", "matcher/orders/serialize"} },
                    { "delete", new List<object>() {"matcher/orderbook/{baseId}/{quoteId}", "matcher/settings/rates/{assetId}"} },
                    { "put", new List<object>() {"matcher/settings/rates/{assetId}"} },
                } },
                { "node", new Dictionary<string, object>() {
                    { "get", new List<object>() {"addresses", "addresses/balance/{address}", "addresses/balance/{address}/{confirmations}", "addresses/balance/details/{address}", "addresses/data/{address}", "addresses/data/{address}/{key}", "addresses/effectiveBalance/{address}", "addresses/effectiveBalance/{address}/{confirmations}", "addresses/publicKey/{publicKey}", "addresses/scriptInfo/{address}", "addresses/scriptInfo/{address}/meta", "addresses/seed/{address}", "addresses/seq/{from}/{to}", "addresses/validate/{address}", "alias/by-address/{address}", "alias/by-alias/{alias}", "assets/{assetId}/distribution/{height}/{limit}", "assets/balance/{address}", "assets/balance/{address}/{assetId}", "assets/details/{assetId}", "assets/nft/{address}/limit/{limit}", "blockchain/rewards", "blockchain/rewards/height", "blocks/address/{address}/{from}/{to}/", "blocks/at/{height}", "blocks/delay/{signature}/{blockNum}", "blocks/first", "blocks/headers/last", "blocks/headers/seq/{from}/{to}", "blocks/height", "blocks/height/{signature}", "blocks/last", "blocks/seq/{from}/{to}", "blocks/signature/{signature}", "consensus/algo", "consensus/basetarget", "consensus/basetarget/{blockId}", "consensus/{generatingbalance}/address", "consensus/generationsignature", "consensus/generationsignature/{blockId}", "debug/balances/history/{address}", "debug/blocks/{howMany}", "debug/configInfo", "debug/historyInfo", "debug/info", "debug/minerInfo", "debug/portfolios/{address}", "debug/state", "debug/stateChanges/address/{address}", "debug/stateChanges/info/{id}", "debug/stateWaves/{height}", "leasing/active/{address}", "node/state", "node/version", "peers/all", "peers/blacklisted", "peers/connected", "peers/suspended", "transactions/address/{address}/limit/{limit}", "transactions/info/{id}", "transactions/status", "transactions/unconfirmed", "transactions/unconfirmed/info/{id}", "transactions/unconfirmed/size", "utils/seed", "utils/seed/{length}", "utils/time", "wallet/seed"} },
                    { "post", new List<object>() {"addresses", "addresses/data/{address}", "addresses/sign/{address}", "addresses/signText/{address}", "addresses/verify/{address}", "addresses/verifyText/{address}", "debug/blacklist", "debug/print", "debug/rollback", "debug/validate", "node/stop", "peers/clearblacklist", "peers/connect", "transactions/broadcast", "transactions/calculateFee", "tranasctions/sign", "transactions/sign/{signerAddress}", "tranasctions/status", "utils/hash/fast", "utils/hash/secure", "utils/script/compileCode", "utils/script/compileWithImports", "utils/script/decompile", "utils/script/estimate", "utils/sign/{privateKey}", "utils/transactionsSerialize"} },
                    { "delete", new List<object>() {"addresses/{address}", "debug/rollback-to/{signature}"} },
                } },
                { "public", new Dictionary<string, object>() {
                    { "get", new List<object>() {"assets", "pairs", "candles/{baseId}/{quoteId}", "transactions/exchange"} },
                } },
                { "private", new Dictionary<string, object>() {
                    { "get", new List<object>() {"deposit/addresses/{currency}", "deposit/addresses/{currency}/{platform}", "platforms", "deposit/currencies", "withdraw/currencies", "withdraw/addresses/{currency}/{address}"} },
                    { "post", new List<object>() {"oauth2/token"} },
                } },
                { "forward", new Dictionary<string, object>() {
                    { "get", new List<object>() {"matcher/orders/{address}", "matcher/orders/{address}/{orderId}"} },
                    { "post", new List<object>() {"matcher/orders/{wavesAddress}/cancel"} },
                } },
                { "market", new Dictionary<string, object>() {
                    { "get", new List<object>() {"tickers"} },
                } },
            } },
            { "currencies", new Dictionary<string, object>() {
                { "WX", this.safeCurrencyStructure(new Dictionary<string, object>() {
                    { "id", "EMAMLxDnv3xiz8RXg8Btj33jcEw3wLczL3JKYYmuubpc" },
                    { "numericId", null },
                    { "code", "WX" },
                    { "precision", this.parseToInt("8") },
                }) },
            } },
            { "precisionMode", DECIMAL_PLACES },
            { "options", new Dictionary<string, object>() {
                { "allowedCandles", 1440 },
                { "accessToken", null },
                { "createMarketBuyOrderRequiresPrice", true },
                { "matcherPublicKey", null },
                { "quotes", null },
                { "createOrderDefaultExpiry", 2419200000 },
                { "wavesAddress", null },
                { "withdrawFeeUSDN", 7420 },
                { "withdrawFeeWAVES", 100000 },
                { "wavesPrecision", 8 },
                { "messagePrefix", "W" },
                { "networks", new Dictionary<string, object>() {
                    { "ERC20", "ETH" },
                    { "BEP20", "BSC" },
                } },
            } },
            { "commonCurrencies", new Dictionary<string, object>() {
                { "EGG", "Waves Ducks" },
            } },
            { "requiresEddsa", true },
            { "exceptions", new Dictionary<string, object>() {
                { "3147270", typeof(InsufficientFunds) },
                { "112", typeof(InsufficientFunds) },
                { "4", typeof(ExchangeError) },
                { "13", typeof(ExchangeNotAvailable) },
                { "14", typeof(ExchangeNotAvailable) },
                { "3145733", typeof(AccountSuspended) },
                { "3148040", typeof(DuplicateOrderId) },
                { "3148801", typeof(AuthenticationError) },
                { "9440512", typeof(AuthenticationError) },
                { "9440771", typeof(BadSymbol) },
                { "9441026", typeof(InvalidOrder) },
                { "9441282", typeof(InvalidOrder) },
                { "9441286", typeof(InvalidOrder) },
                { "9441295", typeof(InvalidOrder) },
                { "9441540", typeof(InvalidOrder) },
                { "9441542", typeof(InvalidOrder) },
                { "106954752", typeof(AuthenticationError) },
                { "106954769", typeof(AuthenticationError) },
                { "106957828", typeof(AuthenticationError) },
                { "106960131", typeof(AuthenticationError) },
                { "106981137", typeof(AuthenticationError) },
                { "9437184", typeof(BadRequest) },
                { "9437193", typeof(OrderNotFound) },
                { "1048577", typeof(BadRequest) },
                { "1051904", typeof(AuthenticationError) },
            } },
        });
    }

    public override void setSandboxMode(object enabled)
    {
        ((IDictionary<string,object>)this.options)["messagePrefix"] = ((bool) isTrue(enabled)) ? "T" : "W";
        ((IDictionary<string,object>)this.options)["sandboxMode"] = enabled;
        base.setSandboxMode(enabled);
    }

    public async virtual Task<object> getFeesForAsset(object symbol, object side, object amount, object price, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        amount = this.customAmountToPrecision(symbol, amount);
        price = this.customPriceToPrecision(symbol, price);
        object request = this.extend(new Dictionary<string, object>() {
            { "baseId", getValue(market, "baseId") },
            { "quoteId", getValue(market, "quoteId") },
            { "orderType", side },
            { "amount", amount },
            { "price", price },
        }, parameters);
        return await this.matcherPostMatcherOrderbookBaseIdQuoteIdCalculateFee(request);
    }

    public async virtual Task<object> customCalculateFee(object symbol, object type, object side, object amount, object price, object takerOrMaker = null, object parameters = null)
    {
        takerOrMaker ??= "taker";
        parameters ??= new Dictionary<string, object>();
        object response = await this.getFeesForAsset(symbol, side, amount, price);
        // {
        //     "base":{
        //        "feeAssetId":"WAVES",
        //        "matcherFee":"1000000"
        //     },
        //     "discount":{
        //        "feeAssetId":"EMAMLxDnv3xiz8RXg8Btj33jcEw3wLczL3JKYYmuubpc",
        //        "matcherFee":"4077612"
        //     }
        //  }
        object isDiscountFee = this.safeBool(parameters, "isDiscountFee", false);
        object mode = null;
        if (isTrue(isDiscountFee))
        {
            mode = this.safeValue(response, "discount");
        } else
        {
            mode = this.safeValue(response, "base");
        }
        object matcherFee = this.safeString(mode, "matcherFee");
        object feeAssetId = this.safeString(mode, "feeAssetId");
        object feeAsset = this.safeCurrencyCode(feeAssetId);
        object adjustedMatcherFee = this.currencyFromPrecision(feeAsset, matcherFee);
        object amountAsString = this.numberToString(amount);
        object priceAsString = this.numberToString(price);
        object feeCost = this.feeToPrecision(symbol, this.parseNumber(adjustedMatcherFee));
        object feeRate = Precise.stringDiv(adjustedMatcherFee, Precise.stringMul(amountAsString, priceAsString));
        return new Dictionary<string, object>() {
            { "type", takerOrMaker },
            { "currency", feeAsset },
            { "rate", this.parseNumber(feeRate) },
            { "cost", this.parseNumber(feeCost) },
        };
    }

    public async virtual Task<object> getQuotes()
    {
        object quotes = this.safeValue(this.options, "quotes");
        if (isTrue(quotes))
        {
            return quotes;
        } else
        {
            // currencies can have any name because you can create you own token
            // as a result someone can create a fake token called BTC
            // we use this mapping to determine the real tokens
            // https://docs.wx.network/en/waves-matcher/matcher-api#asset-pair
            object response = await this.matcherGetMatcherSettings();
            // {
            //   "orderVersions": [
            //     1,
            //     2,
            //     3
            //   ],
            //   "success": true,
            //   "matcherPublicKey": "9cpfKN9suPNvfeUNphzxXMjcnn974eme8ZhWUjaktzU5",
            //   "orderFee": {
            //     "dynamic": {
            //       "baseFee": 300000,
            //       "rates": {
            //         "34N9YcEETLWn93qYQ64EsP1x89tSruJU44RrEMSXXEPJ": 1.22639597,
            //         "62LyMjcr2DtiyF5yVXFhoQ2q414VPPJXjsNYp72SuDCH": 0.00989643,
            //         "HZk1mbfuJpmxU1Fs4AX5MWLVYtctsNcg6e2C6VKqK8zk": 0.0395674,
            //         "8LQW8f7P5d5PZM7GtZEBgaqRPGSzS3DfPuiXrURJ4AJS": 0.00018814,
            //         "4LHHvYGNKJUg5hj65aGD5vgScvCBmLpdRFtjokvCjSL8": 26.19721262,
            //         "474jTeYx2r2Va35794tCScAXWJG9hU2HcgxzMowaZUnu": 0.00752978,
            //         "DG2xFkPdDwKUoBkzGAhQtLpSGzfXLiCYPEzeKH2Ad24p": 1.84575,
            //         "B3uGHFRpSUuGEDWjqB9LWWxafQj8VTvpMucEyoxzws5H": 0.02330273,
            //         "zMFqXuoyrn5w17PFurTqxB7GsS71fp9dfk6XFwxbPCy": 0.00721412,
            //         "5WvPKSJXzVE2orvbkJ8wsQmmQKqTv9sGBPksV4adViw3": 0.02659103,
            //         "WAVES": 1,
            //         "BrjUWjndUanm5VsJkbUip8VRYy6LWJePtxya3FNv4TQa": 0.03433583
            //       }
            //     }
            //   },
            //   "networkByte": 87,
            //   "matcherVersion": "2.1.3.5",
            //   "status": "SimpleResponse",
            //   "priceAssets": [
            //     "Ft8X1v1LTa1ABafufpaCWyVj8KkaxUWE6xBhW6sNFJck",
            //     "DG2xFkPdDwKUoBkzGAhQtLpSGzfXLiCYPEzeKH2Ad24p",
            //     "34N9YcEETLWn93qYQ64EsP1x89tSruJU44RrEMSXXEPJ",
            //     "Gtb1WRznfchDnTh37ezoDTJ4wcoKaRsKqKjJjy7nm2zU",
            //     "2mX5DzVKWrAJw8iwdJnV2qtoeVG9h5nTDpTqC1wb1WEN",
            //     "8LQW8f7P5d5PZM7GtZEBgaqRPGSzS3DfPuiXrURJ4AJS",
            //     "WAVES",
            //     "474jTeYx2r2Va35794tCScAXWJG9hU2HcgxzMowaZUnu",
            //     "zMFqXuoyrn5w17PFurTqxB7GsS71fp9dfk6XFwxbPCy",
            //     "62LyMjcr2DtiyF5yVXFhoQ2q414VPPJXjsNYp72SuDCH",
            //     "HZk1mbfuJpmxU1Fs4AX5MWLVYtctsNcg6e2C6VKqK8zk",
            //     "B3uGHFRpSUuGEDWjqB9LWWxafQj8VTvpMucEyoxzws5H",
            //     "5WvPKSJXzVE2orvbkJ8wsQmmQKqTv9sGBPksV4adViw3",
            //     "BrjUWjndUanm5VsJkbUip8VRYy6LWJePtxya3FNv4TQa",
            //     "4LHHvYGNKJUg5hj65aGD5vgScvCBmLpdRFtjokvCjSL8"
            //   ]
            // }
            quotes = new Dictionary<string, object>() {};
            object priceAssets = this.safeValue(response, "priceAssets");
            for (object i = 0; isLessThan(i, getArrayLength(priceAssets)); postFixIncrement(ref i))
            {
                ((IDictionary<string,object>)quotes)[(string)getValue(priceAssets, i)] = true;
            }
            ((IDictionary<string,object>)this.options)["quotes"] = quotes;
            return quotes;
        }
    }

    public async override Task<object> fetchMarkets(object parameters = null)
    {
        /**
        * @method
        * @name wavesexchange#fetchMarkets
        * @description retrieves data on all markets for wavesexchange
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} an array of objects representing market data
        */
        parameters ??= new Dictionary<string, object>();
        object response = await this.marketGetTickers();
        //
        //   [
        //       {
        //           "symbol": "WAVES/BTC",
        //           "amountAssetID": "WAVES",
        //           "amountAssetName": "Waves",
        //           "amountAssetDecimals": 8,
        //           "amountAssetTotalSupply": "106908766.00000000",
        //           "amountAssetMaxSupply": "106908766.00000000",
        //           "amountAssetCirculatingSupply": "106908766.00000000",
        //           "priceAssetID": "8LQW8f7P5d5PZM7GtZEBgaqRPGSzS3DfPuiXrURJ4AJS",
        //           "priceAssetName": "WBTC",
        //           "priceAssetDecimals": 8,
        //           "priceAssetTotalSupply": "20999999.96007507",
        //           "priceAssetMaxSupply": "20999999.96007507",
        //           "priceAssetCirculatingSupply": "20999999.66019601",
        //           "24h_open": "0.00032688",
        //           "24h_high": "0.00033508",
        //           "24h_low": "0.00032443",
        //           "24h_close": "0.00032806",
        //           "24h_vwap": "0.00032988",
        //           "24h_volume": "42349.69440104",
        //           "24h_priceVolume": "13.97037207",
        //           "timestamp":1640232379124
        //       }
        //       ...
        //   ]
        //
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(response)); postFixIncrement(ref i))
        {
            object entry = getValue(response, i);
            object baseId = this.safeString(entry, "amountAssetID");
            object quoteId = this.safeString(entry, "priceAssetID");
            object id = add(add(baseId, "/"), quoteId);
            object marketId = this.safeString(entry, "symbol");
            var bsquoteVariable = ((string)marketId).Split(new [] {((string)"/")}, StringSplitOptions.None).ToList<object>();
            var bs = ((IList<object>) bsquoteVariable)[0];
            var quote = ((IList<object>) bsquoteVariable)[1];
            bs = this.safeCurrencyCode(bs);
            quote = this.safeCurrencyCode(quote);
            object symbol = add(add(bs, "/"), quote);
            ((IList<object>)result).Add(new Dictionary<string, object>() {
                { "id", id },
                { "symbol", symbol },
                { "base", bs },
                { "quote", quote },
                { "settle", null },
                { "baseId", baseId },
                { "quoteId", quoteId },
                { "settleId", null },
                { "type", "spot" },
                { "spot", true },
                { "margin", false },
                { "swap", false },
                { "future", false },
                { "option", false },
                { "active", null },
                { "contract", false },
                { "linear", null },
                { "inverse", null },
                { "contractSize", null },
                { "expiry", null },
                { "expiryDatetime", null },
                { "strike", null },
                { "optionType", null },
                { "precision", new Dictionary<string, object>() {
                    { "amount", this.safeInteger(entry, "amountAssetDecimals") },
                    { "price", this.safeInteger(entry, "priceAssetDecimals") },
                } },
                { "limits", new Dictionary<string, object>() {
                    { "leverage", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                    { "amount", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                    { "price", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                    { "cost", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                } },
                { "created", null },
                { "info", entry },
            });
        }
        return result;
    }

    public async override Task<object> fetchOrderBook(object symbol, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name wavesexchange#fetchOrderBook
        * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
        * @param {string} symbol unified symbol of the market to fetch the order book for
        * @param {int} [limit] the maximum amount of order book entries to return
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = this.extend(new Dictionary<string, object>() {
            { "baseId", getValue(market, "baseId") },
            { "quoteId", getValue(market, "quoteId") },
        }, parameters);
        object response = await this.matcherGetMatcherOrderbookBaseIdQuoteId(request);
        object timestamp = this.safeInteger(response, "timestamp");
        object bids = this.parseOrderBookSide(this.safeValue(response, "bids"), market, limit);
        object asks = this.parseOrderBookSide(this.safeValue(response, "asks"), market, limit);
        return new Dictionary<string, object>() {
            { "symbol", symbol },
            { "bids", bids },
            { "asks", asks },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "nonce", null },
        };
    }

    public virtual object parseOrderBookSide(object bookSide, object market = null, object limit = null)
    {
        object precision = getValue(market, "precision");
        object wavesPrecision = this.safeString(this.options, "wavesPrecision", "8");
        object amountPrecision = add("1e", this.numberToString(getValue(precision, "amount")));
        object amountPrecisionString = this.numberToString(getValue(precision, "amount"));
        object pricePrecisionString = this.numberToString(getValue(precision, "price"));
        object difference = Precise.stringSub(amountPrecisionString, pricePrecisionString);
        object pricePrecision = add("1e", Precise.stringSub(wavesPrecision, difference));
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(bookSide)); postFixIncrement(ref i))
        {
            object entry = getValue(bookSide, i);
            object entryPrice = this.safeString(entry, "price", "0");
            object entryAmount = this.safeString(entry, "amount", "0");
            object price = null;
            object amount = null;
            if (isTrue(isTrue((!isEqual(pricePrecision, null))) && isTrue((!isEqual(entryPrice, null)))))
            {
                price = Precise.stringDiv(entryPrice, pricePrecision);
            }
            if (isTrue(isTrue((!isEqual(amountPrecision, null))) && isTrue((!isEqual(entryAmount, null)))))
            {
                amount = Precise.stringDiv(entryAmount, amountPrecision);
            }
            if (isTrue(isTrue((!isEqual(limit, null))) && isTrue((isGreaterThan(i, limit)))))
            {
                break;
            }
            ((IList<object>)result).Add(new List<object> {this.parseNumber(price), this.parseNumber(amount)});
        }
        return result;
    }

    public virtual void checkRequiredKeys()
    {
        if (isTrue(isEqual(this.apiKey, null)))
        {
            throw new AuthenticationError ((string)add(this.id, " requires apiKey credential")) ;
        }
        if (isTrue(isEqual(this.secret, null)))
        {
            throw new AuthenticationError ((string)add(this.id, " requires secret credential")) ;
        }
        object apiKeyBytes = null;
        object secretKeyBytes = null;
        try
        {
            apiKeyBytes = this.base58ToBinary(this.apiKey);
        } catch(Exception e)
        {
            throw new AuthenticationError ((string)add(this.id, " apiKey must be a base58 encoded public key")) ;
        }
        try
        {
            secretKeyBytes = this.base58ToBinary(this.secret);
        } catch(Exception e)
        {
            throw new AuthenticationError ((string)add(this.id, " secret must be a base58 encoded private key")) ;
        }
        object hexApiKeyBytes = this.binaryToBase16(apiKeyBytes);
        object hexSecretKeyBytes = this.binaryToBase16(secretKeyBytes);
        if (isTrue(!isEqual(((string)hexApiKeyBytes).Length, 64)))
        {
            throw new AuthenticationError ((string)add(this.id, " apiKey must be a base58 encoded public key")) ;
        }
        if (isTrue(!isEqual(((string)hexSecretKeyBytes).Length, 64)))
        {
            throw new AuthenticationError ((string)add(this.id, " secret must be a base58 encoded private key")) ;
        }
    }

    public override object sign(object path, object api = null, object method = null, object parameters = null, object headers = null, object body = null)
    {
        api ??= "public";
        method ??= "GET";
        parameters ??= new Dictionary<string, object>();
        object query = this.omit(parameters, this.extractParams(path));
        object isCancelOrder = isEqual(path, "matcher/orders/{wavesAddress}/cancel");
        path = this.implodeParams(path, parameters);
        object url = add(add(getValue(getValue(this.urls, "api"), api), "/"), path);
        object queryString = this.urlencodeWithArrayRepeat(query);
        if (isTrue(isTrue((isEqual(api, "private"))) || isTrue((isEqual(api, "forward")))))
        {
            headers = new Dictionary<string, object>() {
                { "Accept", "application/json" },
            };
            object accessToken = this.safeString(this.options, "accessToken");
            if (isTrue(accessToken))
            {
                ((IDictionary<string,object>)headers)["Authorization"] = add("Bearer ", accessToken);
            }
            if (isTrue(isEqual(method, "POST")))
            {
                ((IDictionary<string,object>)headers)["content-type"] = "application/json";
            } else
            {
                ((IDictionary<string,object>)headers)["content-type"] = "application/x-www-form-urlencoded";
            }
            if (isTrue(isCancelOrder))
            {
                body = this.json(new List<object>() {getValue(query, "orderId")});
                queryString = "";
            }
            if (isTrue(isGreaterThan(getArrayLength(queryString), 0)))
            {
                url = add(url, add("?", queryString));
            }
        } else if (isTrue(isEqual(api, "matcher")))
        {
            if (isTrue(isEqual(method, "POST")))
            {
                headers = new Dictionary<string, object>() {
                    { "Accept", "application/json" },
                    { "Content-Type", "application/json" },
                };
                body = this.json(query);
            } else
            {
                headers = query;
            }
        } else
        {
            if (isTrue(isEqual(method, "POST")))
            {
                headers = new Dictionary<string, object>() {
                    { "content-type", "application/json" },
                };
                body = this.json(query);
            } else
            {
                headers = new Dictionary<string, object>() {
                    { "content-type", "application/x-www-form-urlencoded" },
                };
                if (isTrue(isGreaterThan(getArrayLength(queryString), 0)))
                {
                    url = add(url, add("?", queryString));
                }
            }
        }
        return new Dictionary<string, object>() {
            { "url", url },
            { "method", method },
            { "body", body },
            { "headers", headers },
        };
    }

    public async override Task<object> signIn(object parameters = null)
    {
        /**
        * @method
        * @name wavesexchange#signIn
        * @description sign in, must be called prior to using other authenticated methods
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns response from exchange
        */
        // W for production, T for testnet
        // { access_token: "eyJhbGciOXJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJzaWciOiJiaTZiMVhMQlo0M1Q4QmRTSlVSejJBZGlQdVlpaFZQYVhhVjc4ZGVIOEpTM3M3NUdSeEU1VkZVOE5LRUI0UXViNkFHaUhpVFpuZ3pzcnhXdExUclRvZTgiLCJhIjoiM1A4VnpMU2EyM0VXNUNWY2tIYlY3ZDVCb043NWZGMWhoRkgiLCJuYiI6IlciLCJ1c2VyX25hbWUiOiJBSFhuOG5CQTRTZkxRRjdoTFFpU24xNmt4eWVoaml6QkdXMVRkcm1TWjFnRiIsInNjb3BlIjpbImdlbmVyYWwiXSwibHQiOjYwNDc5OSwicGsiOiJBSFhuOG5CQTRTZkxRRjdoTFFpU24xNmt4eWVoaml6QkdXMVRkcm1TWjFnRiIsImV4cCI6MTU5MTk3NTA1NywiZXhwMCI6MTU5MTk3NTA1NywianRpIjoiN2JhOTUxMTMtOGI2MS00NjEzLTlkZmYtNTEwYTc0NjlkOWI5IiwiY2lkIjoid2F2ZXMuZXhjaGFuZ2UifQ.B-XwexBnUAzbWknVN68RKT0ZP5w6Qk1SKJ8usL3OIwDEzCUUX9PjW-5TQHmiCRcA4oft8lqXEiCwEoNfsblCo_jTpRo518a1vZkIbHQk0-13Dm1K5ewGxfxAwBk0g49odcbKdjl64TN1yM_PO1VtLVuiTeZP-XF-S42Uj-7fcO-r7AulyQLuTE0uo-Qdep8HDCk47rduZwtJOmhFbCCnSgnLYvKWy3CVTeldsR77qxUY-vy8q9McqeP7Id-_MWnsob8vWXpkeJxaEsw1Fke1dxApJaJam09VU8EB3ZJWpkT7V8PdafIrQGeexx3jhKKxo7rRb4hDV8kfpVoCgkvFan",
        //   "token_type": "bearer",
        //   "refresh_token": "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJzaWciOiJiaTZiMVhMQlo0M1Q4QmRTSlVSejJBZGlQdVlpaFZQYVhhVjc4ZGVIOEpTM3M3NUdSeEU1VkZVOE5LRUI0UXViNkFHaUhpVFpuZ3pzcnhXdExUclRvZTgiLCJhIjoiM1A4VnpMU2EyM0VXNUNWY2tIYlY3ZDVCb043NWZGMWhoRkgiLCJuYiI6IlciLCJ1c2VyX25hbWUiOiJBSFhuOG5CQTRTZkxRRjdoTFFpU24xNmt4eWVoaml6QkdXMVRkcm1TWjFnRiIsInNjb3BlIjpbImdlbmVyYWwiXSwiYXRpIjoiN2JhOTUxMTMtOGI2MS00NjEzLTlkZmYtNTEwYTc0NjlkXWI5IiwibHQiOjYwNDc5OSwicGsiOiJBSFhuOG5CQTRTZkxRRjdoTFFpU24xNmt4eWVoaml6QkdXMVRkcm1TWjFnRiIsImV4cCI6MTU5Mzk2MjI1OCwiZXhwMCI6MTU5MTk3NTA1NywianRpIjoiM2MzZWRlMTktNjI5My00MTNlLWJmMWUtZTRlZDZlYzUzZTgzIiwiY2lkIjoid2F2ZXMuZXhjaGFuZ2UifQ.gD1Qj0jfqayfZpBvNY0t3ccMyK5hdbT7dY-_5L6LxwV0Knan4ndEtvygxlTOczmJUKtnA4T1r5GBFgNMZTvtViKZIbqZNysEg2OY8UxwDaF4VPeGJLg_QXEnn8wBeBQdyMafh9UQdwD2ci7x-saM4tOAGmncAygfTDxy80201gwDhfAkAGerb9kL00oWzSJScldxu--pNLDBUEHZt52MSEel10HGrzvZkkvvSh67vcQo5TOGb5KG6nh65UdJCwr41AVz4fbQPP-N2Nkxqy0TE_bqVzZxExXgvcS8TS0Z82T3ijJa_ct7B9wblpylBnvmyj3VycUzufD6uy8MUGq32D",
        //   "expires_in": 604798,
        //   "scope": "general" }
        parameters ??= new Dictionary<string, object>();
        if (!isTrue(this.safeString(this.options, "accessToken")))
        {
            object prefix = "ffffff01";
            object expiresDelta = multiply(multiply(multiply(60, 60), 24), 7);
            object seconds = this.sum(this.seconds(), expiresDelta);
            seconds = ((object)seconds).ToString();
            object clientId = "wx.network";
            object defaultMessagePrefix = this.safeString(this.options, "messagePrefix", "W");
            object message = add(add(add(add(defaultMessagePrefix, ":"), clientId), ":"), seconds);
            object messageHex = this.binaryToBase16(this.encode(message));
            object payload = add(prefix, messageHex);
            object hexKey = this.binaryToBase16(this.base58ToBinary(this.secret));
            object signature = this.axolotl(payload, hexKey, ed25519);
            object request = new Dictionary<string, object>() {
                { "grant_type", "password" },
                { "scope", "general" },
                { "username", this.apiKey },
                { "password", add(add(seconds, ":"), signature) },
                { "client_id", clientId },
            };
            object response = await this.privatePostOauth2Token(request);
            ((IDictionary<string,object>)this.options)["accessToken"] = this.safeString(response, "access_token");
            return getValue(this.options, "accessToken");
        }
        return null;
    }

    public override object parseTicker(object ticker, object market = null)
    {
        //
        //       {
        //           "symbol": "WAVES/BTC",
        //           "amountAssetID": "WAVES",
        //           "amountAssetName": "Waves",
        //           "amountAssetDecimals": 8,
        //           "amountAssetTotalSupply": "106908766.00000000",
        //           "amountAssetMaxSupply": "106908766.00000000",
        //           "amountAssetCirculatingSupply": "106908766.00000000",
        //           "priceAssetID": "8LQW8f7P5d5PZM7GtZEBgaqRPGSzS3DfPuiXrURJ4AJS",
        //           "priceAssetName": "WBTC",
        //           "priceAssetDecimals": 8,
        //           "priceAssetTotalSupply": "20999999.96007507",
        //           "priceAssetMaxSupply": "20999999.96007507",
        //           "priceAssetCirculatingSupply": "20999999.66019601",
        //           "24h_open": "0.00032688",
        //           "24h_high": "0.00033508",
        //           "24h_low": "0.00032443",
        //           "24h_close": "0.00032806",
        //           "24h_vwap": "0.00032988",
        //           "24h_volume": "42349.69440104",
        //           "24h_priceVolume": "13.97037207",
        //           "timestamp":1640232379124
        //       }
        //
        //  fetch ticker
        //
        //       {
        //           "firstPrice": "21749",
        //           "lastPrice": "22000",
        //           "volume": "0.73747149",
        //           "quoteVolume": "16409.44564928645471",
        //           "high": "23589.999941",
        //           "low": "21010.000845",
        //           "weightedAveragePrice": "22250.955964",
        //           "txsCount": "148",
        //           "volumeWaves": "0.0000000000680511203072"
        //       }
        //
        object timestamp = this.safeInteger(ticker, "timestamp");
        object marketId = this.safeString(ticker, "symbol");
        market = this.safeMarket(marketId, market, "/");
        object symbol = getValue(market, "symbol");
        object last = this.safeString2(ticker, "24h_close", "lastPrice");
        object low = this.safeString2(ticker, "24h_low", "low");
        object high = this.safeString2(ticker, "24h_high", "high");
        object vwap = this.safeString2(ticker, "24h_vwap", "weightedAveragePrice");
        object baseVolume = this.safeString2(ticker, "24h_volume", "volume");
        object quoteVolume = this.safeString2(ticker, "24h_priceVolume", "quoteVolume");
        object open = this.safeString2(ticker, "24h_open", "firstPrice");
        return this.safeTicker(new Dictionary<string, object>() {
            { "symbol", symbol },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "high", high },
            { "low", low },
            { "bid", null },
            { "bidVolume", null },
            { "ask", null },
            { "askVolume", null },
            { "vwap", vwap },
            { "open", open },
            { "close", last },
            { "last", last },
            { "previousClose", null },
            { "change", null },
            { "percentage", null },
            { "average", null },
            { "baseVolume", baseVolume },
            { "quoteVolume", quoteVolume },
            { "info", ticker },
        }, market);
    }

    public async override Task<object> fetchTicker(object symbol, object parameters = null)
    {
        /**
        * @method
        * @name wavesexchange#fetchTicker
        * @description fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
        * @param {string} symbol unified symbol of the market to fetch the ticker for
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "pairs", getValue(market, "id") },
        };
        object response = await this.publicGetPairs(this.extend(request, parameters));
        //
        //     {
        //         "__type":"list",
        //         "data":[
        //             {
        //                 "__type":"pair",
        //                 "data":{
        //                     "firstPrice":0.00012512,
        //                     "lastPrice":0.00012441,
        //                     "low":0.00012167,
        //                     "high":0.00012768,
        //                     "weightedAveragePrice":0.000124710697407246,
        //                     "volume":209554.26356614,
        //                     "quoteVolume":26.1336583539951,
        //                     "volumeWaves":209554.26356614,
        //                     "txsCount":6655
        //                 },
        //                 "amountAsset":"WAVES",
        //                 "priceAsset":"8LQW8f7P5d5PZM7GtZEBgaqRPGSzS3DfPuiXrURJ4AJS"
        //             }
        //         ]
        //     }
        //
        object data = this.safeValue(response, "data", new List<object>() {});
        object ticker = this.safeValue(data, 0, new Dictionary<string, object>() {});
        object dataTicker = this.safeDict(ticker, "data", new Dictionary<string, object>() {});
        return this.parseTicker(dataTicker, market);
    }

    public async override Task<object> fetchTickers(object symbols = null, object parameters = null)
    {
        /**
        * @method
        * @name wavesexchange#fetchTickers
        * @description fetches price tickers for multiple markets, statistical information calculated over the past 24 hours for each market
        * @param {string[]|undefined} symbols unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/#/?id=ticker-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.marketGetTickers(parameters);
        //
        //   [
        //       {
        //           "symbol": "WAVES/BTC",
        //           "amountAssetID": "WAVES",
        //           "amountAssetName": "Waves",
        //           "amountAssetDecimals": 8,
        //           "amountAssetTotalSupply": "106908766.00000000",
        //           "amountAssetMaxSupply": "106908766.00000000",
        //           "amountAssetCirculatingSupply": "106908766.00000000",
        //           "priceAssetID": "8LQW8f7P5d5PZM7GtZEBgaqRPGSzS3DfPuiXrURJ4AJS",
        //           "priceAssetName": "WBTC",
        //           "priceAssetDecimals": 8,
        //           "priceAssetTotalSupply": "20999999.96007507",
        //           "priceAssetMaxSupply": "20999999.96007507",
        //           "priceAssetCirculatingSupply": "20999999.66019601",
        //           "24h_open": "0.00032688",
        //           "24h_high": "0.00033508",
        //           "24h_low": "0.00032443",
        //           "24h_close": "0.00032806",
        //           "24h_vwap": "0.00032988",
        //           "24h_volume": "42349.69440104",
        //           "24h_priceVolume": "13.97037207",
        //           "timestamp":1640232379124
        //       }
        //       ...
        //   ]
        //
        return this.parseTickers(response, symbols);
    }

    public async override Task<object> fetchOHLCV(object symbol, object timeframe = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name wavesexchange#fetchOHLCV
        * @description fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
        * @param {string} symbol unified symbol of the market to fetch OHLCV data for
        * @param {string} timeframe the length of time each candle represents
        * @param {int} [since] timestamp in ms of the earliest candle to fetch
        * @param {int} [limit] the maximum amount of candles to fetch
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
        */
        timeframe ??= "1m";
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "baseId", getValue(market, "baseId") },
            { "quoteId", getValue(market, "quoteId") },
            { "interval", this.safeString(this.timeframes, timeframe, timeframe) },
        };
        object allowedCandles = this.safeInteger(this.options, "allowedCandles", 1440);
        if (isTrue(isEqual(limit, null)))
        {
            limit = allowedCandles;
        }
        limit = mathMin(allowedCandles, limit);
        object duration = multiply(this.parseTimeframe(timeframe), 1000);
        if (isTrue(isEqual(since, null)))
        {
            object durationRoundedTimestamp = multiply(this.parseToInt(divide(this.milliseconds(), duration)), duration);
            object delta = multiply((subtract(limit, 1)), duration);
            object timeStart = subtract(durationRoundedTimestamp, delta);
            ((IDictionary<string,object>)request)["timeStart"] = ((object)timeStart).ToString();
        } else
        {
            ((IDictionary<string,object>)request)["timeStart"] = ((object)since).ToString();
            object timeEnd = this.sum(since, multiply(duration, limit));
            ((IDictionary<string,object>)request)["timeEnd"] = ((object)timeEnd).ToString();
        }
        object response = await this.publicGetCandlesBaseIdQuoteId(this.extend(request, parameters));
        //
        //     {
        //         "__type": "list",
        //         "data": [
        //             {
        //                 "__type": "candle",
        //                 "data": {
        //                     "time": "2020-06-09T14:47:00.000Z",
        //                     "open": 0.0250385,
        //                     "close": 0.0250385,
        //                     "high": 0.0250385,
        //                     "low": 0.0250385,
        //                     "volume": 0.01033012,
        //                     "quoteVolume": 0.00025865,
        //                     "weightedAveragePrice": 0.0250385,
        //                     "maxHeight": 2099399,
        //                     "txsCount": 5,
        //                     "timeClose": "2020-06-09T14:47:59.999Z"
        //                 }
        //             }
        //         ]
        //     }
        //
        object data = this.safeValue(response, "data", new List<object>() {});
        object result = this.parseOHLCVs(data, market, timeframe, since, limit);
        result = this.filterFutureCandles(result);
        object lastClose = null;
        object length = getArrayLength(result);
        for (object i = 0; isLessThan(i, getArrayLength(result)); postFixIncrement(ref i))
        {
            object j = subtract(subtract(length, i), 1);
            object entry = getValue(result, j);
            object open = getValue(entry, 1);
            if (isTrue(isEqual(open, null)))
            {
                ((List<object>)entry)[Convert.ToInt32(1)] = lastClose;
                ((List<object>)entry)[Convert.ToInt32(2)] = lastClose;
                ((List<object>)entry)[Convert.ToInt32(3)] = lastClose;
                ((List<object>)entry)[Convert.ToInt32(4)] = lastClose;
                ((List<object>)result)[Convert.ToInt32(j)] = entry;
            }
            lastClose = getValue(entry, 4);
        }
        return result;
    }

    public virtual object filterFutureCandles(object ohlcvs)
    {
        object result = new List<object>() {};
        object timestamp = this.milliseconds();
        for (object i = 0; isLessThan(i, getArrayLength(ohlcvs)); postFixIncrement(ref i))
        {
            if (isTrue(isGreaterThan(getValue(getValue(ohlcvs, i), 0), timestamp)))
            {
                // stop when getting data from the future
                break;
            }
            ((IList<object>)result).Add(getValue(ohlcvs, i));
        }
        return result;
    }

    public override object parseOHLCV(object ohlcv, object market = null)
    {
        //
        //     {
        //         "__type": "candle",
        //         "data": {
        //             "time": "2020-06-05T20:46:00.000Z",
        //             "open": 240.573975,
        //             "close": 240.573975,
        //             "high": 240.573975,
        //             "low": 240.573975,
        //             "volume": 0.01278413,
        //             "quoteVolume": 3.075528,
        //             "weightedAveragePrice": 240.573975,
        //             "maxHeight": 2093895,
        //             "txsCount": 5,
        //             "timeClose": "2020-06-05T20:46:59.999Z"
        //         }
        //     }
        //
        object data = this.safeValue(ohlcv, "data", new Dictionary<string, object>() {});
        return new List<object> {this.parse8601(this.safeString(data, "time")), this.safeNumber(data, "open"), this.safeNumber(data, "high"), this.safeNumber(data, "low"), this.safeNumber(data, "close"), this.safeNumber(data, "volume", 0)};
    }

    public async override Task<object> fetchDepositAddress(object code, object parameters = null)
    {
        /**
        * @method
        * @name wavesexchange#fetchDepositAddress
        * @description fetch the deposit address for a currency associated with this account
        * @param {string} code unified currency code
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} an [address structure]{@link https://docs.ccxt.com/#/?id=address-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.signIn();
        object networks = this.safeValue(this.options, "networks", new Dictionary<string, object>() {});
        object rawNetwork = this.safeStringUpper(parameters, "network");
        object network = this.safeString(networks, rawNetwork, rawNetwork);
        parameters = this.omit(parameters, new List<object>() {"network"});
        object supportedCurrencies = await this.privateGetPlatforms();
        //
        //     {
        //       "type": "list",
        //       "page_info": {
        //         "has_next_page": false,
        //         "last_cursor": null
        //       },
        //       "items": [
        //         {
        //           "type": "platform",
        //           "id": "ETH",
        //           "name": "Ethereum",
        //           "currencies": [
        //             "BAG",
        //             "BNT",
        //             "CRV",
        //             "EGG",
        //             "ETH",
        //             "EURN",
        //             "FL",
        //             "NSBT",
        //             "USDAP",
        //             "USDC",
        //             "USDFL",
        //             "USDN",
        //             "USDT",
        //             "WAVES"
        //           ]
        //         }
        //       ]
        //     }
        //
        object currencies = new Dictionary<string, object>() {};
        object networksByCurrency = new Dictionary<string, object>() {};
        object items = this.safeValue(supportedCurrencies, "items", new List<object>() {});
        for (object i = 0; isLessThan(i, getArrayLength(items)); postFixIncrement(ref i))
        {
            object entry = getValue(items, i);
            object currencyId = this.safeString(entry, "id");
            object innerCurrencies = this.safeValue(entry, "currencies", new List<object>() {});
            for (object j = 0; isLessThan(j, getArrayLength(innerCurrencies)); postFixIncrement(ref j))
            {
                object currencyCode = this.safeString(innerCurrencies, j);
                ((IDictionary<string,object>)currencies)[(string)currencyCode] = true;
                if (!isTrue((inOp(networksByCurrency, currencyCode))))
                {
                    ((IDictionary<string,object>)networksByCurrency)[(string)currencyCode] = new Dictionary<string, object>() {};
                }
                ((IDictionary<string,object>)getValue(networksByCurrency, currencyCode))[(string)currencyId] = true;
            }
        }
        if (!isTrue((inOp(currencies, code))))
        {
            object codes = new List<object>(((IDictionary<string,object>)currencies).Keys);
            throw new ExchangeError ((string)add(add(add(add(this.id, " fetchDepositAddress() "), code), " not supported. Currency code must be one of "), String.Join(", ", ((IList<object>)codes).ToArray()))) ;
        }
        object response = null;
        if (isTrue(isEqual(network, null)))
        {
            object request = new Dictionary<string, object>() {
                { "currency", code },
            };
            response = await this.privateGetDepositAddressesCurrency(this.extend(request, parameters));
        } else
        {
            object supportedNetworks = getValue(networksByCurrency, code);
            if (!isTrue((inOp(supportedNetworks, network))))
            {
                object supportedNetworkKeys = new List<object>(((IDictionary<string,object>)supportedNetworks).Keys);
                throw new ExchangeError ((string)add(add(add(add(add(add(this.id, " "), network), " network "), code), " deposit address not supported. Network must be one of "), String.Join(", ", ((IList<object>)supportedNetworkKeys).ToArray()))) ;
            }
            if (isTrue(isEqual(network, "WAVES")))
            {
                object request = new Dictionary<string, object>() {
                    { "publicKey", this.apiKey },
                };
                object responseInner = await this.nodeGetAddressesPublicKeyPublicKey(this.extend(request, request));
                object addressInner = this.safeString(response, "address");
                return new Dictionary<string, object>() {
                    { "address", addressInner },
                    { "code", code },
                    { "currency", code },
                    { "network", network },
                    { "tag", null },
                    { "info", responseInner },
                };
            } else
            {
                object request = new Dictionary<string, object>() {
                    { "currency", code },
                    { "platform", network },
                };
                response = await this.privateGetDepositAddressesCurrencyPlatform(this.extend(request, parameters));
            }
        }
        //
        // {
        //   "type": "deposit_addresses",
        //   "currency": {
        //     "type": "deposit_currency",
        //     "id": "ERGO",
        //     "waves_asset_id": "5dJj4Hn9t2Ve3tRpNGirUHy4yBK6qdJRAJYV21yPPuGz",
        //     "platform_id": "BSC",
        //     "decimals": 9,
        //     "status": "active",
        //     "allowed_amount": {
        //       "min": 0.001,
        //       "max": 100000
        //     },
        //     "fees": {
        //       "flat": 0,
        //       "rate": 0
        //     }
        //   },
        //   "deposit_addresses": [
        //     "9fRAAQjF8Yqg7qicQCL884zjimsRnuwsSavsM1rUdDaoG8mThku"
        //   ]
        // }
        object currency = this.safeValue(response, "currency");
        object networkId = this.safeString(currency, "platform_id");
        object networkByIds = this.safeValue(this.options, "networkByIds", new Dictionary<string, object>() {});
        object unifiedNetwork = this.safeString(networkByIds, networkId, networkId);
        object addresses = this.safeValue(response, "deposit_addresses");
        object address = this.safeString(addresses, 0);
        return new Dictionary<string, object>() {
            { "address", address },
            { "code", code },
            { "currency", code },
            { "tag", null },
            { "network", unifiedNetwork },
            { "info", response },
        };
    }

    public async virtual Task<object> getMatcherPublicKey()
    {
        // this method returns a single string
        object matcherPublicKey = this.safeString(this.options, "matcherPublicKey");
        if (isTrue(matcherPublicKey))
        {
            return matcherPublicKey;
        } else
        {
            object response = await this.matcherGetMatcher();
            // remove trailing quotes from string response
            ((IDictionary<string,object>)this.options)["matcherPublicKey"] = slice(response, 1, subtract(getArrayLength(response), 1));
            return getValue(this.options, "matcherPublicKey");
        }
    }

    public virtual object getAssetBytes(object currencyId)
    {
        if (isTrue(isEqual(currencyId, "WAVES")))
        {
            return this.numberToBE(0, 1);
        } else
        {
            return this.binaryConcat(this.numberToBE(1, 1), this.base58ToBinary(currencyId));
        }
    }

    public virtual object getAssetId(object currencyId)
    {
        if (isTrue(isEqual(currencyId, "WAVES")))
        {
            return "";
        }
        return currencyId;
    }

    public virtual object customPriceToPrecision(object symbol, object price)
    {
        object market = getValue(this.markets, symbol);
        object wavesPrecision = this.safeString(this.options, "wavesPrecision", "8");
        object amount = this.numberToString(getValue(getValue(market, "precision"), "amount"));
        object precisionPrice = this.numberToString(getValue(getValue(market, "precision"), "price"));
        object difference = Precise.stringSub(amount, precisionPrice);
        object precision = Precise.stringSub(wavesPrecision, difference);
        object pricePrecision = ((object)this.toPrecision(price, precision)).ToString();
        return this.parseToInt(parseFloat(pricePrecision));
    }

    public virtual object customAmountToPrecision(object symbol, object amount)
    {
        object amountPrecision = this.numberToString(this.toPrecision(amount, this.numberToString(getValue(getValue(getValue(this.markets, symbol), "precision"), "amount"))));
        return this.parseToInt(parseFloat(amountPrecision));
    }

    public override object currencyToPrecision(object code, object amount, object networkCode = null)
    {
        object amountPrecision = this.numberToString(this.toPrecision(amount, getValue(getValue(this.currencies, code), "precision")));
        return this.parseToInt(parseFloat(amountPrecision));
    }

    public virtual object fromPrecision(object amount, object scale)
    {
        if (isTrue(isEqual(amount, null)))
        {
            return null;
        }
        var precise = new Precise(amount);
        precise.decimals = this.sum(precise.decimals, scale);
        precise.reduce();
        return ((object)precise).ToString();
    }

    public virtual object toPrecision(object amount, object scale)
    {
        object amountString = this.numberToString(amount);
        var precise = new Precise(amountString);
        // precise.decimals should be integer
        precise.decimals = this.parseToInt(Precise.stringSub(this.numberToString(precise.decimals), this.numberToString(scale)));
        precise.reduce();
        object stringValue = ((object)precise).ToString();
        return stringValue;
    }

    public virtual object currencyFromPrecision(object currency, object amount)
    {
        object scale = getValue(getValue(this.currencies, currency), "precision");
        return this.fromPrecision(amount, scale);
    }

    public virtual object priceFromPrecision(object symbol, object price)
    {
        object market = getValue(this.markets, symbol);
        object wavesPrecision = this.safeInteger(this.options, "wavesPrecision", 8);
        object scale = subtract(this.sum(wavesPrecision, getValue(getValue(market, "precision"), "price")), getValue(getValue(market, "precision"), "amount"));
        return this.fromPrecision(price, scale);
    }

    public virtual object safeGetDynamic(object settings)
    {
        object orderFee = this.safeValue(settings, "orderFee");
        if (isTrue(inOp(orderFee, "dynamic")))
        {
            return this.safeValue(orderFee, "dynamic");
        } else
        {
            return this.safeValue(getValue(getValue(orderFee, "composite"), "default"), "dynamic");
        }
    }

    public virtual object safeGetRates(object dynamic)
    {
        object rates = this.safeValue(dynamic, "rates");
        if (isTrue(isEqual(rates, null)))
        {
            return new Dictionary<string, object>() {
                { "WAVES", 1 },
            };
        }
        return rates;
    }

    public async override Task<object> createOrder(object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        /**
        * @method
        * @name wavesexchange#createOrder
        * @description create a trade order
        * @param {string} symbol unified symbol of the market to create an order in
        * @param {string} type 'market' or 'limit'
        * @param {string} side 'buy' or 'sell'
        * @param {float} amount how much of currency you want to trade in units of base currency
        * @param {float} [price] the price at which the order is to be fullfilled, in units of the quote currency, ignored in market orders
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {float} [params.stopPrice] The price at which a stop order is triggered at
        * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        this.checkRequiredDependencies();
        this.checkRequiredKeys();
        await this.loadMarkets();
        object market = this.market(symbol);
        object matcherPublicKey = await this.getMatcherPublicKey();
        object amountAsset = this.getAssetId(getValue(market, "baseId"));
        object priceAsset = this.getAssetId(getValue(market, "quoteId"));
        object isMarketOrder = (isEqual(type, "market"));
        object stopPrice = this.safeFloat2(parameters, "triggerPrice", "stopPrice");
        object isStopOrder = (!isEqual(stopPrice, null));
        if (isTrue(isTrue((isMarketOrder)) && isTrue((isEqual(price, null)))))
        {
            throw new InvalidOrder ((string)add(add(add(this.id, " createOrder() requires a price argument for "), type), " orders to determine the max price for buy and the min price for sell")) ;
        }
        object timestamp = this.milliseconds();
        object defaultExpiryDelta = this.safeInteger(this.options, "createOrderDefaultExpiry", 2419200000);
        object expiration = this.sum(timestamp, defaultExpiryDelta);
        object matcherFees = await this.getFeesForAsset(symbol, side, amount, price);
        // {
        //     "base":{
        //        "feeAssetId":"WAVES", // varies depending on the trading pair
        //        "matcherFee":"1000000"
        //     },
        //     "discount":{
        //        "feeAssetId":"EMAMLxDnv3xiz8RXg8Btj33jcEw3wLczL3JKYYmuubpc",
        //        "matcherFee":"4077612"
        //     }
        //  }
        object bs = this.safeValue2(matcherFees, "base", "discount");
        object baseFeeAssetId = this.safeString(bs, "feeAssetId");
        object baseFeeAsset = this.safeCurrencyCode(baseFeeAssetId);
        object baseMatcherFee = this.safeString(bs, "matcherFee");
        object discount = this.safeValue(matcherFees, "discount");
        object discountFeeAssetId = this.safeString(discount, "feeAssetId");
        object discountFeeAsset = this.safeCurrencyCode(discountFeeAssetId);
        object discountMatcherFee = this.safeString(discount, "matcherFee");
        object matcherFeeAssetId = null;
        object matcherFee = null;
        // check first if user supplied asset fee is valid
        if (isTrue(isTrue((inOp(parameters, "feeAsset"))) || isTrue((inOp(this.options, "feeAsset")))))
        {
            object feeAsset = this.safeString(parameters, "feeAsset", this.safeString(this.options, "feeAsset"));
            object feeCurrency = this.currency(feeAsset);
            matcherFeeAssetId = this.safeString(feeCurrency, "id");
        }
        object balances = await this.fetchBalance();
        if (isTrue(!isEqual(matcherFeeAssetId, null)))
        {
            if (isTrue(isTrue(!isEqual(baseFeeAssetId, matcherFeeAssetId)) && isTrue(!isEqual(discountFeeAssetId, matcherFeeAssetId))))
            {
                throw new InvalidOrder ((string)add(add(add(add(this.id, " asset fee must be "), baseFeeAsset), " or "), discountFeeAsset)) ;
            }
            object matcherFeeAsset = this.safeCurrencyCode(matcherFeeAssetId);
            object rawMatcherFee = ((bool) isTrue((isEqual(matcherFeeAssetId, baseFeeAssetId)))) ? baseMatcherFee : discountMatcherFee;
            object floatMatcherFee = parseFloat(this.currencyFromPrecision(matcherFeeAsset, rawMatcherFee));
            if (isTrue(isTrue((inOp(balances, matcherFeeAsset))) && isTrue((isGreaterThanOrEqual(((object)getValue(getValue(balances, matcherFeeAsset), "free")), floatMatcherFee)))))
            {
                matcherFee = parseInt(rawMatcherFee);
            } else
            {
                throw new InsufficientFunds ((string)add(this.id, " not enough funds of the selected asset fee")) ;
            }
        }
        if (isTrue(isEqual(matcherFeeAssetId, null)))
        {
            // try to the pay the fee using the base first then discount asset
            object floatBaseMatcherFee = parseFloat(this.currencyFromPrecision(baseFeeAsset, baseMatcherFee));
            if (isTrue(isTrue((inOp(balances, baseFeeAsset))) && isTrue((isGreaterThanOrEqual(((object)getValue(getValue(balances, baseFeeAsset), "free")), floatBaseMatcherFee)))))
            {
                matcherFeeAssetId = baseFeeAssetId;
                matcherFee = parseInt(baseMatcherFee);
            } else
            {
                object floatDiscountMatcherFee = parseFloat(this.currencyFromPrecision(discountFeeAsset, discountMatcherFee));
                if (isTrue(isTrue((inOp(balances, discountFeeAsset))) && isTrue((isGreaterThanOrEqual(((object)getValue(getValue(balances, discountFeeAsset), "free")), floatDiscountMatcherFee)))))
                {
                    matcherFeeAssetId = discountFeeAssetId;
                    matcherFee = parseInt(discountMatcherFee);
                }
            }
        }
        if (isTrue(isEqual(matcherFeeAssetId, null)))
        {
            throw new InsufficientFunds ((string)add(this.id, " not enough funds on none of the eligible asset fees")) ;
        }
        amount = this.customAmountToPrecision(symbol, amount);
        price = this.customPriceToPrecision(symbol, price);
        object assetPair = new Dictionary<string, object>() {
            { "amountAsset", amountAsset },
            { "priceAsset", priceAsset },
        };
        object sandboxMode = this.safeBool(this.options, "sandboxMode", false);
        object chainId = ((bool) isTrue((sandboxMode))) ? 84 : 87;
        object body = new Dictionary<string, object>() {
            { "senderPublicKey", this.apiKey },
            { "matcherPublicKey", matcherPublicKey },
            { "assetPair", assetPair },
            { "orderType", side },
            { "price", price },
            { "amount", amount },
            { "timestamp", timestamp },
            { "expiration", expiration },
            { "matcherFee", parseInt(matcherFee) },
            { "priceMode", "assetDecimals" },
            { "version", 4 },
            { "chainId", chainId },
        };
        if (isTrue(isStopOrder))
        {
            //
            // {
            //     "v": 1, // version (int)
            //     "c": { // condition (object)
            //         "t": "sp", // condition type. for now only "stop-price" (string)
            //         "v": { // value (object)
            //             "p": "123", // price (long)
            //         },
            //     },
            // }
            //
            object attachment = new Dictionary<string, object>() {
                { "v", 1 },
                { "c", new Dictionary<string, object>() {
                    { "t", "sp" },
                    { "v", new Dictionary<string, object>() {
                        { "p", this.customPriceToPrecision(symbol, stopPrice) },
                    } },
                } },
            };
            ((IDictionary<string,object>)body)["attachment"] = this.binaryToBase58(this.encode(json(attachment)));
        }
        if (isTrue(!isEqual(matcherFeeAssetId, "WAVES")))
        {
            ((IDictionary<string,object>)body)["matcherFeeAssetId"] = matcherFeeAssetId;
        }
        object serializedOrder = await this.matcherPostMatcherOrdersSerialize(body);
        if (isTrue(isTrue((isEqual(getValue(serializedOrder, 0), "\""))) && isTrue((isEqual(getValue(serializedOrder, (subtract(getArrayLength(serializedOrder), 1))), "\"")))))
        {
            serializedOrder = slice(serializedOrder, 1, subtract(getArrayLength(serializedOrder), 1));
        }
        object signature = this.axolotl(this.binaryToBase16(this.base58ToBinary(serializedOrder)), this.binaryToBase16(this.base58ToBinary(this.secret)), ed25519);
        ((IDictionary<string,object>)body)["signature"] = signature;
        //
        //     {
        //         "success": true,
        //         "message": {
        //           "version": 4,
        //           "id": "8VR49dLZFaYcVwzx9TqVMTAZCSUoyB74kLUHrEPCSJgN",
        //           "sender": "3MpEdBXtsRHRj2TvZURSb8uLDxzneVbYczW",
        //           "senderPublicKey": "8aUTNqHGCBiubySBRhcS1N6NC5jLczhVcndRfMAuwtkY",
        //           "matcherPublicKey": "8QUAqtTckM5B8gvcuP7mMswat9SjKUuafJMusEoSn1Gy",
        //           "assetPair": {
        //             "amountAsset": "EMAMLxDnv3xiz8RXg8Btj33jcEw3wLczL3JKYYmuubpc",
        //             "priceAsset": "25FEqEjRkqK6yCkiT7Lz6SAYz7gUFCtxfCChnrVFD5AT"
        //           },
        //           "orderType": "sell",
        //           "amount": 100000,
        //           "price": 480000,
        //           "timestamp": 1690852043772,
        //           "expiration": 1693271243772,
        //           "matcherFee": 83327570,
        //           "signature": "3QYDWQVSP4kdqpTLodCuboh8bpWd6GW5s1pQyKdce1JBDwX6t4kH5Xtuq35pqo94gxjo3cfG6k6Xuic2JaYLubkK",
        //           "proofs": [
        //             "3QYDWQVSP4kdqpTLodCuboh8bpWd6GW5s1pQyKdce1JBDwX6t4kH5Xtuq35pqo94gxjo3cfG6k6Xuic2JaYLubkK"
        //           ],
        //           "matcherFeeAssetId": "EMAMLxDnv3xiz8RXg8Btj33jcEw3wLczL3JKYYmuubpc",
        //           "eip712Signature": null,
        //           "priceMode": "assetDecimals",
        //           "attachment": "2PQ4akZHnMSZrQissuu5uudoXbgsipeDnFcRtXtjVgkdm1gUWEgGzp"
        //         },
        //         "status": "OrderAccepted"
        //     }
        //
        if (isTrue(isMarketOrder))
        {
            object response = await this.matcherPostMatcherOrderbookMarket(body);
            object value = this.safeDict(response, "message");
            return this.parseOrder(value, market);
        } else
        {
            object response = await this.matcherPostMatcherOrderbook(body);
            object value = this.safeDict(response, "message");
            return this.parseOrder(value, market);
        }
    }

    public async override Task<object> cancelOrder(object id, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name wavesexchange#cancelOrder
        * @description cancels an open order
        * @param {string} id order id
        * @param {string} symbol unified symbol of the market the order was made in
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        this.checkRequiredDependencies();
        this.checkRequiredKeys();
        await this.signIn();
        object wavesAddress = await this.getWavesAddress();
        object response = await this.forwardPostMatcherOrdersWavesAddressCancel(new Dictionary<string, object>() {
            { "wavesAddress", wavesAddress },
            { "orderId", id },
        });
        //  {
        //    "success":true,
        //    "message":[[{"orderId":"EBpJeGM36KKFz5gTJAUKDBm89V8wqxKipSFBdU35AN3c","success":true,"status":"OrderCanceled"}]],
        //    "status":"BatchCancelCompleted"
        //  }
        object message = this.safeValue(response, "message");
        object firstMessage = this.safeValue(message, 0);
        object firstOrder = this.safeValue(firstMessage, 0);
        object returnedId = this.safeString(firstOrder, "orderId");
        return new Dictionary<string, object>() {
            { "info", response },
            { "id", returnedId },
            { "clientOrderId", null },
            { "timestamp", null },
            { "datetime", null },
            { "lastTradeTimestamp", null },
            { "symbol", symbol },
            { "type", null },
            { "side", null },
            { "price", null },
            { "amount", null },
            { "cost", null },
            { "average", null },
            { "filled", null },
            { "remaining", null },
            { "status", null },
            { "fee", null },
            { "trades", null },
        };
    }

    public async override Task<object> fetchOrder(object id, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name wavesexchange#fetchOrder
        * @description fetches information on an order made by the user
        * @param {string} symbol unified symbol of the market the order was made in
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        this.checkRequiredDependencies();
        this.checkRequiredKeys();
        await this.loadMarkets();
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
        }
        object timestamp = this.milliseconds();
        object byteArray = new List<object> {this.base58ToBinary(this.apiKey), this.numberToBE(timestamp, 8)};
        object binary = this.binaryConcatArray(byteArray);
        object hexSecret = this.binaryToBase16(this.base58ToBinary(this.secret));
        object signature = this.axolotl(this.binaryToBase16(binary), hexSecret, ed25519);
        object request = new Dictionary<string, object>() {
            { "Timestamp", ((object)timestamp).ToString() },
            { "Signature", signature },
            { "publicKey", this.apiKey },
            { "orderId", id },
        };
        object response = await this.matcherGetMatcherOrderbookPublicKeyOrderId(this.extend(request, parameters));
        return this.parseOrder(response, market);
    }

    public async override Task<object> fetchOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name wavesexchange#fetchOrders
        * @description fetches information on multiple orders made by the user
        * @param {string} symbol unified market symbol of the market orders were made in
        * @param {int} [since] the earliest time in ms to fetch orders for
        * @param {int} [limit] the maximum number of order structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        this.checkRequiredDependencies();
        this.checkRequiredKeys();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchOrders() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object timestamp = this.milliseconds();
        object byteArray = new List<object> {this.base58ToBinary(this.apiKey), this.numberToBE(timestamp, 8)};
        object binary = this.binaryConcatArray(byteArray);
        object hexSecret = this.binaryToBase16(this.base58ToBinary(this.secret));
        object signature = this.axolotl(this.binaryToBase16(binary), hexSecret, ed25519);
        object request = new Dictionary<string, object>() {
            { "Accept", "application/json" },
            { "Timestamp", ((object)timestamp).ToString() },
            { "Signature", signature },
            { "publicKey", this.apiKey },
            { "baseId", getValue(market, "baseId") },
            { "quoteId", getValue(market, "quoteId") },
        };
        object response = await this.matcherGetMatcherOrderbookBaseIdQuoteIdPublicKeyPublicKey(this.extend(request, parameters));
        // [ { id: "3KicDeWayY2mdrRoYdCkP3gUAoUZUNT1AA6GAtWuPLfa",
        //     "type": "sell",
        //     "orderType": "limit",
        //     "amount": 1,
        //     "fee": 300000,
        //     "price": 100000000,
        //     "timestamp": 1591651254076,
        //     "filled": 0,
        //     "filledFee": 0,
        //     "feeAsset": "WAVES",
        //     "status": "Accepted",
        //     "assetPair":
        //      { amountAsset: null,
        //        "priceAsset": "8LQW8f7P5d5PZM7GtZEBgaqRPGSzS3DfPuiXrURJ4AJS" },
        //     "avgWeighedPrice": 0 }, ... ]
        return this.parseOrders(response, market, since, limit);
    }

    public async override Task<object> fetchOpenOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name wavesexchange#fetchOpenOrders
        * @description fetch all unfilled currently open orders
        * @param {string} symbol unified market symbol
        * @param {int} [since] the earliest time in ms to fetch open orders for
        * @param {int} [limit] the maximum number of  open orders structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        await this.signIn();
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
        }
        object address = await this.getWavesAddress();
        object request = new Dictionary<string, object>() {
            { "address", address },
            { "activeOnly", true },
        };
        object response = await this.forwardGetMatcherOrdersAddress(request);
        return this.parseOrders(response, market, since, limit);
    }

    public async override Task<object> fetchClosedOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name wavesexchange#fetchClosedOrders
        * @description fetches information on multiple closed orders made by the user
        * @param {string} symbol unified market symbol of the market orders were made in
        * @param {int} [since] the earliest time in ms to fetch orders for
        * @param {int} [limit] the maximum number of order structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        await this.signIn();
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
        }
        object address = await this.getWavesAddress();
        object request = new Dictionary<string, object>() {
            { "address", address },
            { "closedOnly", true },
        };
        object response = await this.forwardGetMatcherOrdersAddress(request);
        // [
        //   {
        //     "id": "9aXcxvXai73jbAm7tQNnqaQ2PwUjdmWuyjvRTKAHsw4f",
        //     "type": "buy",
        //     "orderType": "limit",
        //     "amount": 23738330,
        //     "fee": 300000,
        //     "price": 3828348334,
        //     "timestamp": 1591926905636,
        //     "filled": 23738330,
        //     "filledFee": 300000,
        //     "feeAsset": "WAVES",
        //     "status": "Filled",
        //     "assetPair": {
        //       "amountAsset": "HZk1mbfuJpmxU1Fs4AX5MWLVYtctsNcg6e2C6VKqK8zk",
        //       "priceAsset": null
        //     },
        //     "avgWeighedPrice": 3828348334
        //   }, ...
        // ]
        return this.parseOrders(response, market, since, limit);
    }

    public virtual object parseOrderStatus(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "Cancelled", "canceled" },
            { "Accepted", "open" },
            { "Filled", "closed" },
            { "PartiallyFilled", "open" },
        };
        return this.safeString(statuses, status, status);
    }

    public virtual object getSymbolFromAssetPair(object assetPair)
    {
        // a blank string or null can indicate WAVES
        object baseId = this.safeString(assetPair, "amountAsset", "WAVES");
        object quoteId = this.safeString(assetPair, "priceAsset", "WAVES");
        return add(add(this.safeCurrencyCode(baseId), "/"), this.safeCurrencyCode(quoteId));
    }

    public override object parseOrder(object order, object market = null)
    {
        //
        // createOrder
        //
        //     {
        //         "version": 4,
        //         "id": "BshyeHXDfJmTnjTdBYt371jD4yWaT3JTP6KpjpsiZepS",
        //         "sender": "3P8VzLSa23EW5CVckHbV7d5BoN75fF1hhFH",
        //         "senderPublicKey": "AHXn8nBA4SfLQF7hLQiSn16kxyehjizBGW1TdrmSZ1gF",
        //         "matcherPublicKey": "9cpfKN9suPNvfeUNphzxXMjcnn974eme8ZhWUjaktzU5",
        //         "assetPair": {
        //             "amountAsset": "474jTeYx2r2Va35794tCScAXWJG9hU2HcgxzMowaZUnu",
        //             "priceAsset": "DG2xFkPdDwKUoBkzGAhQtLpSGzfXLiCYPEzeKH2Ad24p",
        //         },
        //         "orderType": "buy",
        //         "amount": 10000,
        //         "price": 400000000,
        //         "timestamp": 1599848586891,
        //         "expiration": 1602267786891,
        //         "matcherFee": 3008,
        //         "matcherFeeAssetId": "474jTeYx2r2Va35794tCScAXWJG9hU2HcgxzMowaZUnu",
        //         "signature": "3D2h8ubrhuWkXbVn4qJ3dvjmZQxLoRNfjTqb9uNpnLxUuwm4fGW2qGH6yKFe2SQPrcbgkS3bDVe7SNtMuatEJ7qy",
        //         "proofs": [
        //             "3D2h8ubrhuWkXbVn4qJ3dvjmZQxLoRNfjTqb9uNpnLxUuwm4fGW2qGH6yKFe2SQPrcbgkS3bDVe7SNtMuatEJ7qy",
        //         ],
        //         "attachment":"77rnoyFX5BDr15hqZiUtgXKSN46zsbHHQjVNrTMLZcLz62mmFKr39FJ"
        //     }
        //
        //
        // fetchOrder, fetchOrders, fetchOpenOrders, fetchClosedOrders
        //
        //     {
        //         "id": "81D9uKk2NfmZzfG7uaJsDtxqWFbJXZmjYvrL88h15fk8",
        //         "type": "buy",
        //         "orderType": "limit",
        //         "amount": 30000000000,
        //         "filled": 0,
        //         "price": 1000000,
        //         "fee": 300000,
        //         "filledFee": 0,
        //         "feeAsset": "WAVES",
        //         "timestamp": 1594303779322,
        //         "status": "Cancelled",
        //         "assetPair": {
        //             "amountAsset": "474jTeYx2r2Va35794tCScAXWJG9hU2HcgxzMowaZUnu",
        //             "priceAsset": "WAVES"
        //         },
        //         "avgWeighedPrice": 0,
        //         "version": 4,
        //         "totalExecutedPriceAssets": 0,  // in fetchOpenOrder/s
        //         "attachment":"77rnoyFX5BDr15hqZiUtgXKSN46zsbHHQjVNrTMLZcLz62mmFKr39FJ"
        //     }
        //
        object timestamp = this.safeInteger(order, "timestamp");
        object side = this.safeString2(order, "type", "orderType");
        object type = "limit";
        if (isTrue(inOp(order, "type")))
        {
            // fetchOrders
            type = this.safeString(order, "orderType", type);
        }
        object id = this.safeString(order, "id");
        object filledString = this.safeString(order, "filled");
        object priceString = this.safeString(order, "price");
        object amountString = this.safeString(order, "amount");
        object assetPair = this.safeValue(order, "assetPair");
        object symbol = null;
        if (isTrue(!isEqual(assetPair, null)))
        {
            symbol = this.getSymbolFromAssetPair(assetPair);
        } else if (isTrue(!isEqual(market, null)))
        {
            symbol = getValue(market, "symbol");
        }
        object amountCurrency = this.safeCurrencyCode(this.safeString(assetPair, "amountAsset", "WAVES"));
        object price = this.priceFromPrecision(symbol, priceString);
        object amount = this.currencyFromPrecision(amountCurrency, amountString);
        object filled = this.currencyFromPrecision(amountCurrency, filledString);
        object average = this.priceFromPrecision(symbol, this.safeString(order, "avgWeighedPrice"));
        object status = this.parseOrderStatus(this.safeString(order, "status"));
        object fee = null;
        if (isTrue(inOp(order, "type")))
        {
            object currency = this.safeCurrencyCode(this.safeString(order, "feeAsset"));
            fee = new Dictionary<string, object>() {
                { "currency", currency },
                { "fee", this.parseNumber(this.currencyFromPrecision(currency, this.safeString(order, "filledFee"))) },
            };
        } else
        {
            object currency = this.safeCurrencyCode(this.safeString(order, "matcherFeeAssetId", "WAVES"));
            fee = new Dictionary<string, object>() {
                { "currency", currency },
                { "fee", this.parseNumber(this.currencyFromPrecision(currency, this.safeString(order, "matcherFee"))) },
            };
        }
        object triggerPrice = null;
        object attachment = this.safeString(order, "attachment");
        if (isTrue(!isEqual(attachment, null)))
        {
            object decodedAttachment = this.parseJson(this.decode(this.base58ToBinary(attachment)));
            if (isTrue(!isEqual(decodedAttachment, null)))
            {
                object c = this.safeValue(decodedAttachment, "c");
                if (isTrue(!isEqual(c, null)))
                {
                    object v = this.safeValue(c, "v");
                    if (isTrue(!isEqual(v, null)))
                    {
                        triggerPrice = this.safeString(v, "p");
                    }
                }
            }
        }
        return this.safeOrder(new Dictionary<string, object>() {
            { "info", order },
            { "id", id },
            { "clientOrderId", null },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "lastTradeTimestamp", null },
            { "symbol", symbol },
            { "type", type },
            { "timeInForce", null },
            { "postOnly", null },
            { "side", side },
            { "price", price },
            { "stopPrice", triggerPrice },
            { "triggerPrice", triggerPrice },
            { "amount", amount },
            { "cost", null },
            { "average", average },
            { "filled", filled },
            { "remaining", null },
            { "status", status },
            { "fee", fee },
            { "trades", null },
        }, market);
    }

    public async virtual Task<object> getWavesAddress()
    {
        object cachedAddreess = this.safeString(this.options, "wavesAddress");
        if (isTrue(isEqual(cachedAddreess, null)))
        {
            object request = new Dictionary<string, object>() {
                { "publicKey", this.apiKey },
            };
            object response = await this.nodeGetAddressesPublicKeyPublicKey(request);
            ((IDictionary<string,object>)this.options)["wavesAddress"] = this.safeString(response, "address");
            return getValue(this.options, "wavesAddress");
        } else
        {
            return cachedAddreess;
        }
    }

    public async override Task<object> fetchBalance(object parameters = null)
    {
        /**
        * @method
        * @name wavesexchange#fetchBalance
        * @description query for balance and get the amount of funds available for trading or funds locked in orders
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
        */
        // makes a lot of different requests to get all the data
        // in particular:
        // fetchMarkets, getWavesAddress,
        // getTotalBalance (doesn't include waves), getReservedBalance (doesn't include waves)
        // getReservedBalance (includes WAVES)
        // I couldn't find another way to get all the data
        parameters ??= new Dictionary<string, object>();
        this.checkRequiredDependencies();
        this.checkRequiredKeys();
        await this.loadMarkets();
        object wavesAddress = await this.getWavesAddress();
        object request = new Dictionary<string, object>() {
            { "address", wavesAddress },
        };
        object totalBalance = await this.nodeGetAssetsBalanceAddress(request);
        // {
        //   "address": "3P8VzLSa23EW5CVckHbV7d5BoN75fF1hhFH",
        //   "balances": [
        //     {
        //       "assetId": "DG2xFkPdDwKUoBkzGAhQtLpSGzfXLiCYPEzeKH2Ad24p",
        //       "balance": 1177200,
        //       "reissuable": false,
        //       "minSponsoredAssetFee": 7420,
        //       "sponsorBalance": 47492147189709,
        //       "quantity": 999999999775381400,
        //       "issueTransaction": {
        //         "senderPublicKey": "BRnVwSVctnV8pge5vRpsJdWnkjWEJspFb6QvrmZvu3Ht",
        //         "quantity": 1000000000000000000,
        //         "fee": 100400000,
        //         "description": "Neutrino USD",
        //         "type": 3,
        //         "version": 2,
        //         "reissuable": false,
        //         "script": null,
        //         "sender": "3PC9BfRwJWWiw9AREE2B3eWzCks3CYtg4yo",
        //         "feeAssetId": null,
        //         "chainId": 87,
        //         "proofs": [
        //           "3HNpbVkgP69NWSeb9hGYauiQDaXrRXh3tXFzNsGwsAAXnFrA29SYGbLtziW9JLpXEq7qW1uytv5Fnm5XTUMB2BxU"
        //         ],
        //         "assetId": "DG2xFkPdDwKUoBkzGAhQtLpSGzfXLiCYPEzeKH2Ad24p",
        //         "decimals": 6,
        //         "name": "USD-N",
        //         "id": "DG2xFkPdDwKUoBkzGAhQtLpSGzfXLiCYPEzeKH2Ad24p",
        //         "timestamp": 1574429393962
        //       }
        //     }
        //   ]
        // }
        object balances = this.safeValue(totalBalance, "balances", new List<object>() {});
        object result = new Dictionary<string, object>() {};
        object timestamp = null;
        object assetIds = new List<object>() {};
        object nonStandardBalances = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(balances)); postFixIncrement(ref i))
        {
            object entry = getValue(balances, i);
            object entryTimestamp = this.safeInteger(entry, "timestamp");
            timestamp = ((bool) isTrue((isEqual(timestamp, null)))) ? entryTimestamp : mathMax(timestamp, entryTimestamp);
            object issueTransaction = this.safeValue(entry, "issueTransaction");
            object currencyId = this.safeString(entry, "assetId");
            object balance = this.safeString(entry, "balance");
            if (isTrue(isEqual(issueTransaction, null)))
            {
                ((IList<object>)assetIds).Add(currencyId);
                ((IList<object>)nonStandardBalances).Add(balance);
                continue;
            }
            object decimals = this.safeInteger(issueTransaction, "decimals");
            object code = null;
            if (isTrue(inOp(this.currencies_by_id, currencyId)))
            {
                code = this.safeCurrencyCode(currencyId);
                ((IDictionary<string,object>)result)[(string)code] = this.account();
                ((IDictionary<string,object>)getValue(result, code))["total"] = this.fromPrecision(balance, decimals);
            }
        }
        object nonStandardAssets = getArrayLength(assetIds);
        if (isTrue(nonStandardAssets))
        {
            object requestInner = new Dictionary<string, object>() {
                { "ids", assetIds },
            };
            object response = await this.publicGetAssets(requestInner);
            object data = this.safeValue(response, "data", new List<object>() {});
            for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
            {
                object entry = getValue(data, i);
                object balance = getValue(nonStandardBalances, i);
                object inner = this.safeValue(entry, "data");
                object decimals = this.safeInteger(inner, "precision");
                object ticker = this.safeString(inner, "ticker");
                object code = this.safeCurrencyCode(ticker);
                ((IDictionary<string,object>)result)[(string)code] = this.account();
                ((IDictionary<string,object>)getValue(result, code))["total"] = this.fromPrecision(balance, decimals);
            }
        }
        object currentTimestamp = this.milliseconds();
        object byteArray = new List<object> {this.base58ToBinary(this.apiKey), this.numberToBE(currentTimestamp, 8)};
        object binary = this.binaryConcatArray(byteArray);
        object hexSecret = this.binaryToBase16(this.base58ToBinary(this.secret));
        object signature = this.axolotl(this.binaryToBase16(binary), hexSecret, ed25519);
        object matcherRequest = new Dictionary<string, object>() {
            { "publicKey", this.apiKey },
            { "signature", signature },
            { "timestamp", ((object)currentTimestamp).ToString() },
        };
        object reservedBalance = await this.matcherGetMatcherBalanceReservedPublicKey(matcherRequest);
        // { WAVES: 200300000 }
        object reservedKeys = new List<object>(((IDictionary<string,object>)reservedBalance).Keys);
        for (object i = 0; isLessThan(i, getArrayLength(reservedKeys)); postFixIncrement(ref i))
        {
            object currencyId = getValue(reservedKeys, i);
            object code = this.safeCurrencyCode(currencyId);
            if (!isTrue((inOp(result, code))))
            {
                ((IDictionary<string,object>)result)[(string)code] = this.account();
            }
            object amount = this.safeString(reservedBalance, currencyId);
            if (isTrue(inOp(this.currencies, code)))
            {
                ((IDictionary<string,object>)getValue(result, code))["used"] = this.currencyFromPrecision(code, amount);
            } else
            {
                ((IDictionary<string,object>)getValue(result, code))["used"] = amount;
            }
        }
        object wavesRequest = new Dictionary<string, object>() {
            { "address", wavesAddress },
        };
        object wavesTotal = await this.nodeGetAddressesBalanceAddress(wavesRequest);
        // {
        //   "address": "3P8VzLSa23EW5CVckHbV7d5BoN75fF1hhFH",
        //   "confirmations": 0,
        //   "balance": 909085978
        // }
        ((IDictionary<string,object>)result)["WAVES"] = this.safeValue(result, "WAVES", new Dictionary<string, object>() {});
        ((IDictionary<string,object>)getValue(result, "WAVES"))["total"] = this.currencyFromPrecision("WAVES", this.safeString(wavesTotal, "balance"));
        object codes = new List<object>(((IDictionary<string,object>)result).Keys);
        for (object i = 0; isLessThan(i, getArrayLength(codes)); postFixIncrement(ref i))
        {
            object code = getValue(codes, i);
            if (isTrue(isEqual(this.safeValue(getValue(result, code), "used"), null)))
            {
                ((IDictionary<string,object>)getValue(result, code))["used"] = "0";
            }
        }
        ((IDictionary<string,object>)result)["timestamp"] = timestamp;
        ((IDictionary<string,object>)result)["datetime"] = this.iso8601(timestamp);
        return this.safeBalance(result);
    }

    public async override Task<object> fetchMyTrades(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name wavesexchange#fetchMyTrades
        * @description fetch all trades made by the user
        * @param {string} symbol unified market symbol
        * @param {int} [since] the earliest time in ms to fetch trades for
        * @param {int} [limit] the maximum number of trades structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object address = await this.getWavesAddress();
        object request = new Dictionary<string, object>() {
            { "sender", address },
        };
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            ((IDictionary<string,object>)request)["amountAsset"] = getValue(market, "baseId");
            ((IDictionary<string,object>)request)["priceAsset"] = getValue(market, "quoteId");
        }
        object response = await this.publicGetTransactionsExchange(request);
        object data = this.safeValue(response, "data");
        //
        //      {
        //          "__type":"list",
        //          "isLastPage":true,
        //          "lastCursor":"MzA2MjQ0MzAwMDI5OjpkZXNj",
        //          "data": [
        //              {
        //                  "__type":"transaction",
        //                  "data": {
        //                      "id":"GbjPqco2wRP5QSrY5LimFrUyJaM535K9nhK5zaQ7J7Tx",
        //                      "timestamp":"2022-04-06T19:56:31.479Z",
        //                      "height":3062443,
        //                      "type":7,
        //                      "version":2,
        //                      "proofs":[
        //                          "57mYrANw61eiArCTv2eYwzXm71jYC2KpZ5AeM9zHEstuRaYSAWSuSE7njAJYJu8zap6DMCm3nzqc6es3wQFDpRCN"
        //                      ],
        //                      "fee":0.003,
        //                      "applicationStatus":"succeeded",
        //                      "sender":"3PEjHv3JGjcWNpYEEkif2w8NXV4kbhnoGgu",
        //                      "senderPublicKey":"9cpfKN9suPNvfeUNphzxXMjcnn974eme8ZhWUjaktzU5",
        //                      "buyMatcherFee":0,
        //                      "sellMatcherFee":0.00141728,
        //                      "price":215.7431,
        //                      "amount":0.09,
        //                      "order1": {
        //                          "id":"49qiuQj5frdZ6zpTCEpMuKPMAh1EimwXpXWB4BeCw33h",
        //                          "senderPublicKey":"CjUfoH3dsDZsf5UuAjqqzpWHXgvKzBZpVG9YixF7L48K",
        //                          "matcherPublicKey":"9cpfKN9suPNvfeUNphzxXMjcnn974eme8ZhWUjaktzU5",
        //                          "assetPair": {
        //                              "amountAsset":"7TMu26hAs7B2oW6c5sfx45KSZT7GQA3TZNYuCav8Dcqt",
        //                              "priceAsset":"DG2xFkPdDwKUoBkzGAhQtLpSGzfXLiCYPEzeKH2Ad24p"
        //                          },
        //                          "orderType":"buy",
        //                          "price":215.7431,
        //                          "sender":"3PR9WmaHV5ueVw2Wr9xsiCG3t4ySXzkkGLy",
        //                          "amount":0.36265477,
        //                          "timestamp":"2022-04-06T19:55:06.832Z",
        //                          "expiration":"2022-05-05T19:55:06.832Z",
        //                          "matcherFee":3.000334,
        //                          "signature":"2rBWhdeuRJNpQfXfTFtcR8x8Lpic8FUHPdLML9uxABRUuxe48YRJcZxbncwWAh9LWFCEUZiztv7RZBZfGMWfFxTs",
        //                          "matcherFeeAssetId":"DG2xFkPdDwKUoBkzGAhQtLpSGzfXLiCYPEzeKH2Ad24p"
        //                      },
        //                      "order2": {
        //                          "id":"AkxiJqCuv6wm8K41TUSgFNwShZMnCbMDT78MqrcWpQ53",
        //                          "senderPublicKey":"72o7qNKyne5hthB1Ww6famE7uHrk5vTVB2ZfUMBEqL3Y",
        //                          "matcherPublicKey":"9cpfKN9suPNvfeUNphzxXMjcnn974eme8ZhWUjaktzU5",
        //                          "assetPair": {
        //                              "amountAsset":"7TMu26hAs7B2oW6c5sfx45KSZT7GQA3TZNYuCav8Dcqt",
        //                              "priceAsset":"DG2xFkPdDwKUoBkzGAhQtLpSGzfXLiCYPEzeKH2Ad24p"
        //                          },
        //                          "orderType":"sell",
        //                          "price":210,
        //                          "sender":"3P3CzbjGgiqEyUBeKZYfgZtyaZfMG8fjoUD",
        //                          "amount":0.09,
        //                          "timestamp":"2022-04-06T19:56:18.535Z",
        //                          "expiration":"2022-05-04T19:56:18.535Z",
        //                          "matcherFee":0.00141728,
        //                          "signature":"5BZCjYn6QzVkMXBFDBnzcAUBdCZqhq9hQfRXFHfLUQCsbis4zeriw4sUqLa1BZRT2isC6iY4Z4HtekikPqZ461PT",
        //                          "matcherFeeAssetId":"7TMu26hAs7B2oW6c5sfx45KSZT7GQA3TZNYuCav8Dcqt"
        //                      }
        //                  }
        //              },...
        //          ]
        //      }
        //
        return this.parseTrades(data, market, since, limit);
    }

    public async override Task<object> fetchTrades(object symbol, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name wavesexchange#fetchTrades
        * @description get the list of most recent trades for a particular symbol
        * @param {string} symbol unified symbol of the market to fetch trades for
        * @param {int} [since] timestamp in ms of the earliest trade to fetch
        * @param {int} [limit] the maximum amount of trades to fetch
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "amountAsset", getValue(market, "baseId") },
            { "priceAsset", getValue(market, "quoteId") },
        };
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = mathMin(limit, 100);
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["timeStart"] = since;
        }
        object response = await this.publicGetTransactionsExchange(request);
        object data = this.safeValue(response, "data");
        //
        //      {
        //          "__type":"list",
        //          "isLastPage":false,
        //          "lastCursor":"MzA2MjM2MTAwMDU0OjpkZXNj",
        //          "data": [
        //              {
        //                  "__type":"transaction",
        //                  "data": {
        //                      "id":"F42WsvSsyEzvpPLFjVhQKkSNuopooP4zMkjSUs47NeML",
        //                      "timestamp":"2022-04-06T18:39:49.145Z",
        //                      "height":3062361,
        //                      "type":7,
        //                      "version":2,
        //                      "proofs": [
        //                          "39iJv82kFi4pyuBxYeZpP45NXXjbrCXdVsHPAAvj32UMLmTXLjMTfV43PcmZDSAuS93HKSDo1aKJrin8UvkeE9Bs"
        //                      ],
        //                      "fee":0.003,
        //                      "applicationStatus":"succeeded",
        //                      "sender":"3PEjHv3JGjcWNpYEEkif2w8NXV4kbhnoGgu",
        //                      "senderPublicKey":"9cpfKN9suPNvfeUNphzxXMjcnn974eme8ZhWUjaktzU5",
        //                      "buyMatcherFee":0.02314421,
        //                      "sellMatcherFee":0,
        //                      "price":217.3893,
        //                      "amount":0.34523025,
        //                      "order1": {
        //                          "id":"HkM36PHGaeeZdDKT1mYgZXhaU9PRZ54RZiJc2K4YMT3Q",
        //                          "senderPublicKey":"7wYCaDcc6GX1Jx2uS7QgLHBypBKvrezTS1HfiW6Xe4Bk",
        //                          "matcherPublicKey":"9cpfKN9suPNvfeUNphzxXMjcnn974eme8ZhWUjaktzU5",
        //                          "assetPair": {
        //                              "amountAsset":"7TMu26hAs7B2oW6c5sfx45KSZT7GQA3TZNYuCav8Dcqt",
        //                              "priceAsset":"DG2xFkPdDwKUoBkzGAhQtLpSGzfXLiCYPEzeKH2Ad24p"
        //                          },
        //                          "orderType":"buy",
        //                          "price":225.2693,
        //                          "sender":"3PLPc8f4DGYaF9C9bwJ2uVmHqRv3NCjg5VQ",
        //                          "amount":2.529,
        //                          "timestamp":"2022-04-06T18:39:48.796Z",
        //                          "expiration":"2022-05-05T18:39:48.796Z",
        //                          "matcherFee":0.17584444,
        //                          "signature":"2yQfJoomv86evQDw36fg1uiRkHvPDZtRp3qvxqTBWPvz4JLTHGQtEHJF5NGTvym6U93CtgNprngzmD9ecHBjxf6U",
        //                          "matcherFeeAssetId":"Atqv59EYzjFGuitKVnMRk6H8FukjoV3ktPorbEys25on"
        //                      },
        //                      "order2": {
        //                          "id":"F7HKmeuzwWdk3wKitHLnVx5MuD4wBWPpphQ8kUGx4tT9",
        //                          "senderPublicKey":"CjUfoH3dsDZsf5UuAjqqzpWHXgvKzBZpVG9YixF7L48K",
        //                          "matcherPublicKey":"9cpfKN9suPNvfeUNphzxXMjcnn974eme8ZhWUjaktzU5",
        //                          "assetPair": {
        //                              "amountAsset":"7TMu26hAs7B2oW6c5sfx45KSZT7GQA3TZNYuCav8Dcqt",
        //                              "priceAsset":"DG2xFkPdDwKUoBkzGAhQtLpSGzfXLiCYPEzeKH2Ad24p"
        //                          },
        //                          "orderType":"sell",
        //                          "price":217.3893,
        //                          "sender":"3PR9WmaHV5ueVw2Wr9xsiCG3t4ySXzkkGLy",
        //                          "amount":0.35767793,
        //                          "timestamp":"2022-04-06T18:32:01.390Z",
        //                          "expiration":"2022-05-05T18:32:01.390Z",
        //                          "matcherFee":0.0139168,
        //                          "signature":"34HgWVLPgeYWkiSvAc5ChVepGTYDQDug2dMTSincs6idEyoM7AtaZuH3mqQ5RJG2fcxxH2QSB723Qq3dgLQwQmKf",
        //                          "matcherFeeAssetId":"7TMu26hAs7B2oW6c5sfx45KSZT7GQA3TZNYuCav8Dcqt"
        //                      }
        //                  }
        //              }, ...
        //          ]
        //      }
        //
        return this.parseTrades(data, market, since, limit);
    }

    public override object parseTrade(object trade, object market = null)
    {
        //
        // { __type: "transaction",
        //   "data":
        //    { id: "HSdruioHqvYHeyn9hhyoHdRWPB2bFA8ujeCPZMK6992c",
        //      "timestamp": "2020-06-09T19:34:51.897Z",
        //      "height": 2099684,
        //      "type": 7,
        //      "version": 2,
        //      "proofs":
        //       [ "26teDHERQgwjjHqEn4REcDotNG8M21xjou3X42XuDuCvrRkQo6aPyrswByH3UrkWG8v27ZAaVNzoxDg4teNcLtde" ],
        //      "fee": 0.003,
        //      "sender": "3PEjHv3JGjcWNpYEEkif2w8NXV4kbhnoGgu",
        //      "senderPublicKey": "9cpfKN9suPNvfeUNphzxXMjcnn974eme8ZhWUjaktzU5",
        //      "buyMatcherFee": 0.00299999,
        //      "sellMatcherFee": 0.00299999,
        //      "price": 0.00012003,
        //      "amount": 60.80421562,
        //      "order1":
        //       { id: "CBRwP3ar4oMvvpUiGyfxc1syh41488SDi2GkrjuBDegv",
        //         "senderPublicKey": "DBXSHBz96NFsMu7xh4fi2eT9ZnyxefAHXsMxUayzgC6a",
        //         "matcherPublicKey": "9cpfKN9suPNvfeUNphzxXMjcnn974eme8ZhWUjaktzU5",
        //         "assetPair": [Object],
        //         "orderType": "buy",
        //         "price": 0.00012003,
        //         "sender": "3PJfFRgVuJ47UY4ckb74EGzEBzkHXtmG1LA",
        //         "amount": 60.80424773,
        //         "timestamp": "2020-06-09T19:34:51.885Z",
        //         "expiration": "2020-06-10T12:31:31.885Z",
        //         "matcherFee": 0.003,
        //         "signature": "4cA3ZAb3XAEEXaFG7caqpto5TRbpR5PkhZpxoNQZ9ZReNvjuJQs5a3THnumv7rcqmVUiVtuHAgk2f67ANcqtKyJ8",
        //         "matcherFeeAssetId": null },
        //      "order2":
        //       { id: "CHJSLQ6dfSPs6gu2mAegrMUcRiDEDqaj2GKfvptMjS3M",
        //         "senderPublicKey": "3RUC4NGFZm9H8VJhSSjJyFLdiE42qNiUagDcZPwjgDf8",
        //         "matcherPublicKey": "9cpfKN9suPNvfeUNphzxXMjcnn974eme8ZhWUjaktzU5",
        //         "assetPair": [Object],
        //         "orderType": "sell",
        //         "price": 0.00012003,
        //         "sender": "3P9vKoQpMZtaSkHKpNh977YY9ZPzTuntLAq",
        //         "amount": 60.80424773,
        //         "timestamp": "2020-06-09T19:34:51.887Z",
        //         "expiration": "2020-06-10T12:31:31.887Z",
        //         "matcherFee": 0.003,
        //         "signature": "3SFyrcqzou2ddZyNisnLYaGhLt5qRjKxH8Nw3s4T5U7CEKGX9DDo8dS27RgThPVGbYF1rYET1FwrWoQ2UFZ6SMTR",
        //         "matcherFeeAssetId": null } } }
        //
        object data = this.safeValue(trade, "data");
        object datetime = this.safeString(data, "timestamp");
        object timestamp = this.parse8601(datetime);
        object id = this.safeString(data, "id");
        object priceString = this.safeString(data, "price");
        object amountString = this.safeString(data, "amount");
        object order1 = this.safeValue(data, "order1");
        object order2 = this.safeValue(data, "order2");
        object order = null;
        // order2 arrived after order1
        if (isTrue(isEqual(this.safeString(order1, "senderPublicKey"), this.apiKey)))
        {
            order = order1;
        } else
        {
            order = order2;
        }
        object symbol = null;
        object assetPair = this.safeValue(order, "assetPair");
        if (isTrue(!isEqual(assetPair, null)))
        {
            symbol = this.getSymbolFromAssetPair(assetPair);
        } else if (isTrue(!isEqual(market, null)))
        {
            symbol = getValue(market, "symbol");
        }
        object side = this.safeString(order, "orderType");
        object orderId = this.safeString(order, "id");
        object fee = new Dictionary<string, object>() {
            { "cost", this.safeString(order, "matcherFee") },
            { "currency", this.safeCurrencyCode(this.safeString(order, "matcherFeeAssetId", "WAVES")) },
        };
        return this.safeTrade(new Dictionary<string, object>() {
            { "info", trade },
            { "timestamp", timestamp },
            { "datetime", datetime },
            { "symbol", symbol },
            { "id", id },
            { "order", orderId },
            { "type", null },
            { "side", side },
            { "takerOrMaker", null },
            { "price", priceString },
            { "amount", amountString },
            { "cost", null },
            { "fee", fee },
        }, market);
    }

    public override object parseDepositWithdrawFees(object response, object codes = null, object currencyIdKey = null)
    {
        object depositWithdrawFees = new Dictionary<string, object>() {};
        codes = this.marketCodes(codes);
        for (object i = 0; isLessThan(i, getArrayLength(response)); postFixIncrement(ref i))
        {
            object entry = getValue(response, i);
            object dictionary = entry;
            object currencyId = this.safeString(dictionary, currencyIdKey);
            object currency = this.safeValue(this.currencies_by_id, currencyId);
            object code = this.safeString(currency, "code", currencyId);
            if (isTrue(isTrue((isEqual(codes, null))) || isTrue((this.inArray(code, codes)))))
            {
                object depositWithdrawFee = this.safeValue(depositWithdrawFees, code);
                if (isTrue(isEqual(depositWithdrawFee, null)))
                {
                    depositWithdrawFee = new Dictionary<string, object>() {
                        { "info", new List<object>() {dictionary} },
                        { "withdraw", new Dictionary<string, object>() {
                            { "fee", null },
                            { "percentage", null },
                        } },
                        { "deposit", new Dictionary<string, object>() {
                            { "fee", null },
                            { "percentage", null },
                        } },
                        { "networks", new Dictionary<string, object>() {} },
                    };
                } else
                {
                    depositWithdrawFee = getValue(depositWithdrawFees, code);
                    ((IDictionary<string,object>)depositWithdrawFee)["info"] = this.arrayConcat(getValue(depositWithdrawFee, "info"), new List<object>() {dictionary});
                }
                object networkId = this.safeString(dictionary, "platform_id");
                object currencyCode = this.safeString(currency, "code");
                object networkCode = this.networkIdToCode(networkId, currencyCode);
                object network = this.safeValue(getValue(depositWithdrawFee, "networks"), networkCode);
                if (isTrue(isEqual(network, null)))
                {
                    network = new Dictionary<string, object>() {
                        { "withdraw", new Dictionary<string, object>() {
                            { "fee", null },
                            { "percentage", null },
                        } },
                        { "deposit", new Dictionary<string, object>() {
                            { "fee", null },
                            { "percentage", null },
                        } },
                    };
                }
                object feeType = this.safeString(dictionary, "type");
                object fees = this.safeValue(dictionary, "fees");
                object networkKey = "deposit";
                if (isTrue(isEqual(feeType, "withdrawal_currency")))
                {
                    networkKey = "withdraw";
                }
                ((IDictionary<string,object>)network)[(string)networkKey] = new Dictionary<string, object>() {
                    { "fee", this.safeNumber(fees, "flat") },
                    { "percentage", false },
                };
                ((IDictionary<string,object>)getValue(depositWithdrawFee, "networks"))[(string)networkCode] = network;
                ((IDictionary<string,object>)depositWithdrawFees)[(string)code] = depositWithdrawFee;
            }
        }
        object depositWithdrawFeesKeys = new List<object>(((IDictionary<string,object>)depositWithdrawFees).Keys);
        for (object i = 0; isLessThan(i, getArrayLength(depositWithdrawFeesKeys)); postFixIncrement(ref i))
        {
            object code = getValue(depositWithdrawFeesKeys, i);
            object entry = getValue(depositWithdrawFees, code);
            object networks = this.safeValue(entry, "networks");
            object networkKeys = new List<object>(((IDictionary<string,object>)networks).Keys);
            object networkKeysLength = getArrayLength(networkKeys);
            if (isTrue(isEqual(networkKeysLength, 1)))
            {
                object network = this.safeValue(networks, getValue(networkKeys, 0));
                ((IDictionary<string,object>)getValue(depositWithdrawFees, code))["withdraw"] = this.safeValue(network, "withdraw");
                ((IDictionary<string,object>)getValue(depositWithdrawFees, code))["deposit"] = this.safeValue(network, "deposit");
            }
        }
        return depositWithdrawFees;
    }

    public async override Task<object> fetchDepositWithdrawFees(object codes = null, object parameters = null)
    {
        /**
        * @method
        * @name wavesexchange#fetchDepositWithdrawFees
        * @description fetch deposit and withdraw fees
        * @see https://docs.wx.network/en/api/gateways/deposit/currencies
        * @see https://docs.wx.network/en/api/gateways/withdraw/currencies
        * @param {string[]|undefined} codes list of unified currency codes
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a list of [fee structures]{@link https://docs.ccxt.com/#/?id=fee-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object data = new List<object>() {};
        object promises = new List<object>() {};
        ((IList<object>)promises).Add(this.privateGetDepositCurrencies(parameters));
        ((IList<object>)promises).Add(this.privateGetWithdrawCurrencies(parameters));
        promises = await promiseAll(promises);
        //
        //    {
        //        "type": "list",
        //        "page_info": {
        //          "has_next_page": false,
        //          "last_cursor": null
        //        },
        //        "items": [
        //          {
        //            "type": "deposit_currency",
        //            "id": "WEST",
        //            "platform_id": "WEST",
        //            "waves_asset_id": "4LHHvYGNKJUg5hj65aGD5vgScvCBmLpdRFtjokvCjSL8",
        //            "platform_asset_id": "WEST",
        //            "decimals": 8,
        //            "status": "active",
        //            "allowed_amount": {
        //              "min": 0.1,
        //              "max": 2000000
        //            },
        //            "fees": {
        //              "flat": 0,
        //              "rate": 0
        //            }
        //          },
        //        ]
        //    }
        //
        //
        //    {
        //        "type": "list",
        //        "page_info": {
        //          "has_next_page": false,
        //          "last_cursor": null
        //        },
        //        "items": [
        //          {
        //            "type": "withdrawal_currency",
        //            "id": "BTC",
        //            "platform_id": "BTC",
        //            "waves_asset_id": "8LQW8f7P5d5PZM7GtZEBgaqRPGSzS3DfPuiXrURJ4AJS",
        //            "platform_asset_id": "BTC",
        //            "decimals": 8,
        //            "status": "inactive",
        //            "allowed_amount": {
        //              "min": 0.001,
        //              "max": 10
        //            },
        //            "fees": {
        //              "flat": 0.001,
        //              "rate": 0
        //            }
        //          },
        //        ]
        //    }
        //
        for (object i = 0; isLessThan(i, getArrayLength(promises)); postFixIncrement(ref i))
        {
            object items = this.safeValue(getValue(promises, i), "items");
            data = this.arrayConcat(data, items);
        }
        return this.parseDepositWithdrawFees(data, codes, "id");
    }

    public override object handleErrors(object code, object reason, object url, object method, object headers, object body, object response, object requestHeaders, object requestBody)
    {
        object errorCode = this.safeString(response, "error");
        object success = this.safeBool(response, "success", true);
        object Exception = this.safeValue(this.exceptions, errorCode);
        if (isTrue(!isEqual(Exception, null)))
        {
            object messageInner = this.safeString(response, "message");
            throwDynamicException(Exception, add(add(this.id, " "), messageInner));return null;
        }
        object message = this.safeString(response, "message");
        if (isTrue(isEqual(message, "Validation Error")))
        {
            throw new BadRequest ((string)add(add(this.id, " "), body)) ;
        }
        if (!isTrue(success))
        {
            throw new ExchangeError ((string)add(add(this.id, " "), body)) ;
        }
        return null;
    }

    public async override Task<object> withdraw(object code, object amount, object address, object tag = null, object parameters = null)
    {
        /**
        * @method
        * @name wavesexchange#withdraw
        * @description make a withdrawal
        * @param {string} code unified currency code
        * @param {float} amount the amount to withdraw
        * @param {string} address the address to withdraw to
        * @param {string} tag
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
        */
        parameters ??= new Dictionary<string, object>();
        var tagparametersVariable = this.handleWithdrawTagAndParams(tag, parameters);
        tag = ((IList<object>)tagparametersVariable)[0];
        parameters = ((IList<object>)tagparametersVariable)[1];
        // currently only works for BTC and WAVES
        if (isTrue(!isEqual(code, "WAVES")))
        {
            object supportedCurrencies = await this.privateGetWithdrawCurrencies();
            object currencies = new Dictionary<string, object>() {};
            object items = this.safeValue(supportedCurrencies, "items", new List<object>() {});
            for (object i = 0; isLessThan(i, getArrayLength(items)); postFixIncrement(ref i))
            {
                object entry = getValue(items, i);
                object currencyCode = this.safeString(entry, "id");
                ((IDictionary<string,object>)currencies)[(string)currencyCode] = true;
            }
            if (!isTrue((inOp(currencies, code))))
            {
                object codes = new List<object>(((IDictionary<string,object>)currencies).Keys);
                throw new ExchangeError ((string)add(add(add(add(this.id, " withdraw() "), code), " not supported. Currency code must be one of "), ((object)codes).ToString())) ;
            }
        }
        await this.loadMarkets();
        object hexChars = new List<object>() {"0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f"};
        object set = new Dictionary<string, object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(hexChars)); postFixIncrement(ref i))
        {
            object key = getValue(hexChars, i);
            ((IDictionary<string,object>)set)[(string)key] = true;
        }
        object isErc20 = true;
        object noPrefix = this.remove0xPrefix(address);
        object lower = ((string)noPrefix).ToLower();
        object stringLength = multiply(getArrayLength(lower), 1);
        for (object i = 0; isLessThan(i, stringLength); postFixIncrement(ref i))
        {
            object character = getValue(lower, i);
            if (!isTrue((inOp(set, character))))
            {
                isErc20 = false;
                break;
            }
        }
        await this.signIn();
        object proxyAddress = null;
        if (isTrue(isTrue(isEqual(code, "WAVES")) && !isTrue(isErc20)))
        {
            proxyAddress = address;
        } else
        {
            object withdrawAddressRequest = new Dictionary<string, object>() {
                { "address", address },
                { "currency", code },
            };
            object withdrawAddress = await this.privateGetWithdrawAddressesCurrencyAddress(withdrawAddressRequest);
            object currencyInner = this.safeValue(withdrawAddress, "currency");
            object allowedAmount = this.safeValue(currencyInner, "allowed_amount");
            object minimum = this.safeNumber(allowedAmount, "min");
            if (isTrue(isLessThanOrEqual(amount, minimum)))
            {
                throw new BadRequest ((string)add(add(add(add(add(add(this.id, " "), code), " withdraw failed, amount "), ((object)amount).ToString()), " must be greater than the minimum allowed amount of "), ((object)minimum).ToString())) ;
            }
            // {
            //   "type": "withdrawal_addresses",
            //   "currency": {
            //     "type": "withdrawal_currency",
            //     "id": "BTC",
            //     "waves_asset_id": "8LQW8f7P5d5PZM7GtZEBgaqRPGSzS3DfPuiXrURJ4AJS",
            //     "decimals": 8,
            //     "status": "active",
            //     "allowed_amount": {
            //       "min": 0.001,
            //       "max": 20
            //     },
            //     "fees": {
            //       "flat": 0.001,
            //       "rate": 0
            //     }
            //   },
            //   "proxy_addresses": [
            //     "3P3qqmkiLwNHB7x1FeoE8bvkRtULwGpo9ga"
            //   ]
            // }
            object proxyAddresses = this.safeValue(withdrawAddress, "proxy_addresses", new List<object>() {});
            proxyAddress = this.safeString(proxyAddresses, 0);
        }
        object fee = this.safeInteger(this.options, "withdrawFeeWAVES", 100000); // 0.001 WAVES
        object feeAssetId = "WAVES";
        object type = 4; // transfer
        object version = 2;
        object amountInteger = this.currencyToPrecision(code, amount);
        object currency = this.currency(code);
        object timestamp = this.milliseconds();
        object byteArray = new List<object> {this.numberToBE(4, 1), this.numberToBE(2, 1), this.base58ToBinary(this.apiKey), this.getAssetBytes(getValue(currency, "id")), this.getAssetBytes(feeAssetId), this.numberToBE(timestamp, 8), this.numberToBE(amountInteger, 8), this.numberToBE(fee, 8), this.base58ToBinary(proxyAddress), this.numberToBE(0, 2)};
        object binary = this.binaryConcatArray(byteArray);
        object hexSecret = this.binaryToBase16(this.base58ToBinary(this.secret));
        object signature = this.axolotl(this.binaryToBase16(binary), hexSecret, ed25519);
        object request = new Dictionary<string, object>() {
            { "senderPublicKey", this.apiKey },
            { "amount", amountInteger },
            { "fee", fee },
            { "type", type },
            { "version", version },
            { "attachment", "" },
            { "feeAssetId", this.getAssetId(feeAssetId) },
            { "proofs", new List<object>() {signature} },
            { "assetId", this.getAssetId(getValue(currency, "id")) },
            { "recipient", proxyAddress },
            { "timestamp", timestamp },
            { "signature", signature },
        };
        object result = await this.nodePostTransactionsBroadcast(request);
        //
        //     {
        //         "id": "string",
        //         "signature": "string",
        //         "fee": 0,
        //         "timestamp": 1460678400000,
        //         "recipient": "3P274YB5qseSE9DTTL3bpSjosZrYBPDpJ8k",
        //         "amount": 0
        //     }
        //
        return this.parseTransaction(result, currency);
    }

    public override object parseTransaction(object transaction, object currency = null)
    {
        //
        // withdraw
        //
        //     {
        //         "id": "string",
        //         "signature": "string",
        //         "fee": 0,
        //         "timestamp": 1460678400000,
        //         "recipient": "3P274YB5qseSE9DTTL3bpSjosZrYBPDpJ8k",
        //         "amount": 0
        //     }
        //
        currency = this.safeCurrency(null, currency);
        return new Dictionary<string, object>() {
            { "id", null },
            { "txid", null },
            { "timestamp", null },
            { "datetime", null },
            { "network", null },
            { "addressFrom", null },
            { "address", null },
            { "addressTo", null },
            { "amount", null },
            { "type", null },
            { "currency", getValue(currency, "code") },
            { "status", null },
            { "updated", null },
            { "tagFrom", null },
            { "tag", null },
            { "tagTo", null },
            { "comment", null },
            { "internal", null },
            { "fee", null },
            { "info", transaction },
        };
    }
}
