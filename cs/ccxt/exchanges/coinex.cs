namespace ccxt;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

public partial class coinex : Exchange
{
    public override object describe()
    {
        return this.deepExtend(base.describe(), new Dictionary<string, object>() {
            { "id", "coinex" },
            { "name", "CoinEx" },
            { "version", "v1" },
            { "countries", new List<object>() {"CN"} },
            { "rateLimit", 2.5 },
            { "pro", true },
            { "certified", true },
            { "has", new Dictionary<string, object>() {
                { "CORS", null },
                { "spot", true },
                { "margin", true },
                { "swap", true },
                { "future", false },
                { "option", false },
                { "addMargin", true },
                { "borrowCrossMargin", false },
                { "borrowIsolatedMargin", true },
                { "cancelAllOrders", true },
                { "cancelOrder", true },
                { "cancelOrders", true },
                { "createDepositAddress", true },
                { "createMarketBuyOrderWithCost", true },
                { "createMarketOrderWithCost", false },
                { "createMarketSellOrderWithCost", false },
                { "createOrder", true },
                { "createOrders", true },
                { "createReduceOnlyOrder", true },
                { "createStopLossOrder", true },
                { "createTakeProfitOrder", true },
                { "createTriggerOrder", true },
                { "editOrder", true },
                { "fetchBalance", true },
                { "fetchBorrowInterest", true },
                { "fetchBorrowRateHistories", false },
                { "fetchBorrowRateHistory", false },
                { "fetchClosedOrders", true },
                { "fetchCrossBorrowRate", false },
                { "fetchCrossBorrowRates", false },
                { "fetchCurrencies", true },
                { "fetchDepositAddress", true },
                { "fetchDepositAddressByNetwork", false },
                { "fetchDepositAddresses", false },
                { "fetchDeposits", true },
                { "fetchDepositWithdrawFee", "emulated" },
                { "fetchDepositWithdrawFees", true },
                { "fetchFundingHistory", true },
                { "fetchFundingRate", true },
                { "fetchFundingRateHistory", true },
                { "fetchFundingRates", true },
                { "fetchIndexOHLCV", false },
                { "fetchIsolatedBorrowRate", true },
                { "fetchIsolatedBorrowRates", true },
                { "fetchLeverage", "emulated" },
                { "fetchLeverages", true },
                { "fetchLeverageTiers", true },
                { "fetchMarginAdjustmentHistory", true },
                { "fetchMarketLeverageTiers", "emulated" },
                { "fetchMarkets", true },
                { "fetchMarkOHLCV", false },
                { "fetchMyTrades", true },
                { "fetchOHLCV", true },
                { "fetchOpenOrders", true },
                { "fetchOrder", true },
                { "fetchOrderBook", true },
                { "fetchPosition", true },
                { "fetchPositionHistory", true },
                { "fetchPositions", true },
                { "fetchPositionsHistory", false },
                { "fetchPositionsRisk", false },
                { "fetchPremiumIndexOHLCV", false },
                { "fetchTicker", true },
                { "fetchTickers", true },
                { "fetchTime", true },
                { "fetchTrades", true },
                { "fetchTradingFee", true },
                { "fetchTradingFees", true },
                { "fetchTransfer", false },
                { "fetchTransfers", true },
                { "fetchWithdrawal", false },
                { "fetchWithdrawals", true },
                { "reduceMargin", true },
                { "repayCrossMargin", false },
                { "repayIsolatedMargin", true },
                { "setLeverage", true },
                { "setMarginMode", true },
                { "setPositionMode", false },
                { "transfer", true },
                { "withdraw", true },
            } },
            { "timeframes", new Dictionary<string, object>() {
                { "1m", "1min" },
                { "3m", "3min" },
                { "5m", "5min" },
                { "15m", "15min" },
                { "30m", "30min" },
                { "1h", "1hour" },
                { "2h", "2hour" },
                { "4h", "4hour" },
                { "6h", "6hour" },
                { "12h", "12hour" },
                { "1d", "1day" },
                { "3d", "3day" },
                { "1w", "1week" },
            } },
            { "urls", new Dictionary<string, object>() {
                { "logo", "https://user-images.githubusercontent.com/51840849/87182089-1e05fa00-c2ec-11ea-8da9-cc73b45abbbc.jpg" },
                { "api", new Dictionary<string, object>() {
                    { "public", "https://api.coinex.com" },
                    { "private", "https://api.coinex.com" },
                    { "perpetualPublic", "https://api.coinex.com/perpetual" },
                    { "perpetualPrivate", "https://api.coinex.com/perpetual" },
                } },
                { "www", "https://www.coinex.com" },
                { "doc", "https://docs.coinex.com/api/v2" },
                { "fees", "https://www.coinex.com/fees" },
                { "referral", "https://www.coinex.com/register?refer_code=yw5fz" },
            } },
            { "api", new Dictionary<string, object>() {
                { "v1", new Dictionary<string, object>() {
                    { "public", new Dictionary<string, object>() {
                        { "get", new Dictionary<string, object>() {
                            { "amm/market", 1 },
                            { "common/currency/rate", 1 },
                            { "common/asset/config", 1 },
                            { "common/maintain/info", 1 },
                            { "common/temp-maintain/info", 1 },
                            { "margin/market", 1 },
                            { "market/info", 1 },
                            { "market/list", 1 },
                            { "market/ticker", 1 },
                            { "market/ticker/all", 1 },
                            { "market/depth", 1 },
                            { "market/deals", 1 },
                            { "market/kline", 1 },
                            { "market/detail", 1 },
                        } },
                    } },
                    { "private", new Dictionary<string, object>() {
                        { "get", new Dictionary<string, object>() {
                            { "account/amm/balance", 40 },
                            { "account/investment/balance", 40 },
                            { "account/balance/history", 40 },
                            { "account/market/fee", 40 },
                            { "balance/coin/deposit", 40 },
                            { "balance/coin/withdraw", 40 },
                            { "balance/info", 40 },
                            { "balance/deposit/address/{coin_type}", 40 },
                            { "contract/transfer/history", 40 },
                            { "credit/info", 40 },
                            { "credit/balance", 40 },
                            { "investment/transfer/history", 40 },
                            { "margin/account", 1 },
                            { "margin/config", 1 },
                            { "margin/loan/history", 40 },
                            { "margin/transfer/history", 40 },
                            { "order/deals", 40 },
                            { "order/finished", 40 },
                            { "order/pending", 8 },
                            { "order/status", 8 },
                            { "order/status/batch", 8 },
                            { "order/user/deals", 40 },
                            { "order/stop/finished", 40 },
                            { "order/stop/pending", 8 },
                            { "order/user/trade/fee", 1 },
                            { "order/market/trade/info", 1 },
                            { "sub_account/balance", 1 },
                            { "sub_account/transfer/history", 40 },
                            { "sub_account/auth/api", 40 },
                            { "sub_account/auth/api/{user_auth_id}", 40 },
                        } },
                        { "post", new Dictionary<string, object>() {
                            { "balance/coin/withdraw", 40 },
                            { "contract/balance/transfer", 40 },
                            { "margin/flat", 40 },
                            { "margin/loan", 40 },
                            { "margin/transfer", 40 },
                            { "order/limit/batch", 40 },
                            { "order/ioc", 13.334 },
                            { "order/limit", 13.334 },
                            { "order/market", 13.334 },
                            { "order/modify", 13.334 },
                            { "order/stop/limit", 13.334 },
                            { "order/stop/market", 13.334 },
                            { "order/stop/modify", 13.334 },
                            { "sub_account/transfer", 40 },
                            { "sub_account/register", 1 },
                            { "sub_account/unfrozen", 40 },
                            { "sub_account/frozen", 40 },
                            { "sub_account/auth/api", 40 },
                        } },
                        { "put", new Dictionary<string, object>() {
                            { "balance/deposit/address/{coin_type}", 40 },
                            { "sub_account/unfrozen", 40 },
                            { "sub_account/frozen", 40 },
                            { "sub_account/auth/api/{user_auth_id}", 40 },
                            { "v1/account/settings", 40 },
                        } },
                        { "delete", new Dictionary<string, object>() {
                            { "balance/coin/withdraw", 40 },
                            { "order/pending/batch", 40 },
                            { "order/pending", 13.334 },
                            { "order/stop/pending", 40 },
                            { "order/stop/pending/{id}", 13.334 },
                            { "order/pending/by_client_id", 40 },
                            { "order/stop/pending/by_client_id", 40 },
                            { "sub_account/auth/api/{user_auth_id}", 40 },
                            { "sub_account/authorize/{id}", 40 },
                        } },
                    } },
                    { "perpetualPublic", new Dictionary<string, object>() {
                        { "get", new Dictionary<string, object>() {
                            { "ping", 1 },
                            { "time", 1 },
                            { "market/list", 1 },
                            { "market/limit_config", 1 },
                            { "market/ticker", 1 },
                            { "market/ticker/all", 1 },
                            { "market/depth", 1 },
                            { "market/deals", 1 },
                            { "market/funding_history", 1 },
                            { "market/kline", 1 },
                        } },
                    } },
                    { "perpetualPrivate", new Dictionary<string, object>() {
                        { "get", new Dictionary<string, object>() {
                            { "market/user_deals", 1 },
                            { "asset/query", 40 },
                            { "order/pending", 8 },
                            { "order/finished", 40 },
                            { "order/stop_finished", 40 },
                            { "order/stop_pending", 8 },
                            { "order/status", 8 },
                            { "order/stop_status", 8 },
                            { "position/finished", 40 },
                            { "position/pending", 40 },
                            { "position/funding", 40 },
                            { "position/adl_history", 40 },
                            { "market/preference", 40 },
                            { "position/margin_history", 40 },
                            { "position/settle_history", 40 },
                        } },
                        { "post", new Dictionary<string, object>() {
                            { "market/adjust_leverage", 1 },
                            { "market/position_expect", 1 },
                            { "order/put_limit", 20 },
                            { "order/put_market", 20 },
                            { "order/put_stop_limit", 20 },
                            { "order/put_stop_market", 20 },
                            { "order/modify", 20 },
                            { "order/modify_stop", 20 },
                            { "order/cancel", 20 },
                            { "order/cancel_all", 40 },
                            { "order/cancel_batch", 40 },
                            { "order/cancel_stop", 20 },
                            { "order/cancel_stop_all", 40 },
                            { "order/close_limit", 20 },
                            { "order/close_market", 20 },
                            { "position/adjust_margin", 20 },
                            { "position/stop_loss", 20 },
                            { "position/take_profit", 20 },
                            { "position/market_close", 20 },
                            { "order/cancel/by_client_id", 20 },
                            { "order/cancel_stop/by_client_id", 20 },
                            { "market/preference", 20 },
                        } },
                    } },
                } },
                { "v2", new Dictionary<string, object>() {
                    { "public", new Dictionary<string, object>() {
                        { "get", new Dictionary<string, object>() {
                            { "maintain-info", 1 },
                            { "ping", 1 },
                            { "time", 1 },
                            { "spot/market", 1 },
                            { "spot/ticker", 1 },
                            { "spot/depth", 1 },
                            { "spot/deals", 1 },
                            { "spot/kline", 1 },
                            { "spot/index", 1 },
                            { "futures/market", 1 },
                            { "futures/ticker", 1 },
                            { "futures/depth", 1 },
                            { "futures/deals", 1 },
                            { "futures/kline", 1 },
                            { "futures/index", 1 },
                            { "futures/funding-rate", 1 },
                            { "futures/funding-rate-history", 1 },
                            { "futures/position-level", 1 },
                            { "futures/liquidation-history", 1 },
                            { "futures/basis-history", 1 },
                        } },
                    } },
                    { "private", new Dictionary<string, object>() {
                        { "get", new Dictionary<string, object>() {
                            { "account/subs", 1 },
                            { "account/subs/api-detail", 40 },
                            { "account/subs/info", 1 },
                            { "account/subs/api", 40 },
                            { "account/subs/transfer-history", 40 },
                            { "account/subs/spot-balance", 1 },
                            { "account/trade-fee-rate", 40 },
                            { "assets/spot/balance", 40 },
                            { "assets/futures/balance", 40 },
                            { "assets/margin/balance", 1 },
                            { "assets/financial/balance", 40 },
                            { "assets/amm/liquidity", 40 },
                            { "assets/credit/info", 40 },
                            { "assets/margin/borrow-history", 40 },
                            { "assets/margin/interest-limit", 1 },
                            { "assets/deposit-address", 40 },
                            { "assets/deposit-history", 40 },
                            { "assets/withdraw", 40 },
                            { "assets/deposit-withdraw-config", 1 },
                            { "assets/transfer-history", 40 },
                            { "spot/order-status", 8 },
                            { "spot/batch-order-status", 8 },
                            { "spot/pending-order", 8 },
                            { "spot/finished-order", 40 },
                            { "spot/pending-stop-order", 8 },
                            { "spot/finished-stop-order", 40 },
                            { "spot/user-deals", 40 },
                            { "spot/order-deals", 40 },
                            { "futures/order-status", 8 },
                            { "futures/batch-order-status", 1 },
                            { "futures/pending-order", 8 },
                            { "futures/finished-order", 40 },
                            { "futures/pending-stop-order", 8 },
                            { "futures/finished-stop-order", 40 },
                            { "futures/user-deals", 1 },
                            { "futures/order-deals", 1 },
                            { "futures/pending-position", 40 },
                            { "futures/finished-position", 1 },
                            { "futures/position-margin-history", 1 },
                            { "futures/position-funding-history", 40 },
                            { "futures/position-adl-history", 1 },
                            { "futures/position-settle-history", 1 },
                        } },
                        { "post", new Dictionary<string, object>() {
                            { "account/subs", 40 },
                            { "account/subs/frozen", 40 },
                            { "account/subs/unfrozen", 40 },
                            { "account/subs/api", 40 },
                            { "account/subs/edit-api", 40 },
                            { "account/subs/delete-api", 40 },
                            { "account/subs/transfer", 40 },
                            { "account/settings", 40 },
                            { "assets/margin/borrow", 40 },
                            { "assets/margin/repay", 40 },
                            { "assets/renewal-deposit-address", 40 },
                            { "assets/withdraw", 40 },
                            { "assets/cancel-withdraw", 40 },
                            { "assets/transfer", 40 },
                            { "assets/amm/add-liquidity", 1 },
                            { "assets/amm/remove-liquidity", 1 },
                            { "spot/order", 13.334 },
                            { "spot/stop-order", 13.334 },
                            { "spot/batch-order", 40 },
                            { "spot/batch-stop-order", 1 },
                            { "spot/modify-order", 13.334 },
                            { "spot/modify-stop-order", 13.334 },
                            { "spot/cancel-all-order", 1 },
                            { "spot/cancel-order", 6.667 },
                            { "spot/cancel-stop-order", 6.667 },
                            { "spot/cancel-batch-order", 10 },
                            { "spot/cancel-batch-stop-order", 10 },
                            { "spot/cancel-order-by-client-id", 1 },
                            { "spot/cancel-stop-order-by-client-id", 1 },
                            { "futures/order", 20 },
                            { "futures/stop-order", 20 },
                            { "futures/batch-order", 1 },
                            { "futures/batch-stop-order", 1 },
                            { "futures/modify-order", 20 },
                            { "futures/modify-stop-order", 20 },
                            { "futures/cancel-all-order", 1 },
                            { "futures/cancel-order", 10 },
                            { "futures/cancel-stop-order", 10 },
                            { "futures/cancel-batch-order", 20 },
                            { "futures/cancel-batch-stop-order", 20 },
                            { "futures/cancel-order-by-client-id", 1 },
                            { "futures/cancel-stop-order-by-client-id", 1 },
                            { "futures/close-position", 20 },
                            { "futures/adjust-position-margin", 20 },
                            { "futures/adjust-position-leverage", 20 },
                            { "futures/set-position-stop-loss", 20 },
                            { "futures/set-position-take-profit", 20 },
                        } },
                    } },
                } },
            } },
            { "fees", new Dictionary<string, object>() {
                { "trading", new Dictionary<string, object>() {
                    { "maker", 0.001 },
                    { "taker", 0.001 },
                } },
                { "funding", new Dictionary<string, object>() {
                    { "withdraw", new Dictionary<string, object>() {
                        { "BCH", 0 },
                        { "BTC", 0.001 },
                        { "LTC", 0.001 },
                        { "ETH", 0.001 },
                        { "ZEC", 0.0001 },
                        { "DASH", 0.0001 },
                    } },
                } },
            } },
            { "limits", new Dictionary<string, object>() {
                { "amount", new Dictionary<string, object>() {
                    { "min", 0.001 },
                    { "max", null },
                } },
            } },
            { "options", new Dictionary<string, object>() {
                { "brokerId", "x-167673045" },
                { "createMarketBuyOrderRequiresPrice", true },
                { "defaultType", "spot" },
                { "defaultSubType", "linear" },
                { "fetchDepositAddress", new Dictionary<string, object>() {
                    { "fillResponseFromRequest", true },
                } },
                { "accountsById", new Dictionary<string, object>() {
                    { "spot", "0" },
                } },
                { "networks", new Dictionary<string, object>() {
                    { "BEP20", "BSC" },
                    { "TRX", "TRC20" },
                    { "ETH", "ERC20" },
                } },
            } },
            { "commonCurrencies", new Dictionary<string, object>() {
                { "ACM", "Actinium" },
            } },
            { "precisionMode", TICK_SIZE },
            { "exceptions", new Dictionary<string, object>() {
                { "exact", new Dictionary<string, object>() {
                    { "23", typeof(PermissionDenied) },
                    { "24", typeof(AuthenticationError) },
                    { "25", typeof(AuthenticationError) },
                    { "34", typeof(AuthenticationError) },
                    { "35", typeof(ExchangeNotAvailable) },
                    { "36", typeof(RequestTimeout) },
                    { "213", typeof(RateLimitExceeded) },
                    { "107", typeof(InsufficientFunds) },
                    { "600", typeof(OrderNotFound) },
                    { "601", typeof(InvalidOrder) },
                    { "602", typeof(InvalidOrder) },
                    { "606", typeof(InvalidOrder) },
                } },
                { "broad", new Dictionary<string, object>() {
                    { "ip not allow visit", typeof(PermissionDenied) },
                    { "service too busy", typeof(ExchangeNotAvailable) },
                } },
            } },
        });
    }

    public async override Task<object> fetchCurrencies(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object response = await this.v1PublicGetCommonAssetConfig(parameters);
        //     {
        //         "code": 0,
        //         "data": {
        //             "USDT-ERC20": {
        //                  "asset": "USDT",
        //                  "chain": "ERC20",
        //                  "withdrawal_precision": 6,
        //                  "can_deposit": true,
        //                  "can_withdraw": true,
        //                  "deposit_least_amount": "4.9",
        //                  "withdraw_least_amount": "4.9",
        //                  "withdraw_tx_fee": "4.9",
        //                  "explorer_asset_url": "https://etherscan.io/token/0xdac17f958d2ee523a2206206994597c13d831ec7"
        //             },
        //             ...
        //         },
        //         "message": "Success",
        //     }
        //
        object data = this.safeValue(response, "data", new List<object>() {});
        object coins = new List<object>(((IDictionary<string,object>)data).Keys);
        object result = new Dictionary<string, object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(coins)); postFixIncrement(ref i))
        {
            object coin = getValue(coins, i);
            object currency = getValue(data, coin);
            object currencyId = this.safeString(currency, "asset");
            object networkId = this.safeString(currency, "chain");
            object code = this.safeCurrencyCode(currencyId);
            object precisionString = this.parsePrecision(this.safeString(currency, "withdrawal_precision"));
            object precision = this.parseNumber(precisionString);
            object canDeposit = this.safeValue(currency, "can_deposit");
            object canWithdraw = this.safeValue(currency, "can_withdraw");
            object feeString = this.safeString(currency, "withdraw_tx_fee");
            object fee = this.parseNumber(feeString);
            object minNetworkDepositString = this.safeString(currency, "deposit_least_amount");
            object minNetworkDeposit = this.parseNumber(minNetworkDepositString);
            object minNetworkWithdrawString = this.safeString(currency, "withdraw_least_amount");
            object minNetworkWithdraw = this.parseNumber(minNetworkWithdrawString);
            if (isTrue(isEqual(this.safeValue(result, code), null)))
            {
                ((IDictionary<string,object>)result)[(string)code] = new Dictionary<string, object>() {
                    { "id", currencyId },
                    { "numericId", null },
                    { "code", code },
                    { "info", null },
                    { "name", null },
                    { "active", isTrue(canDeposit) && isTrue(canWithdraw) },
                    { "deposit", canDeposit },
                    { "withdraw", canWithdraw },
                    { "fee", fee },
                    { "precision", precision },
                    { "limits", new Dictionary<string, object>() {
                        { "amount", new Dictionary<string, object>() {
                            { "min", null },
                            { "max", null },
                        } },
                        { "deposit", new Dictionary<string, object>() {
                            { "min", minNetworkDeposit },
                            { "max", null },
                        } },
                        { "withdraw", new Dictionary<string, object>() {
                            { "min", minNetworkWithdraw },
                            { "max", null },
                        } },
                    } },
                };
            }
            object minFeeString = this.safeString(getValue(result, code), "fee");
            if (isTrue(!isEqual(feeString, null)))
            {
                minFeeString = ((bool) isTrue((isEqual(minFeeString, null)))) ? feeString : Precise.stringMin(feeString, minFeeString);
            }
            object depositAvailable = this.safeValue(getValue(result, code), "deposit");
            depositAvailable = ((bool) isTrue((canDeposit))) ? canDeposit : depositAvailable;
            object withdrawAvailable = this.safeValue(getValue(result, code), "withdraw");
            withdrawAvailable = ((bool) isTrue((canWithdraw))) ? canWithdraw : withdrawAvailable;
            object minDepositString = this.safeString(getValue(getValue(getValue(result, code), "limits"), "deposit"), "min");
            if (isTrue(!isEqual(minNetworkDepositString, null)))
            {
                minDepositString = ((bool) isTrue((isEqual(minDepositString, null)))) ? minNetworkDepositString : Precise.stringMin(minNetworkDepositString, minDepositString);
            }
            object minWithdrawString = this.safeString(getValue(getValue(getValue(result, code), "limits"), "withdraw"), "min");
            if (isTrue(!isEqual(minNetworkWithdrawString, null)))
            {
                minWithdrawString = ((bool) isTrue((isEqual(minWithdrawString, null)))) ? minNetworkWithdrawString : Precise.stringMin(minNetworkWithdrawString, minWithdrawString);
            }
            object minPrecisionString = this.safeString(getValue(result, code), "precision");
            if (isTrue(!isEqual(precisionString, null)))
            {
                minPrecisionString = ((bool) isTrue((isEqual(minPrecisionString, null)))) ? precisionString : Precise.stringMin(precisionString, minPrecisionString);
            }
            object networks = this.safeValue(getValue(result, code), "networks", new Dictionary<string, object>() {});
            object network = new Dictionary<string, object>() {
                { "info", currency },
                { "id", networkId },
                { "network", networkId },
                { "name", null },
                { "limits", new Dictionary<string, object>() {
                    { "amount", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                    { "deposit", new Dictionary<string, object>() {
                        { "min", this.safeNumber(currency, "deposit_least_amount") },
                        { "max", null },
                    } },
                    { "withdraw", new Dictionary<string, object>() {
                        { "min", this.safeNumber(currency, "withdraw_least_amount") },
                        { "max", null },
                    } },
                } },
                { "active", isTrue(canDeposit) && isTrue(canWithdraw) },
                { "deposit", canDeposit },
                { "withdraw", canWithdraw },
                { "fee", fee },
                { "precision", precision },
            };
            ((IDictionary<string,object>)networks)[(string)networkId] = network;
            ((IDictionary<string,object>)getValue(result, code))["networks"] = networks;
            ((IDictionary<string,object>)getValue(result, code))["active"] = isTrue(depositAvailable) && isTrue(withdrawAvailable);
            ((IDictionary<string,object>)getValue(result, code))["deposit"] = depositAvailable;
            ((IDictionary<string,object>)getValue(result, code))["withdraw"] = withdrawAvailable;
            object info = this.safeValue(getValue(result, code), "info", new List<object>() {});
            ((IList<object>)info).Add(currency);
            ((IDictionary<string,object>)getValue(result, code))["info"] = info;
            ((IDictionary<string,object>)getValue(result, code))["fee"] = this.parseNumber(minFeeString);
            ((IDictionary<string,object>)getValue(result, code))["precision"] = this.parseNumber(minPrecisionString);
            ((IDictionary<string,object>)getValue(getValue(getValue(result, code), "limits"), "deposit"))["min"] = this.parseNumber(minDepositString);
            ((IDictionary<string,object>)getValue(getValue(getValue(result, code), "limits"), "withdraw"))["min"] = this.parseNumber(minWithdrawString);
        }
        return result;
    }

    public async override Task<object> fetchMarkets(object parameters = null)
    {
        /**
        * @method
        * @name coinex#fetchMarkets
        * @description retrieves data on all markets for coinex
        * @see https://docs.coinex.com/api/v2/spot/market/http/list-market
        * @see https://docs.coinex.com/api/v2/futures/market/http/list-market
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} an array of objects representing market data
        */
        parameters ??= new Dictionary<string, object>();
        object promisesUnresolved = new List<object> {this.fetchSpotMarkets(parameters), this.fetchContractMarkets(parameters)};
        object promises = await promiseAll(promisesUnresolved);
        object spotMarkets = getValue(promises, 0);
        object swapMarkets = getValue(promises, 1);
        return this.arrayConcat(spotMarkets, swapMarkets);
    }

    public async virtual Task<object> fetchSpotMarkets(object parameters)
    {
        object response = await this.v2PublicGetSpotMarket(parameters);
        //
        //     {
        //         "code": 0,
        //         "data": [
        //             {
        //                 "base_ccy": "SORA",
        //                 "base_ccy_precision": 8,
        //                 "is_amm_available": true,
        //                 "is_margin_available": false,
        //                 "maker_fee_rate": "0.003",
        //                 "market": "SORAUSDT",
        //                 "min_amount": "500",
        //                 "quote_ccy": "USDT",
        //                 "quote_ccy_precision": 6,
        //                 "taker_fee_rate": "0.003"
        //             },
        //         ],
        //         "message": "OK"
        //     }
        //
        object markets = this.safeList(response, "data", new List<object>() {});
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(markets)); postFixIncrement(ref i))
        {
            object market = getValue(markets, i);
            object id = this.safeString(market, "market");
            object baseId = this.safeString(market, "base_ccy");
            object quoteId = this.safeString(market, "quote_ccy");
            object bs = this.safeCurrencyCode(baseId);
            object quote = this.safeCurrencyCode(quoteId);
            object symbol = add(add(bs, "/"), quote);
            ((IList<object>)result).Add(new Dictionary<string, object>() {
                { "id", id },
                { "symbol", symbol },
                { "base", bs },
                { "quote", quote },
                { "settle", null },
                { "baseId", baseId },
                { "quoteId", quoteId },
                { "settleId", null },
                { "type", "spot" },
                { "spot", true },
                { "margin", null },
                { "swap", false },
                { "future", false },
                { "option", false },
                { "active", null },
                { "contract", false },
                { "linear", null },
                { "inverse", null },
                { "taker", this.safeNumber(market, "taker_fee_rate") },
                { "maker", this.safeNumber(market, "maker_fee_rate") },
                { "contractSize", null },
                { "expiry", null },
                { "expiryDatetime", null },
                { "strike", null },
                { "optionType", null },
                { "precision", new Dictionary<string, object>() {
                    { "amount", this.parseNumber(this.parsePrecision(this.safeString(market, "base_ccy_precision"))) },
                    { "price", this.parseNumber(this.parsePrecision(this.safeString(market, "quote_ccy_precision"))) },
                } },
                { "limits", new Dictionary<string, object>() {
                    { "leverage", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                    { "amount", new Dictionary<string, object>() {
                        { "min", this.safeNumber(market, "min_amount") },
                        { "max", null },
                    } },
                    { "price", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                    { "cost", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                } },
                { "created", null },
                { "info", market },
            });
        }
        return result;
    }

    public async virtual Task<object> fetchContractMarkets(object parameters)
    {
        object response = await this.v2PublicGetFuturesMarket(parameters);
        //
        //     {
        //         "code": 0,
        //         "data": [
        //             {
        //                 "base_ccy": "BTC",
        //                 "base_ccy_precision": 8,
        //                 "contract_type": "inverse",
        //                 "leverage": ["1","2","3","5","8","10","15","20","30","50","100"],
        //                 "maker_fee_rate": "0",
        //                 "market": "BTCUSD",
        //                 "min_amount": "10",
        //                 "open_interest_volume": "2566879",
        //                 "quote_ccy": "USD",
        //                 "quote_ccy_precision": 2,
        //                 "taker_fee_rate": "0"
        //             },
        //         ],
        //         "message": "OK"
        //     }
        //
        object markets = this.safeList(response, "data", new List<object>() {});
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(markets)); postFixIncrement(ref i))
        {
            object entry = getValue(markets, i);
            object fees = this.fees;
            object leverages = this.safeList(entry, "leverage", new List<object>() {});
            object subType = this.safeString(entry, "contract_type");
            object linear = (isEqual(subType, "linear"));
            object inverse = (isEqual(subType, "inverse"));
            object id = this.safeString(entry, "market");
            object baseId = this.safeString(entry, "base_ccy");
            object quoteId = this.safeString(entry, "quote_ccy");
            object bs = this.safeCurrencyCode(baseId);
            object quote = this.safeCurrencyCode(quoteId);
            object settleId = ((bool) isTrue((isEqual(subType, "linear")))) ? "USDT" : baseId;
            object settle = this.safeCurrencyCode(settleId);
            object symbol = add(add(add(add(bs, "/"), quote), ":"), settle);
            object leveragesLength = getArrayLength(leverages);
            ((IList<object>)result).Add(new Dictionary<string, object>() {
                { "id", id },
                { "symbol", symbol },
                { "base", bs },
                { "quote", quote },
                { "settle", settle },
                { "baseId", baseId },
                { "quoteId", quoteId },
                { "settleId", settleId },
                { "type", "swap" },
                { "spot", false },
                { "margin", false },
                { "swap", true },
                { "future", false },
                { "option", false },
                { "active", null },
                { "contract", true },
                { "linear", linear },
                { "inverse", inverse },
                { "taker", getValue(getValue(fees, "trading"), "taker") },
                { "maker", getValue(getValue(fees, "trading"), "maker") },
                { "contractSize", this.parseNumber("1") },
                { "expiry", null },
                { "expiryDatetime", null },
                { "strike", null },
                { "optionType", null },
                { "precision", new Dictionary<string, object>() {
                    { "amount", this.parseNumber(this.parsePrecision(this.safeString(entry, "base_ccy_precision"))) },
                    { "price", this.parseNumber(this.parsePrecision(this.safeString(entry, "quote_ccy_precision"))) },
                } },
                { "limits", new Dictionary<string, object>() {
                    { "leverage", new Dictionary<string, object>() {
                        { "min", this.safeNumber(leverages, 0) },
                        { "max", this.safeNumber(leverages, subtract(leveragesLength, 1)) },
                    } },
                    { "amount", new Dictionary<string, object>() {
                        { "min", this.safeNumber(entry, "min_amount") },
                        { "max", null },
                    } },
                    { "price", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                    { "cost", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                } },
                { "created", null },
                { "info", entry },
            });
        }
        return result;
    }

    public override object parseTicker(object ticker, object market = null)
    {
        //
        // Spot fetchTicker, fetchTickers
        //
        //     {
        //         "close": "62393.47",
        //         "high": "64106.41",
        //         "last": "62393.47",
        //         "low": "59650.01",
        //         "market": "BTCUSDT",
        //         "open": "61616.15",
        //         "period": 86400,
        //         "value": "28711273.4065667262",
        //         "volume": "461.76557205",
        //         "volume_buy": "11.41506354",
        //         "volume_sell": "7.3240169"
        //     }
        //
        // Swap fetchTicker, fetchTickers
        //
        //     {
        //         "close": "62480.08",
        //         "high": "64100",
        //         "index_price": "62443.05",
        //         "last": "62480.08",
        //         "low": "59600",
        //         "mark_price": "62443.05",
        //         "market": "BTCUSDT",
        //         "open": "61679.98",
        //         "period": 86400,
        //         "value": "180226025.69791713065326633165",
        //         "volume": "2900.2218",
        //         "volume_buy": "7.3847",
        //         "volume_sell": "6.1249"
        //     }
        //
        object marketType = ((bool) isTrue((inOp(ticker, "mark_price")))) ? "swap" : "spot";
        object marketId = this.safeString(ticker, "market");
        object symbol = this.safeSymbol(marketId, market, null, marketType);
        return this.safeTicker(new Dictionary<string, object>() {
            { "symbol", symbol },
            { "timestamp", null },
            { "datetime", null },
            { "high", this.safeString(ticker, "high") },
            { "low", this.safeString(ticker, "low") },
            { "bid", null },
            { "bidVolume", this.safeString(ticker, "volume_buy") },
            { "ask", null },
            { "askVolume", this.safeString(ticker, "volume_sell") },
            { "vwap", null },
            { "open", this.safeString(ticker, "open") },
            { "close", this.safeString(ticker, "close") },
            { "last", this.safeString(ticker, "last") },
            { "previousClose", null },
            { "change", null },
            { "percentage", null },
            { "average", null },
            { "baseVolume", this.safeString(ticker, "volume") },
            { "quoteVolume", null },
            { "info", ticker },
        }, market);
    }

    public async override Task<object> fetchTicker(object symbol, object parameters = null)
    {
        /**
        * @method
        * @name coinex#fetchTicker
        * @description fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
        * @see https://docs.coinex.com/api/v2/spot/market/http/list-market-ticker
        * @see https://docs.coinex.com/api/v2/futures/market/http/list-market-ticker
        * @param {string} symbol unified symbol of the market to fetch the ticker for
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "market", getValue(market, "id") },
        };
        object response = null;
        if (isTrue(getValue(market, "swap")))
        {
            response = await this.v2PublicGetFuturesTicker(this.extend(request, parameters));
        } else
        {
            response = await this.v2PublicGetSpotTicker(this.extend(request, parameters));
        }
        //
        // Spot
        //
        //     {
        //         "code": 0,
        //         "data": [
        //             {
        //                 "close": "62393.47",
        //                 "high": "64106.41",
        //                 "last": "62393.47",
        //                 "low": "59650.01",
        //                 "market": "BTCUSDT",
        //                 "open": "61616.15",
        //                 "period": 86400,
        //                 "value": "28711273.4065667262",
        //                 "volume": "461.76557205",
        //                 "volume_buy": "11.41506354",
        //                 "volume_sell": "7.3240169"
        //             }
        //         ],
        //         "message": "OK"
        //     }
        //
        // Swap
        //
        //     {
        //         "code": 0,
        //         "data": [
        //             {
        //                 "close": "62480.08",
        //                 "high": "64100",
        //                 "index_price": "62443.05",
        //                 "last": "62480.08",
        //                 "low": "59600",
        //                 "mark_price": "62443.05",
        //                 "market": "BTCUSDT",
        //                 "open": "61679.98",
        //                 "period": 86400,
        //                 "value": "180226025.69791713065326633165",
        //                 "volume": "2900.2218",
        //                 "volume_buy": "7.3847",
        //                 "volume_sell": "6.1249"
        //             }
        //         ],
        //         "message": "OK"
        //     }
        //
        object data = this.safeList(response, "data", new List<object>() {});
        object result = this.safeDict(data, 0, new Dictionary<string, object>() {});
        return this.parseTicker(result, market);
    }

    public async override Task<object> fetchTickers(object symbols = null, object parameters = null)
    {
        /**
        * @method
        * @name coinex#fetchTickers
        * @description fetches price tickers for multiple markets, statistical information calculated over the past 24 hours for each market
        * @see https://docs.coinex.com/api/v2/spot/market/http/list-market-ticker
        * @see https://docs.coinex.com/api/v2/futures/market/http/list-market-ticker
        * @param {string[]|undefined} symbols unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/#/?id=ticker-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        symbols = this.marketSymbols(symbols);
        object market = null;
        if (isTrue(!isEqual(symbols, null)))
        {
            object symbol = this.safeValue(symbols, 0);
            market = this.market(symbol);
        }
        var marketTypequeryVariable = this.handleMarketTypeAndParams("fetchTickers", market, parameters);
        var marketType = ((IList<object>) marketTypequeryVariable)[0];
        var query = ((IList<object>) marketTypequeryVariable)[1];
        object response = null;
        if (isTrue(isEqual(marketType, "swap")))
        {
            response = await this.v2PublicGetFuturesTicker(query);
        } else
        {
            response = await this.v2PublicGetSpotTicker(query);
        }
        //
        // Spot
        //
        //     {
        //         "code": 0,
        //         "data": [
        //             {
        //                 "close": "62393.47",
        //                 "high": "64106.41",
        //                 "last": "62393.47",
        //                 "low": "59650.01",
        //                 "market": "BTCUSDT",
        //                 "open": "61616.15",
        //                 "period": 86400,
        //                 "value": "28711273.4065667262",
        //                 "volume": "461.76557205",
        //                 "volume_buy": "11.41506354",
        //                 "volume_sell": "7.3240169"
        //             }
        //         ],
        //         "message": "OK"
        //     }
        //
        // Swap
        //
        //     {
        //         "code": 0,
        //         "data": [
        //             {
        //                 "close": "62480.08",
        //                 "high": "64100",
        //                 "index_price": "62443.05",
        //                 "last": "62480.08",
        //                 "low": "59600",
        //                 "mark_price": "62443.05",
        //                 "market": "BTCUSDT",
        //                 "open": "61679.98",
        //                 "period": 86400,
        //                 "value": "180226025.69791713065326633165",
        //                 "volume": "2900.2218",
        //                 "volume_buy": "7.3847",
        //                 "volume_sell": "6.1249"
        //             }
        //         ],
        //         "message": "OK"
        //     }
        //
        object data = this.safeList(response, "data", new List<object>() {});
        return this.parseTickers(data, symbols);
    }

    public async override Task<object> fetchTime(object parameters = null)
    {
        /**
        * @method
        * @name coinex#fetchTime
        * @description fetches the current integer timestamp in milliseconds from the exchange server
        * @see https://docs.coinex.com/api/v2/common/http/time
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {int} the current integer timestamp in milliseconds from the exchange server
        */
        parameters ??= new Dictionary<string, object>();
        object response = await this.v2PublicGetTime(parameters);
        //
        //     {
        //         "code": 0,
        //         "data": {
        //             "timestamp": 1711699867777
        //         },
        //         "message": "OK"
        //     }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        return this.safeInteger(data, "timestamp");
    }

    public async override Task<object> fetchOrderBook(object symbol, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name coinex#fetchOrderBook
        * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
        * @see https://docs.coinex.com/api/v2/spot/market/http/list-market-depth
        * @see https://docs.coinex.com/api/v2/futures/market/http/list-market-depth
        * @param {string} symbol unified symbol of the market to fetch the order book for
        * @param {int} [limit] the maximum amount of order book entries to return
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
        */
        limit ??= 20;
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        if (isTrue(isEqual(limit, null)))
        {
            limit = 20; // default
        }
        object request = new Dictionary<string, object>() {
            { "market", getValue(market, "id") },
            { "limit", limit },
            { "interval", "0" },
        };
        object response = null;
        if (isTrue(getValue(market, "swap")))
        {
            response = await this.v2PublicGetFuturesDepth(this.extend(request, parameters));
        } else
        {
            response = await this.v2PublicGetSpotDepth(this.extend(request, parameters));
        }
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        object depth = this.safeDict(data, "depth", new Dictionary<string, object>() {});
        object timestamp = this.safeInteger(depth, "updated_at");
        return this.parseOrderBook(depth, symbol, timestamp);
    }

    public override object parseTrade(object trade, object market = null)
    {
        //
        // Spot and Swap fetchTrades (public)
        //
        //     {
        //         "amount": "0.00049432",
        //         "created_at": 1713849825667,
        //         "deal_id": 4137517302,
        //         "price": "66251",
        //         "side": "buy"
        //     }
        //
        // Spot and Margin fetchMyTrades (private)
        //
        //     {
        //         "amount": "0.00010087",
        //         "created_at": 1714618087585,
        //         "deal_id": 4161200602,
        //         "margin_market": "",
        //         "market": "BTCUSDT",
        //         "order_id": 117654919342,
        //         "price": "57464.04",
        //         "side": "sell"
        //     }
        //
        // Swap fetchMyTrades (private)
        //
        //     {
        //         "deal_id": 1180222387,
        //         "created_at": 1714119054558,
        //         "market": "BTCUSDT",
        //         "side": "buy",
        //         "order_id": 136915589622,
        //         "price": "64376",
        //         "amount": "0.0001"
        //     }
        //
        object timestamp = this.safeInteger(trade, "created_at");
        object defaultType = this.safeString(this.options, "defaultType");
        if (isTrue(!isEqual(market, null)))
        {
            defaultType = getValue(market, "type");
        }
        object marketId = this.safeString(trade, "market");
        market = this.safeMarket(marketId, market, null, defaultType);
        return this.safeTrade(new Dictionary<string, object>() {
            { "info", trade },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "symbol", getValue(market, "symbol") },
            { "id", this.safeString(trade, "deal_id") },
            { "order", this.safeString(trade, "order_id") },
            { "type", null },
            { "side", this.safeString(trade, "side") },
            { "takerOrMaker", null },
            { "price", this.safeString(trade, "price") },
            { "amount", this.safeString(trade, "amount") },
            { "cost", this.safeString(trade, "deal_money") },
            { "fee", null },
        }, market);
    }

    public async override Task<object> fetchTrades(object symbol, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name coinex#fetchTrades
        * @description get the list of the most recent trades for a particular symbol
        * @see https://docs.coinex.com/api/v2/spot/market/http/list-market-deals
        * @see https://docs.coinex.com/api/v2/futures/market/http/list-market-deals
        * @param {string} symbol unified symbol of the market to fetch trades for
        * @param {int} [since] timestamp in ms of the earliest trade to fetch
        * @param {int} [limit] the maximum amount of trades to fetch
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "market", getValue(market, "id") },
        };
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        object response = null;
        if (isTrue(getValue(market, "swap")))
        {
            response = await this.v2PublicGetFuturesDeals(this.extend(request, parameters));
        } else
        {
            response = await this.v2PublicGetSpotDeals(this.extend(request, parameters));
        }
        //
        // Spot and Swap
        //
        //     {
        //         "code": 0,
        //         "data": [
        //             {
        //                 "amount": "0.00049432",
        //                 "created_at": 1713849825667,
        //                 "deal_id": 4137517302,
        //                 "price": "66251",
        //                 "side": "buy"
        //             },
        //         ],
        //         "message": "OK"
        //     }
        //
        return this.parseTrades(getValue(response, "data"), market, since, limit);
    }

    public async override Task<object> fetchTradingFee(object symbol, object parameters = null)
    {
        /**
        * @method
        * @name coinex#fetchTradingFee
        * @description fetch the trading fees for a market
        * @see https://docs.coinex.com/api/v2/spot/market/http/list-market
        * @see https://docs.coinex.com/api/v2/futures/market/http/list-market
        * @param {string} symbol unified market symbol
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [fee structure]{@link https://docs.ccxt.com/#/?id=fee-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "market", getValue(market, "id") },
        };
        object response = null;
        if (isTrue(getValue(market, "spot")))
        {
            response = await this.v2PublicGetSpotMarket(this.extend(request, parameters));
        } else
        {
            response = await this.v2PublicGetFuturesMarket(this.extend(request, parameters));
        }
        object data = this.safeList(response, "data", new List<object>() {});
        object result = this.safeDict(data, 0, new Dictionary<string, object>() {});
        return this.parseTradingFee(result, market);
    }

    public async override Task<object> fetchTradingFees(object parameters = null)
    {
        /**
        * @method
        * @name coinex#fetchTradingFees
        * @description fetch the trading fees for multiple markets
        * @see https://docs.coinex.com/api/v2/spot/market/http/list-market
        * @see https://docs.coinex.com/api/v2/futures/market/http/list-market
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a dictionary of [fee structures]{@link https://docs.ccxt.com/#/?id=fee-structure} indexed by market symbols
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object type = null;
        var typeparametersVariable = this.handleMarketTypeAndParams("fetchTradingFees", null, parameters);
        type = ((IList<object>)typeparametersVariable)[0];
        parameters = ((IList<object>)typeparametersVariable)[1];
        object response = null;
        if (isTrue(isEqual(type, "swap")))
        {
            response = await this.v2PublicGetFuturesMarket(parameters);
        } else
        {
            response = await this.v2PublicGetSpotMarket(parameters);
        }
        object data = this.safeList(response, "data", new List<object>() {});
        object result = new Dictionary<string, object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
        {
            object entry = getValue(data, i);
            object marketId = this.safeString(entry, "market");
            object market = this.safeMarket(marketId, null, null, type);
            object symbol = getValue(market, "symbol");
            ((IDictionary<string,object>)result)[(string)symbol] = this.parseTradingFee(entry, market);
        }
        return result;
    }

    public virtual object parseTradingFee(object fee, object market = null)
    {
        object marketId = this.safeValue(fee, "market");
        object symbol = this.safeSymbol(marketId, market);
        return new Dictionary<string, object>() {
            { "info", fee },
            { "symbol", symbol },
            { "maker", this.safeNumber(fee, "maker_fee_rate") },
            { "taker", this.safeNumber(fee, "taker_fee_rate") },
            { "percentage", true },
            { "tierBased", true },
        };
    }

    public override object parseOHLCV(object ohlcv, object market = null)
    {
        //
        //     {
        //         "close": "66999.95",
        //         "created_at": 1713934620000,
        //         "high": "66999.95",
        //         "low": "66988.53",
        //         "market": "BTCUSDT",
        //         "open": "66988.53",
        //         "value": "0.1572393",        // base volume
        //         "volume": "10533.2501364336" // quote volume
        //     }
        //
        return new List<object> {this.safeInteger(ohlcv, "created_at"), this.safeNumber(ohlcv, "open"), this.safeNumber(ohlcv, "high"), this.safeNumber(ohlcv, "low"), this.safeNumber(ohlcv, "close"), this.safeNumber(ohlcv, "value")};
    }

    public async override Task<object> fetchOHLCV(object symbol, object timeframe = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name coinex#fetchOHLCV
        * @description fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
        * @see https://docs.coinex.com/api/v2/spot/market/http/list-market-kline
        * @see https://docs.coinex.com/api/v2/futures/market/http/list-market-kline
        * @param {string} symbol unified symbol of the market to fetch OHLCV data for
        * @param {string} timeframe the length of time each candle represents
        * @param {int} [since] timestamp in ms of the earliest candle to fetch
        * @param {int} [limit] the maximum amount of candles to fetch
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
        */
        timeframe ??= "1m";
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "market", getValue(market, "id") },
            { "period", this.safeString(this.timeframes, timeframe, timeframe) },
        };
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        object response = null;
        if (isTrue(getValue(market, "swap")))
        {
            response = await this.v2PublicGetFuturesKline(this.extend(request, parameters));
        } else
        {
            response = await this.v2PublicGetSpotKline(this.extend(request, parameters));
        }
        //
        // Spot and Swap
        //
        //     {
        //         "code": 0,
        //         "data": [
        //             {
        //                 "close": "66999.95",
        //                 "created_at": 1713934620000,
        //                 "high": "66999.95",
        //                 "low": "66988.53",
        //                 "market": "BTCUSDT",
        //                 "open": "66988.53",
        //                 "value": "0.1572393",
        //                 "volume": "10533.2501364336"
        //             },
        //         ],
        //         "message": "OK"
        //     }
        //
        object data = this.safeList(response, "data", new List<object>() {});
        return this.parseOHLCVs(data, market, timeframe, since, limit);
    }

    public async virtual Task<object> fetchMarginBalance(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.v2PrivateGetAssetsMarginBalance(parameters);
        //
        //     {
        //         "data": [
        //             {
        //                 "margin_account": "BTCUSDT",
        //                 "base_ccy": "BTC",
        //                 "quote_ccy": "USDT",
        //                 "available": {
        //                     "base_ccy": "0.00000026",
        //                     "quote_ccy": "0"
        //                 },
        //                 "frozen": {
        //                     "base_ccy": "0",
        //                     "quote_ccy": "0"
        //                 },
        //                 "repaid": {
        //                     "base_ccy": "0",
        //                     "quote_ccy": "0"
        //                 },
        //                 "interest": {
        //                     "base_ccy": "0",
        //                     "quote_ccy": "0"
        //                 },
        //                 "rik_rate": "",
        //                 "liq_price": ""
        //             },
        //         ],
        //         "code": 0,
        //         "message": "OK"
        //     }
        //
        object result = new Dictionary<string, object>() {
            { "info", response },
        };
        object balances = this.safeList(response, "data", new List<object>() {});
        for (object i = 0; isLessThan(i, getArrayLength(balances)); postFixIncrement(ref i))
        {
            object entry = getValue(balances, i);
            object free = this.safeDict(entry, "available", new Dictionary<string, object>() {});
            object used = this.safeDict(entry, "frozen", new Dictionary<string, object>() {});
            object loan = this.safeDict(entry, "repaid", new Dictionary<string, object>() {});
            object interest = this.safeDict(entry, "interest", new Dictionary<string, object>() {});
            object baseAccount = this.account();
            object baseCurrencyId = this.safeString(entry, "base_ccy");
            object baseCurrencyCode = this.safeCurrencyCode(baseCurrencyId);
            ((IDictionary<string,object>)baseAccount)["free"] = this.safeString(free, "base_ccy");
            ((IDictionary<string,object>)baseAccount)["used"] = this.safeString(used, "base_ccy");
            object baseDebt = this.safeString(loan, "base_ccy");
            object baseInterest = this.safeString(interest, "base_ccy");
            ((IDictionary<string,object>)baseAccount)["debt"] = Precise.stringAdd(baseDebt, baseInterest);
            ((IDictionary<string,object>)result)[(string)baseCurrencyCode] = baseAccount;
        }
        return this.safeBalance(result);
    }

    public async virtual Task<object> fetchSpotBalance(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.v2PrivateGetAssetsSpotBalance(parameters);
        //
        //     {
        //         "code": 0,
        //         "data": [
        //             {
        //                 "available": "0.00000046",
        //                 "ccy": "USDT",
        //                 "frozen": "0"
        //             }
        //         ],
        //         "message": "OK"
        //     }
        //
        object result = new Dictionary<string, object>() {
            { "info", response },
        };
        object balances = this.safeList(response, "data", new List<object>() {});
        for (object i = 0; isLessThan(i, getArrayLength(balances)); postFixIncrement(ref i))
        {
            object entry = getValue(balances, i);
            object currencyId = this.safeString(entry, "ccy");
            object code = this.safeCurrencyCode(currencyId);
            object account = this.account();
            ((IDictionary<string,object>)account)["free"] = this.safeString(entry, "available");
            ((IDictionary<string,object>)account)["used"] = this.safeString(entry, "frozen");
            ((IDictionary<string,object>)result)[(string)code] = account;
        }
        return this.safeBalance(result);
    }

    public async virtual Task<object> fetchSwapBalance(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.v2PrivateGetAssetsFuturesBalance(parameters);
        //
        //     {
        //         "code": 0,
        //         "data": [
        //             {
        //                 "available": "0.00000046",
        //                 "ccy": "USDT",
        //                 "frozen": "0",
        //                 "margin": "0",
        //                 "transferrable": "0.00000046",
        //                 "unrealized_pnl": "0"
        //             }
        //         ],
        //         "message": "OK"
        //     }
        //
        object result = new Dictionary<string, object>() {
            { "info", response },
        };
        object balances = this.safeList(response, "data", new List<object>() {});
        for (object i = 0; isLessThan(i, getArrayLength(balances)); postFixIncrement(ref i))
        {
            object entry = getValue(balances, i);
            object currencyId = this.safeString(entry, "ccy");
            object code = this.safeCurrencyCode(currencyId);
            object account = this.account();
            ((IDictionary<string,object>)account)["free"] = this.safeString(entry, "available");
            ((IDictionary<string,object>)account)["used"] = this.safeString(entry, "frozen");
            ((IDictionary<string,object>)result)[(string)code] = account;
        }
        return this.safeBalance(result);
    }

    public async virtual Task<object> fetchFinancialBalance(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.v2PrivateGetAssetsFinancialBalance(parameters);
        //
        //     {
        //         "code": 0,
        //         "data": [
        //             {
        //                 "available": "0.00000046",
        //                 "ccy": "USDT",
        //                 "frozen": "0"
        //             }
        //         ],
        //         "message": "OK"
        //     }
        //
        object result = new Dictionary<string, object>() {
            { "info", response },
        };
        object balances = this.safeList(response, "data", new List<object>() {});
        for (object i = 0; isLessThan(i, getArrayLength(balances)); postFixIncrement(ref i))
        {
            object entry = getValue(balances, i);
            object currencyId = this.safeString(entry, "ccy");
            object code = this.safeCurrencyCode(currencyId);
            object account = this.account();
            ((IDictionary<string,object>)account)["free"] = this.safeString(entry, "available");
            ((IDictionary<string,object>)account)["used"] = this.safeString(entry, "frozen");
            ((IDictionary<string,object>)result)[(string)code] = account;
        }
        return this.safeBalance(result);
    }

    public async override Task<object> fetchBalance(object parameters = null)
    {
        /**
        * @method
        * @name coinex#fetchBalance
        * @description query for balance and get the amount of funds available for trading or funds locked in orders
        * @see https://docs.coinex.com/api/v2/assets/balance/http/get-spot-balance         // spot
        * @see https://docs.coinex.com/api/v2/assets/balance/http/get-futures-balance      // swap
        * @see https://docs.coinex.com/api/v2/assets/balance/http/get-marigin-balance      // margin
        * @see https://docs.coinex.com/api/v2/assets/balance/http/get-financial-balance    // financial
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {string} [params.type] 'margin', 'swap', 'financial', or 'spot'
        * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
        */
        parameters ??= new Dictionary<string, object>();
        object marketType = null;
        var marketTypeparametersVariable = this.handleMarketTypeAndParams("fetchBalance", null, parameters);
        marketType = ((IList<object>)marketTypeparametersVariable)[0];
        parameters = ((IList<object>)marketTypeparametersVariable)[1];
        object marginMode = null;
        var marginModeparametersVariable = this.handleMarginModeAndParams("fetchBalance", parameters);
        marginMode = ((IList<object>)marginModeparametersVariable)[0];
        parameters = ((IList<object>)marginModeparametersVariable)[1];
        marketType = ((bool) isTrue((!isEqual(marginMode, null)))) ? "margin" : marketType;
        parameters = this.omit(parameters, "margin");
        if (isTrue(isEqual(marketType, "margin")))
        {
            return await this.fetchMarginBalance(parameters);
        } else if (isTrue(isEqual(marketType, "swap")))
        {
            return await this.fetchSwapBalance(parameters);
        } else if (isTrue(isEqual(marketType, "financial")))
        {
            return await this.fetchFinancialBalance(parameters);
        } else
        {
            return await this.fetchSpotBalance(parameters);
        }
    }

    public virtual object parseOrderStatus(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "rejected", "rejected" },
            { "open", "open" },
            { "not_deal", "open" },
            { "part_deal", "open" },
            { "done", "closed" },
            { "cancel", "canceled" },
        };
        return this.safeString(statuses, status, status);
    }

    public override object parseOrder(object order, object market = null)
    {
        //
        // Spot and Margin createOrder, createOrders, editOrder, cancelOrders, cancelOrder, fetchOpenOrders
        //
        //     {
        //         "amount": "0.0001",
        //         "base_fee": "0",
        //         "ccy": "BTC",
        //         "client_id": "x-167673045-a0a3c6461459a801",
        //         "created_at": 1714114386250,
        //         "discount_fee": "0",
        //         "filled_amount": "0",
        //         "filled_value": "0",
        //         "last_fill_amount": "0",
        //         "last_fill_price": "0",
        //         "maker_fee_rate": "0.002",
        //         "market": "BTCUSDT",
        //         "market_type": "SPOT",
        //         "order_id": 117178743547,
        //         "price": "61000",
        //         "quote_fee": "0",
        //         "side": "buy",
        //         "taker_fee_rate": "0.002",
        //         "type": "limit",
        //         "unfilled_amount": "0.0001",
        //         "updated_at": 1714114386250
        //     }
        //
        // Spot and Margin fetchClosedOrders
        //
        //     {
        //         "order_id": 117180532345,
        //         "market": "BTCUSDT",
        //         "market_type": "SPOT",
        //         "side": "sell",
        //         "type": "market",
        //         "ccy": "BTC",
        //         "amount": "0.00015484",
        //         "price": "0",
        //         "client_id": "",
        //         "created_at": 1714116494219,
        //         "updated_at": 0,
        //         "base_fee": "0",
        //         "quote_fee": "0.0199931699632",
        //         "discount_fee": "0",
        //         "maker_fee_rate": "0",
        //         "taker_fee_rate": "0.002",
        //         "unfilled_amount": "0",
        //         "filled_amount": "0.00015484",
        //         "filled_value": "9.9965849816"
        //     }
        //
        // Spot, Margin and Swap trigger createOrder, createOrders, editOrder
        //
        //     {
        //         "stop_id": 117180138153
        //     }
        //
        // Swap createOrder, createOrders, editOrder, cancelOrders, cancelOrder, fetchOpenOrders, fetchClosedOrders
        //
        //     {
        //         "amount": "0.0001",
        //         "client_id": "x-167673045-1471b81d747080a0",
        //         "created_at": 1714116769986,
        //         "fee": "0",
        //         "fee_ccy": "USDT",
        //         "filled_amount": "0",
        //         "filled_value": "0",
        //         "last_filled_amount": "0",
        //         "last_filled_price": "0",
        //         "maker_fee_rate": "0.0003",
        //         "market": "BTCUSDT",
        //         "market_type": "FUTURES",
        //         "order_id": 136913377780,
        //         "price": "61000.42",
        //         "realized_pnl": "0",
        //         "side": "buy",
        //         "taker_fee_rate": "0.0005",
        //         "type": "limit",
        //         "unfilled_amount": "0.0001",
        //         "updated_at": 1714116769986
        //     }
        //
        // Swap stopLossPrice and takeProfitPrice createOrder
        //
        //     {
        //         "adl_level": 1,
        //         "ath_margin_size": "2.14586666",
        //         "ath_position_amount": "0.0001",
        //         "avg_entry_price": "64376",
        //         "bkr_price": "0",
        //         "close_avbl": "0.0001",
        //         "cml_position_value": "6.4376",
        //         "created_at": 1714119054558,
        //         "leverage": "3",
        //         "liq_price": "0",
        //         "maintenance_margin_rate": "0.005",
        //         "maintenance_margin_value": "0.03218632",
        //         "margin_avbl": "2.14586666",
        //         "margin_mode": "cross",
        //         "market": "BTCUSDT",
        //         "market_type": "FUTURES",
        //         "max_position_value": "6.4376",
        //         "open_interest": "0.0001",
        //         "position_id": 303884204,
        //         "position_margin_rate": "3.10624785634397912265",
        //         "realized_pnl": "-0.0032188",
        //         "settle_price": "64376",
        //         "settle_value": "6.4376",
        //         "side": "long",
        //         "stop_loss_price": "62000",
        //         "stop_loss_type": "latest_price",
        //         "take_profit_price": "0",
        //         "take_profit_type": "",
        //         "unrealized_pnl": "0",
        //         "updated_at": 1714119054559
        //     }
        //
        // Swap fetchOrder
        //
        //     {
        //         "amount": "0.0001",
        //         "client_id": "x-167673045-da5f31dcd478a829",
        //         "created_at": 1714460987164,
        //         "fee": "0",
        //         "fee_ccy": "USDT",
        //         "filled_amount": "0",
        //         "filled_value": "0",
        //         "last_filled_amount": "0",
        //         "last_filled_price": "0",
        //         "maker_fee_rate": "0.0003",
        //         "market": "BTCUSDT",
        //         "market_type": "FUTURES",
        //         "order_id": 137319868771,
        //         "price": "61000",
        //         "realized_pnl": "0",
        //         "side": "buy",
        //         "status": "open",
        //         "taker_fee_rate": "0.0005",
        //         "type": "limit",
        //         "unfilled_amount": "0.0001",
        //         "updated_at": 1714460987164
        //     }
        //
        // Spot and Margin fetchOrder
        //
        //     {
        //         "amount": "0.0001",
        //         "base_fee": "0",
        //         "ccy": "BTC",
        //         "client_id": "x-167673045-da918d6724e3af81",
        //         "created_at": 1714461638958,
        //         "discount_fee": "0",
        //         "filled_amount": "0",
        //         "filled_value": "0",
        //         "last_fill_amount": "0",
        //         "last_fill_price": "0",
        //         "maker_fee_rate": "0.002",
        //         "market": "BTCUSDT",
        //         "market_type": "SPOT",
        //         "order_id": 117492012985,
        //         "price": "61000",
        //         "quote_fee": "0",
        //         "side": "buy",
        //         "status": "open",
        //         "taker_fee_rate": "0.002",
        //         "type": "limit",
        //         "unfilled_amount": "0.0001",
        //         "updated_at": 1714461638958
        //     }
        //
        // Swap trigger fetchOpenOrders, fetchClosedOrders - Spot and Swap trigger cancelOrders, cancelOrder
        //
        //     {
        //         "amount": "0.0001",
        //         "client_id": "x-167673045-a7d7714c6478acf6",
        //         "created_at": 1714187923820,
        //         "market": "BTCUSDT",
        //         "market_type": "FUTURES",
        //         "price": "61000",
        //         "side": "buy",
        //         "stop_id": 136984426097,
        //         "trigger_direction": "higher",
        //         "trigger_price": "62000",
        //         "trigger_price_type": "latest_price",
        //         "type": "limit",
        //         "updated_at": 1714187974363
        //     }
        //
        // Spot and Margin trigger fetchOpenOrders, fetchClosedOrders
        //
        //     {
        //         "stop_id": 117586439530,
        //         "market": "BTCUSDT",
        //         "market_type": "SPOT",
        //         "ccy": "BTC",
        //         "side": "buy",
        //         "type": "limit",
        //         "amount": "0.0001",
        //         "price": "51000",
        //         "trigger_price": "52000",
        //         "trigger_direction": "higher",
        //         "trigger_price_type": "mark_price",
        //         "client_id": "x-167673045-df61777094c69312",
        //         "created_at": 1714551237335,
        //         "updated_at": 1714551237335
        //     }
        //
        object rawStatus = this.safeString(order, "status");
        object timestamp = this.safeInteger(order, "created_at");
        object updatedTimestamp = this.safeInteger(order, "updated_at");
        if (isTrue(isEqual(updatedTimestamp, 0)))
        {
            updatedTimestamp = timestamp;
        }
        object marketId = this.safeString(order, "market");
        object defaultType = this.safeString(this.options, "defaultType");
        object orderType = this.safeStringLower(order, "market_type", defaultType);
        if (isTrue(isEqual(orderType, "futures")))
        {
            orderType = "swap";
        }
        object marketType = ((bool) isTrue((isEqual(orderType, "swap")))) ? "swap" : "spot";
        market = this.safeMarket(marketId, market, null, marketType);
        object feeCurrencyId = this.safeString(order, "fee_ccy");
        object feeCurrency = this.safeCurrencyCode(feeCurrencyId);
        if (isTrue(isEqual(feeCurrency, null)))
        {
            feeCurrency = getValue(market, "quote");
        }
        object side = this.safeString(order, "side");
        if (isTrue(isEqual(side, "long")))
        {
            side = "buy";
        } else if (isTrue(isEqual(side, "short")))
        {
            side = "sell";
        }
        object clientOrderId = this.safeString(order, "client_id");
        if (isTrue(isEqual(clientOrderId, "")))
        {
            clientOrderId = null;
        }
        return this.safeOrder(new Dictionary<string, object>() {
            { "id", this.safeStringN(order, new List<object>() {"position_id", "order_id", "stop_id"}) },
            { "clientOrderId", clientOrderId },
            { "datetime", this.iso8601(timestamp) },
            { "timestamp", timestamp },
            { "lastTradeTimestamp", updatedTimestamp },
            { "status", this.parseOrderStatus(rawStatus) },
            { "symbol", getValue(market, "symbol") },
            { "type", this.safeString(order, "type") },
            { "timeInForce", null },
            { "postOnly", null },
            { "reduceOnly", null },
            { "side", side },
            { "price", this.safeString(order, "price") },
            { "stopPrice", this.safeString(order, "trigger_price") },
            { "triggerPrice", this.safeString(order, "trigger_price") },
            { "takeProfitPrice", this.safeNumber(order, "take_profit_price") },
            { "stopLossPrice", this.safeNumber(order, "stop_loss_price") },
            { "cost", this.safeString(order, "filled_value") },
            { "average", this.safeString(order, "avg_entry_price") },
            { "amount", this.safeString(order, "amount") },
            { "filled", this.safeString(order, "filled_amount") },
            { "remaining", this.safeString(order, "unfilled_amount") },
            { "trades", null },
            { "fee", new Dictionary<string, object>() {
                { "currency", feeCurrency },
                { "cost", this.safeString2(order, "quote_fee", "fee") },
            } },
            { "info", order },
        }, market);
    }

    public async override Task<object> createMarketBuyOrderWithCost(object symbol, object cost, object parameters = null)
    {
        /**
        * @method
        * @name coinex#createMarketBuyOrderWithCost
        * @description create a market buy order by providing the symbol and cost
        * @see https://viabtc.github.io/coinex_api_en_doc/spot/#docsspot003_trade003_market_order
        * @see https://docs.coinex.com/api/v2/spot/order/http/put-order
        * @param {string} symbol unified symbol of the market to create an order in
        * @param {float} cost how much you want to trade in units of the quote currency
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        if (!isTrue(getValue(market, "spot")))
        {
            throw new NotSupported ((string)add(this.id, " createMarketBuyOrderWithCost() supports spot orders only")) ;
        }
        ((IDictionary<string,object>)parameters)["createMarketBuyOrderRequiresPrice"] = false;
        return await this.createOrder(symbol, "market", "buy", cost, null, parameters);
    }

    public virtual object createOrderRequest(object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object market = this.market(symbol);
        object swap = getValue(market, "swap");
        object clientOrderId = this.safeString2(parameters, "client_id", "clientOrderId");
        object stopPrice = this.safeString2(parameters, "stopPrice", "triggerPrice");
        object stopLossPrice = this.safeString(parameters, "stopLossPrice");
        object takeProfitPrice = this.safeString(parameters, "takeProfitPrice");
        object option = this.safeString(parameters, "option");
        object isMarketOrder = isEqual(type, "market");
        object postOnly = this.isPostOnly(isMarketOrder, isEqual(option, "maker_only"), parameters);
        object timeInForceRaw = this.safeStringUpper(parameters, "timeInForce");
        object reduceOnly = this.safeBool(parameters, "reduceOnly");
        if (isTrue(reduceOnly))
        {
            if (!isTrue(getValue(market, "swap")))
            {
                throw new InvalidOrder ((string)add(add(add(this.id, " createOrder() does not support reduceOnly for "), getValue(market, "type")), " orders, reduceOnly orders are supported for swap markets only")) ;
            }
        }
        object request = new Dictionary<string, object>() {
            { "market", getValue(market, "id") },
        };
        if (isTrue(isEqual(clientOrderId, null)))
        {
            object defaultId = "x-167673045";
            object brokerId = this.safeString(this.options, "brokerId", defaultId);
            ((IDictionary<string,object>)request)["client_id"] = add(add(brokerId, "-"), this.uuid16());
        } else
        {
            ((IDictionary<string,object>)request)["client_id"] = clientOrderId;
        }
        if (isTrue(isTrue((isEqual(stopLossPrice, null))) && isTrue((isEqual(takeProfitPrice, null)))))
        {
            if (!isTrue(reduceOnly))
            {
                ((IDictionary<string,object>)request)["side"] = side;
            }
            object requestType = type;
            if (isTrue(postOnly))
            {
                requestType = "maker_only";
            } else if (isTrue(!isEqual(timeInForceRaw, null)))
            {
                if (isTrue(isEqual(timeInForceRaw, "IOC")))
                {
                    requestType = "ioc";
                } else if (isTrue(isEqual(timeInForceRaw, "FOK")))
                {
                    requestType = "fok";
                }
            }
            if (!isTrue(isMarketOrder))
            {
                ((IDictionary<string,object>)request)["price"] = this.priceToPrecision(symbol, price);
            }
            ((IDictionary<string,object>)request)["type"] = requestType;
        }
        if (isTrue(swap))
        {
            ((IDictionary<string,object>)request)["market_type"] = "FUTURES";
            if (isTrue(isTrue(stopLossPrice) || isTrue(takeProfitPrice)))
            {
                if (isTrue(stopLossPrice))
                {
                    ((IDictionary<string,object>)request)["stop_loss_price"] = this.priceToPrecision(symbol, stopLossPrice);
                    ((IDictionary<string,object>)request)["stop_loss_type"] = this.safeString(parameters, "stop_type", "latest_price");
                } else if (isTrue(takeProfitPrice))
                {
                    ((IDictionary<string,object>)request)["take_profit_price"] = this.priceToPrecision(symbol, takeProfitPrice);
                    ((IDictionary<string,object>)request)["take_profit_type"] = this.safeString(parameters, "stop_type", "latest_price");
                }
            } else
            {
                ((IDictionary<string,object>)request)["amount"] = this.amountToPrecision(symbol, amount);
                if (isTrue(!isEqual(stopPrice, null)))
                {
                    ((IDictionary<string,object>)request)["trigger_price"] = this.priceToPrecision(symbol, stopPrice);
                    ((IDictionary<string,object>)request)["trigger_price_type"] = this.safeString(parameters, "stop_type", "latest_price");
                }
            }
        } else
        {
            object marginMode = null;
            var marginModeparametersVariable = this.handleMarginModeAndParams("createOrder", parameters);
            marginMode = ((IList<object>)marginModeparametersVariable)[0];
            parameters = ((IList<object>)marginModeparametersVariable)[1];
            if (isTrue(!isEqual(marginMode, null)))
            {
                ((IDictionary<string,object>)request)["market_type"] = "MARGIN";
            } else
            {
                ((IDictionary<string,object>)request)["market_type"] = "SPOT";
            }
            if (isTrue(isTrue((isEqual(type, "market"))) && isTrue((isEqual(side, "buy")))))
            {
                object createMarketBuyOrderRequiresPrice = true;
                var createMarketBuyOrderRequiresPriceparametersVariable = this.handleOptionAndParams(parameters, "createOrder", "createMarketBuyOrderRequiresPrice", true);
                createMarketBuyOrderRequiresPrice = ((IList<object>)createMarketBuyOrderRequiresPriceparametersVariable)[0];
                parameters = ((IList<object>)createMarketBuyOrderRequiresPriceparametersVariable)[1];
                object cost = this.safeNumber(parameters, "cost");
                parameters = this.omit(parameters, "cost");
                if (isTrue(createMarketBuyOrderRequiresPrice))
                {
                    if (isTrue(isTrue((isEqual(price, null))) && isTrue((isEqual(cost, null)))))
                    {
                        throw new InvalidOrder ((string)add(this.id, " createOrder() requires the price argument for market buy orders to calculate the total cost to spend (amount * price), alternatively set the createMarketBuyOrderRequiresPrice option or param to false and pass the cost to spend in the amount argument")) ;
                    } else
                    {
                        object amountString = this.numberToString(amount);
                        object priceString = this.numberToString(price);
                        object quoteAmount = this.parseToNumeric(Precise.stringMul(amountString, priceString));
                        object costRequest = ((bool) isTrue((!isEqual(cost, null)))) ? cost : quoteAmount;
                        ((IDictionary<string,object>)request)["amount"] = this.costToPrecision(symbol, costRequest);
                    }
                } else
                {
                    ((IDictionary<string,object>)request)["amount"] = this.costToPrecision(symbol, amount);
                }
            } else
            {
                ((IDictionary<string,object>)request)["amount"] = this.amountToPrecision(symbol, amount);
            }
            if (isTrue(!isEqual(stopPrice, null)))
            {
                ((IDictionary<string,object>)request)["trigger_price"] = this.priceToPrecision(symbol, stopPrice);
            }
        }
        parameters = this.omit(parameters, new List<object>() {"reduceOnly", "timeInForce", "postOnly", "stopPrice", "triggerPrice", "stopLossPrice", "takeProfitPrice"});
        return this.extend(request, parameters);
    }

    public async override Task<object> createOrder(object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        /**
        * @method
        * @name coinex#createOrder
        * @description create a trade order
        * @see https://docs.coinex.com/api/v2/spot/order/http/put-order
        * @see https://docs.coinex.com/api/v2/spot/order/http/put-stop-order
        * @see https://docs.coinex.com/api/v2/futures/order/http/put-order
        * @see https://docs.coinex.com/api/v2/futures/order/http/put-stop-order
        * @see https://docs.coinex.com/api/v2/futures/position/http/close-position
        * @see https://docs.coinex.com/api/v2/futures/position/http/set-position-stop-loss
        * @see https://docs.coinex.com/api/v2/futures/position/http/set-position-take-profit
        * @param {string} symbol unified symbol of the market to create an order in
        * @param {string} type 'market' or 'limit'
        * @param {string} side 'buy' or 'sell'
        * @param {float} amount how much you want to trade in units of the base currency
        * @param {float} [price] the price at which the order is to be fullfilled, in units of the quote currency, ignored in market orders
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {float} [params.triggerPrice] price to trigger stop orders
        * @param {float} [params.stopLossPrice] price to trigger stop loss orders
        * @param {float} [params.takeProfitPrice] price to trigger take profit orders
        * @param {string} [params.timeInForce] 'GTC', 'IOC', 'FOK', 'PO'
        * @param {boolean} [params.postOnly] set to true if you wish to make a post only order
        * @param {boolean} [params.reduceOnly] *contract only* indicates if this order is to reduce the size of a position
        * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object reduceOnly = this.safeBool(parameters, "reduceOnly");
        object triggerPrice = this.safeString2(parameters, "stopPrice", "triggerPrice");
        object stopLossTriggerPrice = this.safeString(parameters, "stopLossPrice");
        object takeProfitTriggerPrice = this.safeString(parameters, "takeProfitPrice");
        object isTriggerOrder = !isEqual(triggerPrice, null);
        object isStopLossTriggerOrder = !isEqual(stopLossTriggerPrice, null);
        object isTakeProfitTriggerOrder = !isEqual(takeProfitTriggerPrice, null);
        object isStopLossOrTakeProfitTrigger = isTrue(isStopLossTriggerOrder) || isTrue(isTakeProfitTriggerOrder);
        object request = this.createOrderRequest(symbol, type, side, amount, price, parameters);
        object response = null;
        if (isTrue(getValue(market, "spot")))
        {
            if (isTrue(isTriggerOrder))
            {
                response = await this.v2PrivatePostSpotStopOrder(request);
            } else
            {
                response = await this.v2PrivatePostSpotOrder(request);
            }
        } else
        {
            if (isTrue(isTriggerOrder))
            {
                response = await this.v2PrivatePostFuturesStopOrder(request);
            } else if (isTrue(isStopLossOrTakeProfitTrigger))
            {
                if (isTrue(isStopLossTriggerOrder))
                {
                    response = await this.v2PrivatePostFuturesSetPositionStopLoss(request);
                } else if (isTrue(isTakeProfitTriggerOrder))
                {
                    response = await this.v2PrivatePostFuturesSetPositionTakeProfit(request);
                }
            } else
            {
                if (isTrue(reduceOnly))
                {
                    response = await this.v2PrivatePostFuturesClosePosition(request);
                } else
                {
                    response = await this.v2PrivatePostFuturesOrder(request);
                }
            }
        }
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        return this.parseOrder(data, market);
    }

    public async override Task<object> createOrders(object orders, object parameters = null)
    {
        /**
        * @method
        * @name coinex#createOrders
        * @description create a list of trade orders (all orders should be of the same symbol)
        * @see https://docs.coinex.com/api/v2/spot/order/http/put-multi-order
        * @see https://docs.coinex.com/api/v2/spot/order/http/put-multi-stop-order
        * @see https://docs.coinex.com/api/v2/futures/order/http/put-multi-order
        * @see https://docs.coinex.com/api/v2/futures/order/http/put-multi-stop-order
        * @param {Array} orders list of orders to create, each object should contain the parameters required by createOrder, namely symbol, type, side, amount, price and params
        * @param {object} [params] extra parameters specific to the api endpoint
        * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object ordersRequests = new List<object>() {};
        object symbol = null;
        object reduceOnly = false;
        object isTriggerOrder = false;
        object isStopLossOrTakeProfitTrigger = false;
        for (object i = 0; isLessThan(i, getArrayLength(orders)); postFixIncrement(ref i))
        {
            object rawOrder = getValue(orders, i);
            object marketId = this.safeString(rawOrder, "symbol");
            if (isTrue(isEqual(symbol, null)))
            {
                symbol = marketId;
            } else
            {
                if (isTrue(!isEqual(symbol, marketId)))
                {
                    throw new BadRequest ((string)add(this.id, " createOrders() requires all orders to have the same symbol")) ;
                }
            }
            object type = this.safeString(rawOrder, "type");
            object side = this.safeString(rawOrder, "side");
            object amount = this.safeValue(rawOrder, "amount");
            object price = this.safeValue(rawOrder, "price");
            object orderParams = this.safeValue(rawOrder, "params", new Dictionary<string, object>() {});
            if (isTrue(!isEqual(type, "limit")))
            {
                throw new NotSupported ((string)add(add(add(this.id, " createOrders() does not support "), type), " orders, only limit orders are accepted")) ;
            }
            reduceOnly = this.safeValue(orderParams, "reduceOnly");
            object triggerPrice = this.safeNumber2(orderParams, "stopPrice", "triggerPrice");
            object stopLossTriggerPrice = this.safeNumber(orderParams, "stopLossPrice");
            object takeProfitTriggerPrice = this.safeNumber(orderParams, "takeProfitPrice");
            isTriggerOrder = !isEqual(triggerPrice, null);
            object isStopLossTriggerOrder = !isEqual(stopLossTriggerPrice, null);
            object isTakeProfitTriggerOrder = !isEqual(takeProfitTriggerPrice, null);
            isStopLossOrTakeProfitTrigger = isTrue(isStopLossTriggerOrder) || isTrue(isTakeProfitTriggerOrder);
            object orderRequest = this.createOrderRequest(marketId, type, side, amount, price, orderParams);
            ((IList<object>)ordersRequests).Add(orderRequest);
        }
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "market", getValue(market, "id") },
            { "orders", ordersRequests },
        };
        object response = null;
        if (isTrue(getValue(market, "spot")))
        {
            if (isTrue(isTriggerOrder))
            {
                response = await this.v2PrivatePostSpotBatchStopOrder(request);
            } else
            {
                response = await this.v2PrivatePostSpotBatchOrder(request);
            }
        } else
        {
            if (isTrue(isTriggerOrder))
            {
                response = await this.v2PrivatePostFuturesBatchStopOrder(request);
            } else if (isTrue(isStopLossOrTakeProfitTrigger))
            {
                throw new NotSupported ((string)add(this.id, " createOrders() does not support stopLossPrice or takeProfitPrice orders")) ;
            } else
            {
                if (isTrue(reduceOnly))
                {
                    throw new NotSupported ((string)add(this.id, " createOrders() does not support reduceOnly orders")) ;
                } else
                {
                    response = await this.v2PrivatePostFuturesBatchOrder(request);
                }
            }
        }
        object data = this.safeList(response, "data", new List<object>() {});
        object results = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
        {
            object entry = getValue(data, i);
            object status = null;
            object code = this.safeInteger(entry, "code");
            if (isTrue(!isEqual(code, null)))
            {
                if (isTrue(!isEqual(code, 0)))
                {
                    status = "rejected";
                } else
                {
                    status = "open";
                }
            }
            object innerData = this.safeDict(entry, "data", new Dictionary<string, object>() {});
            object order = null;
            if (isTrue(isTrue(getValue(market, "spot")) && !isTrue(isTriggerOrder)))
            {
                ((IDictionary<string,object>)entry)["status"] = status;
                order = this.parseOrder(entry, market);
            } else
            {
                ((IDictionary<string,object>)innerData)["status"] = status;
                order = this.parseOrder(innerData, market);
            }
            ((IList<object>)results).Add(order);
        }
        return results;
    }

    public async virtual Task<object> cancelOrders(object ids, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name coinex#cancelOrders
        * @description cancel multiple orders
        * @see https://docs.coinex.com/api/v2/spot/order/http/cancel-batch-order
        * @see https://docs.coinex.com/api/v2/spot/order/http/cancel-batch-stop-order
        * @see https://docs.coinex.com/api/v2/futures/order/http/cancel-batch-order
        * @see https://docs.coinex.com/api/v2/futures/order/http/cancel-batch-stop-order
        * @param {string[]} ids order ids
        * @param {string} symbol unified market symbol
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {boolean} [params.trigger] set to true for canceling stop orders
        * @returns {object} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " cancelOrders() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "market", getValue(market, "id") },
        };
        object stop = this.safeBool2(parameters, "stop", "trigger");
        parameters = this.omit(parameters, new List<object>() {"stop", "trigger"});
        object response = null;
        if (isTrue(stop))
        {
            ((IDictionary<string,object>)request)["stop_ids"] = ids;
        } else
        {
            ((IDictionary<string,object>)request)["order_ids"] = ids;
        }
        if (isTrue(getValue(market, "spot")))
        {
            if (isTrue(stop))
            {
                response = await this.v2PrivatePostSpotCancelBatchStopOrder(this.extend(request, parameters));
            } else
            {
                response = await this.v2PrivatePostSpotCancelBatchOrder(this.extend(request, parameters));
            }
        } else
        {
            ((IDictionary<string,object>)request)["market_type"] = "FUTURES";
            if (isTrue(stop))
            {
                response = await this.v2PrivatePostFuturesCancelBatchStopOrder(this.extend(request, parameters));
            } else
            {
                response = await this.v2PrivatePostFuturesCancelBatchOrder(this.extend(request, parameters));
            }
        }
        object data = this.safeList(response, "data", new List<object>() {});
        object results = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
        {
            object entry = getValue(data, i);
            object item = this.safeDict(entry, "data", new Dictionary<string, object>() {});
            object order = this.parseOrder(item, market);
            ((IList<object>)results).Add(order);
        }
        return results;
    }

    public async override Task<object> editOrder(object id, object symbol, object type, object side, object amount = null, object price = null, object parameters = null)
    {
        /**
        * @method
        * @name coinex#editOrder
        * @description edit a trade order
        * @see https://docs.coinex.com/api/v2/spot/order/http/edit-order
        * @see https://docs.coinex.com/api/v2/spot/order/http/edit-stop-order
        * @see https://docs.coinex.com/api/v2/futures/order/http/edit-order
        * @see https://docs.coinex.com/api/v2/futures/order/http/edit-stop-order
        * @param {string} id order id
        * @param {string} symbol unified symbol of the market to create an order in
        * @param {string} type 'market' or 'limit'
        * @param {string} side 'buy' or 'sell'
        * @param {float} amount how much of the currency you want to trade in units of the base currency
        * @param {float} [price] the price at which the order is to be fullfilled, in units of the quote currency, ignored in market orders
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {float} [params.triggerPrice] the price to trigger stop orders
        * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " editOrder() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "market", getValue(market, "id") },
        };
        if (isTrue(!isEqual(amount, null)))
        {
            ((IDictionary<string,object>)request)["amount"] = this.amountToPrecision(symbol, amount);
        }
        if (isTrue(!isEqual(price, null)))
        {
            ((IDictionary<string,object>)request)["price"] = this.priceToPrecision(symbol, price);
        }
        object response = null;
        object triggerPrice = this.safeStringN(parameters, new List<object>() {"stopPrice", "triggerPrice", "trigger_price"});
        parameters = this.omit(parameters, new List<object>() {"stopPrice", "triggerPrice"});
        object isTriggerOrder = !isEqual(triggerPrice, null);
        if (isTrue(isTriggerOrder))
        {
            ((IDictionary<string,object>)request)["trigger_price"] = this.priceToPrecision(symbol, triggerPrice);
            ((IDictionary<string,object>)request)["stop_id"] = this.parseToNumeric(id);
        } else
        {
            ((IDictionary<string,object>)request)["order_id"] = this.parseToNumeric(id);
        }
        object marginMode = null;
        var marginModeparametersVariable = this.handleMarginModeAndParams("editOrder", parameters);
        marginMode = ((IList<object>)marginModeparametersVariable)[0];
        parameters = ((IList<object>)marginModeparametersVariable)[1];
        if (isTrue(getValue(market, "spot")))
        {
            if (isTrue(!isEqual(marginMode, null)))
            {
                ((IDictionary<string,object>)request)["market_type"] = "MARGIN";
            } else
            {
                ((IDictionary<string,object>)request)["market_type"] = "SPOT";
            }
            if (isTrue(isTriggerOrder))
            {
                response = await this.v2PrivatePostSpotModifyStopOrder(this.extend(request, parameters));
            } else
            {
                response = await this.v2PrivatePostSpotModifyOrder(this.extend(request, parameters));
            }
        } else
        {
            ((IDictionary<string,object>)request)["market_type"] = "FUTURES";
            if (isTrue(isTriggerOrder))
            {
                response = await this.v2PrivatePostFuturesModifyStopOrder(this.extend(request, parameters));
            } else
            {
                response = await this.v2PrivatePostFuturesModifyOrder(this.extend(request, parameters));
            }
        }
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        return this.parseOrder(data, market);
    }

    public async override Task<object> cancelOrder(object id, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name coinex#cancelOrder
        * @description cancels an open order
        * @see https://docs.coinex.com/api/v2/spot/order/http/cancel-order
        * @see https://docs.coinex.com/api/v2/spot/order/http/cancel-stop-order
        * @see https://docs.coinex.com/api/v2/spot/order/http/cancel-order-by-client-id
        * @see https://docs.coinex.com/api/v2/spot/order/http/cancel-stop-order-by-client-id
        * @see https://docs.coinex.com/api/v2/futures/order/http/cancel-order
        * @see https://docs.coinex.com/api/v2/futures/order/http/cancel-stop-order
        * @see https://docs.coinex.com/api/v2/futures/order/http/cancel-order-by-client-id
        * @see https://docs.coinex.com/api/v2/futures/order/http/cancel-stop-order-by-client-id
        * @param {string} id order id
        * @param {string} symbol unified symbol of the market the order was made in
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {string} [params.clientOrderId] client order id, defaults to id if not passed
        * @param {boolean} [params.trigger] set to true for canceling a trigger order
        * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " cancelOrder() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object isTriggerOrder = this.safeBool2(parameters, "stop", "trigger");
        object swap = getValue(market, "swap");
        object request = new Dictionary<string, object>() {
            { "market", getValue(market, "id") },
        };
        object marginMode = null;
        var marginModeparametersVariable = this.handleMarginModeAndParams("cancelOrder", parameters);
        marginMode = ((IList<object>)marginModeparametersVariable)[0];
        parameters = ((IList<object>)marginModeparametersVariable)[1];
        if (isTrue(swap))
        {
            ((IDictionary<string,object>)request)["market_type"] = "FUTURES";
        } else
        {
            if (isTrue(!isEqual(marginMode, null)))
            {
                ((IDictionary<string,object>)request)["market_type"] = "MARGIN";
            } else
            {
                ((IDictionary<string,object>)request)["market_type"] = "SPOT";
            }
        }
        object clientOrderId = this.safeString2(parameters, "client_id", "clientOrderId");
        parameters = this.omit(parameters, new List<object>() {"stop", "trigger", "clientOrderId"});
        object response = null;
        if (isTrue(!isEqual(clientOrderId, null)))
        {
            ((IDictionary<string,object>)request)["client_id"] = clientOrderId;
            if (isTrue(isTriggerOrder))
            {
                if (isTrue(swap))
                {
                    response = await this.v2PrivatePostFuturesCancelStopOrderByClientId(this.extend(request, parameters));
                } else
                {
                    response = await this.v2PrivatePostSpotCancelStopOrderByClientId(this.extend(request, parameters));
                }
            } else
            {
                if (isTrue(swap))
                {
                    response = await this.v2PrivatePostFuturesCancelOrderByClientId(this.extend(request, parameters));
                } else
                {
                    response = await this.v2PrivatePostSpotCancelOrderByClientId(this.extend(request, parameters));
                }
            }
        } else
        {
            if (isTrue(isTriggerOrder))
            {
                ((IDictionary<string,object>)request)["stop_id"] = this.parseToNumeric(id);
                if (isTrue(swap))
                {
                    response = await this.v2PrivatePostFuturesCancelStopOrder(this.extend(request, parameters));
                } else
                {
                    response = await this.v2PrivatePostSpotCancelStopOrder(this.extend(request, parameters));
                }
            } else
            {
                ((IDictionary<string,object>)request)["order_id"] = this.parseToNumeric(id);
                if (isTrue(swap))
                {
                    response = await this.v2PrivatePostFuturesCancelOrder(this.extend(request, parameters));
                } else
                {
                    response = await this.v2PrivatePostSpotCancelOrder(this.extend(request, parameters));
                }
            }
        }
        object data = null;
        if (isTrue(!isEqual(clientOrderId, null)))
        {
            object rows = this.safeList(response, "data", new List<object>() {});
            data = this.safeDict(getValue(rows, 0), "data", new Dictionary<string, object>() {});
        } else
        {
            data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        }
        return this.parseOrder(data, market);
    }

    public async override Task<object> cancelAllOrders(object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name coinex#cancelAllOrders
        * @description cancel all open orders in a market
        * @see https://docs.coinex.com/api/v2/spot/order/http/cancel-all-order
        * @see https://docs.coinex.com/api/v2/futures/order/http/cancel-all-order
        * @param {string} symbol unified market symbol of the market to cancel orders in
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {string} [params.marginMode] 'cross' or 'isolated' for canceling spot margin orders
        * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " cancelAllOrders() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "market", getValue(market, "id") },
        };
        object response = null;
        if (isTrue(getValue(market, "swap")))
        {
            ((IDictionary<string,object>)request)["market_type"] = "FUTURES";
            response = await this.v2PrivatePostFuturesCancelAllOrder(this.extend(request, parameters));
        } else
        {
            object marginMode = null;
            var marginModeparametersVariable = this.handleMarginModeAndParams("cancelAllOrders", parameters);
            marginMode = ((IList<object>)marginModeparametersVariable)[0];
            parameters = ((IList<object>)marginModeparametersVariable)[1];
            if (isTrue(!isEqual(marginMode, null)))
            {
                ((IDictionary<string,object>)request)["market_type"] = "MARGIN";
            } else
            {
                ((IDictionary<string,object>)request)["market_type"] = "SPOT";
            }
            response = await this.v2PrivatePostSpotCancelAllOrder(this.extend(request, parameters));
        }
        return response;
    }

    public async override Task<object> fetchOrder(object id, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name coinex#fetchOrder
        * @description fetches information on an order made by the user
        * @see https://docs.coinex.com/api/v2/spot/order/http/get-order-status
        * @see https://docs.coinex.com/api/v2/futures/order/http/get-order-status
        * @param {string} symbol unified symbol of the market the order was made in
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchOrder() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "market", getValue(market, "id") },
            { "order_id", this.parseToNumeric(id) },
        };
        object response = null;
        if (isTrue(getValue(market, "swap")))
        {
            response = await this.v2PrivateGetFuturesOrderStatus(this.extend(request, parameters));
        } else
        {
            response = await this.v2PrivateGetSpotOrderStatus(this.extend(request, parameters));
        }
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        return this.parseOrder(data, market);
    }

    public async virtual Task<object> fetchOrdersByStatus(object status, object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name coinex#fetchOrdersByStatus
        * @description fetch a list of orders
        * @see https://docs.coinex.com/api/v2/spot/order/http/list-finished-order
        * @see https://docs.coinex.com/api/v2/spot/order/http/list-finished-stop-order
        * @see https://docs.coinex.com/api/v2/futures/order/http/list-finished-order
        * @see https://docs.coinex.com/api/v2/futures/order/http/list-finished-stop-order
        * @param {string} symbol unified market symbol of the market orders were made in
        * @param {int} [since] the earliest time in ms to fetch orders for
        * @param {int} [limit] the maximum number of order structures to retrieve
        * @param {boolean} [params.trigger] set to true for fetching trigger orders
        * @param {string} [params.marginMode] 'cross' or 'isolated' for fetching spot margin orders
        * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            ((IDictionary<string,object>)request)["market"] = getValue(market, "id");
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        object stop = this.safeBool2(parameters, "stop", "trigger");
        parameters = this.omit(parameters, new List<object>() {"stop", "trigger"});
        object marketType = null;
        var marketTypeparametersVariable = this.handleMarketTypeAndParams("fetchOrdersByStatus", market, parameters);
        marketType = ((IList<object>)marketTypeparametersVariable)[0];
        parameters = ((IList<object>)marketTypeparametersVariable)[1];
        object response = null;
        object isClosed = isTrue((isEqual(status, "finished"))) || isTrue((isEqual(status, "closed")));
        object isOpen = isTrue((isEqual(status, "pending"))) || isTrue((isEqual(status, "open")));
        if (isTrue(isEqual(marketType, "swap")))
        {
            ((IDictionary<string,object>)request)["market_type"] = "FUTURES";
            if (isTrue(isClosed))
            {
                if (isTrue(stop))
                {
                    response = await this.v2PrivateGetFuturesFinishedStopOrder(this.extend(request, parameters));
                } else
                {
                    response = await this.v2PrivateGetFuturesFinishedOrder(this.extend(request, parameters));
                }
            } else if (isTrue(isOpen))
            {
                if (isTrue(stop))
                {
                    response = await this.v2PrivateGetFuturesPendingStopOrder(this.extend(request, parameters));
                } else
                {
                    response = await this.v2PrivateGetFuturesPendingOrder(this.extend(request, parameters));
                }
            }
        } else
        {
            object marginMode = null;
            var marginModeparametersVariable = this.handleMarginModeAndParams("fetchOrdersByStatus", parameters);
            marginMode = ((IList<object>)marginModeparametersVariable)[0];
            parameters = ((IList<object>)marginModeparametersVariable)[1];
            if (isTrue(!isEqual(marginMode, null)))
            {
                ((IDictionary<string,object>)request)["market_type"] = "MARGIN";
            } else
            {
                ((IDictionary<string,object>)request)["market_type"] = "SPOT";
            }
            if (isTrue(isClosed))
            {
                if (isTrue(stop))
                {
                    response = await this.v2PrivateGetSpotFinishedStopOrder(this.extend(request, parameters));
                } else
                {
                    response = await this.v2PrivateGetSpotFinishedOrder(this.extend(request, parameters));
                }
            } else if (isTrue(isEqual(status, "pending")))
            {
                if (isTrue(stop))
                {
                    response = await this.v2PrivateGetSpotPendingStopOrder(this.extend(request, parameters));
                } else
                {
                    response = await this.v2PrivateGetSpotPendingOrder(this.extend(request, parameters));
                }
            }
        }
        object data = this.safeList(response, "data", new List<object>() {});
        return this.parseOrders(data, market, since, limit);
    }

    public async override Task<object> fetchOpenOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name coinex#fetchOpenOrders
        * @description fetch all unfilled currently open orders
        * @see https://docs.coinex.com/api/v2/spot/order/http/list-pending-order
        * @see https://docs.coinex.com/api/v2/spot/order/http/list-pending-stop-order
        * @see https://docs.coinex.com/api/v2/futures/order/http/list-pending-order
        * @see https://docs.coinex.com/api/v2/futures/order/http/list-pending-stop-order
        * @param {string} symbol unified market symbol
        * @param {int} [since] the earliest time in ms to fetch open orders for
        * @param {int} [limit] the maximum number of open order structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {boolean} [params.trigger] set to true for fetching trigger orders
        * @param {string} [params.marginMode] 'cross' or 'isolated' for fetching spot margin orders
        * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        return await this.fetchOrdersByStatus("pending", symbol, since, limit, parameters);
    }

    public async override Task<object> fetchClosedOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name coinex#fetchClosedOrders
        * @description fetches information on multiple closed orders made by the user
        * @see https://docs.coinex.com/api/v2/spot/order/http/list-finished-order
        * @see https://docs.coinex.com/api/v2/spot/order/http/list-finished-stop-order
        * @see https://docs.coinex.com/api/v2/futures/order/http/list-finished-order
        * @see https://docs.coinex.com/api/v2/futures/order/http/list-finished-stop-order
        * @param {string} symbol unified market symbol of the market orders were made in
        * @param {int} [since] the earliest time in ms to fetch orders for
        * @param {int} [limit] the maximum number of order structures to retrieve
        * @param {boolean} [params.trigger] set to true for fetching trigger orders
        * @param {string} [params.marginMode] 'cross' or 'isolated' for fetching spot margin orders
        * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        return await this.fetchOrdersByStatus("finished", symbol, since, limit, parameters);
    }

    public async override Task<object> createDepositAddress(object code, object parameters = null)
    {
        /**
        * @method
        * @name coinex#createDepositAddress
        * @description create a currency deposit address
        * @see https://docs.coinex.com/api/v2/assets/deposit-withdrawal/http/update-deposit-address
        * @param {string} code unified currency code of the currency for the deposit address
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {string} [params.network] the blockchain network to create a deposit address on
        * @returns {object} an [address structure]{@link https://docs.ccxt.com/#/?id=address-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        object network = this.safeString2(parameters, "chain", "network");
        if (isTrue(isEqual(network, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " createDepositAddress() requires a network parameter")) ;
        }
        parameters = this.omit(parameters, "network");
        object request = new Dictionary<string, object>() {
            { "ccy", getValue(currency, "id") },
            { "chain", this.networkCodeToId(network, getValue(currency, "code")) },
        };
        object response = await this.v2PrivatePostAssetsRenewalDepositAddress(this.extend(request, parameters));
        //
        //     {
        //         "code": 0,
        //         "data": {
        //             "address": "0x321bd6479355142334f45653ad5d8b76105a1234",
        //             "memo": ""
        //         },
        //         "message": "OK"
        //     }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        return this.parseDepositAddress(data, currency);
    }

    public async override Task<object> fetchDepositAddress(object code, object parameters = null)
    {
        /**
        * @method
        * @name coinex#fetchDepositAddress
        * @description fetch the deposit address for a currency associated with this account
        * @see https://docs.coinex.com/api/v2/assets/deposit-withdrawal/http/get-deposit-address
        * @param {string} code unified currency code
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {string} [params.network] the blockchain network to create a deposit address on
        * @returns {object} an [address structure]{@link https://docs.ccxt.com/#/?id=address-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        object networks = this.safeDict(currency, "networks", new Dictionary<string, object>() {});
        object network = this.safeString2(parameters, "network", "chain");
        parameters = this.omit(parameters, "network");
        object networksKeys = new List<object>(((IDictionary<string,object>)networks).Keys);
        object numOfNetworks = getArrayLength(networksKeys);
        if (isTrue(isTrue(!isEqual(networks, null)) && isTrue(isGreaterThan(numOfNetworks, 1))))
        {
            if (isTrue(isEqual(network, null)))
            {
                throw new ArgumentsRequired ((string)add(add(add(this.id, " fetchDepositAddress() "), code), " requires a network parameter")) ;
            }
            if (!isTrue((inOp(networks, network))))
            {
                throw new ExchangeError ((string)add(add(add(add(this.id, " fetchDepositAddress() "), network), " network not supported for "), code)) ;
            }
        }
        object request = new Dictionary<string, object>() {
            { "ccy", getValue(currency, "id") },
            { "chain", network },
        };
        object response = await this.v2PrivateGetAssetsDepositAddress(this.extend(request, parameters));
        //
        //     {
        //         "code": 0,
        //         "data": {
        //             "address": "0x321bd6479355142334f45653ad5d8b76105a1234",
        //             "memo": ""
        //         },
        //         "message": "OK"
        //     }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        object depositAddress = this.parseDepositAddress(data, currency);
        object options = this.safeDict(this.options, "fetchDepositAddress", new Dictionary<string, object>() {});
        object fillResponseFromRequest = this.safeBool(options, "fillResponseFromRequest", true);
        if (isTrue(fillResponseFromRequest))
        {
            ((IDictionary<string,object>)depositAddress)["network"] = this.safeNetworkCode(network, currency);
        }
        return depositAddress;
    }

    public virtual object safeNetwork(object networkId, object currency = null)
    {
        object networks = this.safeValue(currency, "networks", new Dictionary<string, object>() {});
        object networksCodes = new List<object>(((IDictionary<string,object>)networks).Keys);
        object networksCodesLength = getArrayLength(networksCodes);
        if (isTrue(isTrue(isEqual(networkId, null)) && isTrue(isEqual(networksCodesLength, 1))))
        {
            return getValue(networks, getValue(networksCodes, 0));
        }
        return new Dictionary<string, object>() {
            { "id", networkId },
            { "network", ((bool) isTrue((isEqual(networkId, null)))) ? null : ((string)networkId).ToUpper() },
        };
    }

    public virtual object safeNetworkCode(object networkId, object currency = null)
    {
        object network = this.safeNetwork(networkId, currency);
        return getValue(network, "network");
    }

    public override object parseDepositAddress(object depositAddress, object currency = null)
    {
        //
        //     {
        //         "address": "1P1JqozxioQwaqPwgMAQdNDYNyaVSqgARq",
        //         "memo": ""
        //     }
        //
        object coinAddress = this.safeString(depositAddress, "address");
        object parts = ((string)coinAddress).Split(new [] {((string)":")}, StringSplitOptions.None).ToList<object>();
        object address = null;
        object tag = null;
        object partsLength = getArrayLength(parts);
        if (isTrue(isTrue(isGreaterThan(partsLength, 1)) && isTrue(!isEqual(getValue(parts, 0), "cfx"))))
        {
            address = getValue(parts, 0);
            tag = getValue(parts, 1);
        } else
        {
            address = coinAddress;
        }
        return new Dictionary<string, object>() {
            { "info", depositAddress },
            { "currency", this.safeCurrencyCode(null, currency) },
            { "address", address },
            { "tag", tag },
            { "network", null },
        };
    }

    public async override Task<object> fetchMyTrades(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name coinex#fetchMyTrades
        * @description fetch all trades made by the user
        * @see https://docs.coinex.com/api/v2/spot/deal/http/list-user-deals
        * @see https://docs.coinex.com/api/v2/futures/deal/http/list-user-deals
        * @param {string} symbol unified market symbol
        * @param {int} [since] the earliest time in ms to fetch trades for
        * @param {int} [limit] the maximum number of trade structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {int} [params.until] timestamp in ms of the latest trades
        * @param {string} [params.side] the side of the trades, either 'buy' or 'sell', required for swap
        * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
        */
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchMyTrades() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "market", getValue(market, "id") },
        };
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["start_time"] = since;
        }
        var requestparametersVariable = this.handleUntilOption("end_time", request, parameters);
        request = ((IList<object>)requestparametersVariable)[0];
        parameters = ((IList<object>)requestparametersVariable)[1];
        object response = null;
        if (isTrue(getValue(market, "swap")))
        {
            ((IDictionary<string,object>)request)["market_type"] = "FUTURES";
            response = await this.v2PrivateGetFuturesUserDeals(this.extend(request, parameters));
        } else
        {
            object marginMode = null;
            var marginModeparametersVariable = this.handleMarginModeAndParams("fetchMyTrades", parameters);
            marginMode = ((IList<object>)marginModeparametersVariable)[0];
            parameters = ((IList<object>)marginModeparametersVariable)[1];
            if (isTrue(!isEqual(marginMode, null)))
            {
                ((IDictionary<string,object>)request)["market_type"] = "MARGIN";
            } else
            {
                ((IDictionary<string,object>)request)["market_type"] = "SPOT";
            }
            response = await this.v2PrivateGetSpotUserDeals(this.extend(request, parameters));
        }
        object data = this.safeList(response, "data", new List<object>() {});
        return this.parseTrades(data, market, since, limit);
    }

    public async override Task<object> fetchPositions(object symbols = null, object parameters = null)
    {
        /**
        * @method
        * @name coinex#fetchPositions
        * @description fetch all open positions
        * @see https://docs.coinex.com/api/v2/futures/position/http/list-pending-position
        * @see https://docs.coinex.com/api/v2/futures/position/http/list-finished-position
        * @param {string[]} [symbols] list of unified market symbols
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {string} [params.method] the method to use 'v2PrivateGetFuturesPendingPosition' or 'v2PrivateGetFuturesFinishedPosition' default is 'v2PrivateGetFuturesPendingPosition'
        * @returns {object[]} a list of [position structure]{@link https://docs.ccxt.com/#/?id=position-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object defaultMethod = null;
        var defaultMethodparametersVariable = this.handleOptionAndParams(parameters, "fetchPositions", "method", "v2PrivateGetFuturesPendingPosition");
        defaultMethod = ((IList<object>)defaultMethodparametersVariable)[0];
        parameters = ((IList<object>)defaultMethodparametersVariable)[1];
        symbols = this.marketSymbols(symbols);
        object request = new Dictionary<string, object>() {
            { "market_type", "FUTURES" },
        };
        object market = null;
        if (isTrue(!isEqual(symbols, null)))
        {
            object symbol = null;
            if (isTrue(((symbols is IList<object>) || (symbols.GetType().IsGenericType && symbols.GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>))))))
            {
                object symbolsLength = getArrayLength(symbols);
                if (isTrue(isGreaterThan(symbolsLength, 1)))
                {
                    throw new BadRequest ((string)add(this.id, " fetchPositions() symbols argument cannot contain more than 1 symbol")) ;
                }
                symbol = getValue(symbols, 0);
            } else
            {
                symbol = symbols;
            }
            market = this.market(symbol);
            ((IDictionary<string,object>)request)["market"] = getValue(market, "id");
        }
        object response = null;
        if (isTrue(isEqual(defaultMethod, "v2PrivateGetFuturesPendingPosition")))
        {
            response = await this.v2PrivateGetFuturesPendingPosition(this.extend(request, parameters));
        } else
        {
            response = await this.v2PrivateGetFuturesFinishedPosition(this.extend(request, parameters));
        }
        //
        //     {
        //         "code": 0,
        //         "data": [
        //             {
        //                 "position_id": 305891033,
        //                 "market": "BTCUSDT",
        //                 "market_type": "FUTURES",
        //                 "side": "long",
        //                 "margin_mode": "cross",
        //                 "open_interest": "0.0001",
        //                 "close_avbl": "0.0001",
        //                 "ath_position_amount": "0.0001",
        //                 "unrealized_pnl": "0",
        //                 "realized_pnl": "-0.00311684",
        //                 "avg_entry_price": "62336.8",
        //                 "cml_position_value": "6.23368",
        //                 "max_position_value": "6.23368",
        //                 "created_at": 1715152208041,
        //                 "updated_at": 1715152208041,
        //                 "take_profit_price": "0",
        //                 "stop_loss_price": "0",
        //                 "take_profit_type": "",
        //                 "stop_loss_type": "",
        //                 "settle_price": "62336.8",
        //                 "settle_value": "6.23368",
        //                 "leverage": "3",
        //                 "margin_avbl": "2.07789333",
        //                 "ath_margin_size": "2.07789333",
        //                 "position_margin_rate": "2.40545879023305655728",
        //                 "maintenance_margin_rate": "0.005",
        //                 "maintenance_margin_value": "0.03118094",
        //                 "liq_price": "0",
        //                 "bkr_price": "0",
        //                 "adl_level": 1
        //             }
        //         ],
        //         "message": "OK",
        //         "pagination": {
        //             "has_next": false
        //         }
        //     }
        //
        object position = this.safeList(response, "data", new List<object>() {});
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(position)); postFixIncrement(ref i))
        {
            ((IList<object>)result).Add(this.parsePosition(getValue(position, i), market));
        }
        return this.filterByArrayPositions(result, "symbol", symbols, false);
    }

    public async override Task<object> fetchPosition(object symbol, object parameters = null)
    {
        /**
        * @method
        * @name coinex#fetchPosition
        * @description fetch data on a single open contract trade position
        * @see https://docs.coinex.com/api/v2/futures/position/http/list-pending-position
        * @param {string} symbol unified market symbol of the market the position is held in
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [position structure]{@link https://docs.ccxt.com/#/?id=position-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "market_type", "FUTURES" },
            { "market", getValue(market, "id") },
        };
        object response = await this.v2PrivateGetFuturesPendingPosition(this.extend(request, parameters));
        //
        //     {
        //         "code": 0,
        //         "data": [
        //             {
        //                 "position_id": 305891033,
        //                 "market": "BTCUSDT",
        //                 "market_type": "FUTURES",
        //                 "side": "long",
        //                 "margin_mode": "cross",
        //                 "open_interest": "0.0001",
        //                 "close_avbl": "0.0001",
        //                 "ath_position_amount": "0.0001",
        //                 "unrealized_pnl": "0",
        //                 "realized_pnl": "-0.00311684",
        //                 "avg_entry_price": "62336.8",
        //                 "cml_position_value": "6.23368",
        //                 "max_position_value": "6.23368",
        //                 "created_at": 1715152208041,
        //                 "updated_at": 1715152208041,
        //                 "take_profit_price": "0",
        //                 "stop_loss_price": "0",
        //                 "take_profit_type": "",
        //                 "stop_loss_type": "",
        //                 "settle_price": "62336.8",
        //                 "settle_value": "6.23368",
        //                 "leverage": "3",
        //                 "margin_avbl": "2.07789333",
        //                 "ath_margin_size": "2.07789333",
        //                 "position_margin_rate": "2.40545879023305655728",
        //                 "maintenance_margin_rate": "0.005",
        //                 "maintenance_margin_value": "0.03118094",
        //                 "liq_price": "0",
        //                 "bkr_price": "0",
        //                 "adl_level": 1
        //             }
        //         ],
        //         "message": "OK",
        //         "pagination": {
        //             "has_next": false
        //         }
        //     }
        //
        object data = this.safeList(response, "data", new List<object>() {});
        return this.parsePosition(getValue(data, 0), market);
    }

    public override object parsePosition(object position, object market = null)
    {
        //
        //     {
        //         "position_id": 305891033,
        //         "market": "BTCUSDT",
        //         "market_type": "FUTURES",
        //         "side": "long",
        //         "margin_mode": "cross",
        //         "open_interest": "0.0001",
        //         "close_avbl": "0.0001",
        //         "ath_position_amount": "0.0001",
        //         "unrealized_pnl": "0",
        //         "realized_pnl": "-0.00311684",
        //         "avg_entry_price": "62336.8",
        //         "cml_position_value": "6.23368",
        //         "max_position_value": "6.23368",
        //         "created_at": 1715152208041,
        //         "updated_at": 1715152208041,
        //         "take_profit_price": "0",
        //         "stop_loss_price": "0",
        //         "take_profit_type": "",
        //         "stop_loss_type": "",
        //         "settle_price": "62336.8",
        //         "settle_value": "6.23368",
        //         "leverage": "3",
        //         "margin_avbl": "2.07789333",
        //         "ath_margin_size": "2.07789333",
        //         "position_margin_rate": "2.40545879023305655728",
        //         "maintenance_margin_rate": "0.005",
        //         "maintenance_margin_value": "0.03118094",
        //         "liq_price": "0",
        //         "bkr_price": "0",
        //         "adl_level": 1
        //     }
        //
        object marketId = this.safeString(position, "market");
        market = this.safeMarket(marketId, market, null, "swap");
        object timestamp = this.safeInteger(position, "created_at");
        return this.safePosition(new Dictionary<string, object>() {
            { "info", position },
            { "id", this.safeInteger(position, "position_id") },
            { "symbol", getValue(market, "symbol") },
            { "notional", this.safeNumber(position, "settle_value") },
            { "marginMode", this.safeString(position, "margin_mode") },
            { "liquidationPrice", this.safeNumber(position, "liq_price") },
            { "entryPrice", this.safeNumber(position, "avg_entry_price") },
            { "unrealizedPnl", this.safeNumber(position, "unrealized_pnl") },
            { "realizedPnl", this.safeNumber(position, "realized_pnl") },
            { "percentage", null },
            { "contracts", this.safeNumber(position, "close_avbl") },
            { "contractSize", this.safeNumber(market, "contractSize") },
            { "markPrice", null },
            { "lastPrice", null },
            { "side", this.safeString(position, "side") },
            { "hedged", null },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "lastUpdateTimestamp", this.safeInteger(position, "updated_at") },
            { "maintenanceMargin", this.safeNumber(position, "maintenance_margin_value") },
            { "maintenanceMarginPercentage", this.safeNumber(position, "maintenance_margin_rate") },
            { "collateral", this.safeNumber(position, "margin_avbl") },
            { "initialMargin", null },
            { "initialMarginPercentage", null },
            { "leverage", this.safeNumber(position, "leverage") },
            { "marginRatio", this.safeNumber(position, "position_margin_rate") },
            { "stopLossPrice", this.omitZero(this.safeString(position, "stop_loss_price")) },
            { "takeProfitPrice", this.omitZero(this.safeString(position, "take_profit_price")) },
        });
    }

    public async override Task<object> setMarginMode(object marginMode, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name coinex#setMarginMode
        * @description set margin mode to 'cross' or 'isolated'
        * @see https://viabtc.github.io/coinex_api_en_doc/futures/#docsfutures001_http014_adjust_leverage
        * @param {string} marginMode 'cross' or 'isolated'
        * @param {string} symbol unified market symbol
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} response from the exchange
        */
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " setMarginMode() requires a symbol argument")) ;
        }
        marginMode = ((string)marginMode).ToLower();
        if (isTrue(isTrue(!isEqual(marginMode, "isolated")) && isTrue(!isEqual(marginMode, "cross"))))
        {
            throw new BadRequest ((string)add(this.id, " setMarginMode() marginMode argument should be isolated or cross")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        if (isTrue(!isEqual(getValue(market, "type"), "swap")))
        {
            throw new BadSymbol ((string)add(this.id, " setMarginMode() supports swap contracts only")) ;
        }
        object defaultPositionType = null;
        if (isTrue(isEqual(marginMode, "isolated")))
        {
            defaultPositionType = 1;
        } else if (isTrue(isEqual(marginMode, "cross")))
        {
            defaultPositionType = 2;
        }
        object leverage = this.safeInteger(parameters, "leverage");
        object maxLeverage = this.safeInteger(getValue(getValue(market, "limits"), "leverage"), "max", 100);
        object positionType = this.safeInteger(parameters, "position_type", defaultPositionType);
        if (isTrue(isEqual(leverage, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " setMarginMode() requires a leverage parameter")) ;
        }
        if (isTrue(isEqual(positionType, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " setMarginMode() requires a position_type parameter that will transfer margin to the specified trading pair")) ;
        }
        if (isTrue(isTrue((isLessThan(leverage, 3))) || isTrue((isGreaterThan(leverage, maxLeverage)))))
        {
            throw new BadRequest ((string)add(add(add(add(this.id, " setMarginMode() leverage should be between 3 and "), ((object)maxLeverage).ToString()), " for "), symbol)) ;
        }
        object request = new Dictionary<string, object>() {
            { "market", getValue(market, "id") },
            { "leverage", ((object)leverage).ToString() },
            { "position_type", positionType },
        };
        return await this.v1PerpetualPrivatePostMarketAdjustLeverage(this.extend(request, parameters));
    }

    public async override Task<object> setLeverage(object leverage, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name coinex#setLeverage
        * @see https://viabtc.github.io/coinex_api_en_doc/futures/#docsfutures001_http014_adjust_leverage
        * @description set the level of leverage for a market
        * @param {float} leverage the rate of leverage
        * @param {string} symbol unified market symbol
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {string} [params.marginMode] 'cross' or 'isolated' (default is 'cross')
        * @returns {object} response from the exchange
        */
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " setLeverage() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        if (!isTrue(getValue(market, "swap")))
        {
            throw new BadSymbol ((string)add(this.id, " setLeverage() supports swap contracts only")) ;
        }
        object marginMode = null;
        var marginModeparametersVariable = this.handleMarginModeAndParams("setLeverage", parameters, "cross");
        marginMode = ((IList<object>)marginModeparametersVariable)[0];
        parameters = ((IList<object>)marginModeparametersVariable)[1];
        object positionType = null;
        if (isTrue(isEqual(marginMode, "isolated")))
        {
            positionType = 1;
        } else if (isTrue(isEqual(marginMode, "cross")))
        {
            positionType = 2;
        }
        object minLeverage = this.safeInteger(getValue(getValue(market, "limits"), "leverage"), "min", 1);
        object maxLeverage = this.safeInteger(getValue(getValue(market, "limits"), "leverage"), "max", 100);
        if (isTrue(isTrue((isLessThan(leverage, minLeverage))) || isTrue((isGreaterThan(leverage, maxLeverage)))))
        {
            throw new BadRequest ((string)add(add(add(add(add(add(this.id, " setLeverage() leverage should be between "), ((object)minLeverage).ToString()), " and "), ((object)maxLeverage).ToString()), " for "), symbol)) ;
        }
        object request = new Dictionary<string, object>() {
            { "market", getValue(market, "id") },
            { "leverage", ((object)leverage).ToString() },
            { "position_type", positionType },
        };
        return await this.v1PerpetualPrivatePostMarketAdjustLeverage(this.extend(request, parameters));
    }

    public async override Task<object> fetchLeverageTiers(object symbols = null, object parameters = null)
    {
        /**
        * @method
        * @name coinex#fetchLeverageTiers
        * @description retrieve information on the maximum leverage, and maintenance margin for trades of varying trade sizes
        * @see https://viabtc.github.io/coinex_api_en_doc/futures/#docsfutures001_http007_market_limit
        * @param {string[]|undefined} symbols list of unified market symbols
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a dictionary of [leverage tiers structures]{@link https://docs.ccxt.com/#/?id=leverage-tiers-structure}, indexed by market symbols
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.v1PerpetualPublicGetMarketLimitConfig(parameters);
        //
        //     {
        //         "code": 0,
        //         "data": {
        //             "BTCUSD": [
        //                 ["500001", "100", "0.005"],
        //                 ["1000001", "50", "0.01"],
        //                 ["2000001", "30", "0.015"],
        //                 ["5000001", "20", "0.02"],
        //                 ["10000001", "15", "0.025"],
        //                 ["20000001", "10", "0.03"]
        //             ],
        //             ...
        //         },
        //         "message": "OK"
        //     }
        //
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        return this.parseLeverageTiers(data, symbols, null);
    }

    public override object parseMarketLeverageTiers(object item, object market = null)
    {
        object tiers = new List<object>() {};
        object minNotional = 0;
        for (object j = 0; isLessThan(j, getArrayLength(item)); postFixIncrement(ref j))
        {
            object bracket = getValue(item, j);
            object maxNotional = this.safeNumber(bracket, 0);
            ((IList<object>)tiers).Add(new Dictionary<string, object>() {
                { "tier", add(j, 1) },
                { "currency", ((bool) isTrue(getValue(market, "linear"))) ? getValue(market, "base") : getValue(market, "quote") },
                { "minNotional", minNotional },
                { "maxNotional", maxNotional },
                { "maintenanceMarginRate", this.safeNumber(bracket, 2) },
                { "maxLeverage", this.safeInteger(bracket, 1) },
                { "info", bracket },
            });
            minNotional = maxNotional;
        }
        return tiers;
    }

    public async virtual Task<object> modifyMarginHelper(object symbol, object amount, object addOrReduce, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "market", getValue(market, "id") },
            { "amount", this.amountToPrecision(symbol, amount) },
            { "type", addOrReduce },
        };
        object response = await this.v1PerpetualPrivatePostPositionAdjustMargin(this.extend(request, parameters));
        //
        //     {
        //         "code": 0,
        //         "data": {
        //             "adl_sort": 1,
        //             "adl_sort_val": "0.00004320",
        //             "amount": "0.0005",
        //             "amount_max": "0.0005",
        //             "amount_max_margin": "6.57352000000000000000",
        //             "bkr_price": "16294.08000000000000011090",
        //             "bkr_price_imply": "0.00000000000000000000",
        //             "close_left": "0.0005",
        //             "create_time": 1651202571.320778,
        //             "deal_all": "19.72000000000000000000",
        //             "deal_asset_fee": "0.00000000000000000000",
        //             "fee_asset": "",
        //             "finish_type": 1,
        //             "first_price": "39441.12",
        //             "insurance": "0.00000000000000000000",
        //             "latest_price": "39441.12",
        //             "leverage": "3",
        //             "liq_amount": "0.00000000000000000000",
        //             "liq_order_price": "0",
        //             "liq_order_time": 0,
        //             "liq_price": "16491.28560000000000011090",
        //             "liq_price_imply": "0.00000000000000000000",
        //             "liq_profit": "0.00000000000000000000",
        //             "liq_time": 0,
        //             "mainten_margin": "0.005",
        //             "mainten_margin_amount": "0.09860280000000000000",
        //             "maker_fee": "0.00000000000000000000",
        //             "margin_amount": "11.57352000000000000000",
        //             "market": "BTCUSDT",
        //             "open_margin": "0.58687582908396110455",
        //             "open_margin_imply": "0.00000000000000000000",
        //             "open_price": "39441.12000000000000000000",
        //             "open_val": "19.72056000000000000000",
        //             "open_val_max": "19.72056000000000000000",
        //             "position_id": 65171206,
        //             "profit_clearing": "-0.00986028000000000000",
        //             "profit_real": "-0.00986028000000000000",
        //             "profit_unreal": "0.00",
        //             "side": 2,
        //             "stop_loss_price": "0.00000000000000000000",
        //             "stop_loss_type": 0,
        //             "s ys": 0,
        //             "take_profit_price": "0.00000000000000000000",
        //             "take_profit_type": 0,
        //             "taker_fee": "0.00000000000000000000",
        //             "total": 3464,
        //             "type": 1,
        //             "update_time": 1651202638.911212,
        //             "user_id": 3620173
        //         },
        //         "message":"OK"
        //     }
        //
        object data = this.safeDict(response, "data");
        object status = this.safeString(response, "message");
        return this.extend(this.parseMarginModification(data, market), new Dictionary<string, object>() {
            { "amount", this.parseNumber(amount) },
            { "status", status },
        });
    }

    public override object parseMarginModification(object data, object market = null)
    {
        //
        // addMargin/reduceMargin
        //
        //    {
        //        "adl_sort": 1,
        //        "adl_sort_val": "0.00004320",
        //        "amount": "0.0005",
        //        "amount_max": "0.0005",
        //        "amount_max_margin": "6.57352000000000000000",
        //        "bkr_price": "16294.08000000000000011090",
        //        "bkr_price_imply": "0.00000000000000000000",
        //        "close_left": "0.0005",
        //        "create_time": 1651202571.320778,
        //        "deal_all": "19.72000000000000000000",
        //        "deal_asset_fee": "0.00000000000000000000",
        //        "fee_asset": "",
        //        "finish_type": 1,
        //        "first_price": "39441.12",
        //        "insurance": "0.00000000000000000000",
        //        "latest_price": "39441.12",
        //        "leverage": "3",
        //        "liq_amount": "0.00000000000000000000",
        //        "liq_order_price": "0",
        //        "liq_order_time": 0,
        //        "liq_price": "16491.28560000000000011090",
        //        "liq_price_imply": "0.00000000000000000000",
        //        "liq_profit": "0.00000000000000000000",
        //        "liq_time": 0,
        //        "mainten_margin": "0.005",
        //        "mainten_margin_amount": "0.09860280000000000000",
        //        "maker_fee": "0.00000000000000000000",
        //        "margin_amount": "11.57352000000000000000",
        //        "market": "BTCUSDT",
        //        "open_margin": "0.58687582908396110455",
        //        "open_margin_imply": "0.00000000000000000000",
        //        "open_price": "39441.12000000000000000000",
        //        "open_val": "19.72056000000000000000",
        //        "open_val_max": "19.72056000000000000000",
        //        "position_id": 65171206,
        //        "profit_clearing": "-0.00986028000000000000",
        //        "profit_real": "-0.00986028000000000000",
        //        "profit_unreal": "0.00",
        //        "side": 2,
        //        "stop_loss_price": "0.00000000000000000000",
        //        "stop_loss_type": 0,
        //        "sy s": 0,
        //        "take_profit_price": "0.00000000000000000000",
        //        "take_profit_type": 0,
        //        "taker_fee": "0.00000000000000000000",
        //        "total": 3464,
        //        "type": 1,
        //        "update_time": 1651202638.911212,
        //        "user_id": 3620173
        //    }
        //
        // fetchMarginAdjustmentHistory
        //
        //    {
        //        bkr_price: '0',
        //        leverage: '3',
        //        liq_price: '0',
        //        margin_amount: '5.33236666666666666666',
        //        margin_change: '3',
        //        market: 'XRPUSDT',
        //        position_amount: '11',
        //        position_id: '297155652',
        //        position_type: '2',
        //        settle_price: '0.6361',
        //        time: '1711050906.382891',
        //        type: '1',
        //        user_id: '3685860'
        //    }
        //
        object marketId = this.safeString(data, "market");
        object type = this.safeString(data, "type");
        object timestamp = this.safeIntegerProduct2(data, "time", "update_time", 1000);
        return new Dictionary<string, object>() {
            { "info", data },
            { "symbol", this.safeSymbol(marketId, market, null, "swap") },
            { "type", ((bool) isTrue((isEqual(type, "1")))) ? "add" : "reduce" },
            { "marginMode", "isolated" },
            { "amount", this.safeNumber(data, "margin_change") },
            { "total", this.safeNumber(data, "position_amount") },
            { "code", getValue(market, "quote") },
            { "status", null },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
        };
    }

    public async override Task<object> addMargin(object symbol, object amount, object parameters = null)
    {
        /**
        * @method
        * @name coinex#addMargin
        * @description add margin
        * @see https://viabtc.github.io/coinex_api_en_doc/futures/#docsfutures001_http032_adjust_position_margin
        * @param {string} symbol unified market symbol
        * @param {float} amount amount of margin to add
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [margin structure]{@link https://docs.ccxt.com/#/?id=add-margin-structure}
        */
        parameters ??= new Dictionary<string, object>();
        return await this.modifyMarginHelper(symbol, amount, 1, parameters);
    }

    public async override Task<object> reduceMargin(object symbol, object amount, object parameters = null)
    {
        /**
        * @method
        * @name coinex#reduceMargin
        * @description remove margin from a position
        * @see https://viabtc.github.io/coinex_api_en_doc/futures/#docsfutures001_http032_adjust_position_margin
        * @param {string} symbol unified market symbol
        * @param {float} amount the amount of margin to remove
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [margin structure]{@link https://docs.ccxt.com/#/?id=reduce-margin-structure}
        */
        parameters ??= new Dictionary<string, object>();
        return await this.modifyMarginHelper(symbol, amount, 2, parameters);
    }

    public async override Task<object> fetchFundingHistory(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name coinex#fetchFundingHistory
        * @description fetch the history of funding payments paid and received on this account
        * @see https://viabtc.github.io/coinex_api_en_doc/futures/#docsfutures001_http034_funding_position
        * @param {string} symbol unified market symbol
        * @param {int} [since] the earliest time in ms to fetch funding history for
        * @param {int} [limit] the maximum number of funding history structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [funding history structure]{@link https://docs.ccxt.com/#/?id=funding-history-structure}
        */
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchFundingHistory() requires a symbol argument")) ;
        }
        limit = ((bool) isTrue((isEqual(limit, null)))) ? 100 : limit;
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "market", getValue(market, "id") },
            { "limit", limit },
        };
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["start_time"] = since;
        }
        object response = await this.v1PerpetualPrivateGetPositionFunding(this.extend(request, parameters));
        //
        //     {
        //         "code": 0,
        //         "data": {
        //             "limit": 100,
        //             "offset": 0,
        //             "records": [
        //                 {
        //                     "amount": "0.0012",
        //                     "asset": "USDT",
        //                     "funding": "-0.0095688273996",
        //                     "funding_rate": "0.00020034",
        //                     "market": "BTCUSDT",
        //                     "position_id": 62052321,
        //                     "price": "39802.45",
        //                     "real_funding_rate": "0.00020034",
        //                     "side": 2,
        //                     "time": 1650729623.933885,
        //                     "type": 1,
        //                     "user_id": 3620173,
        //                     "value": "47.76294"
        //                 },
        //             ]
        //         },
        //         "message": "OK"
        //     }
        //
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        object resultList = this.safeValue(data, "records", new List<object>() {});
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(resultList)); postFixIncrement(ref i))
        {
            object entry = getValue(resultList, i);
            object timestamp = this.safeTimestamp(entry, "time");
            object currencyId = this.safeString(entry, "asset");
            object code = this.safeCurrencyCode(currencyId);
            ((IList<object>)result).Add(new Dictionary<string, object>() {
                { "info", entry },
                { "symbol", symbol },
                { "code", code },
                { "timestamp", timestamp },
                { "datetime", this.iso8601(timestamp) },
                { "id", this.safeNumber(entry, "position_id") },
                { "amount", this.safeNumber(entry, "funding") },
            });
        }
        return result;
    }

    public async override Task<object> fetchFundingRate(object symbol, object parameters = null)
    {
        /**
        * @method
        * @name coinex#fetchFundingRate
        * @description fetch the current funding rate
        * @see https://viabtc.github.io/coinex_api_en_doc/futures/#docsfutures001_http008_market_ticker
        * @param {string} symbol unified market symbol
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [funding rate structure]{@link https://docs.ccxt.com/#/?id=funding-rate-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        if (!isTrue(getValue(market, "swap")))
        {
            throw new BadSymbol ((string)add(this.id, " fetchFundingRate() supports swap contracts only")) ;
        }
        object request = new Dictionary<string, object>() {
            { "market", getValue(market, "id") },
        };
        object response = await this.v1PerpetualPublicGetMarketTicker(this.extend(request, parameters));
        //
        //     {
        //          "code": 0,
        //         "data":
        //         {
        //             "date": 1650678472474,
        //             "ticker": {
        //                 "vol": "6090.9430",
        //                 "low": "39180.30",
        //                 "open": "40474.97",
        //                 "high": "40798.01",
        //                 "last": "39659.30",
        //                 "buy": "39663.79",
        //                 "period": 86400,
        //                 "funding_time": 372,
        //                 "position_amount": "270.1956",
        //                 "funding_rate_last": "0.00022913",
        //                 "funding_rate_next": "0.00013158",
        //                 "funding_rate_predict": "0.00016552",
        //                 "insurance": "16045554.83969682659674035672",
        //                 "sign_price": "39652.48",
        //                 "index_price": "39648.44250000",
        //                 "sell_total": "22.3913",
        //                 "buy_total": "19.4498",
        //                 "buy_amount": "12.8942",
        //                 "sell": "39663.80",
        //                 "sell_amount": "0.9388"
        //             }
        //         },
        //         "message": "OK"
        //     }
        //
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        object ticker = this.safeValue(data, "ticker", new Dictionary<string, object>() {});
        object timestamp = this.safeInteger(data, "date");
        ((IDictionary<string,object>)ticker)["timestamp"] = timestamp; // avoid changing parseFundingRate signature
        return this.parseFundingRate(ticker, market);
    }

    public override object parseFundingRate(object contract, object market = null)
    {
        //
        // fetchFundingRate
        //
        //     {
        //         "vol": "6090.9430",
        //         "low": "39180.30",
        //         "open": "40474.97",
        //         "high": "40798.01",
        //         "last": "39659.30",
        //         "buy": "39663.79",
        //         "period": 86400,
        //         "funding_time": 372,
        //         "position_amount": "270.1956",
        //         "funding_rate_last": "0.00022913",
        //         "funding_rate_next": "0.00013158",
        //         "funding_rate_predict": "0.00016552",
        //         "insurance": "16045554.83969682659674035672",
        //         "sign_price": "39652.48",
        //         "index_price": "39648.44250000",
        //         "sell_total": "22.3913",
        //         "buy_total": "19.4498",
        //         "buy_amount": "12.8942",
        //         "sell": "39663.80",
        //         "sell_amount": "0.9388"
        //     }
        //
        object timestamp = this.safeInteger(contract, "timestamp");
        contract = this.omit(contract, "timestamp");
        object fundingDelta = multiply(multiply(this.safeInteger(contract, "funding_time"), 60), 1000);
        object fundingHour = divide((add(timestamp, fundingDelta)), 3600000);
        object fundingTimestamp = multiply(Math.Round(Convert.ToDouble(fundingHour)), 3600000);
        return new Dictionary<string, object>() {
            { "info", contract },
            { "symbol", this.safeSymbol(null, market) },
            { "markPrice", this.safeNumber(contract, "sign_price") },
            { "indexPrice", this.safeNumber(contract, "index_price") },
            { "interestRate", null },
            { "estimatedSettlePrice", null },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "fundingRate", this.safeNumber(contract, "funding_rate_next") },
            { "fundingTimestamp", fundingTimestamp },
            { "fundingDatetime", this.iso8601(fundingTimestamp) },
            { "nextFundingRate", this.safeNumber(contract, "funding_rate_predict") },
            { "nextFundingTimestamp", null },
            { "nextFundingDatetime", null },
            { "previousFundingRate", this.safeNumber(contract, "funding_rate_last") },
            { "previousFundingTimestamp", null },
            { "previousFundingDatetime", null },
        };
    }

    public async override Task<object> fetchFundingRates(object symbols = null, object parameters = null)
    {
        /**
        * @method
        * @name coinex#fetchFundingRates
        * @description fetch the current funding rates
        * @see https://viabtc.github.io/coinex_api_en_doc/futures/#docsfutures001_http009_market_ticker_all
        * @param {string[]} symbols unified market symbols
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} an array of [funding rate structures]{@link https://docs.ccxt.com/#/?id=funding-rate-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        symbols = this.marketSymbols(symbols);
        object market = null;
        if (isTrue(!isEqual(symbols, null)))
        {
            object symbol = this.safeValue(symbols, 0);
            market = this.market(symbol);
            if (!isTrue(getValue(market, "swap")))
            {
                throw new BadSymbol ((string)add(this.id, " fetchFundingRates() supports swap contracts only")) ;
            }
        }
        object response = await this.v1PerpetualPublicGetMarketTickerAll(parameters);
        //
        //     {
        //         "code": 0,
        //         "data":
        //         {
        //             "date": 1650678472474,
        //             "ticker": {
        //                 "BTCUSDT": {
        //                     "vol": "6090.9430",
        //                     "low": "39180.30",
        //                     "open": "40474.97",
        //                     "high": "40798.01",
        //                     "last": "39659.30",
        //                     "buy": "39663.79",
        //                     "period": 86400,
        //                     "funding_time": 372,
        //                     "position_amount": "270.1956",
        //                     "funding_rate_last": "0.00022913",
        //                     "funding_rate_next": "0.00013158",
        //                     "funding_rate_predict": "0.00016552",
        //                     "insurance": "16045554.83969682659674035672",
        //                     "sign_price": "39652.48",
        //                     "index_price": "39648.44250000",
        //                     "sell_total": "22.3913",
        //                     "buy_total": "19.4498",
        //                     "buy_amount": "12.8942",
        //                     "sell": "39663.80",
        //                     "sell_amount": "0.9388"
        //                 }
        //             }
        //         },
        //         "message": "OK"
        //     }
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        object tickers = this.safeValue(data, "ticker", new Dictionary<string, object>() {});
        object timestamp = this.safeInteger(data, "date");
        object result = new List<object>() {};
        object marketIds = new List<object>(((IDictionary<string,object>)tickers).Keys);
        for (object i = 0; isLessThan(i, getArrayLength(marketIds)); postFixIncrement(ref i))
        {
            object marketId = getValue(marketIds, i);
            if (isTrue(isEqual(getIndexOf(marketId, "_"), -1)))
            {
                object marketInner = this.safeMarket(marketId, null, null, "swap");
                object ticker = getValue(tickers, marketId);
                ((IDictionary<string,object>)ticker)["timestamp"] = timestamp;
                ((IList<object>)result).Add(this.parseFundingRate(ticker, marketInner));
            }
        }
        return this.filterByArray(result, "symbol", symbols);
    }

    public async override Task<object> withdraw(object code, object amount, object address, object tag = null, object parameters = null)
    {
        /**
        * @method
        * @name coinex#withdraw
        * @description make a withdrawal
        * @see https://viabtc.github.io/coinex_api_en_doc/spot/#docsspot002_account015_submit_withdraw
        * @param {string} code unified currency code
        * @param {float} amount the amount to withdraw
        * @param {string} address the address to withdraw to
        * @param {string} tag
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {string} [params.network] unified network code
        * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
        */
        parameters ??= new Dictionary<string, object>();
        var tagparametersVariable = this.handleWithdrawTagAndParams(tag, parameters);
        tag = ((IList<object>)tagparametersVariable)[0];
        parameters = ((IList<object>)tagparametersVariable)[1];
        this.checkAddress(address);
        await this.loadMarkets();
        object currency = this.currency(code);
        object networkCode = this.safeStringUpper(parameters, "network");
        parameters = this.omit(parameters, "network");
        if (isTrue(tag))
        {
            address = add(add(address, ":"), tag);
        }
        object request = new Dictionary<string, object>() {
            { "coin_type", getValue(currency, "id") },
            { "coin_address", address },
            { "actual_amount", parseFloat(this.numberToString(amount)) },
            { "transfer_method", "onchain" },
        };
        if (isTrue(!isEqual(networkCode, null)))
        {
            ((IDictionary<string,object>)request)["smart_contract_name"] = this.networkCodeToId(networkCode);
        }
        object response = await this.v1PrivatePostBalanceCoinWithdraw(this.extend(request, parameters));
        //
        //     {
        //         "code": 0,
        //         "data": {
        //             "actual_amount": "1.00000000",
        //             "amount": "1.00000000",
        //             "coin_address": "1KAv3pazbTk2JnQ5xTo6fpKK7p1it2RzD4",
        //             "coin_type": "BCH",
        //             "coin_withdraw_id": 206,
        //             "confirmations": 0,
        //             "create_time": 1524228297,
        //             "status": "audit",
        //             "tx_fee": "0",
        //             "tx_id": ""
        //         },
        //         "message": "Ok"
        //     }
        //
        object transaction = this.safeDict(response, "data", new Dictionary<string, object>() {});
        return this.parseTransaction(transaction, currency);
    }

    public virtual object parseTransactionStatus(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "audit", "pending" },
            { "pass", "pending" },
            { "processing", "pending" },
            { "confirming", "pending" },
            { "not_pass", "failed" },
            { "cancel", "canceled" },
            { "finish", "ok" },
            { "fail", "failed" },
        };
        return this.safeString(statuses, status, status);
    }

    public async override Task<object> fetchFundingRateHistory(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name coinex#fetchFundingRateHistory
        * @see https://viabtc.github.io/coinex_api_en_doc/futures/#docsfutures001_http038_funding_history
        * @description fetches historical funding rate prices
        * @param {string} symbol unified symbol of the market to fetch the funding rate history for
        * @param {int} [since] timestamp in ms of the earliest funding rate to fetch
        * @param {int} [limit] the maximum amount of [funding rate structures]{@link https://docs.ccxt.com/#/?id=funding-rate-history-structure} to fetch
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [availble parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
        * @param {int} [params.until] timestamp in ms of the latest funding rate
        * @returns {object[]} a list of [funding rate structures]{@link https://docs.ccxt.com/#/?id=funding-rate-history-structure}
        */
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchFundingRateHistory() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object paginate = false;
        var paginateparametersVariable = this.handleOptionAndParams(parameters, "fetchFundingRateHistory", "paginate");
        paginate = ((IList<object>)paginateparametersVariable)[0];
        parameters = ((IList<object>)paginateparametersVariable)[1];
        if (isTrue(paginate))
        {
            return await this.fetchPaginatedCallDeterministic("fetchFundingRateHistory", symbol, since, limit, "8h", parameters, 1000);
        }
        if (isTrue(isEqual(limit, null)))
        {
            limit = 100;
        }
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "market", getValue(market, "id") },
            { "limit", limit },
            { "offset", 0 },
        };
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["start_time"] = since;
        }
        var requestparametersVariable = this.handleUntilOption("end_time", request, parameters);
        request = ((IList<object>)requestparametersVariable)[0];
        parameters = ((IList<object>)requestparametersVariable)[1];
        object response = await this.v1PerpetualPublicGetMarketFundingHistory(this.extend(request, parameters));
        //
        //     {
        //         "code": 0,
        //         "data": {
        //             "offset": 0,
        //             "limit": 3,
        //             "records": [
        //                 {
        //                     "time": 1650672021.6230309,
        //                     "market": "BTCUSDT",
        //                     "asset": "USDT",
        //                     "funding_rate": "0.00022913",
        //                     "funding_rate_real": "0.00022913"
        //                 },
        //             ]
        //         },
        //         "message": "OK"
        //     }
        //
        object data = this.safeValue(response, "data");
        object result = this.safeValue(data, "records", new List<object>() {});
        object rates = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(result)); postFixIncrement(ref i))
        {
            object entry = getValue(result, i);
            object marketId = this.safeString(entry, "market");
            object symbolInner = this.safeSymbol(marketId, market, null, "swap");
            object timestamp = this.safeTimestamp(entry, "time");
            ((IList<object>)rates).Add(new Dictionary<string, object>() {
                { "info", entry },
                { "symbol", symbolInner },
                { "fundingRate", this.safeNumber(entry, "funding_rate") },
                { "timestamp", timestamp },
                { "datetime", this.iso8601(timestamp) },
            });
        }
        object sorted = this.sortBy(rates, "timestamp");
        return this.filterBySymbolSinceLimit(sorted, getValue(market, "symbol"), since, limit);
    }

    public override object parseTransaction(object transaction, object currency = null)
    {
        //
        // fetchDeposits
        //
        //    {
        //        "coin_deposit_id": 32555985,
        //        "create_time": 1673325495,
        //        "amount": "12.71",
        //        "amount_display": "12.71",
        //        "diff_amount": "0",
        //        "min_amount": "0",
        //        "actual_amount": "12.71",
        //        "actual_amount_display": "12.71",
        //        "confirmations": 35,
        //        "tx_id": "0x57f1c92cc10b48316e2bf5faf230694fec2174e7744c1562a9a88b9c1e585f56",
        //        "tx_id_display": "0x57f1c92cc10b48316e2bf5faf230694fec2174e7744c1562a9a88b9c1e585f56",
        //        "coin_address": "0xe7a3831c56836f466b6a6268cff4fc852cf4b738",
        //        "coin_address_display": "0xe7a3****f4b738",
        //        "add_explorer": "https://bscscan.com/address/0xe7a3831c56836f466b6a6268cff4fc852cf4b738",
        //        "coin_type": "USDT",
        //        "smart_contract_name": "BSC",
        //        "transfer_method": "onchain",
        //        "status": "finish",
        //        "status_display": "finish",
        //        "remark": "",
        //        "explorer": "https://bscscan.com/tx/0x57f1c92cc10b48316e2bf5faf230694fec2174e7744c1562a9a88b9c1e585f56"
        //    }
        //
        // fetchWithdrawals
        //
        //    {
        //        "coin_withdraw_id": 20076836,
        //        "create_time": 1673325776,
        //        "actual_amount": "0.029",
        //        "actual_amount_display": "0.029",
        //        "amount": "0.03",
        //        "amount_display": "0.03",
        //        "coin_address": "MBhJcc3r5b3insc7QxyvEPtf31NqUdJpAb",
        //        "app_coin_address_display": "MBh****pAb",
        //        "coin_address_display": "MBhJcc****UdJpAb",
        //        "add_explorer": "https://explorer.viawallet.com/ltc/address/MBhJcc3r5b3insc7QxyvEPtf31NqUdJpAb",
        //        "coin_type": "LTC",
        //        "confirmations": 7,
        //        "explorer": "https://explorer.viawallet.com/ltc/tx/a0aa082132619b8a499b87e7d5bc3c508e0227104f5202ae26b695bb4cb7fbf9",
        //        "fee": "0",
        //        "remark": "",
        //        "smart_contract_name": "",
        //        "status": "finish",
        //        "status_display": "finish",
        //        "transfer_method": "onchain",
        //        "tx_fee": "0.001",
        //        "tx_id": "a0aa082132619b8a499b87e7d5bc3c508e0227104f5202ae26b695bb4cb7fbf9"
        //    }
        //
        object id = this.safeString2(transaction, "coin_withdraw_id", "coin_deposit_id");
        object address = this.safeString(transaction, "coin_address");
        object tag = this.safeString(transaction, "remark"); // set but unused
        if (isTrue(!isEqual(tag, null)))
        {
            if (isTrue(isLessThan(((string)tag).Length, 1)))
            {
                tag = null;
            }
        }
        object txid = this.safeValue(transaction, "tx_id");
        if (isTrue(!isEqual(txid, null)))
        {
            if (isTrue(isLessThan(getArrayLength(txid), 1)))
            {
                txid = null;
            }
        }
        object currencyId = this.safeString(transaction, "coin_type");
        object code = this.safeCurrencyCode(currencyId, currency);
        object timestamp = this.safeTimestamp(transaction, "create_time");
        object type = ((bool) isTrue((inOp(transaction, "coin_withdraw_id")))) ? "withdrawal" : "deposit";
        object status = this.parseTransactionStatus(this.safeString(transaction, "status"));
        object networkId = this.safeString(transaction, "smart_contract_name");
        object amount = this.safeNumber(transaction, "actual_amount");
        object feeCost = this.safeString(transaction, "tx_fee");
        object transferMethod = this.safeString(transaction, "transfer_method");
        object intern = isEqual(transferMethod, "local");
        object addressTo = null;
        object addressFrom = null;
        if (isTrue(isEqual(type, "deposit")))
        {
            feeCost = "0";
            addressTo = address;
        } else
        {
            addressFrom = address;
        }
        object fee = new Dictionary<string, object>() {
            { "cost", this.parseNumber(feeCost) },
            { "currency", code },
        };
        return new Dictionary<string, object>() {
            { "info", transaction },
            { "id", id },
            { "txid", txid },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "network", this.networkIdToCode(networkId) },
            { "address", address },
            { "addressTo", null },
            { "addressFrom", null },
            { "tag", tag },
            { "tagTo", addressTo },
            { "tagFrom", addressFrom },
            { "type", type },
            { "amount", this.parseNumber(amount) },
            { "currency", code },
            { "status", status },
            { "updated", null },
            { "fee", fee },
            { "comment", null },
            { "internal", intern },
        };
    }

    public async override Task<object> transfer(object code, object amount, object fromAccount, object toAccount, object parameters = null)
    {
        /**
        * @method
        * @name coinex#transfer
        * @description transfer currency internally between wallets on the same account
        * @see https://viabtc.github.io/coinex_api_en_doc/spot/#docsspot002_account014_balance_contract_transfer
        * @see https://viabtc.github.io/coinex_api_en_doc/spot/#docsspot002_account013_margin_transfer
        * @param {string} code unified currency code
        * @param {float} amount amount to transfer
        * @param {string} fromAccount account to transfer from
        * @param {string} toAccount account to transfer to
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [transfer structure]{@link https://docs.ccxt.com/#/?id=transfer-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        object amountToPrecision = this.currencyToPrecision(code, amount);
        object request = new Dictionary<string, object>() {
            { "amount", amountToPrecision },
            { "coin_type", getValue(currency, "id") },
        };
        object response = null;
        if (isTrue(isTrue((isEqual(fromAccount, "spot"))) && isTrue((isEqual(toAccount, "swap")))))
        {
            ((IDictionary<string,object>)request)["transfer_side"] = "in"; // 'in' spot to swap, 'out' swap to spot
            response = await this.v1PrivatePostContractBalanceTransfer(this.extend(request, parameters));
        } else if (isTrue(isTrue((isEqual(fromAccount, "swap"))) && isTrue((isEqual(toAccount, "spot")))))
        {
            ((IDictionary<string,object>)request)["transfer_side"] = "out"; // 'in' spot to swap, 'out' swap to spot
            response = await this.v1PrivatePostContractBalanceTransfer(this.extend(request, parameters));
        } else
        {
            object accountsById = this.safeValue(this.options, "accountsById", new Dictionary<string, object>() {});
            object fromId = this.safeString(accountsById, fromAccount, fromAccount);
            object toId = this.safeString(accountsById, toAccount, toAccount);
            // fromAccount and toAccount must be integers for margin transfers
            // spot is 0, use fetchBalance() to find the margin account id
            ((IDictionary<string,object>)request)["from_account"] = parseInt(fromId);
            ((IDictionary<string,object>)request)["to_account"] = parseInt(toId);
            response = await this.v1PrivatePostMarginTransfer(this.extend(request, parameters));
        }
        //
        //     {"code": 0, "data": null, "message": "Success"}
        //
        return this.extend(this.parseTransfer(response, currency), new Dictionary<string, object>() {
            { "amount", this.parseNumber(amountToPrecision) },
            { "fromAccount", fromAccount },
            { "toAccount", toAccount },
        });
    }

    public virtual object parseTransferStatus(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "0", "ok" },
            { "SUCCESS", "ok" },
        };
        return this.safeString(statuses, status, status);
    }

    public override object parseTransfer(object transfer, object currency = null)
    {
        //
        // fetchTransfers Swap
        //
        //     {
        //         "amount": "10",
        //         "asset": "USDT",
        //         "transfer_type": "transfer_out", // from swap to spot
        //         "created_at": 1651633422
        //     },
        //
        // fetchTransfers Margin
        //
        //     {
        //         "id": 7580062,
        //         "updated_at": 1653684379,
        //         "user_id": 3620173,
        //         "from_account_id": 0,
        //         "to_account_id": 1,
        //         "asset": "BTC",
        //         "amount": "0.00160829",
        //         "balance": "0.00160829",
        //         "transfer_type": "IN",
        //         "status": "SUCCESS",
        //         "created_at": 1653684379
        //     },
        //
        object timestamp = this.safeTimestamp(transfer, "created_at");
        object transferType = this.safeString(transfer, "transfer_type");
        object fromAccount = null;
        object toAccount = null;
        if (isTrue(isEqual(transferType, "transfer_out")))
        {
            fromAccount = "swap";
            toAccount = "spot";
        } else if (isTrue(isEqual(transferType, "transfer_in")))
        {
            fromAccount = "spot";
            toAccount = "swap";
        } else if (isTrue(isEqual(transferType, "IN")))
        {
            fromAccount = "spot";
            toAccount = "margin";
        } else if (isTrue(isEqual(transferType, "OUT")))
        {
            fromAccount = "margin";
            toAccount = "spot";
        }
        object currencyId = this.safeString(transfer, "asset");
        object currencyCode = this.safeCurrencyCode(currencyId, currency);
        return new Dictionary<string, object>() {
            { "info", transfer },
            { "id", this.safeInteger(transfer, "id") },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "currency", currencyCode },
            { "amount", this.safeNumber(transfer, "amount") },
            { "fromAccount", fromAccount },
            { "toAccount", toAccount },
            { "status", this.parseTransferStatus(this.safeString2(transfer, "code", "status")) },
        };
    }

    public async virtual Task<object> fetchTransfers(object code = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name coinex#fetchTransfers
        * @description fetch a history of internal transfers made on an account
        * @see https://viabtc.github.io/coinex_api_en_doc/spot/#docsspot002_account025_margin_transfer_history
        * @see https://viabtc.github.io/coinex_api_en_doc/spot/#docsspot002_account024_contract_transfer_history
        * @param {string} code unified currency code of the currency transferred
        * @param {int} [since] the earliest time in ms to fetch transfers for
        * @param {int} [limit] the maximum number of  transfers structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} a list of [transfer structures]{@link https://docs.ccxt.com/#/?id=transfer-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = null;
        object request = new Dictionary<string, object>() {
            { "page", 1 },
        };
        object page = this.safeInteger(parameters, "page");
        if (isTrue(!isEqual(page, null)))
        {
            ((IDictionary<string,object>)request)["page"] = page;
        }
        if (isTrue(!isEqual(code, null)))
        {
            currency = this.currency(code);
            ((IDictionary<string,object>)request)["asset"] = getValue(currency, "id");
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["start_time"] = since;
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        } else
        {
            ((IDictionary<string,object>)request)["limit"] = 100;
        }
        parameters = this.omit(parameters, "page");
        object marginMode = null;
        var marginModeparametersVariable = this.handleMarginModeAndParams("fetchTransfers", parameters);
        marginMode = ((IList<object>)marginModeparametersVariable)[0];
        parameters = ((IList<object>)marginModeparametersVariable)[1];
        object response = null;
        if (isTrue(!isEqual(marginMode, null)))
        {
            response = await this.v1PrivateGetMarginTransferHistory(this.extend(request, parameters));
        } else
        {
            response = await this.v1PrivateGetContractTransferHistory(this.extend(request, parameters));
        }
        //
        // Swap
        //
        //     {
        //         "code": 0,
        //         "data": {
        //             "records": [
        //                 {
        //                     "amount": "10",
        //                     "asset": "USDT",
        //                     "transfer_type": "transfer_out",
        //                     "created_at": 1651633422
        //                 },
        //             ],
        //             "total": 5
        //         },
        //         "message": "Success"
        //     }
        //
        // Margin
        //
        //     {
        //         "code": 0,
        //         "data": {
        //             "records": [
        //                 {
        //                     "id": 7580062,
        //                     "updated_at": 1653684379,
        //                     "user_id": 3620173,
        //                     "from_account_id": 0,
        //                     "to_account_id": 1,
        //                     "asset": "BTC",
        //                     "amount": "0.00160829",
        //                     "balance": "0.00160829",
        //                     "transfer_type": "IN",
        //                     "status": "SUCCESS",
        //                     "created_at": 1653684379
        //                 }
        //             ],
        //             "total": 1
        //         },
        //         "message": "Success"
        //     }
        //
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        object transfers = this.safeList(data, "records", new List<object>() {});
        return this.parseTransfers(transfers, currency, since, limit);
    }

    public async override Task<object> fetchWithdrawals(object code = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name coinex#fetchWithdrawals
        * @description fetch all withdrawals made from an account
        * @see https://viabtc.github.io/coinex_api_en_doc/spot/#docsspot002_account026_withdraw_list
        * @param {string} code unified currency code
        * @param {int} [since] the earliest time in ms to fetch withdrawals for
        * @param {int} [limit] the maximum number of withdrawals structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
        */
        parameters ??= new Dictionary<string, object>();
        object request = new Dictionary<string, object>() {};
        object currency = null;
        if (isTrue(!isEqual(code, null)))
        {
            await this.loadMarkets();
            currency = this.currency(code);
            ((IDictionary<string,object>)request)["coin_type"] = getValue(currency, "id");
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["Limit"] = limit;
        }
        object response = await this.v1PrivateGetBalanceCoinWithdraw(this.extend(request, parameters));
        //
        //    {
        //        "code": 0,
        //        "data": {
        //            "has_next": false,
        //            "curr_page": 1,
        //            "count": 1,
        //            "data": [
        //                {
        //                    "coin_withdraw_id": 20076836,
        //                    "create_time": 1673325776,
        //                    "actual_amount": "0.029",
        //                    "actual_amount_display": "0.029",
        //                    "amount": "0.03",
        //                    "amount_display": "0.03",
        //                    "coin_address": "MBhJcc3r5b3insc7QxyvEPtf31NqUdJpAb",
        //                    "app_coin_address_display": "MBh****pAb",
        //                    "coin_address_display": "MBhJcc****UdJpAb",
        //                    "add_explorer": "https://explorer.viawallet.com/ltc/address/MBhJcc3r5b3insc7QxyvEPtf31NqUdJpAb",
        //                    "coin_type": "LTC",
        //                    "confirmations": 7,
        //                    "explorer": "https://explorer.viawallet.com/ltc/tx/a0aa082132619b8a499b87e7d5bc3c508e0227104f5202ae26b695bb4cb7fbf9",
        //                    "fee": "0",
        //                    "remark": "",
        //                    "smart_contract_name": "",
        //                    "status": "finish",
        //                    "status_display": "finish",
        //                    "transfer_method": "onchain",
        //                    "tx_fee": "0.001",
        //                    "tx_id": "a0aa082132619b8a499b87e7d5bc3c508e0227104f5202ae26b695bb4cb7fbf9"
        //                }
        //            ],
        //            "total": 1,
        //            "total_page": 1
        //        },
        //        "message": "Success"
        //    }
        //
        object data = this.safeValue(response, "data");
        if (!isTrue(((data is IList<object>) || (data.GetType().IsGenericType && data.GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>))))))
        {
            data = this.safeValue(data, "data", new List<object>() {});
        }
        return this.parseTransactions(data, currency, since, limit);
    }

    public async override Task<object> fetchDeposits(object code = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name coinex#fetchDeposits
        * @description fetch all deposits made to an account
        * @see https://viabtc.github.io/coinex_api_en_doc/spot/#docsspot002_account009_deposit_list
        * @param {string} code unified currency code
        * @param {int} [since] the earliest time in ms to fetch deposits for
        * @param {int} [limit] the maximum number of deposits structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
        */
        parameters ??= new Dictionary<string, object>();
        object request = new Dictionary<string, object>() {};
        object currency = null;
        if (isTrue(!isEqual(code, null)))
        {
            await this.loadMarkets();
            currency = this.currency(code);
            ((IDictionary<string,object>)request)["coin_type"] = getValue(currency, "id");
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["Limit"] = limit;
        }
        object response = await this.v1PrivateGetBalanceCoinDeposit(this.extend(request, parameters));
        //
        //    {
        //        "code": 0,
        //        "data": {
        //            "has_next": false,
        //            "curr_page": 1,
        //            "count": 1,
        //            "data": [
        //                {
        //                    "coin_deposit_id": 32555985,
        //                    "create_time": 1673325495,
        //                    "amount": "12.71",
        //                    "amount_display": "12.71",
        //                    "diff_amount": "0",
        //                    "min_amount": "0",
        //                    "actual_amount": "12.71",
        //                    "actual_amount_display": "12.71",
        //                    "confirmations": 35,
        //                    "tx_id": "0x57f1c92cc10b48316e2bf5faf230694fec2174e7744c1562a9a88b9c1e585f56",
        //                    "tx_id_display": "0x57f1c92cc10b48316e2bf5faf230694fec2174e7744c1562a9a88b9c1e585f56",
        //                    "coin_address": "0xe7a3831c56836f466b6a6268cff4fc852cf4b738",
        //                    "coin_address_display": "0xe7a3****f4b738",
        //                    "add_explorer": "https://bscscan.com/address/0xe7a3831c56836f466b6a6268cff4fc852cf4b738",
        //                    "coin_type": "USDT",
        //                    "smart_contract_name": "BSC",
        //                    "transfer_method": "onchain",
        //                    "status": "finish",
        //                    "status_display": "finish",
        //                    "remark": "",
        //                    "explorer": "https://bscscan.com/tx/0x57f1c92cc10b48316e2bf5faf230694fec2174e7744c1562a9a88b9c1e585f56"
        //                }
        //            ],
        //            "total": 1,
        //            "total_page": 1
        //        },
        //        "message": "Success"
        //    }
        //
        object data = this.safeValue(response, "data");
        if (!isTrue(((data is IList<object>) || (data.GetType().IsGenericType && data.GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>))))))
        {
            data = this.safeValue(data, "data", new List<object>() {});
        }
        return this.parseTransactions(data, currency, since, limit);
    }

    public override object parseIsolatedBorrowRate(object info, object market = null)
    {
        //
        //     {
        //         "market": "BTCUSDT",
        //         "leverage": 10,
        //         "BTC": {
        //             "min_amount": "0.002",
        //             "max_amount": "200",
        //             "day_rate": "0.001"
        //         },
        //         "USDT": {
        //             "min_amount": "60",
        //             "max_amount": "5000000",
        //             "day_rate": "0.001"
        //         }
        //     },
        //
        object marketId = this.safeString(info, "market");
        market = this.safeMarket(marketId, market, null, "spot");
        object baseInfo = this.safeValue(info, getValue(market, "baseId"));
        object quoteInfo = this.safeValue(info, getValue(market, "quoteId"));
        return new Dictionary<string, object>() {
            { "symbol", getValue(market, "symbol") },
            { "base", getValue(market, "base") },
            { "baseRate", this.safeNumber(baseInfo, "day_rate") },
            { "quote", getValue(market, "quote") },
            { "quoteRate", this.safeNumber(quoteInfo, "day_rate") },
            { "period", 86400000 },
            { "timestamp", null },
            { "datetime", null },
            { "info", info },
        };
    }

    public async override Task<object> fetchIsolatedBorrowRate(object symbol, object parameters = null)
    {
        /**
        * @method
        * @name coinex#fetchIsolatedBorrowRate
        * @description fetch the rate of interest to borrow a currency for margin trading
        * @see https://viabtc.github.io/coinex_api_en_doc/spot/#docsspot002_account007_margin_account_settings
        * @param {string} symbol unified symbol of the market to fetch the borrow rate for
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} an [isolated borrow rate structure]{@link https://docs.ccxt.com/#/?id=isolated-borrow-rate-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "market", getValue(market, "id") },
        };
        object response = await this.v1PrivateGetMarginConfig(this.extend(request, parameters));
        //
        //     {
        //         "code": 0,
        //         "data": {
        //             "market": "BTCUSDT",
        //             "leverage": 10,
        //             "BTC": {
        //                 "min_amount": "0.002",
        //                 "max_amount": "200",
        //                 "day_rate": "0.001"
        //             },
        //             "USDT": {
        //                 "min_amount": "60",
        //                 "max_amount": "5000000",
        //                 "day_rate": "0.001"
        //             }
        //         },
        //         "message": "Success"
        //     }
        //
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        return this.parseIsolatedBorrowRate(data, market);
    }

    public async override Task<object> fetchIsolatedBorrowRates(object parameters = null)
    {
        /**
        * @method
        * @name coinex#fetchIsolatedBorrowRates
        * @description fetch the borrow interest rates of all currencies
        * @see https://viabtc.github.io/coinex_api_en_doc/spot/#docsspot002_account007_margin_account_settings
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a list of [isolated borrow rate structures]{@link https://github.com/ccxt/ccxt/wiki/Manual#isolated-borrow-rate-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.v1PrivateGetMarginConfig(parameters);
        //
        //     {
        //         "code": 0,
        //         "data": [
        //             {
        //                 "market": "BTCUSDT",
        //                 "leverage": 10,
        //                 "BTC": {
        //                     "min_amount": "0.002",
        //                     "max_amount": "200",
        //                     "day_rate": "0.001"
        //                 },
        //                 "USDT": {
        //                     "min_amount": "60",
        //                     "max_amount": "5000000",
        //                     "day_rate": "0.001"
        //                 }
        //             },
        //         ],
        //         "message": "Success"
        //     }
        //
        object data = this.safeValue(response, "data", new List<object>() {});
        return this.parseIsolatedBorrowRates(data);
    }

    public async override Task<object> fetchBorrowInterest(object code = null, object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            ((IDictionary<string,object>)request)["market"] = getValue(market, "id");
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        object response = await this.v1PrivateGetMarginLoanHistory(this.extend(request, parameters));
        //
        //     {
        //         "code": 0,
        //         "data": {
        //             "page": 1,
        //             "limit": 10,
        //             "total": 1,
        //             "has_next": false,
        //             "curr_page": 1,
        //             "count": 1,
        //             "data": [
        //                 {
        //                     "loan_id": 2616357,
        //                     "create_time": 1654214027,
        //                     "market_type": "BTCUSDT",
        //                     "coin_type": "BTC",
        //                     "day_rate": "0.001",
        //                     "loan_amount": "0.0144",
        //                     "interest_amount": "0",
        //                     "unflat_amount": "0",
        //                     "expire_time": 1655078027,
        //                     "is_renew": true,
        //                     "status": "finish"
        //                 }
        //             ],
        //             "total_page": 1
        //         },
        //         "message": "Success"
        //     }
        //
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        object rows = this.safeValue(data, "data", new List<object>() {});
        object interest = this.parseBorrowInterests(rows, market);
        return this.filterByCurrencySinceLimit(interest, code, since, limit);
    }

    public override object parseBorrowInterest(object info, object market = null)
    {
        //
        //     {
        //         "loan_id": 2616357,
        //         "create_time": 1654214027,
        //         "market_type": "BTCUSDT",
        //         "coin_type": "BTC",
        //         "day_rate": "0.001",
        //         "loan_amount": "0.0144",
        //         "interest_amount": "0",
        //         "unflat_amount": "0",
        //         "expire_time": 1655078027,
        //         "is_renew": true,
        //         "status": "finish"
        //     }
        //
        object marketId = this.safeString(info, "market_type");
        market = this.safeMarket(marketId, market, null, "spot");
        object symbol = this.safeString(market, "symbol");
        object timestamp = this.safeTimestamp(info, "expire_time");
        object unflatAmount = this.safeString(info, "unflat_amount");
        object loanAmount = this.safeString(info, "loan_amount");
        object interest = Precise.stringSub(unflatAmount, loanAmount);
        if (isTrue(isEqual(unflatAmount, "0")))
        {
            interest = null;
        }
        return new Dictionary<string, object>() {
            { "account", null },
            { "symbol", symbol },
            { "marginMode", "isolated" },
            { "marginType", null },
            { "currency", this.safeCurrencyCode(this.safeString(info, "coin_type")) },
            { "interest", this.parseNumber(interest) },
            { "interestRate", this.safeNumber(info, "day_rate") },
            { "amountBorrowed", this.parseNumber(loanAmount) },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "info", info },
        };
    }

    public async override Task<object> borrowIsolatedMargin(object symbol, object code, object amount, object parameters = null)
    {
        /**
        * @method
        * @name coinex#borrowIsolatedMargin
        * @description create a loan to borrow margin
        * @see https://viabtc.github.io/coinex_api_en_doc/spot/#docsspot002_account017_margin_loan
        * @param {string} symbol unified market symbol, required for coinex
        * @param {string} code unified currency code of the currency to borrow
        * @param {float} amount the amount to borrow
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [margin loan structure]{@link https://docs.ccxt.com/#/?id=margin-loan-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "market", getValue(market, "id") },
            { "coin_type", getValue(currency, "id") },
            { "amount", this.currencyToPrecision(code, amount) },
        };
        object response = await this.v1PrivatePostMarginLoan(this.extend(request, parameters));
        //
        //     {
        //         "code": 0,
        //         "data": {
        //             "loan_id": 1670
        //         },
        //         "message": "Success"
        //     }
        //
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        object transaction = this.parseMarginLoan(data, currency);
        return this.extend(transaction, new Dictionary<string, object>() {
            { "amount", amount },
            { "symbol", symbol },
        });
    }

    public async override Task<object> repayIsolatedMargin(object symbol, object code, object amount, object parameters = null)
    {
        /**
        * @method
        * @name coinex#repayIsolatedMargin
        * @description repay borrowed margin and interest
        * @see https://viabtc.github.io/coinex_api_en_doc/spot/#docsspot002_account018_margin_flat
        * @param {string} symbol unified market symbol, required for coinex
        * @param {string} code unified currency code of the currency to repay
        * @param {float} amount the amount to repay
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {string} [params.loan_id] extra parameter that is not required
        * @returns {object} a [margin loan structure]{@link https://docs.ccxt.com/#/?id=margin-loan-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "market", getValue(market, "id") },
            { "coin_type", getValue(currency, "id") },
            { "amount", this.currencyToPrecision(code, amount) },
        };
        object response = await this.v1PrivatePostMarginFlat(this.extend(request, parameters));
        //
        //     {
        //         "code": 0,
        //         "data": null,
        //         "message": "Success"
        //     }
        //
        object transaction = this.parseMarginLoan(response, currency);
        return this.extend(transaction, new Dictionary<string, object>() {
            { "amount", amount },
            { "symbol", symbol },
        });
    }

    public virtual object parseMarginLoan(object info, object currency = null)
    {
        //
        // borrowMargin
        //
        //     {
        //         "loan_id": 1670
        //     }
        //
        // repayMargin
        //
        //     {
        //         "code": 0,
        //         "data": null,
        //         "message": "Success"
        //     }
        //
        return new Dictionary<string, object>() {
            { "id", this.safeInteger(info, "loan_id") },
            { "currency", this.safeCurrencyCode(null, currency) },
            { "amount", null },
            { "symbol", null },
            { "timestamp", null },
            { "datetime", null },
            { "info", info },
        };
    }

    public async override Task<object> fetchDepositWithdrawFees(object codes = null, object parameters = null)
    {
        /**
        * @method
        * @name coinex#fetchDepositWithdrawFees
        * @description fetch deposit and withdraw fees
        * @see https://viabtc.github.io/coinex_api_en_doc/spot/#docsspot001_market010_asset_config
        * @param {string[]|undefined} codes list of unified currency codes
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} a list of [fees structures]{@link https://docs.ccxt.com/#/?id=fee-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        if (isTrue(!isEqual(codes, null)))
        {
            object codesLength = getArrayLength(codes);
            if (isTrue(isEqual(codesLength, 1)))
            {
                ((IDictionary<string,object>)request)["coin_type"] = this.safeValue(codes, 0);
            }
        }
        object response = await this.v1PublicGetCommonAssetConfig(this.extend(request, parameters));
        //
        //    {
        //        "code": 0,
        //        "data": {
        //            "CET-CSC": {
        //                "asset": "CET",
        //                "chain": "CSC",
        //                "can_deposit": true,
        //                "can_withdraw ": false,
        //                "deposit_least_amount": "1",
        //                "withdraw_least_amount": "1",
        //                "withdraw_tx_fee": "0.1"
        //            },
        //            "CET-ERC20": {
        //                "asset": "CET",
        //                "chain": "ERC20",
        //                "can_deposit": true,
        //                "can_withdraw": false,
        //                "deposit_least_amount": "14",
        //                "withdraw_least_amount": "14",
        //                "withdraw_tx_fee": "14"
        //            }
        //        },
        //        "message": "Success"
        //    }
        //
        return this.parseDepositWithdrawFees(response, codes);
    }

    public override object parseDepositWithdrawFees(object response, object codes = null, object currencyIdKey = null)
    {
        object depositWithdrawFees = new Dictionary<string, object>() {};
        codes = this.marketCodes(codes);
        object data = this.safeValue(response, "data");
        object currencyIds = new List<object>(((IDictionary<string,object>)data).Keys);
        for (object i = 0; isLessThan(i, getArrayLength(currencyIds)); postFixIncrement(ref i))
        {
            object entry = getValue(currencyIds, i);
            object splitEntry = ((string)entry).Split(new [] {((string)"-")}, StringSplitOptions.None).ToList<object>();
            object feeInfo = getValue(data, getValue(currencyIds, i));
            object currencyId = this.safeString(feeInfo, "asset");
            object currency = this.safeCurrency(currencyId);
            object code = this.safeString(currency, "code");
            if (isTrue(isTrue((isEqual(codes, null))) || isTrue((this.inArray(code, codes)))))
            {
                object depositWithdrawFee = this.safeValue(depositWithdrawFees, code);
                if (isTrue(isEqual(depositWithdrawFee, null)))
                {
                    ((IDictionary<string,object>)depositWithdrawFees)[(string)code] = this.depositWithdrawFee(new Dictionary<string, object>() {});
                }
                ((IDictionary<string,object>)getValue(getValue(depositWithdrawFees, code), "info"))[(string)entry] = feeInfo;
                object networkId = this.safeString(splitEntry, 1);
                object withdrawFee = this.safeValue(feeInfo, "withdraw_tx_fee");
                object withdrawResult = new Dictionary<string, object>() {
                    { "fee", withdrawFee },
                    { "percentage", ((bool) isTrue((!isEqual(withdrawFee, null)))) ? false : null },
                };
                object depositResult = new Dictionary<string, object>() {
                    { "fee", null },
                    { "percentage", null },
                };
                if (isTrue(!isEqual(networkId, null)))
                {
                    object networkCode = this.networkIdToCode(networkId);
                    ((IDictionary<string,object>)getValue(getValue(depositWithdrawFees, code), "networks"))[(string)networkCode] = new Dictionary<string, object>() {
                        { "withdraw", withdrawResult },
                        { "deposit", depositResult },
                    };
                } else
                {
                    ((IDictionary<string,object>)getValue(depositWithdrawFees, code))["withdraw"] = withdrawResult;
                    ((IDictionary<string,object>)getValue(depositWithdrawFees, code))["deposit"] = depositResult;
                }
            }
        }
        object depositWithdrawCodes = new List<object>(((IDictionary<string,object>)depositWithdrawFees).Keys);
        for (object i = 0; isLessThan(i, getArrayLength(depositWithdrawCodes)); postFixIncrement(ref i))
        {
            object code = getValue(depositWithdrawCodes, i);
            object currency = this.currency(code);
            ((IDictionary<string,object>)depositWithdrawFees)[(string)code] = this.assignDefaultDepositWithdrawFees(getValue(depositWithdrawFees, code), currency);
        }
        return depositWithdrawFees;
    }

    public async override Task<object> fetchLeverages(object symbols = null, object parameters = null)
    {
        /**
        * @method
        * @name coinex#fetchLeverages
        * @description fetch the set leverage for all contract and margin markets
        * @see https://viabtc.github.io/coinex_api_en_doc/spot/#docsspot002_account007_margin_account_settings
        * @param {string[]} [symbols] a list of unified market symbols
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a list of [leverage structures]{@link https://docs.ccxt.com/#/?id=leverage-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        symbols = this.marketSymbols(symbols);
        object market = null;
        if (isTrue(!isEqual(symbols, null)))
        {
            object symbol = this.safeValue(symbols, 0);
            market = this.market(symbol);
        }
        object marketType = null;
        var marketTypeparametersVariable = this.handleMarketTypeAndParams("fetchLeverages", market, parameters);
        marketType = ((IList<object>)marketTypeparametersVariable)[0];
        parameters = ((IList<object>)marketTypeparametersVariable)[1];
        if (isTrue(!isEqual(marketType, "spot")))
        {
            throw new NotSupported ((string)add(this.id, " fetchLeverages() supports spot margin markets only")) ;
        }
        object response = await this.v1PrivateGetMarginConfig(parameters);
        //
        //     {
        //         "code": 0,
        //         "data": [
        //             {
        //                 "market": "BTCUSDT",
        //                 "leverage": 10,
        //                 "BTC": {
        //                     "min_amount": "0.0008",
        //                     "max_amount": "200",
        //                     "day_rate": "0.0015"
        //                 },
        //                 "USDT": {
        //                     "min_amount": "50",
        //                     "max_amount": "500000",
        //                     "day_rate": "0.001"
        //                 }
        //             },
        //         ],
        //         "message": "Success"
        //     }
        //
        object leverages = this.safeList(response, "data", new List<object>() {});
        return this.parseLeverages(leverages, symbols, "market", marketType);
    }

    public override object parseLeverage(object leverage, object market = null)
    {
        object marketId = this.safeString(leverage, "market");
        object leverageValue = this.safeInteger(leverage, "leverage");
        return new Dictionary<string, object>() {
            { "info", leverage },
            { "symbol", this.safeSymbol(marketId, market, null, "spot") },
            { "marginMode", null },
            { "longLeverage", leverageValue },
            { "shortLeverage", leverageValue },
        };
    }

    public async override Task<object> fetchPositionHistory(object symbol, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name coinex#fetchPositionHistory
        * @description fetches historical positions
        * @see https://docs.coinex.com/api/v2/futures/position/http/list-finished-position
        * @param {string} symbol unified contract symbol
        * @param {int} [since] the earliest time in ms to fetch positions for
        * @param {int} [limit] the maximum amount of records to fetch, default is 10
        * @param {object} [params] extra parameters specific to the exchange api endpoint
        * @param {int} [params.until] the latest time in ms to fetch positions for
        * @returns {object[]} a list of [position structures]{@link https://docs.ccxt.com/#/?id=position-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "market_type", "FUTURES" },
            { "market", getValue(market, "id") },
        };
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["start_time"] = since;
        }
        var requestparametersVariable = this.handleUntilOption("end_time", request, parameters);
        request = ((IList<object>)requestparametersVariable)[0];
        parameters = ((IList<object>)requestparametersVariable)[1];
        object response = await this.v2PrivateGetFuturesFinishedPosition(this.extend(request, parameters));
        //
        //     {
        //         "code": 0,
        //         "data": [
        //             {
        //                 "position_id": 305891033,
        //                 "market": "BTCUSDT",
        //                 "market_type": "FUTURES",
        //                 "side": "long",
        //                 "margin_mode": "cross",
        //                 "open_interest": "0.0001",
        //                 "close_avbl": "0.0001",
        //                 "ath_position_amount": "0.0001",
        //                 "unrealized_pnl": "0",
        //                 "realized_pnl": "-0.00311684",
        //                 "avg_entry_price": "62336.8",
        //                 "cml_position_value": "6.23368",
        //                 "max_position_value": "6.23368",
        //                 "created_at": 1715152208041,
        //                 "updated_at": 1715152208041,
        //                 "take_profit_price": "0",
        //                 "stop_loss_price": "0",
        //                 "take_profit_type": "",
        //                 "stop_loss_type": "",
        //                 "settle_price": "62336.8",
        //                 "settle_value": "6.23368",
        //                 "leverage": "3",
        //                 "margin_avbl": "2.07789333",
        //                 "ath_margin_size": "2.07789333",
        //                 "position_margin_rate": "2.40545879023305655728",
        //                 "maintenance_margin_rate": "0.005",
        //                 "maintenance_margin_value": "0.03118094",
        //                 "liq_price": "0",
        //                 "bkr_price": "0",
        //                 "adl_level": 1
        //             }
        //         ],
        //         "message": "OK",
        //         "pagination": {
        //             "has_next": false
        //         }
        //     }
        //
        object records = this.safeList(response, "data", new List<object>() {});
        object positions = this.parsePositions(records);
        return this.filterBySymbolSinceLimit(positions, symbol, since, limit);
    }

    public override object handleMarginModeAndParams(object methodName, object parameters = null, object defaultValue = null)
    {
        /**
        * @ignore
        * @method
        * @description marginMode specified by params["marginMode"], this.options["marginMode"], this.options["defaultMarginMode"], params["margin"] = true or this.options["defaultType"] = 'margin'
        * @param {object} params extra parameters specific to the exchange api endpoint
        * @returns {Array} the marginMode in lowercase
        */
        parameters ??= new Dictionary<string, object>();
        object defaultType = this.safeString(this.options, "defaultType");
        object isMargin = this.safeBool(parameters, "margin", false);
        object marginMode = null;
        var marginModeparametersVariable = base.handleMarginModeAndParams(methodName, parameters, defaultValue);
        marginMode = ((IList<object>)marginModeparametersVariable)[0];
        parameters = ((IList<object>)marginModeparametersVariable)[1];
        if (isTrue(isEqual(marginMode, null)))
        {
            if (isTrue(isTrue((isEqual(defaultType, "margin"))) || isTrue((isEqual(isMargin, true)))))
            {
                marginMode = "isolated";
            }
        }
        return new List<object>() {marginMode, parameters};
    }

    public override object nonce()
    {
        return this.milliseconds();
    }

    public override object sign(object path, object api = null, object method = null, object parameters = null, object headers = null, object body = null)
    {
        api ??= new List<object>();
        method ??= "GET";
        parameters ??= new Dictionary<string, object>();
        path = this.implodeParams(path, parameters);
        object version = getValue(api, 0);
        object requestUrl = getValue(api, 1);
        object url = add(add(add(add(getValue(getValue(this.urls, "api"), requestUrl), "/"), version), "/"), path);
        object query = this.omit(parameters, this.extractParams(path));
        object nonce = ((object)this.nonce()).ToString();
        if (isTrue(isEqual(method, "POST")))
        {
            object parts = ((string)path).Split(new [] {((string)"/")}, StringSplitOptions.None).ToList<object>();
            object firstPart = this.safeString(parts, 0, "");
            object numParts = getArrayLength(parts);
            object lastPart = this.safeString(parts, subtract(numParts, 1), "");
            object lastWords = ((string)lastPart).Split(new [] {((string)"_")}, StringSplitOptions.None).ToList<object>();
            object numWords = getArrayLength(lastWords);
            object lastWord = this.safeString(lastWords, subtract(numWords, 1), "");
            if (isTrue(isTrue((isEqual(firstPart, "order"))) && isTrue((isTrue(isEqual(lastWord, "limit")) || isTrue(isEqual(lastWord, "market"))))))
            {
                // inject in implicit API calls
                // POST /order/limit - Place limit orders
                // POST /order/market - Place market orders
                // POST /order/stop/limit - Place stop limit orders
                // POST /order/stop/market - Place stop market orders
                // POST /perpetual/v1/order/put_limit - Place limit orders
                // POST /perpetual/v1/order/put_market - Place market orders
                // POST /perpetual/v1/order/put_stop_limit - Place stop limit orders
                // POST /perpetual/v1/order/put_stop_market - Place stop market orders
                object clientOrderId = this.safeString(parameters, "client_id");
                if (isTrue(isEqual(clientOrderId, null)))
                {
                    object defaultId = "x-167673045";
                    object brokerId = this.safeValue(this.options, "brokerId", defaultId);
                    ((IDictionary<string,object>)query)["client_id"] = add(add(brokerId, "_"), this.uuid16());
                }
            }
        }
        if (isTrue(isEqual(requestUrl, "perpetualPrivate")))
        {
            this.checkRequiredCredentials();
            query = this.extend(new Dictionary<string, object>() {
                { "access_id", this.apiKey },
                { "timestamp", nonce },
            }, query);
            query = this.keysort(query);
            object urlencoded = this.rawencode(query);
            object signature = this.hash(this.encode(add(add(urlencoded, "&secret_key="), this.secret)), sha256);
            headers = new Dictionary<string, object>() {
                { "Authorization", ((string)signature).ToLower() },
                { "AccessId", this.apiKey },
            };
            if (isTrue(isTrue((isEqual(method, "GET"))) || isTrue((isEqual(method, "PUT")))))
            {
                url = add(url, add("?", urlencoded));
            } else
            {
                ((IDictionary<string,object>)headers)["Content-Type"] = "application/x-www-form-urlencoded";
                body = urlencoded;
            }
        } else if (isTrue(isTrue(isEqual(requestUrl, "public")) || isTrue(isEqual(requestUrl, "perpetualPublic"))))
        {
            if (isTrue(getArrayLength(new List<object>(((IDictionary<string,object>)query).Keys))))
            {
                url = add(url, add("?", this.urlencode(query)));
            }
        } else
        {
            if (isTrue(isEqual(version, "v1")))
            {
                this.checkRequiredCredentials();
                query = this.extend(new Dictionary<string, object>() {
                    { "access_id", this.apiKey },
                    { "tonce", nonce },
                }, query);
                query = this.keysort(query);
                object urlencoded = this.rawencode(query);
                object signature = this.hash(this.encode(add(add(urlencoded, "&secret_key="), this.secret)), md5);
                headers = new Dictionary<string, object>() {
                    { "Authorization", ((string)signature).ToUpper() },
                    { "Content-Type", "application/json" },
                };
                if (isTrue(isTrue(isTrue((isEqual(method, "GET"))) || isTrue((isEqual(method, "DELETE")))) || isTrue((isEqual(method, "PUT")))))
                {
                    url = add(url, add("?", urlencoded));
                } else
                {
                    body = this.json(query);
                }
            } else if (isTrue(isEqual(version, "v2")))
            {
                this.checkRequiredCredentials();
                query = this.keysort(query);
                object urlencoded = this.rawencode(query);
                object preparedString = add(add(add(add(method, "/"), version), "/"), path);
                if (isTrue(isEqual(method, "POST")))
                {
                    body = this.json(query);
                    preparedString = add(preparedString, body);
                } else if (isTrue(urlencoded))
                {
                    preparedString = add(preparedString, add("?", urlencoded));
                }
                preparedString = add(preparedString, add(nonce, this.secret));
                object signature = this.hash(this.encode(preparedString), sha256);
                headers = new Dictionary<string, object>() {
                    { "Content-Type", "application/json; charset=utf-8" },
                    { "Accept", "application/json" },
                    { "X-COINEX-KEY", this.apiKey },
                    { "X-COINEX-SIGN", signature },
                    { "X-COINEX-TIMESTAMP", nonce },
                };
                if (isTrue(!isEqual(method, "POST")))
                {
                    if (isTrue(urlencoded))
                    {
                        url = add(url, add("?", urlencoded));
                    }
                }
            }
        }
        return new Dictionary<string, object>() {
            { "url", url },
            { "method", method },
            { "body", body },
            { "headers", headers },
        };
    }

    public override object handleErrors(object httpCode, object reason, object url, object method, object headers, object body, object response, object requestHeaders, object requestBody)
    {
        if (isTrue(isEqual(response, null)))
        {
            return null;
        }
        object code = this.safeString(response, "code");
        object data = this.safeValue(response, "data");
        object message = this.safeString(response, "message");
        if (isTrue(isTrue((!isEqual(code, "0"))) || isTrue((isTrue(isTrue(isTrue((!isEqual(message, "Success"))) && isTrue((!isEqual(message, "Succeeded")))) && isTrue((!isEqual(message, "Ok")))) && !isTrue(data)))))
        {
            object feedback = add(add(this.id, " "), message);
            this.throwBroadlyMatchedException(getValue(this.exceptions, "broad"), message, feedback);
            this.throwExactlyMatchedException(getValue(this.exceptions, "exact"), code, feedback);
            throw new ExchangeError ((string)feedback) ;
        }
        return null;
    }

    public async override Task<object> fetchMarginAdjustmentHistory(object symbol = null, object type = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name coinex#fetchMarginAdjustmentHistory
        * @description fetches the history of margin added or reduced from contract isolated positions
        * @see https://viabtc.github.io/coinex_api_en_doc/futures/#docsfutures001_http046_position_margin_history
        * @param {string} [symbol] unified market symbol
        * @param {string} [type] not used by coinex fetchMarginAdjustmentHistory
        * @param {int} [since] timestamp in ms of the earliest change to fetch
        * @param {int} [limit] the maximum amount of changes to fetch, default=100, max=100
        * @param {object} params extra parameters specific to the exchange api endpoint
        * @param {int} [params.until] timestamp in ms of the latest change to fetch
        *
        * EXCHANGE SPECIFIC PARAMETERS
        * @param {int} [params.offset] offset
        * @returns {object[]} a list of [margin structures]{@link https://docs.ccxt.com/#/?id=margin-loan-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object until = this.safeInteger(parameters, "until");
        parameters = this.omit(parameters, "until");
        if (isTrue(isEqual(limit, null)))
        {
            limit = 100;
        }
        object request = new Dictionary<string, object>() {
            { "market", "" },
            { "position_id", 0 },
            { "offset", 0 },
            { "limit", limit },
        };
        if (isTrue(!isEqual(symbol, null)))
        {
            object market = this.market(symbol);
            ((IDictionary<string,object>)request)["market"] = getValue(market, "id");
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["start_time"] = since;
        }
        if (isTrue(!isEqual(until, null)))
        {
            ((IDictionary<string,object>)request)["end_time"] = until;
        }
        object response = await this.v1PerpetualPrivateGetPositionMarginHistory(this.extend(request, parameters));
        //
        //    {
        //        code: '0',
        //        data: {
        //            limit: '100',
        //            offset: '0',
        //            records: [
        //                {
        //                    bkr_price: '0',
        //                    leverage: '3',
        //                    liq_price: '0',
        //                    margin_amount: '5.33236666666666666666',
        //                    margin_change: '3',
        //                    market: 'XRPUSDT',
        //                    position_amount: '11',
        //                    position_id: '297155652',
        //                    position_type: '2',
        //                    settle_price: '0.6361',
        //                    time: '1711050906.382891',
        //                    type: '1',
        //                    user_id: '3685860'
        //                }
        //            ]
        //        },
        //        message: 'OK'
        //    }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        object records = this.safeList(data, "records", new List<object>() {});
        object modifications = this.parseMarginModifications(records, null, "market", "swap");
        return this.filterBySymbolSinceLimit(modifications, symbol, since, limit);
    }
}
