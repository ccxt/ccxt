namespace ccxt;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

public partial class coinex : Exchange
{
    public override object describe()
    {
        return this.deepExtend(base.describe(), new Dictionary<string, object>() {
            { "id", "coinex" },
            { "name", "CoinEx" },
            { "version", "v2" },
            { "countries", new List<object>() {"CN"} },
            { "rateLimit", 2.5 },
            { "pro", true },
            { "certified", true },
            { "has", new Dictionary<string, object>() {
                { "CORS", null },
                { "spot", true },
                { "margin", true },
                { "swap", true },
                { "future", false },
                { "option", false },
                { "addMargin", true },
                { "borrowCrossMargin", false },
                { "borrowIsolatedMargin", true },
                { "cancelAllOrders", true },
                { "cancelOrder", true },
                { "cancelOrders", true },
                { "createDepositAddress", true },
                { "createMarketBuyOrderWithCost", true },
                { "createMarketOrderWithCost", false },
                { "createMarketSellOrderWithCost", false },
                { "createOrder", true },
                { "createOrders", true },
                { "createReduceOnlyOrder", true },
                { "createStopLossOrder", true },
                { "createTakeProfitOrder", true },
                { "createTriggerOrder", true },
                { "editOrder", true },
                { "fetchBalance", true },
                { "fetchBorrowInterest", true },
                { "fetchBorrowRateHistories", false },
                { "fetchBorrowRateHistory", false },
                { "fetchClosedOrders", true },
                { "fetchCrossBorrowRate", false },
                { "fetchCrossBorrowRates", false },
                { "fetchCurrencies", true },
                { "fetchDepositAddress", true },
                { "fetchDepositAddressByNetwork", false },
                { "fetchDepositAddresses", false },
                { "fetchDeposits", true },
                { "fetchDepositWithdrawFee", true },
                { "fetchDepositWithdrawFees", false },
                { "fetchFundingHistory", true },
                { "fetchFundingRate", true },
                { "fetchFundingRateHistory", true },
                { "fetchFundingRates", true },
                { "fetchIndexOHLCV", false },
                { "fetchIsolatedBorrowRate", true },
                { "fetchIsolatedBorrowRates", false },
                { "fetchLeverage", true },
                { "fetchLeverages", false },
                { "fetchLeverageTiers", true },
                { "fetchMarginAdjustmentHistory", true },
                { "fetchMarketLeverageTiers", "emulated" },
                { "fetchMarkets", true },
                { "fetchMarkOHLCV", false },
                { "fetchMyTrades", true },
                { "fetchOHLCV", true },
                { "fetchOpenOrders", true },
                { "fetchOrder", true },
                { "fetchOrderBook", true },
                { "fetchPosition", true },
                { "fetchPositionHistory", true },
                { "fetchPositions", true },
                { "fetchPositionsHistory", false },
                { "fetchPositionsRisk", false },
                { "fetchPremiumIndexOHLCV", false },
                { "fetchTicker", true },
                { "fetchTickers", true },
                { "fetchTime", true },
                { "fetchTrades", true },
                { "fetchTradingFee", true },
                { "fetchTradingFees", true },
                { "fetchTransfer", false },
                { "fetchTransfers", true },
                { "fetchWithdrawal", false },
                { "fetchWithdrawals", true },
                { "reduceMargin", true },
                { "repayCrossMargin", false },
                { "repayIsolatedMargin", true },
                { "setLeverage", true },
                { "setMarginMode", true },
                { "setPositionMode", false },
                { "transfer", true },
                { "withdraw", true },
            } },
            { "timeframes", new Dictionary<string, object>() {
                { "1m", "1min" },
                { "3m", "3min" },
                { "5m", "5min" },
                { "15m", "15min" },
                { "30m", "30min" },
                { "1h", "1hour" },
                { "2h", "2hour" },
                { "4h", "4hour" },
                { "6h", "6hour" },
                { "12h", "12hour" },
                { "1d", "1day" },
                { "3d", "3day" },
                { "1w", "1week" },
            } },
            { "urls", new Dictionary<string, object>() {
                { "logo", "https://user-images.githubusercontent.com/51840849/87182089-1e05fa00-c2ec-11ea-8da9-cc73b45abbbc.jpg" },
                { "api", new Dictionary<string, object>() {
                    { "public", "https://api.coinex.com" },
                    { "private", "https://api.coinex.com" },
                    { "perpetualPublic", "https://api.coinex.com/perpetual" },
                    { "perpetualPrivate", "https://api.coinex.com/perpetual" },
                } },
                { "www", "https://www.coinex.com" },
                { "doc", "https://docs.coinex.com/api/v2" },
                { "fees", "https://www.coinex.com/fees" },
                { "referral", "https://www.coinex.com/register?refer_code=yw5fz" },
            } },
            { "api", new Dictionary<string, object>() {
                { "v1", new Dictionary<string, object>() {
                    { "public", new Dictionary<string, object>() {
                        { "get", new Dictionary<string, object>() {
                            { "amm/market", 1 },
                            { "common/currency/rate", 1 },
                            { "common/asset/config", 1 },
                            { "common/maintain/info", 1 },
                            { "common/temp-maintain/info", 1 },
                            { "margin/market", 1 },
                            { "market/info", 1 },
                            { "market/list", 1 },
                            { "market/ticker", 1 },
                            { "market/ticker/all", 1 },
                            { "market/depth", 1 },
                            { "market/deals", 1 },
                            { "market/kline", 1 },
                            { "market/detail", 1 },
                        } },
                    } },
                    { "private", new Dictionary<string, object>() {
                        { "get", new Dictionary<string, object>() {
                            { "account/amm/balance", 40 },
                            { "account/investment/balance", 40 },
                            { "account/balance/history", 40 },
                            { "account/market/fee", 40 },
                            { "balance/coin/deposit", 40 },
                            { "balance/coin/withdraw", 40 },
                            { "balance/info", 40 },
                            { "balance/deposit/address/{coin_type}", 40 },
                            { "contract/transfer/history", 40 },
                            { "credit/info", 40 },
                            { "credit/balance", 40 },
                            { "investment/transfer/history", 40 },
                            { "margin/account", 1 },
                            { "margin/config", 1 },
                            { "margin/loan/history", 40 },
                            { "margin/transfer/history", 40 },
                            { "order/deals", 40 },
                            { "order/finished", 40 },
                            { "order/pending", 8 },
                            { "order/status", 8 },
                            { "order/status/batch", 8 },
                            { "order/user/deals", 40 },
                            { "order/stop/finished", 40 },
                            { "order/stop/pending", 8 },
                            { "order/user/trade/fee", 1 },
                            { "order/market/trade/info", 1 },
                            { "sub_account/balance", 1 },
                            { "sub_account/transfer/history", 40 },
                            { "sub_account/auth/api", 40 },
                            { "sub_account/auth/api/{user_auth_id}", 40 },
                        } },
                        { "post", new Dictionary<string, object>() {
                            { "balance/coin/withdraw", 40 },
                            { "contract/balance/transfer", 40 },
                            { "margin/flat", 40 },
                            { "margin/loan", 40 },
                            { "margin/transfer", 40 },
                            { "order/limit/batch", 40 },
                            { "order/ioc", 13.334 },
                            { "order/limit", 13.334 },
                            { "order/market", 13.334 },
                            { "order/modify", 13.334 },
                            { "order/stop/limit", 13.334 },
                            { "order/stop/market", 13.334 },
                            { "order/stop/modify", 13.334 },
                            { "sub_account/transfer", 40 },
                            { "sub_account/register", 1 },
                            { "sub_account/unfrozen", 40 },
                            { "sub_account/frozen", 40 },
                            { "sub_account/auth/api", 40 },
                        } },
                        { "put", new Dictionary<string, object>() {
                            { "balance/deposit/address/{coin_type}", 40 },
                            { "sub_account/unfrozen", 40 },
                            { "sub_account/frozen", 40 },
                            { "sub_account/auth/api/{user_auth_id}", 40 },
                            { "v1/account/settings", 40 },
                        } },
                        { "delete", new Dictionary<string, object>() {
                            { "balance/coin/withdraw", 40 },
                            { "order/pending/batch", 40 },
                            { "order/pending", 13.334 },
                            { "order/stop/pending", 40 },
                            { "order/stop/pending/{id}", 13.334 },
                            { "order/pending/by_client_id", 40 },
                            { "order/stop/pending/by_client_id", 40 },
                            { "sub_account/auth/api/{user_auth_id}", 40 },
                            { "sub_account/authorize/{id}", 40 },
                        } },
                    } },
                    { "perpetualPublic", new Dictionary<string, object>() {
                        { "get", new Dictionary<string, object>() {
                            { "ping", 1 },
                            { "time", 1 },
                            { "market/list", 1 },
                            { "market/limit_config", 1 },
                            { "market/ticker", 1 },
                            { "market/ticker/all", 1 },
                            { "market/depth", 1 },
                            { "market/deals", 1 },
                            { "market/funding_history", 1 },
                            { "market/kline", 1 },
                        } },
                    } },
                    { "perpetualPrivate", new Dictionary<string, object>() {
                        { "get", new Dictionary<string, object>() {
                            { "market/user_deals", 1 },
                            { "asset/query", 40 },
                            { "order/pending", 8 },
                            { "order/finished", 40 },
                            { "order/stop_finished", 40 },
                            { "order/stop_pending", 8 },
                            { "order/status", 8 },
                            { "order/stop_status", 8 },
                            { "position/finished", 40 },
                            { "position/pending", 40 },
                            { "position/funding", 40 },
                            { "position/adl_history", 40 },
                            { "market/preference", 40 },
                            { "position/margin_history", 40 },
                            { "position/settle_history", 40 },
                        } },
                        { "post", new Dictionary<string, object>() {
                            { "market/adjust_leverage", 1 },
                            { "market/position_expect", 1 },
                            { "order/put_limit", 20 },
                            { "order/put_market", 20 },
                            { "order/put_stop_limit", 20 },
                            { "order/put_stop_market", 20 },
                            { "order/modify", 20 },
                            { "order/modify_stop", 20 },
                            { "order/cancel", 20 },
                            { "order/cancel_all", 40 },
                            { "order/cancel_batch", 40 },
                            { "order/cancel_stop", 20 },
                            { "order/cancel_stop_all", 40 },
                            { "order/close_limit", 20 },
                            { "order/close_market", 20 },
                            { "position/adjust_margin", 20 },
                            { "position/stop_loss", 20 },
                            { "position/take_profit", 20 },
                            { "position/market_close", 20 },
                            { "order/cancel/by_client_id", 20 },
                            { "order/cancel_stop/by_client_id", 20 },
                            { "market/preference", 20 },
                        } },
                    } },
                } },
                { "v2", new Dictionary<string, object>() {
                    { "public", new Dictionary<string, object>() {
                        { "get", new Dictionary<string, object>() {
                            { "maintain/info", 1 },
                            { "ping", 1 },
                            { "time", 1 },
                            { "spot/market", 1 },
                            { "spot/ticker", 1 },
                            { "spot/depth", 1 },
                            { "spot/deals", 1 },
                            { "spot/kline", 1 },
                            { "spot/index", 1 },
                            { "futures/market", 1 },
                            { "futures/ticker", 1 },
                            { "futures/depth", 1 },
                            { "futures/deals", 1 },
                            { "futures/kline", 1 },
                            { "futures/index", 1 },
                            { "futures/funding-rate", 1 },
                            { "futures/funding-rate-history", 1 },
                            { "futures/position-level", 1 },
                            { "futures/liquidation-history", 1 },
                            { "futures/basis-history", 1 },
                            { "assets/deposit-withdraw-config", 1 },
                            { "assets/all-deposit-withdraw-config", 1 },
                        } },
                    } },
                    { "private", new Dictionary<string, object>() {
                        { "get", new Dictionary<string, object>() {
                            { "account/subs", 1 },
                            { "account/subs/api-detail", 40 },
                            { "account/subs/info", 1 },
                            { "account/subs/api", 40 },
                            { "account/subs/transfer-history", 40 },
                            { "account/subs/spot-balance", 1 },
                            { "account/trade-fee-rate", 40 },
                            { "assets/spot/balance", 40 },
                            { "assets/futures/balance", 40 },
                            { "assets/margin/balance", 1 },
                            { "assets/financial/balance", 40 },
                            { "assets/amm/liquidity", 40 },
                            { "assets/credit/info", 40 },
                            { "assets/margin/borrow-history", 40 },
                            { "assets/margin/interest-limit", 1 },
                            { "assets/deposit-address", 40 },
                            { "assets/deposit-history", 40 },
                            { "assets/withdraw", 40 },
                            { "assets/transfer-history", 40 },
                            { "spot/order-status", 8 },
                            { "spot/batch-order-status", 8 },
                            { "spot/pending-order", 8 },
                            { "spot/finished-order", 40 },
                            { "spot/pending-stop-order", 8 },
                            { "spot/finished-stop-order", 40 },
                            { "spot/user-deals", 40 },
                            { "spot/order-deals", 40 },
                            { "futures/order-status", 8 },
                            { "futures/batch-order-status", 1 },
                            { "futures/pending-order", 8 },
                            { "futures/finished-order", 40 },
                            { "futures/pending-stop-order", 8 },
                            { "futures/finished-stop-order", 40 },
                            { "futures/user-deals", 1 },
                            { "futures/order-deals", 1 },
                            { "futures/pending-position", 40 },
                            { "futures/finished-position", 1 },
                            { "futures/position-margin-history", 1 },
                            { "futures/position-funding-history", 40 },
                            { "futures/position-adl-history", 1 },
                            { "futures/position-settle-history", 1 },
                        } },
                        { "post", new Dictionary<string, object>() {
                            { "account/subs", 40 },
                            { "account/subs/frozen", 40 },
                            { "account/subs/unfrozen", 40 },
                            { "account/subs/api", 40 },
                            { "account/subs/edit-api", 40 },
                            { "account/subs/delete-api", 40 },
                            { "account/subs/transfer", 40 },
                            { "account/settings", 40 },
                            { "assets/margin/borrow", 40 },
                            { "assets/margin/repay", 40 },
                            { "assets/renewal-deposit-address", 40 },
                            { "assets/withdraw", 40 },
                            { "assets/cancel-withdraw", 40 },
                            { "assets/transfer", 40 },
                            { "assets/amm/add-liquidity", 1 },
                            { "assets/amm/remove-liquidity", 1 },
                            { "spot/order", 13.334 },
                            { "spot/stop-order", 13.334 },
                            { "spot/batch-order", 40 },
                            { "spot/batch-stop-order", 1 },
                            { "spot/modify-order", 13.334 },
                            { "spot/modify-stop-order", 13.334 },
                            { "spot/cancel-all-order", 1 },
                            { "spot/cancel-order", 6.667 },
                            { "spot/cancel-stop-order", 6.667 },
                            { "spot/cancel-batch-order", 10 },
                            { "spot/cancel-batch-stop-order", 10 },
                            { "spot/cancel-order-by-client-id", 1 },
                            { "spot/cancel-stop-order-by-client-id", 1 },
                            { "futures/order", 20 },
                            { "futures/stop-order", 20 },
                            { "futures/batch-order", 1 },
                            { "futures/batch-stop-order", 1 },
                            { "futures/modify-order", 20 },
                            { "futures/modify-stop-order", 20 },
                            { "futures/cancel-all-order", 1 },
                            { "futures/cancel-order", 10 },
                            { "futures/cancel-stop-order", 10 },
                            { "futures/cancel-batch-order", 20 },
                            { "futures/cancel-batch-stop-order", 20 },
                            { "futures/cancel-order-by-client-id", 1 },
                            { "futures/cancel-stop-order-by-client-id", 1 },
                            { "futures/close-position", 20 },
                            { "futures/adjust-position-margin", 20 },
                            { "futures/adjust-position-leverage", 20 },
                            { "futures/set-position-stop-loss", 20 },
                            { "futures/set-position-take-profit", 20 },
                        } },
                    } },
                } },
            } },
            { "fees", new Dictionary<string, object>() {
                { "trading", new Dictionary<string, object>() {
                    { "maker", 0.001 },
                    { "taker", 0.001 },
                } },
                { "funding", new Dictionary<string, object>() {
                    { "withdraw", new Dictionary<string, object>() {
                        { "BCH", 0 },
                        { "BTC", 0.001 },
                        { "LTC", 0.001 },
                        { "ETH", 0.001 },
                        { "ZEC", 0.0001 },
                        { "DASH", 0.0001 },
                    } },
                } },
            } },
            { "limits", new Dictionary<string, object>() {
                { "amount", new Dictionary<string, object>() {
                    { "min", 0.001 },
                    { "max", null },
                } },
            } },
            { "options", new Dictionary<string, object>() {
                { "brokerId", "x-167673045" },
                { "createMarketBuyOrderRequiresPrice", true },
                { "defaultType", "spot" },
                { "defaultSubType", "linear" },
                { "fetchDepositAddress", new Dictionary<string, object>() {
                    { "fillResponseFromRequest", true },
                } },
                { "accountsByType", new Dictionary<string, object>() {
                    { "spot", "SPOT" },
                    { "margin", "MARGIN" },
                    { "swap", "FUTURES" },
                } },
                { "accountsById", new Dictionary<string, object>() {
                    { "SPOT", "spot" },
                    { "MARGIN", "margin" },
                    { "FUTURES", "swap" },
                } },
                { "networks", new Dictionary<string, object>() {
                    { "BEP20", "BSC" },
                    { "TRX", "TRC20" },
                    { "ETH", "ERC20" },
                } },
            } },
            { "commonCurrencies", new Dictionary<string, object>() {
                { "ACM", "Actinium" },
            } },
            { "precisionMode", TICK_SIZE },
            { "exceptions", new Dictionary<string, object>() {
                { "exact", new Dictionary<string, object>() {
                    { "23", typeof(PermissionDenied) },
                    { "24", typeof(AuthenticationError) },
                    { "25", typeof(AuthenticationError) },
                    { "34", typeof(AuthenticationError) },
                    { "35", typeof(ExchangeNotAvailable) },
                    { "36", typeof(RequestTimeout) },
                    { "213", typeof(RateLimitExceeded) },
                    { "107", typeof(InsufficientFunds) },
                    { "158", typeof(PermissionDenied) },
                    { "600", typeof(OrderNotFound) },
                    { "601", typeof(InvalidOrder) },
                    { "602", typeof(InvalidOrder) },
                    { "606", typeof(InvalidOrder) },
                    { "3008", typeof(RequestTimeout) },
                    { "3109", typeof(InsufficientFunds) },
                    { "3127", typeof(InvalidOrder) },
                    { "3606", typeof(InvalidOrder) },
                    { "3610", typeof(ExchangeError) },
                    { "3612", typeof(InvalidOrder) },
                    { "3613", typeof(InvalidOrder) },
                    { "3614", typeof(InvalidOrder) },
                    { "3615", typeof(InvalidOrder) },
                    { "3616", typeof(InvalidOrder) },
                    { "3617", typeof(InvalidOrder) },
                    { "3618", typeof(InvalidOrder) },
                    { "3619", typeof(InvalidOrder) },
                    { "3620", typeof(InvalidOrder) },
                    { "3621", typeof(InvalidOrder) },
                    { "3622", typeof(InvalidOrder) },
                    { "3627", typeof(InvalidOrder) },
                    { "3628", typeof(InvalidOrder) },
                    { "3629", typeof(InvalidOrder) },
                    { "3632", typeof(InvalidOrder) },
                    { "3633", typeof(InvalidOrder) },
                    { "3634", typeof(InvalidOrder) },
                    { "3635", typeof(InvalidOrder) },
                    { "4001", typeof(ExchangeNotAvailable) },
                    { "4002", typeof(RequestTimeout) },
                    { "4003", typeof(ExchangeError) },
                    { "4004", typeof(BadRequest) },
                    { "4005", typeof(AuthenticationError) },
                    { "4006", typeof(AuthenticationError) },
                    { "4007", typeof(PermissionDenied) },
                    { "4008", typeof(AuthenticationError) },
                    { "4009", typeof(ExchangeError) },
                    { "4010", typeof(ExchangeError) },
                    { "4011", typeof(PermissionDenied) },
                    { "4017", typeof(ExchangeError) },
                    { "4115", typeof(AccountSuspended) },
                    { "4117", typeof(BadSymbol) },
                    { "4123", typeof(RateLimitExceeded) },
                    { "4130", typeof(ExchangeError) },
                    { "4158", typeof(ExchangeError) },
                    { "4213", typeof(RateLimitExceeded) },
                    { "4512", typeof(PermissionDenied) },
                } },
                { "broad", new Dictionary<string, object>() {
                    { "ip not allow visit", typeof(PermissionDenied) },
                    { "service too busy", typeof(ExchangeNotAvailable) },
                } },
            } },
        });
    }

    public async override Task<object> fetchCurrencies(object parameters = null)
    {
        /**
        * @method
        * @name coinex#fetchCurrencies
        * @description fetches all available currencies on an exchange
        * @see https://docs.coinex.com/api/v2/assets/deposit-withdrawal/http/list-all-deposit-withdrawal-config
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} an associative dictionary of currencies
        */
        parameters ??= new Dictionary<string, object>();
        object response = await this.v2PublicGetAssetsAllDepositWithdrawConfig(parameters);
        //
        //     {
        //         "code": 0,
        //         "data": [
        //             {
        //                 "asset": {
        //                     "ccy": "CET",
        //                     "deposit_enabled": true,
        //                     "withdraw_enabled": true,
        //                     "inter_transfer_enabled": true,
        //                     "is_st": false
        //                 },
        //                 "chains": [
        //                     {
        //                         "chain": "CSC",
        //                         "min_deposit_amount": "0.8",
        //                         "min_withdraw_amount": "8",
        //                         "deposit_enabled": true,
        //                         "withdraw_enabled": true,
        //                         "deposit_delay_minutes": 0,
        //                         "safe_confirmations": 10,
        //                         "irreversible_confirmations": 20,
        //                         "deflation_rate": "0",
        //                         "withdrawal_fee": "0.026",
        //                         "withdrawal_precision": 8,
        //                         "memo": "",
        //                         "is_memo_required_for_deposit": false,
        //                         "explorer_asset_url": ""
        //                     },
        //                 ]
        //             }
        //         ],
        //         "message": "OK"
        //     }
        //
        object data = this.safeList(response, "data", new List<object>() {});
        object result = new Dictionary<string, object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
        {
            object coin = getValue(data, i);
            object asset = this.safeDict(coin, "asset", new Dictionary<string, object>() {});
            object chains = this.safeList(coin, "chains", new List<object>() {});
            object currencyId = this.safeString(asset, "ccy");
            if (isTrue(isEqual(currencyId, null)))
            {
                continue;
            }
            object code = this.safeCurrencyCode(currencyId);
            object canDeposit = this.safeBool(asset, "deposit_enabled");
            object canWithdraw = this.safeBool(asset, "withdraw_enabled");
            object firstChain = this.safeDict(chains, 0, new Dictionary<string, object>() {});
            object firstPrecisionString = this.parsePrecision(this.safeString(firstChain, "withdrawal_precision"));
            ((IDictionary<string,object>)result)[(string)code] = new Dictionary<string, object>() {
                { "id", currencyId },
                { "code", code },
                { "name", null },
                { "active", isTrue(canDeposit) && isTrue(canWithdraw) },
                { "deposit", canDeposit },
                { "withdraw", canWithdraw },
                { "fee", null },
                { "precision", this.parseNumber(firstPrecisionString) },
                { "limits", new Dictionary<string, object>() {
                    { "amount", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                    { "deposit", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                    { "withdraw", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                } },
                { "networks", new Dictionary<string, object>() {} },
                { "info", coin },
            };
            for (object j = 0; isLessThan(j, getArrayLength(chains)); postFixIncrement(ref j))
            {
                object chain = getValue(chains, j);
                object networkId = this.safeString(chain, "chain");
                object precisionString = this.parsePrecision(this.safeString(chain, "withdrawal_precision"));
                object feeString = this.safeString(chain, "withdrawal_fee");
                object minNetworkDepositString = this.safeString(chain, "min_deposit_amount");
                object minNetworkWithdrawString = this.safeString(chain, "min_withdraw_amount");
                object canDepositChain = this.safeBool(chain, "deposit_enabled");
                object canWithdrawChain = this.safeBool(chain, "withdraw_enabled");
                object network = new Dictionary<string, object>() {
                    { "id", networkId },
                    { "network", networkId },
                    { "name", null },
                    { "active", isTrue(canDepositChain) && isTrue(canWithdrawChain) },
                    { "deposit", canDepositChain },
                    { "withdraw", canWithdrawChain },
                    { "fee", this.parseNumber(feeString) },
                    { "precision", this.parseNumber(precisionString) },
                    { "limits", new Dictionary<string, object>() {
                        { "amount", new Dictionary<string, object>() {
                            { "min", null },
                            { "max", null },
                        } },
                        { "deposit", new Dictionary<string, object>() {
                            { "min", this.parseNumber(minNetworkDepositString) },
                            { "max", null },
                        } },
                        { "withdraw", new Dictionary<string, object>() {
                            { "min", this.parseNumber(minNetworkWithdrawString) },
                            { "max", null },
                        } },
                    } },
                    { "info", chain },
                };
                object networks = this.safeDict(getValue(result, code), "networks", new Dictionary<string, object>() {});
                ((IDictionary<string,object>)networks)[(string)networkId] = network;
                ((IDictionary<string,object>)getValue(result, code))["networks"] = networks;
            }
        }
        return result;
    }

    public async override Task<object> fetchMarkets(object parameters = null)
    {
        /**
        * @method
        * @name coinex#fetchMarkets
        * @description retrieves data on all markets for coinex
        * @see https://docs.coinex.com/api/v2/spot/market/http/list-market
        * @see https://docs.coinex.com/api/v2/futures/market/http/list-market
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} an array of objects representing market data
        */
        parameters ??= new Dictionary<string, object>();
        object promisesUnresolved = new List<object> {this.fetchSpotMarkets(parameters), this.fetchContractMarkets(parameters)};
        object promises = await promiseAll(promisesUnresolved);
        object spotMarkets = getValue(promises, 0);
        object swapMarkets = getValue(promises, 1);
        return this.arrayConcat(spotMarkets, swapMarkets);
    }

    public async virtual Task<object> fetchSpotMarkets(object parameters)
    {
        object response = await this.v2PublicGetSpotMarket(parameters);
        //
        //     {
        //         "code": 0,
        //         "data": [
        //             {
        //                 "base_ccy": "SORA",
        //                 "base_ccy_precision": 8,
        //                 "is_amm_available": true,
        //                 "is_margin_available": false,
        //                 "maker_fee_rate": "0.003",
        //                 "market": "SORAUSDT",
        //                 "min_amount": "500",
        //                 "quote_ccy": "USDT",
        //                 "quote_ccy_precision": 6,
        //                 "taker_fee_rate": "0.003"
        //             },
        //         ],
        //         "message": "OK"
        //     }
        //
        object markets = this.safeList(response, "data", new List<object>() {});
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(markets)); postFixIncrement(ref i))
        {
            object market = getValue(markets, i);
            object id = this.safeString(market, "market");
            object baseId = this.safeString(market, "base_ccy");
            object quoteId = this.safeString(market, "quote_ccy");
            object bs = this.safeCurrencyCode(baseId);
            object quote = this.safeCurrencyCode(quoteId);
            object symbol = add(add(bs, "/"), quote);
            ((IList<object>)result).Add(new Dictionary<string, object>() {
                { "id", id },
                { "symbol", symbol },
                { "base", bs },
                { "quote", quote },
                { "settle", null },
                { "baseId", baseId },
                { "quoteId", quoteId },
                { "settleId", null },
                { "type", "spot" },
                { "spot", true },
                { "margin", null },
                { "swap", false },
                { "future", false },
                { "option", false },
                { "active", null },
                { "contract", false },
                { "linear", null },
                { "inverse", null },
                { "taker", this.safeNumber(market, "taker_fee_rate") },
                { "maker", this.safeNumber(market, "maker_fee_rate") },
                { "contractSize", null },
                { "expiry", null },
                { "expiryDatetime", null },
                { "strike", null },
                { "optionType", null },
                { "precision", new Dictionary<string, object>() {
                    { "amount", this.parseNumber(this.parsePrecision(this.safeString(market, "base_ccy_precision"))) },
                    { "price", this.parseNumber(this.parsePrecision(this.safeString(market, "quote_ccy_precision"))) },
                } },
                { "limits", new Dictionary<string, object>() {
                    { "leverage", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                    { "amount", new Dictionary<string, object>() {
                        { "min", this.safeNumber(market, "min_amount") },
                        { "max", null },
                    } },
                    { "price", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                    { "cost", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                } },
                { "created", null },
                { "info", market },
            });
        }
        return result;
    }

    public async virtual Task<object> fetchContractMarkets(object parameters)
    {
        object response = await this.v2PublicGetFuturesMarket(parameters);
        //
        //     {
        //         "code": 0,
        //         "data": [
        //             {
        //                 "base_ccy": "BTC",
        //                 "base_ccy_precision": 8,
        //                 "contract_type": "inverse",
        //                 "leverage": ["1","2","3","5","8","10","15","20","30","50","100"],
        //                 "maker_fee_rate": "0",
        //                 "market": "BTCUSD",
        //                 "min_amount": "10",
        //                 "open_interest_volume": "2566879",
        //                 "quote_ccy": "USD",
        //                 "quote_ccy_precision": 2,
        //                 "taker_fee_rate": "0"
        //             },
        //         ],
        //         "message": "OK"
        //     }
        //
        object markets = this.safeList(response, "data", new List<object>() {});
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(markets)); postFixIncrement(ref i))
        {
            object entry = getValue(markets, i);
            object fees = this.fees;
            object leverages = this.safeList(entry, "leverage", new List<object>() {});
            object subType = this.safeString(entry, "contract_type");
            object linear = (isEqual(subType, "linear"));
            object inverse = (isEqual(subType, "inverse"));
            object id = this.safeString(entry, "market");
            object baseId = this.safeString(entry, "base_ccy");
            object quoteId = this.safeString(entry, "quote_ccy");
            object bs = this.safeCurrencyCode(baseId);
            object quote = this.safeCurrencyCode(quoteId);
            object settleId = ((bool) isTrue((isEqual(subType, "linear")))) ? "USDT" : baseId;
            object settle = this.safeCurrencyCode(settleId);
            object symbol = add(add(add(add(bs, "/"), quote), ":"), settle);
            object leveragesLength = getArrayLength(leverages);
            ((IList<object>)result).Add(new Dictionary<string, object>() {
                { "id", id },
                { "symbol", symbol },
                { "base", bs },
                { "quote", quote },
                { "settle", settle },
                { "baseId", baseId },
                { "quoteId", quoteId },
                { "settleId", settleId },
                { "type", "swap" },
                { "spot", false },
                { "margin", false },
                { "swap", true },
                { "future", false },
                { "option", false },
                { "active", null },
                { "contract", true },
                { "linear", linear },
                { "inverse", inverse },
                { "taker", getValue(getValue(fees, "trading"), "taker") },
                { "maker", getValue(getValue(fees, "trading"), "maker") },
                { "contractSize", this.parseNumber("1") },
                { "expiry", null },
                { "expiryDatetime", null },
                { "strike", null },
                { "optionType", null },
                { "precision", new Dictionary<string, object>() {
                    { "amount", this.parseNumber(this.parsePrecision(this.safeString(entry, "base_ccy_precision"))) },
                    { "price", this.parseNumber(this.parsePrecision(this.safeString(entry, "quote_ccy_precision"))) },
                } },
                { "limits", new Dictionary<string, object>() {
                    { "leverage", new Dictionary<string, object>() {
                        { "min", this.safeNumber(leverages, 0) },
                        { "max", this.safeNumber(leverages, subtract(leveragesLength, 1)) },
                    } },
                    { "amount", new Dictionary<string, object>() {
                        { "min", this.safeNumber(entry, "min_amount") },
                        { "max", null },
                    } },
                    { "price", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                    { "cost", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                } },
                { "created", null },
                { "info", entry },
            });
        }
        return result;
    }

    public override object parseTicker(object ticker, object market = null)
    {
        //
        // Spot fetchTicker, fetchTickers
        //
        //     {
        //         "close": "62393.47",
        //         "high": "64106.41",
        //         "last": "62393.47",
        //         "low": "59650.01",
        //         "market": "BTCUSDT",
        //         "open": "61616.15",
        //         "period": 86400,
        //         "value": "28711273.4065667262",
        //         "volume": "461.76557205",
        //         "volume_buy": "11.41506354",
        //         "volume_sell": "7.3240169"
        //     }
        //
        // Swap fetchTicker, fetchTickers
        //
        //     {
        //         "close": "62480.08",
        //         "high": "64100",
        //         "index_price": "62443.05",
        //         "last": "62480.08",
        //         "low": "59600",
        //         "mark_price": "62443.05",
        //         "market": "BTCUSDT",
        //         "open": "61679.98",
        //         "period": 86400,
        //         "value": "180226025.69791713065326633165",
        //         "volume": "2900.2218",
        //         "volume_buy": "7.3847",
        //         "volume_sell": "6.1249"
        //     }
        //
        object marketType = ((bool) isTrue((inOp(ticker, "mark_price")))) ? "swap" : "spot";
        object marketId = this.safeString(ticker, "market");
        object symbol = this.safeSymbol(marketId, market, null, marketType);
        return this.safeTicker(new Dictionary<string, object>() {
            { "symbol", symbol },
            { "timestamp", null },
            { "datetime", null },
            { "high", this.safeString(ticker, "high") },
            { "low", this.safeString(ticker, "low") },
            { "bid", null },
            { "bidVolume", this.safeString(ticker, "volume_buy") },
            { "ask", null },
            { "askVolume", this.safeString(ticker, "volume_sell") },
            { "vwap", null },
            { "open", this.safeString(ticker, "open") },
            { "close", this.safeString(ticker, "close") },
            { "last", this.safeString(ticker, "last") },
            { "previousClose", null },
            { "change", null },
            { "percentage", null },
            { "average", null },
            { "baseVolume", this.safeString(ticker, "volume") },
            { "quoteVolume", null },
            { "info", ticker },
        }, market);
    }

    public async override Task<object> fetchTicker(object symbol, object parameters = null)
    {
        /**
        * @method
        * @name coinex#fetchTicker
        * @description fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
        * @see https://docs.coinex.com/api/v2/spot/market/http/list-market-ticker
        * @see https://docs.coinex.com/api/v2/futures/market/http/list-market-ticker
        * @param {string} symbol unified symbol of the market to fetch the ticker for
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "market", getValue(market, "id") },
        };
        object response = null;
        if (isTrue(getValue(market, "swap")))
        {
            response = await this.v2PublicGetFuturesTicker(this.extend(request, parameters));
        } else
        {
            response = await this.v2PublicGetSpotTicker(this.extend(request, parameters));
        }
        //
        // Spot
        //
        //     {
        //         "code": 0,
        //         "data": [
        //             {
        //                 "close": "62393.47",
        //                 "high": "64106.41",
        //                 "last": "62393.47",
        //                 "low": "59650.01",
        //                 "market": "BTCUSDT",
        //                 "open": "61616.15",
        //                 "period": 86400,
        //                 "value": "28711273.4065667262",
        //                 "volume": "461.76557205",
        //                 "volume_buy": "11.41506354",
        //                 "volume_sell": "7.3240169"
        //             }
        //         ],
        //         "message": "OK"
        //     }
        //
        // Swap
        //
        //     {
        //         "code": 0,
        //         "data": [
        //             {
        //                 "close": "62480.08",
        //                 "high": "64100",
        //                 "index_price": "62443.05",
        //                 "last": "62480.08",
        //                 "low": "59600",
        //                 "mark_price": "62443.05",
        //                 "market": "BTCUSDT",
        //                 "open": "61679.98",
        //                 "period": 86400,
        //                 "value": "180226025.69791713065326633165",
        //                 "volume": "2900.2218",
        //                 "volume_buy": "7.3847",
        //                 "volume_sell": "6.1249"
        //             }
        //         ],
        //         "message": "OK"
        //     }
        //
        object data = this.safeList(response, "data", new List<object>() {});
        object result = this.safeDict(data, 0, new Dictionary<string, object>() {});
        return this.parseTicker(result, market);
    }

    public async override Task<object> fetchTickers(object symbols = null, object parameters = null)
    {
        /**
        * @method
        * @name coinex#fetchTickers
        * @description fetches price tickers for multiple markets, statistical information calculated over the past 24 hours for each market
        * @see https://docs.coinex.com/api/v2/spot/market/http/list-market-ticker
        * @see https://docs.coinex.com/api/v2/futures/market/http/list-market-ticker
        * @param {string[]|undefined} symbols unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/#/?id=ticker-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        symbols = this.marketSymbols(symbols);
        object market = null;
        if (isTrue(!isEqual(symbols, null)))
        {
            object symbol = this.safeValue(symbols, 0);
            market = this.market(symbol);
        }
        var marketTypequeryVariable = this.handleMarketTypeAndParams("fetchTickers", market, parameters);
        var marketType = ((IList<object>) marketTypequeryVariable)[0];
        var query = ((IList<object>) marketTypequeryVariable)[1];
        object response = null;
        if (isTrue(isEqual(marketType, "swap")))
        {
            response = await this.v2PublicGetFuturesTicker(query);
        } else
        {
            response = await this.v2PublicGetSpotTicker(query);
        }
        //
        // Spot
        //
        //     {
        //         "code": 0,
        //         "data": [
        //             {
        //                 "close": "62393.47",
        //                 "high": "64106.41",
        //                 "last": "62393.47",
        //                 "low": "59650.01",
        //                 "market": "BTCUSDT",
        //                 "open": "61616.15",
        //                 "period": 86400,
        //                 "value": "28711273.4065667262",
        //                 "volume": "461.76557205",
        //                 "volume_buy": "11.41506354",
        //                 "volume_sell": "7.3240169"
        //             }
        //         ],
        //         "message": "OK"
        //     }
        //
        // Swap
        //
        //     {
        //         "code": 0,
        //         "data": [
        //             {
        //                 "close": "62480.08",
        //                 "high": "64100",
        //                 "index_price": "62443.05",
        //                 "last": "62480.08",
        //                 "low": "59600",
        //                 "mark_price": "62443.05",
        //                 "market": "BTCUSDT",
        //                 "open": "61679.98",
        //                 "period": 86400,
        //                 "value": "180226025.69791713065326633165",
        //                 "volume": "2900.2218",
        //                 "volume_buy": "7.3847",
        //                 "volume_sell": "6.1249"
        //             }
        //         ],
        //         "message": "OK"
        //     }
        //
        object data = this.safeList(response, "data", new List<object>() {});
        return this.parseTickers(data, symbols);
    }

    public async override Task<object> fetchTime(object parameters = null)
    {
        /**
        * @method
        * @name coinex#fetchTime
        * @description fetches the current integer timestamp in milliseconds from the exchange server
        * @see https://docs.coinex.com/api/v2/common/http/time
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {int} the current integer timestamp in milliseconds from the exchange server
        */
        parameters ??= new Dictionary<string, object>();
        object response = await this.v2PublicGetTime(parameters);
        //
        //     {
        //         "code": 0,
        //         "data": {
        //             "timestamp": 1711699867777
        //         },
        //         "message": "OK"
        //     }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        return this.safeInteger(data, "timestamp");
    }

    public async override Task<object> fetchOrderBook(object symbol, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name coinex#fetchOrderBook
        * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
        * @see https://docs.coinex.com/api/v2/spot/market/http/list-market-depth
        * @see https://docs.coinex.com/api/v2/futures/market/http/list-market-depth
        * @param {string} symbol unified symbol of the market to fetch the order book for
        * @param {int} [limit] the maximum amount of order book entries to return
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
        */
        limit ??= 20;
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        if (isTrue(isEqual(limit, null)))
        {
            limit = 20; // default
        }
        object request = new Dictionary<string, object>() {
            { "market", getValue(market, "id") },
            { "limit", limit },
            { "interval", "0" },
        };
        object response = null;
        if (isTrue(getValue(market, "swap")))
        {
            response = await this.v2PublicGetFuturesDepth(this.extend(request, parameters));
        } else
        {
            response = await this.v2PublicGetSpotDepth(this.extend(request, parameters));
        }
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        object depth = this.safeDict(data, "depth", new Dictionary<string, object>() {});
        object timestamp = this.safeInteger(depth, "updated_at");
        return this.parseOrderBook(depth, symbol, timestamp);
    }

    public override object parseTrade(object trade, object market = null)
    {
        //
        // Spot and Swap fetchTrades (public)
        //
        //     {
        //         "amount": "0.00049432",
        //         "created_at": 1713849825667,
        //         "deal_id": 4137517302,
        //         "price": "66251",
        //         "side": "buy"
        //     }
        //
        // Spot and Margin fetchMyTrades (private)
        //
        //     {
        //         "amount": "0.00010087",
        //         "created_at": 1714618087585,
        //         "deal_id": 4161200602,
        //         "margin_market": "",
        //         "market": "BTCUSDT",
        //         "order_id": 117654919342,
        //         "price": "57464.04",
        //         "side": "sell"
        //     }
        //
        // Swap fetchMyTrades (private)
        //
        //     {
        //         "deal_id": 1180222387,
        //         "created_at": 1714119054558,
        //         "market": "BTCUSDT",
        //         "side": "buy",
        //         "order_id": 136915589622,
        //         "price": "64376",
        //         "amount": "0.0001"
        //     }
        //
        object timestamp = this.safeInteger(trade, "created_at");
        object defaultType = this.safeString(this.options, "defaultType");
        if (isTrue(!isEqual(market, null)))
        {
            defaultType = getValue(market, "type");
        }
        object marketId = this.safeString(trade, "market");
        market = this.safeMarket(marketId, market, null, defaultType);
        return this.safeTrade(new Dictionary<string, object>() {
            { "info", trade },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "symbol", getValue(market, "symbol") },
            { "id", this.safeString(trade, "deal_id") },
            { "order", this.safeString(trade, "order_id") },
            { "type", null },
            { "side", this.safeString(trade, "side") },
            { "takerOrMaker", null },
            { "price", this.safeString(trade, "price") },
            { "amount", this.safeString(trade, "amount") },
            { "cost", this.safeString(trade, "deal_money") },
            { "fee", null },
        }, market);
    }

    public async override Task<object> fetchTrades(object symbol, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name coinex#fetchTrades
        * @description get the list of the most recent trades for a particular symbol
        * @see https://docs.coinex.com/api/v2/spot/market/http/list-market-deals
        * @see https://docs.coinex.com/api/v2/futures/market/http/list-market-deals
        * @param {string} symbol unified symbol of the market to fetch trades for
        * @param {int} [since] timestamp in ms of the earliest trade to fetch
        * @param {int} [limit] the maximum amount of trades to fetch
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "market", getValue(market, "id") },
        };
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        object response = null;
        if (isTrue(getValue(market, "swap")))
        {
            response = await this.v2PublicGetFuturesDeals(this.extend(request, parameters));
        } else
        {
            response = await this.v2PublicGetSpotDeals(this.extend(request, parameters));
        }
        //
        // Spot and Swap
        //
        //     {
        //         "code": 0,
        //         "data": [
        //             {
        //                 "amount": "0.00049432",
        //                 "created_at": 1713849825667,
        //                 "deal_id": 4137517302,
        //                 "price": "66251",
        //                 "side": "buy"
        //             },
        //         ],
        //         "message": "OK"
        //     }
        //
        return this.parseTrades(getValue(response, "data"), market, since, limit);
    }

    public async override Task<object> fetchTradingFee(object symbol, object parameters = null)
    {
        /**
        * @method
        * @name coinex#fetchTradingFee
        * @description fetch the trading fees for a market
        * @see https://docs.coinex.com/api/v2/spot/market/http/list-market
        * @see https://docs.coinex.com/api/v2/futures/market/http/list-market
        * @param {string} symbol unified market symbol
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [fee structure]{@link https://docs.ccxt.com/#/?id=fee-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "market", getValue(market, "id") },
        };
        object response = null;
        if (isTrue(getValue(market, "spot")))
        {
            response = await this.v2PublicGetSpotMarket(this.extend(request, parameters));
        } else
        {
            response = await this.v2PublicGetFuturesMarket(this.extend(request, parameters));
        }
        object data = this.safeList(response, "data", new List<object>() {});
        object result = this.safeDict(data, 0, new Dictionary<string, object>() {});
        return this.parseTradingFee(result, market);
    }

    public async override Task<object> fetchTradingFees(object parameters = null)
    {
        /**
        * @method
        * @name coinex#fetchTradingFees
        * @description fetch the trading fees for multiple markets
        * @see https://docs.coinex.com/api/v2/spot/market/http/list-market
        * @see https://docs.coinex.com/api/v2/futures/market/http/list-market
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a dictionary of [fee structures]{@link https://docs.ccxt.com/#/?id=fee-structure} indexed by market symbols
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object type = null;
        var typeparametersVariable = this.handleMarketTypeAndParams("fetchTradingFees", null, parameters);
        type = ((IList<object>)typeparametersVariable)[0];
        parameters = ((IList<object>)typeparametersVariable)[1];
        object response = null;
        if (isTrue(isEqual(type, "swap")))
        {
            response = await this.v2PublicGetFuturesMarket(parameters);
        } else
        {
            response = await this.v2PublicGetSpotMarket(parameters);
        }
        object data = this.safeList(response, "data", new List<object>() {});
        object result = new Dictionary<string, object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
        {
            object entry = getValue(data, i);
            object marketId = this.safeString(entry, "market");
            object market = this.safeMarket(marketId, null, null, type);
            object symbol = getValue(market, "symbol");
            ((IDictionary<string,object>)result)[(string)symbol] = this.parseTradingFee(entry, market);
        }
        return result;
    }

    public virtual object parseTradingFee(object fee, object market = null)
    {
        object marketId = this.safeValue(fee, "market");
        object symbol = this.safeSymbol(marketId, market);
        return new Dictionary<string, object>() {
            { "info", fee },
            { "symbol", symbol },
            { "maker", this.safeNumber(fee, "maker_fee_rate") },
            { "taker", this.safeNumber(fee, "taker_fee_rate") },
            { "percentage", true },
            { "tierBased", true },
        };
    }

    public override object parseOHLCV(object ohlcv, object market = null)
    {
        //
        //     {
        //         "close": "66999.95",
        //         "created_at": 1713934620000,
        //         "high": "66999.95",
        //         "low": "66988.53",
        //         "market": "BTCUSDT",
        //         "open": "66988.53",
        //         "value": "0.1572393",        // base volume
        //         "volume": "10533.2501364336" // quote volume
        //     }
        //
        return new List<object> {this.safeInteger(ohlcv, "created_at"), this.safeNumber(ohlcv, "open"), this.safeNumber(ohlcv, "high"), this.safeNumber(ohlcv, "low"), this.safeNumber(ohlcv, "close"), this.safeNumber(ohlcv, "value")};
    }

    public async override Task<object> fetchOHLCV(object symbol, object timeframe = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name coinex#fetchOHLCV
        * @description fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
        * @see https://docs.coinex.com/api/v2/spot/market/http/list-market-kline
        * @see https://docs.coinex.com/api/v2/futures/market/http/list-market-kline
        * @param {string} symbol unified symbol of the market to fetch OHLCV data for
        * @param {string} timeframe the length of time each candle represents
        * @param {int} [since] timestamp in ms of the earliest candle to fetch
        * @param {int} [limit] the maximum amount of candles to fetch
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
        */
        timeframe ??= "1m";
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "market", getValue(market, "id") },
            { "period", this.safeString(this.timeframes, timeframe, timeframe) },
        };
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        object response = null;
        if (isTrue(getValue(market, "swap")))
        {
            response = await this.v2PublicGetFuturesKline(this.extend(request, parameters));
        } else
        {
            response = await this.v2PublicGetSpotKline(this.extend(request, parameters));
        }
        //
        // Spot and Swap
        //
        //     {
        //         "code": 0,
        //         "data": [
        //             {
        //                 "close": "66999.95",
        //                 "created_at": 1713934620000,
        //                 "high": "66999.95",
        //                 "low": "66988.53",
        //                 "market": "BTCUSDT",
        //                 "open": "66988.53",
        //                 "value": "0.1572393",
        //                 "volume": "10533.2501364336"
        //             },
        //         ],
        //         "message": "OK"
        //     }
        //
        object data = this.safeList(response, "data", new List<object>() {});
        return this.parseOHLCVs(data, market, timeframe, since, limit);
    }

    public async virtual Task<object> fetchMarginBalance(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.v2PrivateGetAssetsMarginBalance(parameters);
        //
        //     {
        //         "data": [
        //             {
        //                 "margin_account": "BTCUSDT",
        //                 "base_ccy": "BTC",
        //                 "quote_ccy": "USDT",
        //                 "available": {
        //                     "base_ccy": "0.00000026",
        //                     "quote_ccy": "0"
        //                 },
        //                 "frozen": {
        //                     "base_ccy": "0",
        //                     "quote_ccy": "0"
        //                 },
        //                 "repaid": {
        //                     "base_ccy": "0",
        //                     "quote_ccy": "0"
        //                 },
        //                 "interest": {
        //                     "base_ccy": "0",
        //                     "quote_ccy": "0"
        //                 },
        //                 "rik_rate": "",
        //                 "liq_price": ""
        //             },
        //         ],
        //         "code": 0,
        //         "message": "OK"
        //     }
        //
        object result = new Dictionary<string, object>() {
            { "info", response },
        };
        object balances = this.safeList(response, "data", new List<object>() {});
        for (object i = 0; isLessThan(i, getArrayLength(balances)); postFixIncrement(ref i))
        {
            object entry = getValue(balances, i);
            object free = this.safeDict(entry, "available", new Dictionary<string, object>() {});
            object used = this.safeDict(entry, "frozen", new Dictionary<string, object>() {});
            object loan = this.safeDict(entry, "repaid", new Dictionary<string, object>() {});
            object interest = this.safeDict(entry, "interest", new Dictionary<string, object>() {});
            object baseAccount = this.account();
            object baseCurrencyId = this.safeString(entry, "base_ccy");
            object baseCurrencyCode = this.safeCurrencyCode(baseCurrencyId);
            ((IDictionary<string,object>)baseAccount)["free"] = this.safeString(free, "base_ccy");
            ((IDictionary<string,object>)baseAccount)["used"] = this.safeString(used, "base_ccy");
            object baseDebt = this.safeString(loan, "base_ccy");
            object baseInterest = this.safeString(interest, "base_ccy");
            ((IDictionary<string,object>)baseAccount)["debt"] = Precise.stringAdd(baseDebt, baseInterest);
            ((IDictionary<string,object>)result)[(string)baseCurrencyCode] = baseAccount;
        }
        return this.safeBalance(result);
    }

    public async virtual Task<object> fetchSpotBalance(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.v2PrivateGetAssetsSpotBalance(parameters);
        //
        //     {
        //         "code": 0,
        //         "data": [
        //             {
        //                 "available": "0.00000046",
        //                 "ccy": "USDT",
        //                 "frozen": "0"
        //             }
        //         ],
        //         "message": "OK"
        //     }
        //
        object result = new Dictionary<string, object>() {
            { "info", response },
        };
        object balances = this.safeList(response, "data", new List<object>() {});
        for (object i = 0; isLessThan(i, getArrayLength(balances)); postFixIncrement(ref i))
        {
            object entry = getValue(balances, i);
            object currencyId = this.safeString(entry, "ccy");
            object code = this.safeCurrencyCode(currencyId);
            object account = this.account();
            ((IDictionary<string,object>)account)["free"] = this.safeString(entry, "available");
            ((IDictionary<string,object>)account)["used"] = this.safeString(entry, "frozen");
            ((IDictionary<string,object>)result)[(string)code] = account;
        }
        return this.safeBalance(result);
    }

    public async virtual Task<object> fetchSwapBalance(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.v2PrivateGetAssetsFuturesBalance(parameters);
        //
        //     {
        //         "code": 0,
        //         "data": [
        //             {
        //                 "available": "0.00000046",
        //                 "ccy": "USDT",
        //                 "frozen": "0",
        //                 "margin": "0",
        //                 "transferrable": "0.00000046",
        //                 "unrealized_pnl": "0"
        //             }
        //         ],
        //         "message": "OK"
        //     }
        //
        object result = new Dictionary<string, object>() {
            { "info", response },
        };
        object balances = this.safeList(response, "data", new List<object>() {});
        for (object i = 0; isLessThan(i, getArrayLength(balances)); postFixIncrement(ref i))
        {
            object entry = getValue(balances, i);
            object currencyId = this.safeString(entry, "ccy");
            object code = this.safeCurrencyCode(currencyId);
            object account = this.account();
            ((IDictionary<string,object>)account)["free"] = this.safeString(entry, "available");
            ((IDictionary<string,object>)account)["used"] = this.safeString(entry, "frozen");
            ((IDictionary<string,object>)result)[(string)code] = account;
        }
        return this.safeBalance(result);
    }

    public async virtual Task<object> fetchFinancialBalance(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.v2PrivateGetAssetsFinancialBalance(parameters);
        //
        //     {
        //         "code": 0,
        //         "data": [
        //             {
        //                 "available": "0.00000046",
        //                 "ccy": "USDT",
        //                 "frozen": "0"
        //             }
        //         ],
        //         "message": "OK"
        //     }
        //
        object result = new Dictionary<string, object>() {
            { "info", response },
        };
        object balances = this.safeList(response, "data", new List<object>() {});
        for (object i = 0; isLessThan(i, getArrayLength(balances)); postFixIncrement(ref i))
        {
            object entry = getValue(balances, i);
            object currencyId = this.safeString(entry, "ccy");
            object code = this.safeCurrencyCode(currencyId);
            object account = this.account();
            ((IDictionary<string,object>)account)["free"] = this.safeString(entry, "available");
            ((IDictionary<string,object>)account)["used"] = this.safeString(entry, "frozen");
            ((IDictionary<string,object>)result)[(string)code] = account;
        }
        return this.safeBalance(result);
    }

    public async override Task<object> fetchBalance(object parameters = null)
    {
        /**
        * @method
        * @name coinex#fetchBalance
        * @description query for balance and get the amount of funds available for trading or funds locked in orders
        * @see https://docs.coinex.com/api/v2/assets/balance/http/get-spot-balance         // spot
        * @see https://docs.coinex.com/api/v2/assets/balance/http/get-futures-balance      // swap
        * @see https://docs.coinex.com/api/v2/assets/balance/http/get-marigin-balance      // margin
        * @see https://docs.coinex.com/api/v2/assets/balance/http/get-financial-balance    // financial
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {string} [params.type] 'margin', 'swap', 'financial', or 'spot'
        * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
        */
        parameters ??= new Dictionary<string, object>();
        object marketType = null;
        var marketTypeparametersVariable = this.handleMarketTypeAndParams("fetchBalance", null, parameters);
        marketType = ((IList<object>)marketTypeparametersVariable)[0];
        parameters = ((IList<object>)marketTypeparametersVariable)[1];
        object marginMode = null;
        var marginModeparametersVariable = this.handleMarginModeAndParams("fetchBalance", parameters);
        marginMode = ((IList<object>)marginModeparametersVariable)[0];
        parameters = ((IList<object>)marginModeparametersVariable)[1];
        object isMargin = isTrue((!isEqual(marginMode, null))) || isTrue((isEqual(marketType, "margin")));
        if (isTrue(isEqual(marketType, "swap")))
        {
            return await this.fetchSwapBalance(parameters);
        } else if (isTrue(isEqual(marketType, "financial")))
        {
            return await this.fetchFinancialBalance(parameters);
        } else if (isTrue(isMargin))
        {
            return await this.fetchMarginBalance(parameters);
        } else
        {
            return await this.fetchSpotBalance(parameters);
        }
    }

    public virtual object parseOrderStatus(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "rejected", "rejected" },
            { "open", "open" },
            { "not_deal", "open" },
            { "part_deal", "open" },
            { "done", "closed" },
            { "cancel", "canceled" },
        };
        return this.safeString(statuses, status, status);
    }

    public override object parseOrder(object order, object market = null)
    {
        //
        // Spot and Margin createOrder, createOrders, editOrder, cancelOrders, cancelOrder, fetchOpenOrders
        //
        //     {
        //         "amount": "0.0001",
        //         "base_fee": "0",
        //         "ccy": "BTC",
        //         "client_id": "x-167673045-a0a3c6461459a801",
        //         "created_at": 1714114386250,
        //         "discount_fee": "0",
        //         "filled_amount": "0",
        //         "filled_value": "0",
        //         "last_fill_amount": "0",
        //         "last_fill_price": "0",
        //         "maker_fee_rate": "0.002",
        //         "market": "BTCUSDT",
        //         "market_type": "SPOT",
        //         "order_id": 117178743547,
        //         "price": "61000",
        //         "quote_fee": "0",
        //         "side": "buy",
        //         "taker_fee_rate": "0.002",
        //         "type": "limit",
        //         "unfilled_amount": "0.0001",
        //         "updated_at": 1714114386250
        //     }
        //
        // Spot and Margin fetchClosedOrders
        //
        //     {
        //         "order_id": 117180532345,
        //         "market": "BTCUSDT",
        //         "market_type": "SPOT",
        //         "side": "sell",
        //         "type": "market",
        //         "ccy": "BTC",
        //         "amount": "0.00015484",
        //         "price": "0",
        //         "client_id": "",
        //         "created_at": 1714116494219,
        //         "updated_at": 0,
        //         "base_fee": "0",
        //         "quote_fee": "0.0199931699632",
        //         "discount_fee": "0",
        //         "maker_fee_rate": "0",
        //         "taker_fee_rate": "0.002",
        //         "unfilled_amount": "0",
        //         "filled_amount": "0.00015484",
        //         "filled_value": "9.9965849816"
        //     }
        //
        // Spot, Margin and Swap trigger createOrder, createOrders, editOrder
        //
        //     {
        //         "stop_id": 117180138153
        //     }
        //
        // Swap createOrder, createOrders, editOrder, cancelOrders, cancelOrder, fetchOpenOrders, fetchClosedOrders
        //
        //     {
        //         "amount": "0.0001",
        //         "client_id": "x-167673045-1471b81d747080a0",
        //         "created_at": 1714116769986,
        //         "fee": "0",
        //         "fee_ccy": "USDT",
        //         "filled_amount": "0",
        //         "filled_value": "0",
        //         "last_filled_amount": "0",
        //         "last_filled_price": "0",
        //         "maker_fee_rate": "0.0003",
        //         "market": "BTCUSDT",
        //         "market_type": "FUTURES",
        //         "order_id": 136913377780,
        //         "price": "61000.42",
        //         "realized_pnl": "0",
        //         "side": "buy",
        //         "taker_fee_rate": "0.0005",
        //         "type": "limit",
        //         "unfilled_amount": "0.0001",
        //         "updated_at": 1714116769986
        //     }
        //
        // Swap stopLossPrice and takeProfitPrice createOrder
        //
        //     {
        //         "adl_level": 1,
        //         "ath_margin_size": "2.14586666",
        //         "ath_position_amount": "0.0001",
        //         "avg_entry_price": "64376",
        //         "bkr_price": "0",
        //         "close_avbl": "0.0001",
        //         "cml_position_value": "6.4376",
        //         "created_at": 1714119054558,
        //         "leverage": "3",
        //         "liq_price": "0",
        //         "maintenance_margin_rate": "0.005",
        //         "maintenance_margin_value": "0.03218632",
        //         "margin_avbl": "2.14586666",
        //         "margin_mode": "cross",
        //         "market": "BTCUSDT",
        //         "market_type": "FUTURES",
        //         "max_position_value": "6.4376",
        //         "open_interest": "0.0001",
        //         "position_id": 303884204,
        //         "position_margin_rate": "3.10624785634397912265",
        //         "realized_pnl": "-0.0032188",
        //         "settle_price": "64376",
        //         "settle_value": "6.4376",
        //         "side": "long",
        //         "stop_loss_price": "62000",
        //         "stop_loss_type": "latest_price",
        //         "take_profit_price": "0",
        //         "take_profit_type": "",
        //         "unrealized_pnl": "0",
        //         "updated_at": 1714119054559
        //     }
        //
        // Swap fetchOrder
        //
        //     {
        //         "amount": "0.0001",
        //         "client_id": "x-167673045-da5f31dcd478a829",
        //         "created_at": 1714460987164,
        //         "fee": "0",
        //         "fee_ccy": "USDT",
        //         "filled_amount": "0",
        //         "filled_value": "0",
        //         "last_filled_amount": "0",
        //         "last_filled_price": "0",
        //         "maker_fee_rate": "0.0003",
        //         "market": "BTCUSDT",
        //         "market_type": "FUTURES",
        //         "order_id": 137319868771,
        //         "price": "61000",
        //         "realized_pnl": "0",
        //         "side": "buy",
        //         "status": "open",
        //         "taker_fee_rate": "0.0005",
        //         "type": "limit",
        //         "unfilled_amount": "0.0001",
        //         "updated_at": 1714460987164
        //     }
        //
        // Spot and Margin fetchOrder
        //
        //     {
        //         "amount": "0.0001",
        //         "base_fee": "0",
        //         "ccy": "BTC",
        //         "client_id": "x-167673045-da918d6724e3af81",
        //         "created_at": 1714461638958,
        //         "discount_fee": "0",
        //         "filled_amount": "0",
        //         "filled_value": "0",
        //         "last_fill_amount": "0",
        //         "last_fill_price": "0",
        //         "maker_fee_rate": "0.002",
        //         "market": "BTCUSDT",
        //         "market_type": "SPOT",
        //         "order_id": 117492012985,
        //         "price": "61000",
        //         "quote_fee": "0",
        //         "side": "buy",
        //         "status": "open",
        //         "taker_fee_rate": "0.002",
        //         "type": "limit",
        //         "unfilled_amount": "0.0001",
        //         "updated_at": 1714461638958
        //     }
        //
        // Swap trigger fetchOpenOrders, fetchClosedOrders - Spot and Swap trigger cancelOrders, cancelOrder
        //
        //     {
        //         "amount": "0.0001",
        //         "client_id": "x-167673045-a7d7714c6478acf6",
        //         "created_at": 1714187923820,
        //         "market": "BTCUSDT",
        //         "market_type": "FUTURES",
        //         "price": "61000",
        //         "side": "buy",
        //         "stop_id": 136984426097,
        //         "trigger_direction": "higher",
        //         "trigger_price": "62000",
        //         "trigger_price_type": "latest_price",
        //         "type": "limit",
        //         "updated_at": 1714187974363
        //     }
        //
        // Spot and Margin trigger fetchOpenOrders, fetchClosedOrders
        //
        //     {
        //         "stop_id": 117586439530,
        //         "market": "BTCUSDT",
        //         "market_type": "SPOT",
        //         "ccy": "BTC",
        //         "side": "buy",
        //         "type": "limit",
        //         "amount": "0.0001",
        //         "price": "51000",
        //         "trigger_price": "52000",
        //         "trigger_direction": "higher",
        //         "trigger_price_type": "mark_price",
        //         "client_id": "x-167673045-df61777094c69312",
        //         "created_at": 1714551237335,
        //         "updated_at": 1714551237335
        //     }
        //
        object rawStatus = this.safeString(order, "status");
        object timestamp = this.safeInteger(order, "created_at");
        object updatedTimestamp = this.safeInteger(order, "updated_at");
        if (isTrue(isEqual(updatedTimestamp, 0)))
        {
            updatedTimestamp = timestamp;
        }
        object marketId = this.safeString(order, "market");
        object defaultType = this.safeString(this.options, "defaultType");
        object orderType = this.safeStringLower(order, "market_type", defaultType);
        if (isTrue(isEqual(orderType, "futures")))
        {
            orderType = "swap";
        }
        object marketType = ((bool) isTrue((isEqual(orderType, "swap")))) ? "swap" : "spot";
        market = this.safeMarket(marketId, market, null, marketType);
        object feeCurrencyId = this.safeString(order, "fee_ccy");
        object feeCurrency = this.safeCurrencyCode(feeCurrencyId);
        if (isTrue(isEqual(feeCurrency, null)))
        {
            feeCurrency = getValue(market, "quote");
        }
        object side = this.safeString(order, "side");
        if (isTrue(isEqual(side, "long")))
        {
            side = "buy";
        } else if (isTrue(isEqual(side, "short")))
        {
            side = "sell";
        }
        object clientOrderId = this.safeString(order, "client_id");
        if (isTrue(isEqual(clientOrderId, "")))
        {
            clientOrderId = null;
        }
        return this.safeOrder(new Dictionary<string, object>() {
            { "id", this.safeStringN(order, new List<object>() {"position_id", "order_id", "stop_id"}) },
            { "clientOrderId", clientOrderId },
            { "datetime", this.iso8601(timestamp) },
            { "timestamp", timestamp },
            { "lastTradeTimestamp", updatedTimestamp },
            { "status", this.parseOrderStatus(rawStatus) },
            { "symbol", getValue(market, "symbol") },
            { "type", this.safeString(order, "type") },
            { "timeInForce", null },
            { "postOnly", null },
            { "reduceOnly", null },
            { "side", side },
            { "price", this.safeString(order, "price") },
            { "stopPrice", this.safeString(order, "trigger_price") },
            { "triggerPrice", this.safeString(order, "trigger_price") },
            { "takeProfitPrice", this.safeNumber(order, "take_profit_price") },
            { "stopLossPrice", this.safeNumber(order, "stop_loss_price") },
            { "cost", this.safeString(order, "filled_value") },
            { "average", this.safeString(order, "avg_entry_price") },
            { "amount", this.safeString(order, "amount") },
            { "filled", this.safeString(order, "filled_amount") },
            { "remaining", this.safeString(order, "unfilled_amount") },
            { "trades", null },
            { "fee", new Dictionary<string, object>() {
                { "currency", feeCurrency },
                { "cost", this.safeString2(order, "quote_fee", "fee") },
            } },
            { "info", order },
        }, market);
    }

    public async override Task<object> createMarketBuyOrderWithCost(object symbol, object cost, object parameters = null)
    {
        /**
        * @method
        * @name coinex#createMarketBuyOrderWithCost
        * @description create a market buy order by providing the symbol and cost
        * @see https://viabtc.github.io/coinex_api_en_doc/spot/#docsspot003_trade003_market_order
        * @see https://docs.coinex.com/api/v2/spot/order/http/put-order
        * @param {string} symbol unified symbol of the market to create an order in
        * @param {float} cost how much you want to trade in units of the quote currency
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        if (!isTrue(getValue(market, "spot")))
        {
            throw new NotSupported ((string)add(this.id, " createMarketBuyOrderWithCost() supports spot orders only")) ;
        }
        ((IDictionary<string,object>)parameters)["createMarketBuyOrderRequiresPrice"] = false;
        return await this.createOrder(symbol, "market", "buy", cost, null, parameters);
    }

    public virtual object createOrderRequest(object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object market = this.market(symbol);
        object swap = getValue(market, "swap");
        object clientOrderId = this.safeString2(parameters, "client_id", "clientOrderId");
        object stopPrice = this.safeString2(parameters, "stopPrice", "triggerPrice");
        object stopLossPrice = this.safeString(parameters, "stopLossPrice");
        object takeProfitPrice = this.safeString(parameters, "takeProfitPrice");
        object option = this.safeString(parameters, "option");
        object isMarketOrder = isEqual(type, "market");
        object postOnly = this.isPostOnly(isMarketOrder, isEqual(option, "maker_only"), parameters);
        object timeInForceRaw = this.safeStringUpper(parameters, "timeInForce");
        object reduceOnly = this.safeBool(parameters, "reduceOnly");
        if (isTrue(reduceOnly))
        {
            if (!isTrue(getValue(market, "swap")))
            {
                throw new InvalidOrder ((string)add(add(add(this.id, " createOrder() does not support reduceOnly for "), getValue(market, "type")), " orders, reduceOnly orders are supported for swap markets only")) ;
            }
        }
        object request = new Dictionary<string, object>() {
            { "market", getValue(market, "id") },
        };
        if (isTrue(isEqual(clientOrderId, null)))
        {
            object defaultId = "x-167673045";
            object brokerId = this.safeString(this.options, "brokerId", defaultId);
            ((IDictionary<string,object>)request)["client_id"] = add(add(brokerId, "-"), this.uuid16());
        } else
        {
            ((IDictionary<string,object>)request)["client_id"] = clientOrderId;
        }
        if (isTrue(isTrue((isEqual(stopLossPrice, null))) && isTrue((isEqual(takeProfitPrice, null)))))
        {
            if (!isTrue(reduceOnly))
            {
                ((IDictionary<string,object>)request)["side"] = side;
            }
            object requestType = type;
            if (isTrue(postOnly))
            {
                requestType = "maker_only";
            } else if (isTrue(!isEqual(timeInForceRaw, null)))
            {
                if (isTrue(isEqual(timeInForceRaw, "IOC")))
                {
                    requestType = "ioc";
                } else if (isTrue(isEqual(timeInForceRaw, "FOK")))
                {
                    requestType = "fok";
                }
            }
            if (!isTrue(isMarketOrder))
            {
                ((IDictionary<string,object>)request)["price"] = this.priceToPrecision(symbol, price);
            }
            ((IDictionary<string,object>)request)["type"] = requestType;
        }
        if (isTrue(swap))
        {
            ((IDictionary<string,object>)request)["market_type"] = "FUTURES";
            if (isTrue(isTrue(stopLossPrice) || isTrue(takeProfitPrice)))
            {
                if (isTrue(stopLossPrice))
                {
                    ((IDictionary<string,object>)request)["stop_loss_price"] = this.priceToPrecision(symbol, stopLossPrice);
                    ((IDictionary<string,object>)request)["stop_loss_type"] = this.safeString(parameters, "stop_type", "latest_price");
                } else if (isTrue(takeProfitPrice))
                {
                    ((IDictionary<string,object>)request)["take_profit_price"] = this.priceToPrecision(symbol, takeProfitPrice);
                    ((IDictionary<string,object>)request)["take_profit_type"] = this.safeString(parameters, "stop_type", "latest_price");
                }
            } else
            {
                ((IDictionary<string,object>)request)["amount"] = this.amountToPrecision(symbol, amount);
                if (isTrue(!isEqual(stopPrice, null)))
                {
                    ((IDictionary<string,object>)request)["trigger_price"] = this.priceToPrecision(symbol, stopPrice);
                    ((IDictionary<string,object>)request)["trigger_price_type"] = this.safeString(parameters, "stop_type", "latest_price");
                }
            }
        } else
        {
            object marginMode = null;
            var marginModeparametersVariable = this.handleMarginModeAndParams("createOrder", parameters);
            marginMode = ((IList<object>)marginModeparametersVariable)[0];
            parameters = ((IList<object>)marginModeparametersVariable)[1];
            if (isTrue(!isEqual(marginMode, null)))
            {
                ((IDictionary<string,object>)request)["market_type"] = "MARGIN";
            } else
            {
                ((IDictionary<string,object>)request)["market_type"] = "SPOT";
            }
            if (isTrue(isTrue((isEqual(type, "market"))) && isTrue((isEqual(side, "buy")))))
            {
                object createMarketBuyOrderRequiresPrice = true;
                var createMarketBuyOrderRequiresPriceparametersVariable = this.handleOptionAndParams(parameters, "createOrder", "createMarketBuyOrderRequiresPrice", true);
                createMarketBuyOrderRequiresPrice = ((IList<object>)createMarketBuyOrderRequiresPriceparametersVariable)[0];
                parameters = ((IList<object>)createMarketBuyOrderRequiresPriceparametersVariable)[1];
                object cost = this.safeNumber(parameters, "cost");
                parameters = this.omit(parameters, "cost");
                if (isTrue(createMarketBuyOrderRequiresPrice))
                {
                    if (isTrue(isTrue((isEqual(price, null))) && isTrue((isEqual(cost, null)))))
                    {
                        throw new InvalidOrder ((string)add(this.id, " createOrder() requires the price argument for market buy orders to calculate the total cost to spend (amount * price), alternatively set the createMarketBuyOrderRequiresPrice option or param to false and pass the cost to spend in the amount argument")) ;
                    } else
                    {
                        object amountString = this.numberToString(amount);
                        object priceString = this.numberToString(price);
                        object quoteAmount = this.parseToNumeric(Precise.stringMul(amountString, priceString));
                        object costRequest = ((bool) isTrue((!isEqual(cost, null)))) ? cost : quoteAmount;
                        ((IDictionary<string,object>)request)["amount"] = this.costToPrecision(symbol, costRequest);
                    }
                } else
                {
                    ((IDictionary<string,object>)request)["amount"] = this.costToPrecision(symbol, amount);
                }
            } else
            {
                ((IDictionary<string,object>)request)["amount"] = this.amountToPrecision(symbol, amount);
            }
            if (isTrue(!isEqual(stopPrice, null)))
            {
                ((IDictionary<string,object>)request)["trigger_price"] = this.priceToPrecision(symbol, stopPrice);
            }
        }
        parameters = this.omit(parameters, new List<object>() {"reduceOnly", "timeInForce", "postOnly", "stopPrice", "triggerPrice", "stopLossPrice", "takeProfitPrice"});
        return this.extend(request, parameters);
    }

    public async override Task<object> createOrder(object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        /**
        * @method
        * @name coinex#createOrder
        * @description create a trade order
        * @see https://docs.coinex.com/api/v2/spot/order/http/put-order
        * @see https://docs.coinex.com/api/v2/spot/order/http/put-stop-order
        * @see https://docs.coinex.com/api/v2/futures/order/http/put-order
        * @see https://docs.coinex.com/api/v2/futures/order/http/put-stop-order
        * @see https://docs.coinex.com/api/v2/futures/position/http/close-position
        * @see https://docs.coinex.com/api/v2/futures/position/http/set-position-stop-loss
        * @see https://docs.coinex.com/api/v2/futures/position/http/set-position-take-profit
        * @param {string} symbol unified symbol of the market to create an order in
        * @param {string} type 'market' or 'limit'
        * @param {string} side 'buy' or 'sell'
        * @param {float} amount how much you want to trade in units of the base currency
        * @param {float} [price] the price at which the order is to be fullfilled, in units of the quote currency, ignored in market orders
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {float} [params.triggerPrice] price to trigger stop orders
        * @param {float} [params.stopLossPrice] price to trigger stop loss orders
        * @param {float} [params.takeProfitPrice] price to trigger take profit orders
        * @param {string} [params.timeInForce] 'GTC', 'IOC', 'FOK', 'PO'
        * @param {boolean} [params.postOnly] set to true if you wish to make a post only order
        * @param {boolean} [params.reduceOnly] *contract only* indicates if this order is to reduce the size of a position
        * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object reduceOnly = this.safeBool(parameters, "reduceOnly");
        object triggerPrice = this.safeString2(parameters, "stopPrice", "triggerPrice");
        object stopLossTriggerPrice = this.safeString(parameters, "stopLossPrice");
        object takeProfitTriggerPrice = this.safeString(parameters, "takeProfitPrice");
        object isTriggerOrder = !isEqual(triggerPrice, null);
        object isStopLossTriggerOrder = !isEqual(stopLossTriggerPrice, null);
        object isTakeProfitTriggerOrder = !isEqual(takeProfitTriggerPrice, null);
        object isStopLossOrTakeProfitTrigger = isTrue(isStopLossTriggerOrder) || isTrue(isTakeProfitTriggerOrder);
        object request = this.createOrderRequest(symbol, type, side, amount, price, parameters);
        object response = null;
        if (isTrue(getValue(market, "spot")))
        {
            if (isTrue(isTriggerOrder))
            {
                response = await this.v2PrivatePostSpotStopOrder(request);
            } else
            {
                response = await this.v2PrivatePostSpotOrder(request);
            }
        } else
        {
            if (isTrue(isTriggerOrder))
            {
                response = await this.v2PrivatePostFuturesStopOrder(request);
            } else if (isTrue(isStopLossOrTakeProfitTrigger))
            {
                if (isTrue(isStopLossTriggerOrder))
                {
                    response = await this.v2PrivatePostFuturesSetPositionStopLoss(request);
                } else if (isTrue(isTakeProfitTriggerOrder))
                {
                    response = await this.v2PrivatePostFuturesSetPositionTakeProfit(request);
                }
            } else
            {
                if (isTrue(reduceOnly))
                {
                    response = await this.v2PrivatePostFuturesClosePosition(request);
                } else
                {
                    response = await this.v2PrivatePostFuturesOrder(request);
                }
            }
        }
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        return this.parseOrder(data, market);
    }

    public async override Task<object> createOrders(object orders, object parameters = null)
    {
        /**
        * @method
        * @name coinex#createOrders
        * @description create a list of trade orders (all orders should be of the same symbol)
        * @see https://docs.coinex.com/api/v2/spot/order/http/put-multi-order
        * @see https://docs.coinex.com/api/v2/spot/order/http/put-multi-stop-order
        * @see https://docs.coinex.com/api/v2/futures/order/http/put-multi-order
        * @see https://docs.coinex.com/api/v2/futures/order/http/put-multi-stop-order
        * @param {Array} orders list of orders to create, each object should contain the parameters required by createOrder, namely symbol, type, side, amount, price and params
        * @param {object} [params] extra parameters specific to the api endpoint
        * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object ordersRequests = new List<object>() {};
        object symbol = null;
        object reduceOnly = false;
        object isTriggerOrder = false;
        object isStopLossOrTakeProfitTrigger = false;
        for (object i = 0; isLessThan(i, getArrayLength(orders)); postFixIncrement(ref i))
        {
            object rawOrder = getValue(orders, i);
            object marketId = this.safeString(rawOrder, "symbol");
            if (isTrue(isEqual(symbol, null)))
            {
                symbol = marketId;
            } else
            {
                if (isTrue(!isEqual(symbol, marketId)))
                {
                    throw new BadRequest ((string)add(this.id, " createOrders() requires all orders to have the same symbol")) ;
                }
            }
            object type = this.safeString(rawOrder, "type");
            object side = this.safeString(rawOrder, "side");
            object amount = this.safeValue(rawOrder, "amount");
            object price = this.safeValue(rawOrder, "price");
            object orderParams = this.safeValue(rawOrder, "params", new Dictionary<string, object>() {});
            if (isTrue(!isEqual(type, "limit")))
            {
                throw new NotSupported ((string)add(add(add(this.id, " createOrders() does not support "), type), " orders, only limit orders are accepted")) ;
            }
            reduceOnly = this.safeValue(orderParams, "reduceOnly");
            object triggerPrice = this.safeNumber2(orderParams, "stopPrice", "triggerPrice");
            object stopLossTriggerPrice = this.safeNumber(orderParams, "stopLossPrice");
            object takeProfitTriggerPrice = this.safeNumber(orderParams, "takeProfitPrice");
            isTriggerOrder = !isEqual(triggerPrice, null);
            object isStopLossTriggerOrder = !isEqual(stopLossTriggerPrice, null);
            object isTakeProfitTriggerOrder = !isEqual(takeProfitTriggerPrice, null);
            isStopLossOrTakeProfitTrigger = isTrue(isStopLossTriggerOrder) || isTrue(isTakeProfitTriggerOrder);
            object orderRequest = this.createOrderRequest(marketId, type, side, amount, price, orderParams);
            ((IList<object>)ordersRequests).Add(orderRequest);
        }
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "market", getValue(market, "id") },
            { "orders", ordersRequests },
        };
        object response = null;
        if (isTrue(getValue(market, "spot")))
        {
            if (isTrue(isTriggerOrder))
            {
                response = await this.v2PrivatePostSpotBatchStopOrder(request);
            } else
            {
                response = await this.v2PrivatePostSpotBatchOrder(request);
            }
        } else
        {
            if (isTrue(isTriggerOrder))
            {
                response = await this.v2PrivatePostFuturesBatchStopOrder(request);
            } else if (isTrue(isStopLossOrTakeProfitTrigger))
            {
                throw new NotSupported ((string)add(this.id, " createOrders() does not support stopLossPrice or takeProfitPrice orders")) ;
            } else
            {
                if (isTrue(reduceOnly))
                {
                    throw new NotSupported ((string)add(this.id, " createOrders() does not support reduceOnly orders")) ;
                } else
                {
                    response = await this.v2PrivatePostFuturesBatchOrder(request);
                }
            }
        }
        object data = this.safeList(response, "data", new List<object>() {});
        object results = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
        {
            object entry = getValue(data, i);
            object status = null;
            object code = this.safeInteger(entry, "code");
            if (isTrue(!isEqual(code, null)))
            {
                if (isTrue(!isEqual(code, 0)))
                {
                    status = "rejected";
                } else
                {
                    status = "open";
                }
            }
            object innerData = this.safeDict(entry, "data", new Dictionary<string, object>() {});
            object order = null;
            if (isTrue(isTrue(getValue(market, "spot")) && !isTrue(isTriggerOrder)))
            {
                ((IDictionary<string,object>)entry)["status"] = status;
                order = this.parseOrder(entry, market);
            } else
            {
                ((IDictionary<string,object>)innerData)["status"] = status;
                order = this.parseOrder(innerData, market);
            }
            ((IList<object>)results).Add(order);
        }
        return results;
    }

    public async virtual Task<object> cancelOrders(object ids, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name coinex#cancelOrders
        * @description cancel multiple orders
        * @see https://docs.coinex.com/api/v2/spot/order/http/cancel-batch-order
        * @see https://docs.coinex.com/api/v2/spot/order/http/cancel-batch-stop-order
        * @see https://docs.coinex.com/api/v2/futures/order/http/cancel-batch-order
        * @see https://docs.coinex.com/api/v2/futures/order/http/cancel-batch-stop-order
        * @param {string[]} ids order ids
        * @param {string} symbol unified market symbol
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {boolean} [params.trigger] set to true for canceling stop orders
        * @returns {object} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " cancelOrders() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "market", getValue(market, "id") },
        };
        object stop = this.safeBool2(parameters, "stop", "trigger");
        parameters = this.omit(parameters, new List<object>() {"stop", "trigger"});
        object response = null;
        if (isTrue(stop))
        {
            ((IDictionary<string,object>)request)["stop_ids"] = ids;
        } else
        {
            ((IDictionary<string,object>)request)["order_ids"] = ids;
        }
        if (isTrue(getValue(market, "spot")))
        {
            if (isTrue(stop))
            {
                response = await this.v2PrivatePostSpotCancelBatchStopOrder(this.extend(request, parameters));
            } else
            {
                response = await this.v2PrivatePostSpotCancelBatchOrder(this.extend(request, parameters));
            }
        } else
        {
            ((IDictionary<string,object>)request)["market_type"] = "FUTURES";
            if (isTrue(stop))
            {
                response = await this.v2PrivatePostFuturesCancelBatchStopOrder(this.extend(request, parameters));
            } else
            {
                response = await this.v2PrivatePostFuturesCancelBatchOrder(this.extend(request, parameters));
            }
        }
        object data = this.safeList(response, "data", new List<object>() {});
        object results = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
        {
            object entry = getValue(data, i);
            object item = this.safeDict(entry, "data", new Dictionary<string, object>() {});
            object order = this.parseOrder(item, market);
            ((IList<object>)results).Add(order);
        }
        return results;
    }

    public async override Task<object> editOrder(object id, object symbol, object type, object side, object amount = null, object price = null, object parameters = null)
    {
        /**
        * @method
        * @name coinex#editOrder
        * @description edit a trade order
        * @see https://docs.coinex.com/api/v2/spot/order/http/edit-order
        * @see https://docs.coinex.com/api/v2/spot/order/http/edit-stop-order
        * @see https://docs.coinex.com/api/v2/futures/order/http/edit-order
        * @see https://docs.coinex.com/api/v2/futures/order/http/edit-stop-order
        * @param {string} id order id
        * @param {string} symbol unified symbol of the market to create an order in
        * @param {string} type 'market' or 'limit'
        * @param {string} side 'buy' or 'sell'
        * @param {float} amount how much of the currency you want to trade in units of the base currency
        * @param {float} [price] the price at which the order is to be fullfilled, in units of the quote currency, ignored in market orders
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {float} [params.triggerPrice] the price to trigger stop orders
        * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " editOrder() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "market", getValue(market, "id") },
        };
        if (isTrue(!isEqual(amount, null)))
        {
            ((IDictionary<string,object>)request)["amount"] = this.amountToPrecision(symbol, amount);
        }
        if (isTrue(!isEqual(price, null)))
        {
            ((IDictionary<string,object>)request)["price"] = this.priceToPrecision(symbol, price);
        }
        object response = null;
        object triggerPrice = this.safeStringN(parameters, new List<object>() {"stopPrice", "triggerPrice", "trigger_price"});
        parameters = this.omit(parameters, new List<object>() {"stopPrice", "triggerPrice"});
        object isTriggerOrder = !isEqual(triggerPrice, null);
        if (isTrue(isTriggerOrder))
        {
            ((IDictionary<string,object>)request)["trigger_price"] = this.priceToPrecision(symbol, triggerPrice);
            ((IDictionary<string,object>)request)["stop_id"] = this.parseToNumeric(id);
        } else
        {
            ((IDictionary<string,object>)request)["order_id"] = this.parseToNumeric(id);
        }
        object marginMode = null;
        var marginModeparametersVariable = this.handleMarginModeAndParams("editOrder", parameters);
        marginMode = ((IList<object>)marginModeparametersVariable)[0];
        parameters = ((IList<object>)marginModeparametersVariable)[1];
        if (isTrue(getValue(market, "spot")))
        {
            if (isTrue(!isEqual(marginMode, null)))
            {
                ((IDictionary<string,object>)request)["market_type"] = "MARGIN";
            } else
            {
                ((IDictionary<string,object>)request)["market_type"] = "SPOT";
            }
            if (isTrue(isTriggerOrder))
            {
                response = await this.v2PrivatePostSpotModifyStopOrder(this.extend(request, parameters));
            } else
            {
                response = await this.v2PrivatePostSpotModifyOrder(this.extend(request, parameters));
            }
        } else
        {
            ((IDictionary<string,object>)request)["market_type"] = "FUTURES";
            if (isTrue(isTriggerOrder))
            {
                response = await this.v2PrivatePostFuturesModifyStopOrder(this.extend(request, parameters));
            } else
            {
                response = await this.v2PrivatePostFuturesModifyOrder(this.extend(request, parameters));
            }
        }
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        return this.parseOrder(data, market);
    }

    public async override Task<object> cancelOrder(object id, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name coinex#cancelOrder
        * @description cancels an open order
        * @see https://docs.coinex.com/api/v2/spot/order/http/cancel-order
        * @see https://docs.coinex.com/api/v2/spot/order/http/cancel-stop-order
        * @see https://docs.coinex.com/api/v2/spot/order/http/cancel-order-by-client-id
        * @see https://docs.coinex.com/api/v2/spot/order/http/cancel-stop-order-by-client-id
        * @see https://docs.coinex.com/api/v2/futures/order/http/cancel-order
        * @see https://docs.coinex.com/api/v2/futures/order/http/cancel-stop-order
        * @see https://docs.coinex.com/api/v2/futures/order/http/cancel-order-by-client-id
        * @see https://docs.coinex.com/api/v2/futures/order/http/cancel-stop-order-by-client-id
        * @param {string} id order id
        * @param {string} symbol unified symbol of the market the order was made in
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {string} [params.clientOrderId] client order id, defaults to id if not passed
        * @param {boolean} [params.trigger] set to true for canceling a trigger order
        * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " cancelOrder() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object isTriggerOrder = this.safeBool2(parameters, "stop", "trigger");
        object swap = getValue(market, "swap");
        object request = new Dictionary<string, object>() {
            { "market", getValue(market, "id") },
        };
        object marginMode = null;
        var marginModeparametersVariable = this.handleMarginModeAndParams("cancelOrder", parameters);
        marginMode = ((IList<object>)marginModeparametersVariable)[0];
        parameters = ((IList<object>)marginModeparametersVariable)[1];
        if (isTrue(swap))
        {
            ((IDictionary<string,object>)request)["market_type"] = "FUTURES";
        } else
        {
            if (isTrue(!isEqual(marginMode, null)))
            {
                ((IDictionary<string,object>)request)["market_type"] = "MARGIN";
            } else
            {
                ((IDictionary<string,object>)request)["market_type"] = "SPOT";
            }
        }
        object clientOrderId = this.safeString2(parameters, "client_id", "clientOrderId");
        parameters = this.omit(parameters, new List<object>() {"stop", "trigger", "clientOrderId"});
        object response = null;
        if (isTrue(!isEqual(clientOrderId, null)))
        {
            ((IDictionary<string,object>)request)["client_id"] = clientOrderId;
            if (isTrue(isTriggerOrder))
            {
                if (isTrue(swap))
                {
                    response = await this.v2PrivatePostFuturesCancelStopOrderByClientId(this.extend(request, parameters));
                } else
                {
                    response = await this.v2PrivatePostSpotCancelStopOrderByClientId(this.extend(request, parameters));
                }
            } else
            {
                if (isTrue(swap))
                {
                    response = await this.v2PrivatePostFuturesCancelOrderByClientId(this.extend(request, parameters));
                } else
                {
                    response = await this.v2PrivatePostSpotCancelOrderByClientId(this.extend(request, parameters));
                }
            }
        } else
        {
            if (isTrue(isTriggerOrder))
            {
                ((IDictionary<string,object>)request)["stop_id"] = this.parseToNumeric(id);
                if (isTrue(swap))
                {
                    response = await this.v2PrivatePostFuturesCancelStopOrder(this.extend(request, parameters));
                } else
                {
                    response = await this.v2PrivatePostSpotCancelStopOrder(this.extend(request, parameters));
                }
            } else
            {
                ((IDictionary<string,object>)request)["order_id"] = this.parseToNumeric(id);
                if (isTrue(swap))
                {
                    response = await this.v2PrivatePostFuturesCancelOrder(this.extend(request, parameters));
                } else
                {
                    response = await this.v2PrivatePostSpotCancelOrder(this.extend(request, parameters));
                }
            }
        }
        object data = null;
        if (isTrue(!isEqual(clientOrderId, null)))
        {
            object rows = this.safeList(response, "data", new List<object>() {});
            data = this.safeDict(getValue(rows, 0), "data", new Dictionary<string, object>() {});
        } else
        {
            data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        }
        return this.parseOrder(data, market);
    }

    public async override Task<object> cancelAllOrders(object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name coinex#cancelAllOrders
        * @description cancel all open orders in a market
        * @see https://docs.coinex.com/api/v2/spot/order/http/cancel-all-order
        * @see https://docs.coinex.com/api/v2/futures/order/http/cancel-all-order
        * @param {string} symbol unified market symbol of the market to cancel orders in
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {string} [params.marginMode] 'cross' or 'isolated' for canceling spot margin orders
        * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " cancelAllOrders() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "market", getValue(market, "id") },
        };
        object response = null;
        if (isTrue(getValue(market, "swap")))
        {
            ((IDictionary<string,object>)request)["market_type"] = "FUTURES";
            response = await this.v2PrivatePostFuturesCancelAllOrder(this.extend(request, parameters));
        } else
        {
            object marginMode = null;
            var marginModeparametersVariable = this.handleMarginModeAndParams("cancelAllOrders", parameters);
            marginMode = ((IList<object>)marginModeparametersVariable)[0];
            parameters = ((IList<object>)marginModeparametersVariable)[1];
            if (isTrue(!isEqual(marginMode, null)))
            {
                ((IDictionary<string,object>)request)["market_type"] = "MARGIN";
            } else
            {
                ((IDictionary<string,object>)request)["market_type"] = "SPOT";
            }
            response = await this.v2PrivatePostSpotCancelAllOrder(this.extend(request, parameters));
        }
        return new List<object> {this.safeOrder(new Dictionary<string, object>() {
    { "info", response },
})};
    }

    public async override Task<object> fetchOrder(object id, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name coinex#fetchOrder
        * @description fetches information on an order made by the user
        * @see https://docs.coinex.com/api/v2/spot/order/http/get-order-status
        * @see https://docs.coinex.com/api/v2/futures/order/http/get-order-status
        * @param {string} symbol unified symbol of the market the order was made in
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchOrder() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "market", getValue(market, "id") },
            { "order_id", this.parseToNumeric(id) },
        };
        object response = null;
        if (isTrue(getValue(market, "swap")))
        {
            response = await this.v2PrivateGetFuturesOrderStatus(this.extend(request, parameters));
        } else
        {
            response = await this.v2PrivateGetSpotOrderStatus(this.extend(request, parameters));
        }
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        return this.parseOrder(data, market);
    }

    public async virtual Task<object> fetchOrdersByStatus(object status, object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name coinex#fetchOrdersByStatus
        * @description fetch a list of orders
        * @see https://docs.coinex.com/api/v2/spot/order/http/list-finished-order
        * @see https://docs.coinex.com/api/v2/spot/order/http/list-finished-stop-order
        * @see https://docs.coinex.com/api/v2/futures/order/http/list-finished-order
        * @see https://docs.coinex.com/api/v2/futures/order/http/list-finished-stop-order
        * @param {string} symbol unified market symbol of the market orders were made in
        * @param {int} [since] the earliest time in ms to fetch orders for
        * @param {int} [limit] the maximum number of order structures to retrieve
        * @param {boolean} [params.trigger] set to true for fetching trigger orders
        * @param {string} [params.marginMode] 'cross' or 'isolated' for fetching spot margin orders
        * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            ((IDictionary<string,object>)request)["market"] = getValue(market, "id");
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        object stop = this.safeBool2(parameters, "stop", "trigger");
        parameters = this.omit(parameters, new List<object>() {"stop", "trigger"});
        object marketType = null;
        var marketTypeparametersVariable = this.handleMarketTypeAndParams("fetchOrdersByStatus", market, parameters);
        marketType = ((IList<object>)marketTypeparametersVariable)[0];
        parameters = ((IList<object>)marketTypeparametersVariable)[1];
        object response = null;
        object isClosed = isTrue((isEqual(status, "finished"))) || isTrue((isEqual(status, "closed")));
        object isOpen = isTrue((isEqual(status, "pending"))) || isTrue((isEqual(status, "open")));
        if (isTrue(isEqual(marketType, "swap")))
        {
            ((IDictionary<string,object>)request)["market_type"] = "FUTURES";
            if (isTrue(isClosed))
            {
                if (isTrue(stop))
                {
                    response = await this.v2PrivateGetFuturesFinishedStopOrder(this.extend(request, parameters));
                } else
                {
                    response = await this.v2PrivateGetFuturesFinishedOrder(this.extend(request, parameters));
                }
            } else if (isTrue(isOpen))
            {
                if (isTrue(stop))
                {
                    response = await this.v2PrivateGetFuturesPendingStopOrder(this.extend(request, parameters));
                } else
                {
                    response = await this.v2PrivateGetFuturesPendingOrder(this.extend(request, parameters));
                }
            }
        } else
        {
            object marginMode = null;
            var marginModeparametersVariable = this.handleMarginModeAndParams("fetchOrdersByStatus", parameters);
            marginMode = ((IList<object>)marginModeparametersVariable)[0];
            parameters = ((IList<object>)marginModeparametersVariable)[1];
            if (isTrue(!isEqual(marginMode, null)))
            {
                ((IDictionary<string,object>)request)["market_type"] = "MARGIN";
            } else
            {
                ((IDictionary<string,object>)request)["market_type"] = "SPOT";
            }
            if (isTrue(isClosed))
            {
                if (isTrue(stop))
                {
                    response = await this.v2PrivateGetSpotFinishedStopOrder(this.extend(request, parameters));
                } else
                {
                    response = await this.v2PrivateGetSpotFinishedOrder(this.extend(request, parameters));
                }
            } else if (isTrue(isEqual(status, "pending")))
            {
                if (isTrue(stop))
                {
                    response = await this.v2PrivateGetSpotPendingStopOrder(this.extend(request, parameters));
                } else
                {
                    response = await this.v2PrivateGetSpotPendingOrder(this.extend(request, parameters));
                }
            }
        }
        object data = this.safeList(response, "data", new List<object>() {});
        return this.parseOrders(data, market, since, limit);
    }

    public async override Task<object> fetchOpenOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name coinex#fetchOpenOrders
        * @description fetch all unfilled currently open orders
        * @see https://docs.coinex.com/api/v2/spot/order/http/list-pending-order
        * @see https://docs.coinex.com/api/v2/spot/order/http/list-pending-stop-order
        * @see https://docs.coinex.com/api/v2/futures/order/http/list-pending-order
        * @see https://docs.coinex.com/api/v2/futures/order/http/list-pending-stop-order
        * @param {string} symbol unified market symbol
        * @param {int} [since] the earliest time in ms to fetch open orders for
        * @param {int} [limit] the maximum number of open order structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {boolean} [params.trigger] set to true for fetching trigger orders
        * @param {string} [params.marginMode] 'cross' or 'isolated' for fetching spot margin orders
        * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        object openOrders = await this.fetchOrdersByStatus("pending", symbol, since, limit, parameters);
        for (object i = 0; isLessThan(i, getArrayLength(openOrders)); postFixIncrement(ref i))
        {
            ((IDictionary<string,object>)getValue(openOrders, i))["status"] = "open";
        }
        return openOrders;
    }

    public async override Task<object> fetchClosedOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name coinex#fetchClosedOrders
        * @description fetches information on multiple closed orders made by the user
        * @see https://docs.coinex.com/api/v2/spot/order/http/list-finished-order
        * @see https://docs.coinex.com/api/v2/spot/order/http/list-finished-stop-order
        * @see https://docs.coinex.com/api/v2/futures/order/http/list-finished-order
        * @see https://docs.coinex.com/api/v2/futures/order/http/list-finished-stop-order
        * @param {string} symbol unified market symbol of the market orders were made in
        * @param {int} [since] the earliest time in ms to fetch orders for
        * @param {int} [limit] the maximum number of order structures to retrieve
        * @param {boolean} [params.trigger] set to true for fetching trigger orders
        * @param {string} [params.marginMode] 'cross' or 'isolated' for fetching spot margin orders
        * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        return await this.fetchOrdersByStatus("finished", symbol, since, limit, parameters);
    }

    public async override Task<object> createDepositAddress(object code, object parameters = null)
    {
        /**
        * @method
        * @name coinex#createDepositAddress
        * @description create a currency deposit address
        * @see https://docs.coinex.com/api/v2/assets/deposit-withdrawal/http/update-deposit-address
        * @param {string} code unified currency code of the currency for the deposit address
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {string} [params.network] the blockchain network to create a deposit address on
        * @returns {object} an [address structure]{@link https://docs.ccxt.com/#/?id=address-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        object network = this.safeString2(parameters, "chain", "network");
        if (isTrue(isEqual(network, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " createDepositAddress() requires a network parameter")) ;
        }
        parameters = this.omit(parameters, "network");
        object request = new Dictionary<string, object>() {
            { "ccy", getValue(currency, "id") },
            { "chain", this.networkCodeToId(network, getValue(currency, "code")) },
        };
        object response = await this.v2PrivatePostAssetsRenewalDepositAddress(this.extend(request, parameters));
        //
        //     {
        //         "code": 0,
        //         "data": {
        //             "address": "0x321bd6479355142334f45653ad5d8b76105a1234",
        //             "memo": ""
        //         },
        //         "message": "OK"
        //     }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        return this.parseDepositAddress(data, currency);
    }

    public async override Task<object> fetchDepositAddress(object code, object parameters = null)
    {
        /**
        * @method
        * @name coinex#fetchDepositAddress
        * @description fetch the deposit address for a currency associated with this account
        * @see https://docs.coinex.com/api/v2/assets/deposit-withdrawal/http/get-deposit-address
        * @param {string} code unified currency code
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {string} [params.network] the blockchain network to create a deposit address on
        * @returns {object} an [address structure]{@link https://docs.ccxt.com/#/?id=address-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        object networks = this.safeDict(currency, "networks", new Dictionary<string, object>() {});
        object network = this.safeString2(parameters, "network", "chain");
        parameters = this.omit(parameters, "network");
        object networksKeys = new List<object>(((IDictionary<string,object>)networks).Keys);
        object numOfNetworks = getArrayLength(networksKeys);
        if (isTrue(isTrue(!isEqual(networks, null)) && isTrue(isGreaterThan(numOfNetworks, 1))))
        {
            if (isTrue(isEqual(network, null)))
            {
                throw new ArgumentsRequired ((string)add(add(add(this.id, " fetchDepositAddress() "), code), " requires a network parameter")) ;
            }
            if (!isTrue((inOp(networks, network))))
            {
                throw new ExchangeError ((string)add(add(add(add(this.id, " fetchDepositAddress() "), network), " network not supported for "), code)) ;
            }
        }
        object request = new Dictionary<string, object>() {
            { "ccy", getValue(currency, "id") },
            { "chain", network },
        };
        object response = await this.v2PrivateGetAssetsDepositAddress(this.extend(request, parameters));
        //
        //     {
        //         "code": 0,
        //         "data": {
        //             "address": "0x321bd6479355142334f45653ad5d8b76105a1234",
        //             "memo": ""
        //         },
        //         "message": "OK"
        //     }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        object depositAddress = this.parseDepositAddress(data, currency);
        object options = this.safeDict(this.options, "fetchDepositAddress", new Dictionary<string, object>() {});
        object fillResponseFromRequest = this.safeBool(options, "fillResponseFromRequest", true);
        if (isTrue(fillResponseFromRequest))
        {
            ((IDictionary<string,object>)depositAddress)["network"] = this.safeNetworkCode(network, currency);
        }
        return depositAddress;
    }

    public virtual object safeNetwork(object networkId, object currency = null)
    {
        object networks = this.safeValue(currency, "networks", new Dictionary<string, object>() {});
        object networksCodes = new List<object>(((IDictionary<string,object>)networks).Keys);
        object networksCodesLength = getArrayLength(networksCodes);
        if (isTrue(isTrue(isEqual(networkId, null)) && isTrue(isEqual(networksCodesLength, 1))))
        {
            return getValue(networks, getValue(networksCodes, 0));
        }
        return new Dictionary<string, object>() {
            { "id", networkId },
            { "network", ((bool) isTrue((isEqual(networkId, null)))) ? null : ((string)networkId).ToUpper() },
        };
    }

    public virtual object safeNetworkCode(object networkId, object currency = null)
    {
        object network = this.safeNetwork(networkId, currency);
        return getValue(network, "network");
    }

    public override object parseDepositAddress(object depositAddress, object currency = null)
    {
        //
        //     {
        //         "address": "1P1JqozxioQwaqPwgMAQdNDYNyaVSqgARq",
        //         "memo": ""
        //     }
        //
        object coinAddress = this.safeString(depositAddress, "address");
        object parts = ((string)coinAddress).Split(new [] {((string)":")}, StringSplitOptions.None).ToList<object>();
        object address = null;
        object tag = null;
        object partsLength = getArrayLength(parts);
        if (isTrue(isTrue(isGreaterThan(partsLength, 1)) && isTrue(!isEqual(getValue(parts, 0), "cfx"))))
        {
            address = getValue(parts, 0);
            tag = getValue(parts, 1);
        } else
        {
            address = coinAddress;
        }
        return new Dictionary<string, object>() {
            { "info", depositAddress },
            { "currency", this.safeCurrencyCode(null, currency) },
            { "address", address },
            { "tag", tag },
            { "network", null },
        };
    }

    public async override Task<object> fetchMyTrades(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name coinex#fetchMyTrades
        * @description fetch all trades made by the user
        * @see https://docs.coinex.com/api/v2/spot/deal/http/list-user-deals
        * @see https://docs.coinex.com/api/v2/futures/deal/http/list-user-deals
        * @param {string} symbol unified market symbol
        * @param {int} [since] the earliest time in ms to fetch trades for
        * @param {int} [limit] the maximum number of trade structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {int} [params.until] timestamp in ms of the latest trades
        * @param {string} [params.side] the side of the trades, either 'buy' or 'sell', required for swap
        * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
        */
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchMyTrades() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "market", getValue(market, "id") },
        };
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["start_time"] = since;
        }
        var requestparametersVariable = this.handleUntilOption("end_time", request, parameters);
        request = ((IList<object>)requestparametersVariable)[0];
        parameters = ((IList<object>)requestparametersVariable)[1];
        object response = null;
        if (isTrue(getValue(market, "swap")))
        {
            ((IDictionary<string,object>)request)["market_type"] = "FUTURES";
            response = await this.v2PrivateGetFuturesUserDeals(this.extend(request, parameters));
        } else
        {
            object marginMode = null;
            var marginModeparametersVariable = this.handleMarginModeAndParams("fetchMyTrades", parameters);
            marginMode = ((IList<object>)marginModeparametersVariable)[0];
            parameters = ((IList<object>)marginModeparametersVariable)[1];
            if (isTrue(!isEqual(marginMode, null)))
            {
                ((IDictionary<string,object>)request)["market_type"] = "MARGIN";
            } else
            {
                ((IDictionary<string,object>)request)["market_type"] = "SPOT";
            }
            response = await this.v2PrivateGetSpotUserDeals(this.extend(request, parameters));
        }
        object data = this.safeList(response, "data", new List<object>() {});
        return this.parseTrades(data, market, since, limit);
    }

    public async override Task<object> fetchPositions(object symbols = null, object parameters = null)
    {
        /**
        * @method
        * @name coinex#fetchPositions
        * @description fetch all open positions
        * @see https://docs.coinex.com/api/v2/futures/position/http/list-pending-position
        * @see https://docs.coinex.com/api/v2/futures/position/http/list-finished-position
        * @param {string[]} [symbols] list of unified market symbols
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {string} [params.method] the method to use 'v2PrivateGetFuturesPendingPosition' or 'v2PrivateGetFuturesFinishedPosition' default is 'v2PrivateGetFuturesPendingPosition'
        * @returns {object[]} a list of [position structure]{@link https://docs.ccxt.com/#/?id=position-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object defaultMethod = null;
        var defaultMethodparametersVariable = this.handleOptionAndParams(parameters, "fetchPositions", "method", "v2PrivateGetFuturesPendingPosition");
        defaultMethod = ((IList<object>)defaultMethodparametersVariable)[0];
        parameters = ((IList<object>)defaultMethodparametersVariable)[1];
        symbols = this.marketSymbols(symbols);
        object request = new Dictionary<string, object>() {
            { "market_type", "FUTURES" },
        };
        object market = null;
        if (isTrue(!isEqual(symbols, null)))
        {
            object symbol = null;
            if (isTrue(((symbols is IList<object>) || (symbols.GetType().IsGenericType && symbols.GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>))))))
            {
                object symbolsLength = getArrayLength(symbols);
                if (isTrue(isGreaterThan(symbolsLength, 1)))
                {
                    throw new BadRequest ((string)add(this.id, " fetchPositions() symbols argument cannot contain more than 1 symbol")) ;
                }
                symbol = getValue(symbols, 0);
            } else
            {
                symbol = symbols;
            }
            market = this.market(symbol);
            ((IDictionary<string,object>)request)["market"] = getValue(market, "id");
        }
        object response = null;
        if (isTrue(isEqual(defaultMethod, "v2PrivateGetFuturesPendingPosition")))
        {
            response = await this.v2PrivateGetFuturesPendingPosition(this.extend(request, parameters));
        } else
        {
            response = await this.v2PrivateGetFuturesFinishedPosition(this.extend(request, parameters));
        }
        //
        //     {
        //         "code": 0,
        //         "data": [
        //             {
        //                 "position_id": 305891033,
        //                 "market": "BTCUSDT",
        //                 "market_type": "FUTURES",
        //                 "side": "long",
        //                 "margin_mode": "cross",
        //                 "open_interest": "0.0001",
        //                 "close_avbl": "0.0001",
        //                 "ath_position_amount": "0.0001",
        //                 "unrealized_pnl": "0",
        //                 "realized_pnl": "-0.00311684",
        //                 "avg_entry_price": "62336.8",
        //                 "cml_position_value": "6.23368",
        //                 "max_position_value": "6.23368",
        //                 "created_at": 1715152208041,
        //                 "updated_at": 1715152208041,
        //                 "take_profit_price": "0",
        //                 "stop_loss_price": "0",
        //                 "take_profit_type": "",
        //                 "stop_loss_type": "",
        //                 "settle_price": "62336.8",
        //                 "settle_value": "6.23368",
        //                 "leverage": "3",
        //                 "margin_avbl": "2.07789333",
        //                 "ath_margin_size": "2.07789333",
        //                 "position_margin_rate": "2.40545879023305655728",
        //                 "maintenance_margin_rate": "0.005",
        //                 "maintenance_margin_value": "0.03118094",
        //                 "liq_price": "0",
        //                 "bkr_price": "0",
        //                 "adl_level": 1
        //             }
        //         ],
        //         "message": "OK",
        //         "pagination": {
        //             "has_next": false
        //         }
        //     }
        //
        object position = this.safeList(response, "data", new List<object>() {});
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(position)); postFixIncrement(ref i))
        {
            ((IList<object>)result).Add(this.parsePosition(getValue(position, i), market));
        }
        return this.filterByArrayPositions(result, "symbol", symbols, false);
    }

    public async override Task<object> fetchPosition(object symbol, object parameters = null)
    {
        /**
        * @method
        * @name coinex#fetchPosition
        * @description fetch data on a single open contract trade position
        * @see https://docs.coinex.com/api/v2/futures/position/http/list-pending-position
        * @param {string} symbol unified market symbol of the market the position is held in
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [position structure]{@link https://docs.ccxt.com/#/?id=position-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "market_type", "FUTURES" },
            { "market", getValue(market, "id") },
        };
        object response = await this.v2PrivateGetFuturesPendingPosition(this.extend(request, parameters));
        //
        //     {
        //         "code": 0,
        //         "data": [
        //             {
        //                 "position_id": 305891033,
        //                 "market": "BTCUSDT",
        //                 "market_type": "FUTURES",
        //                 "side": "long",
        //                 "margin_mode": "cross",
        //                 "open_interest": "0.0001",
        //                 "close_avbl": "0.0001",
        //                 "ath_position_amount": "0.0001",
        //                 "unrealized_pnl": "0",
        //                 "realized_pnl": "-0.00311684",
        //                 "avg_entry_price": "62336.8",
        //                 "cml_position_value": "6.23368",
        //                 "max_position_value": "6.23368",
        //                 "created_at": 1715152208041,
        //                 "updated_at": 1715152208041,
        //                 "take_profit_price": "0",
        //                 "stop_loss_price": "0",
        //                 "take_profit_type": "",
        //                 "stop_loss_type": "",
        //                 "settle_price": "62336.8",
        //                 "settle_value": "6.23368",
        //                 "leverage": "3",
        //                 "margin_avbl": "2.07789333",
        //                 "ath_margin_size": "2.07789333",
        //                 "position_margin_rate": "2.40545879023305655728",
        //                 "maintenance_margin_rate": "0.005",
        //                 "maintenance_margin_value": "0.03118094",
        //                 "liq_price": "0",
        //                 "bkr_price": "0",
        //                 "adl_level": 1
        //             }
        //         ],
        //         "message": "OK",
        //         "pagination": {
        //             "has_next": false
        //         }
        //     }
        //
        object data = this.safeList(response, "data", new List<object>() {});
        return this.parsePosition(getValue(data, 0), market);
    }

    public override object parsePosition(object position, object market = null)
    {
        //
        //     {
        //         "position_id": 305891033,
        //         "market": "BTCUSDT",
        //         "market_type": "FUTURES",
        //         "side": "long",
        //         "margin_mode": "cross",
        //         "open_interest": "0.0001",
        //         "close_avbl": "0.0001",
        //         "ath_position_amount": "0.0001",
        //         "unrealized_pnl": "0",
        //         "realized_pnl": "-0.00311684",
        //         "avg_entry_price": "62336.8",
        //         "cml_position_value": "6.23368",
        //         "max_position_value": "6.23368",
        //         "created_at": 1715152208041,
        //         "updated_at": 1715152208041,
        //         "take_profit_price": "0",
        //         "stop_loss_price": "0",
        //         "take_profit_type": "",
        //         "stop_loss_type": "",
        //         "settle_price": "62336.8",
        //         "settle_value": "6.23368",
        //         "leverage": "3",
        //         "margin_avbl": "2.07789333",
        //         "ath_margin_size": "2.07789333",
        //         "position_margin_rate": "2.40545879023305655728",
        //         "maintenance_margin_rate": "0.005",
        //         "maintenance_margin_value": "0.03118094",
        //         "liq_price": "0",
        //         "bkr_price": "0",
        //         "adl_level": 1
        //     }
        //
        object marketId = this.safeString(position, "market");
        market = this.safeMarket(marketId, market, null, "swap");
        object timestamp = this.safeInteger(position, "created_at");
        return this.safePosition(new Dictionary<string, object>() {
            { "info", position },
            { "id", this.safeInteger(position, "position_id") },
            { "symbol", getValue(market, "symbol") },
            { "notional", this.safeNumber(position, "settle_value") },
            { "marginMode", this.safeString(position, "margin_mode") },
            { "liquidationPrice", this.safeNumber(position, "liq_price") },
            { "entryPrice", this.safeNumber(position, "avg_entry_price") },
            { "unrealizedPnl", this.safeNumber(position, "unrealized_pnl") },
            { "realizedPnl", this.safeNumber(position, "realized_pnl") },
            { "percentage", null },
            { "contracts", this.safeNumber(position, "close_avbl") },
            { "contractSize", this.safeNumber(market, "contractSize") },
            { "markPrice", null },
            { "lastPrice", null },
            { "side", this.safeString(position, "side") },
            { "hedged", null },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "lastUpdateTimestamp", this.safeInteger(position, "updated_at") },
            { "maintenanceMargin", this.safeNumber(position, "maintenance_margin_value") },
            { "maintenanceMarginPercentage", this.safeNumber(position, "maintenance_margin_rate") },
            { "collateral", this.safeNumber(position, "margin_avbl") },
            { "initialMargin", null },
            { "initialMarginPercentage", null },
            { "leverage", this.safeNumber(position, "leverage") },
            { "marginRatio", this.safeNumber(position, "position_margin_rate") },
            { "stopLossPrice", this.omitZero(this.safeString(position, "stop_loss_price")) },
            { "takeProfitPrice", this.omitZero(this.safeString(position, "take_profit_price")) },
        });
    }

    public async override Task<object> setMarginMode(object marginMode, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name coinex#setMarginMode
        * @description set margin mode to 'cross' or 'isolated'
        * @see https://docs.coinex.com/api/v2/futures/position/http/adjust-position-leverage
        * @param {string} marginMode 'cross' or 'isolated'
        * @param {string} symbol unified market symbol
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {int} params.leverage the rate of leverage
        * @returns {object} response from the exchange
        */
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " setMarginMode() requires a symbol argument")) ;
        }
        marginMode = ((string)marginMode).ToLower();
        if (isTrue(isTrue(!isEqual(marginMode, "isolated")) && isTrue(!isEqual(marginMode, "cross"))))
        {
            throw new BadRequest ((string)add(this.id, " setMarginMode() marginMode argument should be isolated or cross")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        if (isTrue(!isEqual(getValue(market, "type"), "swap")))
        {
            throw new BadSymbol ((string)add(this.id, " setMarginMode() supports swap contracts only")) ;
        }
        object leverage = this.safeInteger(parameters, "leverage");
        object maxLeverage = this.safeInteger(getValue(getValue(market, "limits"), "leverage"), "max", 100);
        if (isTrue(isEqual(leverage, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " setMarginMode() requires a leverage parameter")) ;
        }
        if (isTrue(isTrue((isLessThan(leverage, 1))) || isTrue((isGreaterThan(leverage, maxLeverage)))))
        {
            throw new BadRequest ((string)add(add(add(add(this.id, " setMarginMode() leverage should be between 1 and "), ((object)maxLeverage).ToString()), " for "), symbol)) ;
        }
        object request = new Dictionary<string, object>() {
            { "market", getValue(market, "id") },
            { "market_type", "FUTURES" },
            { "margin_mode", marginMode },
            { "leverage", leverage },
        };
        return await this.v2PrivatePostFuturesAdjustPositionLeverage(this.extend(request, parameters));
    }

    public async override Task<object> setLeverage(object leverage, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name coinex#setLeverage
        * @see https://docs.coinex.com/api/v2/futures/position/http/adjust-position-leverage
        * @description set the level of leverage for a market
        * @param {float} leverage the rate of leverage
        * @param {string} symbol unified market symbol
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {string} [params.marginMode] 'cross' or 'isolated' (default is 'cross')
        * @returns {object} response from the exchange
        */
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " setLeverage() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        if (!isTrue(getValue(market, "swap")))
        {
            throw new BadSymbol ((string)add(this.id, " setLeverage() supports swap contracts only")) ;
        }
        object marginMode = null;
        var marginModeparametersVariable = this.handleMarginModeAndParams("setLeverage", parameters, "cross");
        marginMode = ((IList<object>)marginModeparametersVariable)[0];
        parameters = ((IList<object>)marginModeparametersVariable)[1];
        object minLeverage = this.safeInteger(getValue(getValue(market, "limits"), "leverage"), "min", 1);
        object maxLeverage = this.safeInteger(getValue(getValue(market, "limits"), "leverage"), "max", 100);
        if (isTrue(isTrue((isLessThan(leverage, minLeverage))) || isTrue((isGreaterThan(leverage, maxLeverage)))))
        {
            throw new BadRequest ((string)add(add(add(add(add(add(this.id, " setLeverage() leverage should be between "), ((object)minLeverage).ToString()), " and "), ((object)maxLeverage).ToString()), " for "), symbol)) ;
        }
        object request = new Dictionary<string, object>() {
            { "market", getValue(market, "id") },
            { "market_type", "FUTURES" },
            { "margin_mode", marginMode },
            { "leverage", leverage },
        };
        return await this.v2PrivatePostFuturesAdjustPositionLeverage(this.extend(request, parameters));
    }

    public async override Task<object> fetchLeverageTiers(object symbols = null, object parameters = null)
    {
        /**
        * @method
        * @name coinex#fetchLeverageTiers
        * @description retrieve information on the maximum leverage, and maintenance margin for trades of varying trade sizes
        * @see https://docs.coinex.com/api/v2/futures/market/http/list-market-position-level
        * @param {string[]|undefined} symbols list of unified market symbols
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a dictionary of [leverage tiers structures]{@link https://docs.ccxt.com/#/?id=leverage-tiers-structure}, indexed by market symbols
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        if (isTrue(!isEqual(symbols, null)))
        {
            object marketIds = this.marketIds(symbols);
            ((IDictionary<string,object>)request)["market"] = String.Join(",", ((IList<object>)marketIds).ToArray());
        }
        object response = await this.v2PublicGetFuturesPositionLevel(this.extend(request, parameters));
        //
        //     {
        //         "code": 0,
        //         "data": [
        //             {
        //                 "level": [
        //                     {
        //                         "amount": "20001",
        //                         "leverage": "20",
        //                         "maintenance_margin_rate": "0.02",
        //                         "min_initial_margin_rate": "0.05"
        //                     },
        //                     {
        //                         "amount": "50001",
        //                         "leverage": "10",
        //                         "maintenance_margin_rate": "0.04",
        //                         "min_initial_margin_rate": "0.1"
        //                     },
        //                 ],
        //                 "market": "MINAUSDT"
        //             },
        //         ],
        //         "message": "OK"
        //     }
        //
        object data = this.safeList(response, "data", new List<object>() {});
        return this.parseLeverageTiers(data, symbols, "market");
    }

    public override object parseMarketLeverageTiers(object info, object market = null)
    {
        object tiers = new List<object>() {};
        object brackets = this.safeList(info, "level", new List<object>() {});
        object minNotional = 0;
        for (object i = 0; isLessThan(i, getArrayLength(brackets)); postFixIncrement(ref i))
        {
            object tier = getValue(brackets, i);
            object marketId = this.safeString(info, "market");
            market = this.safeMarket(marketId, market, null, "swap");
            object maxNotional = this.safeNumber(tier, "amount");
            ((IList<object>)tiers).Add(new Dictionary<string, object>() {
                { "tier", this.sum(i, 1) },
                { "currency", ((bool) isTrue(getValue(market, "linear"))) ? getValue(market, "base") : getValue(market, "quote") },
                { "minNotional", minNotional },
                { "maxNotional", maxNotional },
                { "maintenanceMarginRate", this.safeNumber(tier, "maintenance_margin_rate") },
                { "maxLeverage", this.safeInteger(tier, "leverage") },
                { "info", tier },
            });
            minNotional = maxNotional;
        }
        return tiers;
    }

    public async virtual Task<object> modifyMarginHelper(object symbol, object amount, object addOrReduce, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object rawAmount = this.amountToPrecision(symbol, amount);
        object requestAmount = rawAmount;
        if (isTrue(isEqual(addOrReduce, "reduce")))
        {
            requestAmount = Precise.stringNeg(rawAmount);
        }
        object request = new Dictionary<string, object>() {
            { "market", getValue(market, "id") },
            { "market_type", "FUTURES" },
            { "amount", requestAmount },
        };
        object response = await this.v2PrivatePostFuturesAdjustPositionMargin(this.extend(request, parameters));
        //
        //     {
        //         "code": 0,
        //         "data": {
        //             "adl_level": 1,
        //             "ath_margin_size": "2.034928",
        //             "ath_position_amount": "0.0001",
        //             "avg_entry_price": "61047.84",
        //             "bkr_price": "30698.5600000000000004142",
        //             "close_avbl": "0.0001",
        //             "cml_position_value": "6.104784",
        //             "created_at": 1715488472908,
        //             "leverage": "3",
        //             "liq_price": "30852.82412060301507579316",
        //             "maintenance_margin_rate": "0.005",
        //             "maintenance_margin_value": "0.03051465",
        //             "margin_avbl": "3.034928",
        //             "margin_mode": "isolated",
        //             "market": "BTCUSDT",
        //             "market_type": "FUTURES",
        //             "max_position_value": "6.104784",
        //             "open_interest": "0.0001",
        //             "position_id": 306458800,
        //             "position_margin_rate": "0.49713929272518077625",
        //             "realized_pnl": "-0.003052392",
        //             "settle_price": "61047.84",
        //             "settle_value": "6.104784",
        //             "side": "long",
        //             "stop_loss_price": "0",
        //             "stop_loss_type": "",
        //             "take_profit_price": "0",
        //             "take_profit_type": "",
        //             "unrealized_pnl": "0",
        //             "updated_at": 1715488805563
        //         },
        //         "message": "OK"
        //     }
        //
        object data = this.safeDict(response, "data");
        object status = this.safeStringLower(response, "message");
        object type = ((bool) isTrue((isEqual(addOrReduce, "reduce")))) ? "reduce" : "add";
        return this.extend(this.parseMarginModification(data, market), new Dictionary<string, object>() {
            { "type", type },
            { "amount", this.parseNumber(amount) },
            { "status", status },
        });
    }

    public override object parseMarginModification(object data, object market = null)
    {
        //
        // addMargin/reduceMargin
        //
        //     {
        //         "adl_level": 1,
        //         "ath_margin_size": "2.034928",
        //         "ath_position_amount": "0.0001",
        //         "avg_entry_price": "61047.84",
        //         "bkr_price": "30698.5600000000000004142",
        //         "close_avbl": "0.0001",
        //         "cml_position_value": "6.104784",
        //         "created_at": 1715488472908,
        //         "leverage": "3",
        //         "liq_price": "30852.82412060301507579316",
        //         "maintenance_margin_rate": "0.005",
        //         "maintenance_margin_value": "0.03051465",
        //         "margin_avbl": "3.034928",
        //         "margin_mode": "isolated",
        //         "market": "BTCUSDT",
        //         "market_type": "FUTURES",
        //         "max_position_value": "6.104784",
        //         "open_interest": "0.0001",
        //         "position_id": 306458800,
        //         "position_margin_rate": "0.49713929272518077625",
        //         "realized_pnl": "-0.003052392",
        //         "settle_price": "61047.84",
        //         "settle_value": "6.104784",
        //         "side": "long",
        //         "stop_loss_price": "0",
        //         "stop_loss_type": "",
        //         "take_profit_price": "0",
        //         "take_profit_type": "",
        //         "unrealized_pnl": "0",
        //         "updated_at": 1715488805563
        //     }
        //
        // fetchMarginAdjustmentHistory
        //
        //     {
        //         "bkr_pirce": "24698.56000000000000005224",
        //         "created_at": 1715489978697,
        //         "leverage": "3",
        //         "liq_price": "24822.67336683417085432386",
        //         "margin_avbl": "3.634928",
        //         "margin_change": "-1.5",
        //         "margin_mode": "isolated",
        //         "market": "BTCUSDT",
        //         "market_type": "FUTURES",
        //         "open_interest": "0.0001",
        //         "position_id": 306458800,
        //         "settle_price": "61047.84"
        //     }
        //
        object marketId = this.safeString(data, "market");
        object timestamp = this.safeInteger2(data, "updated_at", "created_at");
        object change = this.safeString(data, "margin_change");
        return new Dictionary<string, object>() {
            { "info", data },
            { "symbol", this.safeSymbol(marketId, market, null, "swap") },
            { "type", null },
            { "marginMode", "isolated" },
            { "amount", this.parseNumber(Precise.stringAbs(change)) },
            { "total", this.safeNumber(data, "margin_avbl") },
            { "code", getValue(market, "quote") },
            { "status", null },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
        };
    }

    public async override Task<object> addMargin(object symbol, object amount, object parameters = null)
    {
        /**
        * @method
        * @name coinex#addMargin
        * @description add margin
        * @see https://docs.coinex.com/api/v2/futures/position/http/adjust-position-margin
        * @param {string} symbol unified market symbol
        * @param {float} amount amount of margin to add
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [margin structure]{@link https://docs.ccxt.com/#/?id=add-margin-structure}
        */
        parameters ??= new Dictionary<string, object>();
        return await this.modifyMarginHelper(symbol, amount, "add", parameters);
    }

    public async override Task<object> reduceMargin(object symbol, object amount, object parameters = null)
    {
        /**
        * @method
        * @name coinex#reduceMargin
        * @description remove margin from a position
        * @see https://docs.coinex.com/api/v2/futures/position/http/adjust-position-margin
        * @param {string} symbol unified market symbol
        * @param {float} amount the amount of margin to remove
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [margin structure]{@link https://docs.ccxt.com/#/?id=reduce-margin-structure}
        */
        parameters ??= new Dictionary<string, object>();
        return await this.modifyMarginHelper(symbol, amount, "reduce", parameters);
    }

    public async override Task<object> fetchFundingHistory(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name coinex#fetchFundingHistory
        * @description fetch the history of funding fee payments paid and received on this account
        * @see https://docs.coinex.com/api/v2/futures/position/http/list-position-funding-history
        * @param {string} symbol unified market symbol
        * @param {int} [since] the earliest time in ms to fetch funding history for
        * @param {int} [limit] the maximum number of funding history structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [funding history structure]{@link https://docs.ccxt.com/#/?id=funding-history-structure}
        */
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchFundingHistory() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "market", getValue(market, "id") },
            { "market_type", "FUTURES" },
        };
        var requestparametersVariable = this.handleUntilOption("end_time", request, parameters);
        request = ((IList<object>)requestparametersVariable)[0];
        parameters = ((IList<object>)requestparametersVariable)[1];
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["start_time"] = since;
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        object response = await this.v2PrivateGetFuturesPositionFundingHistory(this.extend(request, parameters));
        //
        //     {
        //         "code": 0,
        //         "data": [
        //             {
        //                 "ccy": "USDT",
        //                 "created_at": 1715673620183,
        //                 "funding_rate": "0",
        //                 "funding_value": "0",
        //                 "market": "BTCUSDT",
        //                 "market_type": "FUTURES",
        //                 "position_id": 306458800,
        //                 "side": "long"
        //             },
        //         ],
        //         "message": "OK",
        //         "pagination": {
        //             "has_next": true
        //         }
        //     }
        //
        object data = this.safeList(response, "data", new List<object>() {});
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
        {
            object entry = getValue(data, i);
            object timestamp = this.safeInteger(entry, "created_at");
            object currencyId = this.safeString(entry, "ccy");
            object code = this.safeCurrencyCode(currencyId);
            ((IList<object>)result).Add(new Dictionary<string, object>() {
                { "info", entry },
                { "symbol", symbol },
                { "code", code },
                { "timestamp", timestamp },
                { "datetime", this.iso8601(timestamp) },
                { "id", this.safeNumber(entry, "position_id") },
                { "amount", this.safeNumber(entry, "funding_value") },
            });
        }
        return result;
    }

    public async override Task<object> fetchFundingRate(object symbol, object parameters = null)
    {
        /**
        * @method
        * @name coinex#fetchFundingRate
        * @description fetch the current funding rate
        * @see https://docs.coinex.com/api/v2/futures/market/http/list-market-funding-rate
        * @param {string} symbol unified market symbol
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [funding rate structure]{@link https://docs.ccxt.com/#/?id=funding-rate-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        if (!isTrue(getValue(market, "swap")))
        {
            throw new BadSymbol ((string)add(this.id, " fetchFundingRate() supports swap contracts only")) ;
        }
        object request = new Dictionary<string, object>() {
            { "market", getValue(market, "id") },
        };
        object response = await this.v2PublicGetFuturesFundingRate(this.extend(request, parameters));
        //
        //     {
        //         "code": 0,
        //         "data": [
        //             {
        //                 "latest_funding_rate": "0",
        //                 "latest_funding_time": 1715731200000,
        //                 "mark_price": "61602.22",
        //                 "market": "BTCUSDT",
        //                 "max_funding_rate": "0.00375",
        //                 "min_funding_rate": "-0.00375",
        //                 "next_funding_rate": "0.00021074",
        //                 "next_funding_time": 1715760000000
        //             }
        //         ],
        //         "message": "OK"
        //     }
        //
        object data = this.safeList(response, "data", new List<object>() {});
        object first = this.safeDict(data, 0, new Dictionary<string, object>() {});
        return this.parseFundingRate(first, market);
    }

    public override object parseFundingRate(object contract, object market = null)
    {
        //
        // fetchFundingRate, fetchFundingRates
        //
        //     {
        //         "latest_funding_rate": "0",
        //         "latest_funding_time": 1715731200000,
        //         "mark_price": "61602.22",
        //         "market": "BTCUSDT",
        //         "max_funding_rate": "0.00375",
        //         "min_funding_rate": "-0.00375",
        //         "next_funding_rate": "0.00021074",
        //         "next_funding_time": 1715760000000
        //     }
        //
        object currentFundingTimestamp = this.safeInteger(contract, "latest_funding_time");
        object futureFundingTimestamp = this.safeInteger(contract, "next_funding_time");
        object marketId = this.safeString(contract, "market");
        return new Dictionary<string, object>() {
            { "info", contract },
            { "symbol", this.safeSymbol(marketId, market, null, "swap") },
            { "markPrice", this.safeNumber(contract, "mark_price") },
            { "indexPrice", null },
            { "interestRate", null },
            { "estimatedSettlePrice", null },
            { "timestamp", null },
            { "datetime", null },
            { "fundingRate", this.safeNumber(contract, "latest_funding_rate") },
            { "fundingTimestamp", currentFundingTimestamp },
            { "fundingDatetime", this.iso8601(currentFundingTimestamp) },
            { "nextFundingRate", this.safeNumber(contract, "next_funding_rate") },
            { "nextFundingTimestamp", futureFundingTimestamp },
            { "nextFundingDatetime", this.iso8601(futureFundingTimestamp) },
            { "previousFundingRate", null },
            { "previousFundingTimestamp", null },
            { "previousFundingDatetime", null },
        };
    }

    public async override Task<object> fetchFundingRates(object symbols = null, object parameters = null)
    {
        /**
        * @method
        * @name coinex#fetchFundingRates
        * @description fetch the current funding rates
        * @see https://docs.coinex.com/api/v2/futures/market/http/list-market-funding-rate
        * @param {string[]} symbols unified market symbols
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} an array of [funding rate structures]{@link https://docs.ccxt.com/#/?id=funding-rate-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        symbols = this.marketSymbols(symbols);
        object request = new Dictionary<string, object>() {};
        object market = null;
        if (isTrue(!isEqual(symbols, null)))
        {
            object symbol = this.safeValue(symbols, 0);
            market = this.market(symbol);
            if (!isTrue(getValue(market, "swap")))
            {
                throw new BadSymbol ((string)add(this.id, " fetchFundingRates() supports swap contracts only")) ;
            }
            object marketIds = this.marketIds(symbols);
            ((IDictionary<string,object>)request)["market"] = String.Join(",", ((IList<object>)marketIds).ToArray());
        }
        object response = await this.v2PublicGetFuturesFundingRate(this.extend(request, parameters));
        //
        //     {
        //         "code": 0,
        //         "data": [
        //             {
        //                 "latest_funding_rate": "0",
        //                 "latest_funding_time": 1715731200000,
        //                 "mark_price": "61602.22",
        //                 "market": "BTCUSDT",
        //                 "max_funding_rate": "0.00375",
        //                 "min_funding_rate": "-0.00375",
        //                 "next_funding_rate": "0.00021074",
        //                 "next_funding_time": 1715760000000
        //             }
        //         ],
        //         "message": "OK"
        //     }
        //
        object data = this.safeList(response, "data", new List<object>() {});
        object result = this.parseFundingRates(data, market);
        return this.filterByArray(result, "symbol", symbols);
    }

    public async override Task<object> withdraw(object code, object amount, object address, object tag = null, object parameters = null)
    {
        /**
        * @method
        * @name coinex#withdraw
        * @description make a withdrawal
        * @see https://docs.coinex.com/api/v2/assets/deposit-withdrawal/http/withdrawal
        * @param {string} code unified currency code
        * @param {float} amount the amount to withdraw
        * @param {string} address the address to withdraw to
        * @param {string} tag
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {string} [params.network] unified network code
        * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
        */
        parameters ??= new Dictionary<string, object>();
        var tagparametersVariable = this.handleWithdrawTagAndParams(tag, parameters);
        tag = ((IList<object>)tagparametersVariable)[0];
        parameters = ((IList<object>)tagparametersVariable)[1];
        this.checkAddress(address);
        await this.loadMarkets();
        object currency = this.currency(code);
        object networkCode = this.safeStringUpper2(parameters, "network", "chain");
        parameters = this.omit(parameters, "network");
        if (isTrue(tag))
        {
            address = add(add(address, ":"), tag);
        }
        object request = new Dictionary<string, object>() {
            { "ccy", getValue(currency, "id") },
            { "to_address", address },
            { "amount", this.numberToString(amount) },
        };
        if (isTrue(!isEqual(networkCode, null)))
        {
            ((IDictionary<string,object>)request)["chain"] = this.networkCodeToId(networkCode); // required for on-chain, not required for inter-user transfer
        }
        object response = await this.v2PrivatePostAssetsWithdraw(this.extend(request, parameters));
        //
        //     {
        //         "code": 0,
        //         "data": {
        //             "withdraw_id": 31193755,
        //             "created_at": 1716874165038,
        //             "withdraw_method": "ON_CHAIN",
        //             "ccy": "USDT",
        //             "amount": "17.3",
        //             "actual_amount": "15",
        //             "chain": "TRC20",
        //             "tx_fee": "2.3",
        //             "fee_asset": "USDT",
        //             "fee_amount": "2.3",
        //             "to_address": "TY5vq3MT6b5cQVAHWHtpGyPg1ERcQgi3UN",
        //             "memo": "",
        //             "tx_id": "",
        //             "confirmations": 0,
        //             "explorer_address_url": "https://tronscan.org/#/address/TY5vq3MT6b5cQVAHWHtpGyPg1ERcQgi3UN",
        //             "explorer_tx_url": "https://tronscan.org/#/transaction/",
        //             "remark": "",
        //             "status": "audit_required"
        //         },
        //         "message": "OK"
        //     }
        //
        object transaction = this.safeDict(response, "data", new Dictionary<string, object>() {});
        return this.parseTransaction(transaction, currency);
    }

    public virtual object parseTransactionStatus(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "audit", "pending" },
            { "pass", "pending" },
            { "processing", "pending" },
            { "confirming", "pending" },
            { "not_pass", "failed" },
            { "cancel", "canceled" },
            { "finish", "ok" },
            { "fail", "failed" },
        };
        return this.safeString(statuses, status, status);
    }

    public async override Task<object> fetchFundingRateHistory(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name coinex#fetchFundingRateHistory
        * @description fetches historical funding rate prices
        * @see https://docs.coinex.com/api/v2/futures/market/http/list-market-funding-rate-history
        * @param {string} symbol unified symbol of the market to fetch the funding rate history for
        * @param {int} [since] timestamp in ms of the earliest funding rate to fetch
        * @param {int} [limit] the maximum amount of [funding rate structures]{@link https://docs.ccxt.com/#/?id=funding-rate-history-structure} to fetch
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [available parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
        * @param {int} [params.until] timestamp in ms of the latest funding rate
        * @returns {object[]} a list of [funding rate structures]{@link https://docs.ccxt.com/#/?id=funding-rate-history-structure}
        */
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchFundingRateHistory() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object paginate = false;
        var paginateparametersVariable = this.handleOptionAndParams(parameters, "fetchFundingRateHistory", "paginate");
        paginate = ((IList<object>)paginateparametersVariable)[0];
        parameters = ((IList<object>)paginateparametersVariable)[1];
        if (isTrue(paginate))
        {
            return await this.fetchPaginatedCallDeterministic("fetchFundingRateHistory", symbol, since, limit, "8h", parameters, 1000);
        }
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "market", getValue(market, "id") },
        };
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["start_time"] = since;
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        var requestparametersVariable = this.handleUntilOption("end_time", request, parameters);
        request = ((IList<object>)requestparametersVariable)[0];
        parameters = ((IList<object>)requestparametersVariable)[1];
        object response = await this.v2PublicGetFuturesFundingRateHistory(this.extend(request, parameters));
        //
        //     {
        //         "code": 0,
        //         "data": [
        //             {
        //                 "actual_funding_rate": "0",
        //                 "funding_time": 1715731221761,
        //                 "market": "BTCUSDT",
        //                 "theoretical_funding_rate": "0"
        //             },
        //         ],
        //         "message": "OK",
        //         "pagination": {
        //             "has_next": true
        //         }
        //     }
        //
        object data = this.safeList(response, "data", new List<object>() {});
        object rates = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
        {
            object entry = getValue(data, i);
            object marketId = this.safeString(entry, "market");
            object symbolInner = this.safeSymbol(marketId, market, null, "swap");
            object timestamp = this.safeInteger(entry, "funding_time");
            ((IList<object>)rates).Add(new Dictionary<string, object>() {
                { "info", entry },
                { "symbol", symbolInner },
                { "fundingRate", this.safeNumber(entry, "actual_funding_rate") },
                { "timestamp", timestamp },
                { "datetime", this.iso8601(timestamp) },
            });
        }
        object sorted = this.sortBy(rates, "timestamp");
        return this.filterBySymbolSinceLimit(sorted, getValue(market, "symbol"), since, limit);
    }

    public override object parseTransaction(object transaction, object currency = null)
    {
        //
        // fetchDeposits
        //
        //     {
        //         "deposit_id": 5173806,
        //         "created_at": 1714021652557,
        //         "tx_id": "d9f47d2550397c635cb89a8963118f8fe78ef048bc8b6f0caaeaa7dc6",
        //         "tx_id_display": "",
        //         "ccy": "USDT",
        //         "chain": "TRC20",
        //         "deposit_method": "ON_CHAIN",
        //         "amount": "30",
        //         "actual_amount": "",
        //         "to_address": "TYewD2pVWDUwfNr9A",
        //         "confirmations": 20,
        //         "status": "FINISHED",
        //         "tx_explorer_url": "https://tronscan.org/#/transaction",
        //         "to_addr_explorer_url": "https://tronscan.org/#/address",
        //         "remark": ""
        //     }
        //
        // fetchWithdrawals and withdraw
        //
        //     {
        //         "withdraw_id": 259364,
        //         "created_at": 1701323541548,
        //         "withdraw_method": "ON_CHAIN",
        //         "ccy": "USDT",
        //         "amount": "23.845744",
        //         "actual_amount": "22.445744",
        //         "chain": "TRC20",
        //         "tx_fee": "1.4",
        //         "fee_asset": "USDT",
        //         "fee_amount": "1.4",
        //         "to_address": "T8t5i2454dhdhnnnGdi49vMbihvY",
        //         "memo": "",
        //         "tx_id": "1237623941964de9954ed2e36640228d78765c1026",
        //         "confirmations": 18,
        //         "explorer_address_url": "https://tronscan.org/#/address",
        //         "explorer_tx_url": "https://tronscan.org/#/transaction",
        //         "remark": "",
        //         "status": "finished"
        //     }
        //
        object address = this.safeString(transaction, "to_address");
        object tag = this.safeString(transaction, "memo");
        if (isTrue(!isEqual(tag, null)))
        {
            if (isTrue(isLessThan(((string)tag).Length, 1)))
            {
                tag = null;
            }
        }
        object remark = this.safeString(transaction, "remark");
        if (isTrue(!isEqual(remark, null)))
        {
            if (isTrue(isLessThan(((string)remark).Length, 1)))
            {
                remark = null;
            }
        }
        object txid = this.safeString(transaction, "tx_id");
        if (isTrue(!isEqual(txid, null)))
        {
            if (isTrue(isLessThan(((string)txid).Length, 1)))
            {
                txid = null;
            }
        }
        object currencyId = this.safeString(transaction, "ccy");
        object code = this.safeCurrencyCode(currencyId, currency);
        object timestamp = this.safeInteger(transaction, "created_at");
        object type = ((bool) isTrue((inOp(transaction, "withdraw_id")))) ? "withdrawal" : "deposit";
        object networkId = this.safeString(transaction, "chain");
        object feeCost = this.safeString(transaction, "tx_fee");
        object transferMethod = this.safeStringLower2(transaction, "withdraw_method", "deposit_method");
        object intern = isEqual(transferMethod, "local");
        object amount = this.safeNumber(transaction, "actual_amount");
        if (isTrue(isEqual(amount, null)))
        {
            amount = this.safeNumber(transaction, "amount");
        }
        if (isTrue(isEqual(type, "deposit")))
        {
            feeCost = "0";
        }
        object feeCurrencyId = this.safeString(transaction, "fee_asset");
        object fee = new Dictionary<string, object>() {
            { "cost", this.parseNumber(feeCost) },
            { "currency", this.safeCurrencyCode(feeCurrencyId) },
        };
        return new Dictionary<string, object>() {
            { "info", transaction },
            { "id", this.safeString2(transaction, "withdraw_id", "deposit_id") },
            { "txid", txid },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "network", this.networkIdToCode(networkId) },
            { "address", address },
            { "addressTo", address },
            { "addressFrom", null },
            { "tag", tag },
            { "tagTo", null },
            { "tagFrom", null },
            { "type", type },
            { "amount", amount },
            { "currency", code },
            { "status", this.parseTransactionStatus(this.safeString(transaction, "status")) },
            { "updated", null },
            { "fee", fee },
            { "comment", remark },
            { "internal", intern },
        };
    }

    public async override Task<object> transfer(object code, object amount, object fromAccount, object toAccount, object parameters = null)
    {
        /**
        * @method
        * @name coinex#transfer
        * @description transfer currency internally between wallets on the same account
        * @see https://docs.coinex.com/api/v2/assets/transfer/http/transfer
        * @param {string} code unified currency code
        * @param {float} amount amount to transfer
        * @param {string} fromAccount account to transfer from
        * @param {string} toAccount account to transfer to
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {string} [params.symbol] unified ccxt symbol, required when either the fromAccount or toAccount is margin
        * @returns {object} a [transfer structure]{@link https://docs.ccxt.com/#/?id=transfer-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        object amountToPrecision = this.currencyToPrecision(code, amount);
        object accountsByType = this.safeDict(this.options, "accountsById", new Dictionary<string, object>() {});
        object fromId = this.safeString(accountsByType, fromAccount, fromAccount);
        object toId = this.safeString(accountsByType, toAccount, toAccount);
        object request = new Dictionary<string, object>() {
            { "ccy", getValue(currency, "id") },
            { "amount", amountToPrecision },
            { "from_account_type", fromId },
            { "to_account_type", toId },
        };
        if (isTrue(isTrue((isEqual(fromAccount, "margin"))) || isTrue((isEqual(toAccount, "margin")))))
        {
            object symbol = this.safeString(parameters, "symbol");
            if (isTrue(isEqual(symbol, null)))
            {
                throw new ArgumentsRequired ((string)add(this.id, " transfer() the symbol parameter must be defined for a margin account")) ;
            }
            parameters = this.omit(parameters, "symbol");
            ((IDictionary<string,object>)request)["market"] = this.marketId(symbol);
        }
        if (isTrue(isTrue((!isEqual(fromAccount, "spot"))) && isTrue((!isEqual(toAccount, "spot")))))
        {
            throw new BadRequest ((string)add(this.id, " transfer() can only be between spot and swap, or spot and margin, either the fromAccount or toAccount must be spot")) ;
        }
        object response = await this.v2PrivatePostAssetsTransfer(this.extend(request, parameters));
        //
        //     {
        //         "code": 0,
        //         "data": {},
        //         "message": "OK"
        //     }
        //
        return this.extend(this.parseTransfer(response, currency), new Dictionary<string, object>() {
            { "amount", this.parseNumber(amountToPrecision) },
            { "fromAccount", fromAccount },
            { "toAccount", toAccount },
        });
    }

    public virtual object parseTransferStatus(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "0", "ok" },
            { "SUCCESS", "ok" },
            { "OK", "ok" },
            { "finished", "ok" },
            { "FINISHED", "ok" },
        };
        return this.safeString(statuses, status, status);
    }

    public override object parseTransfer(object transfer, object currency = null)
    {
        object timestamp = this.safeInteger(transfer, "created_at");
        object currencyId = this.safeString(transfer, "ccy");
        object fromId = this.safeString(transfer, "from_account_type");
        object toId = this.safeString(transfer, "to_account_type");
        object accountsById = this.safeValue(this.options, "accountsById", new Dictionary<string, object>() {});
        return new Dictionary<string, object>() {
            { "id", null },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "currency", this.safeCurrencyCode(currencyId, currency) },
            { "amount", this.safeNumber(transfer, "amount") },
            { "fromAccount", this.safeString(accountsById, fromId, fromId) },
            { "toAccount", this.safeString(accountsById, toId, toId) },
            { "status", this.parseTransferStatus(this.safeString2(transfer, "code", "status")) },
        };
    }

    public async override Task<object> fetchTransfers(object code = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name coinex#fetchTransfers
        * @description fetch a history of internal transfers made on an account
        * @see https://docs.coinex.com/api/v2/assets/transfer/http/list-transfer-history
        * @param {string} code unified currency code of the currency transferred
        * @param {int} [since] the earliest time in ms to fetch transfers for
        * @param {int} [limit] the maximum number of transfer structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {string} [params.marginMode] 'cross' or 'isolated' for fetching transfers to and from your margin account
        * @returns {object[]} a list of [transfer structures]{@link https://docs.ccxt.com/#/?id=transfer-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        if (isTrue(isEqual(code, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchTransfers() requires a code argument")) ;
        }
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "ccy", getValue(currency, "id") },
        };
        object marginMode = null;
        var marginModeparametersVariable = this.handleMarginModeAndParams("fetchTransfers", parameters);
        marginMode = ((IList<object>)marginModeparametersVariable)[0];
        parameters = ((IList<object>)marginModeparametersVariable)[1];
        if (isTrue(!isEqual(marginMode, null)))
        {
            ((IDictionary<string,object>)request)["transfer_type"] = "MARGIN";
        } else
        {
            ((IDictionary<string,object>)request)["transfer_type"] = "FUTURES";
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["start_time"] = since;
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        var requestparametersVariable = this.handleUntilOption("end_time", request, parameters);
        request = ((IList<object>)requestparametersVariable)[0];
        parameters = ((IList<object>)requestparametersVariable)[1];
        object response = await this.v2PrivateGetAssetsTransferHistory(this.extend(request, parameters));
        //
        //     {
        //         "data": [
        //             {
        //                 "created_at": 1715848480646,
        //                 "from_account_type": "SPOT",
        //                 "to_account_type": "FUTURES",
        //                 "ccy": "USDT",
        //                 "amount": "10",
        //                 "status": "finished"
        //             },
        //         ],
        //         "pagination": {
        //             "total": 8,
        //             "has_next": false
        //         },
        //         "code": 0,
        //         "message": "OK"
        //     }
        //
        object data = this.safeList(response, "data", new List<object>() {});
        return this.parseTransfers(data, currency, since, limit);
    }

    public async override Task<object> fetchWithdrawals(object code = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name coinex#fetchWithdrawals
        * @description fetch all withdrawals made from an account
        * @see https://docs.coinex.com/api/v2/assets/deposit-withdrawal/http/list-withdrawal-history
        * @param {string} [code] unified currency code
        * @param {int} [since] the earliest time in ms to fetch withdrawals for
        * @param {int} [limit] the maximum number of withdrawal structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object currency = null;
        if (isTrue(!isEqual(code, null)))
        {
            currency = this.currency(code);
            ((IDictionary<string,object>)request)["ccy"] = getValue(currency, "id");
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        object response = await this.v2PrivateGetAssetsWithdraw(this.extend(request, parameters));
        //
        //     {
        //         "data": [
        //             {
        //                 "withdraw_id": 259364,
        //                 "created_at": 1701323541548,
        //                 "withdraw_method": "ON_CHAIN",
        //                 "ccy": "USDT",
        //                 "amount": "23.845744",
        //                 "actual_amount": "22.445744",
        //                 "chain": "TRC20",
        //                 "tx_fee": "1.4",
        //                 "fee_asset": "USDT",
        //                 "fee_amount": "1.4",
        //                 "to_address": "T8t5i2454dhdhnnnGdi49vMbihvY",
        //                 "memo": "",
        //                 "tx_id": "1237623941964de9954ed2e36640228d78765c1026",
        //                 "confirmations": 18,
        //                 "explorer_address_url": "https://tronscan.org/#/address",
        //                 "explorer_tx_url": "https://tronscan.org/#/transaction",
        //                 "remark": "",
        //                 "status": "finished"
        //             },
        //         ],
        //         "pagination": {
        //             "total": 9,
        //             "has_next": true
        //         },
        //         "code": 0,
        //         "message": "OK"
        //     }
        //
        object data = this.safeList(response, "data", new List<object>() {});
        return this.parseTransactions(data, currency, since, limit);
    }

    public async override Task<object> fetchDeposits(object code = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name coinex#fetchDeposits
        * @description fetch all deposits made to an account
        * @see https://docs.coinex.com/api/v2/assets/deposit-withdrawal/http/list-deposit-history
        * @param {string} [code] unified currency code
        * @param {int} [since] the earliest time in ms to fetch deposits for
        * @param {int} [limit] the maximum number of deposit structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object currency = null;
        if (isTrue(!isEqual(code, null)))
        {
            currency = this.currency(code);
            ((IDictionary<string,object>)request)["ccy"] = getValue(currency, "id");
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        object response = await this.v2PrivateGetAssetsDepositHistory(this.extend(request, parameters));
        //
        //     {
        //         "data": [
        //             {
        //                 "deposit_id": 5173806,
        //                 "created_at": 1714021652557,
        //                 "tx_id": "d9f47d2550397c635cb89a8963118f8fe78ef048bc8b6f0caaeaa7dc6",
        //                 "tx_id_display": "",
        //                 "ccy": "USDT",
        //                 "chain": "TRC20",
        //                 "deposit_method": "ON_CHAIN",
        //                 "amount": "30",
        //                 "actual_amount": "",
        //                 "to_address": "TYewD2pVWDUwfNr9A",
        //                 "confirmations": 20,
        //                 "status": "FINISHED",
        //                 "tx_explorer_url": "https://tronscan.org/#/transaction",
        //                 "to_addr_explorer_url": "https://tronscan.org/#/address",
        //                 "remark": ""
        //             },
        //         ],
        //         "paginatation": {
        //             "total": 8,
        //             "has_next": true
        //         },
        //         "code": 0,
        //         "message": "OK"
        //     }
        //
        object data = this.safeList(response, "data", new List<object>() {});
        return this.parseTransactions(data, currency, since, limit);
    }

    public override object parseIsolatedBorrowRate(object info, object market = null)
    {
        //
        //     {
        //         "market": "BTCUSDT",
        //         "ccy": "USDT",
        //         "leverage": 10,
        //         "min_amount": "60",
        //         "max_amount": "500000",
        //         "daily_interest_rate": "0.001"
        //     }
        //
        object marketId = this.safeString(info, "market");
        market = this.safeMarket(marketId, market, null, "spot");
        object currency = this.safeString(info, "ccy");
        object rate = this.safeNumber(info, "daily_interest_rate");
        object baseRate = null;
        object quoteRate = null;
        if (isTrue(isEqual(currency, getValue(market, "baseId"))))
        {
            baseRate = rate;
        } else if (isTrue(isEqual(currency, getValue(market, "quoteId"))))
        {
            quoteRate = rate;
        }
        return new Dictionary<string, object>() {
            { "symbol", getValue(market, "symbol") },
            { "base", getValue(market, "base") },
            { "baseRate", baseRate },
            { "quote", getValue(market, "quote") },
            { "quoteRate", quoteRate },
            { "period", 86400000 },
            { "timestamp", null },
            { "datetime", null },
            { "info", info },
        };
    }

    public async override Task<object> fetchIsolatedBorrowRate(object symbol, object parameters = null)
    {
        /**
        * @method
        * @name coinex#fetchIsolatedBorrowRate
        * @description fetch the rate of interest to borrow a currency for margin trading
        * @see https://docs.coinex.com/api/v2/assets/loan-flat/http/list-margin-interest-limit
        * @param {string} symbol unified symbol of the market to fetch the borrow rate for
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {string} params.code unified currency code
        * @returns {object} an [isolated borrow rate structure]{@link https://docs.ccxt.com/#/?id=isolated-borrow-rate-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object code = this.safeString(parameters, "code");
        if (isTrue(isEqual(code, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchIsolatedBorrowRate() requires a code parameter")) ;
        }
        parameters = this.omit(parameters, "code");
        object currency = this.currency(code);
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "market", getValue(market, "id") },
            { "ccy", getValue(currency, "id") },
        };
        object response = await this.v2PrivateGetAssetsMarginInterestLimit(this.extend(request, parameters));
        //
        //     {
        //         "code": 0,
        //         "data": {
        //             "market": "BTCUSDT",
        //             "ccy": "USDT",
        //             "leverage": 10,
        //             "min_amount": "60",
        //             "max_amount": "500000",
        //             "daily_interest_rate": "0.001"
        //         },
        //         "message": "OK"
        //     }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        return this.parseIsolatedBorrowRate(data, market);
    }

    public async override Task<object> fetchBorrowInterest(object code = null, object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name coinex#fetchBorrowInterest
        * @description fetch the interest owed by the user for borrowing currency for margin trading
        * @see https://docs.coinex.com/api/v2/assets/loan-flat/http/list-margin-borrow-history
        * @param {string} [code] unified currency code
        * @param {string} [symbol] unified market symbol when fetch interest in isolated markets
        * @param {int} [since] the earliest time in ms to fetch borrrow interest for
        * @param {int} [limit] the maximum number of structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} a list of [borrow interest structures]{@link https://docs.ccxt.com/#/?id=borrow-interest-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            ((IDictionary<string,object>)request)["market"] = getValue(market, "id");
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        object response = await this.v2PrivateGetAssetsMarginBorrowHistory(this.extend(request, parameters));
        //
        //     {
        //         "data": [
        //             {
        //                 "borrow_id": 2642934,
        //                 "created_at": 1654761016000,
        //                 "market": "BTCUSDT",
        //                 "ccy": "USDT",
        //                 "daily_interest_rate": "0.001",
        //                 "expired_at": 1655625016000,
        //                 "borrow_amount": "100",
        //                 "to_repaied_amount": "0",
        //                 "is_auto_renew": false,
        //                 "status": "finish"
        //             },
        //         ],
        //         "pagination": {
        //             "total": 4,
        //             "has_next": true
        //         },
        //         "code": 0,
        //         "message": "OK"
        //     }
        //
        object rows = this.safeValue(response, "data", new List<object>() {});
        object interest = this.parseBorrowInterests(rows, market);
        return this.filterByCurrencySinceLimit(interest, code, since, limit);
    }

    public override object parseBorrowInterest(object info, object market = null)
    {
        //
        //     {
        //         "borrow_id": 2642934,
        //         "created_at": 1654761016000,
        //         "market": "BTCUSDT",
        //         "ccy": "USDT",
        //         "daily_interest_rate": "0.001",
        //         "expired_at": 1655625016000,
        //         "borrow_amount": "100",
        //         "to_repaied_amount": "0",
        //         "is_auto_renew": false,
        //         "status": "finish"
        //     }
        //
        object marketId = this.safeString(info, "market");
        market = this.safeMarket(marketId, market, null, "spot");
        object timestamp = this.safeInteger(info, "expired_at");
        return new Dictionary<string, object>() {
            { "account", null },
            { "symbol", getValue(market, "symbol") },
            { "marginMode", "isolated" },
            { "marginType", null },
            { "currency", this.safeCurrencyCode(this.safeString(info, "ccy")) },
            { "interest", this.safeNumber(info, "to_repaied_amount") },
            { "interestRate", this.safeNumber(info, "daily_interest_rate") },
            { "amountBorrowed", this.safeNumber(info, "borrow_amount") },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "info", info },
        };
    }

    public async override Task<object> borrowIsolatedMargin(object symbol, object code, object amount, object parameters = null)
    {
        /**
        * @method
        * @name coinex#borrowIsolatedMargin
        * @description create a loan to borrow margin
        * @see https://docs.coinex.com/api/v2/assets/loan-flat/http/margin-borrow
        * @param {string} symbol unified market symbol, required for coinex
        * @param {string} code unified currency code of the currency to borrow
        * @param {float} amount the amount to borrow
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {boolean} [params.isAutoRenew] whether to renew the margin loan automatically or not, default is false
        * @returns {object} a [margin loan structure]{@link https://docs.ccxt.com/#/?id=margin-loan-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object currency = this.currency(code);
        object isAutoRenew = this.safeBool2(parameters, "isAutoRenew", "is_auto_renew", false);
        parameters = this.omit(parameters, "isAutoRenew");
        object request = new Dictionary<string, object>() {
            { "market", getValue(market, "id") },
            { "ccy", getValue(currency, "id") },
            { "borrow_amount", this.currencyToPrecision(code, amount) },
            { "is_auto_renew", isAutoRenew },
        };
        object response = await this.v2PrivatePostAssetsMarginBorrow(this.extend(request, parameters));
        //
        //     {
        //         "code": 0,
        //         "data": {
        //             "borrow_id": 13784021,
        //             "market": "BTCUSDT",
        //             "ccy": "USDT",
        //             "daily_interest_rate": "0.001",
        //             "expired_at": 1717299948340,
        //             "borrow_amount": "60",
        //             "to_repaied_amount": "60.0025",
        //             "status": "loan"
        //         },
        //         "message": "OK"
        //     }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        object transaction = this.parseMarginLoan(data, currency);
        return this.extend(transaction, new Dictionary<string, object>() {
            { "amount", amount },
            { "symbol", symbol },
        });
    }

    public async override Task<object> repayIsolatedMargin(object symbol, object code, object amount, object parameters = null)
    {
        /**
        * @method
        * @name coinex#repayIsolatedMargin
        * @description repay borrowed margin and interest
        * @see https://docs.coinex.com/api/v2/assets/loan-flat/http/margin-repay
        * @param {string} symbol unified market symbol, required for coinex
        * @param {string} code unified currency code of the currency to repay
        * @param {float} amount the amount to repay
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {string} [params.borrow_id] extra parameter that is not required
        * @returns {object} a [margin loan structure]{@link https://docs.ccxt.com/#/?id=margin-loan-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "market", getValue(market, "id") },
            { "ccy", getValue(currency, "id") },
            { "amount", this.currencyToPrecision(code, amount) },
        };
        object response = await this.v2PrivatePostAssetsMarginRepay(this.extend(request, parameters));
        //
        //     {
        //         "code": 0,
        //         "data": {},
        //         "message": "OK"
        //     }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        object transaction = this.parseMarginLoan(data, currency);
        return this.extend(transaction, new Dictionary<string, object>() {
            { "amount", amount },
            { "symbol", symbol },
        });
    }

    public virtual object parseMarginLoan(object info, object currency = null)
    {
        //
        //     {
        //         "borrow_id": 13784021,
        //         "market": "BTCUSDT",
        //         "ccy": "USDT",
        //         "daily_interest_rate": "0.001",
        //         "expired_at": 1717299948340,
        //         "borrow_amount": "60",
        //         "to_repaied_amount": "60.0025",
        //         "status": "loan"
        //     }
        //
        object currencyId = this.safeString(info, "ccy");
        object marketId = this.safeString(info, "market");
        object timestamp = this.safeInteger(info, "expired_at");
        return new Dictionary<string, object>() {
            { "id", this.safeInteger(info, "borrow_id") },
            { "currency", this.safeCurrencyCode(currencyId, currency) },
            { "amount", this.safeString(info, "borrow_amount") },
            { "symbol", this.safeSymbol(marketId, null, null, "spot") },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "info", info },
        };
    }

    public async override Task<object> fetchDepositWithdrawFee(object code, object parameters = null)
    {
        /**
        * @method
        * @name coinex#fetchDepositWithdrawFee
        * @description fetch the fee for deposits and withdrawals
        * @see https://docs.coinex.com/api/v2/assets/deposit-withdrawal/http/get-deposit-withdrawal-config
        * @param {string} code unified currency code
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [fee structure]{@link https://docs.ccxt.com/#/?id=fee-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "ccy", getValue(currency, "id") },
        };
        object response = await this.v2PublicGetAssetsDepositWithdrawConfig(this.extend(request, parameters));
        //
        //     {
        //         "code": 0,
        //         "data": {
        //             "asset": {
        //                 "ccy": "USDT",
        //                 "deposit_enabled": true,
        //                 "withdraw_enabled": true,
        //                 "inter_transfer_enabled": true,
        //                 "is_st": false
        //             },
        //             "chains": [
        //                 {
        //                     "chain": "TRC20",
        //                     "min_deposit_amount": "2.4",
        //                     "min_withdraw_amount": "2.4",
        //                     "deposit_enabled": true,
        //                     "withdraw_enabled": true,
        //                     "deposit_delay_minutes": 0,
        //                     "safe_confirmations": 10,
        //                     "irreversible_confirmations": 20,
        //                     "deflation_rate": "0",
        //                     "withdrawal_fee": "2.4",
        //                     "withdrawal_precision": 6,
        //                     "memo": "",
        //                     "is_memo_required_for_deposit": false,
        //                     "explorer_asset_url": "https://tronscan.org/#/token20/TR7NHqjeKQxGTCi8q8ZY4pL8otSzgjLj6t"
        //                 },
        //             ]
        //         },
        //         "message": "OK"
        //     }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        return ((object)this.parseDepositWithdrawFee(data, currency));
    }

    public override object parseDepositWithdrawFee(object fee, object currency = null)
    {
        //
        //     {
        //         "asset": {
        //             "ccy": "USDT",
        //             "deposit_enabled": true,
        //             "withdraw_enabled": true,
        //             "inter_transfer_enabled": true,
        //             "is_st": false
        //         },
        //         "chains": [
        //             {
        //                 "chain": "TRC20",
        //                 "min_deposit_amount": "2.4",
        //                 "min_withdraw_amount": "2.4",
        //                 "deposit_enabled": true,
        //                 "withdraw_enabled": true,
        //                 "deposit_delay_minutes": 0,
        //                 "safe_confirmations": 10,
        //                 "irreversible_confirmations": 20,
        //                 "deflation_rate": "0",
        //                 "withdrawal_fee": "2.4",
        //                 "withdrawal_precision": 6,
        //                 "memo": "",
        //                 "is_memo_required_for_deposit": false,
        //                 "explorer_asset_url": "https://tronscan.org/#/token20/TR7NHqjeKQxGTCi8q8ZY4pL8otSzgjLj6t"
        //             },
        //         ]
        //     }
        //
        object result = new Dictionary<string, object>() {
            { "info", fee },
            { "withdraw", new Dictionary<string, object>() {
                { "fee", null },
                { "percentage", null },
            } },
            { "deposit", new Dictionary<string, object>() {
                { "fee", null },
                { "percentage", null },
            } },
            { "networks", new Dictionary<string, object>() {} },
        };
        object chains = this.safeList(fee, "chains", new List<object>() {});
        object asset = this.safeDict(fee, "asset", new Dictionary<string, object>() {});
        for (object i = 0; isLessThan(i, getArrayLength(chains)); postFixIncrement(ref i))
        {
            object entry = getValue(chains, i);
            object isWithdrawEnabled = this.safeBool(entry, "withdraw_enabled");
            if (isTrue(isWithdrawEnabled))
            {
                ((IDictionary<string,object>)getValue(result, "withdraw"))["fee"] = this.safeNumber(entry, "withdrawal_fee");
                ((IDictionary<string,object>)getValue(result, "withdraw"))["percentage"] = false;
                object networkId = this.safeString(entry, "chain");
                if (isTrue(networkId))
                {
                    object networkCode = this.networkIdToCode(networkId, this.safeString(asset, "ccy"));
                    ((IDictionary<string,object>)getValue(result, "networks"))[(string)networkCode] = new Dictionary<string, object>() {
                        { "withdraw", new Dictionary<string, object>() {
                            { "fee", this.safeNumber(entry, "withdrawal_fee") },
                            { "percentage", false },
                        } },
                        { "deposit", new Dictionary<string, object>() {
                            { "fee", null },
                            { "percentage", null },
                        } },
                    };
                }
            }
        }
        return result;
    }

    public async override Task<object> fetchLeverage(object symbol, object parameters = null)
    {
        /**
        * @method
        * @name coinex#fetchLeverage
        * @description fetch the set leverage for a market
        * @see https://docs.coinex.com/api/v2/assets/loan-flat/http/list-margin-interest-limit
        * @param {string} symbol unified market symbol
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {string} params.code unified currency code
        * @returns {object} a [leverage structure]{@link https://docs.ccxt.com/#/?id=leverage-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object code = this.safeString(parameters, "code");
        if (isTrue(isEqual(code, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchLeverage() requires a code parameter")) ;
        }
        parameters = this.omit(parameters, "code");
        object currency = this.currency(code);
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "market", getValue(market, "id") },
            { "ccy", getValue(currency, "id") },
        };
        object response = await this.v2PrivateGetAssetsMarginInterestLimit(this.extend(request, parameters));
        //
        //     {
        //         "code": 0,
        //         "data": {
        //             "market": "BTCUSDT",
        //             "ccy": "USDT",
        //             "leverage": 10,
        //             "min_amount": "50",
        //             "max_amount": "500000",
        //             "daily_interest_rate": "0.001"
        //         },
        //         "message": "OK"
        //     }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        return this.parseLeverage(data, market);
    }

    public override object parseLeverage(object leverage, object market = null)
    {
        //
        //     {
        //         "market": "BTCUSDT",
        //         "ccy": "USDT",
        //         "leverage": 10,
        //         "min_amount": "50",
        //         "max_amount": "500000",
        //         "daily_interest_rate": "0.001"
        //     }
        //
        object marketId = this.safeString(leverage, "market");
        object leverageValue = this.safeInteger(leverage, "leverage");
        return new Dictionary<string, object>() {
            { "info", leverage },
            { "symbol", this.safeSymbol(marketId, market, null, "spot") },
            { "marginMode", "isolated" },
            { "longLeverage", leverageValue },
            { "shortLeverage", leverageValue },
        };
    }

    public async override Task<object> fetchPositionHistory(object symbol, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name coinex#fetchPositionHistory
        * @description fetches historical positions
        * @see https://docs.coinex.com/api/v2/futures/position/http/list-finished-position
        * @param {string} symbol unified contract symbol
        * @param {int} [since] the earliest time in ms to fetch positions for
        * @param {int} [limit] the maximum amount of records to fetch, default is 10
        * @param {object} [params] extra parameters specific to the exchange api endpoint
        * @param {int} [params.until] the latest time in ms to fetch positions for
        * @returns {object[]} a list of [position structures]{@link https://docs.ccxt.com/#/?id=position-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "market_type", "FUTURES" },
            { "market", getValue(market, "id") },
        };
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["start_time"] = since;
        }
        var requestparametersVariable = this.handleUntilOption("end_time", request, parameters);
        request = ((IList<object>)requestparametersVariable)[0];
        parameters = ((IList<object>)requestparametersVariable)[1];
        object response = await this.v2PrivateGetFuturesFinishedPosition(this.extend(request, parameters));
        //
        //     {
        //         "code": 0,
        //         "data": [
        //             {
        //                 "position_id": 305891033,
        //                 "market": "BTCUSDT",
        //                 "market_type": "FUTURES",
        //                 "side": "long",
        //                 "margin_mode": "cross",
        //                 "open_interest": "0.0001",
        //                 "close_avbl": "0.0001",
        //                 "ath_position_amount": "0.0001",
        //                 "unrealized_pnl": "0",
        //                 "realized_pnl": "-0.00311684",
        //                 "avg_entry_price": "62336.8",
        //                 "cml_position_value": "6.23368",
        //                 "max_position_value": "6.23368",
        //                 "created_at": 1715152208041,
        //                 "updated_at": 1715152208041,
        //                 "take_profit_price": "0",
        //                 "stop_loss_price": "0",
        //                 "take_profit_type": "",
        //                 "stop_loss_type": "",
        //                 "settle_price": "62336.8",
        //                 "settle_value": "6.23368",
        //                 "leverage": "3",
        //                 "margin_avbl": "2.07789333",
        //                 "ath_margin_size": "2.07789333",
        //                 "position_margin_rate": "2.40545879023305655728",
        //                 "maintenance_margin_rate": "0.005",
        //                 "maintenance_margin_value": "0.03118094",
        //                 "liq_price": "0",
        //                 "bkr_price": "0",
        //                 "adl_level": 1
        //             }
        //         ],
        //         "message": "OK",
        //         "pagination": {
        //             "has_next": false
        //         }
        //     }
        //
        object records = this.safeList(response, "data", new List<object>() {});
        object positions = this.parsePositions(records);
        return this.filterBySymbolSinceLimit(positions, symbol, since, limit);
    }

    public override object handleMarginModeAndParams(object methodName, object parameters = null, object defaultValue = null)
    {
        /**
        * @ignore
        * @method
        * @description marginMode specified by params["marginMode"], this.options["marginMode"], this.options["defaultMarginMode"], params["margin"] = true or this.options["defaultType"] = 'margin'
        * @param {object} params extra parameters specific to the exchange api endpoint
        * @returns {Array} the marginMode in lowercase
        */
        parameters ??= new Dictionary<string, object>();
        object defaultType = this.safeString(this.options, "defaultType");
        object isMargin = this.safeBool(parameters, "margin", false);
        object marginMode = null;
        var marginModeparametersVariable = base.handleMarginModeAndParams(methodName, parameters, defaultValue);
        marginMode = ((IList<object>)marginModeparametersVariable)[0];
        parameters = ((IList<object>)marginModeparametersVariable)[1];
        if (isTrue(isEqual(marginMode, null)))
        {
            if (isTrue(isTrue((isEqual(defaultType, "margin"))) || isTrue((isEqual(isMargin, true)))))
            {
                marginMode = "isolated";
            }
        }
        return new List<object>() {marginMode, parameters};
    }

    public override object nonce()
    {
        return this.milliseconds();
    }

    public override object sign(object path, object api = null, object method = null, object parameters = null, object headers = null, object body = null)
    {
        api ??= new List<object>();
        method ??= "GET";
        parameters ??= new Dictionary<string, object>();
        path = this.implodeParams(path, parameters);
        object version = getValue(api, 0);
        object requestUrl = getValue(api, 1);
        object url = add(add(add(add(getValue(getValue(this.urls, "api"), requestUrl), "/"), version), "/"), path);
        object query = this.omit(parameters, this.extractParams(path));
        object nonce = ((object)this.nonce()).ToString();
        if (isTrue(isEqual(method, "POST")))
        {
            object parts = ((string)path).Split(new [] {((string)"/")}, StringSplitOptions.None).ToList<object>();
            object firstPart = this.safeString(parts, 0, "");
            object numParts = getArrayLength(parts);
            object lastPart = this.safeString(parts, subtract(numParts, 1), "");
            object lastWords = ((string)lastPart).Split(new [] {((string)"_")}, StringSplitOptions.None).ToList<object>();
            object numWords = getArrayLength(lastWords);
            object lastWord = this.safeString(lastWords, subtract(numWords, 1), "");
            if (isTrue(isTrue((isEqual(firstPart, "order"))) && isTrue((isTrue(isEqual(lastWord, "limit")) || isTrue(isEqual(lastWord, "market"))))))
            {
                // inject in implicit API calls
                // POST /order/limit - Place limit orders
                // POST /order/market - Place market orders
                // POST /order/stop/limit - Place stop limit orders
                // POST /order/stop/market - Place stop market orders
                // POST /perpetual/v1/order/put_limit - Place limit orders
                // POST /perpetual/v1/order/put_market - Place market orders
                // POST /perpetual/v1/order/put_stop_limit - Place stop limit orders
                // POST /perpetual/v1/order/put_stop_market - Place stop market orders
                object clientOrderId = this.safeString(parameters, "client_id");
                if (isTrue(isEqual(clientOrderId, null)))
                {
                    object defaultId = "x-167673045";
                    object brokerId = this.safeValue(this.options, "brokerId", defaultId);
                    ((IDictionary<string,object>)query)["client_id"] = add(add(brokerId, "_"), this.uuid16());
                }
            }
        }
        if (isTrue(isEqual(requestUrl, "perpetualPrivate")))
        {
            this.checkRequiredCredentials();
            query = this.extend(new Dictionary<string, object>() {
                { "access_id", this.apiKey },
                { "timestamp", nonce },
            }, query);
            query = this.keysort(query);
            object urlencoded = this.rawencode(query);
            object signature = this.hash(this.encode(add(add(urlencoded, "&secret_key="), this.secret)), sha256);
            headers = new Dictionary<string, object>() {
                { "Authorization", ((string)signature).ToLower() },
                { "AccessId", this.apiKey },
            };
            if (isTrue(isTrue((isEqual(method, "GET"))) || isTrue((isEqual(method, "PUT")))))
            {
                url = add(url, add("?", urlencoded));
            } else
            {
                ((IDictionary<string,object>)headers)["Content-Type"] = "application/x-www-form-urlencoded";
                body = urlencoded;
            }
        } else if (isTrue(isTrue(isEqual(requestUrl, "public")) || isTrue(isEqual(requestUrl, "perpetualPublic"))))
        {
            if (isTrue(getArrayLength(new List<object>(((IDictionary<string,object>)query).Keys))))
            {
                url = add(url, add("?", this.urlencode(query)));
            }
        } else
        {
            if (isTrue(isEqual(version, "v1")))
            {
                this.checkRequiredCredentials();
                query = this.extend(new Dictionary<string, object>() {
                    { "access_id", this.apiKey },
                    { "tonce", nonce },
                }, query);
                query = this.keysort(query);
                object urlencoded = this.rawencode(query);
                object signature = this.hash(this.encode(add(add(urlencoded, "&secret_key="), this.secret)), md5);
                headers = new Dictionary<string, object>() {
                    { "Authorization", ((string)signature).ToUpper() },
                    { "Content-Type", "application/json" },
                };
                if (isTrue(isTrue(isTrue((isEqual(method, "GET"))) || isTrue((isEqual(method, "DELETE")))) || isTrue((isEqual(method, "PUT")))))
                {
                    url = add(url, add("?", urlencoded));
                } else
                {
                    body = this.json(query);
                }
            } else if (isTrue(isEqual(version, "v2")))
            {
                this.checkRequiredCredentials();
                query = this.keysort(query);
                object urlencoded = this.rawencode(query);
                object preparedString = add(add(add(add(method, "/"), version), "/"), path);
                if (isTrue(isEqual(method, "POST")))
                {
                    body = this.json(query);
                    preparedString = add(preparedString, body);
                } else if (isTrue(urlencoded))
                {
                    preparedString = add(preparedString, add("?", urlencoded));
                }
                preparedString = add(preparedString, add(nonce, this.secret));
                object signature = this.hash(this.encode(preparedString), sha256);
                headers = new Dictionary<string, object>() {
                    { "Content-Type", "application/json" },
                    { "Accept", "application/json" },
                    { "X-COINEX-KEY", this.apiKey },
                    { "X-COINEX-SIGN", signature },
                    { "X-COINEX-TIMESTAMP", nonce },
                };
                if (isTrue(!isEqual(method, "POST")))
                {
                    if (isTrue(urlencoded))
                    {
                        url = add(url, add("?", urlencoded));
                    }
                }
            }
        }
        return new Dictionary<string, object>() {
            { "url", url },
            { "method", method },
            { "body", body },
            { "headers", headers },
        };
    }

    public override object handleErrors(object httpCode, object reason, object url, object method, object headers, object body, object response, object requestHeaders, object requestBody)
    {
        if (isTrue(isEqual(response, null)))
        {
            return null;
        }
        object code = this.safeString(response, "code");
        object data = this.safeValue(response, "data");
        object message = this.safeString(response, "message");
        if (isTrue(isTrue((!isEqual(code, "0"))) || isTrue((isTrue(isTrue(isTrue((!isEqual(message, "Success"))) && isTrue((!isEqual(message, "Succeeded")))) && isTrue((!isEqual(((string)message).ToLower(), "ok")))) && !isTrue(data)))))
        {
            object feedback = add(add(this.id, " "), message);
            this.throwBroadlyMatchedException(getValue(this.exceptions, "broad"), message, feedback);
            this.throwExactlyMatchedException(getValue(this.exceptions, "exact"), code, feedback);
            throw new ExchangeError ((string)feedback) ;
        }
        return null;
    }

    public async override Task<object> fetchMarginAdjustmentHistory(object symbol = null, object type = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name coinex#fetchMarginAdjustmentHistory
        * @description fetches the history of margin added or reduced from contract isolated positions
        * @see https://docs.coinex.com/api/v2/futures/position/http/list-position-margin-history
        * @param {string} symbol unified market symbol
        * @param {string} [type] not used by coinex fetchMarginAdjustmentHistory
        * @param {int} [since] timestamp in ms of the earliest change to fetch
        * @param {int} [limit] the maximum amount of changes to fetch, default is 10
        * @param {object} params extra parameters specific to the exchange api endpoint
        * @param {int} [params.until] timestamp in ms of the latest change to fetch
        * @param {int} [params.positionId] the id of the position that you want to retrieve margin adjustment history for
        * @returns {object[]} a list of [margin structures]{@link https://docs.ccxt.com/#/?id=margin-loan-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchMarginAdjustmentHistory() requires a symbol argument")) ;
        }
        object positionId = this.safeInteger2(parameters, "positionId", "position_id");
        parameters = this.omit(parameters, "positionId");
        if (isTrue(isEqual(positionId, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchMarginAdjustmentHistory() requires a positionId parameter")) ;
        }
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "market", getValue(market, "id") },
            { "market_type", "FUTURES" },
            { "position_id", positionId },
        };
        var requestparametersVariable = this.handleUntilOption("end_time", request, parameters);
        request = ((IList<object>)requestparametersVariable)[0];
        parameters = ((IList<object>)requestparametersVariable)[1];
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["start_time"] = since;
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        object response = await this.v2PrivateGetFuturesPositionMarginHistory(this.extend(request, parameters));
        //
        //     {
        //         "code": 0,
        //         "data": [
        //             {
        //                 "bkr_pirce": "24698.56000000000000005224",
        //                 "created_at": 1715489978697,
        //                 "leverage": "3",
        //                 "liq_price": "24822.67336683417085432386",
        //                 "margin_avbl": "3.634928",
        //                 "margin_change": "-1.5",
        //                 "margin_mode": "isolated",
        //                 "market": "BTCUSDT",
        //                 "market_type": "FUTURES",
        //                 "open_interest": "0.0001",
        //                 "position_id": 306458800,
        //                 "settle_price": "61047.84"
        //             },
        //         ],
        //         "message": "OK",
        //         "pagination": {
        //             "has_next": true
        //         }
        //     }
        //
        object data = this.safeList(response, "data", new List<object>() {});
        object modifications = this.parseMarginModifications(data, null, "market", "swap");
        return this.filterBySymbolSinceLimit(modifications, symbol, since, limit);
    }
}
