namespace ccxt;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

public partial class zebpay : Exchange
{
    public override object describe()
    {
        return this.deepExtend(base.describe(), new Dictionary<string, object>() {
            { "id", "zebpay" },
            { "name", "Zebpay" },
            { "countries", new List<object>() {"IN"} },
            { "rateLimit", 50 },
            { "version", "v1" },
            { "certified", false },
            { "pro", false },
            { "has", new Dictionary<string, object>() {
                { "CORS", null },
                { "spot", true },
                { "margin", false },
                { "swap", true },
                { "future", false },
                { "option", null },
                { "addMargin", true },
                { "borrowCrossMargin", false },
                { "borrowIsolatedMargin", false },
                { "borrowMargin", false },
                { "cancelAllOrders", true },
                { "cancelOrder", true },
                { "cancelOrders", false },
                { "closePosition", true },
                { "createOrder", true },
                { "fetchBalance", true },
                { "fetchBorrowInterest", false },
                { "fetchBorrowRate", false },
                { "fetchBorrowRateHistories", false },
                { "fetchBorrowRateHistory", false },
                { "fetchBorrowRates", false },
                { "fetchBorrowRatesPerSymbol", false },
                { "fetchCrossBorrowRate", false },
                { "fetchCrossBorrowRates", false },
                { "fetchCurrencies", true },
                { "fetchIsolatedBorrowRate", false },
                { "fetchIsolatedBorrowRates", false },
                { "fetchLeverage", true },
                { "fetchLeverages", true },
                { "fetchMarkets", true },
                { "fetchMyTrades", true },
                { "fetchOHLCV", true },
                { "fetchOpenOrders", true },
                { "fetchOrder", true },
                { "fetchOrderBook", true },
                { "fetchOrderTrades", true },
                { "fetchPositions", true },
                { "fetchTicker", true },
                { "fetchTickers", true },
                { "fetchTrades", true },
                { "fetchTradingFee", true },
                { "reduceMargin", true },
                { "repayCrossMargin", false },
                { "repayIsolatedMargin", false },
                { "setLeverage", true },
            } },
            { "timeframes", new Dictionary<string, object>() {
                { "1m", 1 },
                { "5m", 5 },
                { "15m", 15 },
                { "30m", 30 },
                { "1h", 60 },
                { "2h", 120 },
                { "4h", 480 },
                { "12h", 720 },
                { "1d", 1440 },
                { "1w", 10080 },
            } },
            { "urls", new Dictionary<string, object>() {
                { "logo", "https://github.com/user-attachments/assets/8094e7be-55a7-46f4-a087-0ca31b48ecad" },
                { "api", new Dictionary<string, object>() {
                    { "spot", "https://sapi.zebpay.com" },
                    { "swap", "https://futuresbe.zebpay.com" },
                } },
                { "test", new Dictionary<string, object>() {
                    { "spot", "https://www.zebstage.com" },
                    { "swap", "https://dev-futuresbe.zebstage.com" },
                } },
                { "www", "https://www.zebpay.com" },
                { "doc", "https://github.com/zebpay/zebpay-api-references" },
                { "fees", "https://zebpay.com/in/features/pricing" },
            } },
            { "api", new Dictionary<string, object>() {
                { "public", new Dictionary<string, object>() {
                    { "spot", new Dictionary<string, object>() {
                        { "get", new Dictionary<string, object>() {
                            { "v2/system/time", 10 },
                            { "v2/system/status", 10 },
                            { "v2/market/orderbook", 10 },
                            { "v2/market/trades", 10 },
                            { "v2/market/ticker", 10 },
                            { "v2/market/allTickers", 10 },
                            { "v2/ex/exchangeInfo", 10 },
                            { "v2/ex/currencies", 10 },
                            { "v2/market/klines", 10 },
                            { "v2/ex/tradefees", 10 },
                        } },
                    } },
                    { "swap", new Dictionary<string, object>() {
                        { "get", new Dictionary<string, object>() {
                            { "v1/system/time", 10 },
                            { "v1/system/status", 10 },
                            { "v1/exchange/tradefee", 10 },
                            { "v1/exchange/tradefees", 10 },
                            { "v1/market/orderBook", 10 },
                            { "v1/market/ticker24Hr", 10 },
                            { "v1/market/markets", 10 },
                            { "v1/market/aggTrade", 10 },
                        } },
                        { "post", new Dictionary<string, object>() {
                            { "v1/market/klines", 10 },
                        } },
                    } },
                } },
                { "private", new Dictionary<string, object>() {
                    { "spot", new Dictionary<string, object>() {
                        { "post", new Dictionary<string, object>() {
                            { "v2/ex/orders", 10 },
                        } },
                        { "get", new Dictionary<string, object>() {
                            { "v2/ex/orders", 10 },
                            { "v2/account/balance", 10 },
                            { "v2/ex/tradefee", 10 },
                            { "v2/ex/order", 10 },
                            { "v2/ex/order/fills", 10 },
                        } },
                        { "delete", new Dictionary<string, object>() {
                            { "v2/ex/order", 10 },
                            { "v2/ex/orders", 10 },
                            { "v2/ex/orders/cancelAll", 10 },
                        } },
                    } },
                    { "swap", new Dictionary<string, object>() {
                        { "get", new Dictionary<string, object>() {
                            { "v1/wallet/balance", 10 },
                            { "v1/trade/order", 10 },
                            { "v1/trade/order/open-orders", 10 },
                            { "v1/trade/userLeverages", 10 },
                            { "v1/trade/userLeverage", 10 },
                            { "v1/trade/positions", 10 },
                            { "v1/trade/history", 10 },
                        } },
                        { "post", new Dictionary<string, object>() {
                            { "v1/trade/order", 10 },
                            { "v1/trade/order/addTPSL", 10 },
                            { "v1/trade/addMargin", 10 },
                            { "v1/trade/reduceMargin", 10 },
                            { "v1/trade/position/close", 10 },
                            { "v1/trade/update/userLeverage", 10 },
                        } },
                        { "delete", new Dictionary<string, object>() {
                            { "v1/trade/order", 10 },
                        } },
                    } },
                } },
            } },
            { "precisionMode", TICK_SIZE },
            { "fees", new Dictionary<string, object>() {} },
            { "commonCurrencies", new Dictionary<string, object>() {} },
            { "requiredCredentials", new Dictionary<string, object>() {
                { "apiKey", true },
                { "secret", true },
            } },
            { "options", new Dictionary<string, object>() {
                { "fetchMarkets", new Dictionary<string, object>() {
                    { "types", new List<object>() {"spot", "swap"} },
                } },
                { "defaultType", "spot" },
            } },
            { "features", new Dictionary<string, object>() {
                { "default", new Dictionary<string, object>() {
                    { "fetchOHLCV", new Dictionary<string, object>() {
                        { "limit", 100 },
                    } },
                } },
            } },
            { "exceptions", new Dictionary<string, object>() {
                { "exact", new Dictionary<string, object>() {
                    { "77", typeof(InvalidOrder) },
                    { "400", typeof(BadRequest) },
                    { "401", typeof(AuthenticationError) },
                    { "403", typeof(NotSupported) },
                    { "404", typeof(NotSupported) },
                    { "429", typeof(RateLimitExceeded) },
                    { "500", typeof(ExchangeNotAvailable) },
                    { "503", typeof(ExchangeNotAvailable) },
                    { "3013", typeof(OrderNotFound) },
                    { "Order quantity is out of range", typeof(InvalidOrder) },
                    { "Invalid trade order type", typeof(InvalidOrder) },
                    { "Insufficient margin", typeof(InsufficientFunds) },
                    { "insufficient balance", typeof(InsufficientFunds) },
                    { "leverage must be in [1,8]", typeof(BadRequest) },
                    { "the request you sent is invalid", typeof(BadRequest) },
                } },
                { "broad", new Dictionary<string, object>() {
                    { "InvalidOrder", typeof(InvalidOrder) },
                } },
            } },
        });
    }

    /**
     * @method
     * @name zebpay#fetchStatus
     * @description the latest known information on the availability of the exchange API
     * @see [Spot] https://github.com/zebpay/zebpay-api-references/blob/main/spot/api-reference/public-endpoints.md#system-status
     * @see [Swap] https://github.com/zebpay/zebpay-api-references/blob/main/futures/api-reference/public-endpoints/system.md#get-system-status
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [status structure]{@link https://docs.ccxt.com/?id=exchange-status-structure}
     */
    public async override Task<object> fetchStatus(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object type = null;
        var typeparametersVariable = this.handleMarketTypeAndParams("fetchStatus", null, parameters);
        type = ((IList<object>)typeparametersVariable)[0];
        parameters = ((IList<object>)typeparametersVariable)[1];
        object isSpot = (isEqual(type, "spot"));
        object response = null;
        object data = new Dictionary<string, object>() {};
        if (isTrue(isSpot))
        {
            response = await this.publicSpotGetV2SystemStatus(parameters);
            data = response;
        } else
        {
            response = await this.publicSwapGetV1SystemStatus(parameters);
            data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        }
        //
        // {
        //     "statusDescription": "OK",
        //     "data":
        //      {
        //        "systemStatus": "ok"
        //       }
        //     "statusCode": 200,
        //     "customMessage": ["OK"]
        // }
        //
        object status = this.safeString2(data, "systemStatus", "status");
        return new Dictionary<string, object>() {
            { "status", status },
            { "updated", null },
            { "eta", null },
            { "url", null },
            { "info", response },
        };
    }

    /**
     * @method
     * @name zebpayfutures#fetchTime
     * @description fetches the current integer timestamp in milliseconds from the poloniexfutures server
     * @see [Spot] https://github.com/zebpay/zebpay-api-references/blob/main/spot/api-reference/public-endpoints.md#get-server-time
     * @see [Swap] https://github.com/zebpay/zebpay-api-references/blob/main/futures/api-reference/public-endpoints/system.md#get-system-time
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {int} the current integer timestamp in milliseconds from the poloniexfutures server
     */
    public async override Task<object> fetchTime(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object type = null;
        var typeparametersVariable = this.handleMarketTypeAndParams("fetchTime", null, parameters);
        type = ((IList<object>)typeparametersVariable)[0];
        parameters = ((IList<object>)typeparametersVariable)[1];
        object isSpot = (isEqual(type, "spot"));
        object response = null;
        object data = new Dictionary<string, object>() {};
        if (isTrue(isSpot))
        {
            response = await this.publicSpotGetV2SystemTime(parameters);
            data = response;
        } else
        {
            response = await this.publicSwapGetV1SystemTime(parameters);
            data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        }
        //
        // {
        //     "statusDescription": "OK",
        //     "data":
        //      {
        //        "timestamp": 1546837113087
        //      }
        //     "statusCode": 200,
        //     "customMessage": ["OK"]
        // }
        //
        object time = this.safeInteger(data, "timestamp");
        return time;
    }

    /**
     * @method
     * @name zebpay#fetchMarkets
     * @description retrieves data on all markets for zebpay
     * @see [Spot] https://github.com/zebpay/zebpay-api-references/blob/main/spot/api-reference/public-endpoints.md#get-trading-pairs
     * @see [Swap] https://github.com/zebpay/zebpay-api-references/blob/main/futures/api-reference/public-endpoints/market.md#fetch-markets
     * @param {object} [params] extra parameters specific to the exchange api endpoint
     * @returns {object[]} an array of objects representing market data
     */
    public async override Task<object> fetchMarkets(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object promisesUnresolved = new List<object>() {};
        object fetchMarketsOptions = this.safeDict(this.options, "fetchMarkets");
        object defaultMarkets = new List<object>() {"spot", "swap"};
        object types = this.safeList(fetchMarketsOptions, "types", defaultMarkets);
        for (object i = 0; isLessThan(i, getArrayLength(types)); postFixIncrement(ref i))
        {
            object type = getValue(types, i);
            if (isTrue(isEqual(type, "spot")))
            {
                ((IList<object>)promisesUnresolved).Add(this.fetchSpotMarkets(parameters));
            } else if (isTrue(isEqual(type, "swap")))
            {
                ((IList<object>)promisesUnresolved).Add(this.fetchSwapMarkets(parameters));
            } else
            {
                throw new ExchangeError ((string)add(add(add(this.id, " fetchMarkets() this.options fetchMarkets \""), type), "\" is not a supported market type")) ;
            }
        }
        object promises = await promiseAll(promisesUnresolved);
        object spotMarkets = this.safeList(promises, 0, new List<object>() {});
        object futureMarkets = this.safeList(promises, 1, new List<object>() {});
        return this.arrayConcat(spotMarkets, futureMarkets);
    }

    /**
     * @method
     * @name zebpay#fetchCurrencies
     * @description fetches all available currencies on an exchange
     * @see [Spot] https://github.com/zebpay/zebpay-api-references/blob/main/spot/api-reference/public-endpoints.md#get-coin-settings
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} an associative dictionary of currencies
     */
    public async override Task<object> fetchCurrencies(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object response = await this.publicSpotGetV2ExCurrencies(parameters);
        //
        //     {
        //             "data": [
        //                 {
        //                     "currency": "BTC",
        //                     "name": "BTC",
        //                     "fullName": "150",
        //                     "precision": "0.2",
        //                     "type": "fiat",
        //                     "isDebitEnabled": false,
        //                     "chains": [
        //                         {
        //                             "chainName": "Bitcoin",
        //                             "withdrawalMinSize": "0.000482",
        //                             "depositMinSize": "0.00000001",
        //                             "withdrawalFee": "0.00040000",
        //                             "isWithdrawEnabled": "true",
        //                             "isDepositEnabled": "true",
        //                             "contractAddress": "0x095418A82BC2439703b69fbE1210824F2247D77c",
        //                             "withdrawPrecision": "8",
        //                             "maxWithdraw": "2.43090487000000",
        //                             "maxDeposit": "100.00000000",
        //                             "needTag": "false",
        //                             "chainId": "bitcoin",
        //                             "AddressRegex": "^tb1[qpzry9x8gf2tvdw0s3jn54khce6mua7l]{39,59}|m[a-zA-Z0-9]{25,34}|n[a-zA-Z0-9]{25,34}|^2[a-zA-Z0-9]{25,34}$"
        //                          }
        //                     ]
        //                 }
        //             ]
        //     }
        //
        object rows = this.safeList(response, "data", new List<object>() {});
        object result = new Dictionary<string, object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(rows)); postFixIncrement(ref i))
        {
            object currency = getValue(rows, i);
            object currencyId = this.safeString(currency, "currency");
            object code = this.safeCurrencyCode(currencyId);
            object name = this.safeString(currency, "name");
            object precision = this.parseNumber(this.parsePrecision(this.safeString(currency, "precision")));
            object chains = this.safeList(currency, "chains", new List<object>() {});
            object networks = new Dictionary<string, object>() {};
            object minWithdrawFeeString = null;
            object minWithdrawString = null;
            object minDepositString = null;
            object deposit = false;
            object withdraw = false;
            for (object j = 0; isLessThan(j, getArrayLength(chains)); postFixIncrement(ref j))
            {
                object chain = getValue(chains, j);
                object networkId = this.safeString(chain, "chainId");
                object networkCode = this.networkIdToCode(networkId);
                object depositAllowed = isEqual(this.safeBool(chain, "isDepositEnabled"), true);
                deposit = ((bool) isTrue((depositAllowed))) ? depositAllowed : deposit;
                object withdrawAllowed = isEqual(this.safeBool(chain, "isWithdrawEnabled"), true);
                withdraw = ((bool) isTrue((withdrawAllowed))) ? withdrawAllowed : withdraw;
                object withdrawFeeString = this.safeString(chain, "withdrawalFee");
                if (isTrue(!isEqual(withdrawFeeString, null)))
                {
                    minWithdrawFeeString = ((bool) isTrue((isEqual(minWithdrawFeeString, null)))) ? withdrawFeeString : Precise.stringMin(withdrawFeeString, minWithdrawFeeString);
                }
                object minNetworkWithdrawString = this.safeString(chain, "withdrawalMinSize");
                if (isTrue(!isEqual(minNetworkWithdrawString, null)))
                {
                    minWithdrawString = ((bool) isTrue((isEqual(minWithdrawString, null)))) ? minNetworkWithdrawString : Precise.stringMin(minNetworkWithdrawString, minWithdrawString);
                }
                object minNetworkDepositString = this.safeString(chain, "depositMinSize");
                if (isTrue(!isEqual(minNetworkDepositString, null)))
                {
                    minDepositString = ((bool) isTrue((isEqual(minDepositString, null)))) ? minNetworkDepositString : Precise.stringMin(minNetworkDepositString, minDepositString);
                }
                ((IDictionary<string,object>)networks)[(string)networkCode] = new Dictionary<string, object>() {
                    { "info", chain },
                    { "id", networkId },
                    { "network", networkCode },
                    { "active", isTrue(depositAllowed) && isTrue(withdrawAllowed) },
                    { "deposit", depositAllowed },
                    { "withdraw", withdrawAllowed },
                    { "fee", this.parseNumber(withdrawFeeString) },
                    { "precision", precision },
                    { "limits", new Dictionary<string, object>() {
                        { "withdraw", new Dictionary<string, object>() {
                            { "min", this.parseNumber(minNetworkWithdrawString) },
                            { "max", null },
                        } },
                        { "deposit", new Dictionary<string, object>() {
                            { "min", this.parseNumber(minNetworkDepositString) },
                            { "max", null },
                        } },
                    } },
                };
            }
            ((IDictionary<string,object>)result)[(string)code] = this.safeCurrencyStructure(new Dictionary<string, object>() {
                { "info", currency },
                { "code", code },
                { "id", currencyId },
                { "name", name },
                { "active", isTrue(deposit) && isTrue(withdraw) },
                { "deposit", deposit },
                { "withdraw", withdraw },
                { "fee", this.parseNumber(minWithdrawFeeString) },
                { "precision", precision },
                { "limits", new Dictionary<string, object>() {
                    { "amount", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                    { "withdraw", new Dictionary<string, object>() {
                        { "min", this.parseNumber(minWithdrawString) },
                        { "max", null },
                    } },
                    { "deposit", new Dictionary<string, object>() {
                        { "min", this.parseNumber(minDepositString) },
                        { "max", null },
                    } },
                } },
                { "networks", networks },
            });
        }
        return result;
    }

    /**
     * @method
     * @name zebpay#fetchTradingFee
     * @description fetch the trading fees for a market
     * @see [Spot] https://github.com/zebpay/zebpay-api-references/blob/main/spot/api-reference/private-endpoints.md#get-exchange-fee
     * @see [Swap] https://github.com/zebpay/zebpay-api-references/blob/main/futures/api-reference/public-endpoints/exchange.md#get-trade-fee-single-symbol
     * @param {string} symbol unified symbol of the market to fetch the order book for
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {object} [params.side] side to fetch trading fee
     * @returns {object} a [status structure]{@link https://docs.ccxt.com/?id=exchange-status-structure}
     */
    public async override Task<object> fetchTradingFee(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object response = null;
        object data = null;
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        if (isTrue(getValue(market, "spot")))
        {
            response = await this.privateSpotGetV2ExTradefee(this.extend(request, parameters));
            //
            // {
            //     "statusDescription": "Success",
            //     "data":
            //       {
            //         "symbol": "BTCINR",
            //         "takerFeeRate": "0.01",
            //         "makerFeeRate": "0.05",
            //         "percentage": true
            //       } ,
            //     "statusCode": 200,
            // }
            data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        } else
        {
            response = await this.publicSwapGetV1ExchangeTradefee(this.extend(request, parameters));
            //
            // {
            //     "statusDescription": "OK",
            //     "data":
            //     [
            //       {
            //         "symbol": "BTCINR",
            //         "takerFee": "0.01",
            //         "makerFee": "0.05"
            //       }
            //     ] ,
            //     "statusCode": 200,
            //     "customMessage": ["OK"]
            // }
            //
            object responseData = this.safeList(response, "data", new List<object>() {});
            data = this.safeDict(responseData, 0);
        }
        return this.parseTradingFee(data, market);
    }

    /**
     * @method
     * @name zebpay(futures)#fetchTradingFees
     * @description fetch the trading fees for multiple markets
     * @see [Swap] https://github.com/zebpay/zebpay-api-references/blob/main/futures/api-reference/public-endpoints/exchange.md#get-trade-fees-all-symbols
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [status structure]{@link https://docs.ccxt.com/?id=exchange-status-structure}
     */
    public async override Task<object> fetchTradingFees(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object type = null;
        var typeparametersVariable = this.handleMarketTypeAndParams("fetchTradingFees", null, parameters);
        type = ((IList<object>)typeparametersVariable)[0];
        parameters = ((IList<object>)typeparametersVariable)[1];
        object response = null;
        if (isTrue(isEqual(type, "spot")))
        {
            response = await this.publicSpotGetV2ExTradefees(parameters);
        } else
        {
            response = await this.publicSwapGetV1ExchangeTradefees(parameters);
        }
        //
        // {
        //     "statusDescription": "OK",
        //     "data": [
        //         {
        //             "symbol": "BTCINR",
        //             "takerFee": "0.01",
        //             "makerFee": "0.05"
        //         }
        //     ],
        //     "statusCode": 200,
        //     "customMessage": ["OK"]
        // }
        //
        object fees = this.safeList(response, "data", new List<object>() {});
        object result = new Dictionary<string, object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(fees)); postFixIncrement(ref i))
        {
            object fee = this.parseTradingFee(getValue(fees, i));
            object symbol = getValue(fee, "symbol");
            ((IDictionary<string,object>)result)[(string)symbol] = fee;
        }
        return result;
    }

    /**
     * @method
     * @name zebpay#fetchOrderBook
     * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
     * @see [Spot] https://github.com/zebpay/zebpay-api-references/blob/main/spot/api-reference/public-endpoints.md#get-order-book
     * @see [Swap] https://github.com/zebpay/zebpay-api-references/blob/main/futures/api-reference/public-endpoints/market.md#get-order-book
     * @param {string} symbol unified symbol of the market to fetch the order book for
     * @param {int} [limit] the maximum amount of order book entries to return
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/?id=order-book-structure} indexed by market symbols
     */
    public async override Task<object> fetchOrderBook(object symbol, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object response = null;
        if (isTrue(getValue(market, "spot")))
        {
            if (isTrue(!isEqual(limit, null)))
            {
                ((IDictionary<string,object>)request)["limit"] = limit;
            }
            //
            //       {
            //         "asks": [
            //                 [5000, 1000],           //Price, quantity
            //                 [6000, 1983]            //Price, quantity
            //         ],
            //         "bids": [
            //                 [3200, 800],            //Price, quantity
            //                 [3100, 100]             //Price, quantity
            //         ],
            //       }
            // }
            response = await this.publicSpotGetV2MarketOrderbook(this.extend(request, parameters));
        } else
        {
            response = await this.publicSwapGetV1MarketOrderBook(this.extend(request, parameters));
        }
        object bookData = this.safeDict(response, "data", new Dictionary<string, object>() {});
        object orderbook = this.parseOrderBook(bookData, getValue(market, "symbol"), null, "bids", "asks", 0, 1);
        ((IDictionary<string,object>)orderbook)["nonce"] = this.safeInteger(bookData, "nonce");
        return orderbook;
    }

    /**
     * @method
     * @name zebpay#fetchTicker
     * @description fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
     * @see [Spot] https://github.com/zebpay/zebpay-api-references/blob/main/spot/api-reference/public-endpoints.md#get-ticker
     * @see [Swap] https://github.com/zebpay/zebpay-api-references/blob/main/futures/api-reference/public-endpoints/market.md#get-24hr-ticker
     * @param {string} symbol unified symbol of the market to fetch the ticker for
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/?id=ticker-structure}
     */
    public async override Task<object> fetchTicker(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object response = null;
        if (isTrue(getValue(market, "spot")))
        {
            response = await this.publicSpotGetV2MarketTicker(this.extend(request, parameters));
        } else
        {
            response = await this.publicSwapGetV1MarketTicker24Hr(this.extend(request, parameters));
        }
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        return this.parseTicker(data, market);
    }

    /**
     * @method
     * @name zebpay#fetchTickers
     * @description fetches price tickers for multiple markets, statistical information calculated over the past 24 hours for each market
     * @see [Spot] https://github.com/zebpay/zebpay-api-references/blob/main/spot/api-reference/public-endpoints.md#get-all-tickers
     * @param {string[]|undefined} symbols unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/?id=ticker-structure}
     */
    public async override Task<object> fetchTickers(object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object type = null;
        var typeparametersVariable = this.handleMarketTypeAndParams("fetchTickers", null, parameters);
        type = ((IList<object>)typeparametersVariable)[0];
        parameters = ((IList<object>)typeparametersVariable)[1];
        if (isTrue(!isEqual(type, "spot")))
        {
            throw new NotSupported ((string)add(add(add(this.id, " fetchTickers() does not support "), type), " markets")) ;
        }
        await this.loadMarkets();
        symbols = this.marketSymbols(symbols);
        object response = await this.publicSpotGetV2MarketAllTickers(parameters);
        //
        //     [
        //        {
        //            "symbol": "BTC-INR",
        //            "bestBid": "4900000",
        //            "bestBidQty": "0.00014938",
        //            "bestAsk": "",
        //            "bestAskQty": "0",
        //            "priceChange": "-98134.56",
        //            "priceChangePercent": "-1.84",
        //            "high": "5433400",
        //            "low": "5333400",
        //            "vol": "0.0002",
        //            "volValue": "1066.68",
        //            "last": "5333400"
        //        }
        //     ]
        //
        object tickerList = this.safeList(response, "data", new List<object>() {});
        return this.parseTickers(tickerList, symbols);
    }

    /**
     * @method
     * @name zebpay#fetchOHLCV
     * @description fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
     * @see [Spot] https://github.com/zebpay/zebpay-api-references/blob/main/spot/api-reference/public-endpoints.md#get-klinescandlesticks
     * @see [Swap] https://github.com/zebpay/zebpay-api-references/blob/main/futures/api-reference/public-endpoints/market.md#-get-k-lines-ohlcv-data
     * @param {string} symbol unified symbol of the market to fetch OHLCV data for
     * @param {string} timeframe the length of time each candle represents
     * @param {int} [since] timestamp in ms of the earliest candle to fetch
     * @param {int} [limit] the maximum amount of candles to fetch
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {int} [params.endtime] the latest time in ms to fetch orders for
     * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
     */
    public async override Task<object> fetchOHLCV(object symbol, object timeframe = null, object since = null, object limit = null, object parameters = null)
    {
        timeframe ??= "1m";
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        if (isTrue(isEqual(limit, null)))
        {
            limit = 100; // default is 200
        }
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        if (isTrue(getValue(market, "spot")))
        {
            ((IDictionary<string,object>)request)["interval"] = this.safeString(this.timeframes, timeframe, timeframe);
        } else
        {
            ((IDictionary<string,object>)request)["interval"] = timeframe;
        }
        if (isTrue(isTrue(getValue(market, "contract")) && isTrue((!isEqual(limit, null)))))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        if (isTrue(!isEqual(since, null)))
        {
            if (isTrue(getValue(market, "spot")))
            {
                ((IDictionary<string,object>)request)["startTime"] = since;
            } else
            {
                ((IDictionary<string,object>)request)["since"] = since;
            }
        }
        object until = this.safeInteger2(parameters, "until", "endtime");
        if (isTrue(!isEqual(until, null)))
        {
            ((IDictionary<string,object>)request)["endTime"] = until;
            parameters = this.omit(parameters, new List<object>() {"endtime", "until"});
        }
        object response = null;
        if (isTrue(getValue(market, "spot")))
        {
            if (isTrue(isTrue(isEqual(until, null)) || isTrue(isEqual(since, null))))
            {
                throw new ArgumentsRequired ((string)add(this.id, " fetchOHLCV() requires a both a since and until/endtime parameter for spot markets")) ;
            }
            response = await this.publicSpotGetV2MarketKlines(this.extend(request, parameters));
        } else
        {
            response = await this.publicSwapPostV1MarketKlines(this.extend(request, parameters));
        }
        //
        //             [
        //                 [
        //                     "1670608800000",
        //                     "17071",
        //                     "17073",
        //                     "17027",
        //                     "17055.5",
        //                     "268611",
        //                     "15.74462667"
        //                 ],
        //                 [
        //                     "1670605200000",
        //                     "17071.5",
        //                     "17071.5",
        //                     "17061",
        //                     "17071",
        //                     "4177",
        //                     "0.24469757"
        //                 ],
        //                 [
        //                     "1670601600000",
        //                     "17086.5",
        //                     "17088",
        //                     "16978",
        //                     "17071.5",
        //                     "6356",
        //                     "0.37288112"
        //                 ]
        //             ]
        //
        object data = this.safeList(response, "data", new List<object>() {});
        return this.parseOHLCVs(data, market, timeframe, since, limit);
    }

    /**
     * @method
     * @name zebpay#fetchTrades
     * @description get the list of most recent trades for a particular symbol
     * @see [Spot] https://github.com/zebpay/zebpay-api-references/blob/main/spot/api-reference/public-endpoints.md#get-recent-trades
     * @see https://github.com/zebpay/zebpay-api-references/blob/main/futures/api-reference/public-endpoints/market.md#get-aggregate-trades
     * @param {string} symbol unified symbol of the market to fetch trades for
     * @param {int} [since] timestamp in ms of the earliest trade to fetch
     * @param {int} [limit] the maximum amount of trades to fetch
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/?id=public-trades}
     */
    public async override Task<object> fetchTrades(object symbol, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        if (isTrue(isTrue(getValue(market, "spot")) && isTrue(!isEqual(limit, null))))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        object response = null;
        if (isTrue(getValue(market, "spot")))
        {
            response = await this.publicSpotGetV2MarketTrades(this.extend(request, parameters));
        } else
        {
            response = await this.publicSwapGetV1MarketAggTrade(this.extend(request, parameters));
        }
        //
        //     [
        //         {
        //             "id" : "60014521",
        //             "price" : "23162.94",
        //             "qty" : "0.00009",
        //             "side" : "SELL",
        //             "time" : 1659684602042,
        //             "isBuyerMaker" : 1659684602036
        //         }
        //     ]
        //
        object data = this.safeList(response, "data", new List<object>() {});
        return this.parseTrades(data, market, since, limit);
    }

    /**
     * @method
     * @name zebpay#fetchMyTrades
     * @description get the list of most recent trades for a particular symbol
     * @see https://github.com/zebpay/zebpay-api-references/blob/main/futures/api-reference/private-endpoints/trade.md#-get-trade-history
     * @param {string} symbol unified symbol of the market to fetch trades for
     * @param {int} [since] timestamp in ms of the earliest trade to fetch
     * @param {int} [limit] the maximum amount of trades to fetch
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/?id=public-trades}
     */
    public async override Task<object> fetchMyTrades(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
        }
        object type = null;
        var typeparametersVariable = this.handleMarketTypeAndParams("fetchMyTrades", market, parameters);
        type = ((IList<object>)typeparametersVariable)[0];
        parameters = ((IList<object>)typeparametersVariable)[1];
        object response = null;
        if (isTrue(isEqual(type, "spot")))
        {
            throw new NotSupported ((string)add(this.id, " fetchMyTrades() does not support spot markets")) ;
        } else
        {
            response = await this.privateSwapGetV1TradeHistory(parameters);
        }
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        object items = this.safeList(data, "items", new List<object>() {});
        return this.parseTrades(items, market, since, limit);
    }

    /**
     * @method
     * @name zebpatspot#fetchOrderTrades
     * @description fetch all the trades made from a single order
     * @see [Spot] https://github.com/zebpay/zebpay-api-references/blob/main/spot/api-reference/private-endpoints.md#get-order-fills
     * @param {string} id order id
     * @param {string} symbol unified market symbol
     * @param {int} [since] the earliest time in ms to fetch trades for
     * @param {int} [limit] the maximum number of trades to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/?id=trade-structure}
     */
    public async override Task<object> fetchOrderTrades(object id, object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object type = null;
        var typeparametersVariable = this.handleMarketTypeAndParams("fetchOrderTrades", null, parameters);
        type = ((IList<object>)typeparametersVariable)[0];
        parameters = ((IList<object>)typeparametersVariable)[1];
        if (isTrue(!isEqual(type, "spot")))
        {
            throw new NotSupported ((string)add(add(add(this.id, " fetchOrderTrades() does not support "), type), " markets")) ;
        }
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {
            { "orderId", id },
        };
        object response = await this.privateSpotGetV2ExOrderFills(this.extend(request, parameters));
        //
        //         {
        //             "orderId": "456789",
        //             "symbol": "LINK_USDT",
        //             "origQty": "1.5",
        //             "orderId": "30249408733945856",
        //             "side": "BUY",
        //             "type": "LIMIT",
        //             "matchRole": "MAKER",
        //             "createTime": 1648200366864,
        //             "price": "3.1",
        //             "avgExecutedPrice": "2.3456"
        //             "openQty": "1",
        //             "filledQty": "0",
        //             "fees": "0.00145",
        //         }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        object trades = new List<object>() {data};
        return this.parseTrades(trades);
    }

    public override object parseTrade(object trade, object market = null)
    {
        //
        // fetchMyTrades
        //
        //     {
        //         "id": "32164924331503616",
        //         "symbol": "LINK_USDT",
        //         "accountType": "SPOT",
        //         "orderId": "32164923987566592",
        //         "side": "SELL",
        //         "type": "MARKET",
        //         "matchRole": "TAKER",
        //         "createTime": 1648635115525,
        //         "price": "11",
        //         "quantity": "0.5",
        //         "amount": "5.5",
        //         "feeCurrency": "USDT",
        //         "feeAmount": "0.007975",
        //         "pageId": "32164924331503616",
        //         "clientOrderId": "myOwnId-321"
        //     }
        //   {
        //     aggregateTradeId: '2659115835',
        //     symbol: 'ETHINR',
        //     price: '292848',
        //     quantity: '0.147',
        //     firstTradeId: '7018766077',
        //     lastTradeId: '7018766081',
        //     tradeTime: '1765381971447',
        //     isBuyerMarketMaker: true
        //   }
        //
        //
        object id = this.safeString2(trade, "id", "aggregateTradeId");
        object orderId = this.safeString2(trade, "id", "order");
        object timestamp = this.safeInteger2(trade, "timestamp", "tradeTime");
        object marketId = this.safeString(trade, "symbol");
        market = this.safeMarket(marketId, market, "_");
        object symbol = getValue(market, "symbol");
        object side = this.safeStringLower(trade, "side");
        object priceString = this.safeString(trade, "price");
        object amountString = this.safeString2(trade, "amount", "quantity");
        return this.safeTrade(new Dictionary<string, object>() {
            { "id", id },
            { "info", trade },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "symbol", symbol },
            { "order", orderId },
            { "type", this.safeStringLower(trade, "type") },
            { "side", side },
            { "takerOrMaker", null },
            { "price", priceString },
            { "amount", amountString },
            { "cost", this.safeString(trade, "cost") },
            { "fee", this.safeDict(trade, "fee") },
        }, market);
    }

    /**
     * @method
     * @name zebpay#fetchBalance
     * @description query for balance and get the amount of funds available for trading or funds locked in orders
     * @see [Spot] https://github.com/zebpay/zebpay-api-references/blob/main/spot/api-reference/private-endpoints.md#get-account-balance
     * @see [Swap] https://github.com/zebpay/zebpay-api-references/blob/main/futures/api-reference/private-endpoints/wallet.md#get-wallet-balance
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [balance structure]{@link https://docs.ccxt.com/?id=balance-structure}
     */
    public async override Task<object> fetchBalance(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object type = null;
        var typeparametersVariable = this.handleMarketTypeAndParams("fetchBalance", null, parameters);
        type = ((IList<object>)typeparametersVariable)[0];
        parameters = ((IList<object>)typeparametersVariable)[1];
        object isSpot = (isEqual(type, "spot"));
        object response = null;
        if (isTrue(isSpot))
        {
            response = await this.privateSpotGetV2AccountBalance(parameters);
        } else
        {
            response = await this.privateSwapGetV1WalletBalance(parameters);
        }
        //
        //     {
        //         "data": [
        //              {
        //                 "free": 200,
        //                 "used": 100,
        //                 "total": 300,
        //                 "currency": "INR"
        //              },
        //              {
        //                 "free": 0,
        //                 "used": 0,
        //                 "total": 0,
        //                 "currency": "USDT"
        //              }
        //         ]
        //     }
        //
        return this.parseBalance(response);
    }

    /**
     * @method
     * @name zebpay#createOrder
     * @description Create an order on the exchange
     * @see [Spot] https://github.com/zebpay/zebpay-api-references/blob/main/spot/api-reference/private-endpoints.md#place-new-order
     * @see [Swap] https://github.com/zebpay/zebpay-api-references/blob/main/futures/api-reference/private-endpoints/trade.md#--create-order
     * @param {string} symbol Unified CCXT market symbol
     * @param {string} type 'limit' or 'market'
     * @param {string} side 'buy' or 'sell'
     * @param {float} amount the amount of currency to trade
     * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
     * @param {object} [params]  extra parameters specific to the exchange API endpoint
     * @param {string} [params.formType] The price at which a trigger order is triggered at
     * @param {string} [params.marginAsset] The asset the order creates, default is INR.
     * @param {boolean} [params.takeProfit] Takeprofit flag for the order.
     * @param {boolean} [params.stopLoss] Stop loss flag for the order.
     * @param {string} [params.positionId] PositionId of the order.
     * @returns {object} an [order structure]{@link https://docs.ccxt.com/?id=order-structure}
     */
    public async override Task<object> createOrder(object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object upperCaseType = ((string)type).ToUpper();
        object takeProfitPrice = this.safeString(parameters, "takeProfitPrice");
        object stopLossPrice = this.safeString(parameters, "stopLossPrice");
        parameters = this.omit(parameters, new List<object>() {"marginAsset", "takeProfitPrice", "takeProfitPrice"});
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
            { "side", ((string)side).ToUpper() },
        };
        object response = null;
        if (isTrue(getValue(market, "spot")))
        {
            var requestparametersVariable = this.orderRequest(symbol, type, amount, request, price, parameters);
            request = ((IList<object>)requestparametersVariable)[0];
            parameters = ((IList<object>)requestparametersVariable)[1];
            response = await this.privateSpotPostV2ExOrders(this.extend(request, parameters));
        } else
        {
            object marginAsset = this.safeString(parameters, "marginAsset", "INR");
            object formType = this.safeStringUpper(parameters, "formType", "ORDER_FORM");
            ((IDictionary<string,object>)request)["formType"] = formType;
            ((IDictionary<string,object>)request)["amount"] = this.parseToNumeric(this.amountToPrecision(getValue(market, "id"), amount));
            ((IDictionary<string,object>)request)["marginAsset"] = marginAsset;
            object hasTP = !isEqual(takeProfitPrice, null);
            object hasSL = !isEqual(stopLossPrice, null);
            if (isTrue(isTrue(hasTP) || isTrue(hasSL)))
            {
                if (isTrue(hasTP))
                {
                    ((IDictionary<string,object>)request)["takeProfitPrice"] = this.parseToNumeric(this.priceToPrecision(symbol, takeProfitPrice));
                }
                if (isTrue(hasSL))
                {
                    ((IDictionary<string,object>)request)["stopLossPrice"] = this.parseToNumeric(this.priceToPrecision(symbol, stopLossPrice));
                }
                response = await this.privateSwapPostV1TradeOrderAddTPSL(this.extend(request, parameters));
            } else
            {
                ((IDictionary<string,object>)request)["type"] = upperCaseType;
                if (isTrue(isEqual(type, "limit")))
                {
                    if (isTrue(isEqual(price, null)))
                    {
                        throw new ArgumentsRequired ((string)add(this.id, " createOrder() requires a price argument for limit orders")) ;
                    }
                    ((IDictionary<string,object>)request)["price"] = this.parseToNumeric(this.priceToPrecision(symbol, price));
                }
                response = await this.privateSwapPostV1TradeOrder(this.extend(request, parameters));
            }
        }
        //
        //    {
        //        "data": {
        //            "clientOrderId": "619717484f1d010001510cde",
        //        },
        //    }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        return this.parseOrder(data, market);
    }

    public virtual object orderRequest(object symbol, object type, object amount, object request, object price = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object upperCaseType = ((string)type).ToUpper();
        object triggerPrice = this.safeString(parameters, "stopLossPrice", null);
        object quoteOrderQty = this.safeString2(parameters, "quoteOrderQty", "cost", null);
        object timeInForce = this.safeString(parameters, "timeInForce", "GTC");
        object clientOrderId = this.safeString(parameters, "clientOrderId", this.uuid());
        parameters = this.omit(parameters, new List<object>() {"stopLossPrice", "cost", "timeInForce", "clientOrderId"});
        ((IDictionary<string,object>)request)["type"] = upperCaseType;
        ((IDictionary<string,object>)request)["clientOrderId"] = clientOrderId;
        ((IDictionary<string,object>)request)["timeInForce"] = timeInForce;
        if (isTrue(isEqual(upperCaseType, "MARKET")))
        {
            if (isTrue(isEqual(quoteOrderQty, null)))
            {
                throw new ExchangeError ((string)add(this.id, " spot market orders require cost in params")) ;
            }
            ((IDictionary<string,object>)request)["quoteOrderAmount"] = this.costToPrecision(symbol, quoteOrderQty);
        } else
        {
            if (isTrue(!isEqual(triggerPrice, null)))
            {
                ((IDictionary<string,object>)request)["stopLossPrice"] = this.priceToPrecision(symbol, triggerPrice);
            }
            ((IDictionary<string,object>)request)["amount"] = this.amountToPrecision(symbol, amount);
            ((IDictionary<string,object>)request)["price"] = this.priceToPrecision(symbol, price);
        }
        return new List<object>() {request, parameters};
    }

    /**
     * @method
     * @name zebpay#cancelOrder
     * @description cancels an open order
     * @see [Spot] https://github.com/zebpay/zebpay-api-references/blob/main/spot/api-reference/private-endpoints.md#cancel-order
     * @see [Swap] https://github.com/zebpay/zebpay-api-references/blob/main/futures/api-reference/private-endpoints/trade.md#-cancel-order
     * @param {string} id order id
     * @param {string} symbol unified symbol of the market the order was made in
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {object} [params.timestamp] extra parameters specific to the exchange API endpoint
     * @returns {object} An [order structure]{@link https://docs.ccxt.com/?id=order-structure}
     */
    public async override Task<object> cancelOrder(object id, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object response = null;
        object request = new Dictionary<string, object>() {};
        if (isTrue(getValue(market, "spot")))
        {
            ((IDictionary<string,object>)request)["orderId"] = id;
            response = await this.privateSpotDeleteV2ExOrder(this.extend(request, parameters));
        } else
        {
            object clientOrderId = this.safeString(parameters, "clientOrderId");
            if (isTrue(isEqual(clientOrderId, null)))
            {
                throw new ArgumentsRequired ((string)add(this.id, " cancelOrder() requires a clientOrderId parameter for swap orders")) ;
            }
            ((IDictionary<string,object>)request)["clientOrderId"] = clientOrderId;
            ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
            response = await this.privateSwapDeleteV1TradeOrder(this.extend(request, parameters));
        }
        //
        //    {
        //        "data": {
        //            "clientOrderId": "619714b8b6353000014c505a",
        //            "status": "canceled"
        //        },
        //    }
        //
        return this.parseOrder(this.safeDict(response, "data"));
    }

    /**
     * @method
     * @name zebpay#cancelOrders
     * @description cancels all open orders
     * @see [Spot] https://github.com/zebpay/zebpay-api-references/blob/main/spot/api-reference/private-endpoints.md#cancel-all-orders
     * @param {string} symbol unified symbol of the market the order was made in
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {object} [params.timestamp] extra parameters specific to the exchange API endpoint
     * @returns {object} An [order structure]{@link https://docs.ccxt.com/?id=order-structure}
     */
    public async override Task<object> cancelAllOrders(object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object type = null;
        var typeparametersVariable = this.handleMarketTypeAndParams("cancelAllOrders", null, parameters);
        type = ((IList<object>)typeparametersVariable)[0];
        parameters = ((IList<object>)typeparametersVariable)[1];
        if (isTrue(!isEqual(type, "spot")))
        {
            throw new NotSupported ((string)add(add(add(this.id, " cancelAllOrders() does not support "), type), " markets")) ;
        }
        await this.loadMarkets();
        object response = await this.privateSpotDeleteV2ExOrdersCancelAll(parameters);
        //
        //    {
        //        "data": {
        //            "orderId": "12345",
        //            "symbol": 'BTC-INR
        //        },
        //    }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        object parsedOrder = this.parseOrder(data);
        return new List<object>() {parsedOrder};
    }

    /**
     * @method
     * @name zebpay#fetchOpenOrders
     * @description fetches information on multiple open orders made by the user
     * @see [Spot] https://github.com/zebpay/zebpay-api-references/blob/main/spot/api-reference/private-endpoints.md#get-orders
     * @see [Swap] https://github.com/zebpay/zebpay-api-references/blob/main/futures/api-reference/private-endpoints/trade.md#-get-open-orders
     * @param {string} symbol unified market symbol of the market orders were made in
     * @param {int} [since] the earliest time in ms to fetch orders for
     * @param {int} [limit] the maximum number of order structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/?id=order-structure}
     */
    public async override Task<object> fetchOpenOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object response = null;
        object orders = new List<object>() {};
        if (isTrue(getValue(market, "spot")))
        {
            ((IDictionary<string,object>)request)["currentPage"] = 1;
            if (isTrue(!isEqual(limit, null)))
            {
                ((IDictionary<string,object>)request)["pageSize"] = limit;
            }
            response = await this.privateSpotGetV2ExOrders(this.extend(request, parameters));
            object responseData = this.safeDict(response, "data", new Dictionary<string, object>() {});
            orders = this.safeList(responseData, "items", new List<object>() {});
        } else
        {
            if (isTrue(!isEqual(since, null)))
            {
                ((IDictionary<string,object>)request)["since"] = since;
            }
            if (isTrue(!isEqual(limit, null)))
            {
                ((IDictionary<string,object>)request)["limit"] = limit;
            }
            response = await this.privateSwapGetV1TradeOrderOpenOrders(this.extend(request, parameters));
            object responseData = this.safeDict(response, "data", new Dictionary<string, object>() {});
            orders = this.safeList(responseData, "data", new List<object>() {});
        }
        //
        //     {
        //         "data": {
        //             "nextTimeStamp": null,
        //             "totalCount": 100,
        //             "data": [
        //                 {
        //                     "clientOrderId": "64507d02921f1c0001ff6892-123-zeb",
        //                     "datetime": "2025-03-14T14:34:34.4567",
        //                     "timestamp": 1741962557553,
        //                     "status": "open",
        //                     "symbol": "BTCINR",
        //                     "type": "market",
        //                     "timeInForce": "GTC",
        //                     "side": "buy",
        //                     "price": 700000,
        //                     "amount": 0.002,
        //                     "filled": null,
        //                     "remaining": 0.002,
        //                     "trades": []
        //                 }
        //             ]
        //         }
        //     }
        //
        return this.parseOrders(orders, market, null, limit);
    }

    /**
     * @method
     * @name zebpay#fetchOrder
     * @description fetches information on an order made by the user
     * @see [Spot] https://github.com/zebpay/zebpay-api-references/blob/main/spot/api-reference/private-endpoints.md#get-order-details
     * @see [Swap] https://github.com/zebpay/zebpay-api-references/blob/main/futures/api-reference/private-endpoints/trade.md#-get-order-details
     * @param {string} id order id
     * @param {string} symbol unified symbol of the market the order was made in
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.clientOrderId] cancel order by client order id
     * @param {string} [params.timestamp] cancel order by client order id
     * @returns {object} An [order structure]{@link https://docs.ccxt.com/?id=order-structure}
     */
    public async override Task<object> fetchOrder(object id, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {};
        object response = null;
        if (isTrue(getValue(market, "spot")))
        {
            ((IDictionary<string,object>)request)["orderId"] = id;
            response = await this.privateSpotGetV2ExOrder(this.extend(request, parameters));
        } else
        {
            ((IDictionary<string,object>)request)["id"] = id;
            response = await this.privateSwapGetV1TradeOrder(this.extend(request, parameters));
        }
        //
        //     {
        //         "data": {
        //             "nextTimeStamp": null,
        //             "totalCount": 100,
        //             "data": [
        //                 {
        //                     "clientOrderId": "64507d02921f1c0001ff6892-123-zeb",
        //                     "datetime": "2025-03-14T14:34:34.4567",
        //                     "timestamp": 1741962557553,
        //                     "status": "open",
        //                     "symbol": "BTCINR",
        //                     "type": "market",
        //                     "timeInForce": "GTC",
        //                     "side": "buy",
        //                     "price": 700000,
        //                     "amount": 0.002,
        //                     "filled": null,
        //                     "remaining": 0.002,
        //                     "trades": []
        //                 }
        //             ]
        //         }
        //     }
        //
        object responseData = this.safeDict(response, "data");
        return this.parseOrder(responseData, market);
    }

    public override object parseOrder(object order, object market = null)
    {
        //
        //      {
        //          "clientOrderId": "64507d02921f1c0001ff6892-123-zeb",
        //          "datetime": "2025-03-14T14:34:34.4567",
        //          "timestamp": 1741962557553,
        //          "status": "open",
        //          "symbol": "BTCINR",
        //          "type": "market",
        //          "timeInForce": "GTC",
        //          "side": "buy",
        //          "price": 700000,
        //          "amount": 0.002,
        //          "filled": null,
        //          "remaining": 0.002,
        //          "trades": []
        //      }
        //
        object marketId = this.safeString(order, "symbol");
        market = this.safeMarket(marketId, market);
        object symbol = getValue(market, "symbol");
        object type = this.safeString(order, "type");
        object timestamp = this.safeNumber(order, "timestamp");
        object datetime = this.iso8601(timestamp);
        object price = this.safeString(order, "price");
        object side = this.safeString(order, "side");
        object amount = this.safeString(order, "amount");
        object clientOrderId = this.safeString(order, "clientOrderId");
        object timeInForce = this.safeString(order, "timeInForce");
        object status = this.safeStringLower(order, "status");
        object orderId = this.safeString(order, "orderId", null);
        object parsedOrder = this.safeOrder(new Dictionary<string, object>() {
            { "id", orderId },
            { "clientOrderId", clientOrderId },
            { "symbol", symbol },
            { "type", type },
            { "timeInForce", timeInForce },
            { "postOnly", null },
            { "reduceOnly", null },
            { "side", side },
            { "amount", amount },
            { "price", price },
            { "triggerPrice", null },
            { "cost", null },
            { "filled", null },
            { "remaining", null },
            { "timestamp", timestamp },
            { "datetime", datetime },
            { "fee", null },
            { "status", status },
            { "info", order },
            { "lastTradeTimestamp", null },
            { "lastUpdateTimestamp", null },
            { "average", null },
            { "trades", null },
        }, market);
        return parsedOrder;
    }

    /**
     * @method
     * @name zebpay#closePosition
     * @description closes open positions for a market
     * @see [Swap] https://github.com/zebpay/zebpay-api-references/blob/main/futures/api-reference/private-endpoints/trade.md#-close-position
     * @param {string} symbol Unified CCXT market symbol
     * @param {string} side not used by kucoinfutures closePositions
     * @param {object} [params] extra parameters specific to the okx api endpoint
     * @param {string} [params.positionId] client order id of the order
     * @returns {object[]} [A list of position structures]{@link https://docs.ccxt.com/?id=position-structure}
     */
    public async override Task<object> closePosition(object symbol, object side = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object response = await this.privateSwapPostV1TradePositionClose(this.extend(request, parameters));
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        return this.parseOrder(data, market);
    }

    /**
     * @method
     * @name zebpay#fetchLeverages
     * @description fetch the set leverage for all contract and margin markets
     * @see [Swap] https://github.com/zebpay/zebpay-api-references/blob/main/futures/api-reference/private-endpoints/trade.md#-get-all-user-leverages
     * @param {string[]} [symbols] a list of unified market symbols
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a list of [leverage structures]{@link https://docs.ccxt.com/?id=leverage-structure}
     */
    public async override Task<object> fetchLeverages(object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.privateSwapGetV1TradeUserLeverages(parameters);
        //
        //     {
        //         "leveragePreferences": [
        //             {
        //                 "symbol": "ETHINR",
        //                 "shortLeverage": 1,
        //                 "longLeverage": 10,
        //                 "marginMode": "isolated"
        //             },
        //         ]
        //     }
        //
        object leveragePreferences = this.safeList(response, "data", new List<object>() {});
        return this.parseLeverages(leveragePreferences, symbols, "symbol");
    }

    /**
     * @method
     * @name zebpay#fetchLeverage
     * @description fetch the set leverage for a market
     * @see [Swap] https://github.com/zebpay/zebpay-api-references/blob/main/futures/api-reference/private-endpoints/trade.md#get-user-leverage-single-symbol
     * @param {string} symbol unified market symbol
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [leverage structure]{@link https://docs.ccxt.com/?id=leverage-structure}
     */
    public async override Task<object> fetchLeverage(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", ((string)getValue(market, "id")).ToUpper() },
        };
        object response = await this.privateSwapGetV1TradeUserLeverage(this.extend(request, parameters));
        //
        //     {
        //         "data": { symbol: "ETHINR", longLeverage: 1, shortLeverage: 1, marginMode: "isolated" }
        //     }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        return this.parseLeverage(data, market);
    }

    /**
     * @method
     * @name zebpay#setLeverage
     * @description set the level of leverage for a market
     * @see [Swap] https://github.com/zebpay/zebpay-api-references/blob/main/futures/api-reference/private-endpoints/trade.md#-update-user-leverage
     * @param {float} leverage the rate of leverage
     * @param {string} symbol unified market symbol
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} response from the exchange
     */
    public async override Task<object> setLeverage(object leverage, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " setLeverage() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "leverage", leverage },
            { "symbol", getValue(market, "id") },
        };
        //
        // { data: { "symbol", "longLeverage": 10, "shortLeverage": 1, "marginMode": "isolated" }
        //
        object response = await this.privateSwapPostV1TradeUpdateUserLeverage(this.extend(request, parameters));
        return response;
    }

    /**
     * @method
     * @name zebpay#fetchPositions
     * @see [Swap] https://github.com/zebpay/zebpay-api-references/blob/main/futures/api-reference/private-endpoints/trade.md#--get-positions
     * @description Fetches current contract trading positions
     * @param {string[]} symbols List of unified symbols
     * @param {object} [params] Not used by krakenfutures
     * @returns Parsed exchange response for positions
     */
    public async override Task<object> fetchPositions(object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        if (isTrue(!isEqual(symbols, null)))
        {
            ((IDictionary<string,object>)request)["symbols"] = this.marketIds(symbols);
        }
        object response = await this.privateSwapGetV1TradePositions(this.extend(request, parameters));
        //
        //    {
        //        "data": [
        //            {
        //                "id": "31998678-6056-413f-9d0d-fc3678641650",
        //                "symbol": "ETHINR",
        //                "entryPrice": "0.7533",
        //                "datetime": "2022-03-03T22:51:16.566Z",
        //                "contractSize": "230"
        //            }
        //        ],
        //    }
        //
        object positions = this.safeList(response, "data", new List<object>() {});
        object result = this.parsePositions(positions);
        return this.filterByArrayPositions(result, "symbol", symbols, false);
    }

    /**
     * @method
     * @name zebpayfutures#addMargin
     * @description add margin
     * @see [Swap] https://github.com/zebpay/zebpay-api-references/blob/main/futures/api-reference/private-endpoints/trade.md#-add-margin-to-position
     * @param {string} symbol unified market symbol
     * @param {float} amount amount of margin to add
     * @param {object} [params] extra parameters specific to the exchange API endpoint.
     * @param {string} [params.positionId] PositionId of the order to add margin.
     * @param {string} [params.timestamp] Tiemstamp.
     * @returns {object} a [margin structure]{@link https://docs.ccxt.com/?id=margin-structure}
     */
    public async override Task<object> addMargin(object symbol, object amount, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
            { "amount", amount },
        };
        object response = await this.privateSwapPostV1TradeAddMargin(this.extend(request, parameters));
        //
        //    {
        //        "code": "200000",
        //        "data": {
        //            "symbol": "BTCINR",
        //            "type": "add",
        //            "amount": 1000,
        //            "code": "INR",
        //            "status": "ok"
        //        }
        //    }
        //
        //
        //    {
        //        "code":"200000",
        //        "msg":"Position does not exist"
        //    }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        return this.extend(this.parseMarginModification(data, market), new Dictionary<string, object>() {
            { "amount", amount },
            { "direction", "in" },
        });
    }

    /**
     * @method
     * @name zebpayfutures#reduceMargin
     * @description add margin
     * @see [Swap] https://github.com/zebpay/zebpay-api-references/blob/main/futures/api-reference/private-endpoints/trade.md#-reduce-margin-from-position
     * @param {string} symbol unified market symbol.
     * @param {float} amount amount of margin to add.
     * @param {object} [params] extra parameters specific to the exchange API endpoint.
     * @param {string} [params.positionId] PositionId of the order to add margin.
     * @param {string} [params.timestamp] Tiemstamp.
     * @returns {object} a [margin structure]{@link https://docs.ccxt.com/?id=margin-structure}
     */
    public async override Task<object> reduceMargin(object symbol, object amount, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
            { "amount", amount },
        };
        object response = await this.privateSwapPostV1TradeReduceMargin(this.extend(request, parameters));
        //
        //    {
        //        "code": "200000",
        //        "data": {
        //            "symbol": "BTCINR",
        //            "type": "reduce",
        //            "amount": 1000,
        //            "code": "INR",
        //            "status": "ok"
        //        }
        //    }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        return this.extend(this.parseMarginModification(data, market), new Dictionary<string, object>() {
            { "amount", amount },
            { "direction", "out" },
        });
    }

    public async virtual Task<object> fetchSpotMarkets(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object response = await this.publicSpotGetV2ExExchangeInfo(parameters);
        //
        //    {
        //        "data": {
        //            "symbol": "ETH-INR",
        //            "name": "ETH-INR",
        //            "baseCurrency": "ETH",
        //            "quoteCurrency": "INR",
        //            "feeCurrency": "INR",
        //            "baseMinSize": "",
        //            "quoteMinSize": "100",
        //            "baseMaxSize": "",
        //            "quoteMaxSize": "2000",
        //            "baseIncrement": "0.00001"
        //            "quoteIncrement": "0.00001",
        //            "enableTrading": true
        //        }
        //    }
        //
        object result = new List<object>() {};
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        object markets = this.safeList(data, "symbols", new List<object>() {});
        for (object i = 0; isLessThan(i, getArrayLength(markets)); postFixIncrement(ref i))
        {
            object market = getValue(markets, i);
            object id = this.safeString(market, "symbol");
            object baseId = this.safeString(market, "baseAsset");
            object quoteId = this.safeString(market, "quoteAsset");
            object bs = this.safeCurrencyCode(baseId);
            object quote = this.safeCurrencyCode(quoteId);
            object symbol = add(add(bs, "/"), quote);
            ((IList<object>)result).Add(new Dictionary<string, object>() {
                { "id", id },
                { "symbol", symbol },
                { "base", bs },
                { "quote", quote },
                { "baseId", baseId },
                { "quoteId", quoteId },
                { "type", "spot" },
                { "spot", true },
                { "swap", false },
                { "margin", false },
                { "future", false },
                { "option", false },
                { "active", null },
                { "contract", null },
                { "taker", this.safeNumber(market, "takerFee") },
                { "maker", this.safeNumber(market, "makerFee") },
                { "strike", null },
                { "optionType", null },
                { "precision", new Dictionary<string, object>() {
                    { "amount", this.safeNumber(market, "lotSz") },
                    { "price", this.safeNumber(market, "tickSz") },
                } },
                { "limits", new Dictionary<string, object>() {
                    { "amount", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                    { "price", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                    { "cost", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                } },
                { "info", market },
            });
        }
        return result;
    }

    public async virtual Task<object> fetchSwapMarkets(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object response = await this.publicSwapGetV1MarketMarkets(parameters);
        //
        //    {
        //        "data": {
        //            "symbol": "ETHUSDT",
        //            "status": "TRADING",
        //            "mainMarginPercent": "10",
        //            "baseAsset": "ETH",
        //            "quoteAsset": "USDT",
        //            "pricePrecision": 1,
        //            "quantityPrecision": 0.05,
        //            "baseAssetPrecision": 0,
        //            "quotePrecision": 0,
        //            "orderType": ["LIMIT", "MARKET" ]
        //            "timeInForce": ["GTC"],
        //            "makerFee": "0.01",
        //            "takerFee": "0.01",
        //            "minLeverage": "1",
        //            "maxLeverage": "20"
        //            "tickSz": "0.1",
        //            "lotSz": "0.1"
        //        }
        //    }
        //
        object result = new List<object>() {};
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        object markets = this.safeList(data, "symbols", new List<object>() {});
        for (object i = 0; isLessThan(i, getArrayLength(markets)); postFixIncrement(ref i))
        {
            object market = getValue(markets, i);
            object id = this.safeString(market, "symbol");
            object baseId = this.safeString(market, "baseAsset");
            object quoteId = this.safeString(market, "quoteAsset");
            object bs = this.safeCurrencyCode(baseId);
            object quote = this.safeCurrencyCode(quoteId);
            object settle = this.safeCurrencyCode(quoteId);
            object status = this.safeString(market, "status");
            object symbol = add(add(bs, "/"), quote);
            ((IList<object>)result).Add(this.safeMarketStructure(new Dictionary<string, object>() {
                { "id", id },
                { "symbol", add(add(symbol, ":"), settle) },
                { "base", bs },
                { "quote", quote },
                { "baseId", baseId },
                { "quoteId", quoteId },
                { "spot", false },
                { "margin", false },
                { "swap", true },
                { "future", false },
                { "type", "swap" },
                { "option", false },
                { "active", (isEqual(status, "Open")) },
                { "contract", true },
                { "taker", this.safeNumber(market, "takerFee") },
                { "maker", this.safeNumber(market, "makerFee") },
                { "strike", null },
                { "optionType", null },
                { "precision", new Dictionary<string, object>() {
                    { "amount", this.safeNumber(market, "lotSz") },
                    { "price", this.safeNumber(market, "tickSz") },
                } },
                { "limits", new Dictionary<string, object>() {
                    { "leverage", new Dictionary<string, object>() {
                        { "min", this.safeNumber(market, "minLeverage") },
                        { "max", this.safeNumber(market, "maxLeverage") },
                    } },
                } },
                { "info", market },
            }));
        }
        return result;
    }

    public override object parseBalance(object response)
    {
        object result = new Dictionary<string, object>() {
            { "info", response },
            { "timestamp", null },
            { "datetime", null },
        };
        object currencyList = this.safeList(response, "data", new List<object>() {});
        for (object i = 0; isLessThan(i, getArrayLength(currencyList)); postFixIncrement(ref i))
        {
            object entry = getValue(currencyList, i);
            object account = this.account();
            ((IDictionary<string,object>)account)["total"] = this.safeString(entry, "total");
            ((IDictionary<string,object>)account)["free"] = this.safeString(entry, "free");
            ((IDictionary<string,object>)account)["used"] = this.safeString(entry, "used");
            object currencyId = this.safeString(entry, "currency");
            object code = this.safeCurrencyCode(currencyId);
            ((IDictionary<string,object>)result)[(string)code] = account;
        }
        return this.safeBalance(result);
    }

    public override object parsePosition(object position, object market = null)
    {
        //
        // isolated
        //    {
        //        "id":"long",
        //        "symbol":"pf_ftmusd",
        //        "entryPrice":"0.4921",
        //        "datetime":"2023-02-22T11:37:16.685Z",
        //        "contractSize":"1",
        //        "leverage":"1.0"
        //    }
        //
        object leverage = this.safeNumber(position, "leverage");
        object datetime = this.safeString(position, "datetime");
        object marketId = this.safeString(position, "symbol");
        market = this.safeMarket(marketId, market);
        return new Dictionary<string, object>() {
            { "info", position },
            { "symbol", marketId },
            { "timestamp", this.parse8601(datetime) },
            { "datetime", datetime },
            { "initialMargin", this.safeNumber(position, "initialMargin") },
            { "initialMarginPercentage", null },
            { "maintenanceMargin", null },
            { "maintenanceMarginPercentage", null },
            { "entryPrice", this.safeNumber(position, "entryPrice") },
            { "notional", this.safeNumber(position, "notional") },
            { "leverage", leverage },
            { "unrealizedPnl", null },
            { "contracts", this.safeNumber(position, "contracts") },
            { "contractSize", this.safeNumber(market, "contractSize") },
            { "marginRatio", null },
            { "liquidationPrice", this.safeNumber(position, "liquidationPrice") },
            { "markPrice", null },
            { "collateral", null },
            { "marginType", "isolated" },
            { "side", this.safeString(position, "side") },
            { "percentage", null },
        };
    }

    public override object parseLeverage(object leverage, object market = null)
    {
        object marketId = this.safeString(leverage, "symbol");
        object info = this.safeDict(leverage, "info");
        object leverageValue = this.safeInteger(leverage, "longLeverage");
        object leverageValueShort = this.safeInteger(leverage, "shortLeverage");
        object marginMode = this.safeString(leverage, "marginMode");
        return new Dictionary<string, object>() {
            { "info", info },
            { "symbol", marketId },
            { "marginMode", marginMode },
            { "longLeverage", leverageValue },
            { "shortLeverage", leverageValueShort },
        };
    }

    public virtual object parseTradingFee(object fee, object market = null)
    {
        object marketId = this.safeString(fee, "symbol");
        object symbol = this.safeSymbol(marketId, market);
        return new Dictionary<string, object>() {
            { "info", fee },
            { "symbol", symbol },
            { "maker", this.safeNumber2(fee, "makerFeeRate", "makerFee") },
            { "taker", this.safeNumber2(fee, "takerFeeRate", "takerFee") },
            { "percentage", null },
            { "tierBased", null },
        };
    }

    public override object parseTicker(object ticker, object market = null)
    {
        //
        //     [
        //        {
        //            "symbol": "BTC-INR",
        //            "bestBid": "4900000",
        //            "bestBidQty": "0.00014938",
        //            "bestAsk": "",
        //            "bestAskQty": "0",
        //            "priceChange": "-98134.56",
        //            "priceChangePercent": "-1.84",
        //            "high": "5433400",
        //            "low": "5333400",
        //            "vol": "0.0002",
        //            "volValue": "1066.68",
        //            "last": "5333400"
        //        }
        //     ]
        //
        object timestamp = this.safeInteger2(ticker, "timestamp", "ts", null);
        object marketId = this.safeString(ticker, "symbol");
        market = this.safeMarket(marketId);
        object close = this.safeString(ticker, "close", null);
        object last = this.safeString(ticker, "last", null);
        object percentage = this.safeString(ticker, "percentage");
        object bidVolume = this.safeString(ticker, "bidVolume");
        object askVolume = this.safeString(ticker, "askVolume");
        return this.safeTicker(new Dictionary<string, object>() {
            { "id", marketId },
            { "symbol", getValue(market, "symbol") },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "high", this.safeString(ticker, "high") },
            { "low", this.safeString(ticker, "low") },
            { "bid", this.safeString(ticker, "bid") },
            { "bidVolume", bidVolume },
            { "ask", this.safeString(ticker, "ask") },
            { "askVolume", askVolume },
            { "vwap", null },
            { "open", null },
            { "close", close },
            { "last", last },
            { "previousClose", this.safeString(ticker, "previousClose") },
            { "change", this.safeString(ticker, "change") },
            { "percentage", percentage },
            { "average", this.safeString(ticker, "average") },
            { "baseVolume", this.safeString(ticker, "baseVolume") },
            { "quoteVolume", this.safeString(ticker, "quoteVolume") },
            { "markPrice", null },
            { "info", ticker },
        }, market);
    }

    public override object parseMarginModification(object info, object market = null)
    {
        //
        //    {
        //         "symbol": "BTCINR",
        //         "type": "reduce",
        //         "amount": 1000,
        //         "code": "INR",
        //         "status": "ok"
        //    }
        //
        object timestamp = this.milliseconds();
        return new Dictionary<string, object>() {
            { "info", info },
            { "symbol", getValue(market, "id") },
            { "type", null },
            { "marginMode", null },
            { "amount", this.safeNumber(info, "amount") },
            { "total", null },
            { "code", this.safeString(info, "code") },
            { "status", this.safeString(info, "status") },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
        };
    }

    public override object sign(object path, object api = null, object method = null, object parameters = null, object headers = null, object body = null)
    {
        api ??= "public";
        method ??= "GET";
        parameters ??= new Dictionary<string, object>();
        parameters = this.omit(parameters, "defaultType");
        object isV1 = isGreaterThan(getIndexOf(path, "v1/"), -1);
        object marketType = ((bool) isTrue(isV1)) ? "swap" : "spot";
        object url = getValue(getValue(this.urls, "api"), marketType);
        object tail = add("/api/", this.implodeParams(path, parameters));
        url = add(url, tail);
        object timestamp = ((object)this.milliseconds()).ToString();
        object signature = "";
        object query = this.omit(parameters, this.extractParams(path));
        object queryLength = getArrayLength(new List<object>(((IDictionary<string,object>)query).Keys));
        object access = this.safeString(api, 0, "public");
        if (isTrue(isEqual(access, "public")))
        {
            if (isTrue(isTrue(isEqual(method, "GET")) || isTrue(isEqual(method, "DELETE"))))
            {
                if (isTrue(queryLength))
                {
                    url = add(url, add("?", this.urlencode(query)));
                }
            } else
            {
                body = json(parameters);
                headers = new Dictionary<string, object>() {
                    { "Referrer", "ccxt" },
                    { "Content-Type", "application/json" },
                };
            }
        } else
        {
            this.checkRequiredCredentials();
            object isSpot = isEqual(marketType, "spot");
            ((IDictionary<string,object>)parameters)["timestamp"] = timestamp;
            if (isTrue(isTrue(isEqual(method, "GET")) || isTrue((isTrue(isEqual(method, "DELETE")) && isTrue(isSpot)))))
            {
                // For GET/DELETE: Append params to URL and sign the query string
                object queryString = this.urlencode(parameters);
                signature = this.hmac(this.encode(queryString), this.encode(this.secret), sha256, "hex");
                url = add(url, add("?", queryString));
            } else
            {
                // For POST/PUT: Convert body to JSON and sign the stringified payload
                body = this.json(parameters);
                signature = this.hmac(this.encode(body), this.encode(this.secret), sha256, "hex");
            }
            headers = new Dictionary<string, object>() {
                { "Referrer", "ccxt" },
                { "X-AUTH-APIKEY", this.apiKey },
                { "X-AUTH-SIGNATURE", signature },
            };
            ((IDictionary<string,object>)headers)["Content-Type"] = "application/json";
        }
        return new Dictionary<string, object>() {
            { "url", url },
            { "method", method },
            { "body", body },
            { "headers", headers },
        };
    }

    public override object handleErrors(object code, object reason, object url, object method, object headers, object body, object response, object requestHeaders, object requestBody)
    {
        if (!isTrue(response))
        {
            this.throwBroadlyMatchedException(getValue(this.exceptions, "broad"), body, body);
            return null;
        }
        //
        // bad
        //     { "code": "400100", "msg": "validation.createOrder.clientOidIsRequired" }
        // good
        //     { code: "200000", data: { ... }}
        // {"statusDescription":"Order quantity is out of range","data":{},"statusCode":400,"customMessage":["Order quantity is out of range"]}
        //
        object errorCode = this.safeString2(response, "code", "statusCode");
        object message = this.safeString2(response, "msg", "statusDescription");
        object feedback = add(add(this.id, " "), message);
        this.throwBroadlyMatchedException(getValue(this.exceptions, "broad"), message, feedback);
        this.throwExactlyMatchedException(getValue(this.exceptions, "exact"), message, feedback);
        this.throwExactlyMatchedException(getValue(this.exceptions, "exact"), errorCode, feedback);
        return null;
    }
}
