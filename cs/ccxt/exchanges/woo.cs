namespace ccxt;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

public partial class woo : Exchange
{
    public override object describe()
    {
        return this.deepExtend(base.describe(), new Dictionary<string, object>() {
            { "id", "woo" },
            { "name", "WOO X" },
            { "countries", new List<object>() {"KY"} },
            { "rateLimit", 100 },
            { "version", "v1" },
            { "certified", true },
            { "pro", true },
            { "hostname", "woo.org" },
            { "has", new Dictionary<string, object>() {
                { "CORS", null },
                { "spot", true },
                { "margin", true },
                { "swap", true },
                { "future", false },
                { "option", false },
                { "addMargin", false },
                { "cancelAllOrders", true },
                { "cancelAllOrdersAfter", true },
                { "cancelOrder", true },
                { "cancelWithdraw", false },
                { "closeAllPositions", false },
                { "closePosition", false },
                { "createConvertTrade", true },
                { "createDepositAddress", false },
                { "createMarketBuyOrderWithCost", true },
                { "createMarketOrder", false },
                { "createMarketOrderWithCost", false },
                { "createMarketSellOrderWithCost", false },
                { "createOrder", true },
                { "createOrderWithTakeProfitAndStopLoss", true },
                { "createReduceOnlyOrder", true },
                { "createStopLimitOrder", false },
                { "createStopLossOrder", true },
                { "createStopMarketOrder", false },
                { "createStopOrder", false },
                { "createTakeProfitOrder", true },
                { "createTrailingAmountOrder", true },
                { "createTrailingPercentOrder", true },
                { "createTriggerOrder", true },
                { "fetchAccounts", true },
                { "fetchBalance", true },
                { "fetchCanceledOrders", false },
                { "fetchClosedOrder", false },
                { "fetchClosedOrders", true },
                { "fetchConvertCurrencies", true },
                { "fetchConvertQuote", true },
                { "fetchConvertTrade", true },
                { "fetchConvertTradeHistory", true },
                { "fetchCurrencies", true },
                { "fetchDepositAddress", true },
                { "fetchDeposits", true },
                { "fetchDepositsWithdrawals", true },
                { "fetchFundingHistory", true },
                { "fetchFundingRate", true },
                { "fetchFundingRateHistory", true },
                { "fetchFundingRates", true },
                { "fetchIndexOHLCV", false },
                { "fetchLedger", true },
                { "fetchLeverage", true },
                { "fetchMarginAdjustmentHistory", false },
                { "fetchMarginMode", false },
                { "fetchMarkets", true },
                { "fetchMarkOHLCV", false },
                { "fetchMyTrades", true },
                { "fetchOHLCV", true },
                { "fetchOpenInterestHistory", false },
                { "fetchOpenOrder", false },
                { "fetchOpenOrders", true },
                { "fetchOrder", true },
                { "fetchOrderBook", true },
                { "fetchOrders", true },
                { "fetchOrderTrades", true },
                { "fetchPosition", true },
                { "fetchPositionHistory", false },
                { "fetchPositionMode", false },
                { "fetchPositions", true },
                { "fetchPositionsHistory", false },
                { "fetchPremiumIndexOHLCV", false },
                { "fetchStatus", true },
                { "fetchTicker", false },
                { "fetchTickers", false },
                { "fetchTime", true },
                { "fetchTrades", true },
                { "fetchTradingFee", false },
                { "fetchTradingFees", true },
                { "fetchTransactions", "emulated" },
                { "fetchTransfers", true },
                { "fetchWithdrawals", true },
                { "reduceMargin", false },
                { "setLeverage", true },
                { "setMargin", false },
                { "setPositionMode", true },
                { "transfer", true },
                { "withdraw", true },
            } },
            { "timeframes", new Dictionary<string, object>() {
                { "1m", "1m" },
                { "5m", "5m" },
                { "15m", "15m" },
                { "30m", "30m" },
                { "1h", "1h" },
                { "4h", "4h" },
                { "12h", "12h" },
                { "1d", "1d" },
                { "1w", "1w" },
                { "1M", "1mon" },
                { "1y", "1y" },
            } },
            { "urls", new Dictionary<string, object>() {
                { "logo", "https://user-images.githubusercontent.com/1294454/150730761-1a00e5e0-d28c-480f-9e65-089ce3e6ef3b.jpg" },
                { "api", new Dictionary<string, object>() {
                    { "pub", "https://api-pub.woo.org" },
                    { "public", "https://api.{hostname}" },
                    { "private", "https://api.{hostname}" },
                } },
                { "test", new Dictionary<string, object>() {
                    { "pub", "https://api-pub.staging.woo.org" },
                    { "public", "https://api.staging.woo.org" },
                    { "private", "https://api.staging.woo.org" },
                } },
                { "www", "https://woo.org/" },
                { "doc", new List<object>() {"https://docs.woo.org/"} },
                { "fees", new List<object>() {"https://support.woo.org/hc/en-001/articles/4404611795353--Trading-Fees"} },
                { "referral", new Dictionary<string, object>() {
                    { "url", "https://x.woo.org/register?ref=YWOWC96B" },
                    { "discount", 0.35 },
                } },
            } },
            { "api", new Dictionary<string, object>() {
                { "v1", new Dictionary<string, object>() {
                    { "pub", new Dictionary<string, object>() {
                        { "get", new Dictionary<string, object>() {
                            { "hist/kline", 10 },
                            { "hist/trades", 1 },
                        } },
                    } },
                    { "public", new Dictionary<string, object>() {
                        { "get", new Dictionary<string, object>() {
                            { "info", 1 },
                            { "info/{symbol}", 1 },
                            { "system_info", 1 },
                            { "market_trades", 1 },
                            { "token", 1 },
                            { "token_network", 1 },
                            { "funding_rates", 1 },
                            { "funding_rate/{symbol}", 1 },
                            { "funding_rate_history", 1 },
                            { "futures", 1 },
                            { "futures/{symbol}", 1 },
                            { "orderbook/{symbol}", 1 },
                            { "kline", 1 },
                        } },
                    } },
                    { "private", new Dictionary<string, object>() {
                        { "get", new Dictionary<string, object>() {
                            { "client/token", 1 },
                            { "order/{oid}", 1 },
                            { "client/order/{client_order_id}", 1 },
                            { "orders", 1 },
                            { "client/trade/{tid}", 1 },
                            { "order/{oid}/trades", 1 },
                            { "client/trades", 1 },
                            { "client/hist_trades", 1 },
                            { "staking/yield_history", 1 },
                            { "client/holding", 1 },
                            { "asset/deposit", 10 },
                            { "asset/history", 60 },
                            { "sub_account/all", 60 },
                            { "sub_account/assets", 60 },
                            { "sub_account/asset_detail", 60 },
                            { "sub_account/ip_restriction", 10 },
                            { "asset/main_sub_transfer_history", 30 },
                            { "token_interest", 60 },
                            { "token_interest/{token}", 60 },
                            { "interest/history", 60 },
                            { "interest/repay", 60 },
                            { "funding_fee/history", 30 },
                            { "positions", 3.33 },
                            { "position/{symbol}", 3.33 },
                            { "client/transaction_history", 60 },
                        } },
                        { "post", new Dictionary<string, object>() {
                            { "order", 5 },
                            { "order/cancel_all_after", 1 },
                            { "asset/main_sub_transfer", 30 },
                            { "asset/ltv", 30 },
                            { "asset/withdraw", 30 },
                            { "asset/internal_withdraw", 30 },
                            { "interest/repay", 60 },
                            { "client/account_mode", 120 },
                            { "client/position_mode", 5 },
                            { "client/leverage", 120 },
                        } },
                        { "delete", new Dictionary<string, object>() {
                            { "order", 1 },
                            { "client/order", 1 },
                            { "orders", 1 },
                            { "asset/withdraw", 120 },
                        } },
                    } },
                } },
                { "v2", new Dictionary<string, object>() {
                    { "private", new Dictionary<string, object>() {
                        { "get", new Dictionary<string, object>() {
                            { "client/holding", 1 },
                        } },
                    } },
                } },
                { "v3", new Dictionary<string, object>() {
                    { "public", new Dictionary<string, object>() {
                        { "get", new Dictionary<string, object>() {
                            { "insuranceFund", 3 },
                        } },
                    } },
                    { "private", new Dictionary<string, object>() {
                        { "get", new Dictionary<string, object>() {
                            { "algo/order/{oid}", 1 },
                            { "algo/orders", 1 },
                            { "balances", 1 },
                            { "accountinfo", 60 },
                            { "positions", 3.33 },
                            { "buypower", 1 },
                            { "referrals", 60 },
                            { "referral_rewards", 60 },
                            { "convert/exchangeInfo", 1 },
                            { "convert/assetInfo", 1 },
                            { "convert/rfq", 60 },
                            { "convert/trade", 1 },
                            { "convert/trades", 1 },
                        } },
                        { "post", new Dictionary<string, object>() {
                            { "algo/order", 5 },
                            { "convert/rft", 60 },
                        } },
                        { "put", new Dictionary<string, object>() {
                            { "order/{oid}", 2 },
                            { "order/client/{client_order_id}", 2 },
                            { "algo/order/{oid}", 2 },
                            { "algo/order/client/{client_order_id}", 2 },
                        } },
                        { "delete", new Dictionary<string, object>() {
                            { "algo/order/{order_id}", 1 },
                            { "algo/orders/pending", 1 },
                            { "algo/orders/pending/{symbol}", 1 },
                            { "orders/pending", 1 },
                        } },
                    } },
                } },
            } },
            { "fees", new Dictionary<string, object>() {
                { "trading", new Dictionary<string, object>() {
                    { "tierBased", true },
                    { "percentage", true },
                    { "maker", this.parseNumber("0.0002") },
                    { "taker", this.parseNumber("0.0005") },
                } },
            } },
            { "options", new Dictionary<string, object>() {
                { "sandboxMode", false },
                { "createMarketBuyOrderRequiresPrice", true },
                { "network-aliases-for-tokens", new Dictionary<string, object>() {
                    { "HT", "ERC20" },
                    { "OMG", "ERC20" },
                    { "UATOM", "ATOM" },
                    { "ZRX", "ZRX" },
                } },
                { "networks", new Dictionary<string, object>() {
                    { "TRX", "TRON" },
                    { "TRC20", "TRON" },
                    { "ERC20", "ETH" },
                    { "BEP20", "BSC" },
                } },
                { "defaultNetworkCodeForCurrencies", new Dictionary<string, object>() {} },
                { "transfer", new Dictionary<string, object>() {
                    { "fillResponseFromRequest", true },
                } },
                { "brokerId", "bc830de7-50f3-460b-9ee0-f430f83f9dad" },
            } },
            { "commonCurrencies", new Dictionary<string, object>() {} },
            { "exceptions", new Dictionary<string, object>() {
                { "exact", new Dictionary<string, object>() {
                    { "-1000", typeof(ExchangeError) },
                    { "-1001", typeof(AuthenticationError) },
                    { "-1002", typeof(AuthenticationError) },
                    { "-1003", typeof(RateLimitExceeded) },
                    { "-1004", typeof(BadRequest) },
                    { "-1005", typeof(BadRequest) },
                    { "-1006", typeof(BadRequest) },
                    { "-1007", typeof(BadRequest) },
                    { "-1008", typeof(InvalidOrder) },
                    { "-1009", typeof(BadRequest) },
                    { "-1012", typeof(BadRequest) },
                    { "-1101", typeof(InvalidOrder) },
                    { "-1102", typeof(InvalidOrder) },
                    { "-1103", typeof(InvalidOrder) },
                    { "-1104", typeof(InvalidOrder) },
                    { "-1105", typeof(InvalidOrder) },
                } },
                { "broad", new Dictionary<string, object>() {
                    { "Can not place", typeof(ExchangeError) },
                    { "maintenance", typeof(OnMaintenance) },
                    { "symbol must not be blank", typeof(BadRequest) },
                    { "The token is not supported", typeof(BadRequest) },
                    { "Your order and symbol are not valid or already canceled", typeof(BadRequest) },
                    { "Insufficient WOO. Please enable margin trading for leverage trading", typeof(BadRequest) },
                } },
            } },
            { "precisionMode", TICK_SIZE },
        });
    }

    public async override Task<object> fetchStatus(object parameters = null)
    {
        /**
        * @method
        * @name woo#fetchStatus
        * @description the latest known information on the availability of the exchange API
        * @see https://docs.woo.org/#get-system-maintenance-status-public
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [status structure]{@link https://docs.ccxt.com/#/?id=exchange-status-structure}
        */
        parameters ??= new Dictionary<string, object>();
        object response = await this.v1PublicGetSystemInfo(parameters);
        //
        //     {
        //         "success": true,
        //         "data": {
        //             "status": "0",
        //             "msg": "System is functioning properly."
        //         },
        //         "timestamp": "1709274106602"
        //     }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        object status = this.safeString(data, "status");
        if (isTrue(isEqual(status, null)))
        {
            status = "error";
        } else if (isTrue(isEqual(status, "0")))
        {
            status = "ok";
        } else
        {
            status = "maintenance";
        }
        return new Dictionary<string, object>() {
            { "status", status },
            { "updated", null },
            { "eta", null },
            { "url", null },
            { "info", response },
        };
    }

    public async override Task<object> fetchTime(object parameters = null)
    {
        /**
        * @method
        * @name woo#fetchTime
        * @description fetches the current integer timestamp in milliseconds from the exchange server
        * @see https://docs.woo.org/#get-system-maintenance-status-public
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {int} the current integer timestamp in milliseconds from the exchange server
        */
        parameters ??= new Dictionary<string, object>();
        object response = await this.v1PublicGetSystemInfo(parameters);
        //
        //     {
        //         "success": true,
        //         "data": {
        //             "status": "0",
        //             "msg": "System is functioning properly."
        //         },
        //         "timestamp": "1709274106602"
        //     }
        //
        return this.safeInteger(response, "timestamp");
    }

    public async override Task<object> fetchMarkets(object parameters = null)
    {
        /**
        * @method
        * @name woo#fetchMarkets
        * @description retrieves data on all markets for woo
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} an array of objects representing market data
        */
        parameters ??= new Dictionary<string, object>();
        object response = await this.v1PublicGetInfo(parameters);
        //
        // {
        //     "rows": [
        //         {
        //             "symbol": "SPOT_AAVE_USDT",
        //             "quote_min": 0,
        //             "quote_max": 100000,
        //             "quote_tick": 0.01,
        //             "base_min": 0.01,
        //             "base_max": 7284,
        //             "base_tick": 0.0001,
        //             "min_notional": 10,
        //             "price_range": 0.1,
        //             "created_time": "0",
        //             "updated_time": "1639107647.988",
        //             "is_stable": 0
        //         },
        //         ...
        //     "success": true
        // }
        //
        object data = this.safeList(response, "rows", new List<object>() {});
        return this.parseMarkets(data);
    }

    public override object parseMarket(object market)
    {
        object marketId = this.safeString(market, "symbol");
        object parts = ((string)marketId).Split(new [] {((string)"_")}, StringSplitOptions.None).ToList<object>();
        object first = this.safeString(parts, 0);
        object marketType = null;
        object spot = false;
        object swap = false;
        if (isTrue(isEqual(first, "SPOT")))
        {
            spot = true;
            marketType = "spot";
        } else if (isTrue(isEqual(first, "PERP")))
        {
            swap = true;
            marketType = "swap";
        }
        object baseId = this.safeString(parts, 1);
        object quoteId = this.safeString(parts, 2);
        object bs = this.safeCurrencyCode(baseId);
        object quote = this.safeCurrencyCode(quoteId);
        object settleId = null;
        object settle = null;
        object symbol = add(add(bs, "/"), quote);
        object contractSize = null;
        object linear = null;
        object margin = true;
        object contract = swap;
        if (isTrue(contract))
        {
            margin = false;
            settleId = this.safeString(parts, 2);
            settle = this.safeCurrencyCode(settleId);
            symbol = add(add(add(add(bs, "/"), quote), ":"), settle);
            contractSize = this.parseNumber("1");
            linear = true;
        }
        return new Dictionary<string, object>() {
            { "id", marketId },
            { "symbol", symbol },
            { "base", bs },
            { "quote", quote },
            { "settle", settle },
            { "baseId", baseId },
            { "quoteId", quoteId },
            { "settleId", settleId },
            { "type", marketType },
            { "spot", spot },
            { "margin", margin },
            { "swap", swap },
            { "future", false },
            { "option", false },
            { "active", null },
            { "contract", contract },
            { "linear", linear },
            { "inverse", null },
            { "contractSize", contractSize },
            { "expiry", null },
            { "expiryDatetime", null },
            { "strike", null },
            { "optionType", null },
            { "precision", new Dictionary<string, object>() {
                { "amount", this.safeNumber(market, "base_tick") },
                { "price", this.safeNumber(market, "quote_tick") },
            } },
            { "limits", new Dictionary<string, object>() {
                { "leverage", new Dictionary<string, object>() {
                    { "min", null },
                    { "max", null },
                } },
                { "amount", new Dictionary<string, object>() {
                    { "min", this.safeNumber(market, "base_min") },
                    { "max", this.safeNumber(market, "base_max") },
                } },
                { "price", new Dictionary<string, object>() {
                    { "min", this.safeNumber(market, "quote_min") },
                    { "max", this.safeNumber(market, "quote_max") },
                } },
                { "cost", new Dictionary<string, object>() {
                    { "min", this.safeNumber(market, "min_notional") },
                    { "max", null },
                } },
            } },
            { "created", this.safeTimestamp(market, "created_time") },
            { "info", market },
        };
    }

    public async override Task<object> fetchTrades(object symbol, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name woo#fetchTrades
        * @description get the list of most recent trades for a particular symbol
        * @param {string} symbol unified symbol of the market to fetch trades for
        * @param {int} [since] timestamp in ms of the earliest trade to fetch
        * @param {int} [limit] the maximum amount of trades to fetch
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        object response = await this.v1PublicGetMarketTrades(this.extend(request, parameters));
        //
        // {
        //     "success": true,
        //     "rows": [
        //         {
        //             "symbol": "SPOT_BTC_USDT",
        //             "side": "SELL",
        //             "executed_price": 46222.35,
        //             "executed_quantity": 0.0012,
        //             "executed_timestamp": "1641241162.329"
        //         },
        //         {
        //             "symbol": "SPOT_BTC_USDT",
        //             "side": "SELL",
        //             "executed_price": 46222.35,
        //             "executed_quantity": 0.0012,
        //             "executed_timestamp": "1641241162.329"
        //         },
        //         {
        //             "symbol": "SPOT_BTC_USDT",
        //             "side": "BUY",
        //             "executed_price": 46224.32,
        //             "executed_quantity": 0.00039,
        //             "executed_timestamp": "1641241162.287"
        //         },
        //         ...
        //      ]
        // }
        //
        object resultResponse = this.safeList(response, "rows", new List<object>() {});
        return this.parseTrades(resultResponse, market, since, limit);
    }

    public override object parseTrade(object trade, object market = null)
    {
        //
        // public/market_trades
        //
        //     {
        //         "symbol": "SPOT_BTC_USDT",
        //         "side": "SELL",
        //         "executed_price": 46222.35,
        //         "executed_quantity": 0.0012,
        //         "executed_timestamp": "1641241162.329"
        //     }
        //
        // fetchOrderTrades, fetchOrder
        //
        //     {
        //         "id": "99119876",
        //         "symbol": "SPOT_WOO_USDT",
        //         "fee": "0.0024",
        //         "side": "BUY",
        //         "executed_timestamp": "1641481113.084",
        //         "order_id": "87001234",
        //         "order_tag": "default", <-- this param only in "fetchOrderTrades"
        //         "executed_price": "1",
        //         "executed_quantity": "12",
        //         "fee_asset": "WOO",
        //         "is_maker": "1"
        //     }
        //
        object isFromFetchOrder = (inOp(trade, "id"));
        object timestamp = this.safeTimestamp(trade, "executed_timestamp");
        object marketId = this.safeString(trade, "symbol");
        market = this.safeMarket(marketId, market);
        object symbol = getValue(market, "symbol");
        object price = this.safeString(trade, "executed_price");
        object amount = this.safeString(trade, "executed_quantity");
        object order_id = this.safeString(trade, "order_id");
        object fee = this.parseTokenAndFeeTemp(trade, "fee_asset", "fee");
        object cost = Precise.stringMul(price, amount);
        object side = this.safeStringLower(trade, "side");
        object id = this.safeString(trade, "id");
        object takerOrMaker = null;
        if (isTrue(isFromFetchOrder))
        {
            object isMaker = isEqual(this.safeString(trade, "is_maker"), "1");
            takerOrMaker = ((bool) isTrue(isMaker)) ? "maker" : "taker";
        }
        return this.safeTrade(new Dictionary<string, object>() {
            { "id", id },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "symbol", symbol },
            { "side", side },
            { "price", price },
            { "amount", amount },
            { "cost", cost },
            { "order", order_id },
            { "takerOrMaker", takerOrMaker },
            { "type", null },
            { "fee", fee },
            { "info", trade },
        }, market);
    }

    public virtual object parseTokenAndFeeTemp(object item, object feeTokenKey, object feeAmountKey)
    {
        object feeCost = this.safeString(item, feeAmountKey);
        object fee = null;
        if (isTrue(!isEqual(feeCost, null)))
        {
            object feeCurrencyId = this.safeString(item, feeTokenKey);
            object feeCurrencyCode = this.safeCurrencyCode(feeCurrencyId);
            fee = new Dictionary<string, object>() {
                { "cost", feeCost },
                { "currency", feeCurrencyCode },
            };
        }
        return fee;
    }

    public async override Task<object> fetchTradingFees(object parameters = null)
    {
        /**
        * @method
        * @name woo#fetchTradingFees
        * @description fetch the trading fees for multiple markets
        * @see https://docs.woo.org/#get-account-information-new
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a dictionary of [fee structures]{@link https://docs.ccxt.com/#/?id=fee-structure} indexed by market symbols
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.v3PrivateGetAccountinfo(parameters);
        //
        //     {
        //         "success": true,
        //         "data": {
        //             "applicationId": "dsa",
        //             "account": "dsa",
        //             "alias": "haha",
        //             "accountMode": "MARGIN",
        //             "leverage": 1,
        //             "takerFeeRate": 1,
        //             "makerFeeRate": 1,
        //             "interestRate": 1,
        //             "futuresTakerFeeRate": 1,
        //             "futuresMakerFeeRate": 1,
        //             "otpauth": true,
        //             "marginRatio": 1,
        //             "openMarginRatio": 1,
        //             "initialMarginRatio": 1,
        //             "maintenanceMarginRatio": 1,
        //             "totalCollateral": 1,
        //             "freeCollateral": 1,
        //             "totalAccountValue": 1,
        //             "totalVaultValue": 1,
        //             "totalStakingValue": 1
        //         },
        //         "timestamp": 1673323685109
        //     }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        object maker = this.safeString(data, "makerFeeRate");
        object taker = this.safeString(data, "takerFeeRate");
        object result = new Dictionary<string, object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(this.symbols)); postFixIncrement(ref i))
        {
            object symbol = getValue(this.symbols, i);
            ((IDictionary<string,object>)result)[(string)symbol] = new Dictionary<string, object>() {
                { "info", response },
                { "symbol", symbol },
                { "maker", this.parseNumber(Precise.stringDiv(maker, "10000")) },
                { "taker", this.parseNumber(Precise.stringDiv(taker, "10000")) },
                { "percentage", true },
                { "tierBased", true },
            };
        }
        return result;
    }

    public async override Task<object> fetchCurrencies(object parameters = null)
    {
        /**
        * @method
        * @name woo#fetchCurrencies
        * @description fetches all available currencies on an exchange
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} an associative dictionary of currencies
        */
        parameters ??= new Dictionary<string, object>();
        object result = new Dictionary<string, object>() {};
        object tokenResponse = await this.v1PublicGetToken(parameters);
        //
        // {
        //     "rows": [
        //         {
        //             "token": "ETH_USDT",
        //             "fullname": "Tether",
        //             "decimals": 6,
        //             "balance_token": "USDT",
        //             "created_time": "0",
        //             "updated_time": "0"
        //         },
        //         {
        //             "token": "BSC_USDT",
        //             "fullname": "Tether",
        //             "decimals": 18,
        //             "balance_token": "USDT",
        //             "created_time": "0",
        //             "updated_time": "0"
        //         },
        //         {
        //             "token": "ZEC",
        //             "fullname": "ZCash",
        //             "decimals": 8,
        //             "balance_token": "ZEC",
        //             "created_time": "0",
        //             "updated_time": "0"
        //         },
        //         ...
        //     ],
        //     "success": true
        // }
        //
        // only make one request for currrencies...
        // const tokenNetworkResponse = await this.v1PublicGetTokenNetwork (params);
        //
        // {
        //     "rows": [
        //         {
        //             "protocol": "ERC20",
        //             "token": "USDT",
        //             "name": "Ethereum",
        //             "minimum_withdrawal": 30,
        //             "withdrawal_fee": 25,
        //             "allow_deposit": 1,
        //             "allow_withdraw": 1
        //         },
        //         {
        //             "protocol": "TRC20",
        //             "token": "USDT",
        //             "name": "Tron",
        //             "minimum_withdrawal": 30,
        //             "withdrawal_fee": 1,
        //             "allow_deposit": 1,
        //             "allow_withdraw": 1
        //         },
        //         ...
        //     ],
        //     "success": true
        // }
        //
        object tokenRows = this.safeList(tokenResponse, "rows", new List<object>() {});
        object networksByCurrencyId = this.groupBy(tokenRows, "balance_token");
        object currencyIds = new List<object>(((IDictionary<string,object>)networksByCurrencyId).Keys);
        for (object i = 0; isLessThan(i, getArrayLength(currencyIds)); postFixIncrement(ref i))
        {
            object currencyId = getValue(currencyIds, i);
            object networks = getValue(networksByCurrencyId, currencyId);
            object code = this.safeCurrencyCode(currencyId);
            object name = null;
            object minPrecision = null;
            object resultingNetworks = new Dictionary<string, object>() {};
            for (object j = 0; isLessThan(j, getArrayLength(networks)); postFixIncrement(ref j))
            {
                object network = getValue(networks, j);
                name = this.safeString(network, "fullname");
                object networkId = this.safeString(network, "token");
                object splitted = ((string)networkId).Split(new [] {((string)"_")}, StringSplitOptions.None).ToList<object>();
                object unifiedNetwork = getValue(splitted, 0);
                object precision = this.parsePrecision(this.safeString(network, "decimals"));
                if (isTrue(!isEqual(precision, null)))
                {
                    minPrecision = ((bool) isTrue((isEqual(minPrecision, null)))) ? precision : Precise.stringMin(precision, minPrecision);
                }
                ((IDictionary<string,object>)resultingNetworks)[(string)unifiedNetwork] = new Dictionary<string, object>() {
                    { "id", networkId },
                    { "network", unifiedNetwork },
                    { "limits", new Dictionary<string, object>() {
                        { "withdraw", new Dictionary<string, object>() {
                            { "min", null },
                            { "max", null },
                        } },
                        { "deposit", new Dictionary<string, object>() {
                            { "min", null },
                            { "max", null },
                        } },
                    } },
                    { "active", null },
                    { "deposit", null },
                    { "withdraw", null },
                    { "fee", null },
                    { "precision", this.parseNumber(precision) },
                    { "info", network },
                };
            }
            ((IDictionary<string,object>)result)[(string)code] = new Dictionary<string, object>() {
                { "id", currencyId },
                { "name", name },
                { "code", code },
                { "precision", this.parseNumber(minPrecision) },
                { "active", null },
                { "fee", null },
                { "networks", resultingNetworks },
                { "deposit", null },
                { "withdraw", null },
                { "limits", new Dictionary<string, object>() {
                    { "deposit", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                    { "withdraw", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                } },
                { "info", networks },
            };
        }
        return result;
    }

    public async override Task<object> createMarketBuyOrderWithCost(object symbol, object cost, object parameters = null)
    {
        /**
        * @method
        * @name woo#createMarketBuyOrderWithCost
        * @description create a market buy order by providing the symbol and cost
        * @see https://docs.woo.org/#send-order
        * @param {string} symbol unified symbol of the market to create an order in
        * @param {float} cost how much you want to trade in units of the quote currency
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        if (!isTrue(getValue(market, "spot")))
        {
            throw new NotSupported ((string)add(this.id, " createMarketBuyOrderWithCost() supports spot orders only")) ;
        }
        ((IDictionary<string,object>)parameters)["createMarketBuyOrderRequiresPrice"] = false;
        return await this.createOrder(symbol, "market", "buy", cost, null, parameters);
    }

    public async override Task<object> createTrailingAmountOrder(object symbol, object type, object side, object amount, object price = null, object trailingAmount = null, object trailingTriggerPrice = null, object parameters = null)
    {
        /**
        * @method
        * @name woo#createTrailingAmountOrder
        * @description create a trailing order by providing the symbol, type, side, amount, price and trailingAmount
        * @param {string} symbol unified symbol of the market to create an order in
        * @param {string} type 'market' or 'limit'
        * @param {string} side 'buy' or 'sell'
        * @param {float} amount how much you want to trade in units of the base currency, or number of contracts
        * @param {float} [price] the price for the order to be filled at, in units of the quote currency, ignored in market orders
        * @param {float} trailingAmount the quote amount to trail away from the current market price
        * @param {float} trailingTriggerPrice the price to activate a trailing order, default uses the price argument
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(trailingAmount, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " createTrailingAmountOrder() requires a trailingAmount argument")) ;
        }
        if (isTrue(isEqual(trailingTriggerPrice, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " createTrailingAmountOrder() requires a trailingTriggerPrice argument")) ;
        }
        ((IDictionary<string,object>)parameters)["trailingAmount"] = trailingAmount;
        ((IDictionary<string,object>)parameters)["trailingTriggerPrice"] = trailingTriggerPrice;
        return await this.createOrder(symbol, type, side, amount, price, parameters);
    }

    public async override Task<object> createTrailingPercentOrder(object symbol, object type, object side, object amount, object price = null, object trailingPercent = null, object trailingTriggerPrice = null, object parameters = null)
    {
        /**
        * @method
        * @name woo#createTrailingPercentOrder
        * @description create a trailing order by providing the symbol, type, side, amount, price and trailingPercent
        * @param {string} symbol unified symbol of the market to create an order in
        * @param {string} type 'market' or 'limit'
        * @param {string} side 'buy' or 'sell'
        * @param {float} amount how much you want to trade in units of the base currency, or number of contracts
        * @param {float} [price] the price for the order to be filled at, in units of the quote currency, ignored in market orders
        * @param {float} trailingPercent the percent to trail away from the current market price
        * @param {float} trailingTriggerPrice the price to activate a trailing order, default uses the price argument
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(trailingPercent, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " createTrailingPercentOrder() requires a trailingPercent argument")) ;
        }
        if (isTrue(isEqual(trailingTriggerPrice, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " createTrailingPercentOrder() requires a trailingTriggerPrice argument")) ;
        }
        ((IDictionary<string,object>)parameters)["trailingPercent"] = trailingPercent;
        ((IDictionary<string,object>)parameters)["trailingTriggerPrice"] = trailingTriggerPrice;
        return await this.createOrder(symbol, type, side, amount, price, parameters);
    }

    public async override Task<object> createOrder(object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        /**
        * @method
        * @name woo#createOrder
        * @description create a trade order
        * @see https://docs.woo.org/#send-order
        * @see https://docs.woo.org/#send-algo-order
        * @param {string} symbol unified symbol of the market to create an order in
        * @param {string} type 'market' or 'limit'
        * @param {string} side 'buy' or 'sell'
        * @param {float} amount how much of currency you want to trade in units of base currency
        * @param {float} [price] the price at which the order is to be fullfilled, in units of the quote currency, ignored in market orders
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {float} [params.triggerPrice] The price a trigger order is triggered at
        * @param {object} [params.takeProfit] *takeProfit object in params* containing the triggerPrice at which the attached take profit order will be triggered (perpetual swap markets only)
        * @param {float} [params.takeProfit.triggerPrice] take profit trigger price
        * @param {object} [params.stopLoss] *stopLoss object in params* containing the triggerPrice at which the attached stop loss order will be triggered (perpetual swap markets only)
        * @param {float} [params.stopLoss.triggerPrice] stop loss trigger price
        * @param {float} [params.algoType] 'STOP'or 'TRAILING_STOP' or 'OCO' or 'CLOSE_POSITION'
        * @param {float} [params.cost] *spot market buy only* the quote quantity that can be used as an alternative for the amount
        * @param {string} [params.trailingAmount] the quote amount to trail away from the current market price
        * @param {string} [params.trailingPercent] the percent to trail away from the current market price
        * @param {string} [params.trailingTriggerPrice] the price to trigger a trailing order, default uses the price argument
        * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        object reduceOnly = this.safeBool2(parameters, "reduceOnly", "reduce_only");
        parameters = this.omit(parameters, new List<object>() {"reduceOnly", "reduce_only"});
        object orderType = ((string)type).ToUpper();
        await this.loadMarkets();
        object market = this.market(symbol);
        object orderSide = ((string)side).ToUpper();
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
            { "side", orderSide },
        };
        object stopPrice = this.safeNumber2(parameters, "triggerPrice", "stopPrice");
        object stopLoss = this.safeValue(parameters, "stopLoss");
        object takeProfit = this.safeValue(parameters, "takeProfit");
        object algoType = this.safeString(parameters, "algoType");
        object trailingTriggerPrice = this.safeString2(parameters, "trailingTriggerPrice", "activatedPrice", this.numberToString(price));
        object trailingAmount = this.safeString2(parameters, "trailingAmount", "callbackValue");
        object trailingPercent = this.safeString2(parameters, "trailingPercent", "callbackRate");
        object isTrailingAmountOrder = !isEqual(trailingAmount, null);
        object isTrailingPercentOrder = !isEqual(trailingPercent, null);
        object isTrailing = isTrue(isTrailingAmountOrder) || isTrue(isTrailingPercentOrder);
        object isStop = isTrue(isTrue(isTrue(isTrue(isTrailing) || isTrue(!isEqual(stopPrice, null))) || isTrue(!isEqual(stopLoss, null))) || isTrue(!isEqual(takeProfit, null))) || isTrue((!isEqual(this.safeValue(parameters, "childOrders"), null)));
        object isMarket = isEqual(orderType, "MARKET");
        object timeInForce = this.safeStringLower(parameters, "timeInForce");
        object postOnly = this.isPostOnly(isMarket, null, parameters);
        object reduceOnlyKey = ((bool) isTrue(isStop)) ? "reduceOnly" : "reduce_only";
        object clientOrderIdKey = ((bool) isTrue(isStop)) ? "clientOrderId" : "client_order_id";
        object orderQtyKey = ((bool) isTrue(isStop)) ? "quantity" : "order_quantity";
        object priceKey = ((bool) isTrue(isStop)) ? "price" : "order_price";
        object typeKey = ((bool) isTrue(isStop)) ? "type" : "order_type";
        ((IDictionary<string,object>)request)[(string)typeKey] = orderType; // LIMIT/MARKET/IOC/FOK/POST_ONLY/ASK/BID
        if (!isTrue(isStop))
        {
            if (isTrue(postOnly))
            {
                ((IDictionary<string,object>)request)["order_type"] = "POST_ONLY";
            } else if (isTrue(isEqual(timeInForce, "fok")))
            {
                ((IDictionary<string,object>)request)["order_type"] = "FOK";
            } else if (isTrue(isEqual(timeInForce, "ioc")))
            {
                ((IDictionary<string,object>)request)["order_type"] = "IOC";
            }
        }
        if (isTrue(reduceOnly))
        {
            ((IDictionary<string,object>)request)[(string)reduceOnlyKey] = reduceOnly;
        }
        if (isTrue(!isEqual(price, null)))
        {
            ((IDictionary<string,object>)request)[(string)priceKey] = this.priceToPrecision(symbol, price);
        }
        if (isTrue(isTrue(isMarket) && !isTrue(isStop)))
        {
            // for market buy it requires the amount of quote currency to spend
            if (isTrue(isTrue(getValue(market, "spot")) && isTrue(isEqual(orderSide, "BUY"))))
            {
                object quoteAmount = null;
                object createMarketBuyOrderRequiresPrice = true;
                var createMarketBuyOrderRequiresPriceparametersVariable = this.handleOptionAndParams(parameters, "createOrder", "createMarketBuyOrderRequiresPrice", true);
                createMarketBuyOrderRequiresPrice = ((IList<object>)createMarketBuyOrderRequiresPriceparametersVariable)[0];
                parameters = ((IList<object>)createMarketBuyOrderRequiresPriceparametersVariable)[1];
                object cost = this.safeNumber2(parameters, "cost", "order_amount");
                parameters = this.omit(parameters, new List<object>() {"cost", "order_amount"});
                if (isTrue(!isEqual(cost, null)))
                {
                    quoteAmount = this.costToPrecision(symbol, cost);
                } else if (isTrue(createMarketBuyOrderRequiresPrice))
                {
                    if (isTrue(isEqual(price, null)))
                    {
                        throw new InvalidOrder ((string)add(this.id, " createOrder() requires the price argument for market buy orders to calculate the total cost to spend (amount * price), alternatively set the createMarketBuyOrderRequiresPrice option or param to false and pass the cost to spend (quote quantity) in the amount argument")) ;
                    } else
                    {
                        object amountString = this.numberToString(amount);
                        object priceString = this.numberToString(price);
                        object costRequest = Precise.stringMul(amountString, priceString);
                        quoteAmount = this.costToPrecision(symbol, costRequest);
                    }
                } else
                {
                    quoteAmount = this.costToPrecision(symbol, amount);
                }
                ((IDictionary<string,object>)request)["order_amount"] = quoteAmount;
            } else
            {
                ((IDictionary<string,object>)request)["order_quantity"] = this.amountToPrecision(symbol, amount);
            }
        } else if (isTrue(!isEqual(algoType, "POSITIONAL_TP_SL")))
        {
            ((IDictionary<string,object>)request)[(string)orderQtyKey] = this.amountToPrecision(symbol, amount);
        }
        object clientOrderId = this.safeStringN(parameters, new List<object>() {"clOrdID", "clientOrderId", "client_order_id"});
        if (isTrue(!isEqual(clientOrderId, null)))
        {
            ((IDictionary<string,object>)request)[(string)clientOrderIdKey] = clientOrderId;
        }
        if (isTrue(isTrailing))
        {
            if (isTrue(isEqual(trailingTriggerPrice, null)))
            {
                throw new ArgumentsRequired ((string)add(this.id, " createOrder() requires a trailingTriggerPrice parameter for trailing orders")) ;
            }
            ((IDictionary<string,object>)request)["activatedPrice"] = this.priceToPrecision(symbol, trailingTriggerPrice);
            ((IDictionary<string,object>)request)["algoType"] = "TRAILING_STOP";
            if (isTrue(isTrailingAmountOrder))
            {
                ((IDictionary<string,object>)request)["callbackValue"] = trailingAmount;
            } else if (isTrue(isTrailingPercentOrder))
            {
                object convertedTrailingPercent = Precise.stringDiv(trailingPercent, "100");
                ((IDictionary<string,object>)request)["callbackRate"] = convertedTrailingPercent;
            }
        } else if (isTrue(!isEqual(stopPrice, null)))
        {
            if (isTrue(!isEqual(algoType, "TRAILING_STOP")))
            {
                ((IDictionary<string,object>)request)["triggerPrice"] = this.priceToPrecision(symbol, stopPrice);
                ((IDictionary<string,object>)request)["algoType"] = "STOP";
            }
        } else if (isTrue(isTrue((!isEqual(stopLoss, null))) || isTrue((!isEqual(takeProfit, null)))))
        {
            ((IDictionary<string,object>)request)["algoType"] = "BRACKET";
            object outterOrder = new Dictionary<string, object>() {
                { "symbol", getValue(market, "id") },
                { "reduceOnly", false },
                { "algoType", "POSITIONAL_TP_SL" },
                { "childOrders", new List<object>() {} },
            };
            object closeSide = ((bool) isTrue((isEqual(orderSide, "BUY")))) ? "SELL" : "BUY";
            if (isTrue(!isEqual(stopLoss, null)))
            {
                object stopLossPrice = this.safeNumber2(stopLoss, "triggerPrice", "price", stopLoss);
                object stopLossOrder = new Dictionary<string, object>() {
                    { "side", closeSide },
                    { "algoType", "STOP_LOSS" },
                    { "triggerPrice", this.priceToPrecision(symbol, stopLossPrice) },
                    { "type", "CLOSE_POSITION" },
                    { "reduceOnly", true },
                };
                ((IList<object>)getValue(outterOrder, "childOrders")).Add(stopLossOrder);
            }
            if (isTrue(!isEqual(takeProfit, null)))
            {
                object takeProfitPrice = this.safeNumber2(takeProfit, "triggerPrice", "price", takeProfit);
                object takeProfitOrder = new Dictionary<string, object>() {
                    { "side", closeSide },
                    { "algoType", "TAKE_PROFIT" },
                    { "triggerPrice", this.priceToPrecision(symbol, takeProfitPrice) },
                    { "type", "CLOSE_POSITION" },
                    { "reduceOnly", true },
                };
                ((IList<object>)getValue(outterOrder, "childOrders")).Add(takeProfitOrder);
            }
            ((IDictionary<string,object>)request)["childOrders"] = new List<object>() {outterOrder};
        }
        parameters = this.omit(parameters, new List<object>() {"clOrdID", "clientOrderId", "client_order_id", "postOnly", "timeInForce", "stopPrice", "triggerPrice", "stopLoss", "takeProfit", "trailingPercent", "trailingAmount", "trailingTriggerPrice"});
        object response = null;
        if (isTrue(isStop))
        {
            response = await this.v3PrivatePostAlgoOrder(this.extend(request, parameters));
        } else
        {
            response = await this.v1PrivatePostOrder(this.extend(request, parameters));
        }
        // {
        //     "success": true,
        //     "timestamp": "1641383206.489",
        //     "order_id": "86980774",
        //     "order_type": "LIMIT",
        //     "order_price": "1", // null for "MARKET" order
        //     "order_quantity": "12", // null for "MARKET" order
        //     "order_amount": null, // NOT-null for "MARKET" order
        //     "client_order_id": "0"
        // }
        // stop orders
        // {
        //     "success": true,
        //     "data": {
        //       "rows": [
        //         {
        //           "orderId": "1578938",
        //           "clientOrderId": "0",
        //           "algoType": "STOP_LOSS",
        //           "quantity": "0.1"
        //         }
        //       ]
        //     },
        //     "timestamp": "1686149372216"
        // }
        object data = this.safeDict(response, "data");
        if (isTrue(!isEqual(data, null)))
        {
            object rows = this.safeList(data, "rows", new List<object>() {});
            return this.parseOrder(getValue(rows, 0), market);
        }
        object order = this.parseOrder(response, market);
        ((IDictionary<string,object>)order)["type"] = type;
        return order;
    }

    public async override Task<object> editOrder(object id, object symbol, object type, object side, object amount = null, object price = null, object parameters = null)
    {
        /**
        * @method
        * @name woo#editOrder
        * @description edit a trade order
        * @see https://docs.woo.org/#edit-order
        * @see https://docs.woo.org/#edit-order-by-client_order_id
        * @see https://docs.woo.org/#edit-algo-order
        * @see https://docs.woo.org/#edit-algo-order-by-client_order_id
        * @param {string} id order id
        * @param {string} symbol unified symbol of the market to create an order in
        * @param {string} type 'market' or 'limit'
        * @param {string} side 'buy' or 'sell'
        * @param {float} amount how much of currency you want to trade in units of base currency
        * @param {float} [price] the price at which the order is to be fullfilled, in units of the quote currency, ignored in market orders
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {float} [params.triggerPrice] The price a trigger order is triggered at
        * @param {float} [params.stopLossPrice] price to trigger stop-loss orders
        * @param {float} [params.takeProfitPrice] price to trigger take-profit orders
        * @param {string} [params.trailingAmount] the quote amount to trail away from the current market price
        * @param {string} [params.trailingPercent] the percent to trail away from the current market price
        * @param {string} [params.trailingTriggerPrice] the price to trigger a trailing order, default uses the price argument
        * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {};
        if (isTrue(!isEqual(price, null)))
        {
            ((IDictionary<string,object>)request)["price"] = this.priceToPrecision(symbol, price);
        }
        if (isTrue(!isEqual(amount, null)))
        {
            ((IDictionary<string,object>)request)["quantity"] = this.amountToPrecision(symbol, amount);
        }
        object clientOrderIdUnified = this.safeString2(parameters, "clOrdID", "clientOrderId");
        object clientOrderIdExchangeSpecific = this.safeString(parameters, "client_order_id", clientOrderIdUnified);
        object isByClientOrder = !isEqual(clientOrderIdExchangeSpecific, null);
        object stopPrice = this.safeNumberN(parameters, new List<object>() {"triggerPrice", "stopPrice", "takeProfitPrice", "stopLossPrice"});
        if (isTrue(!isEqual(stopPrice, null)))
        {
            ((IDictionary<string,object>)request)["triggerPrice"] = this.priceToPrecision(symbol, stopPrice);
        }
        object trailingTriggerPrice = this.safeString2(parameters, "trailingTriggerPrice", "activatedPrice", this.numberToString(price));
        object trailingAmount = this.safeString2(parameters, "trailingAmount", "callbackValue");
        object trailingPercent = this.safeString2(parameters, "trailingPercent", "callbackRate");
        object isTrailingAmountOrder = !isEqual(trailingAmount, null);
        object isTrailingPercentOrder = !isEqual(trailingPercent, null);
        object isTrailing = isTrue(isTrailingAmountOrder) || isTrue(isTrailingPercentOrder);
        if (isTrue(isTrailing))
        {
            if (isTrue(!isEqual(trailingTriggerPrice, null)))
            {
                ((IDictionary<string,object>)request)["activatedPrice"] = this.priceToPrecision(symbol, trailingTriggerPrice);
            }
            if (isTrue(isTrailingAmountOrder))
            {
                ((IDictionary<string,object>)request)["callbackValue"] = trailingAmount;
            } else if (isTrue(isTrailingPercentOrder))
            {
                object convertedTrailingPercent = Precise.stringDiv(trailingPercent, "100");
                ((IDictionary<string,object>)request)["callbackRate"] = convertedTrailingPercent;
            }
        }
        parameters = this.omit(parameters, new List<object>() {"clOrdID", "clientOrderId", "client_order_id", "stopPrice", "triggerPrice", "takeProfitPrice", "stopLossPrice", "trailingTriggerPrice", "trailingAmount", "trailingPercent"});
        object isStop = isTrue(isTrue(isTrailing) || isTrue((!isEqual(stopPrice, null)))) || isTrue((!isEqual(this.safeValue(parameters, "childOrders"), null)));
        object response = null;
        if (isTrue(isByClientOrder))
        {
            ((IDictionary<string,object>)request)["client_order_id"] = clientOrderIdExchangeSpecific;
            if (isTrue(isStop))
            {
                response = await this.v3PrivatePutAlgoOrderClientClientOrderId(this.extend(request, parameters));
            } else
            {
                response = await this.v3PrivatePutOrderClientClientOrderId(this.extend(request, parameters));
            }
        } else
        {
            ((IDictionary<string,object>)request)["oid"] = id;
            if (isTrue(isStop))
            {
                response = await this.v3PrivatePutAlgoOrderOid(this.extend(request, parameters));
            } else
            {
                response = await this.v3PrivatePutOrderOid(this.extend(request, parameters));
            }
        }
        //
        //     {
        //         "code": 0,
        //         "data": {
        //             "status": "string",
        //             "success": true
        //         },
        //         "message": "string",
        //         "success": true,
        //         "timestamp": 0
        //     }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        return this.parseOrder(data, market);
    }

    public async override Task<object> cancelOrder(object id, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name woo#cancelOrder
        * @see https://docs.woo.org/#cancel-algo-order
        * @see https://docs.woo.org/#cancel-order
        * @see https://docs.woo.org/#cancel-order-by-client_order_id
        * @description cancels an open order
        * @param {string} id order id
        * @param {string} symbol unified symbol of the market the order was made in
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {boolean} [params.stop] whether the order is a stop/algo order
        * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        object stop = this.safeBool(parameters, "stop", false);
        parameters = this.omit(parameters, "stop");
        if (isTrue(!isTrue(stop) && isTrue((isEqual(symbol, null)))))
        {
            throw new ArgumentsRequired ((string)add(this.id, " cancelOrder() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
        }
        object request = new Dictionary<string, object>() {};
        object clientOrderIdUnified = this.safeString2(parameters, "clOrdID", "clientOrderId");
        object clientOrderIdExchangeSpecific = this.safeString(parameters, "client_order_id", clientOrderIdUnified);
        object isByClientOrder = !isEqual(clientOrderIdExchangeSpecific, null);
        object response = null;
        if (isTrue(stop))
        {
            ((IDictionary<string,object>)request)["order_id"] = id;
            response = await this.v3PrivateDeleteAlgoOrderOrderId(this.extend(request, parameters));
        } else
        {
            ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
            if (isTrue(isByClientOrder))
            {
                ((IDictionary<string,object>)request)["client_order_id"] = clientOrderIdExchangeSpecific;
                parameters = this.omit(parameters, new List<object>() {"clOrdID", "clientOrderId", "client_order_id"});
                response = await this.v1PrivateDeleteClientOrder(this.extend(request, parameters));
            } else
            {
                ((IDictionary<string,object>)request)["order_id"] = id;
                response = await this.v1PrivateDeleteOrder(this.extend(request, parameters));
            }
        }
        //
        // { success: true, status: "CANCEL_SENT" }
        //
        object extendParams = new Dictionary<string, object>() {
            { "symbol", symbol },
        };
        if (isTrue(isByClientOrder))
        {
            ((IDictionary<string,object>)extendParams)["client_order_id"] = clientOrderIdExchangeSpecific;
        } else
        {
            ((IDictionary<string,object>)extendParams)["id"] = id;
        }
        return this.extend(this.parseOrder(response), extendParams);
    }

    public async override Task<object> cancelAllOrders(object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name woo#cancelAllOrders
        * @see https://docs.woo.org/#cancel-all-pending-orders
        * @see https://docs.woo.org/#cancel-orders
        * @see https://docs.woo.org/#cancel-all-pending-algo-orders
        * @description cancel all open orders in a market
        * @param {string} symbol unified market symbol
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {boolean} [params.stop] whether the order is a stop/algo order
        * @returns {object} an list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object stop = this.safeBool2(parameters, "stop", "trigger");
        parameters = this.omit(parameters, new List<object>() {"stop", "trigger"});
        if (isTrue(stop))
        {
            return await this.v3PrivateDeleteAlgoOrdersPending(parameters);
        }
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " cancelOrders() requires a symbol argument")) ;
        }
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object response = await this.v1PrivateDeleteOrders(this.extend(request, parameters));
        //
        //     {
        //         "success":true,
        //         "status":"CANCEL_ALL_SENT"
        //     }
        //
        return response;
    }

    public async override Task<object> cancelAllOrdersAfter(object timeout, object parameters = null)
    {
        /**
        * @method
        * @name woo#cancelAllOrdersAfter
        * @description dead man's switch, cancel all orders after the given timeout
        * @see https://docs.woo.org/#cancel-all-after
        * @param {number} timeout time in milliseconds, 0 represents cancel the timer
        * @param {boolean} activated countdown
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} the api result
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {
            { "trigger_after", ((bool) isTrue((isGreaterThan(timeout, 0)))) ? timeout : 0 },
        };
        object response = await this.v1PrivatePostOrderCancelAllAfter(this.extend(request, parameters));
        //
        //     {
        //         "success": true,
        //         "data": {
        //             "expected_trigger_time": 1711534302938
        //         },
        //         "timestamp": 1711534302943
        //     }
        //
        return response;
    }

    public async override Task<object> fetchOrder(object id, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name woo#fetchOrder
        * @see https://docs.woo.org/#get-algo-order
        * @see https://docs.woo.org/#get-order
        * @description fetches information on an order made by the user
        * @param {string} symbol unified symbol of the market the order was made in
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {boolean} [params.stop] whether the order is a stop/algo order
        * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = ((bool) isTrue((!isEqual(symbol, null)))) ? this.market(symbol) : null;
        object stop = this.safeBool2(parameters, "stop", "trigger");
        parameters = this.omit(parameters, new List<object>() {"stop", "trigger"});
        object request = new Dictionary<string, object>() {};
        object clientOrderId = this.safeString2(parameters, "clOrdID", "clientOrderId");
        object response = null;
        if (isTrue(stop))
        {
            ((IDictionary<string,object>)request)["oid"] = id;
            response = await this.v3PrivateGetAlgoOrderOid(this.extend(request, parameters));
        } else if (isTrue(clientOrderId))
        {
            ((IDictionary<string,object>)request)["client_order_id"] = clientOrderId;
            response = await this.v1PrivateGetClientOrderClientOrderId(this.extend(request, parameters));
        } else
        {
            ((IDictionary<string,object>)request)["oid"] = id;
            response = await this.v1PrivateGetOrderOid(this.extend(request, parameters));
        }
        //
        // {
        //     "success": true,
        //     "symbol": "SPOT_WOO_USDT",
        //     "status": "FILLED", // FILLED, NEW
        //     "side": "BUY",
        //     "created_time": "1641480933.000",
        //     "order_id": "87541111",
        //     "order_tag": "default",
        //     "price": "1",
        //     "type": "LIMIT",
        //     "quantity": "12",
        //     "amount": null,
        //     "visible": "12",
        //     "executed": "12", // or any partial amount
        //     "total_fee": "0.0024",
        //     "fee_asset": "WOO",
        //     "client_order_id": null,
        //     "average_executed_price": "1",
        //     "Transactions": [
        //       {
        //         "id": "99111647",
        //         "symbol": "SPOT_WOO_USDT",
        //         "fee": "0.0024",
        //         "side": "BUY",
        //         "executed_timestamp": "1641482113.084",
        //         "order_id": "87541111",
        //         "executed_price": "1",
        //         "executed_quantity": "12",
        //         "fee_asset": "WOO",
        //         "is_maker": "1"
        //       }
        //     ]
        // }
        //
        object orders = this.safeDict(response, "data", response);
        return this.parseOrder(orders, market);
    }

    public async override Task<object> fetchOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name woo#fetchOrders
        * @description fetches information on multiple orders made by the user
        * @see https://docs.woo.org/#get-orders
        * @see https://docs.woo.org/#get-algo-orders
        * @param {string} symbol unified market symbol of the market orders were made in
        * @param {int} [since] the earliest time in ms to fetch orders for
        * @param {int} [limit] the maximum number of order structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {boolean} [params.stop] whether the order is a stop/algo order
        * @param {boolean} [params.isTriggered] whether the order has been triggered (false by default)
        * @param {string} [params.side] 'buy' or 'sell'
        * @param {boolean} [params.trailing] set to true if you want to fetch trailing orders
        * @param {boolean} [params.paginate] set to true if you want to fetch orders with pagination
        * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object paginate = false;
        var paginateparametersVariable = this.handleOptionAndParams(parameters, "fetchOrders", "paginate");
        paginate = ((IList<object>)paginateparametersVariable)[0];
        parameters = ((IList<object>)paginateparametersVariable)[1];
        if (isTrue(paginate))
        {
            return await this.fetchPaginatedCallIncremental("fetchOrders", symbol, since, limit, parameters, "page", 500);
        }
        object request = new Dictionary<string, object>() {};
        object market = null;
        object stop = this.safeBool2(parameters, "stop", "trigger");
        object trailing = this.safeBool(parameters, "trailing", false);
        parameters = this.omit(parameters, new List<object>() {"stop", "trailing", "trigger"});
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
        }
        if (isTrue(!isEqual(since, null)))
        {
            if (isTrue(isTrue(stop) || isTrue(trailing)))
            {
                ((IDictionary<string,object>)request)["createdTimeStart"] = since;
            } else
            {
                ((IDictionary<string,object>)request)["start_t"] = since;
            }
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["size"] = limit;
        } else
        {
            ((IDictionary<string,object>)request)["size"] = 500;
        }
        if (isTrue(stop))
        {
            ((IDictionary<string,object>)request)["algoType"] = "stop";
        } else if (isTrue(trailing))
        {
            ((IDictionary<string,object>)request)["algoType"] = "TRAILING_STOP";
        }
        object response = null;
        if (isTrue(isTrue(stop) || isTrue(trailing)))
        {
            response = await this.v3PrivateGetAlgoOrders(this.extend(request, parameters));
        } else
        {
            response = await this.v1PrivateGetOrders(this.extend(request, parameters));
        }
        //
        //     {
        //         "success":true,
        //         "meta":{
        //             "total":1,
        //             "records_per_page":100,
        //             "current_page":1
        //         },
        //         "rows":[
        //             {
        //                 "symbol":"PERP_BTC_USDT",
        //                 "status":"FILLED",
        //                 "side":"SELL",
        //                 "created_time":"1611617776.000",
        //                 "updated_time":"1611617776.000",
        //                 "order_id":52121167,
        //                 "order_tag":"default",
        //                 "price":null,
        //                 "type":"MARKET",
        //                 "quantity":0.002,
        //                 "amount":null,
        //                 "visible":0,
        //                 "executed":0.002,
        //                 "total_fee":0.01732885,
        //                 "fee_asset":"USDT",
        //                 "client_order_id":null,
        //                 "average_executed_price":28881.41
        //             }
        //         ]
        //     }
        //
        object data = this.safeValue(response, "data", response);
        object orders = this.safeList(data, "rows");
        return this.parseOrders(orders, market, since, limit);
    }

    public async override Task<object> fetchOpenOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name woo#fetchOpenOrders
        * @description fetches information on multiple orders made by the user
        * @see https://docs.woo.org/#get-orders
        * @see https://docs.woo.org/#get-algo-orders
        * @param {string} symbol unified market symbol of the market orders were made in
        * @param {int} [since] the earliest time in ms to fetch orders for
        * @param {int} [limit] the maximum number of order structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {boolean} [params.stop] whether the order is a stop/algo order
        * @param {boolean} [params.isTriggered] whether the order has been triggered (false by default)
        * @param {string} [params.side] 'buy' or 'sell'
        * @param {boolean} [params.trailing] set to true if you want to fetch trailing orders
        * @param {boolean} [params.paginate] set to true if you want to fetch orders with pagination
        * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object extendedParams = this.extend(parameters, new Dictionary<string, object>() {
            { "status", "INCOMPLETE" },
        });
        return await this.fetchOrders(symbol, since, limit, extendedParams);
    }

    public async override Task<object> fetchClosedOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name woo#fetchClosedOrders
        * @description fetches information on multiple orders made by the user
        * @see https://docs.woo.org/#get-orders
        * @see https://docs.woo.org/#get-algo-orders
        * @param {string} symbol unified market symbol of the market orders were made in
        * @param {int} [since] the earliest time in ms to fetch orders for
        * @param {int} [limit] the maximum number of order structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {boolean} [params.stop] whether the order is a stop/algo order
        * @param {boolean} [params.isTriggered] whether the order has been triggered (false by default)
        * @param {string} [params.side] 'buy' or 'sell'
        * @param {boolean} [params.trailing] set to true if you want to fetch trailing orders
        * @param {boolean} [params.paginate] set to true if you want to fetch orders with pagination
        * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object extendedParams = this.extend(parameters, new Dictionary<string, object>() {
            { "status", "COMPLETED" },
        });
        return await this.fetchOrders(symbol, since, limit, extendedParams);
    }

    public virtual object parseTimeInForce(object timeInForce)
    {
        object timeInForces = new Dictionary<string, object>() {
            { "ioc", "IOC" },
            { "fok", "FOK" },
            { "post_only", "PO" },
        };
        return this.safeString(timeInForces, timeInForce, null);
    }

    public override object parseOrder(object order, object market = null)
    {
        //
        // Possible input functions:
        // * createOrder
        // * cancelOrder
        // * fetchOrder
        // * fetchOrders
        // const isFromFetchOrder = ('order_tag' in order); TO_DO
        //
        // stop order after creating it:
        //   {
        //     "orderId": "1578938",
        //     "clientOrderId": "0",
        //     "algoType": "STOP_LOSS",
        //     "quantity": "0.1"
        //   }
        // stop order after fetching it:
        //   {
        //       "algoOrderId": "1578958",
        //       "clientOrderId": "0",
        //       "rootAlgoOrderId": "1578958",
        //       "parentAlgoOrderId": "0",
        //       "symbol": "SPOT_LTC_USDT",
        //       "orderTag": "default",
        //       "algoType": "STOP_LOSS",
        //       "side": "BUY",
        //       "quantity": "0.1",
        //       "isTriggered": false,
        //       "triggerPrice": "100",
        //       "triggerStatus": "USELESS",
        //       "type": "LIMIT",
        //       "rootAlgoStatus": "CANCELLED",
        //       "algoStatus": "CANCELLED",
        //       "triggerPriceType": "MARKET_PRICE",
        //       "price": "75",
        //       "triggerTime": "0",
        //       "totalExecutedQuantity": "0",
        //       "averageExecutedPrice": "0",
        //       "totalFee": "0",
        //       "feeAsset": '',
        //       "reduceOnly": false,
        //       "createdTime": "1686149609.744",
        //       "updatedTime": "1686149903.362"
        //   }
        //
        object timestamp = this.safeTimestampN(order, new List<object>() {"timestamp", "created_time", "createdTime"});
        object orderId = this.safeStringN(order, new List<object>() {"order_id", "orderId", "algoOrderId"});
        object clientOrderId = this.omitZero(this.safeString2(order, "client_order_id", "clientOrderId")); // Somehow, this always returns 0 for limit order
        object marketId = this.safeString(order, "symbol");
        market = this.safeMarket(marketId, market);
        object symbol = getValue(market, "symbol");
        object price = this.safeString2(order, "order_price", "price");
        object amount = this.safeString2(order, "order_quantity", "quantity"); // This is base amount
        object cost = this.safeString2(order, "order_amount", "amount"); // This is quote amount
        object orderType = this.safeStringLower2(order, "order_type", "type");
        object status = this.safeValue2(order, "status", "algoStatus");
        object side = this.safeStringLower(order, "side");
        object filled = this.omitZero(this.safeValue2(order, "executed", "totalExecutedQuantity"));
        object average = this.omitZero(this.safeString2(order, "average_executed_price", "averageExecutedPrice"));
        object remaining = Precise.stringSub(cost, filled);
        object fee = this.safeValue2(order, "total_fee", "totalFee");
        object feeCurrency = this.safeString2(order, "fee_asset", "feeAsset");
        object transactions = this.safeValue(order, "Transactions");
        object stopPrice = this.safeNumber(order, "triggerPrice");
        object takeProfitPrice = null;
        object stopLossPrice = null;
        object childOrders = this.safeValue(order, "childOrders");
        if (isTrue(!isEqual(childOrders, null)))
        {
            object first = this.safeValue(childOrders, 0);
            object innerChildOrders = this.safeValue(first, "childOrders", new List<object>() {});
            object innerChildOrdersLength = getArrayLength(innerChildOrders);
            if (isTrue(isGreaterThan(innerChildOrdersLength, 0)))
            {
                object takeProfitOrder = this.safeValue(innerChildOrders, 0);
                object stopLossOrder = this.safeValue(innerChildOrders, 1);
                takeProfitPrice = this.safeNumber(takeProfitOrder, "triggerPrice");
                stopLossPrice = this.safeNumber(stopLossOrder, "triggerPrice");
            }
        }
        object lastUpdateTimestamp = this.safeTimestamp2(order, "updatedTime", "updated_time");
        return this.safeOrder(new Dictionary<string, object>() {
            { "id", orderId },
            { "clientOrderId", clientOrderId },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "lastTradeTimestamp", null },
            { "lastUpdateTimestamp", lastUpdateTimestamp },
            { "status", this.parseOrderStatus(status) },
            { "symbol", symbol },
            { "type", orderType },
            { "timeInForce", this.parseTimeInForce(orderType) },
            { "postOnly", null },
            { "reduceOnly", this.safeBool(order, "reduce_only") },
            { "side", side },
            { "price", price },
            { "stopPrice", stopPrice },
            { "triggerPrice", stopPrice },
            { "takeProfitPrice", takeProfitPrice },
            { "stopLossPrice", stopLossPrice },
            { "average", average },
            { "amount", amount },
            { "filled", filled },
            { "remaining", remaining },
            { "cost", cost },
            { "trades", transactions },
            { "fee", new Dictionary<string, object>() {
                { "cost", fee },
                { "currency", feeCurrency },
            } },
            { "info", order },
        }, market);
    }

    public virtual object parseOrderStatus(object status)
    {
        if (isTrue(!isEqual(status, null)))
        {
            object statuses = new Dictionary<string, object>() {
                { "NEW", "open" },
                { "FILLED", "closed" },
                { "CANCEL_SENT", "canceled" },
                { "CANCEL_ALL_SENT", "canceled" },
                { "CANCELLED", "canceled" },
                { "PARTIAL_FILLED", "open" },
                { "REJECTED", "rejected" },
                { "INCOMPLETE", "open" },
                { "COMPLETED", "closed" },
            };
            return this.safeString(statuses, status, status);
        }
        return status;
    }

    public async override Task<object> fetchOrderBook(object symbol, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name woo#fetchOrderBook
        * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
        * @param {string} symbol unified symbol of the market to fetch the order book for
        * @param {int} [limit] the maximum amount of order book entries to return
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        if (isTrue(!isEqual(limit, null)))
        {
            limit = mathMin(limit, 1000);
            ((IDictionary<string,object>)request)["max_level"] = limit;
        }
        object response = await this.v1PublicGetOrderbookSymbol(this.extend(request, parameters));
        //
        // {
        //   "success": true,
        //   "timestamp": "1641562961192",
        //   "asks": [
        //     { price: '0.921', quantity: "76.01" },
        //     { price: '0.933', quantity: "477.10" },
        //     ...
        //   ],
        //   "bids": [
        //     { price: '0.940', quantity: "13502.47" },
        //     { price: '0.932', quantity: "43.91" },
        //     ...
        //   ]
        // }
        //
        object timestamp = this.safeInteger(response, "timestamp");
        return this.parseOrderBook(response, symbol, timestamp, "bids", "asks", "price", "quantity");
    }

    public async override Task<object> fetchOHLCV(object symbol, object timeframe = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name woo#fetchOHLCV
        * @see https://docs.woo.org/#kline-public
        * @see https://docs.woo.org/#kline-historical-data-public
        * @description fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
        * @param {string} symbol unified symbol of the market to fetch OHLCV data for
        * @param {string} timeframe the length of time each candle represents
        * @param {int} [since] timestamp in ms of the earliest candle to fetch
        * @param {int} [limit] max=1000, max=100 when since is defined and is less than (now - (999 * (timeframe in ms)))
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
        */
        timeframe ??= "1m";
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
            { "type", this.safeString(this.timeframes, timeframe, timeframe) },
        };
        object useHistEndpoint = !isEqual(since, null);
        if (isTrue(isTrue((!isEqual(limit, null))) && isTrue((!isEqual(since, null)))))
        {
            object oneThousandCandles = multiply(multiply(this.parseTimeframe(timeframe), 1000), 999); // 999 because there will be delay between this and the request, causing the latest candle to be excluded sometimes
            object startWithLimit = subtract(this.milliseconds(), oneThousandCandles);
            useHistEndpoint = isLessThan(since, startWithLimit);
        }
        if (isTrue(useHistEndpoint))
        {
            ((IDictionary<string,object>)request)["start_time"] = since;
        } else if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = mathMin(limit, 1000);
        }
        object response = null;
        if (!isTrue(useHistEndpoint))
        {
            response = await this.v1PublicGetKline(this.extend(request, parameters));
        } else
        {
            response = await this.v1PubGetHistKline(this.extend(request, parameters));
            response = this.safeDict(response, "data");
        }
        object rows = this.safeList(response, "rows", new List<object>() {});
        return this.parseOHLCVs(rows, market, timeframe, since, limit);
    }

    public override object parseOHLCV(object ohlcv, object market = null)
    {
        // example response in fetchOHLCV
        return new List<object> {this.safeInteger(ohlcv, "start_timestamp"), this.safeNumber(ohlcv, "open"), this.safeNumber(ohlcv, "high"), this.safeNumber(ohlcv, "low"), this.safeNumber(ohlcv, "close"), this.safeNumber(ohlcv, "volume")};
    }

    public async override Task<object> fetchOrderTrades(object id, object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name woo#fetchOrderTrades
        * @description fetch all the trades made from a single order
        * @param {string} id order id
        * @param {string} symbol unified market symbol
        * @param {int} [since] the earliest time in ms to fetch trades for
        * @param {int} [limit] the maximum number of trades to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
        }
        object request = new Dictionary<string, object>() {
            { "oid", id },
        };
        object response = await this.v1PrivateGetOrderOidTrades(this.extend(request, parameters));
        // {
        //     "success": true,
        //     "rows": [
        //       {
        //         "id": "99111647",
        //         "symbol": "SPOT_WOO_USDT",
        //         "fee": "0.0024",
        //         "side": "BUY",
        //         "executed_timestamp": "1641482113.084",
        //         "order_id": "87541111",
        //         "order_tag": "default",
        //         "executed_price": "1",
        //         "executed_quantity": "12",
        //         "fee_asset": "WOO",
        //         "is_maker": "1"
        //       }
        //     ]
        // }
        object trades = this.safeList(response, "rows", new List<object>() {});
        return this.parseTrades(trades, market, since, limit, parameters);
    }

    public async override Task<object> fetchMyTrades(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name woo#fetchMyTrades
        * @see https://docs.woo.org/#get-trades
        * @description fetch all trades made by the user
        * @param {string} symbol unified market symbol
        * @param {int} [since] the earliest time in ms to fetch trades for
        * @param {int} [limit] the maximum number of trades structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {boolean} [params.paginate] set to true if you want to fetch trades with pagination
        * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object paginate = false;
        var paginateparametersVariable = this.handleOptionAndParams(parameters, "fetchMyTrades", "paginate");
        paginate = ((IList<object>)paginateparametersVariable)[0];
        parameters = ((IList<object>)paginateparametersVariable)[1];
        if (isTrue(paginate))
        {
            return await this.fetchPaginatedCallIncremental("fetchMyTrades", symbol, since, limit, parameters, "page", 500);
        }
        object request = new Dictionary<string, object>() {};
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["start_t"] = since;
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["size"] = limit;
        } else
        {
            ((IDictionary<string,object>)request)["size"] = 500;
        }
        object response = await this.v1PrivateGetClientTrades(this.extend(request, parameters));
        // {
        //     "success": true,
        //     "meta": {
        //         "records_per_page": 25,
        //         "current_page": 1
        //     },
        //     "rows": [
        //         {
        //             "id": 5,
        //             "symbol": "SPOT_BTC_USDT",
        //             "order_id": 211,
        //             "order_tag": "default",
        //             "executed_price": 10892.84,
        //             "executed_quantity": 0.002,
        //             "is_maker": 0,
        //             "side": "SELL",
        //             "fee": 0,
        //             "fee_asset": "USDT",
        //             "executed_timestamp": "1566264290.250"
        //         },
        //         ...
        //     ]
        // }
        object trades = this.safeList(response, "rows", new List<object>() {});
        return this.parseTrades(trades, market, since, limit, parameters);
    }

    public async override Task<object> fetchAccounts(object parameters = null)
    {
        /**
        * @method
        * @name woo#fetchAccounts
        * @description fetch all the accounts associated with a profile
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a dictionary of [account structures]{@link https://docs.ccxt.com/#/?id=account-structure} indexed by the account type
        */
        parameters ??= new Dictionary<string, object>();
        object response = await this.v1PrivateGetSubAccountAssets(parameters);
        //
        //     {
        //         "rows": [{
        //                 "application_id": "13e4fc34-e2ff-4cb7-b1e4-4c22fee7d365",
        //                 "account": "Main",
        //                 "usdt_balance": "4.0"
        //             },
        //             {
        //                 "application_id": "432952aa-a401-4e26-aff6-972920aebba3",
        //                 "account": "subaccount",
        //                 "usdt_balance": "1.0"
        //             }
        //         ],
        //         "success": true
        //     }
        //
        object rows = this.safeList(response, "rows", new List<object>() {});
        return this.parseAccounts(rows, parameters);
    }

    public override object parseAccount(object account)
    {
        //
        //     {
        //         "application_id": "336952aa-a401-4e26-aff6-972920aebba3",
        //         "account": "subaccount",
        //         "usdt_balance": "1.0",
        //     }
        //
        object accountId = this.safeString(account, "account");
        return new Dictionary<string, object>() {
            { "info", account },
            { "id", this.safeString(account, "application_id") },
            { "name", accountId },
            { "code", null },
            { "type", ((bool) isTrue(isEqual(accountId, "Main"))) ? "main" : "subaccount" },
        };
    }

    public async override Task<object> fetchBalance(object parameters = null)
    {
        /**
        * @method
        * @name woo#fetchBalance
        * @description query for balance and get the amount of funds available for trading or funds locked in orders
        * @see https://docs.woo.org/#get-current-holding-get-balance-new
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.v3PrivateGetBalances(parameters);
        //
        //     {
        //         "success": true,
        //         "data": {
        //             "holding": [
        //                 {
        //                     "token": "0_token",
        //                     "holding": 1,
        //                     "frozen": 0,
        //                     "staked": 0,
        //                     "unbonding": 0,
        //                     "vault": 0,
        //                     "interest": 0,
        //                     "pendingShortQty": 0,
        //                     "pendingLongQty": 0,
        //                     "availableBalance": 0,
        //                     "updatedTime": 312321.121
        //                 }
        //             ]
        //         },
        //         "timestamp": 1673323746259
        //     }
        //
        object data = this.safeDict(response, "data");
        return this.parseBalance(data);
    }

    public override object parseBalance(object response)
    {
        object result = new Dictionary<string, object>() {
            { "info", response },
        };
        object balances = this.safeList(response, "holding", new List<object>() {});
        for (object i = 0; isLessThan(i, getArrayLength(balances)); postFixIncrement(ref i))
        {
            object balance = getValue(balances, i);
            object code = this.safeCurrencyCode(this.safeString(balance, "token"));
            object account = this.account();
            ((IDictionary<string,object>)account)["total"] = this.safeString(balance, "holding");
            ((IDictionary<string,object>)account)["free"] = this.safeString(balance, "availableBalance");
            ((IDictionary<string,object>)result)[(string)code] = account;
        }
        return this.safeBalance(result);
    }

    public async override Task<object> fetchDepositAddress(object code, object parameters = null)
    {
        /**
        * @method
        * @name woo#fetchDepositAddress
        * @description fetch the deposit address for a currency associated with this account
        * @param {string} code unified currency code
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} an [address structure]{@link https://docs.ccxt.com/#/?id=address-structure}
        */
        // this method is TODO because of networks unification
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        object networkCodeDefault = this.defaultNetworkCodeForCurrency(code);
        object networkCode = this.safeString(parameters, "network", networkCodeDefault);
        parameters = this.omit(parameters, "network");
        object codeForExchange = add(add(networkCode, "_"), getValue(currency, "code"));
        object request = new Dictionary<string, object>() {
            { "token", codeForExchange },
        };
        object response = await this.v1PrivateGetAssetDeposit(this.extend(request, parameters));
        // {
        //     "success": true,
        //     "address": "3Jmtjx5544T4smrit9Eroe4PCrRkpDeKjP",
        //     "extra": ''
        // }
        object tag = this.safeString(response, "extra");
        object address = this.safeString(response, "address");
        this.checkAddress(address);
        return new Dictionary<string, object>() {
            { "currency", code },
            { "address", address },
            { "tag", tag },
            { "network", networkCode },
            { "info", response },
        };
    }

    public async virtual Task<object> getAssetHistoryRows(object code = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object currency = null;
        if (isTrue(!isEqual(code, null)))
        {
            currency = this.currency(code);
            ((IDictionary<string,object>)request)["balance_token"] = getValue(currency, "id");
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["start_t"] = since;
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["pageSize"] = limit;
        }
        object transactionType = this.safeString(parameters, "type");
        parameters = this.omit(parameters, "type");
        if (isTrue(!isEqual(transactionType, null)))
        {
            ((IDictionary<string,object>)request)["type"] = transactionType;
        }
        object response = await this.v1PrivateGetAssetHistory(this.extend(request, parameters));
        // {
        //     "rows": [
        //       {
        //         "id": "22010508193900165",
        //         "token": "TRON_USDT",
        //         "extra": '',
        //         "amount": "13.75848500",
        //         "status": "COMPLETED",
        //         "account": null,
        //         "description": null,
        //         "user_id": "42222",
        //         "application_id": "6ad2b303-f354-45c0-8105-9f5f19d0e335",
        //         "external_id": "220105081900134",
        //         "target_address": "TXnyFSnAYad3YCaqtwMw9jvXKkeU39NLnK",
        //         "source_address": "TYDzsYUEpvnYmQk4zGP9sWWcTEd2MiAtW6",
        //         "type": "BALANCE",
        //         "token_side": "DEPOSIT",
        //         "tx_id": "35b0004022f6b3ad07f39a0b7af199f6b258c2c3e2c7cdc93c67efa74fd625ee",
        //         "fee_token": '',
        //         "fee_amount": "0.00000000",
        //         "created_time": "1641370779.442",
        //         "updated_time": "1641370779.465",
        //         "is_new_target_address": null,
        //         "confirmed_number": "29",
        //         "confirming_threshold": "27",
        //         "audit_tag": "1",
        //         "audit_result": "0",
        //         "balance_token": null, // TODO -write to support, that this seems broken. here should be the token id
        //         "network_name": null // TODO -write to support, that this seems broken. here should be the network id
        //       }
        //     ],
        //     "meta": { total: '1', records_per_page: "25", current_page: "1" },
        //     "success": true
        // }
        return new List<object>() {currency, this.safeValue(response, "rows", new Dictionary<string, object>() {})};
    }

    public async override Task<object> fetchLedger(object code = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name woo#fetchLedger
        * @description fetch the history of changes, actions done by the user or operations that altered balance of the user
        * @param {string} code unified currency code, default is undefined
        * @param {int} [since] timestamp in ms of the earliest ledger entry, default is undefined
        * @param {int} [limit] max number of ledger entrys to return, default is undefined
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [ledger structure]{@link https://docs.ccxt.com/#/?id=ledger-structure}
        */
        parameters ??= new Dictionary<string, object>();
        var currencyrowsVariable = await this.getAssetHistoryRows(code, since, limit, parameters);
        var currency = ((IList<object>) currencyrowsVariable)[0];
        var rows = ((IList<object>) currencyrowsVariable)[1];
        return this.parseLedger(rows, currency, since, limit, parameters);
    }

    public override object parseLedgerEntry(object item, object currency = null)
    {
        object networkizedCode = this.safeString(item, "token");
        object currencyDefined = this.getCurrencyFromChaincode(networkizedCode, currency);
        object code = getValue(currencyDefined, "code");
        object amount = this.safeNumber(item, "amount");
        object side = this.safeString(item, "token_side");
        object direction = ((bool) isTrue((isEqual(side, "DEPOSIT")))) ? "in" : "out";
        object timestamp = this.safeTimestamp(item, "created_time");
        object fee = this.parseTokenAndFeeTemp(item, "fee_token", "fee_amount");
        return new Dictionary<string, object>() {
            { "id", this.safeString(item, "id") },
            { "currency", code },
            { "account", this.safeString(item, "account") },
            { "referenceAccount", null },
            { "referenceId", this.safeString(item, "tx_id") },
            { "status", this.parseTransactionStatus(this.safeString(item, "status")) },
            { "amount", amount },
            { "before", null },
            { "after", null },
            { "fee", fee },
            { "direction", direction },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "type", this.parseLedgerEntryType(this.safeString(item, "type")) },
            { "info", item },
        };
    }

    public virtual object parseLedgerEntryType(object type)
    {
        object types = new Dictionary<string, object>() {
            { "BALANCE", "transaction" },
            { "COLLATERAL", "transfer" },
        };
        return this.safeString(types, type, type);
    }

    public virtual object getCurrencyFromChaincode(object networkizedCode, object currency)
    {
        if (isTrue(!isEqual(currency, null)))
        {
            return currency;
        } else
        {
            object parts = ((string)networkizedCode).Split(new [] {((string)"_")}, StringSplitOptions.None).ToList<object>();
            object partsLength = getArrayLength(parts);
            object firstPart = this.safeString(parts, 0);
            object currencyId = this.safeString(parts, 1, firstPart);
            if (isTrue(isGreaterThan(partsLength, 2)))
            {
                currencyId = add(currencyId, add("_", this.safeString(parts, 2)));
            }
            currency = this.safeCurrency(currencyId);
        }
        return currency;
    }

    public async override Task<object> fetchDeposits(object code = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name woo#fetchDeposits
        * @description fetch all deposits made to an account
        * @param {string} code unified currency code
        * @param {int} [since] the earliest time in ms to fetch deposits for
        * @param {int} [limit] the maximum number of deposits structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
        */
        parameters ??= new Dictionary<string, object>();
        object request = new Dictionary<string, object>() {
            { "token_side", "DEPOSIT" },
        };
        return await this.fetchDepositsWithdrawals(code, since, limit, this.extend(request, parameters));
    }

    public async override Task<object> fetchWithdrawals(object code = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name woo#fetchWithdrawals
        * @description fetch all withdrawals made from an account
        * @param {string} code unified currency code
        * @param {int} [since] the earliest time in ms to fetch withdrawals for
        * @param {int} [limit] the maximum number of withdrawals structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
        */
        parameters ??= new Dictionary<string, object>();
        object request = new Dictionary<string, object>() {
            { "token_side", "WITHDRAW" },
        };
        return await this.fetchDepositsWithdrawals(code, since, limit, this.extend(request, parameters));
    }

    public async override Task<object> fetchDepositsWithdrawals(object code = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name woo#fetchDepositsWithdrawals
        * @description fetch history of deposits and withdrawals
        * @param {string} [code] unified currency code for the currency of the deposit/withdrawals, default is undefined
        * @param {int} [since] timestamp in ms of the earliest deposit/withdrawal, default is undefined
        * @param {int} [limit] max number of deposit/withdrawals to return, default is undefined
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a list of [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
        */
        parameters ??= new Dictionary<string, object>();
        object request = new Dictionary<string, object>() {
            { "type", "BALANCE" },
        };
        var currencyrowsVariable = await this.getAssetHistoryRows(code, since, limit, this.extend(request, parameters));
        var currency = ((IList<object>) currencyrowsVariable)[0];
        var rows = ((IList<object>) currencyrowsVariable)[1];
        //
        //     {
        //         "rows":[],
        //         "meta":{
        //             "total":0,
        //             "records_per_page":25,
        //             "current_page":1
        //         },
        //         "success":true
        //     }
        //
        return this.parseTransactions(rows, currency, since, limit, parameters);
    }

    public override object parseTransaction(object transaction, object currency = null)
    {
        // example in fetchLedger
        object networkizedCode = this.safeString(transaction, "token");
        object currencyDefined = this.getCurrencyFromChaincode(networkizedCode, currency);
        object code = getValue(currencyDefined, "code");
        object movementDirection = this.safeStringLower(transaction, "token_side");
        if (isTrue(isEqual(movementDirection, "withdraw")))
        {
            movementDirection = "withdrawal";
        }
        object fee = this.parseTokenAndFeeTemp(transaction, "fee_token", "fee_amount");
        object addressTo = this.safeString(transaction, "target_address");
        object addressFrom = this.safeString(transaction, "source_address");
        object timestamp = this.safeTimestamp(transaction, "created_time");
        return new Dictionary<string, object>() {
            { "info", transaction },
            { "id", this.safeString2(transaction, "id", "withdraw_id") },
            { "txid", this.safeString(transaction, "tx_id") },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "address", null },
            { "addressFrom", addressFrom },
            { "addressTo", addressTo },
            { "tag", this.safeString(transaction, "extra") },
            { "tagFrom", null },
            { "tagTo", null },
            { "type", movementDirection },
            { "amount", this.safeNumber(transaction, "amount") },
            { "currency", code },
            { "status", this.parseTransactionStatus(this.safeString(transaction, "status")) },
            { "updated", this.safeTimestamp(transaction, "updated_time") },
            { "comment", null },
            { "internal", null },
            { "fee", fee },
            { "network", null },
        };
    }

    public virtual object parseTransactionStatus(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "NEW", "pending" },
            { "CONFIRMING", "pending" },
            { "PROCESSING", "pending" },
            { "COMPLETED", "ok" },
            { "CANCELED", "canceled" },
        };
        return this.safeString(statuses, status, status);
    }

    public async override Task<object> transfer(object code, object amount, object fromAccount, object toAccount, object parameters = null)
    {
        /**
        * @method
        * @name woo#transfer
        * @see https://docs.woo.org/#get-transfer-history
        * @description transfer currency internally between wallets on the same account
        * @param {string} code unified currency code
        * @param {float} amount amount to transfer
        * @param {string} fromAccount account to transfer from
        * @param {string} toAccount account to transfer to
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [transfer structure]{@link https://docs.ccxt.com/#/?id=transfer-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "token", getValue(currency, "id") },
            { "amount", this.parseToNumeric(amount) },
            { "from_application_id", fromAccount },
            { "to_application_id", toAccount },
        };
        object response = await this.v1PrivatePostAssetMainSubTransfer(this.extend(request, parameters));
        //
        //     {
        //         "success": true,
        //         "id": 200
        //     }
        //
        object transfer = this.parseTransfer(response, currency);
        object transferOptions = this.safeDict(this.options, "transfer", new Dictionary<string, object>() {});
        object fillResponseFromRequest = this.safeBool(transferOptions, "fillResponseFromRequest", true);
        if (isTrue(fillResponseFromRequest))
        {
            ((IDictionary<string,object>)transfer)["amount"] = amount;
            ((IDictionary<string,object>)transfer)["fromAccount"] = fromAccount;
            ((IDictionary<string,object>)transfer)["toAccount"] = toAccount;
        }
        return transfer;
    }

    public async virtual Task<object> fetchTransfers(object code = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name woo#fetchTransfers
        * @description fetch a history of internal transfers made on an account
        * @see https://docs.woo.org/#get-transfer-history
        * @param {string} code unified currency code of the currency transferred
        * @param {int} [since] the earliest time in ms to fetch transfers for
        * @param {int} [limit] the maximum number of  transfers structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {int} [params.until] the latest time in ms to fetch entries for
        * @returns {object[]} a list of [transfer structures]{@link https://docs.ccxt.com/#/?id=transfer-structure}
        */
        parameters ??= new Dictionary<string, object>();
        object request = new Dictionary<string, object>() {};
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["size"] = limit;
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["start_t"] = since;
        }
        object until = this.safeInteger2(parameters, "until", "till"); // unified in milliseconds
        parameters = this.omit(parameters, new List<object>() {"until", "till"});
        if (isTrue(!isEqual(until, null)))
        {
            ((IDictionary<string,object>)request)["end_t"] = until;
        }
        object response = await this.v1PrivateGetAssetMainSubTransferHistory(this.extend(request, parameters));
        //
        //     {
        //         "rows": [
        //             {
        //                 "id": 46704,
        //                 "token": "USDT",
        //                 "amount": 30000.00000000,
        //                 "status": "COMPLETED",
        //                 "from_application_id": "0f1bd3cd-dba2-4563-b8bb-0adb1bfb83a3",
        //                 "to_application_id": "c01e6940-a735-4022-9b6c-9d3971cdfdfa",
        //                 "from_user": "LeverageLow",
        //                 "to_user": "dev",
        //                 "created_time": "1709022325.427",
        //                 "updated_time": "1709022325.542"
        //             }
        //         ],
        //         "meta": {
        //             "total": 50,
        //             "records_per_page": 25,
        //             "current_page": 1
        //         },
        //         "success": true
        //     }
        //
        object data = this.safeList(response, "rows", new List<object>() {});
        return this.parseTransfers(data, null, since, limit, parameters);
    }

    public override object parseTransfer(object transfer, object currency = null)
    {
        //
        //    fetchTransfers
        //     {
        //         "id": 46704,
        //         "token": "USDT",
        //         "amount": 30000.00000000,
        //         "status": "COMPLETED",
        //         "from_application_id": "0f1bd3cd-dba2-4563-b8bb-0adb1bfb83a3",
        //         "to_application_id": "c01e6940-a735-4022-9b6c-9d3971cdfdfa",
        //         "from_user": "LeverageLow",
        //         "to_user": "dev",
        //         "created_time": "1709022325.427",
        //         "updated_time": "1709022325.542"
        //     }
        //
        //    transfer
        //        {
        //            "success": true,
        //            "id": 200
        //        }
        //
        object networkizedCode = this.safeString(transfer, "token");
        object currencyDefined = this.getCurrencyFromChaincode(networkizedCode, currency);
        object code = getValue(currencyDefined, "code");
        object timestamp = this.safeTimestamp(transfer, "created_time");
        object success = this.safeBool(transfer, "success");
        object status = null;
        if (isTrue(!isEqual(success, null)))
        {
            status = ((bool) isTrue(success)) ? "ok" : "failed";
        }
        return new Dictionary<string, object>() {
            { "id", this.safeString(transfer, "id") },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "currency", code },
            { "amount", this.safeNumber(transfer, "amount") },
            { "fromAccount", this.safeString(transfer, "from_application_id") },
            { "toAccount", this.safeString(transfer, "to_application_id") },
            { "status", this.parseTransferStatus(this.safeString(transfer, "status", status)) },
            { "info", transfer },
        };
    }

    public virtual object parseTransferStatus(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "NEW", "pending" },
            { "CONFIRMING", "pending" },
            { "PROCESSING", "pending" },
            { "COMPLETED", "ok" },
            { "CANCELED", "canceled" },
        };
        return this.safeString(statuses, status, status);
    }

    public async override Task<object> withdraw(object code, object amount, object address, object tag = null, object parameters = null)
    {
        /**
        * @method
        * @name woo#withdraw
        * @description make a withdrawal
        * @param {string} code unified currency code
        * @param {float} amount the amount to withdraw
        * @param {string} address the address to withdraw to
        * @param {string} tag
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
        */
        parameters ??= new Dictionary<string, object>();
        var tagparametersVariable = this.handleWithdrawTagAndParams(tag, parameters);
        tag = ((IList<object>)tagparametersVariable)[0];
        parameters = ((IList<object>)tagparametersVariable)[1];
        await this.loadMarkets();
        this.checkAddress(address);
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "amount", amount },
            { "address", address },
        };
        if (isTrue(!isEqual(tag, null)))
        {
            ((IDictionary<string,object>)request)["extra"] = tag;
        }
        object networks = this.safeDict(this.options, "networks", new Dictionary<string, object>() {});
        object currencyNetworks = this.safeDict(currency, "networks", new Dictionary<string, object>() {});
        object network = this.safeStringUpper(parameters, "network");
        object networkId = this.safeString(networks, network, network);
        object coinNetwork = this.safeDict(currencyNetworks, networkId, new Dictionary<string, object>() {});
        object coinNetworkId = this.safeString(coinNetwork, "id");
        if (isTrue(isEqual(coinNetworkId, null)))
        {
            throw new BadRequest ((string)add(this.id, " withdraw() require network parameter")) ;
        }
        ((IDictionary<string,object>)request)["token"] = coinNetworkId;
        object response = await this.v1PrivatePostAssetWithdraw(this.extend(request, parameters));
        //
        //     {
        //         "success": true,
        //         "withdraw_id": "20200119145703654"
        //     }
        //
        return this.parseTransaction(response, currency);
    }

    public async override Task<object> repayMargin(object code, object amount, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name woo#repayMargin
        * @description repay borrowed margin and interest
        * @see https://docs.woo.org/#repay-interest
        * @param {string} code unified currency code of the currency to repay
        * @param {float} amount the amount to repay
        * @param {string} symbol not used by woo.repayMargin ()
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [margin loan structure]{@link https://docs.ccxt.com/#/?id=margin-loan-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            symbol = getValue(market, "symbol");
        }
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "token", getValue(currency, "id") },
            { "amount", this.currencyToPrecision(code, amount) },
        };
        object response = await this.v1PrivatePostInterestRepay(this.extend(request, parameters));
        //
        //     {
        //         "success": true,
        //     }
        //
        object transaction = this.parseMarginLoan(response, currency);
        return this.extend(transaction, new Dictionary<string, object>() {
            { "amount", amount },
            { "symbol", symbol },
        });
    }

    public virtual object parseMarginLoan(object info, object currency = null)
    {
        //
        //     {
        //         "success": true,
        //     }
        //
        return new Dictionary<string, object>() {
            { "id", null },
            { "currency", this.safeCurrencyCode(null, currency) },
            { "amount", null },
            { "symbol", null },
            { "timestamp", null },
            { "datetime", null },
            { "info", info },
        };
    }

    public override object nonce()
    {
        return this.milliseconds();
    }

    public override object sign(object path, object section = null, object method = null, object parameters = null, object headers = null, object body = null)
    {
        section ??= "public";
        method ??= "GET";
        parameters ??= new Dictionary<string, object>();
        object version = getValue(section, 0);
        object access = getValue(section, 1);
        object pathWithParams = this.implodeParams(path, parameters);
        object url = this.implodeHostname(getValue(getValue(this.urls, "api"), access));
        url = add(url, add(add("/", version), "/"));
        parameters = this.omit(parameters, this.extractParams(path));
        parameters = this.keysort(parameters);
        if (isTrue(isEqual(access, "public")))
        {
            url = add(url, add(add(access, "/"), pathWithParams));
            if (isTrue(getArrayLength(new List<object>(((IDictionary<string,object>)parameters).Keys))))
            {
                url = add(url, add("?", this.urlencode(parameters)));
            }
        } else
        {
            this.checkRequiredCredentials();
            if (isTrue(isTrue(isEqual(method, "POST")) && isTrue((isTrue(isEqual(path, "algo/order")) || isTrue(isEqual(path, "order"))))))
            {
                object isSandboxMode = this.safeBool(this.options, "sandboxMode", false);
                if (!isTrue(isSandboxMode))
                {
                    object applicationId = "bc830de7-50f3-460b-9ee0-f430f83f9dad";
                    object brokerId = this.safeString(this.options, "brokerId", applicationId);
                    object isStop = isGreaterThan(getIndexOf(path, "algo"), -1);
                    if (isTrue(isStop))
                    {
                        ((IDictionary<string,object>)parameters)["brokerId"] = brokerId;
                    } else
                    {
                        ((IDictionary<string,object>)parameters)["broker_id"] = brokerId;
                    }
                }
                parameters = this.keysort(parameters);
            }
            object auth = "";
            object ts = ((object)this.nonce()).ToString();
            url = add(url, pathWithParams);
            headers = new Dictionary<string, object>() {
                { "x-api-key", this.apiKey },
                { "x-api-timestamp", ts },
            };
            if (isTrue(isEqual(version, "v3")))
            {
                auth = add(add(add(add(add(ts, method), "/"), version), "/"), pathWithParams);
                if (isTrue(isTrue(isTrue(isEqual(method, "POST")) || isTrue(isEqual(method, "PUT"))) || isTrue(isEqual(method, "DELETE"))))
                {
                    body = this.json(parameters);
                    auth = add(auth, body);
                } else
                {
                    if (isTrue(getArrayLength(new List<object>(((IDictionary<string,object>)parameters).Keys))))
                    {
                        object query = this.urlencode(parameters);
                        url = add(url, add("?", query));
                        auth = add(auth, add("?", query));
                    }
                }
                ((IDictionary<string,object>)headers)["content-type"] = "application/json";
            } else
            {
                auth = this.urlencode(parameters);
                if (isTrue(isTrue(isTrue(isEqual(method, "POST")) || isTrue(isEqual(method, "PUT"))) || isTrue(isEqual(method, "DELETE"))))
                {
                    body = auth;
                } else
                {
                    if (isTrue(getArrayLength(new List<object>(((IDictionary<string,object>)parameters).Keys))))
                    {
                        url = add(url, add("?", auth));
                    }
                }
                auth = add(auth, add("|", ts));
                ((IDictionary<string,object>)headers)["content-type"] = "application/x-www-form-urlencoded";
            }
            ((IDictionary<string,object>)headers)["x-api-signature"] = this.hmac(this.encode(auth), this.encode(this.secret), sha256);
        }
        return new Dictionary<string, object>() {
            { "url", url },
            { "method", method },
            { "body", body },
            { "headers", headers },
        };
    }

    public override object handleErrors(object httpCode, object reason, object url, object method, object headers, object body, object response, object requestHeaders, object requestBody)
    {
        if (!isTrue(response))
        {
            return null;  // fallback to default error handler
        }
        //
        //     400 Bad Request {"success":false,"code":-1012,"message":"Amount is required for buy market orders when margin disabled."}
        //                     {"code":"-1011","message":"The system is under maintenance.","success":false}
        //
        object success = this.safeBool(response, "success");
        object errorCode = this.safeString(response, "code");
        if (!isTrue(success))
        {
            object feedback = add(add(this.id, " "), this.json(response));
            this.throwBroadlyMatchedException(getValue(this.exceptions, "broad"), body, feedback);
            this.throwExactlyMatchedException(getValue(this.exceptions, "exact"), errorCode, feedback);
        }
        return null;
    }

    public override object parseIncome(object income, object market = null)
    {
        //
        //     {
        //         "id":666666,
        //         "symbol":"PERP_BTC_USDT",
        //         "funding_rate":0.00001198,
        //         "mark_price":28941.04000000,
        //         "funding_fee":0.00069343,
        //         "payment_type":"Pay",
        //         "status":"COMPLETED",
        //         "created_time":"1653616000.666",
        //         "updated_time":"1653616000.605"
        //     }
        //
        object marketId = this.safeString(income, "symbol");
        object symbol = this.safeSymbol(marketId, market);
        object amount = this.safeNumber(income, "funding_fee");
        object code = this.safeCurrencyCode("USD");
        object id = this.safeString(income, "id");
        object timestamp = this.safeTimestamp(income, "updated_time");
        object rate = this.safeNumber(income, "funding_rate");
        return new Dictionary<string, object>() {
            { "info", income },
            { "symbol", symbol },
            { "code", code },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "id", id },
            { "amount", amount },
            { "rate", rate },
        };
    }

    public async override Task<object> fetchFundingHistory(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["start_t"] = since;
        }
        object response = await this.v1PrivateGetFundingFeeHistory(this.extend(request, parameters));
        //
        //     {
        //         "rows":[
        //             {
        //                 "id":666666,
        //                 "symbol":"PERP_BTC_USDT",
        //                 "funding_rate":0.00001198,
        //                 "mark_price":28941.04000000,
        //                 "funding_fee":0.00069343,
        //                 "payment_type":"Pay",
        //                 "status":"COMPLETED",
        //                 "created_time":"1653616000.666",
        //                 "updated_time":"1653616000.605"
        //             }
        //         ],
        //         "meta":{
        //             "total":235,
        //             "records_per_page":25,
        //             "current_page":1
        //         },
        //         "success":true
        //     }
        //
        object result = this.safeList(response, "rows", new List<object>() {});
        return this.parseIncomes(result, market, since, limit);
    }

    public override object parseFundingRate(object fundingRate, object market = null)
    {
        //
        //         {
        //             "symbol":"PERP_AAVE_USDT",
        //             "est_funding_rate":-0.00003447,
        //             "est_funding_rate_timestamp":1653633959001,
        //             "last_funding_rate":-0.00002094,
        //             "last_funding_rate_timestamp":1653631200000,
        //             "next_funding_time":1653634800000
        //         }
        //
        //
        object symbol = this.safeString(fundingRate, "symbol");
        market = this.market(symbol);
        object nextFundingTimestamp = this.safeInteger(fundingRate, "next_funding_time");
        object estFundingRateTimestamp = this.safeInteger(fundingRate, "est_funding_rate_timestamp");
        object lastFundingRateTimestamp = this.safeInteger(fundingRate, "last_funding_rate_timestamp");
        return new Dictionary<string, object>() {
            { "info", fundingRate },
            { "symbol", getValue(market, "symbol") },
            { "markPrice", null },
            { "indexPrice", null },
            { "interestRate", this.parseNumber("0") },
            { "estimatedSettlePrice", null },
            { "timestamp", estFundingRateTimestamp },
            { "datetime", this.iso8601(estFundingRateTimestamp) },
            { "fundingRate", this.safeNumber(fundingRate, "est_funding_rate") },
            { "fundingTimestamp", nextFundingTimestamp },
            { "fundingDatetime", this.iso8601(nextFundingTimestamp) },
            { "nextFundingRate", null },
            { "nextFundingTimestamp", null },
            { "nextFundingDatetime", null },
            { "previousFundingRate", this.safeNumber(fundingRate, "last_funding_rate") },
            { "previousFundingTimestamp", lastFundingRateTimestamp },
            { "previousFundingDatetime", this.iso8601(lastFundingRateTimestamp) },
        };
    }

    public async override Task<object> fetchFundingRate(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object response = await this.v1PublicGetFundingRateSymbol(this.extend(request, parameters));
        //
        //     {
        //         "success":true,
        //         "timestamp":1653640572711,
        //         "symbol":"PERP_BTC_USDT",
        //         "est_funding_rate":0.00000738,
        //         "est_funding_rate_timestamp":1653640559003,
        //         "last_funding_rate":0.00000629,
        //         "last_funding_rate_timestamp":1653638400000,
        //         "next_funding_time":1653642000000
        //     }
        //
        return this.parseFundingRate(response, market);
    }

    public async override Task<object> fetchFundingRates(object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        symbols = this.marketSymbols(symbols);
        object response = await this.v1PublicGetFundingRates(parameters);
        //
        //     {
        //         "success":true,
        //         "rows":[
        //             {
        //                 "symbol":"PERP_AAVE_USDT",
        //                 "est_funding_rate":-0.00003447,
        //                 "est_funding_rate_timestamp":1653633959001,
        //                 "last_funding_rate":-0.00002094,
        //                 "last_funding_rate_timestamp":1653631200000,
        //                 "next_funding_time":1653634800000
        //             }
        //         ],
        //         "timestamp":1653633985646
        //     }
        //
        object rows = this.safeList(response, "rows", new List<object>() {});
        object result = this.parseFundingRates(rows);
        return this.filterByArray(result, "symbol", symbols);
    }

    public async override Task<object> fetchFundingRateHistory(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name woo#fetchFundingRateHistory
        * @description fetches historical funding rate prices
        * @see https://docs.woo.org/#get-funding-rate-history-for-one-market-public
        * @param {string} symbol unified symbol of the market to fetch the funding rate history for
        * @param {int} [since] timestamp in ms of the earliest funding rate to fetch
        * @param {int} [limit] the maximum amount of [funding rate structures]{@link https://docs.ccxt.com/#/?id=funding-rate-history-structure} to fetch
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {int} [params.until] timestamp in ms of the latest funding rate
        * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [availble parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
        * @returns {object[]} a list of [funding rate structures]{@link https://docs.ccxt.com/#/?id=funding-rate-history-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object paginate = false;
        var paginateparametersVariable = this.handleOptionAndParams(parameters, "fetchFundingRateHistory", "paginate");
        paginate = ((IList<object>)paginateparametersVariable)[0];
        parameters = ((IList<object>)paginateparametersVariable)[1];
        if (isTrue(paginate))
        {
            return await this.fetchPaginatedCallIncremental("fetchFundingRateHistory", symbol, since, limit, parameters, "page", 25);
        }
        object request = new Dictionary<string, object>() {};
        if (isTrue(!isEqual(symbol, null)))
        {
            object market = this.market(symbol);
            symbol = getValue(market, "symbol");
            ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["start_t"] = this.parseToInt(divide(since, 1000));
        }
        var requestparametersVariable = this.handleUntilOption("end_t", request, parameters, 0.001);
        request = ((IList<object>)requestparametersVariable)[0];
        parameters = ((IList<object>)requestparametersVariable)[1];
        object response = await this.v1PublicGetFundingRateHistory(this.extend(request, parameters));
        //
        //     {
        //         "success":true,
        //         "meta":{
        //             "total":2464,
        //             "records_per_page":25,
        //             "current_page":1
        //         },
        //         "rows":[
        //             {
        //                 "symbol":"PERP_BTC_USDT",
        //                 "funding_rate":0.00000629,
        //                 "funding_rate_timestamp":1653638400000,
        //                 "next_funding_time":1653642000000
        //             }
        //         ],
        //         "timestamp":1653640814885
        //     }
        //
        object result = this.safeList(response, "rows");
        object rates = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(result)); postFixIncrement(ref i))
        {
            object entry = getValue(result, i);
            object marketId = this.safeString(entry, "symbol");
            object timestamp = this.safeInteger(entry, "funding_rate_timestamp");
            ((IList<object>)rates).Add(new Dictionary<string, object>() {
                { "info", entry },
                { "symbol", this.safeSymbol(marketId) },
                { "fundingRate", this.safeNumber(entry, "funding_rate") },
                { "timestamp", timestamp },
                { "datetime", this.iso8601(timestamp) },
            });
        }
        object sorted = this.sortBy(rates, "timestamp");
        return this.filterBySymbolSinceLimit(sorted, symbol, since, limit);
    }

    public async override Task<object> setPositionMode(object hedged, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name woo#setPositionMode
        * @description set hedged to true or false for a market
        * @see https://docs.woo.org/#update-position-mode
        * @param {bool} hedged set to true to use HEDGE_MODE, false for ONE_WAY
        * @param {string} symbol not used by woo setPositionMode
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} response from the exchange
        */
        parameters ??= new Dictionary<string, object>();
        object hedgeMode = null;
        if (isTrue(hedged))
        {
            hedgeMode = "HEDGE_MODE";
        } else
        {
            hedgeMode = "ONE_WAY";
        }
        object request = new Dictionary<string, object>() {
            { "position_mode", hedgeMode },
        };
        object response = await this.v1PrivatePostClientPositionMode(this.extend(request, parameters));
        //
        //     {
        //         "success": true,
        //         "data": {},
        //         "timestamp": "1709195608551"
        //     }
        //
        return response;
    }

    public async override Task<object> fetchLeverage(object symbol, object parameters = null)
    {
        /**
        * @method
        * @name woo#fetchLeverage
        * @description fetch the set leverage for a market
        * @see https://docs.woo.org/#get-account-information-new
        * @param {string} symbol unified market symbol
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [leverage structure]{@link https://docs.ccxt.com/#/?id=leverage-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object response = await this.v3PrivateGetAccountinfo(parameters);
        //
        //     {
        //         "success": true,
        //         "data": {
        //             "applicationId": "dsa",
        //             "account": "dsa",
        //             "alias": "haha",
        //             "accountMode": "MARGIN",
        //             "leverage": 1,
        //             "takerFeeRate": 1,
        //             "makerFeeRate": 1,
        //             "interestRate": 1,
        //             "futuresTakerFeeRate": 1,
        //             "futuresMakerFeeRate": 1,
        //             "otpauth": true,
        //             "marginRatio": 1,
        //             "openMarginRatio": 1,
        //             "initialMarginRatio": 1,
        //             "maintenanceMarginRatio": 1,
        //             "totalCollateral": 1,
        //             "freeCollateral": 1,
        //             "totalAccountValue": 1,
        //             "totalVaultValue": 1,
        //             "totalStakingValue": 1
        //         },
        //         "timestamp": 1673323685109
        //     }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        return this.parseLeverage(data, market);
    }

    public override object parseLeverage(object leverage, object market = null)
    {
        object leverageValue = this.safeInteger(leverage, "leverage");
        return new Dictionary<string, object>() {
            { "info", leverage },
            { "symbol", getValue(market, "symbol") },
            { "marginMode", null },
            { "longLeverage", leverageValue },
            { "shortLeverage", leverageValue },
        };
    }

    public async override Task<object> setLeverage(object leverage, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        if (isTrue(isTrue((isLessThan(leverage, 1))) || isTrue((isGreaterThan(leverage, 20)))))
        {
            throw new BadRequest ((string)add(this.id, " leverage should be between 1 and 20")) ;
        }
        object request = new Dictionary<string, object>() {
            { "leverage", leverage },
        };
        return await this.v1PrivatePostClientLeverage(this.extend(request, parameters));
    }

    public async override Task<object> fetchPosition(object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object response = await this.v1PrivateGetPositionSymbol(this.extend(request, parameters));
        //
        //     {
        //         "symbol":"PERP_ETC_USDT",
        //         "holding":0.0,
        //         "pnl_24_h":0,
        //         "settle_price":0.0,
        //         "average_open_price":0,
        //         "success":true,
        //         "mark_price":22.6955,
        //         "pending_short_qty":0.0,
        //         "pending_long_qty":0.0,
        //         "fee_24_h":0,
        //         "timestamp":"1652231044.920"
        //     }
        //
        return this.parsePosition(response, market);
    }

    public async override Task<object> fetchPositions(object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.v3PrivateGetPositions(parameters);
        //
        //     {
        //         "success": true,
        //         "data": {
        //             "positions": [
        //                 {
        //                     "symbol": "0_symbol",
        //                     "holding": 1,
        //                     "pendingLongQty": 0,
        //                     "pendingShortQty": 1,
        //                     "settlePrice": 1,
        //                     "averageOpenPrice": 1,
        //                     "pnl24H": 1,
        //                     "fee24H": 1,
        //                     "markPrice": 1,
        //                     "estLiqPrice": 1,
        //                     "timestamp": 12321321
        //                 }
        //             ]
        //         },
        //         "timestamp": 1673323880342
        //     }
        //
        object result = this.safeDict(response, "data", new Dictionary<string, object>() {});
        object positions = this.safeList(result, "positions", new List<object>() {});
        return this.parsePositions(positions, symbols);
    }

    public override object parsePosition(object position, object market = null)
    {
        //
        //     {
        //         "symbol": "0_symbol",
        //         "holding": 1,
        //         "pendingLongQty": 0,
        //         "pendingShortQty": 1,
        //         "settlePrice": 1,
        //         "averageOpenPrice": 1,
        //         "pnl24H": 1,
        //         "fee24H": 1,
        //         "markPrice": 1,
        //         "estLiqPrice": 1,
        //         "timestamp": 12321321
        //     }
        //
        object contract = this.safeString(position, "symbol");
        market = this.safeMarket(contract, market);
        object size = this.safeString(position, "holding");
        object side = null;
        if (isTrue(Precise.stringGt(size, "0")))
        {
            side = "long";
        } else
        {
            side = "short";
        }
        object contractSize = this.safeString(market, "contractSize");
        object markPrice = this.safeString(position, "markPrice");
        object timestamp = this.safeTimestamp(position, "timestamp");
        object entryPrice = this.safeString(position, "averageOpenPrice");
        object priceDifference = Precise.stringSub(markPrice, entryPrice);
        object unrealisedPnl = Precise.stringMul(priceDifference, size);
        size = Precise.stringAbs(size);
        object notional = Precise.stringMul(size, markPrice);
        return this.safePosition(new Dictionary<string, object>() {
            { "info", position },
            { "id", null },
            { "symbol", this.safeString(market, "symbol") },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "lastUpdateTimestamp", null },
            { "initialMargin", null },
            { "initialMarginPercentage", null },
            { "maintenanceMargin", null },
            { "maintenanceMarginPercentage", null },
            { "entryPrice", this.parseNumber(entryPrice) },
            { "notional", this.parseNumber(notional) },
            { "leverage", null },
            { "unrealizedPnl", this.parseNumber(unrealisedPnl) },
            { "contracts", this.parseNumber(size) },
            { "contractSize", this.parseNumber(contractSize) },
            { "marginRatio", null },
            { "liquidationPrice", this.safeNumber(position, "estLiqPrice") },
            { "markPrice", this.parseNumber(markPrice) },
            { "lastPrice", null },
            { "collateral", null },
            { "marginMode", "cross" },
            { "marginType", null },
            { "side", side },
            { "percentage", null },
            { "hedged", null },
            { "stopLossPrice", null },
            { "takeProfitPrice", null },
        });
    }

    public async override Task<object> fetchConvertQuote(object fromCode, object toCode, object amount = null, object parameters = null)
    {
        /**
        * @method
        * @name woo#fetchConvertQuote
        * @description fetch a quote for converting from one currency to another
        * @see https://docs.woo.org/#get-quote-rfq
        * @param {string} fromCode the currency that you want to sell and convert from
        * @param {string} toCode the currency that you want to buy and convert into
        * @param {float} [amount] how much you want to trade in units of the from currency
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [conversion structure]{@link https://docs.ccxt.com/#/?id=conversion-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {
            { "sellToken", ((string)fromCode).ToUpper() },
            { "buyToken", ((string)toCode).ToUpper() },
            { "sellQuantity", this.numberToString(amount) },
        };
        object response = await this.v3PrivateGetConvertRfq(this.extend(request, parameters));
        //
        //     {
        //         "success": true,
        //         "data": {
        //             "quoteId": 123123123,
        //             "counterPartyId": "",
        //             "sellToken": "ETH",
        //             "sellQuantity": "0.0445",
        //             "buyToken": "USDT",
        //             "buyQuantity": "33.45",
        //             "buyPrice": "6.77",
        //             "expireTimestamp": 1659084466000,
        //             "message": 1659084466000
        //         }
        //     }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        object fromCurrencyId = this.safeString(data, "sellToken", fromCode);
        object fromCurrency = this.currency(fromCurrencyId);
        object toCurrencyId = this.safeString(data, "buyToken", toCode);
        object toCurrency = this.currency(toCurrencyId);
        return this.parseConversion(data, fromCurrency, toCurrency);
    }

    public async virtual Task<object> createConvertTrade(object id, object fromCode, object toCode, object amount = null, object parameters = null)
    {
        /**
        * @method
        * @name woo#createConvertTrade
        * @description convert from one currency to another
        * @see https://docs.woo.org/#send-quote-rft
        * @param {string} id the id of the trade that you want to make
        * @param {string} fromCode the currency that you want to sell and convert from
        * @param {string} toCode the currency that you want to buy and convert into
        * @param {float} [amount] how much you want to trade in units of the from currency
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [conversion structure]{@link https://docs.ccxt.com/#/?id=conversion-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {
            { "quoteId", id },
        };
        object response = await this.v3PrivatePostConvertRft(this.extend(request, parameters));
        //
        //     {
        //         "success": true,
        //         "data": {
        //             "quoteId": 123123123,
        //             "counterPartyId": "",
        //             "rftAccepted": 1 // 1 -> success; 2 -> processing; 3 -> fail
        //         }
        //     }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        return this.parseConversion(data);
    }

    public async virtual Task<object> fetchConvertTrade(object id, object code = null, object parameters = null)
    {
        /**
        * @method
        * @name woo#fetchConvertTrade
        * @description fetch the data for a conversion trade
        * @see https://docs.woo.org/#get-quote-trade
        * @param {string} id the id of the trade that you want to fetch
        * @param {string} [code] the unified currency code of the conversion trade
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [conversion structure]{@link https://docs.ccxt.com/#/?id=conversion-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {
            { "quoteId", id },
        };
        object response = await this.v3PrivateGetConvertTrade(this.extend(request, parameters));
        //
        //     {
        //         "success": true,
        //         "data": {
        //             "quoteId": 12,
        //             "buyAsset": "",
        //             "sellAsset": "",
        //             "buyAmount": 12.11,
        //             "sellAmount": 12.11,
        //             "tradeStatus": 12,
        //             "createdTime": ""
        //         }
        //     }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        object fromCurrencyId = this.safeString(data, "sellAsset");
        object toCurrencyId = this.safeString(data, "buyAsset");
        object fromCurrency = null;
        object toCurrency = null;
        if (isTrue(!isEqual(fromCurrencyId, null)))
        {
            fromCurrency = this.currency(fromCurrencyId);
        }
        if (isTrue(!isEqual(toCurrencyId, null)))
        {
            toCurrency = this.currency(toCurrencyId);
        }
        return this.parseConversion(data, fromCurrency, toCurrency);
    }

    public async virtual Task<object> fetchConvertTradeHistory(object code = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name woo#fetchConvertTradeHistory
        * @description fetch the users history of conversion trades
        * @see https://docs.woo.org/#get-quote-trades
        * @param {string} [code] the unified currency code
        * @param {int} [since] the earliest time in ms to fetch conversions for
        * @param {int} [limit] the maximum number of conversion structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {int} [params.until] timestamp in ms of the latest conversion to fetch
        * @returns {object[]} a list of [conversion structures]{@link https://docs.ccxt.com/#/?id=conversion-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        var requestparametersVariable = this.handleUntilOption("endTime", request, parameters);
        request = ((IList<object>)requestparametersVariable)[0];
        parameters = ((IList<object>)requestparametersVariable)[1];
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["startTime"] = since;
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["size"] = limit;
        }
        object response = await this.v3PrivateGetConvertTrades(this.extend(request, parameters));
        //
        //     {
        //         "success": true,
        //         "data": {
        //             "count": 12,
        //             "tradeVos":[
        //                 {
        //                     "quoteId": 12,
        //                     "buyAsset": "",
        //                     "sellAsset": "",
        //                     "buyAmount": 12.11,
        //                     "sellAmount": 12.11,
        //                     "tradeStatus": 12,
        //                     "createdTime": ""
        //                 }
        //                 ...
        //             ]
        //         }
        //     }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        object rows = this.safeList(data, "tradeVos", new List<object>() {});
        return this.parseConversions(rows, "sellAsset", "buyAsset", since, limit);
    }

    public override object parseConversion(object conversion, object fromCurrency = null, object toCurrency = null)
    {
        //
        // fetchConvertQuote
        //
        //     {
        //         "quoteId": 123123123,
        //         "counterPartyId": "",
        //         "sellToken": "ETH",
        //         "sellQuantity": "0.0445",
        //         "buyToken": "USDT",
        //         "buyQuantity": "33.45",
        //         "buyPrice": "6.77",
        //         "expireTimestamp": 1659084466000,
        //         "message": 1659084466000
        //     }
        //
        // createConvertTrade
        //
        //     {
        //         "quoteId": 123123123,
        //         "counterPartyId": "",
        //         "rftAccepted": 1 // 1 -> success; 2 -> processing; 3 -> fail
        //     }
        //
        // fetchConvertTrade, fetchConvertTradeHistory
        //
        //     {
        //         "quoteId": 12,
        //         "buyAsset": "",
        //         "sellAsset": "",
        //         "buyAmount": 12.11,
        //         "sellAmount": 12.11,
        //         "tradeStatus": 12,
        //         "createdTime": ""
        //     }
        //
        object timestamp = this.safeInteger2(conversion, "expireTimestamp", "createdTime");
        object fromCurr = this.safeString2(conversion, "sellToken", "buyAsset");
        object fromCode = this.safeCurrencyCode(fromCurr, fromCurrency);
        object to = this.safeString2(conversion, "buyToken", "sellAsset");
        object toCode = this.safeCurrencyCode(to, toCurrency);
        return new Dictionary<string, object>() {
            { "info", conversion },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "id", this.safeString(conversion, "quoteId") },
            { "fromCurrency", fromCode },
            { "fromAmount", this.safeNumber2(conversion, "sellQuantity", "sellAmount") },
            { "toCurrency", toCode },
            { "toAmount", this.safeNumber2(conversion, "buyQuantity", "buyAmount") },
            { "price", this.safeNumber(conversion, "buyPrice") },
            { "fee", null },
        };
    }

    public async override Task<object> fetchConvertCurrencies(object parameters = null)
    {
        /**
        * @method
        * @name woo#fetchConvertCurrencies
        * @description fetches all available currencies that can be converted
        * @see https://docs.woo.org/#get-quote-asset-info
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} an associative dictionary of currencies
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.v3PrivateGetConvertAssetInfo(parameters);
        //
        //     {
        //         "success": true,
        //         "rows": [
        //             {
        //                 "token": "BTC",
        //                 "tick": 0.0001,
        //                 "createdTime": "1575014248.99", // Unix epoch time in seconds
        //                 "updatedTime": "1575014248.99"  // Unix epoch time in seconds
        //             },
        //         ]
        //     }
        //
        object result = new Dictionary<string, object>() {};
        object data = this.safeList(response, "rows", new List<object>() {});
        for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
        {
            object entry = getValue(data, i);
            object id = this.safeString(entry, "token");
            object code = this.safeCurrencyCode(id);
            ((IDictionary<string,object>)result)[(string)code] = new Dictionary<string, object>() {
                { "info", entry },
                { "id", id },
                { "code", code },
                { "networks", null },
                { "type", null },
                { "name", null },
                { "active", null },
                { "deposit", null },
                { "withdraw", null },
                { "fee", null },
                { "precision", this.safeNumber(entry, "tick") },
                { "limits", new Dictionary<string, object>() {
                    { "amount", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                    { "withdraw", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                    { "deposit", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                } },
                { "created", this.safeTimestamp(entry, "createdTime") },
            };
        }
        return result;
    }

    public virtual object defaultNetworkCodeForCurrency(object code)
    {
        object currencyItem = this.currency(code);
        object networks = getValue(currencyItem, "networks");
        object networkKeys = new List<object>(((IDictionary<string,object>)networks).Keys);
        for (object i = 0; isLessThan(i, getArrayLength(networkKeys)); postFixIncrement(ref i))
        {
            object network = getValue(networkKeys, i);
            if (isTrue(isEqual(network, "ETH")))
            {
                return network;
            }
        }
        // if it was not returned according to above options, then return the first network of currency
        return this.safeValue(networkKeys, 0);
    }

    public override void setSandboxMode(object enable)
    {
        base.setSandboxMode(enable);
        ((IDictionary<string,object>)this.options)["sandboxMode"] = enable;
    }
}
