namespace ccxt;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

public partial class woo : Exchange
{
    public override object describe()
    {
        return this.deepExtend(base.describe(), new Dictionary<string, object>() {
            { "id", "woo" },
            { "name", "WOO X" },
            { "countries", new List<object>() {"KY"} },
            { "rateLimit", 100 },
            { "version", "v1" },
            { "certified", true },
            { "pro", true },
            { "hostname", "woox.io" },
            { "has", new Dictionary<string, object>() {
                { "CORS", null },
                { "spot", true },
                { "margin", true },
                { "swap", true },
                { "future", false },
                { "option", false },
                { "addMargin", true },
                { "cancelAllOrders", true },
                { "cancelAllOrdersAfter", true },
                { "cancelOrder", true },
                { "cancelWithdraw", false },
                { "closeAllPositions", false },
                { "closePosition", false },
                { "createConvertTrade", true },
                { "createDepositAddress", false },
                { "createMarketBuyOrderWithCost", true },
                { "createMarketOrder", false },
                { "createMarketOrderWithCost", false },
                { "createMarketSellOrderWithCost", true },
                { "createOrder", true },
                { "createOrderWithTakeProfitAndStopLoss", true },
                { "createReduceOnlyOrder", true },
                { "createStopLimitOrder", false },
                { "createStopLossOrder", true },
                { "createStopMarketOrder", false },
                { "createStopOrder", false },
                { "createTakeProfitOrder", true },
                { "createTrailingAmountOrder", true },
                { "createTrailingPercentOrder", true },
                { "createTriggerOrder", true },
                { "fetchAccounts", true },
                { "fetchBalance", true },
                { "fetchCanceledOrders", false },
                { "fetchClosedOrder", false },
                { "fetchClosedOrders", true },
                { "fetchConvertCurrencies", true },
                { "fetchConvertQuote", true },
                { "fetchConvertTrade", true },
                { "fetchConvertTradeHistory", true },
                { "fetchCurrencies", true },
                { "fetchDepositAddress", true },
                { "fetchDepositAddresses", false },
                { "fetchDepositAddressesByNetwork", false },
                { "fetchDeposits", true },
                { "fetchDepositsWithdrawals", true },
                { "fetchFundingHistory", true },
                { "fetchFundingInterval", true },
                { "fetchFundingIntervals", false },
                { "fetchFundingRate", true },
                { "fetchFundingRateHistory", true },
                { "fetchFundingRates", true },
                { "fetchIndexOHLCV", false },
                { "fetchLedger", true },
                { "fetchLeverage", true },
                { "fetchMarginAdjustmentHistory", false },
                { "fetchMarginMode", false },
                { "fetchMarkets", true },
                { "fetchMarkOHLCV", false },
                { "fetchMyTrades", true },
                { "fetchOHLCV", true },
                { "fetchOpenInterestHistory", false },
                { "fetchOpenOrder", false },
                { "fetchOpenOrders", true },
                { "fetchOrder", true },
                { "fetchOrderBook", true },
                { "fetchOrders", true },
                { "fetchOrderTrades", true },
                { "fetchPosition", true },
                { "fetchPositionHistory", false },
                { "fetchPositionMode", false },
                { "fetchPositions", true },
                { "fetchPositionsHistory", false },
                { "fetchPremiumIndexOHLCV", false },
                { "fetchStatus", true },
                { "fetchTicker", false },
                { "fetchTickers", false },
                { "fetchTime", true },
                { "fetchTrades", true },
                { "fetchTradingFee", true },
                { "fetchTradingFees", true },
                { "fetchTransactions", "emulated" },
                { "fetchTransfers", true },
                { "fetchWithdrawals", true },
                { "reduceMargin", false },
                { "sandbox", true },
                { "setLeverage", true },
                { "setMargin", false },
                { "setPositionMode", true },
                { "transfer", true },
                { "withdraw", true },
            } },
            { "timeframes", new Dictionary<string, object>() {
                { "1m", "1m" },
                { "5m", "5m" },
                { "15m", "15m" },
                { "30m", "30m" },
                { "1h", "1h" },
                { "4h", "4h" },
                { "12h", "12h" },
                { "1d", "1d" },
                { "1w", "1w" },
                { "1M", "1mon" },
                { "1y", "1y" },
            } },
            { "urls", new Dictionary<string, object>() {
                { "logo", "https://user-images.githubusercontent.com/1294454/150730761-1a00e5e0-d28c-480f-9e65-089ce3e6ef3b.jpg" },
                { "api", new Dictionary<string, object>() {
                    { "pub", "https://api-pub.woox.io" },
                    { "public", "https://api.{hostname}" },
                    { "private", "https://api.{hostname}" },
                } },
                { "test", new Dictionary<string, object>() {
                    { "pub", "https://api-pub.staging.woox.io" },
                    { "public", "https://api.staging.woox.io" },
                    { "private", "https://api.staging.woox.io" },
                } },
                { "www", "https://woox.io/" },
                { "doc", new List<object>() {"https://docs.woox.io/"} },
                { "fees", new List<object>() {"https://support.woox.io/hc/en-001/articles/4404611795353--Trading-Fees"} },
                { "referral", new Dictionary<string, object>() {
                    { "url", "https://woox.io/register?ref=DIJT0CNL" },
                    { "discount", 0.35 },
                } },
            } },
            { "api", new Dictionary<string, object>() {
                { "v1", new Dictionary<string, object>() {
                    { "pub", new Dictionary<string, object>() {
                        { "get", new Dictionary<string, object>() {
                            { "hist/kline", 10 },
                            { "hist/trades", 10 },
                        } },
                    } },
                    { "public", new Dictionary<string, object>() {
                        { "get", new Dictionary<string, object>() {
                            { "info", 1 },
                            { "info/{symbol}", 1 },
                            { "system_info", 1 },
                            { "market_trades", 1 },
                            { "token", 1 },
                            { "token_network", 1 },
                            { "funding_rates", 1 },
                            { "funding_rate/{symbol}", 1 },
                            { "funding_rate_history", 1 },
                            { "futures", 1 },
                            { "futures/{symbol}", 1 },
                            { "orderbook/{symbol}", 1 },
                            { "kline", 1 },
                        } },
                    } },
                    { "private", new Dictionary<string, object>() {
                        { "get", new Dictionary<string, object>() {
                            { "client/token", 1 },
                            { "order/{oid}", 1 },
                            { "client/order/{client_order_id}", 1 },
                            { "orders", 1 },
                            { "client/trade/{tid}", 1 },
                            { "order/{oid}/trades", 1 },
                            { "client/trades", 1 },
                            { "client/hist_trades", 1 },
                            { "staking/yield_history", 1 },
                            { "client/holding", 1 },
                            { "asset/deposit", 10 },
                            { "asset/history", 60 },
                            { "sub_account/all", 60 },
                            { "sub_account/assets", 60 },
                            { "sub_account/asset_detail", 60 },
                            { "sub_account/ip_restriction", 10 },
                            { "asset/main_sub_transfer_history", 30 },
                            { "token_interest", 60 },
                            { "token_interest/{token}", 60 },
                            { "interest/history", 60 },
                            { "interest/repay", 60 },
                            { "funding_fee/history", 30 },
                            { "positions", 3.33 },
                            { "position/{symbol}", 3.33 },
                            { "client/transaction_history", 60 },
                            { "client/futures_leverage", 60 },
                        } },
                        { "post", new Dictionary<string, object>() {
                            { "order", 1 },
                            { "order/cancel_all_after", 1 },
                            { "asset/main_sub_transfer", 30 },
                            { "asset/ltv", 30 },
                            { "asset/withdraw", 30 },
                            { "asset/internal_withdraw", 30 },
                            { "interest/repay", 60 },
                            { "client/account_mode", 120 },
                            { "client/position_mode", 5 },
                            { "client/leverage", 120 },
                            { "client/futures_leverage", 30 },
                            { "client/isolated_margin", 30 },
                        } },
                        { "delete", new Dictionary<string, object>() {
                            { "order", 1 },
                            { "client/order", 1 },
                            { "orders", 1 },
                            { "asset/withdraw", 120 },
                        } },
                    } },
                } },
                { "v2", new Dictionary<string, object>() {
                    { "private", new Dictionary<string, object>() {
                        { "get", new Dictionary<string, object>() {
                            { "client/holding", 1 },
                        } },
                    } },
                } },
                { "v3", new Dictionary<string, object>() {
                    { "public", new Dictionary<string, object>() {
                        { "get", new Dictionary<string, object>() {
                            { "systemInfo", 1 },
                            { "instruments", 1 },
                            { "token", 1 },
                            { "tokenNetwork", 1 },
                            { "tokenInfo", 1 },
                            { "marketTrades", 1 },
                            { "marketTradesHistory", 1 },
                            { "orderbook", 1 },
                            { "kline", 1 },
                            { "klineHistory", 1 },
                            { "futures", 1 },
                            { "fundingRate", 1 },
                            { "fundingRateHistory", 1 },
                            { "insuranceFund", 1 },
                        } },
                    } },
                    { "private", new Dictionary<string, object>() {
                        { "get", new Dictionary<string, object>() {
                            { "trade/order", 2 },
                            { "trade/orders", 1 },
                            { "trade/algoOrder", 1 },
                            { "trade/algoOrders", 1 },
                            { "trade/transaction", 1 },
                            { "trade/transactionHistory", 5 },
                            { "trade/tradingFee", 5 },
                            { "account/info", 60 },
                            { "account/tokenConfig", 1 },
                            { "account/symbolConfig", 1 },
                            { "account/subAccounts/all", 60 },
                            { "account/referral/summary", 60 },
                            { "account/referral/rewardHistory", 60 },
                            { "account/credentials", 60 },
                            { "asset/balances", 1 },
                            { "asset/token/history", 60 },
                            { "asset/transfer/history", 30 },
                            { "asset/wallet/history", 60 },
                            { "asset/wallet/deposit", 60 },
                            { "asset/staking/yieldHistory", 60 },
                            { "futures/positions", 3.33 },
                            { "futures/leverage", 60 },
                            { "futures/defaultMarginMode", 60 },
                            { "futures/fundingFee/history", 30 },
                            { "spotMargin/interestRate", 60 },
                            { "spotMargin/interestHistory", 60 },
                            { "spotMargin/maxMargin", 60 },
                            { "algo/order/{oid}", 1 },
                            { "algo/orders", 1 },
                            { "balances", 1 },
                            { "positions", 3.33 },
                            { "buypower", 1 },
                            { "convert/exchangeInfo", 1 },
                            { "convert/assetInfo", 1 },
                            { "convert/rfq", 60 },
                            { "convert/trade", 1 },
                            { "convert/trades", 1 },
                        } },
                        { "post", new Dictionary<string, object>() {
                            { "trade/order", 2 },
                            { "trade/algoOrder", 5 },
                            { "trade/cancelAllAfter", 1 },
                            { "account/tradingMode", 120 },
                            { "account/listenKey", 20 },
                            { "asset/transfer", 30 },
                            { "asset/wallet/withdraw", 60 },
                            { "spotMargin/leverage", 120 },
                            { "spotMargin/interestRepay", 60 },
                            { "algo/order", 5 },
                            { "convert/rft", 60 },
                        } },
                        { "put", new Dictionary<string, object>() {
                            { "trade/order", 2 },
                            { "trade/algoOrder", 2 },
                            { "futures/leverage", 60 },
                            { "futures/positionMode", 120 },
                            { "order/{oid}", 2 },
                            { "order/client/{client_order_id}", 2 },
                            { "algo/order/{oid}", 2 },
                            { "algo/order/client/{client_order_id}", 2 },
                        } },
                        { "delete", new Dictionary<string, object>() {
                            { "trade/order", 1 },
                            { "trade/orders", 1 },
                            { "trade/algoOrder", 1 },
                            { "trade/algoOrders", 1 },
                            { "trade/allOrders", 1 },
                            { "algo/order/{order_id}", 1 },
                            { "algo/orders/pending", 1 },
                            { "algo/orders/pending/{symbol}", 1 },
                            { "orders/pending", 1 },
                        } },
                    } },
                } },
            } },
            { "fees", new Dictionary<string, object>() {
                { "trading", new Dictionary<string, object>() {
                    { "tierBased", true },
                    { "percentage", true },
                    { "maker", this.parseNumber("0.0002") },
                    { "taker", this.parseNumber("0.0005") },
                } },
            } },
            { "options", new Dictionary<string, object>() {
                { "timeDifference", 0 },
                { "adjustForTimeDifference", false },
                { "sandboxMode", false },
                { "createMarketBuyOrderRequiresPrice", true },
                { "network-aliases-for-tokens", new Dictionary<string, object>() {
                    { "HT", "ERC20" },
                    { "OMG", "ERC20" },
                    { "UATOM", "ATOM" },
                    { "ZRX", "ZRX" },
                } },
                { "networks", new Dictionary<string, object>() {
                    { "TRX", "TRON" },
                    { "TRC20", "TRON" },
                    { "ERC20", "ETH" },
                    { "BEP20", "BSC" },
                    { "ARB", "Arbitrum" },
                } },
                { "networksById", new Dictionary<string, object>() {
                    { "TRX", "TRC20" },
                    { "TRON", "TRC20" },
                } },
                { "defaultNetworkCodeForCurrencies", new Dictionary<string, object>() {} },
                { "transfer", new Dictionary<string, object>() {
                    { "fillResponseFromRequest", true },
                } },
                { "brokerId", "bc830de7-50f3-460b-9ee0-f430f83f9dad" },
            } },
            { "features", new Dictionary<string, object>() {
                { "default", new Dictionary<string, object>() {
                    { "sandbox", true },
                    { "createOrder", new Dictionary<string, object>() {
                        { "marginMode", true },
                        { "triggerPrice", true },
                        { "triggerPriceType", new Dictionary<string, object>() {
                            { "last", true },
                            { "mark", true },
                            { "index", false },
                        } },
                        { "triggerDirection", false },
                        { "stopLossPrice", false },
                        { "takeProfitPrice", false },
                        { "attachedStopLossTakeProfit", null },
                        { "timeInForce", new Dictionary<string, object>() {
                            { "IOC", true },
                            { "FOK", true },
                            { "PO", true },
                            { "GTD", true },
                        } },
                        { "hedged", false },
                        { "trailing", true },
                        { "leverage", false },
                        { "marketBuyByCost", true },
                        { "marketBuyRequiresPrice", false },
                        { "selfTradePrevention", false },
                        { "iceberg", true },
                    } },
                    { "createOrders", null },
                    { "fetchMyTrades", new Dictionary<string, object>() {
                        { "marginMode", false },
                        { "limit", 500 },
                        { "daysBack", 90 },
                        { "untilDays", 10000 },
                        { "symbolRequired", false },
                    } },
                    { "fetchOrder", new Dictionary<string, object>() {
                        { "marginMode", false },
                        { "trigger", true },
                        { "trailing", false },
                        { "symbolRequired", false },
                    } },
                    { "fetchOpenOrders", new Dictionary<string, object>() {
                        { "marginMode", false },
                        { "limit", 500 },
                        { "trigger", true },
                        { "trailing", true },
                        { "symbolRequired", false },
                    } },
                    { "fetchOrders", new Dictionary<string, object>() {
                        { "marginMode", false },
                        { "limit", 500 },
                        { "daysBack", null },
                        { "untilDays", 100000 },
                        { "trigger", true },
                        { "trailing", true },
                        { "symbolRequired", false },
                    } },
                    { "fetchClosedOrders", new Dictionary<string, object>() {
                        { "marginMode", false },
                        { "limit", 500 },
                        { "daysBack", null },
                        { "daysBackCanceled", null },
                        { "untilDays", 100000 },
                        { "trigger", true },
                        { "trailing", true },
                        { "symbolRequired", false },
                    } },
                    { "fetchOHLCV", new Dictionary<string, object>() {
                        { "limit", 1000 },
                    } },
                } },
                { "spot", new Dictionary<string, object>() {
                    { "extends", "default" },
                } },
                { "forSwap", new Dictionary<string, object>() {
                    { "extends", "default" },
                    { "createOrder", new Dictionary<string, object>() {
                        { "hedged", true },
                    } },
                } },
                { "swap", new Dictionary<string, object>() {
                    { "linear", new Dictionary<string, object>() {
                        { "extends", "forSwap" },
                    } },
                    { "inverse", null },
                } },
                { "future", new Dictionary<string, object>() {
                    { "linear", null },
                    { "inverse", null },
                } },
            } },
            { "commonCurrencies", new Dictionary<string, object>() {} },
            { "exceptions", new Dictionary<string, object>() {
                { "exact", new Dictionary<string, object>() {
                    { "-1000", typeof(OperationFailed) },
                    { "-1001", typeof(AuthenticationError) },
                    { "-1002", typeof(AuthenticationError) },
                    { "-1003", typeof(RateLimitExceeded) },
                    { "-1004", typeof(BadRequest) },
                    { "-1005", typeof(BadRequest) },
                    { "-1006", typeof(BadRequest) },
                    { "-1007", typeof(BadRequest) },
                    { "-1008", typeof(InvalidOrder) },
                    { "-1009", typeof(BadRequest) },
                    { "-1012", typeof(BadRequest) },
                    { "-1101", typeof(InvalidOrder) },
                    { "-1102", typeof(InvalidOrder) },
                    { "-1103", typeof(InvalidOrder) },
                    { "-1104", typeof(InvalidOrder) },
                    { "-1105", typeof(InvalidOrder) },
                } },
                { "broad", new Dictionary<string, object>() {
                    { "Can not place", typeof(ExchangeError) },
                    { "maintenance", typeof(OnMaintenance) },
                    { "symbol must not be blank", typeof(BadRequest) },
                    { "The token is not supported", typeof(BadRequest) },
                    { "Your order and symbol are not valid or already canceled", typeof(BadRequest) },
                    { "Insufficient WOO. Please enable margin trading for leverage trading", typeof(BadRequest) },
                } },
            } },
            { "precisionMode", TICK_SIZE },
        });
    }

    /**
     * @method
     * @name woo#fetchStatus
     * @description the latest known information on the availability of the exchange API
     * @see https://developer.woox.io/api-reference/endpoint/public_data/systemInfo
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [status structure]{@link https://docs.ccxt.com/#/?id=exchange-status-structure}
     */
    public async override Task<object> fetchStatus(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object response = await this.v3PublicGetSystemInfo(parameters);
        //
        //     {
        //         "success": true,
        //         "data": {
        //             "status": 0,
        //             "msg": "System is functioning properly.",
        //             "estimatedEndTime": 1749963600362
        //         },
        //         "timestamp": 1751442989564
        //     }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        object status = this.safeString(data, "status");
        if (isTrue(isEqual(status, null)))
        {
            status = "error";
        } else if (isTrue(isEqual(status, "0")))
        {
            status = "ok";
        } else
        {
            status = "maintenance";
        }
        return new Dictionary<string, object>() {
            { "status", status },
            { "updated", null },
            { "eta", null },
            { "url", null },
            { "info", response },
        };
    }

    /**
     * @method
     * @name woo#fetchTime
     * @description fetches the current integer timestamp in milliseconds from the exchange server
     * @see https://developer.woox.io/api-reference/endpoint/public_data/systemInfo
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {int} the current integer timestamp in milliseconds from the exchange server
     */
    public async override Task<object> fetchTime(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object response = await this.v3PublicGetSystemInfo(parameters);
        //
        //     {
        //         "success": true,
        //         "data": {
        //             "status": 0,
        //             "msg": "System is functioning properly.",
        //             "estimatedEndTime": 1749963600362
        //         },
        //         "timestamp": 1751442989564
        //     }
        //
        return this.safeInteger(response, "timestamp");
    }

    /**
     * @method
     * @name woo#fetchMarkets
     * @description retrieves data on all markets for woo
     * @see https://developer.woox.io/api-reference/endpoint/public_data/instruments
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} an array of objects representing market data
     */
    public async override Task<object> fetchMarkets(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (isTrue(getValue(this.options, "adjustForTimeDifference")))
        {
            await this.loadTimeDifference();
        }
        object response = await this.v3PublicGetInstruments(parameters);
        //
        //     {
        //         "success": true,
        //         "data": {
        //             "rows": [
        //                 {
        //                     "symbol": "SPOT_AAVE_USDT",
        //                     "status": "TRADING",
        //                     "baseAsset": "AAVE",
        //                     "baseAssetMultiplier": 1,
        //                     "quoteAsset": "USDT",
        //                     "quoteMin": "0",
        //                     "quoteMax": "100000",
        //                     "quoteTick": "0.01",
        //                     "baseMin": "0.005",
        //                     "baseMax": "5000",
        //                     "baseTick": "0.0001",
        //                     "minNotional": "1",
        //                     "bidCapRatio": "1.1",
        //                     "bidFloorRatio": null,
        //                     "askCapRatio": null,
        //                     "askFloorRatio": "0.9",
        //                     "orderMode": "NORMAL",
        //                     "impactNotional": null,
        //                     "isAllowedRpi": false,
        //                     "tickGranularity": null
        //                 }
        //             ]
        //         },
        //         "timestamp": 1751512951338
        //     }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        object rows = this.safeList(data, "rows", new List<object>() {});
        return this.parseMarkets(rows);
    }

    public override object parseMarket(object market)
    {
        object marketId = this.safeString(market, "symbol");
        object parts = ((string)marketId).Split(new [] {((string)"_")}, StringSplitOptions.None).ToList<object>();
        object first = this.safeString(parts, 0);
        object marketType = null;
        object spot = false;
        object swap = false;
        if (isTrue(isEqual(first, "SPOT")))
        {
            spot = true;
            marketType = "spot";
        } else if (isTrue(isEqual(first, "PERP")))
        {
            swap = true;
            marketType = "swap";
        }
        object baseId = this.safeString(parts, 1);
        object quoteId = this.safeString(parts, 2);
        object bs = this.safeCurrencyCode(baseId);
        object quote = this.safeCurrencyCode(quoteId);
        object settleId = null;
        object settle = null;
        object symbol = add(add(bs, "/"), quote);
        object contractSize = null;
        object linear = null;
        object inverse = null;
        object margin = true;
        object contract = swap;
        if (isTrue(contract))
        {
            margin = false;
            settleId = this.safeString(parts, 2);
            settle = this.safeCurrencyCode(settleId);
            symbol = add(add(add(add(bs, "/"), quote), ":"), settle);
            contractSize = this.parseNumber("1");
            linear = true;
            inverse = false;
        }
        object active = isEqual(this.safeString(market, "status"), "TRADING");
        return new Dictionary<string, object>() {
            { "id", marketId },
            { "symbol", symbol },
            { "base", bs },
            { "quote", quote },
            { "settle", settle },
            { "baseId", baseId },
            { "quoteId", quoteId },
            { "settleId", settleId },
            { "type", marketType },
            { "spot", spot },
            { "margin", margin },
            { "swap", swap },
            { "future", false },
            { "option", false },
            { "active", active },
            { "contract", contract },
            { "linear", linear },
            { "inverse", inverse },
            { "contractSize", contractSize },
            { "expiry", null },
            { "expiryDatetime", null },
            { "strike", null },
            { "optionType", null },
            { "precision", new Dictionary<string, object>() {
                { "amount", this.safeNumber(market, "baseTick") },
                { "price", this.safeNumber(market, "quoteTick") },
            } },
            { "limits", new Dictionary<string, object>() {
                { "leverage", new Dictionary<string, object>() {
                    { "min", null },
                    { "max", null },
                } },
                { "amount", new Dictionary<string, object>() {
                    { "min", this.safeNumber(market, "baseMin") },
                    { "max", this.safeNumber(market, "baseMax") },
                } },
                { "price", new Dictionary<string, object>() {
                    { "min", this.safeNumber(market, "quoteMin") },
                    { "max", this.safeNumber(market, "quoteMax") },
                } },
                { "cost", new Dictionary<string, object>() {
                    { "min", this.safeNumber(market, "minNotional") },
                    { "max", null },
                } },
            } },
            { "created", null },
            { "info", market },
        };
    }

    /**
     * @method
     * @name woo#fetchTrades
     * @description get the list of most recent trades for a particular symbol
     * @see https://developer.woox.io/api-reference/endpoint/public_data/marketTrades
     * @param {string} symbol unified symbol of the market to fetch trades for
     * @param {int} [since] timestamp in ms of the earliest trade to fetch
     * @param {int} [limit] the maximum amount of trades to fetch
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
     */
    public async override Task<object> fetchTrades(object symbol, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        object response = await this.v3PublicGetMarketTrades(this.extend(request, parameters));
        //
        //     {
        //         "success": true,
        //         "data": {
        //             "rows": [
        //                 {
        //                     "symbol": "SPOT_BTC_USDT",
        //                     "side": "SELL",
        //                     "source": 0,
        //                     "executedPrice": "108741.01",
        //                     "executedQuantity": "0.02477",
        //                     "executedTimestamp": 1751513940144
        //                 }
        //             ]
        //         },
        //         "timestamp": 1751513988543
        //     }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        object rows = this.safeList(data, "rows", new List<object>() {});
        return this.parseTrades(rows, market, since, limit);
    }

    public override object parseTrade(object trade, object market = null)
    {
        //
        // public/market_trades
        //
        //     {
        //         "symbol": "SPOT_BTC_USDT",
        //         "side": "SELL",
        //         "source": 0,
        //         "executedPrice": "108741.01",
        //         "executedQuantity": "0.02477",
        //         "executedTimestamp": 1751513940144
        //     }
        //
        // fetchOrderTrades, fetchOrder
        //
        //     {
        //         "id": 1734947821,
        //         "symbol": "SPOT_LTC_USDT",
        //         "orderId": 60780383217,
        //         "executedPrice": 87.86,
        //         "executedQuantity": 0.1,
        //         "fee": 0.0001,
        //         "realizedPnl": null,
        //         "feeAsset": "LTC",
        //         "orderTag": "default",
        //         "side": "BUY",
        //         "executedTimestamp": "1752055173.630",
        //         "isMaker": 0
        //     }
        //
        object isFromFetchOrder = (inOp(trade, "id"));
        object timestampString = this.safeString2(trade, "executed_timestamp", "executedTimestamp");
        object timestamp = null;
        if (isTrue(!isEqual(timestampString, null)))
        {
            if (isTrue(isGreaterThan(getIndexOf(timestampString, "."), -1)))
            {
                timestamp = this.safeTimestamp2(trade, "executed_timestamp", "executedTimestamp");
            } else
            {
                timestamp = this.safeInteger(trade, "executedTimestamp");
            }
        }
        object marketId = this.safeString(trade, "symbol");
        market = this.safeMarket(marketId, market);
        object symbol = getValue(market, "symbol");
        object price = this.safeString2(trade, "executed_price", "executedPrice");
        object amount = this.safeString2(trade, "executed_quantity", "executedQuantity");
        object order_id = this.safeString2(trade, "order_id", "orderId");
        object fee = this.parseTokenAndFeeTemp(trade, new List<object>() {"fee_asset", "feeAsset"}, new List<object>() {"fee"});
        object feeCost = this.safeString(fee, "cost");
        if (isTrue(!isEqual(feeCost, null)))
        {
            ((IDictionary<string,object>)fee)["cost"] = feeCost;
        }
        object cost = Precise.stringMul(price, amount);
        object side = this.safeStringLower(trade, "side");
        object id = this.safeString(trade, "id");
        object takerOrMaker = null;
        if (isTrue(isFromFetchOrder))
        {
            object isMaker = isEqual(this.safeString2(trade, "is_maker", "isMaker"), "1");
            takerOrMaker = ((bool) isTrue(isMaker)) ? "maker" : "taker";
        }
        return this.safeTrade(new Dictionary<string, object>() {
            { "id", id },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "symbol", symbol },
            { "side", side },
            { "price", price },
            { "amount", amount },
            { "cost", cost },
            { "order", order_id },
            { "takerOrMaker", takerOrMaker },
            { "type", null },
            { "fee", fee },
            { "info", trade },
        }, market);
    }

    public virtual object parseTokenAndFeeTemp(object item, object feeTokenKeys, object feeAmountKeys)
    {
        object feeCost = this.safeStringN(item, feeAmountKeys);
        object fee = null;
        if (isTrue(!isEqual(feeCost, null)))
        {
            object feeCurrencyId = this.safeStringN(item, feeTokenKeys);
            object feeCurrencyCode = this.safeCurrencyCode(feeCurrencyId);
            fee = new Dictionary<string, object>() {
                { "cost", feeCost },
                { "currency", feeCurrencyCode },
            };
        }
        return fee;
    }

    public virtual object parseTradingFee(object fee, object market = null)
    {
        object marketId = this.safeString(fee, "symbol");
        object symbol = this.safeSymbol(marketId, market);
        return new Dictionary<string, object>() {
            { "info", fee },
            { "symbol", symbol },
            { "maker", this.parseNumber(Precise.stringDiv(this.safeString(fee, "makerFee"), "100")) },
            { "taker", this.parseNumber(Precise.stringDiv(this.safeString(fee, "takerFee"), "100")) },
            { "percentage", null },
            { "tierBased", null },
        };
    }

    /**
     * @method
     * @name woo#fetchTradingFee
     * @description fetch the trading fees for a market
     * @see https://developer.woox.io/api-reference/endpoint/trading/get_tradingFee
     * @param {string} symbol unified market symbol
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {boolean} [params.portfolioMargin] set to true if you would like to fetch trading fees in a portfolio margin account
     * @param {string} [params.subType] "linear" or "inverse"
     * @returns {object} a [fee structure]{@link https://docs.ccxt.com/#/?id=fee-structure}
     */
    public async override Task<object> fetchTradingFee(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object response = await this.v3PrivateGetTradeTradingFee(this.extend(request, parameters));
        //
        //     {
        //         "success": true,
        //         "data": {
        //             "symbol": "SPOT_BTC_USDT",
        //             "takerFee": "10",
        //             "makerFee": "8"
        //         },
        //         "timestamp": 1751858977368
        //     }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        return this.parseTradingFee(data, market);
    }

    /**
     * @method
     * @name woo#fetchTradingFees
     * @description fetch the trading fees for multiple markets
     * @see https://developer.woox.io/api-reference/endpoint/account/get_account_info
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a dictionary of [fee structures]{@link https://docs.ccxt.com/#/?id=fee-structure} indexed by market symbols
     */
    public async override Task<object> fetchTradingFees(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.v3PrivateGetAccountInfo(parameters);
        //
        //     {
        //         "success": true,
        //         "data": {
        //             "applicationId": "251bf5c4-f3c8-4544-bb8b-80001007c3c0",
        //             "account": "carlos_jose_lima@yahoo.com",
        //             "alias": "carlos_jose_lima@yahoo.com",
        //             "otpauth": true,
        //             "accountMode": "FUTURES",
        //             "positionMode": "ONE_WAY",
        //             "leverage": 0,
        //             "makerFeeRate": 0,
        //             "takerFeeRate": 0,
        //             "marginRatio": "10",
        //             "openMarginRatio": "10",
        //             "initialMarginRatio": "10",
        //             "maintenanceMarginRatio": "0.03",
        //             "totalCollateral": "165.55629469",
        //             "freeCollateral": "165.55629469",
        //             "totalAccountValue": "167.32418611",
        //             "totalTradingValue": "167.32418611",
        //             "totalVaultValue": "0",
        //             "totalStakingValue": "0",
        //             "totalLaunchpadValue": "0",
        //             "totalEarnValue": "0",
        //             "referrerID": null,
        //             "accountType": "Main"
        //         },
        //         "timestamp": 1752062807915
        //     }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        object maker = this.safeString(data, "makerFeeRate");
        object taker = this.safeString(data, "takerFeeRate");
        object result = new Dictionary<string, object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(this.symbols)); postFixIncrement(ref i))
        {
            object symbol = getValue(this.symbols, i);
            ((IDictionary<string,object>)result)[(string)symbol] = new Dictionary<string, object>() {
                { "info", response },
                { "symbol", symbol },
                { "maker", this.parseNumber(Precise.stringDiv(maker, "10000")) },
                { "taker", this.parseNumber(Precise.stringDiv(taker, "10000")) },
                { "percentage", true },
                { "tierBased", true },
            };
        }
        return result;
    }

    /**
     * @method
     * @name woo#fetchCurrencies
     * @description fetches all available currencies on an exchange
     * @see https://docs.woox.io/#available-token-public
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} an associative dictionary of currencies
     */
    public async override Task<object> fetchCurrencies(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object result = new Dictionary<string, object>() {};
        object tokenResponsePromise = this.v1PublicGetToken(parameters);
        //
        //    {
        //      "rows": [
        //         {
        //             "token": "ETH_USDT",
        //             "fullname": "Tether",
        //             "network": "ETH",
        //             "decimals": "6",
        //             "delisted": false,
        //             "balance_token": "USDT",
        //             "created_time": "1710123398",
        //             "updated_time": "1746528481",
        //             "can_collateral": true,
        //             "can_short": true
        //         },
        //         {
        //             "token": "BSC_USDT",
        //             "fullname": "Tether",
        //             "network": "BSC",
        //             "decimals": "18",
        //             "delisted": false,
        //             "balance_token": "USDT",
        //             "created_time": "1710123395",
        //             "updated_time": "1746528601",
        //             "can_collateral": true,
        //             "can_short": true
        //         },
        //         {
        //             "token": "ALGO",
        //             "fullname": "Algorand",
        //             "network": "ALGO",
        //             "decimals": "6",
        //             "delisted": false,
        //             "balance_token": "ALGO",
        //             "created_time": "1710123394",
        //             "updated_time": "1723087518",
        //             "can_collateral": true,
        //             "can_short": true
        //         },
        //         ...
        //     ],
        //     "success": true
        // }
        //
        // only make one request for currrencies...
        object tokenNetworkResponsePromise = this.v1PublicGetTokenNetwork(parameters);
        //
        // {
        //     "rows": [
        //         {
        //             "protocol": "ERC20",
        //             "network": "ETH",
        //             "token": "USDT",
        //             "name": "Ethereum (ERC20)",
        //             "minimum_withdrawal": "10.00000000",
        //             "withdrawal_fee": "2.00000000",
        //             "allow_deposit": "1",
        //             "allow_withdraw": "1"
        //         },
        //         {
        //             "protocol": "TRC20",
        //             "network": "TRX",
        //             "token": "USDT",
        //             "name": "Tron (TRC20)",
        //             "minimum_withdrawal": "10.00000000",
        //             "withdrawal_fee": "4.50000000",
        //             "allow_deposit": "1",
        //             "allow_withdraw": "1"
        //         },
        //         ...
        //     ],
        //     "success": true
        // }
        //
        var tokenResponsetokenNetworkResponseVariable = await promiseAll(new List<object>() {tokenResponsePromise, tokenNetworkResponsePromise});
        var tokenResponse = ((IList<object>) tokenResponsetokenNetworkResponseVariable)[0];
        var tokenNetworkResponse = ((IList<object>) tokenResponsetokenNetworkResponseVariable)[1];
        object tokenRows = this.safeList(tokenResponse, "rows", new List<object>() {});
        object tokenNetworkRows = this.safeList(tokenNetworkResponse, "rows", new List<object>() {});
        object networksById = this.groupBy(tokenNetworkRows, "token");
        object tokensById = this.groupBy(tokenRows, "balance_token");
        object currencyIds = new List<object>(((IDictionary<string,object>)tokensById).Keys);
        for (object i = 0; isLessThan(i, getArrayLength(currencyIds)); postFixIncrement(ref i))
        {
            object currencyId = getValue(currencyIds, i);
            object code = this.safeCurrencyCode(currencyId);
            object tokensByNetworkId = this.indexBy(getValue(tokensById, currencyId), "network");
            object chainsByNetworkId = this.indexBy(getValue(networksById, currencyId), "network");
            object keys = new List<object>(((IDictionary<string,object>)chainsByNetworkId).Keys);
            object resultingNetworks = new Dictionary<string, object>() {};
            for (object j = 0; isLessThan(j, getArrayLength(keys)); postFixIncrement(ref j))
            {
                object networkId = getValue(keys, j);
                object tokenEntry = this.safeDict(tokensByNetworkId, networkId, new Dictionary<string, object>() {});
                object networkEntry = this.safeDict(chainsByNetworkId, networkId, new Dictionary<string, object>() {});
                object networkCode = this.networkIdToCode(networkId, code);
                object specialNetworkId = this.safeString(tokenEntry, "token");
                ((IDictionary<string,object>)resultingNetworks)[(string)networkCode] = new Dictionary<string, object>() {
                    { "id", networkId },
                    { "currencyNetworkId", specialNetworkId },
                    { "network", networkCode },
                    { "active", null },
                    { "deposit", isEqual(this.safeString(networkEntry, "allow_deposit"), "1") },
                    { "withdraw", isEqual(this.safeString(networkEntry, "allow_withdraw"), "1") },
                    { "fee", this.safeNumber(networkEntry, "withdrawal_fee") },
                    { "precision", this.parseNumber(this.parsePrecision(this.safeString(tokenEntry, "decimals"))) },
                    { "limits", new Dictionary<string, object>() {
                        { "withdraw", new Dictionary<string, object>() {
                            { "min", this.safeNumber(networkEntry, "minimum_withdrawal") },
                            { "max", null },
                        } },
                        { "deposit", new Dictionary<string, object>() {
                            { "min", null },
                            { "max", null },
                        } },
                    } },
                    { "info", new List<object>() {networkEntry, tokenEntry} },
                };
            }
            ((IDictionary<string,object>)result)[(string)code] = this.safeCurrencyStructure(new Dictionary<string, object>() {
                { "id", currencyId },
                { "name", null },
                { "code", code },
                { "precision", null },
                { "active", null },
                { "fee", null },
                { "networks", resultingNetworks },
                { "deposit", null },
                { "withdraw", null },
                { "type", "crypto" },
                { "limits", new Dictionary<string, object>() {
                    { "deposit", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                    { "withdraw", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                } },
                { "info", new List<object>() {tokensByNetworkId, chainsByNetworkId} },
            });
        }
        return result;
    }

    /**
     * @method
     * @name woo#createMarketBuyOrderWithCost
     * @description create a market buy order by providing the symbol and cost
     * @see https://docs.woox.io/#send-order
     * @param {string} symbol unified symbol of the market to create an order in
     * @param {float} cost how much you want to trade in units of the quote currency
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> createMarketBuyOrderWithCost(object symbol, object cost, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        if (!isTrue(getValue(market, "spot")))
        {
            throw new NotSupported ((string)add(this.id, " createMarketBuyOrderWithCost() supports spot orders only")) ;
        }
        return await this.createOrder(symbol, "market", "buy", cost, 1, parameters);
    }

    /**
     * @method
     * @name woo#createMarketSellOrderWithCost
     * @description create a market sell order by providing the symbol and cost
     * @see https://docs.woox.io/#send-order
     * @param {string} symbol unified symbol of the market to create an order in
     * @param {float} cost how much you want to trade in units of the quote currency
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> createMarketSellOrderWithCost(object symbol, object cost, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        if (!isTrue(getValue(market, "spot")))
        {
            throw new NotSupported ((string)add(this.id, " createMarketSellOrderWithCost() supports spot orders only")) ;
        }
        return await this.createOrder(symbol, "market", "sell", cost, 1, parameters);
    }

    /**
     * @method
     * @name woo#createTrailingAmountOrder
     * @description create a trailing order by providing the symbol, type, side, amount, price and trailingAmount
     * @see https://docs.woox.io/#send-algo-order
     * @param {string} symbol unified symbol of the market to create an order in
     * @param {string} type 'market' or 'limit'
     * @param {string} side 'buy' or 'sell'
     * @param {float} amount how much you want to trade in units of the base currency, or number of contracts
     * @param {float} [price] the price for the order to be filled at, in units of the quote currency, ignored in market orders
     * @param {float} trailingAmount the quote amount to trail away from the current market price
     * @param {float} trailingTriggerPrice the price to activate a trailing order, default uses the price argument
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> createTrailingAmountOrder(object symbol, object type, object side, object amount, object price = null, object trailingAmount = null, object trailingTriggerPrice = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(trailingAmount, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " createTrailingAmountOrder() requires a trailingAmount argument")) ;
        }
        if (isTrue(isEqual(trailingTriggerPrice, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " createTrailingAmountOrder() requires a trailingTriggerPrice argument")) ;
        }
        ((IDictionary<string,object>)parameters)["trailingAmount"] = trailingAmount;
        ((IDictionary<string,object>)parameters)["trailingTriggerPrice"] = trailingTriggerPrice;
        return await this.createOrder(symbol, type, side, amount, price, parameters);
    }

    /**
     * @method
     * @name woo#createTrailingPercentOrder
     * @description create a trailing order by providing the symbol, type, side, amount, price and trailingPercent
     * @see https://docs.woox.io/#send-algo-order
     * @param {string} symbol unified symbol of the market to create an order in
     * @param {string} type 'market' or 'limit'
     * @param {string} side 'buy' or 'sell'
     * @param {float} amount how much you want to trade in units of the base currency, or number of contracts
     * @param {float} [price] the price for the order to be filled at, in units of the quote currency, ignored in market orders
     * @param {float} trailingPercent the percent to trail away from the current market price
     * @param {float} trailingTriggerPrice the price to activate a trailing order, default uses the price argument
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> createTrailingPercentOrder(object symbol, object type, object side, object amount, object price = null, object trailingPercent = null, object trailingTriggerPrice = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(trailingPercent, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " createTrailingPercentOrder() requires a trailingPercent argument")) ;
        }
        if (isTrue(isEqual(trailingTriggerPrice, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " createTrailingPercentOrder() requires a trailingTriggerPrice argument")) ;
        }
        ((IDictionary<string,object>)parameters)["trailingPercent"] = trailingPercent;
        ((IDictionary<string,object>)parameters)["trailingTriggerPrice"] = trailingTriggerPrice;
        return await this.createOrder(symbol, type, side, amount, price, parameters);
    }

    /**
     * @method
     * @name woo#createOrder
     * @description create a trade order
     * @see https://developer.woox.io/api-reference/endpoint/trading/post_order
     * @see https://developer.woox.io/api-reference/endpoint/trading/post_algo_order
     * @param {string} symbol unified symbol of the market to create an order in
     * @param {string} type 'market' or 'limit'
     * @param {string} side 'buy' or 'sell'
     * @param {float} amount how much of currency you want to trade in units of base currency
     * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.marginMode] *for swap markets only* 'cross' or 'isolated', default 'cross'
     * @param {float} [params.triggerPrice] The price a trigger order is triggered at
     * @param {object} [params.takeProfit] *takeProfit object in params* containing the triggerPrice at which the attached take profit order will be triggered (perpetual swap markets only)
     * @param {float} [params.takeProfit.triggerPrice] take profit trigger price
     * @param {object} [params.stopLoss] *stopLoss object in params* containing the triggerPrice at which the attached stop loss order will be triggered (perpetual swap markets only)
     * @param {float} [params.stopLoss.triggerPrice] stop loss trigger price
     * @param {float} [params.algoType] 'STOP' or 'TRAILING_STOP' or 'OCO' or 'CLOSE_POSITION'
     * @param {float} [params.cost] *spot market buy only* the quote quantity that can be used as an alternative for the amount
     * @param {string} [params.trailingAmount] the quote amount to trail away from the current market price
     * @param {string} [params.trailingPercent] the percent to trail away from the current market price
     * @param {string} [params.trailingTriggerPrice] the price to trigger a trailing order, default uses the price argument
     * @param {string} [params.position_side] 'SHORT' or 'LONG' - if position mode is HEDGE_MODE and the trading involves futures, then is required, otherwise this parameter is not required
     * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> createOrder(object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object reduceOnly = this.safeBool2(parameters, "reduceOnly", "reduce_only");
        parameters = this.omit(parameters, new List<object>() {"reduceOnly", "reduce_only"});
        object orderType = ((string)type).ToUpper();
        await this.loadMarkets();
        object market = this.market(symbol);
        object orderSide = ((string)side).ToUpper();
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
            { "side", orderSide },
        };
        object marginMode = null;
        var marginModeparametersVariable = this.handleMarginModeAndParams("createOrder", parameters);
        marginMode = ((IList<object>)marginModeparametersVariable)[0];
        parameters = ((IList<object>)marginModeparametersVariable)[1];
        if (isTrue(!isEqual(marginMode, null)))
        {
            ((IDictionary<string,object>)request)["marginMode"] = this.encodeMarginMode(marginMode);
        }
        object triggerPrice = this.safeString2(parameters, "triggerPrice", "stopPrice");
        object stopLoss = this.safeValue(parameters, "stopLoss");
        object takeProfit = this.safeValue(parameters, "takeProfit");
        object algoType = this.safeString(parameters, "algoType");
        object trailingTriggerPrice = this.safeString2(parameters, "trailingTriggerPrice", "activatedPrice", this.numberToString(price));
        object trailingAmount = this.safeString2(parameters, "trailingAmount", "callbackValue");
        object trailingPercent = this.safeString2(parameters, "trailingPercent", "callbackRate");
        object isTrailingAmountOrder = !isEqual(trailingAmount, null);
        object isTrailingPercentOrder = !isEqual(trailingPercent, null);
        object isTrailing = isTrue(isTrailingAmountOrder) || isTrue(isTrailingPercentOrder);
        object isConditional = isTrue(isTrue(isTrue(isTrue(isTrailing) || isTrue(!isEqual(triggerPrice, null))) || isTrue(!isEqual(stopLoss, null))) || isTrue(!isEqual(takeProfit, null))) || isTrue((!isEqual(this.safeValue(parameters, "childOrders"), null)));
        object isMarket = isEqual(orderType, "MARKET");
        object timeInForce = this.safeStringLower(parameters, "timeInForce");
        object postOnly = this.isPostOnly(isMarket, null, parameters);
        object clientOrderIdKey = ((bool) isTrue(isConditional)) ? "clientAlgoOrderId" : "clientOrderId";
        ((IDictionary<string,object>)request)["type"] = orderType; // LIMIT/MARKET/IOC/FOK/POST_ONLY/ASK/BID
        if (!isTrue(isConditional))
        {
            if (isTrue(postOnly))
            {
                ((IDictionary<string,object>)request)["type"] = "POST_ONLY";
            } else if (isTrue(isEqual(timeInForce, "fok")))
            {
                ((IDictionary<string,object>)request)["type"] = "FOK";
            } else if (isTrue(isEqual(timeInForce, "ioc")))
            {
                ((IDictionary<string,object>)request)["type"] = "IOC";
            }
        }
        if (isTrue(reduceOnly))
        {
            ((IDictionary<string,object>)request)["reduceOnly"] = reduceOnly;
        }
        if (isTrue(!isTrue(isMarket) && isTrue(!isEqual(price, null))))
        {
            ((IDictionary<string,object>)request)["price"] = this.priceToPrecision(symbol, price);
        }
        if (isTrue(isTrue(isMarket) && !isTrue(isConditional)))
        {
            // for market buy it requires the amount of quote currency to spend
            object cost = this.safeStringN(parameters, new List<object>() {"cost", "order_amount", "orderAmount"});
            parameters = this.omit(parameters, new List<object>() {"cost", "order_amount", "orderAmount"});
            object isPriceProvided = !isEqual(price, null);
            if (isTrue(isTrue(getValue(market, "spot")) && isTrue((isTrue(isPriceProvided) || isTrue((!isEqual(cost, null)))))))
            {
                object quoteAmount = null;
                if (isTrue(!isEqual(cost, null)))
                {
                    quoteAmount = this.costToPrecision(symbol, cost);
                } else
                {
                    object amountString = this.numberToString(amount);
                    object priceString = this.numberToString(price);
                    object costRequest = Precise.stringMul(amountString, priceString);
                    quoteAmount = this.costToPrecision(symbol, costRequest);
                }
                ((IDictionary<string,object>)request)["amount"] = quoteAmount;
            } else
            {
                ((IDictionary<string,object>)request)["quantity"] = this.amountToPrecision(symbol, amount);
            }
        } else if (isTrue(!isEqual(algoType, "POSITIONAL_TP_SL")))
        {
            ((IDictionary<string,object>)request)["quantity"] = this.amountToPrecision(symbol, amount);
        }
        object clientOrderId = this.safeStringN(parameters, new List<object>() {"clOrdID", "clientOrderId", "client_order_id"});
        if (isTrue(!isEqual(clientOrderId, null)))
        {
            ((IDictionary<string,object>)request)[(string)clientOrderIdKey] = clientOrderId;
        }
        if (isTrue(isTrailing))
        {
            if (isTrue(isEqual(trailingTriggerPrice, null)))
            {
                throw new ArgumentsRequired ((string)add(this.id, " createOrder() requires a trailingTriggerPrice parameter for trailing orders")) ;
            }
            ((IDictionary<string,object>)request)["activatedPrice"] = this.priceToPrecision(symbol, trailingTriggerPrice);
            ((IDictionary<string,object>)request)["algoType"] = "TRAILING_STOP";
            if (isTrue(isTrailingAmountOrder))
            {
                ((IDictionary<string,object>)request)["callbackValue"] = trailingAmount;
            } else if (isTrue(isTrailingPercentOrder))
            {
                object convertedTrailingPercent = Precise.stringDiv(trailingPercent, "100");
                ((IDictionary<string,object>)request)["callbackRate"] = convertedTrailingPercent;
            }
        } else if (isTrue(!isEqual(triggerPrice, null)))
        {
            if (isTrue(!isEqual(algoType, "TRAILING_STOP")))
            {
                ((IDictionary<string,object>)request)["triggerPrice"] = this.priceToPrecision(symbol, triggerPrice);
                ((IDictionary<string,object>)request)["algoType"] = "STOP";
            }
        } else if (isTrue(isTrue((!isEqual(stopLoss, null))) || isTrue((!isEqual(takeProfit, null)))))
        {
            ((IDictionary<string,object>)request)["algoType"] = "BRACKET";
            object outterOrder = new Dictionary<string, object>() {
                { "symbol", getValue(market, "id") },
                { "reduceOnly", false },
                { "algoType", "POSITIONAL_TP_SL" },
                { "childOrders", new List<object>() {} },
            };
            object childOrders = getValue(outterOrder, "childOrders");
            object closeSide = ((bool) isTrue((isEqual(orderSide, "BUY")))) ? "SELL" : "BUY";
            if (isTrue(!isEqual(stopLoss, null)))
            {
                object stopLossPrice = this.safeString(stopLoss, "triggerPrice", stopLoss);
                object stopLossOrder = new Dictionary<string, object>() {
                    { "side", closeSide },
                    { "algoType", "STOP_LOSS" },
                    { "triggerPrice", this.priceToPrecision(symbol, stopLossPrice) },
                    { "type", "CLOSE_POSITION" },
                    { "reduceOnly", true },
                };
                ((IList<object>)childOrders).Add(stopLossOrder);
            }
            if (isTrue(!isEqual(takeProfit, null)))
            {
                object takeProfitPrice = this.safeString(takeProfit, "triggerPrice", takeProfit);
                object takeProfitOrder = new Dictionary<string, object>() {
                    { "side", closeSide },
                    { "algoType", "TAKE_PROFIT" },
                    { "triggerPrice", this.priceToPrecision(symbol, takeProfitPrice) },
                    { "type", "CLOSE_POSITION" },
                    { "reduceOnly", true },
                };
                ((IList<object>)childOrders).Add(takeProfitOrder);
            }
            ((IDictionary<string,object>)request)["childOrders"] = new List<object>() {outterOrder};
        }
        parameters = this.omit(parameters, new List<object>() {"clOrdID", "clientOrderId", "client_order_id", "postOnly", "timeInForce", "stopPrice", "triggerPrice", "stopLoss", "takeProfit", "trailingPercent", "trailingAmount", "trailingTriggerPrice"});
        object response = null;
        if (isTrue(isConditional))
        {
            response = await this.v3PrivatePostTradeAlgoOrder(this.extend(request, parameters));
        } else
        {
            response = await this.v3PrivatePostTradeOrder(this.extend(request, parameters));
        }
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        data = this.safeDict(this.safeList(data, "rows"), 0, data);
        ((IDictionary<string,object>)data)["timestamp"] = this.safeString(response, "timestamp");
        return this.parseOrder(data, market);
    }

    public virtual object encodeMarginMode(object mode)
    {
        object modes = new Dictionary<string, object>() {
            { "cross", "CROSS" },
            { "isolated", "ISOLATED" },
        };
        return this.safeString(modes, mode, mode);
    }

    /**
     * @method
     * @name woo#editOrder
     * @description edit a trade order
     * @see https://docs.woox.io/#edit-order
     * @see https://docs.woox.io/#edit-order-by-client_order_id
     * @see https://docs.woox.io/#edit-algo-order
     * @see https://docs.woox.io/#edit-algo-order-by-client_order_id
     * @param {string} id order id
     * @param {string} symbol unified symbol of the market to create an order in
     * @param {string} type 'market' or 'limit'
     * @param {string} side 'buy' or 'sell'
     * @param {float} amount how much of currency you want to trade in units of base currency
     * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {float} [params.triggerPrice] The price a trigger order is triggered at
     * @param {float} [params.stopLossPrice] price to trigger stop-loss orders
     * @param {float} [params.takeProfitPrice] price to trigger take-profit orders
     * @param {string} [params.trailingAmount] the quote amount to trail away from the current market price
     * @param {string} [params.trailingPercent] the percent to trail away from the current market price
     * @param {string} [params.trailingTriggerPrice] the price to trigger a trailing order, default uses the price argument
     * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> editOrder(object id, object symbol, object type, object side, object amount = null, object price = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {};
        if (isTrue(!isEqual(price, null)))
        {
            ((IDictionary<string,object>)request)["price"] = this.priceToPrecision(symbol, price);
        }
        if (isTrue(!isEqual(amount, null)))
        {
            ((IDictionary<string,object>)request)["quantity"] = this.amountToPrecision(symbol, amount);
        }
        object clientOrderIdUnified = this.safeString2(parameters, "clOrdID", "clientOrderId");
        object clientOrderIdExchangeSpecific = this.safeString(parameters, "client_order_id", clientOrderIdUnified);
        object isByClientOrder = !isEqual(clientOrderIdExchangeSpecific, null);
        object triggerPrice = this.safeNumberN(parameters, new List<object>() {"triggerPrice", "stopPrice", "takeProfitPrice", "stopLossPrice"});
        if (isTrue(!isEqual(triggerPrice, null)))
        {
            ((IDictionary<string,object>)request)["triggerPrice"] = this.priceToPrecision(symbol, triggerPrice);
        }
        object trailingTriggerPrice = this.safeString2(parameters, "trailingTriggerPrice", "activatedPrice", this.numberToString(price));
        object trailingAmount = this.safeString2(parameters, "trailingAmount", "callbackValue");
        object trailingPercent = this.safeString2(parameters, "trailingPercent", "callbackRate");
        object isTrailingAmountOrder = !isEqual(trailingAmount, null);
        object isTrailingPercentOrder = !isEqual(trailingPercent, null);
        object isTrailing = isTrue(isTrailingAmountOrder) || isTrue(isTrailingPercentOrder);
        if (isTrue(isTrailing))
        {
            if (isTrue(!isEqual(trailingTriggerPrice, null)))
            {
                ((IDictionary<string,object>)request)["activatedPrice"] = this.priceToPrecision(symbol, trailingTriggerPrice);
            }
            if (isTrue(isTrailingAmountOrder))
            {
                ((IDictionary<string,object>)request)["callbackValue"] = trailingAmount;
            } else if (isTrue(isTrailingPercentOrder))
            {
                object convertedTrailingPercent = Precise.stringDiv(trailingPercent, "100");
                ((IDictionary<string,object>)request)["callbackRate"] = convertedTrailingPercent;
            }
        }
        parameters = this.omit(parameters, new List<object>() {"clOrdID", "clientOrderId", "client_order_id", "stopPrice", "triggerPrice", "takeProfitPrice", "stopLossPrice", "trailingTriggerPrice", "trailingAmount", "trailingPercent"});
        object isConditional = isTrue(isTrue(isTrailing) || isTrue((!isEqual(triggerPrice, null)))) || isTrue((!isEqual(this.safeValue(parameters, "childOrders"), null)));
        object response = null;
        if (isTrue(isByClientOrder))
        {
            ((IDictionary<string,object>)request)["client_order_id"] = clientOrderIdExchangeSpecific;
            if (isTrue(isConditional))
            {
                response = await this.v3PrivatePutAlgoOrderClientClientOrderId(this.extend(request, parameters));
            } else
            {
                response = await this.v3PrivatePutOrderClientClientOrderId(this.extend(request, parameters));
            }
        } else
        {
            ((IDictionary<string,object>)request)["oid"] = id;
            if (isTrue(isConditional))
            {
                response = await this.v3PrivatePutAlgoOrderOid(this.extend(request, parameters));
            } else
            {
                response = await this.v3PrivatePutOrderOid(this.extend(request, parameters));
            }
        }
        //
        //     {
        //         "code": 0,
        //         "data": {
        //             "status": "string",
        //             "success": true
        //         },
        //         "message": "string",
        //         "success": true,
        //         "timestamp": 0
        //     }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        return this.parseOrder(data, market);
    }

    /**
     * @method
     * @name woo#cancelOrder
     * @see https://developer.woox.io/api-reference/endpoint/trading/cancel_order
     * @see https://developer.woox.io/api-reference/endpoint/trading/cancel_algo_order
     * @description cancels an open order
     * @param {string} id order id
     * @param {string} symbol unified symbol of the market the order was made in
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {boolean} [params.trigger] whether the order is a trigger/algo order
     * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> cancelOrder(object id, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object isTrigger = this.safeBool2(parameters, "trigger", "stop", false);
        parameters = this.omit(parameters, new List<object>() {"trigger", "stop"});
        if (isTrue(!isTrue(isTrigger) && isTrue((isEqual(symbol, null)))))
        {
            throw new ArgumentsRequired ((string)add(this.id, " cancelOrder() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
        }
        object request = new Dictionary<string, object>() {};
        object clientOrderIdUnified = this.safeString2(parameters, "clOrdID", "clientOrderId");
        object clientOrderIdExchangeSpecific = this.safeString(parameters, "client_order_id", clientOrderIdUnified);
        parameters = this.omit(parameters, new List<object>() {"clOrdID", "clientOrderId", "client_order_id"});
        object isByClientOrder = !isEqual(clientOrderIdExchangeSpecific, null);
        object response = null;
        if (isTrue(isTrigger))
        {
            if (isTrue(isByClientOrder))
            {
                ((IDictionary<string,object>)request)["clientAlgoOrderId"] = clientOrderIdExchangeSpecific;
            } else
            {
                ((IDictionary<string,object>)request)["algoOrderId"] = id;
            }
            response = await this.v3PrivateDeleteTradeAlgoOrder(this.extend(request, parameters));
        } else
        {
            ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
            if (isTrue(isByClientOrder))
            {
                ((IDictionary<string,object>)request)["clientOrderId"] = clientOrderIdExchangeSpecific;
            } else
            {
                ((IDictionary<string,object>)request)["orderId"] = id;
            }
            response = await this.v3PrivateDeleteTradeOrder(this.extend(request, parameters));
        }
        //
        //     {
        //         "success": true,
        //         "data": {
        //             "status": "CANCEL_SENT"
        //         },
        //         "timestamp": 1751940315838
        //     }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        ((IDictionary<string,object>)data)["timestamp"] = this.safeString(response, "timestamp");
        if (isTrue(isByClientOrder))
        {
            ((IDictionary<string,object>)data)["clientOrderId"] = clientOrderIdExchangeSpecific;
        } else
        {
            ((IDictionary<string,object>)data)["orderId"] = id;
        }
        return this.parseOrder(data, market);
    }

    /**
     * @method
     * @name woo#cancelAllOrders
     * @see https://developer.woox.io/api-reference/endpoint/trading/cancel_all_order
     * @see https://developer.woox.io/api-reference/endpoint/trading/cancel_algo_orders
     * @description cancel all open orders in a market
     * @param {string} symbol unified market symbol
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {boolean} [params.trigger] whether the order is a trigger/algo order
     * @returns {object} an list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> cancelAllOrders(object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object trigger = this.safeBool2(parameters, "stop", "trigger");
        parameters = this.omit(parameters, new List<object>() {"stop", "trigger"});
        object request = new Dictionary<string, object>() {};
        if (isTrue(!isEqual(symbol, null)))
        {
            object market = this.market(symbol);
            ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
        }
        if (isTrue(trigger))
        {
            return await this.v3PrivateDeleteTradeAlgoOrders(parameters);
        }
        //
        //     {
        //         "success": true,
        //         "data": {
        //             "status": "CANCEL_ALL_SENT"
        //         },
        //         "timestamp": 1751941988134
        //     }
        //
        return await this.v3PrivateDeleteTradeOrders(this.extend(request, parameters));
    }

    /**
     * @method
     * @name woo#cancelAllOrdersAfter
     * @description dead man's switch, cancel all orders after the given timeout
     * @see https://developer.woox.io/api-reference/endpoint/trading/cancel_all_after
     * @param {number} timeout time in milliseconds, 0 represents cancel the timer
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} the api result
     */
    public async override Task<object> cancelAllOrdersAfter(object timeout, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {
            { "triggerAfter", ((bool) isTrue((isGreaterThan(timeout, 0)))) ? mathMin(timeout, 900000) : 0 },
        };
        object response = await this.v3PrivatePostTradeCancelAllAfter(this.extend(request, parameters));
        //
        // {
        //     "success": true,
        //     "timestamp": 123,
        //     "data": {
        //         "expectedTriggerTime": 123
        //     }
        // }
        //
        return response;
    }

    /**
     * @method
     * @name woo#fetchOrder
     * @see https://developer.woox.io/api-reference/endpoint/trading/get_order
     * @see https://developer.woox.io/api-reference/endpoint/trading/get_algo_order
     * @description fetches information on an order made by the user
     * @param {string} id the order id
     * @param {string} symbol unified symbol of the market the order was made in
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {boolean} [params.trigger] whether the order is a trigger/algo order
     * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> fetchOrder(object id, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
        }
        object trigger = this.safeBool2(parameters, "stop", "trigger");
        parameters = this.omit(parameters, new List<object>() {"stop", "trigger"});
        object request = new Dictionary<string, object>() {};
        object clientOrderId = this.safeString2(parameters, "clOrdID", "clientOrderId");
        object response = null;
        if (isTrue(trigger))
        {
            if (isTrue(!isEqual(clientOrderId, null)))
            {
                ((IDictionary<string,object>)request)["clientAlgoOrderId"] = id;
            } else
            {
                ((IDictionary<string,object>)request)["algoOrderId"] = id;
            }
            response = await this.v3PrivateGetTradeAlgoOrder(this.extend(request, parameters));
        } else
        {
            if (isTrue(!isEqual(clientOrderId, null)))
            {
                ((IDictionary<string,object>)request)["clientOrderId"] = clientOrderId;
            } else
            {
                ((IDictionary<string,object>)request)["orderId"] = id;
            }
            response = await this.v3PrivateGetTradeOrder(this.extend(request, parameters));
        }
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        return this.parseOrder(data, market);
    }

    /**
     * @method
     * @name woo#fetchOrders
     * @description fetches information on multiple orders made by the user
     * @see https://developer.woox.io/api-reference/endpoint/trading/get_orders
     * @see https://developer.woox.io/api-reference/endpoint/trading/get_algo_orders
     * @param {string} symbol unified market symbol of the market orders were made in
     * @param {int} [since] the earliest time in ms to fetch orders for
     * @param {int} [limit] the maximum number of order structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {boolean} [params.trigger] whether the order is a trigger/algo order
     * @param {boolean} [params.isTriggered] whether the order has been triggered (false by default)
     * @param {string} [params.side] 'buy' or 'sell'
     * @param {boolean} [params.paginate] set to true if you want to fetch orders with pagination
     * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> fetchOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object paginate = false;
        var paginateparametersVariable = this.handleOptionAndParams(parameters, "fetchOrders", "paginate");
        paginate = ((IList<object>)paginateparametersVariable)[0];
        parameters = ((IList<object>)paginateparametersVariable)[1];
        if (isTrue(paginate))
        {
            return await this.fetchPaginatedCallIncremental("fetchOrders", symbol, since, limit, parameters, "page", 500);
        }
        object request = new Dictionary<string, object>() {};
        object market = null;
        object trigger = this.safeBool2(parameters, "stop", "trigger");
        parameters = this.omit(parameters, new List<object>() {"stop", "trigger"});
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["startTime"] = since;
        }
        object until = this.safeInteger(parameters, "until"); // unified in milliseconds
        parameters = this.omit(parameters, new List<object>() {"until"});
        if (isTrue(!isEqual(until, null)))
        {
            ((IDictionary<string,object>)request)["endTime"] = until;
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["size"] = mathMin(limit, 500);
        }
        object response = null;
        if (isTrue(trigger))
        {
            response = await this.v3PrivateGetTradeAlgoOrders(this.extend(request, parameters));
        } else
        {
            response = await this.v3PrivateGetTradeOrders(this.extend(request, parameters));
        }
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        object orders = this.safeList(data, "rows", new List<object>() {});
        return this.parseOrders(orders, market, since, limit);
    }

    /**
     * @method
     * @name woo#fetchOpenOrders
     * @description fetches information on multiple orders made by the user
     * @see https://developer.woox.io/api-reference/endpoint/trading/get_orders
     * @see https://developer.woox.io/api-reference/endpoint/trading/get_algo_orders
     * @param {string} symbol unified market symbol of the market orders were made in
     * @param {int} [since] the earliest time in ms to fetch orders for
     * @param {int} [limit] the maximum number of order structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {boolean} [params.trigger] whether the order is a trigger/algo order
     * @param {boolean} [params.isTriggered] whether the order has been triggered (false by default)
     * @param {string} [params.side] 'buy' or 'sell'
     * @param {boolean} [params.trailing] set to true if you want to fetch trailing orders
     * @param {boolean} [params.paginate] set to true if you want to fetch orders with pagination
     * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> fetchOpenOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object extendedParams = this.extend(parameters, new Dictionary<string, object>() {
            { "status", "INCOMPLETE" },
        });
        return await this.fetchOrders(symbol, since, limit, extendedParams);
    }

    /**
     * @method
     * @name woo#fetchClosedOrders
     * @description fetches information on multiple orders made by the user
     * @see https://developer.woox.io/api-reference/endpoint/trading/get_orders
     * @see https://developer.woox.io/api-reference/endpoint/trading/get_algo_orders
     * @param {string} symbol unified market symbol of the market orders were made in
     * @param {int} [since] the earliest time in ms to fetch orders for
     * @param {int} [limit] the maximum number of order structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {boolean} [params.trigger] whether the order is a trigger/algo order
     * @param {boolean} [params.isTriggered] whether the order has been triggered (false by default)
     * @param {string} [params.side] 'buy' or 'sell'
     * @param {boolean} [params.trailing] set to true if you want to fetch trailing orders
     * @param {boolean} [params.paginate] set to true if you want to fetch orders with pagination
     * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> fetchClosedOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object extendedParams = this.extend(parameters, new Dictionary<string, object>() {
            { "status", "COMPLETED" },
        });
        return await this.fetchOrders(symbol, since, limit, extendedParams);
    }

    public virtual object parseTimeInForce(object timeInForce)
    {
        object timeInForces = new Dictionary<string, object>() {
            { "ioc", "IOC" },
            { "fok", "FOK" },
            { "post_only", "PO" },
        };
        return this.safeString(timeInForces, timeInForce, null);
    }

    public override object parseOrder(object order, object market = null)
    {
        //
        // createOrder
        //     {
        //         "orderId": 60667653330,
        //         "clientOrderId": 0,
        //         "type": "LIMIT",
        //         "price": 60,
        //         "quantity": 0.1,
        //         "amount": null,
        //         "bidAskLevel": null,
        //         "timestamp": 1751871779855
        //     }
        //
        // createOrder - algo
        //     {
        //         "orderId": "1578938",
        //         "clientOrderId": "0",
        //         "algoType": "STOP_LOSS",
        //         "quantity": "0.1",
        //         "timestamp": "1686149372216"
        //     }
        //
        // fetchOrder
        //     {
        //         "orderId": 60780315704,
        //         "clientOrderId": 0,
        //         "symbol": "SPOT_LTC_USDT",
        //         "orderTag": "default",
        //         "side": "BUY",
        //         "quantity": 0.1,
        //         "amount": null,
        //         "type": "LIMIT",
        //         "status": "NEW",
        //         "price": 60,
        //         "executed": 0,
        //         "visible": 0.1,
        //         "averageExecutedPrice": 0,
        //         "totalFee": 0,
        //         "feeAsset": "LTC",
        //         "totalRebate": 0,
        //         "rebateAsset": "USDT",
        //         "reduceOnly": false,
        //         "createdTime": "1752049062.496",
        //         "realizedPnl": null,
        //         "positionSide": "BOTH",
        //         "bidAskLevel": null
        //     }
        //
        // fetchOrder - algo
        //     {
        //         "algoOrderId": 10399260,
        //         "clientAlgoOrderId": 0,
        //         "rootAlgoOrderId": 10399260,
        //         "parentAlgoOrderId": 0,
        //         "symbol": "SPOT_LTC_USDT",
        //         "algoOrderTag": "default",
        //         "algoType": "TAKE_PROFIT",
        //         "side": "BUY",
        //         "quantity": 0.1,
        //         "isTriggered": false,
        //         "triggerPrice": 65,
        //         "triggerStatus": "USELESS",
        //         "type": "LIMIT",
        //         "rootAlgoStatus": "NEW",
        //         "algoStatus": "NEW",
        //         "triggerPriceType": "MARKET_PRICE",
        //         "price": 60,
        //         "triggerTime": "0",
        //         "totalExecutedQuantity": 0,
        //         "visibleQuantity": 0.1,
        //         "averageExecutedPrice": 0,
        //         "totalFee": 0,
        //         "feeAsset": "",
        //         "totalRebate": 0,
        //         "rebateAsset": "",
        //         "reduceOnly": false,
        //         "createdTime": "1752049747.732",
        //         "updatedTime": "1752049747.732",
        //         "positionSide": "BOTH"
        //     }
        //
        object timestamp = this.safeTimestamp(order, "createdTime");
        if (isTrue(isEqual(timestamp, null)))
        {
            timestamp = this.safeInteger(order, "timestamp");
        }
        object orderId = this.safeString2(order, "orderId", "algoOrderId");
        object clientOrderId = this.omitZero(this.safeString2(order, "clientOrderId", "clientAlgoOrderId")); // Somehow, this always returns 0 for limit order
        object marketId = this.safeString(order, "symbol");
        market = this.safeMarket(marketId, market);
        object symbol = getValue(market, "symbol");
        object price = this.safeString(order, "price");
        object amount = this.safeString(order, "quantity"); // This is base amount
        object cost = this.safeString(order, "amount"); // This is quote amount
        object orderType = this.safeStringLower(order, "type");
        object status = this.safeValue2(order, "status", "algoStatus");
        object side = this.safeStringLower(order, "side");
        object filled = this.omitZero(this.safeValue2(order, "executed", "totalExecutedQuantity"));
        object average = this.omitZero(this.safeString(order, "averageExecutedPrice"));
        // const remaining = Precise.stringSub (cost, filled);
        object fee = this.safeNumber(order, "totalFee");
        object feeCurrency = this.safeString(order, "feeAsset");
        object triggerPrice = this.safeNumber(order, "triggerPrice");
        object lastUpdateTimestamp = this.safeTimestamp(order, "updatedTime");
        return this.safeOrder(new Dictionary<string, object>() {
            { "id", orderId },
            { "clientOrderId", clientOrderId },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "lastTradeTimestamp", null },
            { "lastUpdateTimestamp", lastUpdateTimestamp },
            { "status", this.parseOrderStatus(status) },
            { "symbol", symbol },
            { "type", orderType },
            { "timeInForce", this.parseTimeInForce(orderType) },
            { "postOnly", null },
            { "reduceOnly", this.safeBool(order, "reduceOnly") },
            { "side", side },
            { "price", price },
            { "triggerPrice", triggerPrice },
            { "takeProfitPrice", null },
            { "stopLossPrice", null },
            { "average", average },
            { "amount", amount },
            { "filled", filled },
            { "remaining", null },
            { "cost", cost },
            { "trades", null },
            { "fee", new Dictionary<string, object>() {
                { "cost", fee },
                { "currency", feeCurrency },
            } },
            { "info", order },
        }, market);
    }

    public virtual object parseOrderStatus(object status)
    {
        if (isTrue(!isEqual(status, null)))
        {
            object statuses = new Dictionary<string, object>() {
                { "NEW", "open" },
                { "FILLED", "closed" },
                { "CANCEL_SENT", "canceled" },
                { "CANCEL_ALL_SENT", "canceled" },
                { "CANCELLED", "canceled" },
                { "PARTIAL_FILLED", "open" },
                { "REJECTED", "rejected" },
                { "INCOMPLETE", "open" },
                { "COMPLETED", "closed" },
            };
            return this.safeString(statuses, status, status);
        }
        return status;
    }

    /**
     * @method
     * @name woo#fetchOrderBook
     * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
     * @see https://developer.woox.io/api-reference/endpoint/public_data/orderbook
     * @param {string} symbol unified symbol of the market to fetch the order book for
     * @param {int} [limit] the maximum amount of order book entries to return
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
     */
    public async override Task<object> fetchOrderBook(object symbol, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["maxLevel"] = limit;
        }
        object response = await this.v3PublicGetOrderbook(this.extend(request, parameters));
        //
        // }
        //     {
        //         "success": true,
        //         "timestamp": 1751620923344,
        //         "data": {
        //             "asks": [
        //                 {
        //                     "price": "108924.86",
        //                     "quantity": "0.032126"
        //                 }
        //             ],
        //             "bids": [
        //                 {
        //                     "price": "108924.85",
        //                     "quantity": "1.714147"
        //                 }
        //             ]
        //         }
        //     }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        object timestamp = this.safeInteger(response, "timestamp");
        return this.parseOrderBook(data, symbol, timestamp, "bids", "asks", "price", "quantity");
    }

    /**
     * @method
     * @name woo#fetchOHLCV
     * @see https://developer.woox.io/api-reference/endpoint/public_data/klineHistory
     * @description fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
     * @param {string} symbol unified symbol of the market to fetch OHLCV data for
     * @param {string} timeframe the length of time each candle represents
     * @param {int} [since] timestamp in ms of the earliest candle to fetch
     * @param {int} [limit] max=1000, max=100 when since is defined and is less than (now - (999 * (timeframe in ms)))
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {int} [params.until] the latest time in ms to fetch entries for
     * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
     */
    public async override Task<object> fetchOHLCV(object symbol, object timeframe = null, object since = null, object limit = null, object parameters = null)
    {
        timeframe ??= "1m";
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
            { "type", this.safeString(this.timeframes, timeframe, timeframe) },
        };
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = mathMin(limit, 1000);
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["after"] = since;
        }
        object until = this.safeInteger(parameters, "until");
        parameters = this.omit(parameters, "until");
        if (isTrue(!isEqual(until, null)))
        {
            ((IDictionary<string,object>)request)["before"] = until;
        }
        object response = await this.v3PublicGetKlineHistory(this.extend(request, parameters));
        //
        //     {
        //         "success": true,
        //         "data": {
        //             "rows": [
        //                 {
        //                     "symbol": "SPOT_BTC_USDT",
        //                     "open": "108994.16",
        //                     "close": "108994.16",
        //                     "high": "108994.16",
        //                     "low": "108994.16",
        //                     "volume": "0",
        //                     "amount": "0",
        //                     "type": "1m",
        //                     "startTimestamp": 1751622120000,
        //                     "endTimestamp": 1751622180000
        //                 }
        //             ]
        //         },
        //         "timestamp": 1751622205410
        //     }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        object rows = this.safeList(data, "rows", new List<object>() {});
        return this.parseOHLCVs(rows, market, timeframe, since, limit);
    }

    public override object parseOHLCV(object ohlcv, object market = null)
    {
        return new List<object> {this.safeInteger(ohlcv, "startTimestamp"), this.safeNumber(ohlcv, "open"), this.safeNumber(ohlcv, "high"), this.safeNumber(ohlcv, "low"), this.safeNumber(ohlcv, "close"), this.safeNumber(ohlcv, "volume")};
    }

    /**
     * @method
     * @name woo#fetchOrderTrades
     * @description fetch all the trades made from a single order
     * @see https://docs.woox.io/#get-trades
     * @param {string} id order id
     * @param {string} symbol unified market symbol
     * @param {int} [since] the earliest time in ms to fetch trades for
     * @param {int} [limit] the maximum number of trades to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
     */
    public async override Task<object> fetchOrderTrades(object id, object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
        }
        object request = new Dictionary<string, object>() {
            { "oid", id },
        };
        object response = await this.v1PrivateGetOrderOidTrades(this.extend(request, parameters));
        // {
        //     "success": true,
        //     "rows": [
        //       {
        //         "id": "99111647",
        //         "symbol": "SPOT_WOO_USDT",
        //         "fee": "0.0024",
        //         "side": "BUY",
        //         "executed_timestamp": "1641482113.084",
        //         "order_id": "87541111",
        //         "order_tag": "default",
        //         "executed_price": "1",
        //         "executed_quantity": "12",
        //         "fee_asset": "WOO",
        //         "is_maker": "1"
        //       }
        //     ]
        // }
        object trades = this.safeList(response, "rows", new List<object>() {});
        return this.parseTrades(trades, market, since, limit, parameters);
    }

    /**
     * @method
     * @name woo#fetchMyTrades
     * @description fetch all trades made by the user
     * @see https://developer.woox.io/api-reference/endpoint/trading/get_transactions
     * @param {string} symbol unified market symbol
     * @param {int} [since] the earliest time in ms to fetch trades for
     * @param {int} [limit] the maximum number of trades structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {boolean} [params.paginate] set to true if you want to fetch trades with pagination
     * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
     */
    public async override Task<object> fetchMyTrades(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object paginate = false;
        var paginateparametersVariable = this.handleOptionAndParams(parameters, "fetchMyTrades", "paginate");
        paginate = ((IList<object>)paginateparametersVariable)[0];
        parameters = ((IList<object>)paginateparametersVariable)[1];
        if (isTrue(paginate))
        {
            return await this.fetchPaginatedCallIncremental("fetchMyTrades", symbol, since, limit, parameters, "page", 500);
        }
        object request = new Dictionary<string, object>() {};
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["startTime"] = since;
        }
        object until = this.safeInteger(parameters, "until"); // unified in milliseconds
        parameters = this.omit(parameters, new List<object>() {"until"});
        if (isTrue(!isEqual(until, null)))
        {
            ((IDictionary<string,object>)request)["endTime"] = until;
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        object response = await this.v3PrivateGetTradeTransactionHistory(this.extend(request, parameters));
        //
        //     {
        //         "success": true,
        //         "data": {
        //             "rows": [
        //                 {
        //                     "id": 1734947821,
        //                     "symbol": "SPOT_LTC_USDT",
        //                     "orderId": 60780383217,
        //                     "executedPrice": 87.86,
        //                     "executedQuantity": 0.1,
        //                     "fee": 0.0001,
        //                     "realizedPnl": null,
        //                     "feeAsset": "LTC",
        //                     "orderTag": "default",
        //                     "side": "BUY",
        //                     "executedTimestamp": "1752055173.630",
        //                     "isMaker": 0
        //                 }
        //             ],
        //             "meta": {
        //                 "total": 1,
        //                 "recordsPerPage": 100,
        //                 "currentPage": 1
        //             }
        //         },
        //         "timestamp": 1752055545121
        //     }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        object trades = this.safeList(data, "rows", new List<object>() {});
        return this.parseTrades(trades, market, since, limit, parameters);
    }

    /**
     * @method
     * @name woo#fetchAccounts
     * @description fetch all the accounts associated with a profile
     * @see https://developer.woox.io/api-reference/endpoint/account/get_account_info
     * @see https://developer.woox.io/api-reference/endpoint/account/sub_accounts
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a dictionary of [account structures]{@link https://docs.ccxt.com/#/?id=account-structure} indexed by the account type
     */
    public async override Task<object> fetchAccounts(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object mainAccountPromise = this.v3PrivateGetAccountInfo(parameters);
        //
        //     {
        //         "success": true,
        //         "data": {
        //             "applicationId": "251bf5c4-f3c8-4544-bb8b-80001007c3c0",
        //             "account": "carlos_jose_lima@yahoo.com",
        //             "alias": "carlos_jose_lima@yahoo.com",
        //             "otpauth": true,
        //             "accountMode": "FUTURES",
        //             "positionMode": "ONE_WAY",
        //             "leverage": 0,
        //             "marginRatio": "10",
        //             "openMarginRatio": "10",
        //             "initialMarginRatio": "10",
        //             "maintenanceMarginRatio": "0.03",
        //             "totalCollateral": "165.55629469",
        //             "freeCollateral": "165.55629469",
        //             "totalAccountValue": "167.32418611",
        //             "totalTradingValue": "167.32418611",
        //             "totalVaultValue": "0",
        //             "totalStakingValue": "0",
        //             "totalLaunchpadValue": "0",
        //             "totalEarnValue": "0",
        //             "referrerID": null,
        //             "accountType": "Main"
        //         },
        //         "timestamp": 1752062807915
        //     }
        //
        object subAccountPromise = this.v3PrivateGetAccountSubAccountsAll(parameters);
        //
        //     {
        //         "success": true,
        //         "data": {
        //             "rows": [
        //                 {
        //                     "applicationId": "6b43de5c-0955-4887-9862-d84e4689f9fe",
        //                     "name": "sub_account_2",
        //                     "createdTime": "1606897264.994"
        //                 },
        //             ]
        //         },
        //         "timestamp": 1721295317627
        //     }
        //
        var mainAccountResponsesubAccountResponseVariable = await promiseAll(new List<object>() {mainAccountPromise, subAccountPromise});
        var mainAccountResponse = ((IList<object>) mainAccountResponsesubAccountResponseVariable)[0];
        var subAccountResponse = ((IList<object>) mainAccountResponsesubAccountResponseVariable)[1];
        object mainData = this.safeDict(mainAccountResponse, "data", new Dictionary<string, object>() {});
        object mainRows = new List<object>() {mainData};
        object subData = this.safeDict(subAccountResponse, "data", new Dictionary<string, object>() {});
        object subRows = this.safeList(subData, "rows", new List<object>() {});
        object rows = this.arrayConcat(mainRows, subRows);
        return this.parseAccounts(rows, parameters);
    }

    public override object parseAccount(object account)
    {
        //
        //     {
        //         "applicationId": "251bf5c4-f3c8-4544-bb8b-80001007c3c0",
        //         "account": "carlos_jose_lima@yahoo.com",
        //         "alias": "carlos_jose_lima@yahoo.com",
        //         "otpauth": true,
        //         "accountMode": "FUTURES",
        //         "positionMode": "ONE_WAY",
        //         "leverage": 0,
        //         "marginRatio": "10",
        //         "openMarginRatio": "10",
        //         "initialMarginRatio": "10",
        //         "maintenanceMarginRatio": "0.03",
        //         "totalCollateral": "165.55629469",
        //         "freeCollateral": "165.55629469",
        //         "totalAccountValue": "167.32418611",
        //         "totalTradingValue": "167.32418611",
        //         "totalVaultValue": "0",
        //         "totalStakingValue": "0",
        //         "totalLaunchpadValue": "0",
        //         "totalEarnValue": "0",
        //         "referrerID": null,
        //         "accountType": "Main"
        //     }
        //
        //     {
        //         "applicationId": "6b43de5c-0955-4887-9862-d84e4689f9fe",
        //         "name": "sub_account_2",
        //         "createdTime": "1606897264.994"
        //     }
        //
        return new Dictionary<string, object>() {
            { "info", account },
            { "id", this.safeString(account, "applicationId") },
            { "name", this.safeStringN(account, new List<object>() {"name", "account", "alias"}) },
            { "code", null },
            { "type", this.safeStringLower(account, "accountType", "subaccount") },
        };
    }

    /**
     * @method
     * @name woo#fetchBalance
     * @description query for balance and get the amount of funds available for trading or funds locked in orders
     * @see https://docs.woox.io/#get-current-holding-get-balance-new
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
     */
    public async override Task<object> fetchBalance(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.v3PrivateGetBalances(parameters);
        //
        //     {
        //         "success": true,
        //         "data": {
        //             "holding": [
        //                 {
        //                     "token": "0_token",
        //                     "holding": 1,
        //                     "frozen": 0,
        //                     "staked": 0,
        //                     "unbonding": 0,
        //                     "vault": 0,
        //                     "interest": 0,
        //                     "pendingShortQty": 0,
        //                     "pendingLongQty": 0,
        //                     "availableBalance": 0,
        //                     "updatedTime": 312321.121
        //                 }
        //             ]
        //         },
        //         "timestamp": 1673323746259
        //     }
        //
        object data = this.safeDict(response, "data");
        return this.parseBalance(data);
    }

    public override object parseBalance(object response)
    {
        object result = new Dictionary<string, object>() {
            { "info", response },
        };
        object balances = this.safeList(response, "holding", new List<object>() {});
        for (object i = 0; isLessThan(i, getArrayLength(balances)); postFixIncrement(ref i))
        {
            object balance = getValue(balances, i);
            object code = this.safeCurrencyCode(this.safeString(balance, "token"));
            object account = this.account();
            ((IDictionary<string,object>)account)["total"] = this.safeString(balance, "holding");
            ((IDictionary<string,object>)account)["free"] = this.safeString(balance, "availableBalance");
            ((IDictionary<string,object>)result)[(string)code] = account;
        }
        return this.safeBalance(result);
    }

    /**
     * @method
     * @name woo#fetchDepositAddress
     * @description fetch the deposit address for a currency associated with this account
     * @see https://developer.woox.io/api-reference/endpoint/assets/get_wallet_deposit
     * @param {string} code unified currency code
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} an [address structure]{@link https://docs.ccxt.com/#/?id=address-structure}
     */
    public async override Task<object> fetchDepositAddress(object code, object parameters = null)
    {
        // this method is TODO because of networks unification
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        object networkCode = null;
        var networkCodeparametersVariable = this.handleNetworkCodeAndParams(parameters);
        networkCode = ((IList<object>)networkCodeparametersVariable)[0];
        parameters = ((IList<object>)networkCodeparametersVariable)[1];
        object request = new Dictionary<string, object>() {
            { "token", getValue(currency, "id") },
            { "network", this.networkCodeToId(networkCode) },
        };
        object response = await this.v3PrivateGetAssetWalletDeposit(this.extend(request, parameters));
        //
        //     {
        //         "success": true,
        //         "data": {
        //             "address": "0x31d64B3230f8baDD91dE1710A65DF536aF8f7cDa",
        //             "extra": ""
        //         },
        //         "timestamp": 1721300689532
        //     }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        return this.parseDepositAddress(data, currency);
    }

    public virtual object getDedicatedNetworkId(object currency, object parameters)
    {
        object networkCode = null;
        var networkCodeparametersVariable = this.handleNetworkCodeAndParams(parameters);
        networkCode = ((IList<object>)networkCodeparametersVariable)[0];
        parameters = ((IList<object>)networkCodeparametersVariable)[1];
        networkCode = this.networkIdToCode(networkCode, getValue(currency, "code"));
        object networkEntry = this.safeDict(getValue(currency, "networks"), networkCode);
        if (isTrue(isEqual(networkEntry, null)))
        {
            object supportedNetworks = new List<object>(((IDictionary<string,object>)getValue(currency, "networks")).Keys);
            throw new BadRequest ((string)add(add(this.id, "  can not determine a network code, please provide unified \"network\" param, one from the following: "), this.json(supportedNetworks))) ;
        }
        object currentyNetworkId = this.safeString(networkEntry, "currencyNetworkId");
        return new List<object>() {currentyNetworkId, parameters};
    }

    public override object parseDepositAddress(object depositEntry, object currency = null)
    {
        object address = this.safeString(depositEntry, "address");
        this.checkAddress(address);
        return new Dictionary<string, object>() {
            { "info", depositEntry },
            { "currency", this.safeString(currency, "code") },
            { "network", null },
            { "address", address },
            { "tag", this.safeString(depositEntry, "extra") },
        };
    }

    public async virtual Task<object> getAssetHistoryRows(object code = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object currency = null;
        if (isTrue(!isEqual(code, null)))
        {
            currency = this.currency(code);
            ((IDictionary<string,object>)request)["token"] = getValue(currency, "id");
        }
        object networkCode = null;
        var networkCodeparametersVariable = this.handleNetworkCodeAndParams(parameters);
        networkCode = ((IList<object>)networkCodeparametersVariable)[0];
        parameters = ((IList<object>)networkCodeparametersVariable)[1];
        if (isTrue(!isEqual(networkCode, null)))
        {
            ((IDictionary<string,object>)request)["network"] = this.networkCodeToId(networkCode);
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["startTime"] = since;
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["size"] = mathMin(limit, 1000);
        }
        object transactionType = this.safeString(parameters, "type");
        parameters = this.omit(parameters, "type");
        if (isTrue(!isEqual(transactionType, null)))
        {
            ((IDictionary<string,object>)request)["type"] = transactionType;
        }
        object response = await this.v3PrivateGetAssetWalletHistory(this.extend(request, parameters));
        //
        //     {
        //         "success": true,
        //         "data": {
        //             "rows": [
        //                 {
        //                     "createdTime": "1734964440.523",
        //                     "updatedTime": "1734964614.081",
        //                     "id": "24122314340000585",
        //                     "externalId": "241223143600621",
        //                     "applicationId": "251bf5c4-f3c8-4544-bb8b-80001007c3c0",
        //                     "token": "ARB_USDCNATIVE",
        //                     "targetAddress": "0x4d6802d2736daa85e6242ef0dc0f00aa0e68f635",
        //                     "sourceAddress": "0x63DFE4e34A3bFC00eB0220786238a7C6cEF8Ffc4",
        //                     "extra": "",
        //                     "type": "BALANCE",
        //                     "tokenSide": "WITHDRAW",
        //                     "amount": "10.00000000",
        //                     "txId": "0x891ade0a47fd55466bb9d06702bea4edcb75ed9367d9afbc47b93a84f496d2e6",
        //                     "feeToken": "USDC",
        //                     "feeAmount": "2",
        //                     "status": "COMPLETED",
        //                     "confirmingThreshold": null,
        //                     "confirmedNumber": null
        //                 }
        //             ],
        //             "meta": {
        //                 "total": 1,
        //                 "records_per_page": 25,
        //                 "current_page": 1
        //             }
        //         },
        //         "timestamp": 1752485344719
        //     }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        return new List<object>() {currency, this.safeList(data, "rows", new List<object>() {})};
    }

    /**
     * @method
     * @name woo#fetchLedger
     * @description fetch the history of changes, actions done by the user or operations that altered balance of the user
     * @see https://developer.woox.io/api-reference/endpoint/assets/get_wallet_history
     * @param {string} [code] unified currency code, default is undefined
     * @param {int} [since] timestamp in ms of the earliest ledger entry, default is undefined
     * @param {int} [limit] max number of ledger entries to return, default is undefined
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [ledger structure]{@link https://docs.ccxt.com/#/?id=ledger}
     */
    public async override Task<object> fetchLedger(object code = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object currencyRows = await this.getAssetHistoryRows(code, since, limit, parameters);
        object currency = this.safeValue(currencyRows, 0);
        object rows = this.safeList(currencyRows, 1);
        return this.parseLedger(rows, currency, since, limit, parameters);
    }

    public override object parseLedgerEntry(object item, object currency = null)
    {
        //
        //     {
        //         "createdTime": "1734964440.523",
        //         "updatedTime": "1734964614.081",
        //         "id": "24122314340000585",
        //         "externalId": "241223143600621",
        //         "applicationId": "251bf5c4-f3c8-4544-bb8b-80001007c3c0",
        //         "token": "ARB_USDCNATIVE",
        //         "targetAddress": "0x4d6802d2736daa85e6242ef0dc0f00aa0e68f635",
        //         "sourceAddress": "0x63DFE4e34A3bFC00eB0220786238a7C6cEF8Ffc4",
        //         "extra": "",
        //         "type": "BALANCE",
        //         "tokenSide": "WITHDRAW",
        //         "amount": "10.00000000",
        //         "txId": "0x891ade0a47fd55466bb9d06702bea4edcb75ed9367d9afbc47b93a84f496d2e6",
        //         "feeToken": "USDC",
        //         "feeAmount": "2",
        //         "status": "COMPLETED",
        //         "confirmingThreshold": null,
        //         "confirmedNumber": null
        //     }
        //
        object networkizedCode = this.safeString(item, "token");
        object code = this.safeCurrencyCode(networkizedCode, currency);
        currency = this.safeCurrency(code, currency);
        object amount = this.safeNumber(item, "amount");
        object side = this.safeString(item, "tokenSide");
        object direction = ((bool) isTrue((isEqual(side, "DEPOSIT")))) ? "in" : "out";
        object timestamp = this.safeTimestamp(item, "createdTime");
        object fee = this.parseTokenAndFeeTemp(item, new List<object>() {"feeToken"}, new List<object>() {"feeAmount"});
        return this.safeLedgerEntry(new Dictionary<string, object>() {
            { "info", item },
            { "id", this.safeString(item, "id") },
            { "currency", code },
            { "account", this.safeString(item, "account") },
            { "referenceAccount", null },
            { "referenceId", this.safeString(item, "txId") },
            { "status", this.parseTransactionStatus(this.safeString(item, "status")) },
            { "amount", amount },
            { "before", null },
            { "after", null },
            { "direction", direction },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "type", this.parseLedgerEntryType(this.safeString(item, "type")) },
            { "fee", fee },
        }, currency);
    }

    public virtual object parseLedgerEntryType(object type)
    {
        object types = new Dictionary<string, object>() {
            { "BALANCE", "transaction" },
            { "COLLATERAL", "transfer" },
        };
        return this.safeString(types, type, type);
    }

    public virtual object getCurrencyFromChaincode(object networkizedCode, object currency)
    {
        if (isTrue(!isEqual(currency, null)))
        {
            return currency;
        } else
        {
            object parts = ((string)networkizedCode).Split(new [] {((string)"_")}, StringSplitOptions.None).ToList<object>();
            object partsLength = getArrayLength(parts);
            object firstPart = this.safeString(parts, 0);
            object currencyId = this.safeString(parts, 1, firstPart);
            if (isTrue(isGreaterThan(partsLength, 2)))
            {
                currencyId = add(currencyId, add("_", this.safeString(parts, 2)));
            }
            currency = this.safeCurrency(currencyId);
        }
        return currency;
    }

    /**
     * @method
     * @name woo#fetchDeposits
     * @description fetch all deposits made to an account
     * @see https://developer.woox.io/api-reference/endpoint/assets/get_wallet_history
     * @param {string} code unified currency code
     * @param {int} [since] the earliest time in ms to fetch deposits for
     * @param {int} [limit] the maximum number of deposits structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
     */
    public async override Task<object> fetchDeposits(object code = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object request = new Dictionary<string, object>() {
            { "tokenSide", "DEPOSIT" },
        };
        return await this.fetchDepositsWithdrawals(code, since, limit, this.extend(request, parameters));
    }

    /**
     * @method
     * @name woo#fetchWithdrawals
     * @description fetch all withdrawals made from an account
     * @see https://developer.woox.io/api-reference/endpoint/assets/get_wallet_history
     * @param {string} code unified currency code
     * @param {int} [since] the earliest time in ms to fetch withdrawals for
     * @param {int} [limit] the maximum number of withdrawals structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
     */
    public async override Task<object> fetchWithdrawals(object code = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object request = new Dictionary<string, object>() {
            { "tokenSide", "WITHDRAW" },
        };
        return await this.fetchDepositsWithdrawals(code, since, limit, this.extend(request, parameters));
    }

    /**
     * @method
     * @name woo#fetchDepositsWithdrawals
     * @description fetch history of deposits and withdrawals
     * @see https://developer.woox.io/api-reference/endpoint/assets/get_wallet_history
     * @param {string} [code] unified currency code for the currency of the deposit/withdrawals, default is undefined
     * @param {int} [since] timestamp in ms of the earliest deposit/withdrawal, default is undefined
     * @param {int} [limit] max number of deposit/withdrawals to return, default is undefined
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a list of [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
     */
    public async override Task<object> fetchDepositsWithdrawals(object code = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object request = new Dictionary<string, object>() {
            { "type", "BALANCE" },
        };
        object currencyRows = await this.getAssetHistoryRows(code, since, limit, this.extend(request, parameters));
        object currency = this.safeValue(currencyRows, 0);
        object rows = this.safeList(currencyRows, 1);
        return this.parseTransactions(rows, currency, since, limit, parameters);
    }

    public override object parseTransaction(object transaction, object currency = null)
    {
        //
        //     {
        //         "createdTime": "1734964440.523",
        //         "updatedTime": "1734964614.081",
        //         "id": "24122314340000585",
        //         "externalId": "241223143600621",
        //         "applicationId": "251bf5c4-f3c8-4544-bb8b-80001007c3c0",
        //         "token": "ARB_USDCNATIVE",
        //         "targetAddress": "0x4d6802d2736daa85e6242ef0dc0f00aa0e68f635",
        //         "sourceAddress": "0x63DFE4e34A3bFC00eB0220786238a7C6cEF8Ffc4",
        //         "extra": "",
        //         "type": "BALANCE",
        //         "tokenSide": "WITHDRAW",
        //         "amount": "10.00000000",
        //         "txId": "0x891ade0a47fd55466bb9d06702bea4edcb75ed9367d9afbc47b93a84f496d2e6",
        //         "feeToken": "USDC",
        //         "feeAmount": "2",
        //         "status": "COMPLETED",
        //         "confirmingThreshold": null,
        //         "confirmedNumber": null
        //     }
        //
        object networkizedCode = this.safeString(transaction, "token");
        object currencyDefined = this.getCurrencyFromChaincode(networkizedCode, currency);
        object code = getValue(currencyDefined, "code");
        object movementDirection = this.safeStringLower2(transaction, "token_side", "tokenSide");
        if (isTrue(isEqual(movementDirection, "withdraw")))
        {
            movementDirection = "withdrawal";
        }
        object fee = this.parseTokenAndFeeTemp(transaction, new List<object>() {"fee_token", "feeToken"}, new List<object>() {"fee_amount", "feeAmount"});
        object addressTo = this.safeString2(transaction, "target_address", "targetAddress");
        object addressFrom = this.safeString2(transaction, "source_address", "sourceAddress");
        object timestamp = this.safeTimestamp2(transaction, "created_time", "createdTime");
        return new Dictionary<string, object>() {
            { "info", transaction },
            { "id", this.safeStringN(transaction, new List<object>() {"id", "withdraw_id", "withdrawId"}) },
            { "txid", this.safeString2(transaction, "tx_id", "txId") },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "address", null },
            { "addressFrom", addressFrom },
            { "addressTo", addressTo },
            { "tag", this.safeString(transaction, "extra") },
            { "tagFrom", null },
            { "tagTo", null },
            { "type", movementDirection },
            { "amount", this.safeNumber(transaction, "amount") },
            { "currency", code },
            { "status", this.parseTransactionStatus(this.safeString(transaction, "status")) },
            { "updated", this.safeTimestamp2(transaction, "updated_time", "updatedTime") },
            { "comment", null },
            { "internal", null },
            { "fee", fee },
            { "network", null },
        };
    }

    public virtual object parseTransactionStatus(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "NEW", "pending" },
            { "CONFIRMING", "pending" },
            { "PROCESSING", "pending" },
            { "COMPLETED", "ok" },
            { "CANCELED", "canceled" },
        };
        return this.safeString(statuses, status, status);
    }

    /**
     * @method
     * @name woo#transfer
     * @description transfer currency internally between wallets on the same account
     * @see https://docs.woox.io/#get-transfer-history
     * @param {string} code unified currency code
     * @param {float} amount amount to transfer
     * @param {string} fromAccount account to transfer from
     * @param {string} toAccount account to transfer to
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [transfer structure]{@link https://docs.ccxt.com/#/?id=transfer-structure}
     */
    public async override Task<object> transfer(object code, object amount, object fromAccount, object toAccount, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "token", getValue(currency, "id") },
            { "amount", this.parseToNumeric(amount) },
            { "from_application_id", fromAccount },
            { "to_application_id", toAccount },
        };
        object response = await this.v1PrivatePostAssetMainSubTransfer(this.extend(request, parameters));
        //
        //     {
        //         "success": true,
        //         "id": 200
        //     }
        //
        object transfer = this.parseTransfer(response, currency);
        object transferOptions = this.safeDict(this.options, "transfer", new Dictionary<string, object>() {});
        object fillResponseFromRequest = this.safeBool(transferOptions, "fillResponseFromRequest", true);
        if (isTrue(fillResponseFromRequest))
        {
            ((IDictionary<string,object>)transfer)["amount"] = amount;
            ((IDictionary<string,object>)transfer)["fromAccount"] = fromAccount;
            ((IDictionary<string,object>)transfer)["toAccount"] = toAccount;
        }
        return transfer;
    }

    /**
     * @method
     * @name woo#fetchTransfers
     * @description fetch a history of internal transfers made on an account
     * @see https://developer.woox.io/api-reference/endpoint/assets/get_transfer_history
     * @param {string} code unified currency code of the currency transferred
     * @param {int} [since] the earliest time in ms to fetch transfers for
     * @param {int} [limit] the maximum number of  transfers structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {int} [params.until] the latest time in ms to fetch entries for
     * @returns {object[]} a list of [transfer structures]{@link https://docs.ccxt.com/#/?id=transfer-structure}
     */
    public async override Task<object> fetchTransfers(object code = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object request = new Dictionary<string, object>() {};
        object currency = null;
        if (isTrue(!isEqual(code, null)))
        {
            currency = this.currency(code);
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["size"] = limit;
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["startTime"] = since;
        }
        object until = this.safeInteger(parameters, "until"); // unified in milliseconds
        parameters = this.omit(parameters, new List<object>() {"until"});
        if (isTrue(!isEqual(until, null)))
        {
            ((IDictionary<string,object>)request)["endTime"] = until;
        }
        object response = await this.v3PrivateGetAssetTransferHistory(this.extend(request, parameters));
        //
        //     {
        //         "success": true,
        //         "data": {
        //             "rows": [
        //                 {
        //                     "id": 225,
        //                     "token": "USDT",
        //                     "amount": "1000000",
        //                     "status": "COMPLETED",
        //                     "from": {
        //                         "applicationId": "046b5c5c-5b44-4d27-9593-ddc32c0a08ae",
        //                         "accountName": "Main"
        //                     },
        //                     "to": {
        //                         "applicationId": "082ae5ae-e26a-4fb1-be5b-03e5b4867663",
        //                         "accountName": "sub001"
        //                     },
        //                     "createdTime": "1642660941.534",
        //                     "updatedTime": "1642660941.950"
        //                 }
        //             ],
        //             "meta": {
        //                 "total": 46,
        //                 "recordsPerPage": 1,
        //                 "currentPage": 1
        //             }
        //         },
        //         "timestamp": 1721295317627
        //     }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        object rows = this.safeList(data, "rows", new List<object>() {});
        return this.parseTransfers(rows, currency, since, limit, parameters);
    }

    public override object parseTransfer(object transfer, object currency = null)
    {
        //
        //    fetchTransfers
        //     {
        //         "id": 46704,
        //         "token": "USDT",
        //         "amount": 30000.00000000,
        //         "status": "COMPLETED",
        //         "from_application_id": "0f1bd3cd-dba2-4563-b8bb-0adb1bfb83a3",
        //         "to_application_id": "c01e6940-a735-4022-9b6c-9d3971cdfdfa",
        //         "from_user": "LeverageLow",
        //         "to_user": "dev",
        //         "created_time": "1709022325.427",
        //         "updated_time": "1709022325.542"
        //     }
        //     {
        //         "id": 225,
        //         "token": "USDT",
        //         "amount": "1000000",
        //         "status": "COMPLETED",
        //         "from": {
        //             "applicationId": "046b5c5c-5b44-4d27-9593-ddc32c0a08ae",
        //             "accountName": "Main"
        //         },
        //         "to": {
        //             "applicationId": "082ae5ae-e26a-4fb1-be5b-03e5b4867663",
        //             "accountName": "sub001"
        //         },
        //         "createdTime": "1642660941.534",
        //         "updatedTime": "1642660941.950"
        //     }
        //
        //    transfer
        //        {
        //            "success": true,
        //            "id": 200
        //        }
        //
        object code = this.safeCurrencyCode(this.safeString(transfer, "token"), currency);
        object timestamp = this.safeTimestamp(transfer, "createdTime");
        object success = this.safeBool(transfer, "success");
        object status = null;
        if (isTrue(!isEqual(success, null)))
        {
            status = ((bool) isTrue(success)) ? "ok" : "failed";
        }
        object fromAccount = this.safeDict(transfer, "from", new Dictionary<string, object>() {});
        object toAccount = this.safeDict(transfer, "to", new Dictionary<string, object>() {});
        return new Dictionary<string, object>() {
            { "id", this.safeString(transfer, "id") },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "currency", code },
            { "amount", this.safeNumber(transfer, "amount") },
            { "fromAccount", this.safeString(fromAccount, "applicationId") },
            { "toAccount", this.safeString(toAccount, "applicationId") },
            { "status", this.parseTransferStatus(this.safeString(transfer, "status", status)) },
            { "info", transfer },
        };
    }

    public virtual object parseTransferStatus(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "NEW", "pending" },
            { "CONFIRMING", "pending" },
            { "PROCESSING", "pending" },
            { "COMPLETED", "ok" },
            { "CANCELED", "canceled" },
        };
        return this.safeString(statuses, status, status);
    }

    /**
     * @method
     * @name woo#withdraw
     * @description make a withdrawal
     * @see https://docs.woox.io/#token-withdraw
     * @param {string} code unified currency code
     * @param {float} amount the amount to withdraw
     * @param {string} address the address to withdraw to
     * @param {string} tag
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
     */
    public async override Task<object> withdraw(object code, object amount, object address, object tag = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        var tagparametersVariable = this.handleWithdrawTagAndParams(tag, parameters);
        tag = ((IList<object>)tagparametersVariable)[0];
        parameters = ((IList<object>)tagparametersVariable)[1];
        await this.loadMarkets();
        this.checkAddress(address);
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "amount", amount },
            { "address", address },
        };
        if (isTrue(!isEqual(tag, null)))
        {
            ((IDictionary<string,object>)request)["extra"] = tag;
        }
        object specialNetworkId = null;
        var specialNetworkIdparametersVariable = this.getDedicatedNetworkId(currency, parameters);
        specialNetworkId = ((IList<object>)specialNetworkIdparametersVariable)[0];
        parameters = ((IList<object>)specialNetworkIdparametersVariable)[1];
        ((IDictionary<string,object>)request)["token"] = specialNetworkId;
        object response = await this.v1PrivatePostAssetWithdraw(this.extend(request, parameters));
        //
        //     {
        //         "success": true,
        //         "withdraw_id": "20200119145703654"
        //     }
        //
        return this.parseTransaction(response, currency);
    }

    /**
     * @method
     * @name woo#repayMargin
     * @description repay borrowed margin and interest
     * @see https://docs.woox.io/#repay-interest
     * @param {string} code unified currency code of the currency to repay
     * @param {float} amount the amount to repay
     * @param {string} symbol not used by woo.repayMargin ()
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [margin loan structure]{@link https://docs.ccxt.com/#/?id=margin-loan-structure}
     */
    public async override Task<object> repayMargin(object code, object amount, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            symbol = getValue(market, "symbol");
        }
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "token", getValue(currency, "id") },
            { "amount", this.currencyToPrecision(code, amount) },
        };
        object response = await this.v1PrivatePostInterestRepay(this.extend(request, parameters));
        //
        //     {
        //         "success": true,
        //     }
        //
        object transaction = this.parseMarginLoan(response, currency);
        return this.extend(transaction, new Dictionary<string, object>() {
            { "amount", amount },
            { "symbol", symbol },
        });
    }

    public virtual object parseMarginLoan(object info, object currency = null)
    {
        //
        //     {
        //         "success": true,
        //     }
        //
        return new Dictionary<string, object>() {
            { "id", null },
            { "currency", this.safeCurrencyCode(null, currency) },
            { "amount", null },
            { "symbol", null },
            { "timestamp", null },
            { "datetime", null },
            { "info", info },
        };
    }

    public override object nonce()
    {
        return subtract(this.milliseconds(), getValue(this.options, "timeDifference"));
    }

    public override object sign(object path, object section = null, object method = null, object parameters = null, object headers = null, object body = null)
    {
        section ??= "public";
        method ??= "GET";
        parameters ??= new Dictionary<string, object>();
        object version = getValue(section, 0);
        object access = getValue(section, 1);
        object pathWithParams = this.implodeParams(path, parameters);
        object url = this.implodeHostname(getValue(getValue(this.urls, "api"), access));
        url = add(url, add(add("/", version), "/"));
        parameters = this.omit(parameters, this.extractParams(path));
        parameters = this.keysort(parameters);
        if (isTrue(isEqual(access, "public")))
        {
            url = add(url, add(add(access, "/"), pathWithParams));
            if (isTrue(getArrayLength(new List<object>(((IDictionary<string,object>)parameters).Keys))))
            {
                url = add(url, add("?", this.urlencode(parameters)));
            }
        } else if (isTrue(isEqual(access, "pub")))
        {
            url = add(url, pathWithParams);
            if (isTrue(getArrayLength(new List<object>(((IDictionary<string,object>)parameters).Keys))))
            {
                url = add(url, add("?", this.urlencode(parameters)));
            }
        } else
        {
            this.checkRequiredCredentials();
            if (isTrue(isTrue(isEqual(method, "POST")) && isTrue((isTrue(isEqual(path, "trade/algoOrder")) || isTrue(isEqual(path, "trade/order"))))))
            {
                object isSandboxMode = this.safeBool(this.options, "sandboxMode", false);
                if (!isTrue(isSandboxMode))
                {
                    object applicationId = "bc830de7-50f3-460b-9ee0-f430f83f9dad";
                    object brokerId = this.safeString(this.options, "brokerId", applicationId);
                    object isTrigger = isGreaterThan(getIndexOf(path, "algo"), -1);
                    if (isTrue(isTrigger))
                    {
                        ((IDictionary<string,object>)parameters)["brokerId"] = brokerId;
                    } else
                    {
                        ((IDictionary<string,object>)parameters)["broker_id"] = brokerId;
                    }
                }
                parameters = this.keysort(parameters);
            }
            object auth = "";
            object ts = ((object)this.nonce()).ToString();
            url = add(url, pathWithParams);
            headers = new Dictionary<string, object>() {
                { "x-api-key", this.apiKey },
                { "x-api-timestamp", ts },
            };
            if (isTrue(isEqual(version, "v3")))
            {
                auth = add(add(add(add(add(ts, method), "/"), version), "/"), pathWithParams);
                if (isTrue(isTrue(isEqual(method, "POST")) || isTrue(isEqual(method, "PUT"))))
                {
                    body = this.json(parameters);
                    auth = add(auth, body);
                    ((IDictionary<string,object>)headers)["content-type"] = "application/json";
                } else
                {
                    if (isTrue(getArrayLength(new List<object>(((IDictionary<string,object>)parameters).Keys))))
                    {
                        object query = this.urlencode(parameters);
                        url = add(url, add("?", query));
                        auth = add(auth, add("?", query));
                    }
                }
            } else
            {
                auth = this.urlencode(parameters);
                if (isTrue(isTrue(isTrue(isEqual(method, "POST")) || isTrue(isEqual(method, "PUT"))) || isTrue(isEqual(method, "DELETE"))))
                {
                    body = auth;
                } else
                {
                    if (isTrue(getArrayLength(new List<object>(((IDictionary<string,object>)parameters).Keys))))
                    {
                        url = add(url, add("?", auth));
                    }
                }
                auth = add(auth, add("|", ts));
                ((IDictionary<string,object>)headers)["content-type"] = "application/x-www-form-urlencoded";
            }
            ((IDictionary<string,object>)headers)["x-api-signature"] = this.hmac(this.encode(auth), this.encode(this.secret), sha256);
        }
        return new Dictionary<string, object>() {
            { "url", url },
            { "method", method },
            { "body", body },
            { "headers", headers },
        };
    }

    public override object handleErrors(object httpCode, object reason, object url, object method, object headers, object body, object response, object requestHeaders, object requestBody)
    {
        if (!isTrue(response))
        {
            return null;  // fallback to default error handler
        }
        //
        //     400 Bad Request {"success":false,"code":-1012,"message":"Amount is required for buy market orders when margin disabled."}
        //                     {"code":"-1011","message":"The system is under maintenance.","success":false}
        //
        object success = this.safeBool(response, "success");
        object errorCode = this.safeString(response, "code");
        if (!isTrue(success))
        {
            object feedback = add(add(this.id, " "), this.json(response));
            this.throwBroadlyMatchedException(getValue(this.exceptions, "broad"), body, feedback);
            this.throwExactlyMatchedException(getValue(this.exceptions, "exact"), errorCode, feedback);
        }
        return null;
    }

    public override object parseIncome(object income, object market = null)
    {
        //
        //     {
        //         "id": 1286360,
        //         "symbol": "PERP_BTC_USDT",
        //         "fundingRate": -0.00001445,
        //         "markPrice": "26930.60000000",
        //         "fundingFee": "9.56021744",
        //         "fundingIntervalHours": 8,
        //         "paymentType": "Pay",
        //         "status": "COMPLETED",
        //         "createdTime": 1696060873259,
        //         "updatedTime": 1696060873286
        //     }
        //
        object marketId = this.safeString(income, "symbol");
        object symbol = this.safeSymbol(marketId, market);
        object amount = this.safeString(income, "fundingFee");
        object code = this.safeCurrencyCode("USD");
        object id = this.safeString(income, "id");
        object timestamp = this.safeInteger(income, "updatedTime");
        object rate = this.safeNumber(income, "fundingRate");
        object paymentType = this.safeString(income, "paymentType");
        amount = ((bool) isTrue((isEqual(paymentType, "Pay")))) ? Precise.stringNeg(amount) : amount;
        return new Dictionary<string, object>() {
            { "info", income },
            { "symbol", symbol },
            { "code", code },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "id", id },
            { "amount", this.parseNumber(amount) },
            { "rate", rate },
        };
    }

    /**
     * @method
     * @name woo#fetchFundingHistory
     * @description fetch the history of funding payments paid and received on this account
     * @see https://developer.woox.io/api-reference/endpoint/futures/get_fundingFee_history
     * @param {string} [symbol] unified market symbol
     * @param {int} [since] the earliest time in ms to fetch funding history for
     * @param {int} [limit] the maximum number of funding history structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [availble parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
     * @returns {object} a [funding history structure]{@link https://docs.ccxt.com/#/?id=funding-history-structure}
     */
    public async override Task<object> fetchFundingHistory(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object paginate = false;
        var paginateparametersVariable = this.handleOptionAndParams(parameters, "fetchFundingHistory", "paginate");
        paginate = ((IList<object>)paginateparametersVariable)[0];
        parameters = ((IList<object>)paginateparametersVariable)[1];
        if (isTrue(paginate))
        {
            return await this.fetchPaginatedCallIncremental("fetchFundingHistory", symbol, since, limit, parameters, "page", 500);
        }
        object request = new Dictionary<string, object>() {};
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["startTime"] = since;
        }
        object until = this.safeInteger(parameters, "until"); // unified in milliseconds
        parameters = this.omit(parameters, new List<object>() {"until"});
        if (isTrue(!isEqual(until, null)))
        {
            ((IDictionary<string,object>)request)["endTime"] = until;
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["size"] = mathMin(limit, 500);
        }
        object response = await this.v3PrivateGetFuturesFundingFeeHistory(this.extend(request, parameters));
        //
        //     {
        //         "success": true,
        //         "data": {
        //             "meta": {
        //                 "total": 670,
        //                 "recordsPerPage": 25,
        //                 "currentPage": 1
        //             },
        //             "rows": [
        //                 {
        //                     "id": 1286360,
        //                     "symbol": "PERP_BTC_USDT",
        //                     "fundingRate": -0.00001445,
        //                     "markPrice": "26930.60000000",
        //                     "fundingFee": "9.56021744",
        //                     "fundingIntervalHours": 8,
        //                     "paymentType": "Pay",
        //                     "status": "COMPLETED",
        //                     "createdTime": 1696060873259,
        //                     "updatedTime": 1696060873286
        //                 }
        //             ]
        //         },
        //         "timestamp": 1721351502594
        //     }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        object rows = this.safeList(data, "rows", new List<object>() {});
        return this.parseIncomes(rows, market, since, limit);
    }

    public override object parseFundingRate(object fundingRate, object market = null)
    {
        //
        //     {
        //         "symbol": "PERP_BTC_USDT",
        //         "estFundingRate": "-0.00000441",
        //         "estFundingRateTimestamp": 1751623979022,
        //         "lastFundingRate": "-0.00004953",
        //         "lastFundingRateTimestamp": 1751616000000,
        //         "nextFundingTime": 1751644800000,
        //         "lastFundingIntervalHours": 8,
        //         "estFundingIntervalHours": 8
        //     }
        //
        object symbol = this.safeString(fundingRate, "symbol");
        market = this.market(symbol);
        object nextFundingTimestamp = this.safeInteger(fundingRate, "nextFundingTime");
        object estFundingRateTimestamp = this.safeInteger(fundingRate, "estFundingRateTimestamp");
        object lastFundingRateTimestamp = this.safeInteger(fundingRate, "lastFundingRateTimestamp");
        object intervalString = this.safeString(fundingRate, "estFundingIntervalHours");
        return new Dictionary<string, object>() {
            { "info", fundingRate },
            { "symbol", getValue(market, "symbol") },
            { "markPrice", null },
            { "indexPrice", null },
            { "interestRate", this.parseNumber("0") },
            { "estimatedSettlePrice", null },
            { "timestamp", estFundingRateTimestamp },
            { "datetime", this.iso8601(estFundingRateTimestamp) },
            { "fundingRate", this.safeNumber(fundingRate, "estFundingRate") },
            { "fundingTimestamp", nextFundingTimestamp },
            { "fundingDatetime", this.iso8601(nextFundingTimestamp) },
            { "nextFundingRate", null },
            { "nextFundingTimestamp", null },
            { "nextFundingDatetime", null },
            { "previousFundingRate", this.safeNumber(fundingRate, "lastFundingRate") },
            { "previousFundingTimestamp", lastFundingRateTimestamp },
            { "previousFundingDatetime", this.iso8601(lastFundingRateTimestamp) },
            { "interval", add(intervalString, "h") },
        };
    }

    /**
     * @method
     * @name woo#fetchFundingInterval
     * @description fetch the current funding rate interval
     * @see https://developer.woox.io/api-reference/endpoint/public_data/fundingRate
     * @param {string} symbol unified market symbol
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [funding rate structure]{@link https://docs.ccxt.com/#/?id=funding-rate-structure}
     */
    public async override Task<object> fetchFundingInterval(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        return await this.fetchFundingRate(symbol, parameters);
    }

    /**
     * @method
     * @name woo#fetchFundingRate
     * @description fetch the current funding rate
     * @see https://developer.woox.io/api-reference/endpoint/public_data/fundingRate
     * @param {string} symbol unified market symbol
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [funding rate structure]{@link https://docs.ccxt.com/#/?id=funding-rate-structure}
     */
    public async override Task<object> fetchFundingRate(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object response = await this.v3PublicGetFundingRate(this.extend(request, parameters));
        //
        //     {
        //         "success": true,
        //         "data": {
        //             "rows": [
        //                 {
        //                     "symbol": "PERP_BTC_USDT",
        //                     "estFundingRate": "-0.00000441",
        //                     "estFundingRateTimestamp": 1751623979022,
        //                     "lastFundingRate": "-0.00004953",
        //                     "lastFundingRateTimestamp": 1751616000000,
        //                     "nextFundingTime": 1751644800000,
        //                     "lastFundingIntervalHours": 8,
        //                     "estFundingIntervalHours": 8
        //                 }
        //             ]
        //         },
        //         "timestamp": 1751624037798
        //     }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        object rows = this.safeList(data, "rows", new List<object>() {});
        object first = this.safeDict(rows, 0, new Dictionary<string, object>() {});
        return this.parseFundingRate(first, market);
    }

    /**
     * @method
     * @name woo#fetchFundingRates
     * @description fetch the funding rate for multiple markets
     * @see https://developer.woox.io/api-reference/endpoint/public_data/fundingRate
     * @param {string[]|undefined} symbols list of unified market symbols
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} a list of [funding rate structures]{@link https://docs.ccxt.com/#/?id=funding-rates-structure}, indexed by market symbols
     */
    public async override Task<object> fetchFundingRates(object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        symbols = this.marketSymbols(symbols);
        object response = await this.v3PublicGetFundingRate(parameters);
        //
        //     {
        //         "success": true,
        //         "data": {
        //             "rows": [
        //                 {
        //                     "symbol": "PERP_BTC_USDT",
        //                     "estFundingRate": "-0.00000441",
        //                     "estFundingRateTimestamp": 1751623979022,
        //                     "lastFundingRate": "-0.00004953",
        //                     "lastFundingRateTimestamp": 1751616000000,
        //                     "nextFundingTime": 1751644800000,
        //                     "lastFundingIntervalHours": 8,
        //                     "estFundingIntervalHours": 8
        //                 }
        //             ]
        //         },
        //         "timestamp": 1751624037798
        //     }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        object rows = this.safeList(data, "rows", new List<object>() {});
        return this.parseFundingRates(rows, symbols);
    }

    /**
     * @method
     * @name woo#fetchFundingRateHistory
     * @description fetches historical funding rate prices
     * @see https://developer.woox.io/api-reference/endpoint/public_data/fundingRateHistory
     * @param {string} symbol unified symbol of the market to fetch the funding rate history for
     * @param {int} [since] timestamp in ms of the earliest funding rate to fetch
     * @param {int} [limit] the maximum amount of [funding rate structures]{@link https://docs.ccxt.com/#/?id=funding-rate-history-structure} to fetch
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {int} [params.until] timestamp in ms of the latest funding rate
     * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [availble parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
     * @returns {object[]} a list of [funding rate structures]{@link https://docs.ccxt.com/#/?id=funding-rate-history-structure}
     */
    public async override Task<object> fetchFundingRateHistory(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object paginate = false;
        var paginateparametersVariable = this.handleOptionAndParams(parameters, "fetchFundingRateHistory", "paginate");
        paginate = ((IList<object>)paginateparametersVariable)[0];
        parameters = ((IList<object>)paginateparametersVariable)[1];
        if (isTrue(paginate))
        {
            return await this.fetchPaginatedCallIncremental("fetchFundingRateHistory", symbol, since, limit, parameters, "page", 25);
        }
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchFundingRateHistory() requires a symbol argument")) ;
        }
        object market = this.market(symbol);
        symbol = getValue(market, "symbol");
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["startTime"] = since;
        }
        var requestparametersVariable = this.handleUntilOption("endTime", request, parameters);
        request = ((IList<object>)requestparametersVariable)[0];
        parameters = ((IList<object>)requestparametersVariable)[1];
        object response = await this.v3PublicGetFundingRateHistory(this.extend(request, parameters));
        //
        //     {
        //         "success": true,
        //         "data": {
        //             "rows": [
        //                 {
        //                     "symbol": "PERP_BTC_USDT",
        //                     "fundingRate": "-0.00004953",
        //                     "fundingRateTimestamp": 1751616000000,
        //                     "nextFundingTime": 1751644800000,
        //                     "markPrice": "108708"
        //                 }
        //             ],
        //             "meta": {
        //                 "total": 11690,
        //                 "recordsPerPage": 25,
        //                 "currentPage": 1
        //             }
        //         },
        //         "timestamp": 1751632390031
        //     }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        object rows = this.safeList(data, "rows", new List<object>() {});
        object rates = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(rows)); postFixIncrement(ref i))
        {
            object entry = getValue(rows, i);
            object marketId = this.safeString(entry, "symbol");
            object timestamp = this.safeInteger(entry, "fundingRateTimestamp");
            ((IList<object>)rates).Add(new Dictionary<string, object>() {
                { "info", entry },
                { "symbol", this.safeSymbol(marketId) },
                { "fundingRate", this.safeNumber(entry, "fundingRate") },
                { "timestamp", timestamp },
                { "datetime", this.iso8601(timestamp) },
            });
        }
        object sorted = this.sortBy(rates, "timestamp");
        return this.filterBySymbolSinceLimit(sorted, symbol, since, limit);
    }

    /**
     * @method
     * @name woo#setPositionMode
     * @description set hedged to true or false for a market
     * @see https://developer.woox.io/api-reference/endpoint/futures/position_mode
     * @param {bool} hedged set to true to use HEDGE_MODE, false for ONE_WAY
     * @param {string} symbol not used by woo setPositionMode
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} response from the exchange
     */
    public async override Task<object> setPositionMode(object hedged, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object hedgeMode = null;
        if (isTrue(hedged))
        {
            hedgeMode = "HEDGE_MODE";
        } else
        {
            hedgeMode = "ONE_WAY";
        }
        object request = new Dictionary<string, object>() {
            { "positionMode", hedgeMode },
        };
        object response = await this.v3PrivatePutFuturesPositionMode(this.extend(request, parameters));
        //
        //     {
        //         "success": true,
        //         "timestamp": 1752550492845
        //     }
        //
        return response;
    }

    /**
     * @method
     * @name woo#fetchLeverage
     * @description fetch the set leverage for a market
     * @see https://developer.woox.io/api-reference/endpoint/account/get_account_info
     * @see https://developer.woox.io/api-reference/endpoint/futures/get_leverage
     * @param {string} symbol unified market symbol
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.marginMode] *for swap markets only* 'cross' or 'isolated'
     * @param {string} [params.positionMode] *for swap markets only* 'ONE_WAY' or 'HEDGE_MODE'
     * @returns {object} a [leverage structure]{@link https://docs.ccxt.com/#/?id=leverage-structure}
     */
    public async override Task<object> fetchLeverage(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object response = null;
        if (isTrue(getValue(market, "spot")))
        {
            response = await this.v3PrivateGetAccountInfo(parameters);
        } else if (isTrue(getValue(market, "swap")))
        {
            object request = new Dictionary<string, object>() {
                { "symbol", getValue(market, "id") },
            };
            object marginMode = null;
            var marginModeparametersVariable = this.handleMarginModeAndParams("fetchLeverage", parameters, "cross");
            marginMode = ((IList<object>)marginModeparametersVariable)[0];
            parameters = ((IList<object>)marginModeparametersVariable)[1];
            ((IDictionary<string,object>)request)["marginMode"] = this.encodeMarginMode(marginMode);
            response = await this.v3PrivateGetFuturesLeverage(this.extend(request, parameters));
        } else
        {
            throw new NotSupported ((string)add(add(add(this.id, " fetchLeverage() is not supported for "), getValue(market, "type")), " markets")) ;
        }
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        return this.parseLeverage(data, market);
    }

    public override object parseLeverage(object leverage, object market = null)
    {
        object marketId = this.safeString(leverage, "symbol");
        market = this.safeMarket(marketId, market);
        object marginMode = this.safeStringLower(leverage, "marginMode");
        object spotLeverage = this.safeInteger(leverage, "leverage");
        if (isTrue(isEqual(spotLeverage, 0)))
        {
            spotLeverage = null;
        }
        object longLeverage = spotLeverage;
        object shortLeverage = spotLeverage;
        object details = this.safeList(leverage, "details", new List<object>() {});
        for (object i = 0; isLessThan(i, getArrayLength(details)); postFixIncrement(ref i))
        {
            object position = this.safeDict(details, i, new Dictionary<string, object>() {});
            object positionLeverage = this.safeInteger(position, "leverage");
            object side = this.safeString(position, "positionSide");
            if (isTrue(isEqual(side, "BOTH")))
            {
                longLeverage = positionLeverage;
                shortLeverage = positionLeverage;
            } else if (isTrue(isEqual(side, "LONG")))
            {
                longLeverage = positionLeverage;
            } else if (isTrue(isEqual(side, "SHORT")))
            {
                shortLeverage = positionLeverage;
            }
        }
        return new Dictionary<string, object>() {
            { "info", leverage },
            { "symbol", getValue(market, "symbol") },
            { "marginMode", marginMode },
            { "longLeverage", longLeverage },
            { "shortLeverage", shortLeverage },
        };
    }

    /**
     * @method
     * @name woo#setLeverage
     * @description set the level of leverage for a market
     * @see https://developer.woox.io/api-reference/endpoint/spot_margin/set_leverage
     * @see https://developer.woox.io/api-reference/endpoint/futures/set_leverage
     * @param {float} leverage the rate of leverage (1, 2, 3, 4 or 5 for spot markets, 1, 2, 3, 4, 5, 10, 15, 20 for swap markets)
     * @param {string} [symbol] unified market symbol (is mandatory for swap markets)
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.marginMode] *for swap markets only* 'cross' or 'isolated'
     * @param {string} [params.positionMode] *for swap markets only* 'ONE_WAY' or 'HEDGE_MODE'
     * @returns {object} response from the exchange
     */
    public async override Task<object> setLeverage(object leverage, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {
            { "leverage", leverage },
        };
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
        }
        if (isTrue(isTrue((isEqual(symbol, null))) || isTrue(getValue(market, "spot"))))
        {
            return await this.v3PrivatePostSpotMarginLeverage(this.extend(request, parameters));
        } else if (isTrue(getValue(market, "swap")))
        {
            ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
            object marginMode = null;
            var marginModeparametersVariable = this.handleMarginModeAndParams("fetchLeverage", parameters, "cross");
            marginMode = ((IList<object>)marginModeparametersVariable)[0];
            parameters = ((IList<object>)marginModeparametersVariable)[1];
            ((IDictionary<string,object>)request)["marginMode"] = this.encodeMarginMode(marginMode);
            return await this.v3PrivatePutFuturesLeverage(this.extend(request, parameters));
        } else
        {
            throw new NotSupported ((string)add(add(add(this.id, " fetchLeverage() is not supported for "), getValue(market, "type")), " markets")) ;
        }
    }

    /**
     * @method
     * @name woo#addMargin
     * @description add margin
     * @see https://docs.woox.io/#update-isolated-margin-setting
     * @param {string} symbol unified market symbol
     * @param {float} amount amount of margin to add
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.position_side] 'LONG' or 'SHORT' in hedge mode, 'BOTH' in one way mode
     * @returns {object} a [margin structure]{@link https://docs.ccxt.com/#/?id=add-margin-structure}
     */
    public async override Task<object> addMargin(object symbol, object amount, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        return await this.modifyMarginHelper(symbol, amount, "ADD", parameters);
    }

    /**
     * @method
     * @name woo#reduceMargin
     * @description remove margin from a position
     * @see https://docs.woox.io/#update-isolated-margin-setting
     * @param {string} symbol unified market symbol
     * @param {float} amount amount of margin to remove
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.position_side] 'LONG' or 'SHORT' in hedge mode, 'BOTH' in one way mode
     * @returns {object} a [margin structure]{@link https://docs.ccxt.com/#/?id=reduce-margin-structure}
     */
    public async override Task<object> reduceMargin(object symbol, object amount, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        return await this.modifyMarginHelper(symbol, amount, "REDUCE", parameters);
    }

    public async virtual Task<object> modifyMarginHelper(object symbol, object amount, object type, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
            { "adjust_token", "USDT" },
            { "adjust_amount", amount },
            { "action", type },
        };
        return await this.v1PrivatePostClientIsolatedMargin(this.extend(request, parameters));
    }

    /**
     * @method
     * @name woo#fetchPosition
     * @description fetch data on an open position
     * @see https://developer.woox.io/api-reference/endpoint/futures/get_positions
     * @param {string} symbol unified market symbol of the market the position is held in
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [position structure]{@link https://docs.ccxt.com/#/?id=position-structure}
     */
    public async override Task<object> fetchPosition(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object response = await this.v3PrivateGetFuturesPositions(this.extend(request, parameters));
        //
        //     {
        //         "success": true,
        //         "data": {
        //             "positions": [
        //                 {
        //                     "symbol": "PERP_LTC_USDT",
        //                     "holding": "0.1",
        //                     "pendingLongQty": "0",
        //                     "pendingShortQty": "0",
        //                     "settlePrice": "96.87",
        //                     "averageOpenPrice": "96.87",
        //                     "pnl24H": "0",
        //                     "fee24H": "0.0048435",
        //                     "markPrice": "96.83793449",
        //                     "estLiqPrice": "0",
        //                     "timestamp": 1752500555823,
        //                     "adlQuantile": 2,
        //                     "positionSide": "BOTH",
        //                     "marginMode": "CROSS",
        //                     "isolatedMarginToken": "",
        //                     "isolatedMarginAmount": "0",
        //                     "isolatedFrozenLong": "0",
        //                     "isolatedFrozenShort": "0",
        //                     "leverage": 10
        //                 }
        //             ]
        //         },
        //         "timestamp": 1752500579848
        //     }
        //
        object result = this.safeDict(response, "data", new Dictionary<string, object>() {});
        object positions = this.safeList(result, "positions", new List<object>() {});
        object first = this.safeDict(positions, 0, new Dictionary<string, object>() {});
        return this.parsePosition(first, market);
    }

    /**
     * @method
     * @name woo#fetchPositions
     * @description fetch all open positions
     * @see https://developer.woox.io/api-reference/endpoint/futures/get_positions
     * @param {string[]} [symbols] list of unified market symbols
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} a list of [position structure]{@link https://docs.ccxt.com/#/?id=position-structure}
     */
    public async override Task<object> fetchPositions(object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.v3PrivateGetFuturesPositions(parameters);
        //
        //     {
        //         "success": true,
        //         "data": {
        //             "positions": [
        //                 {
        //                     "symbol": "PERP_LTC_USDT",
        //                     "holding": "0.1",
        //                     "pendingLongQty": "0",
        //                     "pendingShortQty": "0",
        //                     "settlePrice": "96.87",
        //                     "averageOpenPrice": "96.87",
        //                     "pnl24H": "0",
        //                     "fee24H": "0.0048435",
        //                     "markPrice": "96.83793449",
        //                     "estLiqPrice": "0",
        //                     "timestamp": 1752500555823,
        //                     "adlQuantile": 2,
        //                     "positionSide": "BOTH",
        //                     "marginMode": "CROSS",
        //                     "isolatedMarginToken": "",
        //                     "isolatedMarginAmount": "0",
        //                     "isolatedFrozenLong": "0",
        //                     "isolatedFrozenShort": "0",
        //                     "leverage": 10
        //                 }
        //             ]
        //         },
        //         "timestamp": 1752500579848
        //     }
        //
        object result = this.safeDict(response, "data", new Dictionary<string, object>() {});
        object positions = this.safeList(result, "positions", new List<object>() {});
        return this.parsePositions(positions, symbols);
    }

    public override object parsePosition(object position, object market = null)
    {
        //
        // v1PrivateGetPositionSymbol
        //     {
        //         "symbol": "PERP_ETH_USDT",
        //         "position_side": "BOTH",
        //         "leverage": 10,
        //         "margin_mode": "CROSS",
        //         "average_open_price": 3139.9,
        //         "isolated_margin_amount": 0.0,
        //         "isolated_margin_token": "",
        //         "opening_time": "1720627963.094",
        //         "mark_price": 3155.19169891,
        //         "pending_short_qty": 0.0,
        //         "pending_long_qty": 0.0,
        //         "holding": -0.7,
        //         "pnl_24_h": 0.0,
        //         "est_liq_price": 9107.40055552,
        //         "settle_price": 3151.0319904,
        //         "success": true,
        //         "fee_24_h": 0.0,
        //         "isolated_frozen_long": 0.0,
        //         "isolated_frozen_short": 0.0,
        //         "timestamp": "1720867502.544"
        //     }
        //
        // v3PrivateGetPositions
        //     {
        //         "symbol": "PERP_LTC_USDT",
        //         "holding": "0.1",
        //         "pendingLongQty": "0",
        //         "pendingShortQty": "0",
        //         "settlePrice": "96.87",
        //         "averageOpenPrice": "96.87",
        //         "pnl24H": "0",
        //         "fee24H": "0.0048435",
        //         "markPrice": "96.83793449",
        //         "estLiqPrice": "0",
        //         "timestamp": 1752500555823,
        //         "adlQuantile": 2,
        //         "positionSide": "BOTH",
        //         "marginMode": "CROSS",
        //         "isolatedMarginToken": "",
        //         "isolatedMarginAmount": "0",
        //         "isolatedFrozenLong": "0",
        //         "isolatedFrozenShort": "0",
        //         "leverage": 10
        //     }
        //
        object contract = this.safeString(position, "symbol");
        market = this.safeMarket(contract, market);
        object size = this.safeString(position, "holding");
        object side = null;
        if (isTrue(Precise.stringGt(size, "0")))
        {
            side = "long";
        } else
        {
            side = "short";
        }
        object contractSize = this.safeString(market, "contractSize");
        object markPrice = this.safeString2(position, "markPrice", "mark_price");
        object timestampString = this.safeString(position, "timestamp");
        object timestamp = null;
        if (isTrue(!isEqual(timestampString, null)))
        {
            if (isTrue(isGreaterThan(getIndexOf(timestampString, "."), -1)))
            {
                timestamp = this.safeTimestamp(position, "timestamp");
            } else
            {
                timestamp = this.safeInteger(position, "timestamp");
            }
        }
        object entryPrice = this.safeString2(position, "averageOpenPrice", "average_open_price");
        object priceDifference = Precise.stringSub(markPrice, entryPrice);
        object unrealisedPnl = Precise.stringMul(priceDifference, size);
        size = Precise.stringAbs(size);
        object notional = Precise.stringMul(size, markPrice);
        object positionSide = this.safeString(position, "positionSide"); // 'SHORT' or 'LONG' for hedged, 'BOTH' for non-hedged
        return this.safePosition(new Dictionary<string, object>() {
            { "info", position },
            { "id", null },
            { "symbol", this.safeString(market, "symbol") },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "lastUpdateTimestamp", null },
            { "initialMargin", null },
            { "initialMarginPercentage", null },
            { "maintenanceMargin", null },
            { "maintenanceMarginPercentage", null },
            { "entryPrice", this.parseNumber(entryPrice) },
            { "notional", this.parseNumber(notional) },
            { "leverage", this.safeNumber(position, "leverage") },
            { "unrealizedPnl", this.parseNumber(unrealisedPnl) },
            { "contracts", this.parseNumber(size) },
            { "contractSize", this.parseNumber(contractSize) },
            { "marginRatio", null },
            { "liquidationPrice", this.safeNumber2(position, "estLiqPrice", "est_liq_price") },
            { "markPrice", this.parseNumber(markPrice) },
            { "lastPrice", null },
            { "collateral", null },
            { "marginMode", this.safeStringLower2(position, "marginMode", "margin_mode") },
            { "side", side },
            { "percentage", null },
            { "hedged", !isEqual(positionSide, "BOTH") },
            { "stopLossPrice", null },
            { "takeProfitPrice", null },
        });
    }

    /**
     * @method
     * @name woo#fetchConvertQuote
     * @description fetch a quote for converting from one currency to another
     * @see https://docs.woox.io/#get-quote-rfq
     * @param {string} fromCode the currency that you want to sell and convert from
     * @param {string} toCode the currency that you want to buy and convert into
     * @param {float} [amount] how much you want to trade in units of the from currency
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [conversion structure]{@link https://docs.ccxt.com/#/?id=conversion-structure}
     */
    public async override Task<object> fetchConvertQuote(object fromCode, object toCode, object amount = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {
            { "sellToken", ((string)fromCode).ToUpper() },
            { "buyToken", ((string)toCode).ToUpper() },
            { "sellQuantity", this.numberToString(amount) },
        };
        object response = await this.v3PrivateGetConvertRfq(this.extend(request, parameters));
        //
        //     {
        //         "success": true,
        //         "data": {
        //             "quoteId": 123123123,
        //             "counterPartyId": "",
        //             "sellToken": "ETH",
        //             "sellQuantity": "0.0445",
        //             "buyToken": "USDT",
        //             "buyQuantity": "33.45",
        //             "buyPrice": "6.77",
        //             "expireTimestamp": 1659084466000,
        //             "message": 1659084466000
        //         }
        //     }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        object fromCurrencyId = this.safeString(data, "sellToken", fromCode);
        object fromCurrency = this.currency(fromCurrencyId);
        object toCurrencyId = this.safeString(data, "buyToken", toCode);
        object toCurrency = this.currency(toCurrencyId);
        return this.parseConversion(data, fromCurrency, toCurrency);
    }

    /**
     * @method
     * @name woo#createConvertTrade
     * @description convert from one currency to another
     * @see https://docs.woox.io/#send-quote-rft
     * @param {string} id the id of the trade that you want to make
     * @param {string} fromCode the currency that you want to sell and convert from
     * @param {string} toCode the currency that you want to buy and convert into
     * @param {float} [amount] how much you want to trade in units of the from currency
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [conversion structure]{@link https://docs.ccxt.com/#/?id=conversion-structure}
     */
    public async override Task<object> createConvertTrade(object id, object fromCode, object toCode, object amount = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {
            { "quoteId", id },
        };
        object response = await this.v3PrivatePostConvertRft(this.extend(request, parameters));
        //
        //     {
        //         "success": true,
        //         "data": {
        //             "quoteId": 123123123,
        //             "counterPartyId": "",
        //             "rftAccepted": 1 // 1 -> success; 2 -> processing; 3 -> fail
        //         }
        //     }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        return this.parseConversion(data);
    }

    /**
     * @method
     * @name woo#fetchConvertTrade
     * @description fetch the data for a conversion trade
     * @see https://docs.woox.io/#get-quote-trade
     * @param {string} id the id of the trade that you want to fetch
     * @param {string} [code] the unified currency code of the conversion trade
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [conversion structure]{@link https://docs.ccxt.com/#/?id=conversion-structure}
     */
    public async override Task<object> fetchConvertTrade(object id, object code = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {
            { "quoteId", id },
        };
        object response = await this.v3PrivateGetConvertTrade(this.extend(request, parameters));
        //
        //     {
        //         "success": true,
        //         "data": {
        //             "quoteId": 12,
        //             "buyAsset": "",
        //             "sellAsset": "",
        //             "buyAmount": 12.11,
        //             "sellAmount": 12.11,
        //             "tradeStatus": 12,
        //             "createdTime": ""
        //         }
        //     }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        object fromCurrencyId = this.safeString(data, "sellAsset");
        object toCurrencyId = this.safeString(data, "buyAsset");
        object fromCurrency = null;
        object toCurrency = null;
        if (isTrue(!isEqual(fromCurrencyId, null)))
        {
            fromCurrency = this.currency(fromCurrencyId);
        }
        if (isTrue(!isEqual(toCurrencyId, null)))
        {
            toCurrency = this.currency(toCurrencyId);
        }
        return this.parseConversion(data, fromCurrency, toCurrency);
    }

    /**
     * @method
     * @name woo#fetchConvertTradeHistory
     * @description fetch the users history of conversion trades
     * @see https://docs.woox.io/#get-quote-trades
     * @param {string} [code] the unified currency code
     * @param {int} [since] the earliest time in ms to fetch conversions for
     * @param {int} [limit] the maximum number of conversion structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {int} [params.until] timestamp in ms of the latest conversion to fetch
     * @returns {object[]} a list of [conversion structures]{@link https://docs.ccxt.com/#/?id=conversion-structure}
     */
    public async override Task<object> fetchConvertTradeHistory(object code = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        var requestparametersVariable = this.handleUntilOption("endTime", request, parameters);
        request = ((IList<object>)requestparametersVariable)[0];
        parameters = ((IList<object>)requestparametersVariable)[1];
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["startTime"] = since;
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["size"] = limit;
        }
        object response = await this.v3PrivateGetConvertTrades(this.extend(request, parameters));
        //
        //     {
        //         "success": true,
        //         "data": {
        //             "count": 12,
        //             "tradeVos":[
        //                 {
        //                     "quoteId": 12,
        //                     "buyAsset": "",
        //                     "sellAsset": "",
        //                     "buyAmount": 12.11,
        //                     "sellAmount": 12.11,
        //                     "tradeStatus": 12,
        //                     "createdTime": ""
        //                 }
        //                 ...
        //             ]
        //         }
        //     }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        object rows = this.safeList(data, "tradeVos", new List<object>() {});
        return this.parseConversions(rows, code, "sellAsset", "buyAsset", since, limit);
    }

    public override object parseConversion(object conversion, object fromCurrency = null, object toCurrency = null)
    {
        //
        // fetchConvertQuote
        //
        //     {
        //         "quoteId": 123123123,
        //         "counterPartyId": "",
        //         "sellToken": "ETH",
        //         "sellQuantity": "0.0445",
        //         "buyToken": "USDT",
        //         "buyQuantity": "33.45",
        //         "buyPrice": "6.77",
        //         "expireTimestamp": 1659084466000,
        //         "message": 1659084466000
        //     }
        //
        // createConvertTrade
        //
        //     {
        //         "quoteId": 123123123,
        //         "counterPartyId": "",
        //         "rftAccepted": 1 // 1 -> success; 2 -> processing; 3 -> fail
        //     }
        //
        // fetchConvertTrade, fetchConvertTradeHistory
        //
        //     {
        //         "quoteId": 12,
        //         "buyAsset": "",
        //         "sellAsset": "",
        //         "buyAmount": 12.11,
        //         "sellAmount": 12.11,
        //         "tradeStatus": 12,
        //         "createdTime": ""
        //     }
        //
        object timestamp = this.safeInteger2(conversion, "expireTimestamp", "createdTime");
        object fromCurr = this.safeString2(conversion, "sellToken", "buyAsset");
        object fromCode = this.safeCurrencyCode(fromCurr, fromCurrency);
        object to = this.safeString2(conversion, "buyToken", "sellAsset");
        object toCode = this.safeCurrencyCode(to, toCurrency);
        return new Dictionary<string, object>() {
            { "info", conversion },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "id", this.safeString(conversion, "quoteId") },
            { "fromCurrency", fromCode },
            { "fromAmount", this.safeNumber2(conversion, "sellQuantity", "sellAmount") },
            { "toCurrency", toCode },
            { "toAmount", this.safeNumber2(conversion, "buyQuantity", "buyAmount") },
            { "price", this.safeNumber(conversion, "buyPrice") },
            { "fee", null },
        };
    }

    /**
     * @method
     * @name woo#fetchConvertCurrencies
     * @description fetches all available currencies that can be converted
     * @see https://docs.woox.io/#get-quote-asset-info
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} an associative dictionary of currencies
     */
    public async override Task<object> fetchConvertCurrencies(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.v3PrivateGetConvertAssetInfo(parameters);
        //
        //     {
        //         "success": true,
        //         "rows": [
        //             {
        //                 "token": "BTC",
        //                 "tick": 0.0001,
        //                 "createdTime": "1575014248.99", // Unix epoch time in seconds
        //                 "updatedTime": "1575014248.99"  // Unix epoch time in seconds
        //             },
        //         ]
        //     }
        //
        object result = new Dictionary<string, object>() {};
        object data = this.safeList(response, "rows", new List<object>() {});
        for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
        {
            object entry = getValue(data, i);
            object id = this.safeString(entry, "token");
            object code = this.safeCurrencyCode(id);
            ((IDictionary<string,object>)result)[(string)code] = new Dictionary<string, object>() {
                { "info", entry },
                { "id", id },
                { "code", code },
                { "networks", null },
                { "type", null },
                { "name", null },
                { "active", null },
                { "deposit", null },
                { "withdraw", null },
                { "fee", null },
                { "precision", this.safeNumber(entry, "tick") },
                { "limits", new Dictionary<string, object>() {
                    { "amount", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                    { "withdraw", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                    { "deposit", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                } },
                { "created", this.safeTimestamp(entry, "createdTime") },
            };
        }
        return result;
    }

    public virtual object defaultNetworkCodeForCurrency(object code)
    {
        object currencyItem = this.currency(code);
        object networks = getValue(currencyItem, "networks");
        object networkKeys = new List<object>(((IDictionary<string,object>)networks).Keys);
        for (object i = 0; isLessThan(i, getArrayLength(networkKeys)); postFixIncrement(ref i))
        {
            object network = getValue(networkKeys, i);
            if (isTrue(isEqual(network, "ETH")))
            {
                return network;
            }
        }
        // if it was not returned according to above options, then return the first network of currency
        return this.safeValue(networkKeys, 0);
    }

    public override void setSandboxMode(object enable)
    {
        base.setSandboxMode(enable);
        ((IDictionary<string,object>)this.options)["sandboxMode"] = enable;
    }
}
