namespace ccxt;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

public partial class htx : Exchange
{
    public override object describe()
    {
        return this.deepExtend(base.describe(), new Dictionary<string, object>() {
            { "id", "htx" },
            { "name", "HTX" },
            { "countries", new List<object>() {"CN"} },
            { "rateLimit", 100 },
            { "userAgent", getValue(this.userAgents, "chrome100") },
            { "certified", true },
            { "version", "v1" },
            { "hostname", "api.huobi.pro" },
            { "pro", true },
            { "has", new Dictionary<string, object>() {
                { "CORS", null },
                { "spot", true },
                { "margin", true },
                { "swap", true },
                { "future", true },
                { "option", null },
                { "addMargin", null },
                { "borrowCrossMargin", true },
                { "borrowIsolatedMargin", true },
                { "cancelAllOrders", true },
                { "cancelAllOrdersAfter", true },
                { "cancelOrder", true },
                { "cancelOrders", true },
                { "closeAllPositions", false },
                { "closePosition", true },
                { "createDepositAddress", null },
                { "createMarketBuyOrderWithCost", true },
                { "createMarketOrderWithCost", false },
                { "createMarketSellOrderWithCost", false },
                { "createOrder", true },
                { "createOrders", true },
                { "createReduceOnlyOrder", false },
                { "createStopLimitOrder", true },
                { "createStopLossOrder", true },
                { "createStopMarketOrder", true },
                { "createStopOrder", true },
                { "createTakeProfitOrder", true },
                { "createTrailingPercentOrder", true },
                { "createTriggerOrder", true },
                { "fetchAccounts", true },
                { "fetchBalance", true },
                { "fetchBidsAsks", null },
                { "fetchBorrowInterest", true },
                { "fetchBorrowRateHistories", null },
                { "fetchBorrowRateHistory", null },
                { "fetchCanceledOrders", null },
                { "fetchClosedOrder", null },
                { "fetchClosedOrders", true },
                { "fetchCrossBorrowRate", false },
                { "fetchCrossBorrowRates", false },
                { "fetchCurrencies", true },
                { "fetchDeposit", null },
                { "fetchDepositAddress", true },
                { "fetchDepositAddresses", null },
                { "fetchDepositAddressesByNetwork", true },
                { "fetchDeposits", true },
                { "fetchDepositWithdrawFee", "emulated" },
                { "fetchDepositWithdrawFees", true },
                { "fetchFundingHistory", true },
                { "fetchFundingRate", true },
                { "fetchFundingRateHistory", true },
                { "fetchFundingRates", true },
                { "fetchIndexOHLCV", true },
                { "fetchIsolatedBorrowRate", false },
                { "fetchIsolatedBorrowRates", true },
                { "fetchL3OrderBook", null },
                { "fetchLastPrices", true },
                { "fetchLedger", true },
                { "fetchLedgerEntry", null },
                { "fetchLeverage", false },
                { "fetchLeverageTiers", true },
                { "fetchLiquidations", true },
                { "fetchMarginAdjustmentHistory", false },
                { "fetchMarketLeverageTiers", "emulated" },
                { "fetchMarkets", true },
                { "fetchMarkOHLCV", true },
                { "fetchMyLiquidations", false },
                { "fetchMyTrades", true },
                { "fetchOHLCV", true },
                { "fetchOpenInterest", true },
                { "fetchOpenInterestHistory", true },
                { "fetchOpenInterests", true },
                { "fetchOpenOrder", null },
                { "fetchOpenOrders", true },
                { "fetchOrder", true },
                { "fetchOrderBook", true },
                { "fetchOrderBooks", null },
                { "fetchOrders", true },
                { "fetchOrderTrades", true },
                { "fetchPosition", true },
                { "fetchPositionHistory", "emulated" },
                { "fetchPositions", true },
                { "fetchPositionsHistory", false },
                { "fetchPositionsRisk", false },
                { "fetchPremiumIndexOHLCV", true },
                { "fetchSettlementHistory", true },
                { "fetchStatus", true },
                { "fetchTicker", true },
                { "fetchTickers", true },
                { "fetchTime", true },
                { "fetchTrades", true },
                { "fetchTradingFee", true },
                { "fetchTradingFees", false },
                { "fetchTradingLimits", true },
                { "fetchTransactionFee", null },
                { "fetchTransactionFees", null },
                { "fetchTransactions", null },
                { "fetchTransfers", null },
                { "fetchWithdrawAddresses", true },
                { "fetchWithdrawal", null },
                { "fetchWithdrawals", true },
                { "fetchWithdrawalWhitelist", null },
                { "reduceMargin", null },
                { "repayCrossMargin", true },
                { "repayIsolatedMargin", true },
                { "setLeverage", true },
                { "setMarginMode", false },
                { "setPositionMode", true },
                { "signIn", null },
                { "transfer", true },
                { "withdraw", true },
            } },
            { "timeframes", new Dictionary<string, object>() {
                { "1m", "1min" },
                { "5m", "5min" },
                { "15m", "15min" },
                { "30m", "30min" },
                { "1h", "60min" },
                { "4h", "4hour" },
                { "1d", "1day" },
                { "1w", "1week" },
                { "1M", "1mon" },
                { "1y", "1year" },
            } },
            { "urls", new Dictionary<string, object>() {
                { "logo", "https://user-images.githubusercontent.com/1294454/76137448-22748a80-604e-11ea-8069-6e389271911d.jpg" },
                { "hostnames", new Dictionary<string, object>() {
                    { "contract", "api.hbdm.vn" },
                    { "spot", "api.huobi.pro" },
                    { "status", new Dictionary<string, object>() {
                        { "spot", "status.huobigroup.com" },
                        { "future", new Dictionary<string, object>() {
                            { "inverse", "status-dm.huobigroup.com" },
                            { "linear", "status-linear-swap.huobigroup.com" },
                        } },
                        { "swap", new Dictionary<string, object>() {
                            { "inverse", "status-swap.huobigroup.com" },
                            { "linear", "status-linear-swap.huobigroup.com" },
                        } },
                    } },
                } },
                { "api", new Dictionary<string, object>() {
                    { "status", "https://{hostname}" },
                    { "contract", "https://{hostname}" },
                    { "spot", "https://{hostname}" },
                    { "public", "https://{hostname}" },
                    { "private", "https://{hostname}" },
                    { "v2Public", "https://{hostname}" },
                    { "v2Private", "https://{hostname}" },
                } },
                { "www", "https://www.huobi.com" },
                { "referral", new Dictionary<string, object>() {
                    { "url", "https://www.htx.com.vc/invite/en-us/1h?invite_code=6rmm2223" },
                    { "discount", 0.15 },
                } },
                { "doc", new List<object>() {"https://huobiapi.github.io/docs/spot/v1/en/", "https://huobiapi.github.io/docs/dm/v1/en/", "https://huobiapi.github.io/docs/coin_margined_swap/v1/en/", "https://huobiapi.github.io/docs/usdt_swap/v1/en/", "https://www.huobi.com/en-us/opend/newApiPages/"} },
                { "fees", "https://www.huobi.com/about/fee/" },
            } },
            { "api", new Dictionary<string, object>() {
                { "v2Public", new Dictionary<string, object>() {
                    { "get", new Dictionary<string, object>() {
                        { "reference/currencies", 1 },
                        { "market-status", 1 },
                    } },
                } },
                { "v2Private", new Dictionary<string, object>() {
                    { "get", new Dictionary<string, object>() {
                        { "account/ledger", 1 },
                        { "account/withdraw/quota", 1 },
                        { "account/withdraw/address", 1 },
                        { "account/deposit/address", 1 },
                        { "account/repayment", 5 },
                        { "reference/transact-fee-rate", 1 },
                        { "account/asset-valuation", 0.2 },
                        { "point/account", 5 },
                        { "sub-user/user-list", 1 },
                        { "sub-user/user-state", 1 },
                        { "sub-user/account-list", 1 },
                        { "sub-user/deposit-address", 1 },
                        { "sub-user/query-deposit", 1 },
                        { "user/api-key", 1 },
                        { "user/uid", 1 },
                        { "algo-orders/opening", 1 },
                        { "algo-orders/history", 1 },
                        { "algo-orders/specific", 1 },
                        { "c2c/offers", 1 },
                        { "c2c/offer", 1 },
                        { "c2c/transactions", 1 },
                        { "c2c/repayment", 1 },
                        { "c2c/account", 1 },
                        { "etp/reference", 1 },
                        { "etp/transactions", 5 },
                        { "etp/transaction", 5 },
                        { "etp/rebalance", 1 },
                        { "etp/limit", 1 },
                    } },
                    { "post", new Dictionary<string, object>() {
                        { "account/transfer", 1 },
                        { "account/repayment", 5 },
                        { "point/transfer", 5 },
                        { "sub-user/management", 1 },
                        { "sub-user/creation", 1 },
                        { "sub-user/tradable-market", 1 },
                        { "sub-user/transferability", 1 },
                        { "sub-user/api-key-generation", 1 },
                        { "sub-user/api-key-modification", 1 },
                        { "sub-user/api-key-deletion", 1 },
                        { "sub-user/deduct-mode", 1 },
                        { "algo-orders", 1 },
                        { "algo-orders/cancel-all-after", 1 },
                        { "algo-orders/cancellation", 1 },
                        { "c2c/offer", 1 },
                        { "c2c/cancellation", 1 },
                        { "c2c/cancel-all", 1 },
                        { "c2c/repayment", 1 },
                        { "c2c/transfer", 1 },
                        { "etp/creation", 5 },
                        { "etp/redemption", 5 },
                        { "etp/{transactId}/cancel", 10 },
                        { "etp/batch-cancel", 50 },
                    } },
                } },
                { "public", new Dictionary<string, object>() {
                    { "get", new Dictionary<string, object>() {
                        { "common/symbols", 1 },
                        { "common/currencys", 1 },
                        { "common/timestamp", 1 },
                        { "common/exchange", 1 },
                        { "settings/currencys", 1 },
                    } },
                } },
                { "private", new Dictionary<string, object>() {
                    { "get", new Dictionary<string, object>() {
                        { "account/accounts", 0.2 },
                        { "account/accounts/{id}/balance", 0.2 },
                        { "account/accounts/{sub-uid}", 1 },
                        { "account/history", 4 },
                        { "cross-margin/loan-info", 1 },
                        { "margin/loan-info", 1 },
                        { "fee/fee-rate/get", 1 },
                        { "order/openOrders", 0.4 },
                        { "order/orders", 0.4 },
                        { "order/orders/{id}", 0.4 },
                        { "order/orders/{id}/matchresults", 0.4 },
                        { "order/orders/getClientOrder", 0.4 },
                        { "order/history", 1 },
                        { "order/matchresults", 1 },
                        { "query/deposit-withdraw", 1 },
                        { "margin/loan-orders", 0.2 },
                        { "margin/accounts/balance", 0.2 },
                        { "cross-margin/loan-orders", 1 },
                        { "cross-margin/accounts/balance", 1 },
                        { "points/actions", 1 },
                        { "points/orders", 1 },
                        { "subuser/aggregate-balance", 10 },
                        { "stable-coin/exchange_rate", 1 },
                        { "stable-coin/quote", 1 },
                    } },
                    { "post", new Dictionary<string, object>() {
                        { "account/transfer", 1 },
                        { "futures/transfer", 1 },
                        { "order/batch-orders", 0.4 },
                        { "order/orders/place", 0.2 },
                        { "order/orders/submitCancelClientOrder", 0.2 },
                        { "order/orders/batchCancelOpenOrders", 0.4 },
                        { "order/orders/{id}/submitcancel", 0.2 },
                        { "order/orders/batchcancel", 0.4 },
                        { "dw/withdraw/api/create", 1 },
                        { "dw/withdraw-virtual/{id}/cancel", 1 },
                        { "dw/transfer-in/margin", 10 },
                        { "dw/transfer-out/margin", 10 },
                        { "margin/orders", 10 },
                        { "margin/orders/{id}/repay", 10 },
                        { "cross-margin/transfer-in", 1 },
                        { "cross-margin/transfer-out", 1 },
                        { "cross-margin/orders", 1 },
                        { "cross-margin/orders/{id}/repay", 1 },
                        { "stable-coin/exchange", 1 },
                        { "subuser/transfer", 10 },
                    } },
                } },
                { "status", new Dictionary<string, object>() {
                    { "public", new Dictionary<string, object>() {
                        { "spot", new Dictionary<string, object>() {
                            { "get", new Dictionary<string, object>() {
                                { "api/v2/summary.json", 1 },
                            } },
                        } },
                        { "future", new Dictionary<string, object>() {
                            { "inverse", new Dictionary<string, object>() {
                                { "get", new Dictionary<string, object>() {
                                    { "api/v2/summary.json", 1 },
                                } },
                            } },
                            { "linear", new Dictionary<string, object>() {
                                { "get", new Dictionary<string, object>() {
                                    { "api/v2/summary.json", 1 },
                                } },
                            } },
                        } },
                        { "swap", new Dictionary<string, object>() {
                            { "inverse", new Dictionary<string, object>() {
                                { "get", new Dictionary<string, object>() {
                                    { "api/v2/summary.json", 1 },
                                } },
                            } },
                            { "linear", new Dictionary<string, object>() {
                                { "get", new Dictionary<string, object>() {
                                    { "api/v2/summary.json", 1 },
                                } },
                            } },
                        } },
                    } },
                } },
                { "spot", new Dictionary<string, object>() {
                    { "public", new Dictionary<string, object>() {
                        { "get", new Dictionary<string, object>() {
                            { "v2/market-status", 1 },
                            { "v1/common/symbols", 1 },
                            { "v1/common/currencys", 1 },
                            { "v2/settings/common/currencies", 1 },
                            { "v2/reference/currencies", 1 },
                            { "v1/common/timestamp", 1 },
                            { "v1/common/exchange", 1 },
                            { "v1/settings/common/chains", 1 },
                            { "v1/settings/common/currencys", 1 },
                            { "v1/settings/common/symbols", 1 },
                            { "v2/settings/common/symbols", 1 },
                            { "v1/settings/common/market-symbols", 1 },
                            { "market/history/candles", 1 },
                            { "market/history/kline", 1 },
                            { "market/detail/merged", 1 },
                            { "market/tickers", 1 },
                            { "market/detail", 1 },
                            { "market/depth", 1 },
                            { "market/trade", 1 },
                            { "market/history/trade", 1 },
                            { "market/etp", 1 },
                            { "v2/etp/reference", 1 },
                            { "v2/etp/rebalance", 1 },
                        } },
                    } },
                    { "private", new Dictionary<string, object>() {
                        { "get", new Dictionary<string, object>() {
                            { "v1/account/accounts", 0.2 },
                            { "v1/account/accounts/{account-id}/balance", 0.2 },
                            { "v2/account/valuation", 1 },
                            { "v2/account/asset-valuation", 0.2 },
                            { "v1/account/history", 4 },
                            { "v2/account/ledger", 1 },
                            { "v2/point/account", 5 },
                            { "v2/account/deposit/address", 1 },
                            { "v2/account/withdraw/quota", 1 },
                            { "v2/account/withdraw/address", 1 },
                            { "v2/reference/currencies", 1 },
                            { "v1/query/deposit-withdraw", 1 },
                            { "v1/query/withdraw/client-order-id", 1 },
                            { "v2/user/api-key", 1 },
                            { "v2/user/uid", 1 },
                            { "v2/sub-user/user-list", 1 },
                            { "v2/sub-user/user-state", 1 },
                            { "v2/sub-user/account-list", 1 },
                            { "v2/sub-user/deposit-address", 1 },
                            { "v2/sub-user/query-deposit", 1 },
                            { "v1/subuser/aggregate-balance", 10 },
                            { "v1/account/accounts/{sub-uid}", 1 },
                            { "v1/order/openOrders", 0.4 },
                            { "v1/order/orders/{order-id}", 0.4 },
                            { "v1/order/orders/getClientOrder", 0.4 },
                            { "v1/order/orders/{order-id}/matchresult", 0.4 },
                            { "v1/order/orders/{order-id}/matchresults", 0.4 },
                            { "v1/order/orders", 0.4 },
                            { "v1/order/history", 1 },
                            { "v1/order/matchresults", 1 },
                            { "v2/reference/transact-fee-rate", 1 },
                            { "v2/algo-orders/opening", 1 },
                            { "v2/algo-orders/history", 1 },
                            { "v2/algo-orders/specific", 1 },
                            { "v1/margin/loan-info", 1 },
                            { "v1/margin/loan-orders", 0.2 },
                            { "v1/margin/accounts/balance", 0.2 },
                            { "v1/cross-margin/loan-info", 1 },
                            { "v1/cross-margin/loan-orders", 1 },
                            { "v1/cross-margin/accounts/balance", 1 },
                            { "v2/account/repayment", 5 },
                            { "v1/stable-coin/quote", 1 },
                            { "v1/stable_coin/exchange_rate", 1 },
                            { "v2/etp/transactions", 5 },
                            { "v2/etp/transaction", 5 },
                            { "v2/etp/limit", 1 },
                        } },
                        { "post", new Dictionary<string, object>() {
                            { "v1/account/transfer", 1 },
                            { "v1/futures/transfer", 1 },
                            { "v2/point/transfer", 5 },
                            { "v2/account/transfer", 1 },
                            { "v1/dw/withdraw/api/create", 1 },
                            { "v1/dw/withdraw-virtual/{withdraw-id}/cancel", 1 },
                            { "v2/sub-user/deduct-mode", 1 },
                            { "v2/sub-user/creation", 1 },
                            { "v2/sub-user/management", 1 },
                            { "v2/sub-user/tradable-market", 1 },
                            { "v2/sub-user/transferability", 1 },
                            { "v2/sub-user/api-key-generation", 1 },
                            { "v2/sub-user/api-key-modification", 1 },
                            { "v2/sub-user/api-key-deletion", 1 },
                            { "v1/subuser/transfer", 10 },
                            { "v1/trust/user/active/credit", 10 },
                            { "v1/order/orders/place", 0.2 },
                            { "v1/order/batch-orders", 0.4 },
                            { "v1/order/auto/place", 0.2 },
                            { "v1/order/orders/{order-id}/submitcancel", 0.2 },
                            { "v1/order/orders/submitCancelClientOrder", 0.2 },
                            { "v1/order/orders/batchCancelOpenOrders", 0.4 },
                            { "v1/order/orders/batchcancel", 0.4 },
                            { "v2/algo-orders/cancel-all-after", 1 },
                            { "v2/algo-orders", 1 },
                            { "v2/algo-orders/cancellation", 1 },
                            { "v2/account/repayment", 5 },
                            { "v1/dw/transfer-in/margin", 10 },
                            { "v1/dw/transfer-out/margin", 10 },
                            { "v1/margin/orders", 10 },
                            { "v1/margin/orders/{order-id}/repay", 10 },
                            { "v1/cross-margin/transfer-in", 1 },
                            { "v1/cross-margin/transfer-out", 1 },
                            { "v1/cross-margin/orders", 1 },
                            { "v1/cross-margin/orders/{order-id}/repay", 1 },
                            { "v1/stable-coin/exchange", 1 },
                            { "v2/etp/creation", 5 },
                            { "v2/etp/redemption", 5 },
                            { "v2/etp/{transactId}/cancel", 10 },
                            { "v2/etp/batch-cancel", 50 },
                        } },
                    } },
                } },
                { "contract", new Dictionary<string, object>() {
                    { "public", new Dictionary<string, object>() {
                        { "get", new Dictionary<string, object>() {
                            { "api/v1/timestamp", 1 },
                            { "heartbeat/", 1 },
                            { "api/v1/contract_contract_info", 1 },
                            { "api/v1/contract_index", 1 },
                            { "api/v1/contract_query_elements", 1 },
                            { "api/v1/contract_price_limit", 1 },
                            { "api/v1/contract_open_interest", 1 },
                            { "api/v1/contract_delivery_price", 1 },
                            { "market/depth", 1 },
                            { "market/bbo", 1 },
                            { "market/history/kline", 1 },
                            { "index/market/history/mark_price_kline", 1 },
                            { "market/detail/merged", 1 },
                            { "market/detail/batch_merged", 1 },
                            { "v2/market/detail/batch_merged", 1 },
                            { "market/trade", 1 },
                            { "market/history/trade", 1 },
                            { "api/v1/contract_risk_info", 1 },
                            { "api/v1/contract_insurance_fund", 1 },
                            { "api/v1/contract_adjustfactor", 1 },
                            { "api/v1/contract_his_open_interest", 1 },
                            { "api/v1/contract_ladder_margin", 1 },
                            { "api/v1/contract_api_state", 1 },
                            { "api/v1/contract_elite_account_ratio", 1 },
                            { "api/v1/contract_elite_position_ratio", 1 },
                            { "api/v1/contract_liquidation_orders", 1 },
                            { "api/v1/contract_settlement_records", 1 },
                            { "index/market/history/index", 1 },
                            { "index/market/history/basis", 1 },
                            { "api/v1/contract_estimated_settlement_price", 1 },
                            { "api/v3/contract_liquidation_orders", 1 },
                            { "swap-api/v1/swap_contract_info", 1 },
                            { "swap-api/v1/swap_index", 1 },
                            { "swap-api/v1/swap_query_elements", 1 },
                            { "swap-api/v1/swap_price_limit", 1 },
                            { "swap-api/v1/swap_open_interest", 1 },
                            { "swap-ex/market/depth", 1 },
                            { "swap-ex/market/bbo", 1 },
                            { "swap-ex/market/history/kline", 1 },
                            { "index/market/history/swap_mark_price_kline", 1 },
                            { "swap-ex/market/detail/merged", 1 },
                            { "v2/swap-ex/market/detail/batch_merged", 1 },
                            { "index/market/history/swap_premium_index_kline", 1 },
                            { "swap-ex/market/detail/batch_merged", 1 },
                            { "swap-ex/market/trade", 1 },
                            { "swap-ex/market/history/trade", 1 },
                            { "swap-api/v1/swap_risk_info", 1 },
                            { "swap-api/v1/swap_insurance_fund", 1 },
                            { "swap-api/v1/swap_adjustfactor", 1 },
                            { "swap-api/v1/swap_his_open_interest", 1 },
                            { "swap-api/v1/swap_ladder_margin", 1 },
                            { "swap-api/v1/swap_api_state", 1 },
                            { "swap-api/v1/swap_elite_account_ratio", 1 },
                            { "swap-api/v1/swap_elite_position_ratio", 1 },
                            { "swap-api/v1/swap_estimated_settlement_price", 1 },
                            { "swap-api/v1/swap_liquidation_orders", 1 },
                            { "swap-api/v1/swap_settlement_records", 1 },
                            { "swap-api/v1/swap_funding_rate", 1 },
                            { "swap-api/v1/swap_batch_funding_rate", 1 },
                            { "swap-api/v1/swap_historical_funding_rate", 1 },
                            { "swap-api/v3/swap_liquidation_orders", 1 },
                            { "index/market/history/swap_estimated_rate_kline", 1 },
                            { "index/market/history/swap_basis", 1 },
                            { "linear-swap-api/v1/swap_contract_info", 1 },
                            { "linear-swap-api/v1/swap_index", 1 },
                            { "linear-swap-api/v1/swap_query_elements", 1 },
                            { "linear-swap-api/v1/swap_price_limit", 1 },
                            { "linear-swap-api/v1/swap_open_interest", 1 },
                            { "linear-swap-ex/market/depth", 1 },
                            { "linear-swap-ex/market/bbo", 1 },
                            { "linear-swap-ex/market/history/kline", 1 },
                            { "index/market/history/linear_swap_mark_price_kline", 1 },
                            { "linear-swap-ex/market/detail/merged", 1 },
                            { "linear-swap-ex/market/detail/batch_merged", 1 },
                            { "v2/linear-swap-ex/market/detail/batch_merged", 1 },
                            { "linear-swap-ex/market/trade", 1 },
                            { "linear-swap-ex/market/history/trade", 1 },
                            { "linear-swap-api/v1/swap_risk_info", 1 },
                            { "swap-api/v1/linear-swap-api/v1/swap_insurance_fund", 1 },
                            { "linear-swap-api/v1/swap_adjustfactor", 1 },
                            { "linear-swap-api/v1/swap_cross_adjustfactor", 1 },
                            { "linear-swap-api/v1/swap_his_open_interest", 1 },
                            { "linear-swap-api/v1/swap_ladder_margin", 1 },
                            { "linear-swap-api/v1/swap_cross_ladder_margin", 1 },
                            { "linear-swap-api/v1/swap_api_state", 1 },
                            { "linear-swap-api/v1/swap_cross_transfer_state", 1 },
                            { "linear-swap-api/v1/swap_cross_trade_state", 1 },
                            { "linear-swap-api/v1/swap_elite_account_ratio", 1 },
                            { "linear-swap-api/v1/swap_elite_position_ratio", 1 },
                            { "linear-swap-api/v1/swap_liquidation_orders", 1 },
                            { "linear-swap-api/v1/swap_settlement_records", 1 },
                            { "linear-swap-api/v1/swap_funding_rate", 1 },
                            { "linear-swap-api/v1/swap_batch_funding_rate", 1 },
                            { "linear-swap-api/v1/swap_historical_funding_rate", 1 },
                            { "linear-swap-api/v3/swap_liquidation_orders", 1 },
                            { "index/market/history/linear_swap_premium_index_kline", 1 },
                            { "index/market/history/linear_swap_estimated_rate_kline", 1 },
                            { "index/market/history/linear_swap_basis", 1 },
                            { "linear-swap-api/v1/swap_estimated_settlement_price", 1 },
                        } },
                    } },
                    { "private", new Dictionary<string, object>() {
                        { "get", new Dictionary<string, object>() {
                            { "api/v1/contract_sub_auth_list", 1 },
                            { "api/v1/contract_api_trading_status", 1 },
                            { "swap-api/v1/swap_sub_auth_list", 1 },
                            { "swap-api/v1/swap_api_trading_status", 1 },
                            { "linear-swap-api/v1/swap_sub_auth_list", 1 },
                            { "linear-swap-api/v1/swap_api_trading_status", 1 },
                            { "linear-swap-api/v1/swap_cross_position_side", 1 },
                            { "linear-swap-api/v1/swap_position_side", 1 },
                            { "linear-swap-api/v3/unified_account_info", 1 },
                            { "linear-swap-api/v3/fix_position_margin_change_record", 1 },
                            { "linear-swap-api/v3/swap_unified_account_type", 1 },
                            { "linear-swap-api/v3/linear_swap_overview_account_info", 1 },
                            { "v5/account/balance", 1 },
                            { "v5/account/asset_mode", 1 },
                            { "v5/trade/position/opens", 1 },
                            { "v5/trade/order/opens", 1 },
                            { "v5/trade/order/details", 1 },
                            { "v5/trade/order/history", 1 },
                            { "v5/trade/order", 1 },
                            { "v5/position/lever", 1 },
                            { "v5/position/mode", 1 },
                            { "v5/position/risk/limit", 1 },
                            { "v5/position/risk/limit_tier", 1 },
                            { "v5/market/risk/limit", 1 },
                            { "v5/market/assets_deduction_currency", 1 },
                            { "v5/market/multi_assets_margin", 1 },
                        } },
                        { "post", new Dictionary<string, object>() {
                            { "api/v1/contract_balance_valuation", 1 },
                            { "api/v1/contract_account_info", 1 },
                            { "api/v1/contract_position_info", 1 },
                            { "api/v1/contract_sub_auth", 1 },
                            { "api/v1/contract_sub_account_list", 1 },
                            { "api/v1/contract_sub_account_info_list", 1 },
                            { "api/v1/contract_sub_account_info", 1 },
                            { "api/v1/contract_sub_position_info", 1 },
                            { "api/v1/contract_financial_record", 1 },
                            { "api/v1/contract_financial_record_exact", 1 },
                            { "api/v1/contract_user_settlement_records", 1 },
                            { "api/v1/contract_order_limit", 1 },
                            { "api/v1/contract_fee", 1 },
                            { "api/v1/contract_transfer_limit", 1 },
                            { "api/v1/contract_position_limit", 1 },
                            { "api/v1/contract_account_position_info", 1 },
                            { "api/v1/contract_master_sub_transfer", 1 },
                            { "api/v1/contract_master_sub_transfer_record", 1 },
                            { "api/v1/contract_available_level_rate", 1 },
                            { "api/v3/contract_financial_record", 1 },
                            { "api/v3/contract_financial_record_exact", 1 },
                            { "api/v1/contract-cancel-after", 1 },
                            { "api/v1/contract_order", 1 },
                            { "api/v1/contract_batchorder", 1 },
                            { "api/v1/contract_cancel", 1 },
                            { "api/v1/contract_cancelall", 1 },
                            { "api/v1/contract_switch_lever_rate", 30 },
                            { "api/v1/lightning_close_position", 1 },
                            { "api/v1/contract_order_info", 1 },
                            { "api/v1/contract_order_detail", 1 },
                            { "api/v1/contract_openorders", 1 },
                            { "api/v1/contract_hisorders", 1 },
                            { "api/v1/contract_hisorders_exact", 1 },
                            { "api/v1/contract_matchresults", 1 },
                            { "api/v1/contract_matchresults_exact", 1 },
                            { "api/v3/contract_hisorders", 1 },
                            { "api/v3/contract_hisorders_exact", 1 },
                            { "api/v3/contract_matchresults", 1 },
                            { "api/v3/contract_matchresults_exact", 1 },
                            { "api/v1/contract_trigger_order", 1 },
                            { "api/v1/contract_trigger_cancel", 1 },
                            { "api/v1/contract_trigger_cancelall", 1 },
                            { "api/v1/contract_trigger_openorders", 1 },
                            { "api/v1/contract_trigger_hisorders", 1 },
                            { "api/v1/contract_tpsl_order", 1 },
                            { "api/v1/contract_tpsl_cancel", 1 },
                            { "api/v1/contract_tpsl_cancelall", 1 },
                            { "api/v1/contract_tpsl_openorders", 1 },
                            { "api/v1/contract_tpsl_hisorders", 1 },
                            { "api/v1/contract_relation_tpsl_order", 1 },
                            { "api/v1/contract_track_order", 1 },
                            { "api/v1/contract_track_cancel", 1 },
                            { "api/v1/contract_track_cancelall", 1 },
                            { "api/v1/contract_track_openorders", 1 },
                            { "api/v1/contract_track_hisorders", 1 },
                            { "swap-api/v1/swap_balance_valuation", 1 },
                            { "swap-api/v1/swap_account_info", 1 },
                            { "swap-api/v1/swap_position_info", 1 },
                            { "swap-api/v1/swap_account_position_info", 1 },
                            { "swap-api/v1/swap_sub_auth", 1 },
                            { "swap-api/v1/swap_sub_account_list", 1 },
                            { "swap-api/v1/swap_sub_account_info_list", 1 },
                            { "swap-api/v1/swap_sub_account_info", 1 },
                            { "swap-api/v1/swap_sub_position_info", 1 },
                            { "swap-api/v1/swap_financial_record", 1 },
                            { "swap-api/v1/swap_financial_record_exact", 1 },
                            { "swap-api/v1/swap_user_settlement_records", 1 },
                            { "swap-api/v1/swap_available_level_rate", 1 },
                            { "swap-api/v1/swap_order_limit", 1 },
                            { "swap-api/v1/swap_fee", 1 },
                            { "swap-api/v1/swap_transfer_limit", 1 },
                            { "swap-api/v1/swap_position_limit", 1 },
                            { "swap-api/v1/swap_master_sub_transfer", 1 },
                            { "swap-api/v1/swap_master_sub_transfer_record", 1 },
                            { "swap-api/v3/swap_financial_record", 1 },
                            { "swap-api/v3/swap_financial_record_exact", 1 },
                            { "swap-api/v1/swap-cancel-after", 1 },
                            { "swap-api/v1/swap_order", 1 },
                            { "swap-api/v1/swap_batchorder", 1 },
                            { "swap-api/v1/swap_cancel", 1 },
                            { "swap-api/v1/swap_cancelall", 1 },
                            { "swap-api/v1/swap_lightning_close_position", 1 },
                            { "swap-api/v1/swap_switch_lever_rate", 30 },
                            { "swap-api/v1/swap_order_info", 1 },
                            { "swap-api/v1/swap_order_detail", 1 },
                            { "swap-api/v1/swap_openorders", 1 },
                            { "swap-api/v1/swap_hisorders", 1 },
                            { "swap-api/v1/swap_hisorders_exact", 1 },
                            { "swap-api/v1/swap_matchresults", 1 },
                            { "swap-api/v1/swap_matchresults_exact", 1 },
                            { "swap-api/v3/swap_matchresults", 1 },
                            { "swap-api/v3/swap_matchresults_exact", 1 },
                            { "swap-api/v3/swap_hisorders", 1 },
                            { "swap-api/v3/swap_hisorders_exact", 1 },
                            { "swap-api/v1/swap_trigger_order", 1 },
                            { "swap-api/v1/swap_trigger_cancel", 1 },
                            { "swap-api/v1/swap_trigger_cancelall", 1 },
                            { "swap-api/v1/swap_trigger_openorders", 1 },
                            { "swap-api/v1/swap_trigger_hisorders", 1 },
                            { "swap-api/v1/swap_tpsl_order", 1 },
                            { "swap-api/v1/swap_tpsl_cancel", 1 },
                            { "swap-api/v1/swap_tpsl_cancelall", 1 },
                            { "swap-api/v1/swap_tpsl_openorders", 1 },
                            { "swap-api/v1/swap_tpsl_hisorders", 1 },
                            { "swap-api/v1/swap_relation_tpsl_order", 1 },
                            { "swap-api/v1/swap_track_order", 1 },
                            { "swap-api/v1/swap_track_cancel", 1 },
                            { "swap-api/v1/swap_track_cancelall", 1 },
                            { "swap-api/v1/swap_track_openorders", 1 },
                            { "swap-api/v1/swap_track_hisorders", 1 },
                            { "linear-swap-api/v1/swap_lever_position_limit", 1 },
                            { "linear-swap-api/v1/swap_cross_lever_position_limit", 1 },
                            { "linear-swap-api/v1/swap_balance_valuation", 1 },
                            { "linear-swap-api/v1/swap_account_info", 1 },
                            { "linear-swap-api/v1/swap_cross_account_info", 1 },
                            { "linear-swap-api/v1/swap_position_info", 1 },
                            { "linear-swap-api/v1/swap_cross_position_info", 1 },
                            { "linear-swap-api/v1/swap_account_position_info", 1 },
                            { "linear-swap-api/v1/swap_cross_account_position_info", 1 },
                            { "linear-swap-api/v1/swap_sub_auth", 1 },
                            { "linear-swap-api/v1/swap_sub_account_list", 1 },
                            { "linear-swap-api/v1/swap_cross_sub_account_list", 1 },
                            { "linear-swap-api/v1/swap_sub_account_info_list", 1 },
                            { "linear-swap-api/v1/swap_cross_sub_account_info_list", 1 },
                            { "linear-swap-api/v1/swap_sub_account_info", 1 },
                            { "linear-swap-api/v1/swap_cross_sub_account_info", 1 },
                            { "linear-swap-api/v1/swap_sub_position_info", 1 },
                            { "linear-swap-api/v1/swap_cross_sub_position_info", 1 },
                            { "linear-swap-api/v1/swap_financial_record", 1 },
                            { "linear-swap-api/v1/swap_financial_record_exact", 1 },
                            { "linear-swap-api/v1/swap_user_settlement_records", 1 },
                            { "linear-swap-api/v1/swap_cross_user_settlement_records", 1 },
                            { "linear-swap-api/v1/swap_available_level_rate", 1 },
                            { "linear-swap-api/v1/swap_cross_available_level_rate", 1 },
                            { "linear-swap-api/v1/swap_order_limit", 1 },
                            { "linear-swap-api/v1/swap_fee", 1 },
                            { "linear-swap-api/v1/swap_transfer_limit", 1 },
                            { "linear-swap-api/v1/swap_cross_transfer_limit", 1 },
                            { "linear-swap-api/v1/swap_position_limit", 1 },
                            { "linear-swap-api/v1/swap_cross_position_limit", 1 },
                            { "linear-swap-api/v1/swap_master_sub_transfer", 1 },
                            { "linear-swap-api/v1/swap_master_sub_transfer_record", 1 },
                            { "linear-swap-api/v1/swap_transfer_inner", 1 },
                            { "linear-swap-api/v3/swap_financial_record", 1 },
                            { "linear-swap-api/v3/swap_financial_record_exact", 1 },
                            { "linear-swap-api/v1/swap_order", 1 },
                            { "linear-swap-api/v1/swap_cross_order", 1 },
                            { "linear-swap-api/v1/swap_batchorder", 1 },
                            { "linear-swap-api/v1/swap_cross_batchorder", 1 },
                            { "linear-swap-api/v1/swap_cancel", 1 },
                            { "linear-swap-api/v1/swap_cross_cancel", 1 },
                            { "linear-swap-api/v1/swap_cancelall", 1 },
                            { "linear-swap-api/v1/swap_cross_cancelall", 1 },
                            { "linear-swap-api/v1/swap_switch_lever_rate", 30 },
                            { "linear-swap-api/v1/swap_cross_switch_lever_rate", 30 },
                            { "linear-swap-api/v1/swap_lightning_close_position", 1 },
                            { "linear-swap-api/v1/swap_cross_lightning_close_position", 1 },
                            { "linear-swap-api/v1/swap_order_info", 1 },
                            { "linear-swap-api/v1/swap_cross_order_info", 1 },
                            { "linear-swap-api/v1/swap_order_detail", 1 },
                            { "linear-swap-api/v1/swap_cross_order_detail", 1 },
                            { "linear-swap-api/v1/swap_openorders", 1 },
                            { "linear-swap-api/v1/swap_cross_openorders", 1 },
                            { "linear-swap-api/v1/swap_hisorders", 1 },
                            { "linear-swap-api/v1/swap_cross_hisorders", 1 },
                            { "linear-swap-api/v1/swap_hisorders_exact", 1 },
                            { "linear-swap-api/v1/swap_cross_hisorders_exact", 1 },
                            { "linear-swap-api/v1/swap_matchresults", 1 },
                            { "linear-swap-api/v1/swap_cross_matchresults", 1 },
                            { "linear-swap-api/v1/swap_matchresults_exact", 1 },
                            { "linear-swap-api/v1/swap_cross_matchresults_exact", 1 },
                            { "linear-swap-api/v1/linear-cancel-after", 1 },
                            { "linear-swap-api/v1/swap_switch_position_mode", 1 },
                            { "linear-swap-api/v1/swap_cross_switch_position_mode", 1 },
                            { "linear-swap-api/v3/swap_matchresults", 1 },
                            { "linear-swap-api/v3/swap_cross_matchresults", 1 },
                            { "linear-swap-api/v3/swap_matchresults_exact", 1 },
                            { "linear-swap-api/v3/swap_cross_matchresults_exact", 1 },
                            { "linear-swap-api/v3/swap_hisorders", 1 },
                            { "linear-swap-api/v3/swap_cross_hisorders", 1 },
                            { "linear-swap-api/v3/swap_hisorders_exact", 1 },
                            { "linear-swap-api/v3/swap_cross_hisorders_exact", 1 },
                            { "linear-swap-api/v3/fix_position_margin_change", 1 },
                            { "linear-swap-api/v3/swap_switch_account_type", 1 },
                            { "linear-swap-api/v3/linear_swap_fee_switch", 1 },
                            { "linear-swap-api/v1/swap_trigger_order", 1 },
                            { "linear-swap-api/v1/swap_cross_trigger_order", 1 },
                            { "linear-swap-api/v1/swap_trigger_cancel", 1 },
                            { "linear-swap-api/v1/swap_cross_trigger_cancel", 1 },
                            { "linear-swap-api/v1/swap_trigger_cancelall", 1 },
                            { "linear-swap-api/v1/swap_cross_trigger_cancelall", 1 },
                            { "linear-swap-api/v1/swap_trigger_openorders", 1 },
                            { "linear-swap-api/v1/swap_cross_trigger_openorders", 1 },
                            { "linear-swap-api/v1/swap_trigger_hisorders", 1 },
                            { "linear-swap-api/v1/swap_cross_trigger_hisorders", 1 },
                            { "linear-swap-api/v1/swap_tpsl_order", 1 },
                            { "linear-swap-api/v1/swap_cross_tpsl_order", 1 },
                            { "linear-swap-api/v1/swap_tpsl_cancel", 1 },
                            { "linear-swap-api/v1/swap_cross_tpsl_cancel", 1 },
                            { "linear-swap-api/v1/swap_tpsl_cancelall", 1 },
                            { "linear-swap-api/v1/swap_cross_tpsl_cancelall", 1 },
                            { "linear-swap-api/v1/swap_tpsl_openorders", 1 },
                            { "linear-swap-api/v1/swap_cross_tpsl_openorders", 1 },
                            { "linear-swap-api/v1/swap_tpsl_hisorders", 1 },
                            { "linear-swap-api/v1/swap_cross_tpsl_hisorders", 1 },
                            { "linear-swap-api/v1/swap_relation_tpsl_order", 1 },
                            { "linear-swap-api/v1/swap_cross_relation_tpsl_order", 1 },
                            { "linear-swap-api/v1/swap_track_order", 1 },
                            { "linear-swap-api/v1/swap_cross_track_order", 1 },
                            { "linear-swap-api/v1/swap_track_cancel", 1 },
                            { "linear-swap-api/v1/swap_cross_track_cancel", 1 },
                            { "linear-swap-api/v1/swap_track_cancelall", 1 },
                            { "linear-swap-api/v1/swap_cross_track_cancelall", 1 },
                            { "linear-swap-api/v1/swap_track_openorders", 1 },
                            { "linear-swap-api/v1/swap_cross_track_openorders", 1 },
                            { "linear-swap-api/v1/swap_track_hisorders", 1 },
                            { "linear-swap-api/v1/swap_cross_track_hisorders", 1 },
                            { "v5/account/asset_mode", 1 },
                            { "v5/trade/order", 1 },
                            { "v5/trade/batch_orders", 1 },
                            { "v5/trade/cancel_order", 1 },
                            { "v5/trade/cancel_batch_orders", 1 },
                            { "v5/trade/cancel_all_orders", 1 },
                            { "v5/trade/position", 1 },
                            { "v5/trade/position_all", 1 },
                            { "v5/position/lever", 1 },
                            { "v5/position/mode", 1 },
                            { "v5/account/fee_deduction_currency", 1 },
                        } },
                    } },
                } },
            } },
            { "fees", new Dictionary<string, object>() {
                { "trading", new Dictionary<string, object>() {
                    { "feeSide", "get" },
                    { "tierBased", false },
                    { "percentage", true },
                    { "maker", this.parseNumber("0.002") },
                    { "taker", this.parseNumber("0.002") },
                } },
            } },
            { "exceptions", new Dictionary<string, object>() {
                { "broad", new Dictionary<string, object>() {
                    { "contract is restricted of closing positions on API.  Please contact customer service", typeof(OnMaintenance) },
                    { "maintain", typeof(OnMaintenance) },
                    { "API key has no permission", typeof(PermissionDenied) },
                } },
                { "exact", new Dictionary<string, object>() {
                    { "403", typeof(AuthenticationError) },
                    { "1010", typeof(AccountNotEnabled) },
                    { "1003", typeof(AuthenticationError) },
                    { "1013", typeof(BadSymbol) },
                    { "1017", typeof(OrderNotFound) },
                    { "1034", typeof(InvalidOrder) },
                    { "1036", typeof(InvalidOrder) },
                    { "1039", typeof(InvalidOrder) },
                    { "1041", typeof(InvalidOrder) },
                    { "1047", typeof(InsufficientFunds) },
                    { "1048", typeof(InsufficientFunds) },
                    { "1061", typeof(OrderNotFound) },
                    { "1051", typeof(InvalidOrder) },
                    { "1066", typeof(BadSymbol) },
                    { "1067", typeof(InvalidOrder) },
                    { "1094", typeof(InvalidOrder) },
                    { "1220", typeof(AccountNotEnabled) },
                    { "1303", typeof(BadRequest) },
                    { "1461", typeof(InvalidOrder) },
                    { "4007", typeof(BadRequest) },
                    { "bad-request", typeof(BadRequest) },
                    { "validation-format-error", typeof(BadRequest) },
                    { "validation-constraints-required", typeof(BadRequest) },
                    { "base-date-limit-error", typeof(BadRequest) },
                    { "api-not-support-temp-addr", typeof(PermissionDenied) },
                    { "timeout", typeof(RequestTimeout) },
                    { "gateway-internal-error", typeof(ExchangeNotAvailable) },
                    { "account-frozen-balance-insufficient-error", typeof(InsufficientFunds) },
                    { "invalid-amount", typeof(InvalidOrder) },
                    { "order-limitorder-amount-min-error", typeof(InvalidOrder) },
                    { "order-limitorder-amount-max-error", typeof(InvalidOrder) },
                    { "order-marketorder-amount-min-error", typeof(InvalidOrder) },
                    { "order-limitorder-price-min-error", typeof(InvalidOrder) },
                    { "order-limitorder-price-max-error", typeof(InvalidOrder) },
                    { "order-limitorder-price-buy-min-error", typeof(InvalidOrder) },
                    { "order-limitorder-price-buy-max-error", typeof(InvalidOrder) },
                    { "order-limitorder-price-sell-min-error", typeof(InvalidOrder) },
                    { "order-limitorder-price-sell-max-error", typeof(InvalidOrder) },
                    { "order-stop-order-hit-trigger", typeof(InvalidOrder) },
                    { "order-value-min-error", typeof(InvalidOrder) },
                    { "order-invalid-price", typeof(InvalidOrder) },
                    { "order-holding-limit-failed", typeof(InvalidOrder) },
                    { "order-orderprice-precision-error", typeof(InvalidOrder) },
                    { "order-etp-nav-price-max-error", typeof(InvalidOrder) },
                    { "order-orderstate-error", typeof(OrderNotFound) },
                    { "order-queryorder-invalid", typeof(OrderNotFound) },
                    { "order-update-error", typeof(ExchangeNotAvailable) },
                    { "api-signature-check-failed", typeof(AuthenticationError) },
                    { "api-signature-not-valid", typeof(AuthenticationError) },
                    { "base-record-invalid", typeof(OrderNotFound) },
                    { "base-symbol-trade-disabled", typeof(BadSymbol) },
                    { "base-symbol-error", typeof(BadSymbol) },
                    { "system-maintenance", typeof(OnMaintenance) },
                    { "base-request-exceed-frequency-limit", typeof(RateLimitExceeded) },
                    { "rate-too-many-requests", typeof(RateLimitExceeded) },
                    { "invalid symbol", typeof(BadSymbol) },
                    { "symbol trade not open now", typeof(BadSymbol) },
                    { "require-symbol", typeof(BadSymbol) },
                    { "invalid-address", typeof(BadRequest) },
                    { "base-currency-chain-error", typeof(BadRequest) },
                    { "dw-insufficient-balance", typeof(InsufficientFunds) },
                    { "base-withdraw-fee-error", typeof(BadRequest) },
                    { "dw-withdraw-min-limit", typeof(BadRequest) },
                    { "request limit", typeof(RateLimitExceeded) },
                } },
            } },
            { "precisionMode", TICK_SIZE },
            { "options", new Dictionary<string, object>() {
                { "include_OS_certificates", false },
                { "fetchMarkets", new Dictionary<string, object>() {
                    { "types", new Dictionary<string, object>() {
                        { "spot", true },
                        { "linear", true },
                        { "inverse", true },
                    } },
                } },
                { "timeDifference", 0 },
                { "adjustForTimeDifference", false },
                { "fetchOHLCV", new Dictionary<string, object>() {
                    { "useHistoricalEndpointForSpot", true },
                } },
                { "withdraw", new Dictionary<string, object>() {
                    { "includeFee", false },
                } },
                { "defaultType", "spot" },
                { "defaultSubType", "linear" },
                { "defaultNetwork", "ERC20" },
                { "defaultNetworks", new Dictionary<string, object>() {
                    { "ETH", "ERC20" },
                    { "BTC", "BTC" },
                    { "USDT", "TRC20" },
                } },
                { "networks", new Dictionary<string, object>() {
                    { "TRC20", "TRX" },
                    { "BTC", "BTC" },
                    { "ERC20", "ETH" },
                    { "SOL", "SOLANA" },
                    { "HRC20", "HECO" },
                    { "BEP20", "BSC" },
                    { "XMR", "XMR" },
                    { "LTC", "LTC" },
                    { "XRP", "XRP" },
                    { "XLM", "XLM" },
                    { "CRONOS", "CRO" },
                    { "CRO", "CRO" },
                    { "GLMR", "GLMR" },
                    { "POLYGON", "MATIC" },
                    { "MATIC", "MATIC" },
                    { "BTT", "BTT" },
                    { "CUBE", "CUBE" },
                    { "IOST", "IOST" },
                    { "NEO", "NEO" },
                    { "KLAY", "KLAY" },
                    { "EOS", "EOS" },
                    { "THETA", "THETA" },
                    { "NAS", "NAS" },
                    { "NULS", "NULS" },
                    { "QTUM", "QTUM" },
                    { "FTM", "FTM" },
                    { "CELO", "CELO" },
                    { "DOGE", "DOGE" },
                    { "DOGECHAIN", "DOGECHAIN" },
                    { "NEAR", "NEAR" },
                    { "STEP", "STEP" },
                    { "BITCI", "BITCI" },
                    { "CARDANO", "ADA" },
                    { "ADA", "ADA" },
                    { "ETC", "ETC" },
                    { "LUK", "LUK" },
                    { "MINEPLEX", "MINEPLEX" },
                    { "DASH", "DASH" },
                    { "ZEC", "ZEC" },
                    { "IOTA", "IOTA" },
                    { "NEON3", "NEON3" },
                    { "XEM", "XEM" },
                    { "HC", "HC" },
                    { "LSK", "LSK" },
                    { "DCR", "DCR" },
                    { "BTG", "BTG" },
                    { "STEEM", "STEEM" },
                    { "BTS", "BTS" },
                    { "ICX", "ICX" },
                    { "WAVES", "WAVES" },
                    { "CMT", "CMT" },
                    { "BTM", "BTM" },
                    { "VET", "VET" },
                    { "XZC", "XZC" },
                    { "ACT", "ACT" },
                    { "SMT", "SMT" },
                    { "BCD", "BCD" },
                    { "WAX", "WAX1" },
                    { "WICC", "WICC" },
                    { "ELF", "ELF" },
                    { "ZIL", "ZIL" },
                    { "ELA", "ELA" },
                    { "BCX", "BCX" },
                    { "SBTC", "SBTC" },
                    { "BIFI", "BIFI" },
                    { "CTXC", "CTXC" },
                    { "WAN", "WAN" },
                    { "POLYX", "POLYX" },
                    { "PAI", "PAI" },
                    { "WTC", "WTC" },
                    { "DGB", "DGB" },
                    { "XVG", "XVG" },
                    { "AAC", "AAC" },
                    { "AE", "AE" },
                    { "SEELE", "SEELE" },
                    { "BCV", "BCV" },
                    { "GRS", "GRS" },
                    { "ARDR", "ARDR" },
                    { "NANO", "NANO" },
                    { "ZEN", "ZEN" },
                    { "RBTC", "RBTC" },
                    { "BSV", "BSV" },
                    { "GAS", "GAS" },
                    { "XTZ", "XTZ" },
                    { "LAMB", "LAMB" },
                    { "CVNT1", "CVNT1" },
                    { "DOCK", "DOCK" },
                    { "SC", "SC" },
                    { "KMD", "KMD" },
                    { "ETN", "ETN" },
                    { "TOP", "TOP" },
                    { "IRIS", "IRIS" },
                    { "UGAS", "UGAS" },
                    { "TT", "TT" },
                    { "NEWTON", "NEWTON" },
                    { "VSYS", "VSYS" },
                    { "FSN", "FSN" },
                    { "BHD", "BHD" },
                    { "ONE", "ONE" },
                    { "EM", "EM" },
                    { "CKB", "CKB" },
                    { "EOSS", "EOSS" },
                    { "HIVE", "HIVE" },
                    { "RVN", "RVN" },
                    { "DOT", "DOT" },
                    { "KSM", "KSM" },
                    { "BAND", "BAND" },
                    { "OEP4", "OEP4" },
                    { "NBS", "NBS" },
                    { "FIS", "FIS" },
                    { "AR", "AR" },
                    { "HBAR", "HBAR" },
                    { "FIL", "FIL" },
                    { "MASS", "MASS" },
                    { "KAVA", "KAVA" },
                    { "XYM", "XYM" },
                    { "ENJ", "ENJ" },
                    { "CRUST", "CRUST" },
                    { "ICP", "ICP" },
                    { "CSPR", "CSPR" },
                    { "FLOW", "FLOW" },
                    { "IOTX", "IOTX" },
                    { "LAT", "LAT" },
                    { "APT", "APT" },
                    { "XCH", "XCH" },
                    { "MINA", "MINA" },
                    { "XEC", "ECASH" },
                    { "XPRT", "XPRT" },
                    { "CCA", "ACA" },
                    { "AOTI", "COTI" },
                    { "AKT", "AKT" },
                    { "ARS", "ARS" },
                    { "ASTR", "ASTR" },
                    { "AZERO", "AZERO" },
                    { "BLD", "BLD" },
                    { "BRISE", "BRISE" },
                    { "CORE", "CORE" },
                    { "DESO", "DESO" },
                    { "DFI", "DFI" },
                    { "EGLD", "EGLD" },
                    { "ERG", "ERG" },
                    { "ETHF", "ETHFAIR" },
                    { "ETHW", "ETHW" },
                    { "EVMOS", "EVMOS" },
                    { "FIO", "FIO" },
                    { "FLR", "FLR" },
                    { "FINSCHIA", "FINSCHIA" },
                    { "KMA", "KMA" },
                    { "KYVE", "KYVE" },
                    { "MEV", "MEV" },
                    { "MOVR", "MOVR" },
                    { "NODL", "NODL" },
                    { "OAS", "OAS" },
                    { "OSMO", "OSMO" },
                    { "PAYCOIN", "PAYCOIN" },
                    { "POKT", "POKT" },
                    { "PYG", "PYG" },
                    { "REI", "REI" },
                    { "SCRT", "SCRT" },
                    { "SDN", "SDN" },
                    { "SEI", "SEI" },
                    { "SGB", "SGB" },
                    { "SUI", "SUI" },
                    { "SXP", "SOLAR" },
                    { "SYS", "SYS" },
                    { "TENET", "TENET" },
                    { "TON", "TON" },
                    { "UNQ", "UNQ" },
                    { "UYU", "UYU" },
                    { "WEMIX", "WEMIX" },
                    { "XDC", "XDC" },
                    { "XPLA", "XPLA" },
                } },
                { "fetchOrdersByStatesMethod", "spot_private_get_v1_order_orders" },
                { "createMarketBuyOrderRequiresPrice", true },
                { "language", "en-US" },
                { "broker", new Dictionary<string, object>() {
                    { "id", "AA03022abc" },
                } },
                { "accountsByType", new Dictionary<string, object>() {
                    { "spot", "pro" },
                    { "funding", "pro" },
                    { "future", "futures" },
                } },
                { "accountsById", new Dictionary<string, object>() {
                    { "spot", "spot" },
                    { "margin", "margin" },
                    { "otc", "otc" },
                    { "point", "point" },
                    { "super-margin", "super-margin" },
                    { "investment", "investment" },
                    { "borrow", "borrow" },
                    { "grid-trading", "grid-trading" },
                    { "deposit-earning", "deposit-earning" },
                    { "otc-options", "otc-options" },
                } },
                { "typesByAccount", new Dictionary<string, object>() {
                    { "pro", "spot" },
                    { "futures", "future" },
                } },
                { "spot", new Dictionary<string, object>() {
                    { "stopOrderTypes", new Dictionary<string, object>() {
                        { "stop-limit", true },
                        { "buy-stop-limit", true },
                        { "sell-stop-limit", true },
                        { "stop-limit-fok", true },
                        { "buy-stop-limit-fok", true },
                        { "sell-stop-limit-fok", true },
                    } },
                    { "limitOrderTypes", new Dictionary<string, object>() {
                        { "limit", true },
                        { "buy-limit", true },
                        { "sell-limit", true },
                        { "ioc", true },
                        { "buy-ioc", true },
                        { "sell-ioc", true },
                        { "limit-maker", true },
                        { "buy-limit-maker", true },
                        { "sell-limit-maker", true },
                        { "stop-limit", true },
                        { "buy-stop-limit", true },
                        { "sell-stop-limit", true },
                        { "limit-fok", true },
                        { "buy-limit-fok", true },
                        { "sell-limit-fok", true },
                        { "stop-limit-fok", true },
                        { "buy-stop-limit-fok", true },
                        { "sell-stop-limit-fok", true },
                    } },
                } },
            } },
            { "commonCurrencies", new Dictionary<string, object>() {
                { "NGL", "GFNGL" },
                { "GET", "THEMIS" },
                { "GTC", "GAMECOM" },
                { "HIT", "HITCHAIN" },
                { "PNT", "PENTA" },
                { "SBTC", "SUPERBITCOIN" },
                { "SOUL", "SOULSAVER" },
                { "BIFI", "BITCOINFILE" },
                { "FUD", "FTX Users Debt" },
            } },
            { "features", new Dictionary<string, object>() {
                { "spot", new Dictionary<string, object>() {
                    { "sandbox", true },
                    { "createOrder", new Dictionary<string, object>() {
                        { "marginMode", true },
                        { "triggerPrice", true },
                        { "triggerDirection", true },
                        { "triggerPriceType", null },
                        { "stopLossPrice", false },
                        { "takeProfitPrice", false },
                        { "attachedStopLossTakeProfit", null },
                        { "timeInForce", new Dictionary<string, object>() {
                            { "IOC", true },
                            { "FOK", true },
                            { "PO", true },
                            { "GTD", false },
                        } },
                        { "hedged", false },
                        { "trailing", false },
                        { "iceberg", false },
                        { "selfTradePrevention", true },
                        { "leverage", true },
                        { "marketBuyByCost", true },
                        { "marketBuyRequiresPrice", true },
                    } },
                    { "createOrders", new Dictionary<string, object>() {
                        { "max", 10 },
                    } },
                    { "fetchMyTrades", new Dictionary<string, object>() {
                        { "marginMode", false },
                        { "limit", 500 },
                        { "daysBack", 120 },
                        { "untilDays", 2 },
                        { "symbolRequired", false },
                    } },
                    { "fetchOrder", new Dictionary<string, object>() {
                        { "marginMode", false },
                        { "trigger", false },
                        { "trailing", false },
                        { "symbolRequired", false },
                    } },
                    { "fetchOpenOrders", new Dictionary<string, object>() {
                        { "marginMode", false },
                        { "trigger", true },
                        { "trailing", false },
                        { "limit", 500 },
                        { "symbolRequired", false },
                    } },
                    { "fetchOrders", new Dictionary<string, object>() {
                        { "marginMode", false },
                        { "trigger", true },
                        { "trailing", false },
                        { "limit", 500 },
                        { "untilDays", 2 },
                        { "daysBack", 180 },
                        { "symbolRequired", false },
                    } },
                    { "fetchClosedOrders", new Dictionary<string, object>() {
                        { "marginMode", false },
                        { "trigger", true },
                        { "trailing", false },
                        { "untilDays", 2 },
                        { "limit", 500 },
                        { "daysBack", 180 },
                        { "daysBackCanceled", divide(1, 12) },
                        { "symbolRequired", false },
                    } },
                    { "fetchOHLCV", new Dictionary<string, object>() {
                        { "limit", 1000 },
                    } },
                } },
                { "forDerivatives", new Dictionary<string, object>() {
                    { "extends", "spot" },
                    { "createOrder", new Dictionary<string, object>() {
                        { "stopLossPrice", true },
                        { "takeProfitPrice", true },
                        { "trailing", true },
                        { "hedged", true },
                    } },
                    { "createOrders", new Dictionary<string, object>() {
                        { "max", 25 },
                    } },
                    { "fetchOrder", new Dictionary<string, object>() {
                        { "marginMode", true },
                    } },
                    { "fetchOpenOrders", new Dictionary<string, object>() {
                        { "marginMode", true },
                        { "trigger", false },
                        { "trailing", false },
                        { "limit", 50 },
                    } },
                    { "fetchOrders", new Dictionary<string, object>() {
                        { "marginMode", true },
                        { "trigger", false },
                        { "trailing", false },
                        { "limit", 50 },
                        { "daysBack", 90 },
                    } },
                    { "fetchClosedOrders", new Dictionary<string, object>() {
                        { "marginMode", true },
                        { "trigger", false },
                        { "trailing", false },
                        { "untilDays", 2 },
                        { "limit", 50 },
                        { "daysBack", 90 },
                        { "daysBackCanceled", divide(1, 12) },
                    } },
                    { "fetchOHLCV", new Dictionary<string, object>() {
                        { "limit", 2000 },
                    } },
                } },
                { "swap", new Dictionary<string, object>() {
                    { "linear", new Dictionary<string, object>() {
                        { "extends", "forDerivatives" },
                    } },
                    { "inverse", new Dictionary<string, object>() {
                        { "extends", "forDerivatives" },
                    } },
                } },
                { "future", new Dictionary<string, object>() {
                    { "linear", new Dictionary<string, object>() {
                        { "extends", "forDerivatives" },
                    } },
                    { "inverse", new Dictionary<string, object>() {
                        { "extends", "forDerivatives" },
                    } },
                } },
            } },
        });
    }

    /**
     * @method
     * @name htx#fetchStatus
     * @description the latest known information on the availability of the exchange API
     * @see https://huobiapi.github.io/docs/spot/v1/en/#get-system-status
     * @see https://huobiapi.github.io/docs/dm/v1/en/#get-system-status
     * @see https://huobiapi.github.io/docs/coin_margined_swap/v1/en/#get-system-status
     * @see https://huobiapi.github.io/docs/usdt_swap/v1/en/#get-system-status
     * @see https://huobiapi.github.io/docs/usdt_swap/v1/en/#query-whether-the-system-is-available  // contractPublicGetHeartbeat
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [status structure]{@link https://docs.ccxt.com/?id=exchange-status-structure}
     */
    public async override Task<object> fetchStatus(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object marketType = null;
        var marketTypeparametersVariable = this.handleMarketTypeAndParams("fetchStatus", null, parameters);
        marketType = ((IList<object>)marketTypeparametersVariable)[0];
        parameters = ((IList<object>)marketTypeparametersVariable)[1];
        object enabledForContracts = this.handleOption("fetchStatus", "enableForContracts", false); // temp fix for: https://status-linear-swap.huobigroup.com/api/v2/summary.json
        object response = null;
        if (isTrue(isTrue(!isEqual(marketType, "spot")) && isTrue(enabledForContracts)))
        {
            object subType = this.safeString(parameters, "subType", getValue(this.options, "defaultSubType"));
            if (isTrue(isEqual(marketType, "swap")))
            {
                if (isTrue(isEqual(subType, "linear")))
                {
                    response = await this.statusPublicSwapLinearGetApiV2SummaryJson();
                } else if (isTrue(isEqual(subType, "inverse")))
                {
                    response = await this.statusPublicSwapInverseGetApiV2SummaryJson();
                }
            } else if (isTrue(isEqual(marketType, "future")))
            {
                if (isTrue(isEqual(subType, "linear")))
                {
                    response = await this.statusPublicFutureLinearGetApiV2SummaryJson();
                } else if (isTrue(isEqual(subType, "inverse")))
                {
                    response = await this.statusPublicFutureInverseGetApiV2SummaryJson();
                }
            } else if (isTrue(isEqual(marketType, "contract")))
            {
                response = await this.contractPublicGetHeartbeat();
            }
        } else if (isTrue(isEqual(marketType, "spot")))
        {
            response = await this.statusPublicSpotGetApiV2SummaryJson();
        }
        //
        // statusPublicSpotGetApiV2SummaryJson, statusPublicSwapInverseGetApiV2SummaryJson, statusPublicFutureLinearGetApiV2SummaryJson, statusPublicFutureInverseGetApiV2SummaryJson
        //
        //      {
        //          "page": {
        //              "id":"mn7l2lw8pz4p",
        //              "name":"Huobi Futures-USDT-margined Swaps",
        //              "url":"https://status-linear-swap.huobigroup.com",
        //              "time_zone":"Asia/Singapore",
        //              "updated_at":"2022-04-29T12:47:21.319+08:00"},
        //              "components": [
        //                  {
        //                      "id":"lrv093qk3yp5",
        //                      "name":"market data",
        //                      "status":"operational",
        //                      "created_at":"2020-10-29T14:08:59.427+08:00",
        //                      "updated_at":"2020-10-29T14:08:59.427+08:00",
        //                      "position":1,"description":null,
        //                      "showcase":false,
        //                      "start_date":null,
        //                      "group_id":null,
        //                      "page_id":"mn7l2lw8pz4p",
        //                      "group":true,
        //                      "only_show_if_degraded":false,
        //                      "components": [
        //                          "82k5jxg7ltxd" // list of related components
        //                      ]
        //                  },
        //              ],
        //              "incidents": [ // empty array if there are no issues
        //                  {
        //                      "id": "rclfxz2g21ly",  // incident id
        //                      "name": "Market data is delayed",  // incident name
        //                      "status": "investigating",  // incident status
        //                      "created_at": "2020-02-11T03:15:01.913Z",  // incident create time
        //                      "updated_at": "2020-02-11T03:15:02.003Z",   // incident update time
        //                      "monitoring_at": null,
        //                      "resolved_at": null,
        //                      "impact": "minor",  // incident impact
        //                      "shortlink": "http://stspg.io/pkvbwp8jppf9",
        //                      "started_at": "2020-02-11T03:15:01.906Z",
        //                      "page_id": "p0qjfl24znv5",
        //                      "incident_updates": [
        //                          {
        //                              "id": "dwfsk5ttyvtb",
        //                              "status": "investigating",
        //                              "body": "Market data is delayed",
        //                              "incident_id": "rclfxz2g21ly",
        //                              "created_at": "2020-02-11T03:15:02.000Z",
        //                              "updated_at": "2020-02-11T03:15:02.000Z",
        //                              "display_at": "2020-02-11T03:15:02.000Z",
        //                              "affected_components": [
        //                                  {
        //                                      "code": "nctwm9tghxh6",
        //                                      "name": "Market data",
        //                                      "old_status": "operational",
        //                                      "new_status": "degraded_performance"
        //                                  }
        //                              ],
        //                              "deliver_notifications": true,
        //                              "custom_tweet": null,
        //                              "tweet_id": null
        //                          }
        //                      ],
        //                      "components": [
        //                          {
        //                              "id": "nctwm9tghxh6",
        //                              "name": "Market data",
        //                              "status": "degraded_performance",
        //                              "created_at": "2020-01-13T09:34:48.284Z",
        //                              "updated_at": "2020-02-11T03:15:01.951Z",
        //                              "position": 8,
        //                              "description": null,
        //                              "showcase": false,
        //                              "group_id": null,
        //                              "page_id": "p0qjfl24znv5",
        //                              "group": false,
        //                              "only_show_if_degraded": false
        //                          }
        //                      ]
        //                  }, ...
        //              ],
        //              "scheduled_maintenances":[ // empty array if there are no scheduled maintenances
        //                  {
        //                      "id": "k7g299zl765l", // incident id
        //                      "name": "Schedule maintenance", // incident name
        //                      "status": "scheduled", // incident status
        //                      "created_at": "2020-02-11T03:16:31.481Z",  // incident create time
        //                      "updated_at": "2020-02-11T03:16:31.530Z",  // incident update time
        //                      "monitoring_at": null,
        //                      "resolved_at": null,
        //                      "impact": "maintenance",  // incident impact
        //                      "shortlink": "http://stspg.io/md4t4ym7nytd",
        //                      "started_at": "2020-02-11T03:16:31.474Z",
        //                      "page_id": "p0qjfl24znv5",
        //                      "incident_updates": [
        //                          {
        //                              "id": "8whgr3rlbld8",
        //                              "status": "scheduled",
        //                              "body": "We will be undergoing scheduled maintenance during this time.",
        //                              "incident_id": "k7g299zl765l",
        //                              "created_at": "2020-02-11T03:16:31.527Z",
        //                              "updated_at": "2020-02-11T03:16:31.527Z",
        //                              "display_at": "2020-02-11T03:16:31.527Z",
        //                              "affected_components": [
        //                                  {
        //                                      "code": "h028tnzw1n5l",
        //                                      "name": "Deposit And Withdraw - Deposit",
        //                                      "old_status": "operational",
        //                                      "new_status": "operational"
        //                                  }
        //                              ],
        //                              "deliver_notifications": true,
        //                              "custom_tweet": null,
        //                              "tweet_id": null
        //                          }
        //                      ],
        //                      "components": [
        //                          {
        //                              "id": "h028tnzw1n5l",
        //                              "name": "Deposit",
        //                              "status": "operational",
        //                              "created_at": "2019-12-05T02:07:12.372Z",
        //                              "updated_at": "2020-02-10T12:34:52.970Z",
        //                              "position": 1,
        //                              "description": null,
        //                              "showcase": false,
        //                              "group_id": "gtd0nyr3pf0k",
        //                              "page_id": "p0qjfl24znv5",
        //                              "group": false,
        //                              "only_show_if_degraded": false
        //                          }
        //                      ],
        //                      "scheduled_for": "2020-02-15T00:00:00.000Z",  // scheduled maintenance start time
        //                      "scheduled_until": "2020-02-15T01:00:00.000Z"  // scheduled maintenance end time
        //                  }
        //              ],
        //              "status": {
        //                  "indicator":"none", // none, minor, major, critical, maintenance
        //                  "description":"all systems operational" // All Systems Operational, Minor Service Outage, Partial System Outage, Partially Degraded Service, Service Under Maintenance
        //              }
        //          }
        //
        //
        // contractPublicGetHeartbeat
        //
        //      {
        //          "status": "ok", // 'ok', 'error'
        //          "data": {
        //              "heartbeat": 1, // future 1: available, 0: maintenance with service suspended
        //              "estimated_recovery_time": null, // estimated recovery time in milliseconds
        //              "swap_heartbeat": 1,
        //              "swap_estimated_recovery_time": null,
        //              "option_heartbeat": 1,
        //              "option_estimated_recovery_time": null,
        //              "linear_swap_heartbeat": 1,
        //              "linear_swap_estimated_recovery_time": null
        //          },
        //          "ts": 1557714418033
        //      }
        //
        object status = null;
        object updated = null;
        object url = null;
        if (isTrue(isEqual(marketType, "contract")))
        {
            object statusRaw = this.safeString(response, "status");
            if (isTrue(isEqual(statusRaw, null)))
            {
                status = null;
            } else
            {
                status = ((bool) isTrue((isEqual(statusRaw, "ok")))) ? "ok" : "maintenance"; // 'ok', 'error'
            }
            updated = this.safeString(response, "ts");
        } else
        {
            object statusData = this.safeValue(response, "status", new Dictionary<string, object>() {});
            object statusRaw = this.safeString(statusData, "indicator");
            status = ((bool) isTrue((isEqual(statusRaw, "none")))) ? "ok" : "maintenance"; // none, minor, major, critical, maintenance
            object pageData = this.safeValue(response, "page", new Dictionary<string, object>() {});
            object datetime = this.safeString(pageData, "updated_at");
            updated = this.parse8601(datetime);
            url = this.safeString(pageData, "url");
        }
        return new Dictionary<string, object>() {
            { "status", status },
            { "updated", updated },
            { "eta", null },
            { "url", url },
            { "info", response },
        };
    }

    /**
     * @method
     * @name htx#fetchTime
     * @description fetches the current integer timestamp in milliseconds from the exchange server
     * @see https://huobiapi.github.io/docs/spot/v1/en/#get-current-timestamp
     * @see https://huobiapi.github.io/docs/coin_margined_swap/v1/en/#get-current-system-timestamp
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {int} the current integer timestamp in milliseconds from the exchange server
     */
    public async override Task<object> fetchTime(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object options = this.safeValue(this.options, "fetchTime", new Dictionary<string, object>() {});
        object defaultType = this.safeString(this.options, "defaultType", "spot");
        object type = this.safeString(options, "type", defaultType);
        type = this.safeString(parameters, "type", type);
        object response = null;
        if (isTrue(isTrue((isEqual(type, "future"))) || isTrue((isEqual(type, "swap")))))
        {
            response = await this.contractPublicGetApiV1Timestamp(parameters);
        } else
        {
            response = await this.spotPublicGetV1CommonTimestamp(parameters);
        }
        //
        // spot
        //
        //     {"status":"ok","data":1637504261099}
        //
        // future, swap
        //
        //     {"status":"ok","ts":1637504164707}
        //
        return this.safeInteger2(response, "data", "ts");
    }

    public virtual object parseTradingFee(object fee, object market = null)
    {
        //
        //     {
        //         "symbol":"btcusdt",
        //         "actualMakerRate":"0.002",
        //         "actualTakerRate":"0.002",
        //         "takerFeeRate":"0.002",
        //         "makerFeeRate":"0.002"
        //     }
        //
        object marketId = this.safeString(fee, "symbol");
        return new Dictionary<string, object>() {
            { "info", fee },
            { "symbol", this.safeSymbol(marketId, market) },
            { "maker", this.safeNumber(fee, "actualMakerRate") },
            { "taker", this.safeNumber(fee, "actualTakerRate") },
            { "percentage", null },
            { "tierBased", null },
        };
    }

    /**
     * @method
     * @name htx#fetchTradingFee
     * @description fetch the trading fees for a market
     * @see https://huobiapi.github.io/docs/spot/v1/en/#get-current-fee-rate-applied-to-the-user
     * @param {string} symbol unified market symbol
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [fee structure]{@link https://docs.ccxt.com/?id=fee-structure}
     */
    public async override Task<object> fetchTradingFee(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbols", getValue(market, "id") },
        };
        object response = await this.spotPrivateGetV2ReferenceTransactFeeRate(this.extend(request, parameters));
        //
        //     {
        //         "code":200,
        //         "data":[
        //             {
        //                 "symbol":"btcusdt",
        //                 "actualMakerRate":"0.002",
        //                 "actualTakerRate":"0.002",
        //                 "takerFeeRate":"0.002",
        //                 "makerFeeRate":"0.002"
        //             }
        //         ],
        //         "success":true
        //     }
        //
        object data = this.safeValue(response, "data", new List<object>() {});
        object first = this.safeValue(data, 0, new Dictionary<string, object>() {});
        return this.parseTradingFee(first, market);
    }

    public async override Task<object> fetchTradingLimits(object symbols = null, object parameters = null)
    {
        // this method should not be called directly, use loadTradingLimits () instead
        //  by default it will try load withdrawal fees of all currencies (with separate requests)
        //  however if you define symbols = [ 'ETH/BTC', 'LTC/BTC' ] in args it will only load those
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        if (isTrue(isEqual(symbols, null)))
        {
            symbols = this.symbols;
        }
        object result = new Dictionary<string, object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(symbols)); postFixIncrement(ref i))
        {
            object symbol = getValue(symbols, i);
            ((IDictionary<string,object>)result)[(string)symbol] = await this.fetchTradingLimitsById(this.marketId(symbol), parameters);
        }
        return result;
    }

    /**
     * @ignore
     * @method
     * @name htx#fetchTradingLimitsById
     * @see https://huobiapi.github.io/docs/spot/v1/en/#get-current-fee-rate-applied-to-the-user
     * @param {string} id market id
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} the limits object of a market structure
     */
    public async virtual Task<object> fetchTradingLimitsById(object id, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object request = new Dictionary<string, object>() {
            { "symbol", id },
        };
        object response = await this.spotPublicGetV1CommonExchange(this.extend(request, parameters));
        //
        //     { status:   "ok",
        //         "data": {                                  symbol: "aidocbtc",
        //                              "buy-limit-must-less-than":  1.1,
        //                          "sell-limit-must-greater-than":  0.9,
        //                         "limit-order-must-greater-than":  1,
        //                            "limit-order-must-less-than":  5000000,
        //                    "market-buy-order-must-greater-than":  0.0001,
        //                       "market-buy-order-must-less-than":  100,
        //                   "market-sell-order-must-greater-than":  1,
        //                      "market-sell-order-must-less-than":  500000,
        //                       "circuit-break-when-greater-than":  10000,
        //                          "circuit-break-when-less-than":  10,
        //                 "market-sell-order-rate-must-less-than":  0.1,
        //                  "market-buy-order-rate-must-less-than":  0.1        } }
        //
        return this.parseTradingLimits(this.safeValue(response, "data", new Dictionary<string, object>() {}));
    }

    public virtual object parseTradingLimits(object limits, object symbol = null, object parameters = null)
    {
        //
        //   {                                "symbol": "aidocbtc",
        //                  "buy-limit-must-less-than":  1.1,
        //              "sell-limit-must-greater-than":  0.9,
        //             "limit-order-must-greater-than":  1,
        //                "limit-order-must-less-than":  5000000,
        //        "market-buy-order-must-greater-than":  0.0001,
        //           "market-buy-order-must-less-than":  100,
        //       "market-sell-order-must-greater-than":  1,
        //          "market-sell-order-must-less-than":  500000,
        //           "circuit-break-when-greater-than":  10000,
        //              "circuit-break-when-less-than":  10,
        //     "market-sell-order-rate-must-less-than":  0.1,
        //      "market-buy-order-rate-must-less-than":  0.1        }
        //
        parameters ??= new Dictionary<string, object>();
        return new Dictionary<string, object>() {
            { "info", limits },
            { "limits", new Dictionary<string, object>() {
                { "amount", new Dictionary<string, object>() {
                    { "min", this.safeNumber(limits, "limit-order-must-greater-than") },
                    { "max", this.safeNumber(limits, "limit-order-must-less-than") },
                } },
            } },
        };
    }

    public override object costToPrecision(object symbol, object cost)
    {
        return this.decimalToPrecision(cost, TRUNCATE, getValue(getValue(getValue(this.markets, symbol), "precision"), "cost"), this.precisionMode);
    }

    /**
     * @method
     * @name htx#fetchMarkets
     * @description retrieves data on all markets for huobi
     * @see https://huobiapi.github.io/docs/spot/v1/en/#get-all-supported-trading-symbol-v1-deprecated
     * @see https://huobiapi.github.io/docs/dm/v1/en/#get-contract-info
     * @see https://huobiapi.github.io/docs/coin_margined_swap/v1/en/#query-swap-info
     * @see https://huobiapi.github.io/docs/usdt_swap/v1/en/#general-query-swap-info
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} an array of objects representing market data
     */
    public async override Task<object> fetchMarkets(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (isTrue(getValue(this.options, "adjustForTimeDifference")))
        {
            await this.loadTimeDifference();
        }
        object types = null;
        var typesparametersVariable = this.handleOptionAndParams(parameters, "fetchMarkets", "types", new Dictionary<string, object>() {});
        types = ((IList<object>)typesparametersVariable)[0];
        parameters = ((IList<object>)typesparametersVariable)[1];
        object allMarkets = new List<object>() {};
        object promises = new List<object>() {};
        object keys = new List<object>(((IDictionary<string,object>)types).Keys);
        for (object i = 0; isLessThan(i, getArrayLength(keys)); postFixIncrement(ref i))
        {
            object key = getValue(keys, i);
            if (isTrue(this.safeBool(types, key)))
            {
                if (isTrue(isEqual(key, "spot")))
                {
                    ((IList<object>)promises).Add(this.fetchMarketsByTypeAndSubType("spot", null, parameters));
                } else if (isTrue(isEqual(key, "linear")))
                {
                    ((IList<object>)promises).Add(this.fetchMarketsByTypeAndSubType(null, "linear", parameters));
                } else if (isTrue(isEqual(key, "inverse")))
                {
                    ((IList<object>)promises).Add(this.fetchMarketsByTypeAndSubType("swap", "inverse", parameters));
                    ((IList<object>)promises).Add(this.fetchMarketsByTypeAndSubType("future", "inverse", parameters));
                }
            }
        }
        promises = await promiseAll(promises);
        for (object i = 0; isLessThan(i, getArrayLength(promises)); postFixIncrement(ref i))
        {
            allMarkets = this.arrayConcat(allMarkets, getValue(promises, i));
        }
        return allMarkets;
    }

    /**
     * @ignore
     * @method
     * @name htx#fetchMarketsByTypeAndSubType
     * @description retrieves data on all markets of a certain type and/or subtype
     * @see https://huobiapi.github.io/docs/spot/v1/en/#get-all-supported-trading-symbol-v1-deprecated
     * @see https://huobiapi.github.io/docs/dm/v1/en/#get-contract-info
     * @see https://huobiapi.github.io/docs/coin_margined_swap/v1/en/#query-swap-info
     * @see https://huobiapi.github.io/docs/usdt_swap/v1/en/#general-query-swap-info
     * @param {string} [type] 'spot', 'swap' or 'future'
     * @param {string} [subType] 'linear' or 'inverse'
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} an array of objects representing market data
     */
    public async virtual Task<object> fetchMarketsByTypeAndSubType(object type, object subType, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object isSpot = (isEqual(type, "spot"));
        object request = new Dictionary<string, object>() {};
        object response = null;
        if (!isTrue(isSpot))
        {
            if (isTrue(isEqual(subType, "linear")))
            {
                ((IDictionary<string,object>)request)["business_type"] = "all"; // override default to fetch all linear markets
                response = await this.contractPublicGetLinearSwapApiV1SwapContractInfo(this.extend(request, parameters));
            } else if (isTrue(isEqual(subType, "inverse")))
            {
                if (isTrue(isEqual(type, "future")))
                {
                    response = await this.contractPublicGetApiV1ContractContractInfo(this.extend(request, parameters));
                } else if (isTrue(isEqual(type, "swap")))
                {
                    response = await this.contractPublicGetSwapApiV1SwapContractInfo(this.extend(request, parameters));
                }
            }
        } else
        {
            response = await this.spotPublicGetV1CommonSymbols(this.extend(request, parameters));
        }
        //
        // spot
        //
        //     {
        //         "status":"ok",
        //         "data":[
        //             {
        //                 "base-currency":"xrp3s",
        //                 "quote-currency":"usdt",
        //                 "price-precision":4,
        //                 "amount-precision":4,
        //                 "symbol-partition":"innovation",
        //                 "symbol":"xrp3susdt",
        //                 "state":"online",
        //                 "value-precision":8,
        //                 "min-order-amt":0.01,
        //                 "max-order-amt":1616.4353,
        //                 "min-order-value":5,
        //                 "limit-order-min-order-amt":0.01,
        //                 "limit-order-max-order-amt":1616.4353,
        //                 "limit-order-max-buy-amt":1616.4353,
        //                 "limit-order-max-sell-amt":1616.4353,
        //                 "sell-market-min-order-amt":0.01,
        //                 "sell-market-max-order-amt":1616.4353,
        //                 "buy-market-max-order-value":2500,
        //                 "max-order-value":2500,
        //                 "underlying":"xrpusdt",
        //                 "mgmt-fee-rate":0.035000000000000000,
        //                 "charge-time":"23:55:00",
        //                 "rebal-time":"00:00:00",
        //                 "rebal-threshold":-5,
        //                 "init-nav":10.000000000000000000,
        //                 "api-trading":"enabled",
        //                 "tags":"etp,nav,holdinglimit"
        //             },
        //         ]
        //     }
        //
        // inverse (swap & future)
        //
        //     {
        //         "status":"ok",
        //         "data":[
        //             {
        //                 "symbol":"BTC",
        //                 "contract_code":"BTC211126", /// BTC-USD in swap
        //                 "contract_type":"this_week", // only in future
        //                 "contract_size":100,
        //                 "price_tick":0.1,
        //                 "delivery_date":"20211126", // only in future
        //                 "delivery_time":"1637913600000", // empty in swap
        //                 "create_date":"20211112",
        //                 "contract_status":1,
        //                 "settlement_time":"1637481600000" // only in future
        //                 "settlement_date":"16xxxxxxxxxxx" // only in swap
        //             },
        //           ...
        //         ],
        //         "ts":1637474595140
        //     }
        //
        // linear (swap & future)
        //
        //     {
        //         "status":"ok",
        //         "data":[
        //             {
        //                 "symbol":"BTC",
        //                 "contract_code":"BTC-USDT-211231", // or "BTC-USDT" in swap
        //                 "contract_size":0.001,
        //                 "price_tick":0.1,
        //                 "delivery_date":"20211231", // empty in swap
        //                 "delivery_time":"1640937600000", // empty in swap
        //                 "create_date":"20211228",
        //                 "contract_status":1,
        //                 "settlement_date":"1640764800000",
        //                 "support_margin_mode":"cross", // "all" or "cross"
        //                 "business_type":"futures", // "swap" or "futures"
        //                 "pair":"BTC-USDT",
        //                 "contract_type":"this_week", // "swap", "this_week", "next_week", "quarter"
        //                 "trade_partition":"USDT",
        //             }
        //         ],
        //         "ts":1640736207263
        //     }
        //
        object markets = this.safeList(response, "data", new List<object>() {});
        object numMarkets = getArrayLength(markets);
        if (isTrue(isLessThan(numMarkets, 1)))
        {
            throw new OperationFailed ((string)add(add(this.id, " fetchMarkets() returned an empty response: "), this.json(response))) ;
        }
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(markets)); postFixIncrement(ref i))
        {
            object market = getValue(markets, i);
            object baseId = null;
            object quoteId = null;
            object settleId = null;
            object id = null;
            object lowercaseId = null;
            object contract = (inOp(market, "contract_code"));
            object spot = !isTrue(contract);
            object swap = false;
            object future = false;
            object linear = null;
            object inverse = null;
            // check if parsed market is contract
            if (isTrue(contract))
            {
                id = this.safeString(market, "contract_code");
                lowercaseId = ((string)id).ToLower();
                object delivery_date = this.safeString(market, "delivery_date");
                object business_type = this.safeString(market, "business_type");
                future = !isEqual(delivery_date, null);
                swap = !isTrue(future);
                linear = !isEqual(business_type, null);
                inverse = !isTrue(linear);
                if (isTrue(swap))
                {
                    type = "swap";
                    object parts = ((string)id).Split(new [] {((string)"-")}, StringSplitOptions.None).ToList<object>();
                    baseId = this.safeStringLower(market, "symbol");
                    quoteId = this.safeStringLower(parts, 1);
                    settleId = ((bool) isTrue(inverse)) ? baseId : quoteId;
                } else if (isTrue(future))
                {
                    type = "future";
                    baseId = this.safeStringLower(market, "symbol");
                    if (isTrue(inverse))
                    {
                        quoteId = "USD";
                        settleId = baseId;
                    } else
                    {
                        object pair = this.safeString(market, "pair");
                        object parts = ((string)pair).Split(new [] {((string)"-")}, StringSplitOptions.None).ToList<object>();
                        quoteId = this.safeStringLower(parts, 1);
                        settleId = quoteId;
                    }
                }
            } else
            {
                type = "spot";
                baseId = this.safeString(market, "base-currency");
                quoteId = this.safeString(market, "quote-currency");
                id = add(baseId, quoteId);
                lowercaseId = ((string)id).ToLower();
            }
            object bs = this.safeCurrencyCode(baseId);
            object quote = this.safeCurrencyCode(quoteId);
            object settle = this.safeCurrencyCode(settleId);
            object symbol = add(add(bs, "/"), quote);
            object expiry = null;
            if (isTrue(contract))
            {
                if (isTrue(inverse))
                {
                    symbol = add(symbol, add(":", bs));
                } else if (isTrue(linear))
                {
                    symbol = add(symbol, add(":", quote));
                }
                if (isTrue(future))
                {
                    expiry = this.safeInteger(market, "delivery_time");
                    symbol = add(symbol, add("-", this.yymmdd(expiry)));
                }
            }
            object contractSize = this.safeNumber(market, "contract_size");
            object minCost = this.safeNumber(market, "min-order-value");
            object maxAmount = this.safeNumber(market, "max-order-amt");
            object minAmount = this.safeNumber(market, "min-order-amt");
            if (isTrue(contract))
            {
                if (isTrue(linear))
                {
                    minAmount = contractSize;
                } else if (isTrue(inverse))
                {
                    minCost = contractSize;
                }
            }
            object pricePrecision = null;
            object amountPrecision = null;
            object costPrecision = null;
            object maker = null;
            object taker = null;
            object active = null;
            if (isTrue(spot))
            {
                pricePrecision = this.parseNumber(this.parsePrecision(this.safeString(market, "price-precision")));
                amountPrecision = this.parseNumber(this.parsePrecision(this.safeString(market, "amount-precision")));
                costPrecision = this.parseNumber(this.parsePrecision(this.safeString(market, "value-precision")));
                maker = this.parseNumber("0.002");
                taker = this.parseNumber("0.002");
                object state = this.safeString(market, "state");
                active = (isEqual(state, "online"));
            } else
            {
                pricePrecision = this.safeNumber(market, "price_tick");
                amountPrecision = this.parseNumber("1"); // other markets have step size of 1 contract
                maker = this.parseNumber("0.0002");
                taker = this.parseNumber("0.0005");
                object contractStatus = this.safeInteger(market, "contract_status");
                active = (isEqual(contractStatus, 1));
            }
            object leverageRatio = this.safeString(market, "leverage-ratio", "1");
            object superLeverageRatio = this.safeString(market, "super-margin-leverage-ratio", "1");
            object hasLeverage = isTrue(Precise.stringGt(leverageRatio, "1")) || isTrue(Precise.stringGt(superLeverageRatio, "1"));
            // 0 Delisting
            // 1 Listing
            // 2 Pending Listing
            // 3 Suspension
            // 4 Suspending of Listing
            // 5 In Settlement
            // 6 Delivering
            // 7 Settlement Completed
            // 8 Delivered
            // 9 Suspending of Trade
            object created = null;
            object createdDate = this.safeString(market, "create_date"); // i.e 20230101
            if (isTrue(!isEqual(createdDate, null)))
            {
                object createdArray = this.stringToCharsArray(createdDate);
                createdDate = add(add(add(add(add(add(add(add(add(add(getValue(createdArray, 0), getValue(createdArray, 1)), getValue(createdArray, 2)), getValue(createdArray, 3)), "-"), getValue(createdArray, 4)), getValue(createdArray, 5)), "-"), getValue(createdArray, 6)), getValue(createdArray, 7)), " 00:00:00");
                created = this.parse8601(createdDate);
            }
            ((IList<object>)result).Add(new Dictionary<string, object>() {
                { "id", id },
                { "lowercaseId", lowercaseId },
                { "symbol", symbol },
                { "base", bs },
                { "quote", quote },
                { "settle", settle },
                { "baseId", baseId },
                { "quoteId", quoteId },
                { "settleId", settleId },
                { "type", type },
                { "spot", spot },
                { "margin", (isTrue(spot) && isTrue(hasLeverage)) },
                { "swap", swap },
                { "future", future },
                { "option", false },
                { "active", active },
                { "contract", contract },
                { "linear", linear },
                { "inverse", inverse },
                { "taker", taker },
                { "maker", maker },
                { "contractSize", contractSize },
                { "expiry", expiry },
                { "expiryDatetime", this.iso8601(expiry) },
                { "strike", null },
                { "optionType", null },
                { "precision", new Dictionary<string, object>() {
                    { "amount", amountPrecision },
                    { "price", pricePrecision },
                    { "cost", costPrecision },
                } },
                { "limits", new Dictionary<string, object>() {
                    { "leverage", new Dictionary<string, object>() {
                        { "min", this.parseNumber("1") },
                        { "max", this.parseNumber(leverageRatio) },
                        { "superMax", this.parseNumber(superLeverageRatio) },
                    } },
                    { "amount", new Dictionary<string, object>() {
                        { "min", minAmount },
                        { "max", maxAmount },
                    } },
                    { "price", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                    { "cost", new Dictionary<string, object>() {
                        { "min", minCost },
                        { "max", null },
                    } },
                } },
                { "created", created },
                { "info", market },
            });
        }
        return result;
    }

    public virtual object tryGetSymbolFromFutureMarkets(object symbolOrMarketId)
    {
        if (isTrue(inOp(this.markets, symbolOrMarketId)))
        {
            return symbolOrMarketId;
        }
        // only on "future" market type (inverse & linear), market-id differs between "fetchMarkets" and "fetchTicker"
        // so we have to create a mapping
        // - market-id from fetchMarkts:    `BTC-USDT-240419` (linear future) or `BTC240412` (inverse future)
        // - market-id from fetchTciker[s]: `BTC-USDT-CW`     (linear future) or `BTC_CW`    (inverse future)
        if (!isTrue((inOp(this.options, "futureMarketIdsForSymbols"))))
        {
            ((IDictionary<string,object>)this.options)["futureMarketIdsForSymbols"] = new Dictionary<string, object>() {};
        }
        object futureMarketIdsForSymbols = this.safeDict(this.options, "futureMarketIdsForSymbols", new Dictionary<string, object>() {});
        if (isTrue(inOp(futureMarketIdsForSymbols, symbolOrMarketId)))
        {
            return getValue(futureMarketIdsForSymbols, symbolOrMarketId);
        }
        object futureMarkets = this.filterBy(this.markets, "future", true);
        object futuresCharsMaps = new Dictionary<string, object>() {
            { "this_week", "CW" },
            { "next_week", "NW" },
            { "quarter", "CQ" },
            { "next_quarter", "NQ" },
        };
        for (object i = 0; isLessThan(i, getArrayLength(futureMarkets)); postFixIncrement(ref i))
        {
            object market = getValue(futureMarkets, i);
            object info = this.safeValue(market, "info", new Dictionary<string, object>() {});
            object contractType = this.safeString(info, "contract_type");
            object contractSuffix = getValue(futuresCharsMaps, contractType);
            // see comment on formats a bit above
            object constructedId = ((bool) isTrue(getValue(market, "linear"))) ? add(add(add(add(getValue(market, "base"), "-"), getValue(market, "quote")), "-"), contractSuffix) : add(add(getValue(market, "base"), "_"), contractSuffix);
            if (isTrue(isEqual(constructedId, symbolOrMarketId)))
            {
                object symbol = getValue(market, "symbol");
                ((IDictionary<string,object>)getValue(this.options, "futureMarketIdsForSymbols"))[(string)symbolOrMarketId] = symbol;
                return symbol;
            }
        }
        // if not found, just save it to avoid unnecessary future iterations
        ((IDictionary<string,object>)getValue(this.options, "futureMarketIdsForSymbols"))[(string)symbolOrMarketId] = symbolOrMarketId;
        return symbolOrMarketId;
    }

    public override object parseTicker(object ticker, object market = null)
    {
        //
        // fetchTicker
        //
        //     {
        //         "amount": 26228.672978342216,
        //         "open": 9078.95,
        //         "close": 9146.86,
        //         "high": 9155.41,
        //         "id": 209988544334,
        //         "count": 265846,
        //         "low": 8988.0,
        //         "version": 209988544334,
        //         "ask": [ 9146.87, 0.156134 ],
        //         "vol": 2.3822168242201668E8,
        //         "bid": [ 9146.86, 0.080758 ],
        //     }
        //
        // fetchTickers
        //
        //     {
        //         "symbol": "bhdht",
        //         "open":  2.3938,
        //         "high":  2.4151,
        //         "low":  2.3323,
        //         "close":  2.3909,
        //         "amount":  628.992,
        //         "vol":  1493.71841095,
        //         "count":  2088,
        //         "bid":  2.3643,
        //         "bidSize":  0.7136,
        //         "ask":  2.4061,
        //         "askSize":  0.4156
        //     }
        //
        // watchTikcer - bbo
        //     {
        //         "seqId": 161499562790,
        //         "ask": 16829.51,
        //         "askSize": 0.707776,
        //         "bid": 16829.5,
        //         "bidSize": 1.685945,
        //         "quoteTime": 1671941599612,
        //         "symbol": "btcusdt"
        //     }
        //
        object marketId = this.safeString2(ticker, "symbol", "contract_code");
        object symbol = this.safeSymbol(marketId, market);
        symbol = this.tryGetSymbolFromFutureMarkets(symbol);
        object timestamp = this.safeInteger2(ticker, "ts", "quoteTime");
        object bid = null;
        object bidVolume = null;
        object ask = null;
        object askVolume = null;
        if (isTrue(inOp(ticker, "bid")))
        {
            if (isTrue(isTrue(!isEqual(getValue(ticker, "bid"), null)) && isTrue(((getValue(ticker, "bid") is IList<object>) || (getValue(ticker, "bid").GetType().IsGenericType && getValue(ticker, "bid").GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>)))))))
            {
                bid = this.safeString(getValue(ticker, "bid"), 0);
                bidVolume = this.safeString(getValue(ticker, "bid"), 1);
            } else
            {
                bid = this.safeString(ticker, "bid");
                bidVolume = this.safeString(ticker, "bidSize");
            }
        }
        if (isTrue(inOp(ticker, "ask")))
        {
            if (isTrue(isTrue(!isEqual(getValue(ticker, "ask"), null)) && isTrue(((getValue(ticker, "ask") is IList<object>) || (getValue(ticker, "ask").GetType().IsGenericType && getValue(ticker, "ask").GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>)))))))
            {
                ask = this.safeString(getValue(ticker, "ask"), 0);
                askVolume = this.safeString(getValue(ticker, "ask"), 1);
            } else
            {
                ask = this.safeString(ticker, "ask");
                askVolume = this.safeString(ticker, "askSize");
            }
        }
        object open = this.safeString(ticker, "open");
        object close = this.safeString(ticker, "close");
        object baseVolume = this.safeString(ticker, "amount");
        object quoteVolume = this.safeString(ticker, "vol");
        return this.safeTicker(new Dictionary<string, object>() {
            { "symbol", symbol },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "high", this.safeString(ticker, "high") },
            { "low", this.safeString(ticker, "low") },
            { "bid", bid },
            { "bidVolume", bidVolume },
            { "ask", ask },
            { "askVolume", askVolume },
            { "vwap", null },
            { "open", open },
            { "close", close },
            { "last", close },
            { "previousClose", null },
            { "change", null },
            { "percentage", null },
            { "average", null },
            { "baseVolume", baseVolume },
            { "quoteVolume", quoteVolume },
            { "info", ticker },
        }, market);
    }

    /**
     * @method
     * @name htx#fetchTicker
     * @description fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
     * @see https://huobiapi.github.io/docs/spot/v1/en/#get-latest-aggregated-ticker
     * @see https://huobiapi.github.io/docs/dm/v1/en/#get-market-data-overview
     * @see https://huobiapi.github.io/docs/coin_margined_swap/v1/en/#get-market-data-overview
     * @see https://huobiapi.github.io/docs/usdt_swap/v1/en/#general-get-market-data-overview
     * @param {string} symbol unified symbol of the market to fetch the ticker for
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/?id=ticker-structure}
     */
    public async override Task<object> fetchTicker(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {};
        object response = null;
        if (isTrue(getValue(market, "linear")))
        {
            ((IDictionary<string,object>)request)["contract_code"] = getValue(market, "id");
            response = await this.contractPublicGetLinearSwapExMarketDetailMerged(this.extend(request, parameters));
        } else if (isTrue(getValue(market, "inverse")))
        {
            if (isTrue(getValue(market, "future")))
            {
                ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
                response = await this.contractPublicGetMarketDetailMerged(this.extend(request, parameters));
            } else if (isTrue(getValue(market, "swap")))
            {
                ((IDictionary<string,object>)request)["contract_code"] = getValue(market, "id");
                response = await this.contractPublicGetSwapExMarketDetailMerged(this.extend(request, parameters));
            }
        } else
        {
            ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
            response = await this.spotPublicGetMarketDetailMerged(this.extend(request, parameters));
        }
        //
        // spot
        //
        //     {
        //         "status": "ok",
        //         "ch": "market.btcusdt.detail.merged",
        //         "ts": 1583494336669,
        //         "tick": {
        //             "amount": 26228.672978342216,
        //             "open": 9078.95,
        //             "close": 9146.86,
        //             "high": 9155.41,
        //             "id": 209988544334,
        //             "count": 265846,
        //             "low": 8988.0,
        //             "version": 209988544334,
        //             "ask": [ 9146.87, 0.156134 ],
        //             "vol": 2.3822168242201668E8,
        //             "bid": [ 9146.86, 0.080758 ],
        //         }
        //     }
        //
        // future, swap
        //
        //     {
        //         "ch":"market.BTC211126.detail.merged",
        //         "status":"ok",
        //         "tick":{
        //             "amount":"669.3385682049668320322569544150680718474",
        //             "ask":[59117.44,48],
        //             "bid":[59082,48],
        //             "close":"59087.97",
        //             "count":5947,
        //             "high":"59892.62",
        //             "id":1637502670,
        //             "low":"57402.87",
        //             "open":"57638",
        //             "ts":1637502670059,
        //             "vol":"394598"
        //         },
        //         "ts":1637502670059
        //     }
        //
        object tick = this.safeValue(response, "tick", new Dictionary<string, object>() {});
        object ticker = this.parseTicker(tick, market);
        object timestamp = this.safeInteger(response, "ts");
        ((IDictionary<string,object>)ticker)["timestamp"] = timestamp;
        ((IDictionary<string,object>)ticker)["datetime"] = this.iso8601(timestamp);
        return ticker;
    }

    /**
     * @method
     * @name htx#fetchTickers
     * @description fetches price tickers for multiple markets, statistical information calculated over the past 24 hours for each market
     * @see https://huobiapi.github.io/docs/spot/v1/en/#get-latest-tickers-for-all-pairs
     * @see https://huobiapi.github.io/docs/usdt_swap/v1/en/#general-get-a-batch-of-market-data-overview
     * @see https://huobiapi.github.io/docs/dm/v1/en/#get-a-batch-of-market-data-overview
     * @see https://huobiapi.github.io/docs/coin_margined_swap/v1/en/#get-a-batch-of-market-data-overview-v2
     * @param {string[]} [symbols] unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/?id=ticker-structure}
     */
    public async override Task<object> fetchTickers(object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        symbols = this.marketSymbols(symbols);
        object first = this.safeString(symbols, 0);
        object market = null;
        if (isTrue(!isEqual(first, null)))
        {
            market = this.market(first);
        }
        object isSubTypeRequested = isTrue((inOp(parameters, "subType"))) || isTrue((inOp(parameters, "business_type")));
        object type = null;
        object subType = null;
        var typeparametersVariable = this.handleMarketTypeAndParams("fetchTickers", market, parameters);
        type = ((IList<object>)typeparametersVariable)[0];
        parameters = ((IList<object>)typeparametersVariable)[1];
        var subTypeparametersVariable = this.handleSubTypeAndParams("fetchTickers", market, parameters);
        subType = ((IList<object>)subTypeparametersVariable)[0];
        parameters = ((IList<object>)subTypeparametersVariable)[1];
        object request = new Dictionary<string, object>() {};
        object isSpot = (isEqual(type, "spot"));
        object future = (isEqual(type, "future"));
        object swap = (isEqual(type, "swap"));
        object linear = (isEqual(subType, "linear"));
        object inverse = (isEqual(subType, "inverse"));
        object response = null;
        if (isTrue(!isTrue(isSpot) || isTrue(isSubTypeRequested)))
        {
            if (isTrue(linear))
            {
                // independently of type, supports calling all linear symbols i.e. fetchTickers(undefined, {subType:'linear'})
                if (isTrue(future))
                {
                    ((IDictionary<string,object>)request)["business_type"] = "futures";
                } else if (isTrue(swap))
                {
                    ((IDictionary<string,object>)request)["business_type"] = "swap";
                } else
                {
                    ((IDictionary<string,object>)request)["business_type"] = "all";
                }
                response = await this.contractPublicGetLinearSwapExMarketDetailBatchMerged(this.extend(request, parameters));
            } else if (isTrue(inverse))
            {
                if (isTrue(future))
                {
                    response = await this.contractPublicGetMarketDetailBatchMerged(this.extend(request, parameters));
                } else if (isTrue(swap))
                {
                    response = await this.contractPublicGetSwapExMarketDetailBatchMerged(this.extend(request, parameters));
                } else
                {
                    throw new NotSupported ((string)add(this.id, " fetchTickers() you have to set params[\"type\"] to either \"swap\" or \"future\" for inverse contracts")) ;
                }
            } else
            {
                throw new NotSupported ((string)add(this.id, " fetchTickers() you have to set params[\"subType\"] to either \"linear\" or \"inverse\" for contracts")) ;
            }
        } else
        {
            response = await this.spotPublicGetMarketTickers(this.extend(request, parameters));
        }
        //
        // spot
        //
        //     {
        //         "data":[
        //             {
        //                 "symbol":"hbcbtc",
        //                 "open":5.313E-5,
        //                 "high":5.34E-5,
        //                 "low":5.112E-5,
        //                 "close":5.175E-5,
        //                 "amount":1183.87,
        //                 "vol":0.0618599229,
        //                 "count":205,
        //                 "bid":5.126E-5,
        //                 "bidSize":5.25,
        //                 "ask":5.214E-5,
        //                 "askSize":150.0
        //             },
        //         ],
        //         "status":"ok",
        //         "ts":1639547261293
        //     }
        //
        // linear swap, linear future, inverse swap, inverse future
        //
        //     {
        //         "status":"ok",
        //         "ticks":[
        //             {
        //                 "id":1637504679,
        //                 "ts":1637504679372,
        //                 "ask":[0.10644,100],
        //                 "bid":[0.10624,26],
        //                 "symbol":"TRX_CW",
        //                 "open":"0.10233",
        //                 "close":"0.10644",
        //                 "low":"0.1017",
        //                 "high":"0.10725",
        //                 "amount":"2340267.415144052378486261756692535687481566",
        //                 "count":882,
        //                 "vol":"24706",
        //                 "trade_turnover":"840726.5048", // only in linear futures
        //                 "business_type":"futures", // only in linear futures
        //                 "contract_code":"BTC-USDT-CW", // only in linear futures, instead of 'symbol'
        //             }
        //         ],
        //         "ts":1637504679376
        //     }
        //
        object rawTickers = this.safeList2(response, "data", "ticks", new List<object>() {});
        object tickers = this.parseTickers(rawTickers, symbols, parameters);
        return this.filterByArrayTickers(tickers, "symbol", symbols);
    }

    /**
     * @method
     * @name htx#fetchLastPrices
     * @description fetches the last price for multiple markets
     * @see https://www.htx.com/en-us/opend/newApiPages/?id=8cb81024-77b5-11ed-9966-0242ac110003 linear swap & linear future
     * @see https://www.htx.com/en-us/opend/newApiPages/?id=28c2e8fc-77ae-11ed-9966-0242ac110003 inverse future
     * @see https://www.htx.com/en-us/opend/newApiPages/?id=5d517ef5-77b6-11ed-9966-0242ac110003 inverse swap
     * @param {string[]} [symbols] unified symbols of the markets to fetch the last prices
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a dictionary of lastprices structures
     */
    public async override Task<object> fetchLastPrices(object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        symbols = this.marketSymbols(symbols);
        object market = this.getMarketFromSymbols(symbols);
        object type = null;
        object subType = null;
        var subTypeparametersVariable = this.handleSubTypeAndParams("fetchLastPrices", market, parameters);
        subType = ((IList<object>)subTypeparametersVariable)[0];
        parameters = ((IList<object>)subTypeparametersVariable)[1];
        var typeparametersVariable = this.handleMarketTypeAndParams("fetchLastPrices", market, parameters);
        type = ((IList<object>)typeparametersVariable)[0];
        parameters = ((IList<object>)typeparametersVariable)[1];
        object response = null;
        if (isTrue(isTrue((isTrue((isEqual(type, "swap"))) || isTrue((isEqual(type, "future"))))) && isTrue((isEqual(subType, "linear")))))
        {
            response = await this.contractPublicGetLinearSwapExMarketTrade(parameters);
        } else if (isTrue(isTrue((isEqual(type, "swap"))) && isTrue((isEqual(subType, "inverse")))))
        {
            response = await this.contractPublicGetSwapExMarketTrade(parameters);
        } else if (isTrue(isTrue((isEqual(type, "future"))) && isTrue((isEqual(subType, "inverse")))))
        {
            response = await this.contractPublicGetMarketTrade(parameters);
        } else
        {
            throw new NotSupported ((string)add(add(add(this.id, " fetchLastPrices() does not support "), type), " markets yet")) ;
        }
        object tick = this.safeValue(response, "tick", new Dictionary<string, object>() {});
        object data = this.safeList(tick, "data", new List<object>() {});
        return this.parseLastPrices(data, symbols);
    }

    public override object parseLastPrice(object entry, object market = null)
    {
        // example responses are documented in fetchLastPrices
        object marketId = this.safeString2(entry, "symbol", "contract_code");
        market = this.safeMarket(marketId, market);
        object price = this.safeNumber(entry, "price");
        object direction = this.safeString(entry, "direction"); // "buy" or "sell"
        // group timestamp should not be assigned to the individual trades' times
        return new Dictionary<string, object>() {
            { "symbol", getValue(market, "symbol") },
            { "timestamp", null },
            { "datetime", null },
            { "price", price },
            { "side", direction },
            { "info", entry },
        };
    }

    /**
     * @method
     * @name htx#fetchOrderBook
     * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
     * @see https://huobiapi.github.io/docs/spot/v1/en/#get-market-depth
     * @see https://huobiapi.github.io/docs/dm/v1/en/#get-market-depth
     * @see https://huobiapi.github.io/docs/coin_margined_swap/v1/en/#get-market-depth
     * @see https://huobiapi.github.io/docs/usdt_swap/v1/en/#general-get-market-depth
     * @param {string} symbol unified symbol of the market to fetch the order book for
     * @param {int} [limit] the maximum amount of order book entries to return
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/?id=order-book-structure} indexed by market symbols
     */
    public async override Task<object> fetchOrderBook(object symbol, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "type", "step0" },
        };
        object response = null;
        if (isTrue(getValue(market, "linear")))
        {
            ((IDictionary<string,object>)request)["contract_code"] = getValue(market, "id");
            response = await this.contractPublicGetLinearSwapExMarketDepth(this.extend(request, parameters));
        } else if (isTrue(getValue(market, "inverse")))
        {
            if (isTrue(getValue(market, "future")))
            {
                ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
                response = await this.contractPublicGetMarketDepth(this.extend(request, parameters));
            } else if (isTrue(getValue(market, "swap")))
            {
                ((IDictionary<string,object>)request)["contract_code"] = getValue(market, "id");
                response = await this.contractPublicGetSwapExMarketDepth(this.extend(request, parameters));
            }
        } else
        {
            if (isTrue(!isEqual(limit, null)))
            {
                // Valid depths are 5, 10, 20 or empty https://huobiapi.github.io/docs/spot/v1/en/#get-market-depth
                if (isTrue(isTrue(isTrue(isTrue((!isEqual(limit, 5))) && isTrue((!isEqual(limit, 10)))) && isTrue((!isEqual(limit, 20)))) && isTrue((!isEqual(limit, 150)))))
                {
                    throw new BadRequest ((string)add(this.id, " fetchOrderBook() limit argument must be undefined, 5, 10, 20, or 150, default is 150")) ;
                }
                // only set the depth if it is not 150
                // 150 is the implicit default on the exchange side for step0 and no orderbook aggregation
                // it is not accepted by the exchange if you set it explicitly
                if (isTrue(!isEqual(limit, 150)))
                {
                    ((IDictionary<string,object>)request)["depth"] = limit;
                }
            }
            ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
            response = await this.spotPublicGetMarketDepth(this.extend(request, parameters));
        }
        //
        // spot, future, swap
        //
        //     {
        //         "status": "ok",
        //         "ch": "market.btcusdt.depth.step0",
        //         "ts": 1583474832790,
        //         "tick": {
        //             "bids": [
        //                 [ 9100.290000000000000000, 0.200000000000000000 ],
        //                 [ 9099.820000000000000000, 0.200000000000000000 ],
        //                 [ 9099.610000000000000000, 0.205000000000000000 ],
        //             ],
        //             "asks": [
        //                 [ 9100.640000000000000000, 0.005904000000000000 ],
        //                 [ 9101.010000000000000000, 0.287311000000000000 ],
        //                 [ 9101.030000000000000000, 0.012121000000000000 ],
        //             ],
        //             "ch":"market.BTC-USD.depth.step0",
        //             "ts":1583474832008,
        //             "id":1637554816,
        //             "mrid":121654491624,
        //             "version":104999698781
        //         }
        //     }
        //
        if (isTrue(inOp(response, "tick")))
        {
            if (!isTrue(getValue(response, "tick")))
            {
                throw new BadSymbol ((string)add(add(this.id, " fetchOrderBook() returned empty response: "), this.json(response))) ;
            }
            object tick = this.safeValue(response, "tick");
            object timestamp = this.safeInteger(tick, "ts", this.safeInteger(response, "ts"));
            object result = this.parseOrderBook(tick, symbol, timestamp);
            ((IDictionary<string,object>)result)["nonce"] = this.safeInteger(tick, "version");
            return result;
        }
        throw new ExchangeError ((string)add(add(this.id, " fetchOrderBook() returned unrecognized response: "), this.json(response))) ;
    }

    public override object parseTrade(object trade, object market = null)
    {
        //
        // spot fetchTrades (public)
        //
        //     {
        //         "amount": 0.010411000000000000,
        //         "trade-id": 102090736910,
        //         "ts": 1583497692182,
        //         "id": 10500517034273194594947,
        //         "price": 9096.050000000000000000,
        //         "direction": "sell"
        //     }
        //
        // spot fetchMyTrades (private)
        //
        //     {
        //          "symbol": "swftcbtc",
        //          "fee-currency": "swftc",
        //          "filled-fees": "0",
        //          "source": "spot-api",
        //          "id": 83789509854000,
        //          "type": "buy-limit",
        //          "order-id": 83711103204909,
        //          'filled-points': "0.005826843283532154",
        //          "fee-deduct-currency": "ht",
        //          'filled-amount': "45941.53",
        //          "price": "0.0000001401",
        //          "created-at": 1597933260729,
        //          "match-id": 100087455560,
        //          "role": "maker",
        //          "trade-id": 100050305348
        //     }
        //
        // linear swap isolated margin fetchOrder details
        //
        //     {
        //         "trade_id": 131560927,
        //         "trade_price": 13059.800000000000000000,
        //         "trade_volume": 1.000000000000000000,
        //         "trade_turnover": 13.059800000000000000,
        //         "trade_fee": -0.005223920000000000,
        //         "created_at": 1603703614715,
        //         "role": "taker",
        //         "fee_asset": "USDT",
        //         "profit": 0,
        //         "real_profit": 0,
        //         "id": "131560927-770334322963152896-1"
        //     }
        //
        // inverse swap cross margin fetchMyTrades
        //
        //     {
        //         "contract_type":"swap",
        //         "pair":"O3-USDT",
        //         "business_type":"swap",
        //         "query_id":652123190,
        //         "match_id":28306009409,
        //         "order_id":941137865226903553,
        //         "symbol":"O3",
        //         "contract_code":"O3-USDT",
        //         "direction":"sell",
        //         "offset":"open",
        //         "trade_volume":100.000000000000000000,
        //         "trade_price":0.398500000000000000,
        //         "trade_turnover":39.850000000000000000,
        //         "trade_fee":-0.007970000000000000,
        //         "offset_profitloss":0E-18,
        //         "create_date":1644426352999,
        //         "role":"Maker",
        //         "order_source":"api",
        //         "order_id_str":"941137865226903553",
        //         "id":"28306009409-941137865226903553-1",
        //         "fee_asset":"USDT",
        //         "margin_mode":"cross",
        //         "margin_account":"USDT",
        //         "real_profit":0E-18,
        //         "trade_partition":"USDT"
        //     }
        //
        object marketId = this.safeString2(trade, "contract_code", "symbol");
        market = this.safeMarket(marketId, market);
        object symbol = getValue(market, "symbol");
        object timestamp = this.safeInteger2(trade, "ts", "created-at");
        timestamp = this.safeInteger2(trade, "created_at", "create_date", timestamp);
        object order = this.safeString2(trade, "order-id", "order_id");
        object side = this.safeString(trade, "direction");
        object type = this.safeString(trade, "type");
        if (isTrue(!isEqual(type, null)))
        {
            object typeParts = ((string)type).Split(new [] {((string)"-")}, StringSplitOptions.None).ToList<object>();
            side = getValue(typeParts, 0);
            type = getValue(typeParts, 1);
        }
        object takerOrMaker = this.safeStringLower(trade, "role");
        object priceString = this.safeString2(trade, "price", "trade_price");
        object amountString = this.safeString2(trade, "filled-amount", "amount");
        amountString = this.safeString(trade, "trade_volume", amountString);
        object costString = this.safeString(trade, "trade_turnover");
        object fee = null;
        object feeCost = this.safeString(trade, "filled-fees");
        if (isTrue(isEqual(feeCost, null)))
        {
            feeCost = Precise.stringNeg(this.safeString(trade, "trade_fee"));
        }
        object feeCurrencyId = this.safeString2(trade, "fee-currency", "fee_asset");
        object feeCurrency = this.safeCurrencyCode(feeCurrencyId);
        object filledPoints = this.safeString(trade, "filled-points");
        if (isTrue(!isEqual(filledPoints, null)))
        {
            if (isTrue(isTrue((isEqual(feeCost, null))) || isTrue(Precise.stringEquals(feeCost, "0"))))
            {
                object feeDeductCurrency = this.safeString(trade, "fee-deduct-currency");
                if (isTrue(!isEqual(feeDeductCurrency, null)))
                {
                    feeCost = filledPoints;
                    feeCurrency = this.safeCurrencyCode(feeDeductCurrency);
                }
            }
        }
        if (isTrue(!isEqual(feeCost, null)))
        {
            fee = new Dictionary<string, object>() {
                { "cost", feeCost },
                { "currency", feeCurrency },
            };
        }
        // htx's multi-market trade-id is a bit complex to parse accordingly.
        // - for `id` which contains hyphen, it would be the unique id, eg. xxxxxx-1, xxxxxx-2 (this happens mostly for contract markets)
        // - otherwise the least priority is given to the `id` key
        object id = null;
        object safeId = this.safeString(trade, "id");
        if (isTrue(isTrue(!isEqual(safeId, null)) && isTrue(isGreaterThanOrEqual(getIndexOf(safeId, "-"), 0))))
        {
            id = safeId;
        } else
        {
            id = this.safeStringN(trade, new List<object>() {"trade_id", "trade-id", "id"});
        }
        return this.safeTrade(new Dictionary<string, object>() {
            { "id", id },
            { "info", trade },
            { "order", order },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "symbol", symbol },
            { "type", type },
            { "side", side },
            { "takerOrMaker", takerOrMaker },
            { "price", priceString },
            { "amount", amountString },
            { "cost", costString },
            { "fee", fee },
        }, market);
    }

    /**
     * @method
     * @name htx#fetchOrderTrades
     * @description fetch all the trades made from a single order
     * @see https://huobiapi.github.io/docs/spot/v1/en/#get-the-match-result-of-an-order
     * @param {string} id order id
     * @param {string} symbol unified market symbol
     * @param {int} [since] the earliest time in ms to fetch trades for
     * @param {int} [limit] the maximum number of trades to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/?id=trade-structure}
     */
    public async override Task<object> fetchOrderTrades(object id, object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
        }
        object marketType = null;
        var marketTypeparametersVariable = this.handleMarketTypeAndParams("fetchOrderTrades", market, parameters);
        marketType = ((IList<object>)marketTypeparametersVariable)[0];
        parameters = ((IList<object>)marketTypeparametersVariable)[1];
        if (isTrue(!isEqual(marketType, "spot")))
        {
            throw new NotSupported ((string)add(this.id, " fetchOrderTrades() is only supported for spot markets")) ;
        }
        return await this.fetchSpotOrderTrades(id, symbol, since, limit, parameters);
    }

    /**
     * @ignore
     * @method
     * @name htx#fetchOrderTrades
     * @description fetch all the trades made from a single order
     * @see https://huobiapi.github.io/docs/spot/v1/en/#get-the-match-result-of-an-order
     * @param {string} id order id
     * @param {string} symbol unified market symbol
     * @param {int} [since] the earliest time in ms to fetch trades for
     * @param {int} [limit] the maximum number of trades to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/?id=trade-structure}
     */
    public async virtual Task<object> fetchSpotOrderTrades(object id, object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {
            { "order-id", id },
        };
        object response = await this.spotPrivateGetV1OrderOrdersOrderIdMatchresults(this.extend(request, parameters));
        return this.parseTrades(getValue(response, "data"), null, since, limit);
    }

    /**
     * @method
     * @name htx#fetchMyTrades
     * @see https://huobiapi.github.io/docs/usdt_swap/v1/en/#isolated-get-history-match-results-via-multiple-fields-new
     * @see https://huobiapi.github.io/docs/usdt_swap/v1/en/#cross-get-history-match-results-via-multiple-fields-new
     * @see https://huobiapi.github.io/docs/spot/v1/en/#search-match-results
     * @description fetch all trades made by the user
     * @param {string} symbol unified market symbol
     * @param {int} [since] the earliest time in ms to fetch trades for
     * @param {int} [limit] the maximum number of trades structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {int} [params.until] the latest time in ms to fetch trades for
     * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [availble parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
     * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/?id=trade-structure}
     */
    public async override Task<object> fetchMyTrades(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object paginate = false;
        var paginateparametersVariable = this.handleOptionAndParams(parameters, "fetchMyTrades", "paginate");
        paginate = ((IList<object>)paginateparametersVariable)[0];
        parameters = ((IList<object>)paginateparametersVariable)[1];
        if (isTrue(paginate))
        {
            return await this.fetchPaginatedCallDynamic("fetchMyTrades", symbol, since, limit, parameters);
        }
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
        }
        object marketType = null;
        var marketTypeparametersVariable = this.handleMarketTypeAndParams("fetchMyTrades", market, parameters);
        marketType = ((IList<object>)marketTypeparametersVariable)[0];
        parameters = ((IList<object>)marketTypeparametersVariable)[1];
        object request = new Dictionary<string, object>() {};
        object response = null;
        if (isTrue(isEqual(marketType, "spot")))
        {
            if (isTrue(!isEqual(symbol, null)))
            {
                market = this.market(symbol);
                ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
            }
            if (isTrue(!isEqual(limit, null)))
            {
                ((IDictionary<string,object>)request)["size"] = limit; // default 100, max 500
            }
            if (isTrue(!isEqual(since, null)))
            {
                ((IDictionary<string,object>)request)["start-time"] = since; // a date within 120 days from today
            }
            var requestparametersVariable = this.handleUntilOption("end-time", request, parameters);
            request = ((IList<object>)requestparametersVariable)[0];
            parameters = ((IList<object>)requestparametersVariable)[1];
            response = await this.spotPrivateGetV1OrderMatchresults(this.extend(request, parameters));
        } else
        {
            if (isTrue(isEqual(symbol, null)))
            {
                throw new ArgumentsRequired ((string)add(this.id, " fetchMyTrades() requires a symbol argument")) ;
            }
            ((IDictionary<string,object>)request)["contract"] = getValue(market, "id");
            ((IDictionary<string,object>)request)["trade_type"] = 0; // 0 all, 1 open long, 2 open short, 3 close short, 4 close long, 5 liquidate long positions, 6 liquidate short positions
            if (isTrue(!isEqual(since, null)))
            {
                ((IDictionary<string,object>)request)["start_time"] = since; // a date within 120 days from today
            }
            var requestparametersVariable = this.handleUntilOption("end_time", request, parameters);
            request = ((IList<object>)requestparametersVariable)[0];
            parameters = ((IList<object>)requestparametersVariable)[1];
            if (isTrue(!isEqual(limit, null)))
            {
                ((IDictionary<string,object>)request)["page_size"] = limit; // default 100, max 500
            }
            if (isTrue(getValue(market, "linear")))
            {
                object marginMode = null;
                var marginModeparametersVariable = this.handleMarginModeAndParams("fetchMyTrades", parameters);
                marginMode = ((IList<object>)marginModeparametersVariable)[0];
                parameters = ((IList<object>)marginModeparametersVariable)[1];
                marginMode = ((bool) isTrue((isEqual(marginMode, null)))) ? "cross" : marginMode;
                if (isTrue(isEqual(marginMode, "isolated")))
                {
                    response = await this.contractPrivatePostLinearSwapApiV3SwapMatchresultsExact(this.extend(request, parameters));
                } else if (isTrue(isEqual(marginMode, "cross")))
                {
                    response = await this.contractPrivatePostLinearSwapApiV3SwapCrossMatchresultsExact(this.extend(request, parameters));
                }
            } else if (isTrue(getValue(market, "inverse")))
            {
                if (isTrue(isEqual(marketType, "future")))
                {
                    ((IDictionary<string,object>)request)["symbol"] = getValue(market, "settleId");
                    response = await this.contractPrivatePostApiV3ContractMatchresultsExact(this.extend(request, parameters));
                } else if (isTrue(isEqual(marketType, "swap")))
                {
                    response = await this.contractPrivatePostSwapApiV3SwapMatchresultsExact(this.extend(request, parameters));
                } else
                {
                    throw new NotSupported ((string)add(add(add(this.id, " fetchMyTrades() does not support "), marketType), " markets")) ;
                }
            }
        }
        //
        // spot
        //
        //     {
        //         "status": "ok",
        //         "data": [
        //             {
        //                 "symbol": "polyusdt",
        //                 "fee-currency": "poly",
        //                 "source": "spot-web",
        //                 "price": "0.338",
        //                 "created-at": 1629443051839,
        //                 "role": "taker",
        //                 "order-id": 345487249132375,
        //                 "match-id": 5014,
        //                 "trade-id": 1085,
        //                 "filled-amount": "147.928994082840236",
        //                 "filled-fees": "0",
        //                 "filled-points": "0.1",
        //                 "fee-deduct-currency": "hbpoint",
        //                 "fee-deduct-state": "done",
        //                 "id": 313288753120940,
        //                 "type": "buy-market"
        //             }
        //         ]
        //     }
        //
        // contracts
        //
        //     {
        //         "status": "ok",
        //         "data": {
        //             "trades": [
        //                 {
        //                     "query_id": 2424420723,
        //                     "match_id": 113891764710,
        //                     "order_id": 773135295142658048,
        //                     "symbol": "ADA",
        //                     "contract_type": "quarter", // swap
        //                     "business_type": "futures", // swap
        //                     "contract_code": "ADA201225",
        //                     "direction": "buy",
        //                     "offset": "open",
        //                     "trade_volume": 1,
        //                     "trade_price": 0.092,
        //                     "trade_turnover": 10,
        //                     "trade_fee": -0.021739130434782608,
        //                     "offset_profitloss": 0,
        //                     "create_date": 1604371703183,
        //                     "role": "Maker",
        //                     "order_source": "web",
        //                     "order_id_str": "773135295142658048",
        //                     "fee_asset": "ADA",
        //                     "margin_mode": "isolated", // cross
        //                     "margin_account": "BTC-USDT",
        //                     "real_profit": 0,
        //                     "id": "113891764710-773135295142658048-1",
        //                     "trade_partition":"USDT",
        //                 }
        //             ],
        //             "remain_size": 15,
        //             "next_id": 2424413094
        //         },
        //         "ts": 1604372202243
        //     }
        //
        object trades = this.safeValue(response, "data");
        if (!isTrue(((trades is IList<object>) || (trades.GetType().IsGenericType && trades.GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>))))))
        {
            trades = this.safeValue(trades, "trades");
        }
        return this.parseTrades(trades, market, since, limit);
    }

    /**
     * @method
     * @name htx#fetchTrades
     * @see https://huobiapi.github.io/docs/spot/v1/en/#get-the-most-recent-trades
     * @see https://huobiapi.github.io/docs/dm/v1/en/#query-a-batch-of-trade-records-of-a-contract
     * @see https://huobiapi.github.io/docs/coin_margined_swap/v1/en/#query-a-batch-of-trade-records-of-a-contract
     * @see https://huobiapi.github.io/docs/usdt_swap/v1/en/#general-query-a-batch-of-trade-records-of-a-contract
     * @description get the list of most recent trades for a particular symbol
     * @param {string} symbol unified symbol of the market to fetch trades for
     * @param {int} [since] timestamp in ms of the earliest trade to fetch
     * @param {int} [limit] the maximum amount of trades to fetch
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/?id=public-trades}
     */
    public async override Task<object> fetchTrades(object symbol, object since = null, object limit = null, object parameters = null)
    {
        limit ??= 1000;
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {};
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["size"] = mathMin(limit, 2000); // max 2000
        }
        object response = null;
        if (isTrue(getValue(market, "future")))
        {
            if (isTrue(getValue(market, "inverse")))
            {
                ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
                response = await this.contractPublicGetMarketHistoryTrade(this.extend(request, parameters));
            } else if (isTrue(getValue(market, "linear")))
            {
                ((IDictionary<string,object>)request)["contract_code"] = getValue(market, "id");
                response = await this.contractPublicGetLinearSwapExMarketHistoryTrade(this.extend(request, parameters));
            }
        } else if (isTrue(getValue(market, "swap")))
        {
            ((IDictionary<string,object>)request)["contract_code"] = getValue(market, "id");
            if (isTrue(getValue(market, "inverse")))
            {
                response = await this.contractPublicGetSwapExMarketHistoryTrade(this.extend(request, parameters));
            } else if (isTrue(getValue(market, "linear")))
            {
                response = await this.contractPublicGetLinearSwapExMarketHistoryTrade(this.extend(request, parameters));
            }
        } else
        {
            ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
            response = await this.spotPublicGetMarketHistoryTrade(this.extend(request, parameters));
        }
        //
        //     {
        //         "status": "ok",
        //         "ch": "market.btcusdt.trade.detail",
        //         "ts": 1583497692365,
        //         "data": [
        //             {
        //                 "id": 105005170342,
        //                 "ts": 1583497692182,
        //                 "data": [
        //                     {
        //                         "amount": 0.010411000000000000,
        //                         "trade-id": 102090736910,
        //                         "ts": 1583497692182,
        //                         "id": 10500517034273194594947,
        //                         "price": 9096.050000000000000000,
        //                         "direction": "sell"
        //                     }
        //                 ]
        //             },
        //             // ...
        //         ]
        //     }
        //
        object data = this.safeValue(response, "data", new List<object>() {});
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
        {
            object trades = this.safeValue(getValue(data, i), "data", new List<object>() {});
            for (object j = 0; isLessThan(j, getArrayLength(trades)); postFixIncrement(ref j))
            {
                object trade = this.parseTrade(getValue(trades, j), market);
                ((IList<object>)result).Add(trade);
            }
        }
        result = this.sortBy(result, "timestamp");
        return this.filterBySymbolSinceLimit(result, getValue(market, "symbol"), since, limit);
    }

    public override object parseOHLCV(object ohlcv, object market = null)
    {
        //
        //     {
        //         "amount":1.2082,
        //         "open":0.025096,
        //         "close":0.025095,
        //         "high":0.025096,
        //         "id":1591515300,
        //         "count":6,
        //         "low":0.025095,
        //         "vol":0.0303205097
        //     }
        //
        return new List<object> {this.safeTimestamp(ohlcv, "id"), this.safeNumber(ohlcv, "open"), this.safeNumber(ohlcv, "high"), this.safeNumber(ohlcv, "low"), this.safeNumber(ohlcv, "close"), this.safeNumber(ohlcv, "amount")};
    }

    /**
     * @method
     * @name htx#fetchOHLCV
     * @description fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
     * @see https://huobiapi.github.io/docs/spot/v1/en/#get-klines-candles
     * @see https://huobiapi.github.io/docs/dm/v1/en/#get-kline-data
     * @see https://huobiapi.github.io/docs/coin_margined_swap/v1/en/#get-kline-data
     * @see https://huobiapi.github.io/docs/usdt_swap/v1/en/#general-get-kline-data
     * @param {string} symbol unified symbol of the market to fetch OHLCV data for
     * @param {string} timeframe the length of time each candle represents
     * @param {int} [since] timestamp in ms of the earliest candle to fetch
     * @param {int} [limit] the maximum amount of candles to fetch
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [availble parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
     * @param {string} [params.useHistoricalEndpointForSpot] true/false - whether use the historical candles endpoint for spot markets or default klines endpoint
     * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
     */
    public async override Task<object> fetchOHLCV(object symbol, object timeframe = null, object since = null, object limit = null, object parameters = null)
    {
        timeframe ??= "1m";
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object paginate = false;
        var paginateparametersVariable = this.handleOptionAndParams(parameters, "fetchOHLCV", "paginate");
        paginate = ((IList<object>)paginateparametersVariable)[0];
        parameters = ((IList<object>)paginateparametersVariable)[1];
        if (isTrue(paginate))
        {
            return await this.fetchPaginatedCallDeterministic("fetchOHLCV", symbol, since, limit, timeframe, parameters, 1000);
        }
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "period", this.safeString(this.timeframes, timeframe, timeframe) },
        };
        object priceType = this.safeStringN(parameters, new List<object>() {"priceType", "price"});
        parameters = this.omit(parameters, new List<object>() {"priceType", "price"});
        object until = null;
        var untilparametersVariable = this.handleParamInteger(parameters, "until");
        until = ((IList<object>)untilparametersVariable)[0];
        parameters = ((IList<object>)untilparametersVariable)[1];
        object untilSeconds = ((bool) isTrue((!isEqual(until, null)))) ? this.parseToInt(divide(until, 1000)) : null;
        if (isTrue(getValue(market, "contract")))
        {
            if (isTrue(!isEqual(limit, null)))
            {
                ((IDictionary<string,object>)request)["size"] = mathMin(limit, 2000); // when using limit: from & to are ignored
            } else
            {
                limit = 2000; // only used for from/to calculation
            }
            if (isTrue(isEqual(priceType, null)))
            {
                object duration = this.parseTimeframe(timeframe);
                object calcualtedEnd = null;
                if (isTrue(isEqual(since, null)))
                {
                    object now = this.seconds();
                    ((IDictionary<string,object>)request)["from"] = subtract(now, multiply(duration, (subtract(limit, 1))));
                    calcualtedEnd = now;
                } else
                {
                    object start = this.parseToInt(divide(since, 1000));
                    ((IDictionary<string,object>)request)["from"] = start;
                    calcualtedEnd = this.sum(start, multiply(duration, (subtract(limit, 1))));
                }
                ((IDictionary<string,object>)request)["to"] = ((bool) isTrue((!isEqual(untilSeconds, null)))) ? untilSeconds : calcualtedEnd;
            }
        }
        object response = null;
        if (isTrue(getValue(market, "future")))
        {
            if (isTrue(getValue(market, "inverse")))
            {
                ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
                if (isTrue(isEqual(priceType, "mark")))
                {
                    response = await this.contractPublicGetIndexMarketHistoryMarkPriceKline(this.extend(request, parameters));
                } else if (isTrue(isEqual(priceType, "index")))
                {
                    response = await this.contractPublicGetIndexMarketHistoryIndex(this.extend(request, parameters));
                } else if (isTrue(isEqual(priceType, "premiumIndex")))
                {
                    throw new BadRequest ((string)add(add(add(add(add(this.id, " "), getValue(market, "type")), " has no api endpoint for "), priceType), " kline data")) ;
                } else
                {
                    response = await this.contractPublicGetMarketHistoryKline(this.extend(request, parameters));
                }
            } else if (isTrue(getValue(market, "linear")))
            {
                ((IDictionary<string,object>)request)["contract_code"] = getValue(market, "id");
                if (isTrue(isEqual(priceType, "mark")))
                {
                    response = await this.contractPublicGetIndexMarketHistoryLinearSwapMarkPriceKline(this.extend(request, parameters));
                } else if (isTrue(isEqual(priceType, "index")))
                {
                    throw new BadRequest ((string)add(add(add(add(add(this.id, " "), getValue(market, "type")), " has no api endpoint for "), priceType), " kline data")) ;
                } else if (isTrue(isEqual(priceType, "premiumIndex")))
                {
                    response = await this.contractPublicGetIndexMarketHistoryLinearSwapPremiumIndexKline(this.extend(request, parameters));
                } else
                {
                    response = await this.contractPublicGetLinearSwapExMarketHistoryKline(this.extend(request, parameters));
                }
            }
        } else if (isTrue(getValue(market, "swap")))
        {
            ((IDictionary<string,object>)request)["contract_code"] = getValue(market, "id");
            if (isTrue(getValue(market, "inverse")))
            {
                if (isTrue(isEqual(priceType, "mark")))
                {
                    response = await this.contractPublicGetIndexMarketHistorySwapMarkPriceKline(this.extend(request, parameters));
                } else if (isTrue(isEqual(priceType, "index")))
                {
                    throw new BadRequest ((string)add(add(add(add(add(this.id, " "), getValue(market, "type")), " has no api endpoint for "), priceType), " kline data")) ;
                } else if (isTrue(isEqual(priceType, "premiumIndex")))
                {
                    response = await this.contractPublicGetIndexMarketHistorySwapPremiumIndexKline(this.extend(request, parameters));
                } else
                {
                    response = await this.contractPublicGetSwapExMarketHistoryKline(this.extend(request, parameters));
                }
            } else if (isTrue(getValue(market, "linear")))
            {
                if (isTrue(isEqual(priceType, "mark")))
                {
                    response = await this.contractPublicGetIndexMarketHistoryLinearSwapMarkPriceKline(this.extend(request, parameters));
                } else if (isTrue(isEqual(priceType, "index")))
                {
                    throw new BadRequest ((string)add(add(add(add(add(this.id, " "), getValue(market, "type")), " has no api endpoint for "), priceType), " kline data")) ;
                } else if (isTrue(isEqual(priceType, "premiumIndex")))
                {
                    response = await this.contractPublicGetIndexMarketHistoryLinearSwapPremiumIndexKline(this.extend(request, parameters));
                } else
                {
                    response = await this.contractPublicGetLinearSwapExMarketHistoryKline(this.extend(request, parameters));
                }
            }
        } else
        {
            ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
            object useHistorical = null;
            var useHistoricalparametersVariable = this.handleOptionAndParams(parameters, "fetchOHLCV", "useHistoricalEndpointForSpot", true);
            useHistorical = ((IList<object>)useHistoricalparametersVariable)[0];
            parameters = ((IList<object>)useHistoricalparametersVariable)[1];
            if (!isTrue(useHistorical))
            {
                if (isTrue(!isEqual(limit, null)))
                {
                    ((IDictionary<string,object>)request)["size"] = mathMin(limit, 2000); // max 2000
                }
                response = await this.spotPublicGetMarketHistoryKline(this.extend(request, parameters));
            } else
            {
                // "from & to" only available for the this endpoint
                if (isTrue(!isEqual(since, null)))
                {
                    ((IDictionary<string,object>)request)["from"] = this.parseToInt(divide(since, 1000));
                }
                if (isTrue(!isEqual(untilSeconds, null)))
                {
                    ((IDictionary<string,object>)request)["to"] = untilSeconds;
                }
                if (isTrue(!isEqual(limit, null)))
                {
                    ((IDictionary<string,object>)request)["size"] = mathMin(1000, limit); // max 1000, otherwise default returns 150
                }
                response = await this.spotPublicGetMarketHistoryCandles(this.extend(request, parameters));
            }
        }
        //
        //     {
        //         "status":"ok",
        //         "ch":"market.ethbtc.kline.1min",
        //         "ts":1591515374371,
        //         "data":[
        //             {"amount":0.0,"open":0.025095,"close":0.025095,"high":0.025095,"id":1591515360,"count":0,"low":0.025095,"vol":0.0},
        //             {"amount":1.2082,"open":0.025096,"close":0.025095,"high":0.025096,"id":1591515300,"count":6,"low":0.025095,"vol":0.0303205097},
        //             {"amount":0.0648,"open":0.025096,"close":0.025096,"high":0.025096,"id":1591515240,"count":2,"low":0.025096,"vol":0.0016262208},
        //         ]
        //     }
        //
        object data = this.safeList(response, "data", new List<object>() {});
        return this.parseOHLCVs(data, market, timeframe, since, limit);
    }

    /**
     * @method
     * @name htx#fetchAccounts
     * @description fetch all the accounts associated with a profile
     * @see https://huobiapi.github.io/docs/spot/v1/en/#get-all-accounts-of-the-current-user
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a dictionary of [account structures]{@link https://docs.ccxt.com/?id=account-structure} indexed by the account type
     */
    public async override Task<object> fetchAccounts(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.spotPrivateGetV1AccountAccounts(parameters);
        //
        //     {
        //         "status":"ok",
        //         "data":[
        //             {"id":5202591,"type":"point","subtype":"","state":"working"},
        //             {"id":1528640,"type":"spot","subtype":"","state":"working"},
        //         ]
        //     }
        //
        object data = this.safeValue(response, "data");
        return this.parseAccounts(data);
    }

    public override object parseAccount(object account)
    {
        //
        //     {
        //         "id": 5202591,
        //         "type": "point",   // spot, margin, otc, point, super-margin, investment, borrow, grid-trading, deposit-earning, otc-options
        //         "subtype": "",     // The corresponding trading symbol (currency pair) the isolated margin is based on, e.g. btcusdt
        //         "state": "working" // working, lock
        //     }
        //
        object typeId = this.safeString(account, "type");
        object accountsById = this.safeValue(this.options, "accountsById", new Dictionary<string, object>() {});
        object type = this.safeValue(accountsById, typeId, typeId);
        return new Dictionary<string, object>() {
            { "info", account },
            { "id", this.safeString(account, "id") },
            { "type", type },
            { "code", null },
        };
    }

    /**
     * @method
     * @name htx#fetchAccountIdByType
     * @description fetch all the accounts by a type and marginModeassociated with a profile
     * @see https://huobiapi.github.io/docs/spot/v1/en/#get-all-accounts-of-the-current-user
     * @param {string} type 'spot', 'swap' or 'future
     * @param {string} [marginMode] 'cross' or 'isolated'
     * @param {string} [symbol] unified ccxt market symbol
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a dictionary of [account structures]{@link https://docs.ccxt.com/?id=account-structure} indexed by the account type
     */
    public async virtual Task<object> fetchAccountIdByType(object type, object marginMode = null, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object accounts = await this.loadAccounts();
        object accountId = this.safeValue2(parameters, "accountId", "account-id");
        if (isTrue(!isEqual(accountId, null)))
        {
            return accountId;
        }
        if (isTrue(isEqual(type, "spot")))
        {
            if (isTrue(isEqual(marginMode, "cross")))
            {
                type = "super-margin";
            } else if (isTrue(isEqual(marginMode, "isolated")))
            {
                type = "margin";
            }
        }
        object marketId = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            marketId = this.marketId(symbol);
        }
        for (object i = 0; isLessThan(i, getArrayLength(accounts)); postFixIncrement(ref i))
        {
            object account = getValue(accounts, i);
            object info = this.safeValue(account, "info");
            object subtype = this.safeString(info, "subtype", null);
            object typeFromAccount = this.safeString(account, "type");
            if (isTrue(isEqual(type, "margin")))
            {
                if (isTrue(isEqual(subtype, marketId)))
                {
                    return this.safeString(account, "id");
                }
            } else if (isTrue(isEqual(type, typeFromAccount)))
            {
                return this.safeString(account, "id");
            }
        }
        object defaultAccount = this.safeValue(accounts, 0, new Dictionary<string, object>() {});
        return this.safeString(defaultAccount, "id");
    }

    /**
     * @method
     * @name htx#fetchCurrencies
     * @description fetches all available currencies on an exchange
     * @see https://huobiapi.github.io/docs/spot/v1/en/#apiv2-currency-amp-chains
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} an associative dictionary of currencies
     */
    public async override Task<object> fetchCurrencies(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object response = await this.spotPublicGetV2ReferenceCurrencies(parameters);
        //
        //    {
        //        "code": 200,
        //        "data": [
        //            {
        //                "currency": "sxp",
        //                "assetType": "1",
        //                "chains": [
        //                    {
        //                        "chain": "sxp",
        //                        "displayName": "ERC20",
        //                        "baseChain": "ETH",
        //                        "baseChainProtocol": "ERC20",
        //                        "isDynamic": true,
        //                        "numOfConfirmations": "12",
        //                        "numOfFastConfirmations": "12",
        //                        "depositStatus": "allowed",
        //                        "minDepositAmt": "0.23",
        //                        "withdrawStatus": "allowed",
        //                        "minWithdrawAmt": "0.23",
        //                        "withdrawPrecision": "8",
        //                        "maxWithdrawAmt": "227000.000000000000000000",
        //                        "withdrawQuotaPerDay": "227000.000000000000000000",
        //                        "withdrawQuotaPerYear": null,
        //                        "withdrawQuotaTotal": null,
        //                        "withdrawFeeType": "fixed",
        //                        "transactFeeWithdraw": "11.1654",
        //                        "addrWithTag": false,
        //                        "addrDepositTag": false
        //                    }
        //                ],
        //                "instStatus": "normal"
        //            }
        //        ]
        //    }
        //
        object data = this.safeList(response, "data", new List<object>() {});
        object result = new Dictionary<string, object>() {};
        ((IDictionary<string,object>)this.options)["networkChainIdsByNames"] = new Dictionary<string, object>() {};
        ((IDictionary<string,object>)this.options)["networkNamesByChainIds"] = new Dictionary<string, object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
        {
            object entry = getValue(data, i);
            object currencyId = this.safeString(entry, "currency");
            object code = this.safeCurrencyCode(currencyId);
            object assetType = this.safeString(entry, "assetType");
            object type = ((bool) isTrue(isEqual(assetType, "1"))) ? "crypto" : "fiat";
            ((IDictionary<string,object>)getValue(this.options, "networkChainIdsByNames"))[(string)code] = new Dictionary<string, object>() {};
            object chains = this.safeList(entry, "chains", new List<object>() {});
            object networks = new Dictionary<string, object>() {};
            for (object j = 0; isLessThan(j, getArrayLength(chains)); postFixIncrement(ref j))
            {
                object chainEntry = getValue(chains, j);
                object uniqueChainId = this.safeString(chainEntry, "chain"); // i.e. usdterc20, trc20usdt ...
                object title = this.safeString2(chainEntry, "baseChain", "displayName"); // baseChain and baseChainProtocol are together existent or inexistent in entries, but baseChain is preferred. when they are both inexistent, then we use generic displayName
                ((IDictionary<string,object>)getValue(getValue(this.options, "networkChainIdsByNames"), code))[(string)title] = uniqueChainId;
                ((IDictionary<string,object>)getValue(this.options, "networkNamesByChainIds"))[(string)uniqueChainId] = title;
                object networkCode = this.networkIdToCode(uniqueChainId);
                ((IDictionary<string,object>)networks)[(string)networkCode] = new Dictionary<string, object>() {
                    { "info", chainEntry },
                    { "id", uniqueChainId },
                    { "network", networkCode },
                    { "limits", new Dictionary<string, object>() {
                        { "deposit", new Dictionary<string, object>() {
                            { "min", this.safeNumber(chainEntry, "minDepositAmt") },
                            { "max", null },
                        } },
                        { "withdraw", new Dictionary<string, object>() {
                            { "min", this.safeNumber(chainEntry, "minWithdrawAmt") },
                            { "max", this.safeNumber(chainEntry, "maxWithdrawAmt") },
                        } },
                    } },
                    { "active", null },
                    { "deposit", isEqual(this.safeString(chainEntry, "depositStatus"), "allowed") },
                    { "withdraw", isEqual(this.safeString(chainEntry, "withdrawStatus"), "allowed") },
                    { "fee", this.safeNumber(chainEntry, "transactFeeWithdraw") },
                    { "precision", this.parseNumber(this.parsePrecision(this.safeString(chainEntry, "withdrawPrecision"))) },
                };
            }
            ((IDictionary<string,object>)result)[(string)code] = this.safeCurrencyStructure(new Dictionary<string, object>() {
                { "info", entry },
                { "code", code },
                { "id", currencyId },
                { "active", isEqual(this.safeString(entry, "instStatus"), "normal") },
                { "deposit", null },
                { "withdraw", null },
                { "fee", null },
                { "name", null },
                { "type", type },
                { "limits", new Dictionary<string, object>() {
                    { "amount", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                    { "withdraw", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                    { "deposit", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                } },
                { "precision", null },
                { "networks", networks },
            });
        }
        return result;
    }

    public override object networkIdToCode(object networkId = null, object currencyCode = null)
    {
        // here network-id is provided as a pair of currency & chain (i.e. trc20usdt)
        object keys = new List<object>(((IDictionary<string,object>)getValue(this.options, "networkNamesByChainIds")).Keys);
        object keysLength = getArrayLength(keys);
        if (isTrue(isEqual(keysLength, 0)))
        {
            throw new ExchangeError ((string)add(this.id, " networkIdToCode() - markets need to be loaded at first")) ;
        }
        object networkTitle = this.safeValue(getValue(this.options, "networkNamesByChainIds"), networkId, networkId);
        return base.networkIdToCode(networkTitle);
    }

    public override object networkCodeToId(object networkCode, object currencyCode = null)
    {
        if (isTrue(isEqual(currencyCode, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " networkCodeToId() requires a currencyCode argument")) ;
        }
        object keys = new List<object>(((IDictionary<string,object>)getValue(this.options, "networkChainIdsByNames")).Keys);
        object keysLength = getArrayLength(keys);
        if (isTrue(isEqual(keysLength, 0)))
        {
            throw new ExchangeError ((string)add(this.id, " networkCodeToId() - markets need to be loaded at first")) ;
        }
        object uniqueNetworkIds = this.safeValue(getValue(this.options, "networkChainIdsByNames"), currencyCode, new Dictionary<string, object>() {});
        if (isTrue(inOp(uniqueNetworkIds, networkCode)))
        {
            return getValue(uniqueNetworkIds, networkCode);
        } else
        {
            object networkTitle = base.networkCodeToId(networkCode);
            return this.safeValue(uniqueNetworkIds, networkTitle, networkTitle);
        }
    }

    /**
     * @method
     * @name htx#fetchBalance
     * @see https://huobiapi.github.io/docs/spot/v1/en/#get-account-balance-of-a-specific-account
     * @see https://www.htx.com/en-us/opend/newApiPages/?id=7ec4b429-7773-11ed-9966-0242ac110003
     * @see https://www.htx.com/en-us/opend/newApiPages/?id=10000074-77b7-11ed-9966-0242ac110003
     * @see https://huobiapi.github.io/docs/dm/v1/en/#query-asset-valuation
     * @see https://huobiapi.github.io/docs/coin_margined_swap/v1/en/#query-user-s-account-information
     * @see https://huobiapi.github.io/docs/usdt_swap/v1/en/#isolated-query-user-s-account-information
     * @see https://huobiapi.github.io/docs/usdt_swap/v1/en/#cross-query-user-39-s-account-information
     * @description query for balance and get the amount of funds available for trading or funds locked in orders
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {bool} [params.unified] provide this parameter if you have a recent account with unified cross+isolated margin account
     * @returns {object} a [balance structure]{@link https://docs.ccxt.com/?id=balance-structure}
     */
    public async override Task<object> fetchBalance(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object type = null;
        var typeparametersVariable = this.handleMarketTypeAndParams("fetchBalance", null, parameters);
        type = ((IList<object>)typeparametersVariable)[0];
        parameters = ((IList<object>)typeparametersVariable)[1];
        object options = this.safeValue(this.options, "fetchBalance", new Dictionary<string, object>() {});
        object isUnifiedAccount = this.safeValue2(parameters, "isUnifiedAccount", "unified", false);
        parameters = this.omit(parameters, new List<object>() {"isUnifiedAccount", "unified"});
        object request = new Dictionary<string, object>() {};
        object spot = (isEqual(type, "spot"));
        object future = (isEqual(type, "future"));
        object defaultSubType = this.safeString2(this.options, "defaultSubType", "subType", "linear");
        object subType = this.safeString2(options, "defaultSubType", "subType", defaultSubType);
        subType = this.safeString2(parameters, "defaultSubType", "subType", subType);
        object inverse = (isEqual(subType, "inverse"));
        object linear = (isEqual(subType, "linear"));
        object marginMode = null;
        var marginModeparametersVariable = this.handleMarginModeAndParams("fetchBalance", parameters);
        marginMode = ((IList<object>)marginModeparametersVariable)[0];
        parameters = ((IList<object>)marginModeparametersVariable)[1];
        parameters = this.omit(parameters, new List<object>() {"defaultSubType", "subType"});
        object isolated = (isEqual(marginMode, "isolated"));
        object cross = (isEqual(marginMode, "cross"));
        object margin = isTrue((isEqual(type, "margin"))) || isTrue((isTrue(spot) && isTrue((isTrue(cross) || isTrue(isolated)))));
        object response = null;
        if (isTrue(isTrue(spot) || isTrue(margin)))
        {
            if (isTrue(margin))
            {
                if (isTrue(isolated))
                {
                    response = await this.spotPrivateGetV1MarginAccountsBalance(this.extend(request, parameters));
                } else
                {
                    response = await this.spotPrivateGetV1CrossMarginAccountsBalance(this.extend(request, parameters));
                }
            } else
            {
                await this.loadAccounts();
                object accountId = await this.fetchAccountIdByType(type, null, null, parameters);
                ((IDictionary<string,object>)request)["account-id"] = accountId;
                response = await this.spotPrivateGetV1AccountAccountsAccountIdBalance(this.extend(request, parameters));
            }
        } else if (isTrue(isUnifiedAccount))
        {
            response = await this.contractPrivateGetLinearSwapApiV3UnifiedAccountInfo(this.extend(request, parameters));
        } else if (isTrue(linear))
        {
            if (isTrue(isolated))
            {
                response = await this.contractPrivatePostLinearSwapApiV1SwapAccountInfo(this.extend(request, parameters));
            } else
            {
                response = await this.contractPrivatePostLinearSwapApiV1SwapCrossAccountInfo(this.extend(request, parameters));
            }
        } else if (isTrue(inverse))
        {
            if (isTrue(future))
            {
                response = await this.contractPrivatePostApiV1ContractAccountInfo(this.extend(request, parameters));
            } else
            {
                response = await this.contractPrivatePostSwapApiV1SwapAccountInfo(this.extend(request, parameters));
            }
        }
        //
        // spot
        //
        //     {
        //         "status": "ok",
        //         "data": {
        //             "id": 1528640,
        //             "type": "spot",
        //             "state": "working",
        //             "list": [
        //                 { "currency": "lun", "type": "trade", "balance": "0", "seq-num": "0" },
        //                 { "currency": "lun", "type": "frozen", "balance": "0", "seq-num": "0" },
        //                 { "currency": "ht", "type": "frozen", "balance": "0", "seq-num": "145" },
        //             ]
        //         },
        //         "ts":1637644827566
        //     }
        //
        // cross margin
        //
        //     {
        //         "status": "ok",
        //         "data": {
        //             "id": 51015302,
        //             "type": "cross-margin",
        //             "state": "working",
        //             "risk-rate": "2",
        //             "acct-balance-sum": "100",
        //             "debt-balance-sum": "0",
        //             "list": [
        //                 { "currency": "usdt", "type": "trade", "balance": "100" },
        //                 { "currency": "usdt", "type": "frozen", "balance": "0" },
        //                 { "currency": "usdt", "type": "loan-available", "balance": "200" },
        //                 { "currency": "usdt", "type": "transfer-out-available", "balance": "-1" },
        //                 { "currency": "ht", "type": "loan-available", "balance": "36.60724091" },
        //                 { "currency": "ht", "type": "transfer-out-available", "balance": "-1" },
        //                 { "currency": "btc", "type": "trade", "balance": "1168.533000000000000000" },
        //                 { "currency": "btc", "type": "frozen", "balance": "0.000000000000000000" },
        //                 { "currency": "btc", "type": "loan", "balance": "-2.433000000000000000" },
        //                 { "currency": "btc", "type": "interest", "balance": "-0.000533000000000000" },
        //                 { "currency": "btc", "type": "transfer-out-available", "balance": "1163.872174670000000000" },
        //                 { "currency": "btc", "type": "loan-available", "balance": "8161.876538350676000000" }
        //             ]
        //         },
        //         "code": 200
        //     }
        //
        // isolated margin
        //
        //     {
        //         "data": [
        //             {
        //                 "id": 18264,
        //                 "type": "margin",
        //                 "state": "working",
        //                 "symbol": "btcusdt",
        //                 "fl-price": "0",
        //                 "fl-type": "safe",
        //                 "risk-rate": "475.952571086994250554",
        //                 "list": [
        //                     { "currency": "btc","type": "trade","balance": "1168.533000000000000000" },
        //                     { "currency": "btc","type": "frozen","balance": "0.000000000000000000" },
        //                     { "currency": "btc","type": "loan","balance": "-2.433000000000000000" },
        //                     { "currency": "btc","type": "interest","balance": "-0.000533000000000000" },
        //                     { "currency": "btc","type": "transfer-out-available", "balance": "1163.872174670000000000" },
        //                     { "currency": "btc","type": "loan-available", "balance": "8161.876538350676000000" }
        //                 ]
        //             }
        //         ]
        //     }
        //
        // future, swap isolated
        //
        //     {
        //         "status": "ok",
        //         "data": [
        //             {
        //                 "symbol": "BTC",
        //                 "margin_balance": 0,
        //                 "margin_position": 0E-18,
        //                 "margin_frozen": 0,
        //                 "margin_available": 0E-18,
        //                 "profit_real": 0,
        //                 "profit_unreal": 0,
        //                 "risk_rate": null,
        //                 "withdraw_available": 0,
        //                 "liquidation_price": null,
        //                 "lever_rate": 5,
        //                 "adjust_factor": 0.025000000000000000,
        //                 "margin_static": 0,
        //                 "is_debit": 0, // future only
        //                 "contract_code": "BTC-USD", // swap only
        //                 "margin_asset": "USDT", // linear only
        //                 "margin_mode": "isolated", // linear only
        //                 "margin_account": "BTC-USDT" // linear only
        //                 "transfer_profit_ratio": null // inverse only
        //             },
        //         ],
        //         "ts": 1637644827566
        //     }
        //
        // linear cross futures and linear cross swap
        //
        //     {
        //         "status": "ok",
        //         "data": [
        //             {
        //                 "futures_contract_detail": [
        //                     {
        //                         "symbol": "ETH",
        //                         "contract_code": "ETH-USDT-220325",
        //                         "margin_position": 0,
        //                         "margin_frozen": 0,
        //                         "margin_available": 200.000000000000000000,
        //                         "profit_unreal": 0E-18,
        //                         "liquidation_price": null,
        //                         "lever_rate": 5,
        //                         "adjust_factor": 0.060000000000000000,
        //                         "contract_type": "quarter",
        //                         "pair": "ETH-USDT",
        //                         "business_type": "futures"
        //                     },
        //                 ],
        //                 "margin_mode": "cross",
        //                 "margin_account": "USDT",
        //                 "margin_asset": "USDT",
        //                 "margin_balance": 49.874186030200000000,
        //                 "money_in": 50,
        //                 "money_out": 0,
        //                 "margin_static": 49.872786030200000000,
        //                 "margin_position": 6.180000000000000000,
        //                 "margin_frozen": 6.000000000000000000,
        //                 "profit_unreal": 0.001400000000000000,
        //                 "withdraw_available": 37.6927860302,
        //                 "risk_rate": 271.984050521072796934,
        //                 "new_risk_rate": 0.001858676950514399,
        //                 "contract_detail": [
        //                     {
        //                         "symbol": "MANA",
        //                         "contract_code": "MANA-USDT",
        //                         "margin_position": 0,
        //                         "margin_frozen": 0,
        //                         "margin_available": 200.000000000000000000,
        //                         "profit_unreal": 0E-18,
        //                         "liquidation_price": null,
        //                         "lever_rate": 5,
        //                         "adjust_factor": 0.100000000000000000,
        //                         "contract_type": "swap",
        //                         "pair": "MANA-USDT",
        //                         "business_type": "swap"
        //                     },
        //                 ]
        //             }
        //         ],
        //         "ts": 1640915104870
        //     }
        //
        // TODO add balance parsing for linear swap
        //
        object result = ((object)new Dictionary<string, object>() {
            { "info", response },
        });
        object data = this.safeValue(response, "data");
        if (isTrue(isTrue(spot) || isTrue(margin)))
        {
            if (isTrue(isolated))
            {
                for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
                {
                    object entry = getValue(data, i);
                    object symbol = this.safeSymbol(this.safeString(entry, "symbol"));
                    object balances = this.safeValue(entry, "list");
                    object subResult = new Dictionary<string, object>() {};
                    for (object j = 0; isLessThan(j, getArrayLength(balances)); postFixIncrement(ref j))
                    {
                        object balance = getValue(balances, j);
                        object currencyId = this.safeString(balance, "currency");
                        object code = this.safeCurrencyCode(currencyId);
                        ((IDictionary<string,object>)subResult)[(string)code] = this.parseMarginBalanceHelper(balance, code, subResult);
                    }
                    ((IDictionary<string,object>)result)[(string)symbol] = this.safeBalance(subResult);
                }
            } else
            {
                object balances = this.safeValue(data, "list", new List<object>() {});
                for (object i = 0; isLessThan(i, getArrayLength(balances)); postFixIncrement(ref i))
                {
                    object balance = getValue(balances, i);
                    object currencyId = this.safeString(balance, "currency");
                    object code = this.safeCurrencyCode(currencyId);
                    ((IDictionary<string,object>)result)[(string)code] = this.parseMarginBalanceHelper(balance, code, result);
                }
                result = this.safeBalance(result);
            }
        } else if (isTrue(isUnifiedAccount))
        {
            for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
            {
                object entry = getValue(data, i);
                object marginAsset = this.safeString(entry, "margin_asset");
                object currencyCode = this.safeCurrencyCode(marginAsset);
                if (isTrue(isolated))
                {
                    object isolated_swap = this.safeValue(entry, "isolated_swap", new Dictionary<string, object>() {});
                    for (object j = 0; isLessThan(j, getArrayLength(isolated_swap)); postFixIncrement(ref j))
                    {
                        object balance = getValue(isolated_swap, j);
                        object marketId = this.safeString(balance, "contract_code");
                        object subBalance = new Dictionary<string, object>() {
                            { "code", currencyCode },
                            { "free", this.safeNumber(balance, "margin_available") },
                        };
                        object symbol = this.safeSymbol(marketId);
                        ((IDictionary<string,object>)result)[(string)symbol] = subBalance;
                        result = this.safeBalance(result);
                    }
                } else
                {
                    object account = this.account();
                    ((IDictionary<string,object>)account)["free"] = this.safeString(entry, "margin_static");
                    ((IDictionary<string,object>)account)["used"] = this.safeString(entry, "margin_frozen");
                    ((IDictionary<string,object>)result)[(string)currencyCode] = account;
                    result = this.safeBalance(result);
                }
            }
        } else if (isTrue(linear))
        {
            object first = this.safeValue(data, 0, new Dictionary<string, object>() {});
            if (isTrue(isolated))
            {
                for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
                {
                    object balance = getValue(data, i);
                    object marketId = this.safeString2(balance, "contract_code", "margin_account");
                    object market = this.safeMarket(marketId);
                    object currencyId = this.safeString(balance, "margin_asset");
                    object currency = this.safeCurrency(currencyId);
                    object code = this.safeString(market, "settle", getValue(currency, "code"));
                    // the exchange outputs positions for delisted markets
                    // https://www.huobi.com/support/en-us/detail/74882968522337
                    // we skip it if the market was delisted
                    if (isTrue(!isEqual(code, null)))
                    {
                        object account = this.account();
                        ((IDictionary<string,object>)account)["free"] = this.safeString(balance, "margin_balance");
                        ((IDictionary<string,object>)account)["used"] = this.safeString(balance, "margin_frozen");
                        object accountsByCode = new Dictionary<string, object>() {};
                        ((IDictionary<string,object>)accountsByCode)[(string)code] = account;
                        object symbol = getValue(market, "symbol");
                        ((IDictionary<string,object>)result)[(string)symbol] = this.safeBalance(accountsByCode);
                    }
                }
            } else
            {
                object account = this.account();
                ((IDictionary<string,object>)account)["free"] = this.safeString(first, "withdraw_available");
                ((IDictionary<string,object>)account)["total"] = this.safeString(first, "margin_balance");
                object currencyId = this.safeString2(first, "margin_asset", "symbol");
                object code = this.safeCurrencyCode(currencyId);
                ((IDictionary<string,object>)result)[(string)code] = account;
                result = this.safeBalance(result);
            }
        } else if (isTrue(inverse))
        {
            for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
            {
                object balance = getValue(data, i);
                object currencyId = this.safeString(balance, "symbol");
                object code = this.safeCurrencyCode(currencyId);
                object account = this.account();
                ((IDictionary<string,object>)account)["free"] = this.safeString(balance, "margin_available");
                ((IDictionary<string,object>)account)["used"] = this.safeString(balance, "margin_frozen");
                ((IDictionary<string,object>)result)[(string)code] = account;
            }
            result = this.safeBalance(result);
        }
        return result;
    }

    /**
     * @method
     * @name htx#fetchOrder
     * @description fetches information on an order made by the user
     * @see https://huobiapi.github.io/docs/spot/v1/en/#get-the-order-detail-of-an-order-based-on-client-order-id
     * @see https://huobiapi.github.io/docs/spot/v1/en/#get-the-order-detail-of-an-order
     * @see https://huobiapi.github.io/docs/usdt_swap/v1/en/#isolated-get-information-of-an-order
     * @see https://huobiapi.github.io/docs/usdt_swap/v1/en/#cross-get-information-of-order
     * @see https://huobiapi.github.io/docs/dm/v1/en/#get-information-of-an-order
     * @see https://huobiapi.github.io/docs/coin_margined_swap/v1/en/#get-information-of-an-order
     * @param {string} id order id
     * @param {string} symbol unified symbol of the market the order was made in
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} An [order structure]{@link https://docs.ccxt.com/?id=order-structure}
     */
    public async override Task<object> fetchOrder(object id, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
        }
        object marketType = null;
        var marketTypeparametersVariable = this.handleMarketTypeAndParams("fetchOrder", market, parameters);
        marketType = ((IList<object>)marketTypeparametersVariable)[0];
        parameters = ((IList<object>)marketTypeparametersVariable)[1];
        object request = new Dictionary<string, object>() {};
        object response = null;
        if (isTrue(isEqual(marketType, "spot")))
        {
            object clientOrderId = this.safeString(parameters, "clientOrderId");
            if (isTrue(!isEqual(clientOrderId, null)))
            {
                // will be filled below in extend ()
                // they expect clientOrderId instead of client-order-id
                // request['clientOrderId'] = clientOrderId;
                response = await this.spotPrivateGetV1OrderOrdersGetClientOrder(this.extend(request, parameters));
            } else
            {
                ((IDictionary<string,object>)request)["order-id"] = id;
                response = await this.spotPrivateGetV1OrderOrdersOrderId(this.extend(request, parameters));
            }
        } else
        {
            if (isTrue(isEqual(symbol, null)))
            {
                throw new ArgumentsRequired ((string)add(this.id, " fetchOrder() requires a symbol argument")) ;
            }
            object clientOrderId = this.safeString2(parameters, "client_order_id", "clientOrderId");
            if (isTrue(isEqual(clientOrderId, null)))
            {
                ((IDictionary<string,object>)request)["order_id"] = id;
            } else
            {
                ((IDictionary<string,object>)request)["client_order_id"] = clientOrderId;
                parameters = this.omit(parameters, new List<object>() {"client_order_id", "clientOrderId"});
            }
            ((IDictionary<string,object>)request)["contract_code"] = getValue(market, "id");
            if (isTrue(getValue(market, "linear")))
            {
                object marginMode = null;
                var marginModeparametersVariable = this.handleMarginModeAndParams("fetchOrder", parameters);
                marginMode = ((IList<object>)marginModeparametersVariable)[0];
                parameters = ((IList<object>)marginModeparametersVariable)[1];
                marginMode = ((bool) isTrue((isEqual(marginMode, null)))) ? "cross" : marginMode;
                if (isTrue(isEqual(marginMode, "isolated")))
                {
                    response = await this.contractPrivatePostLinearSwapApiV1SwapOrderInfo(this.extend(request, parameters));
                } else if (isTrue(isEqual(marginMode, "cross")))
                {
                    response = await this.contractPrivatePostLinearSwapApiV1SwapCrossOrderInfo(this.extend(request, parameters));
                }
            } else if (isTrue(getValue(market, "inverse")))
            {
                if (isTrue(isEqual(marketType, "future")))
                {
                    ((IDictionary<string,object>)request)["symbol"] = getValue(market, "settleId");
                    response = await this.contractPrivatePostApiV1ContractOrderInfo(this.extend(request, parameters));
                } else if (isTrue(isEqual(marketType, "swap")))
                {
                    response = await this.contractPrivatePostSwapApiV1SwapOrderInfo(this.extend(request, parameters));
                } else
                {
                    throw new NotSupported ((string)add(add(add(this.id, " fetchOrder() does not support "), marketType), " markets")) ;
                }
            }
        }
        //
        // spot
        //
        //     {
        //         "status":"ok",
        //         "data":{
        //             "id":438398393065481,
        //             "symbol":"ethusdt",
        //             "account-id":1528640,
        //             "client-order-id":"AA03022abc2163433e-006b-480e-9ad1-d4781478c5e7",
        //             "amount":"0.100000000000000000",
        //             "price":"3000.000000000000000000",
        //             "created-at":1640549994642,
        //             "type":"buy-limit",
        //             "field-amount":"0.0",
        //             "field-cash-amount":"0.0",
        //             "field-fees":"0.0",
        //             "finished-at":0,
        //             "source":"spot-api",
        //             "state":"submitted",
        //             "canceled-at":0
        //         }
        //     }
        //
        // linear swap cross margin
        //
        //     {
        //         "status":"ok",
        //         "data":[
        //             {
        //                 "business_type":"swap",
        //                 "contract_type":"swap",
        //                 "pair":"BTC-USDT",
        //                 "symbol":"BTC",
        //                 "contract_code":"BTC-USDT",
        //                 "volume":1,
        //                 "price":3000,
        //                 "order_price_type":"limit",
        //                 "order_type":1,
        //                 "direction":"buy",
        //                 "offset":"open",
        //                 "lever_rate":1,
        //                 "order_id":924912513206878210,
        //                 "client_order_id":null,
        //                 "created_at":1640557927189,
        //                 "trade_volume":0,
        //                 "trade_turnover":0,
        //                 "fee":0,
        //                 "trade_avg_price":null,
        //                 "margin_frozen":3.000000000000000000,
        //                 "profit":0,
        //                 "status":3,
        //                 "order_source":"api",
        //                 "order_id_str":"924912513206878210",
        //                 "fee_asset":"USDT",
        //                 "liquidation_type":"0",
        //                 "canceled_at":0,
        //                 "margin_asset":"USDT",
        //                 "margin_account":"USDT",
        //                 "margin_mode":"cross",
        //                 "is_tpsl":0,
        //                 "real_profit":0
        //             }
        //         ],
        //         "ts":1640557982556
        //     }
        //
        // linear swap isolated margin detail
        //
        //     {
        //         "status": "ok",
        //         "data": {
        //             "symbol": "BTC",
        //             "contract_code": "BTC-USDT",
        //             "instrument_price": 0,
        //             "final_interest": 0,
        //             "adjust_value": 0,
        //             "lever_rate": 10,
        //             "direction": "sell",
        //             "offset": "open",
        //             "volume": 1.000000000000000000,
        //             "price": 13059.800000000000000000,
        //             "created_at": 1603703614712,
        //             "canceled_at": 0,
        //             "order_source": "api",
        //             "order_price_type": "opponent",
        //             "margin_frozen": 0,
        //             "profit": 0,
        //             "trades": [
        //                 {
        //                     "trade_id": 131560927,
        //                     "trade_price": 13059.800000000000000000,
        //                     "trade_volume": 1.000000000000000000,
        //                     "trade_turnover": 13.059800000000000000,
        //                     "trade_fee": -0.005223920000000000,
        //                     "created_at": 1603703614715,
        //                     "role": "taker",
        //                     "fee_asset": "USDT",
        //                     "profit": 0,
        //                     "real_profit": 0,
        //                     "id": "131560927-770334322963152896-1"
        //                 }
        //             ],
        //             "total_page": 1,
        //             "current_page": 1,
        //             "total_size": 1,
        //             "liquidation_type": "0",
        //             "fee_asset": "USDT",
        //             "fee": -0.005223920000000000,
        //             "order_id": 770334322963152896,
        //             "order_id_str": "770334322963152896",
        //             "client_order_id": 57012021045,
        //             "order_type": "1",
        //             "status": 6,
        //             "trade_avg_price": 13059.800000000000000000,
        //             "trade_turnover": 13.059800000000000000,
        //             "trade_volume": 1.000000000000000000,
        //             "margin_asset": "USDT",
        //             "margin_mode": "isolated",
        //             "margin_account": "BTC-USDT",
        //             "real_profit": 0,
        //             "is_tpsl": 0
        //         },
        //         "ts": 1603703678477
        //     }
        object order = this.safeValue(response, "data");
        if (isTrue(((order is IList<object>) || (order.GetType().IsGenericType && order.GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>))))))
        {
            order = this.safeValue(order, 0);
        }
        return this.parseOrder(order);
    }

    public virtual object parseMarginBalanceHelper(object balance, object code, object result)
    {
        object account = null;
        if (isTrue(inOp(result, code)))
        {
            account = getValue(result, code);
        } else
        {
            account = this.account();
        }
        if (isTrue(isEqual(getValue(balance, "type"), "trade")))
        {
            ((IDictionary<string,object>)account)["free"] = this.safeString(balance, "balance");
        }
        if (isTrue(isEqual(getValue(balance, "type"), "frozen")))
        {
            ((IDictionary<string,object>)account)["used"] = this.safeString(balance, "balance");
        }
        return account;
    }

    public async virtual Task<object> fetchSpotOrdersByStates(object states, object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object method = this.safeString(this.options, "fetchOrdersByStatesMethod", "spot_private_get_v1_order_orders"); // spot_private_get_v1_order_history
        if (isTrue(isEqual(method, "spot_private_get_v1_order_orders")))
        {
            if (isTrue(isEqual(symbol, null)))
            {
                throw new ArgumentsRequired ((string)add(this.id, " fetchOrders() requires a symbol argument")) ;
            }
        }
        await this.loadMarkets();
        object market = null;
        object request = new Dictionary<string, object>() {
            { "states", states },
        };
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["start-time"] = since; // a window of 48 hours within 180 days
            ((IDictionary<string,object>)request)["end-time"] = this.sum(since, multiply(multiply(multiply(48, 60), 60), 1000));
        }
        var requestparametersVariable = this.handleUntilOption("end-time", request, parameters);
        request = ((IList<object>)requestparametersVariable)[0];
        parameters = ((IList<object>)requestparametersVariable)[1];
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["size"] = limit;
        }
        object response = null;
        if (isTrue(isEqual(method, "spot_private_get_v1_order_orders")))
        {
            response = await this.spotPrivateGetV1OrderOrders(this.extend(request, parameters));
        } else
        {
            response = await this.spotPrivateGetV1OrderHistory(this.extend(request, parameters));
        }
        //
        // spot_private_get_v1_order_orders GET /v1/order/orders
        //
        //     {
        //         "status": "ok",
        //         "data": [
        //             {
        //                 "id": 13997833014,
        //                 "symbol": "ethbtc",
        //                 "account-id": 3398321,
        //                 "client-order-id": "23456",
        //                 "amount": "0.045000000000000000",
        //                 "price": "0.034014000000000000",
        //                 "created-at": 1545836976871,
        //                 "type": "sell-limit",
        //                 "field-amount": "0.045000000000000000",
        //                 "field-cash-amount": "0.001530630000000000",
        //                 "field-fees": "0.000003061260000000",
        //                 "finished-at": 1545837948214,
        //                 "source": "spot-api",
        //                 "state": "filled",
        //                 "canceled-at": 0
        //             }
        //         ]
        //     }
        //
        object data = this.safeList(response, "data", new List<object>() {});
        return this.parseOrders(data, market, since, limit);
    }

    public async virtual Task<object> fetchSpotOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        return await this.fetchSpotOrdersByStates("pre-submitted,submitted,partial-filled,filled,partial-canceled,canceled", symbol, since, limit, parameters);
    }

    public async virtual Task<object> fetchClosedSpotOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        return await this.fetchSpotOrdersByStates("filled,partial-canceled,canceled", symbol, since, limit, parameters);
    }

    public async virtual Task<object> fetchContractOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchContractOrders() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "trade_type", 0 },
            { "status", "0" },
        };
        object response = null;
        object trigger = this.safeBool2(parameters, "stop", "trigger");
        object stopLossTakeProfit = this.safeValue(parameters, "stopLossTakeProfit");
        object trailing = this.safeBool(parameters, "trailing", false);
        parameters = this.omit(parameters, new List<object>() {"stop", "stopLossTakeProfit", "trailing", "trigger"});
        if (isTrue(isTrue(isTrue(trigger) || isTrue(stopLossTakeProfit)) || isTrue(trailing)))
        {
            if (isTrue(!isEqual(limit, null)))
            {
                ((IDictionary<string,object>)request)["page_size"] = limit;
            }
            ((IDictionary<string,object>)request)["contract_code"] = getValue(market, "id");
            ((IDictionary<string,object>)request)["create_date"] = 90;
        } else
        {
            if (isTrue(!isEqual(since, null)))
            {
                ((IDictionary<string,object>)request)["start_time"] = since; // max 90 days back
            }
            ((IDictionary<string,object>)request)["contract"] = getValue(market, "id");
            ((IDictionary<string,object>)request)["type"] = 1; // 1:All Orders,2:Order in Finished Status
        }
        var requestparametersVariable = this.handleUntilOption("end_time", request, parameters);
        request = ((IList<object>)requestparametersVariable)[0];
        parameters = ((IList<object>)requestparametersVariable)[1];
        if (isTrue(getValue(market, "linear")))
        {
            object marginMode = null;
            var marginModeparametersVariable = this.handleMarginModeAndParams("fetchContractOrders", parameters);
            marginMode = ((IList<object>)marginModeparametersVariable)[0];
            parameters = ((IList<object>)marginModeparametersVariable)[1];
            marginMode = ((bool) isTrue((isEqual(marginMode, null)))) ? "cross" : marginMode;
            if (isTrue(isEqual(marginMode, "isolated")))
            {
                if (isTrue(trigger))
                {
                    response = await this.contractPrivatePostLinearSwapApiV1SwapTriggerHisorders(this.extend(request, parameters));
                } else if (isTrue(stopLossTakeProfit))
                {
                    response = await this.contractPrivatePostLinearSwapApiV1SwapTpslHisorders(this.extend(request, parameters));
                } else if (isTrue(trailing))
                {
                    response = await this.contractPrivatePostLinearSwapApiV1SwapTrackHisorders(this.extend(request, parameters));
                } else
                {
                    response = await this.contractPrivatePostLinearSwapApiV3SwapHisorders(this.extend(request, parameters));
                }
            } else if (isTrue(isEqual(marginMode, "cross")))
            {
                if (isTrue(trigger))
                {
                    response = await this.contractPrivatePostLinearSwapApiV1SwapCrossTriggerHisorders(this.extend(request, parameters));
                } else if (isTrue(stopLossTakeProfit))
                {
                    response = await this.contractPrivatePostLinearSwapApiV1SwapCrossTpslHisorders(this.extend(request, parameters));
                } else if (isTrue(trailing))
                {
                    response = await this.contractPrivatePostLinearSwapApiV1SwapCrossTrackHisorders(this.extend(request, parameters));
                } else
                {
                    response = await this.contractPrivatePostLinearSwapApiV3SwapCrossHisorders(this.extend(request, parameters));
                }
            }
        } else if (isTrue(getValue(market, "inverse")))
        {
            if (isTrue(getValue(market, "swap")))
            {
                if (isTrue(trigger))
                {
                    response = await this.contractPrivatePostSwapApiV1SwapTriggerHisorders(this.extend(request, parameters));
                } else if (isTrue(stopLossTakeProfit))
                {
                    response = await this.contractPrivatePostSwapApiV1SwapTpslHisorders(this.extend(request, parameters));
                } else if (isTrue(trailing))
                {
                    response = await this.contractPrivatePostSwapApiV1SwapTrackHisorders(this.extend(request, parameters));
                } else
                {
                    response = await this.contractPrivatePostSwapApiV3SwapHisorders(this.extend(request, parameters));
                }
            } else if (isTrue(getValue(market, "future")))
            {
                ((IDictionary<string,object>)request)["symbol"] = getValue(market, "settleId");
                if (isTrue(trigger))
                {
                    response = await this.contractPrivatePostApiV1ContractTriggerHisorders(this.extend(request, parameters));
                } else if (isTrue(stopLossTakeProfit))
                {
                    response = await this.contractPrivatePostApiV1ContractTpslHisorders(this.extend(request, parameters));
                } else if (isTrue(trailing))
                {
                    response = await this.contractPrivatePostApiV1ContractTrackHisorders(this.extend(request, parameters));
                } else
                {
                    response = await this.contractPrivatePostApiV3ContractHisorders(this.extend(request, parameters));
                }
            }
        }
        //
        // future and swap
        //
        //     {
        //         "code": 200,
        //         "msg": "ok",
        //         "data": [
        //             {
        //                 "direction": "buy",
        //                 "offset": "open",
        //                 "volume": 1.000000000000000000,
        //                 "price": 25000.000000000000000000,
        //                 "profit": 0E-18,
        //                 "pair": "BTC-USDT",
        //                 "query_id": 47403349100,
        //                 "order_id": 1103683465337593856,
        //                 "contract_code": "BTC-USDT-230505",
        //                 "symbol": "BTC",
        //                 "lever_rate": 5,
        //                 "create_date": 1683180243577,
        //                 "order_source": "web",
        //                 "canceled_source": "web",
        //                 "order_price_type": 1,
        //                 "order_type": 1,
        //                 "margin_frozen": 0E-18,
        //                 "trade_volume": 0E-18,
        //                 "trade_turnover": 0E-18,
        //                 "fee": 0E-18,
        //                 "trade_avg_price": 0,
        //                 "status": 7,
        //                 "order_id_str": "1103683465337593856",
        //                 "fee_asset": "USDT",
        //                 "fee_amount": 0,
        //                 "fee_quote_amount": 0,
        //                 "liquidation_type": "0",
        //                 "margin_asset": "USDT",
        //                 "margin_mode": "cross",
        //                 "margin_account": "USDT",
        //                 "update_time": 1683180352034,
        //                 "is_tpsl": 0,
        //                 "real_profit": 0,
        //                 "trade_partition": "USDT",
        //                 "reduce_only": 0,
        //                 "contract_type": "this_week",
        //                 "business_type": "futures"
        //             }
        //         ],
        //         "ts": 1683239909141
        //     }
        //
        // trigger
        //
        //     {
        //         "status": "ok",
        //         "data": {
        //             "orders": [
        //                 {
        //                     "contract_type": "swap",
        //                     "business_type": "swap",
        //                     "pair": "BTC-USDT",
        //                     "symbol": "BTC",
        //                     "contract_code": "BTC-USDT",
        //                     "trigger_type": "le",
        //                     "volume": 1.000000000000000000,
        //                     "order_type": 1,
        //                     "direction": "buy",
        //                     "offset": "open",
        //                     "lever_rate": 1,
        //                     "order_id": 1103670703588327424,
        //                     "order_id_str": "1103670703588327424",
        //                     "relation_order_id": "-1",
        //                     "order_price_type": "limit",
        //                     "status": 6,
        //                     "order_source": "web",
        //                     "trigger_price": 25000.000000000000000000,
        //                     "triggered_price": null,
        //                     "order_price": 24000.000000000000000000,
        //                     "created_at": 1683177200945,
        //                     "triggered_at": null,
        //                     "order_insert_at": 0,
        //                     "canceled_at": 1683179075234,
        //                     "fail_code": null,
        //                     "fail_reason": null,
        //                     "margin_mode": "cross",
        //                     "margin_account": "USDT",
        //                     "update_time": 1683179075958,
        //                     "trade_partition": "USDT",
        //                     "reduce_only": 0
        //                 },
        //             ],
        //             "total_page": 1,
        //             "current_page": 1,
        //             "total_size": 2
        //         },
        //         "ts": 1683239702792
        //     }
        //
        // stop-loss and take-profit
        //
        //     {
        //         "status": "ok",
        //         "data": {
        //             "orders": [
        //                 {
        //                     "contract_type": "swap",
        //                     "business_type": "swap",
        //                     "pair": "BTC-USDT",
        //                     "symbol": "BTC",
        //                     "contract_code": "BTC-USDT",
        //                     "margin_mode": "cross",
        //                     "margin_account": "USDT",
        //                     "volume": 1.000000000000000000,
        //                     "order_type": 1,
        //                     "tpsl_order_type": "sl",
        //                     "direction": "sell",
        //                     "order_id": 1103680386844839936,
        //                     "order_id_str": "1103680386844839936",
        //                     "order_source": "web",
        //                     "trigger_type": "le",
        //                     "trigger_price": 25000.000000000000000000,
        //                     "created_at": 1683179509613,
        //                     "order_price_type": "market",
        //                     "status": 11,
        //                     "source_order_id": null,
        //                     "relation_tpsl_order_id": "-1",
        //                     "canceled_at": 0,
        //                     "fail_code": null,
        //                     "fail_reason": null,
        //                     "triggered_price": null,
        //                     "relation_order_id": "-1",
        //                     "update_time": 1683179968231,
        //                     "order_price": 0E-18,
        //                     "trade_partition": "USDT"
        //                 },
        //             ],
        //             "total_page": 1,
        //             "current_page": 1,
        //             "total_size": 2
        //         },
        //         "ts": 1683229230233
        //     }
        //
        object orders = this.safeValue(response, "data");
        if (!isTrue(((orders is IList<object>) || (orders.GetType().IsGenericType && orders.GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>))))))
        {
            orders = this.safeValue(orders, "orders", new List<object>() {});
        }
        return this.parseOrders(orders, market, since, limit);
    }

    public async virtual Task<object> fetchClosedContractOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object request = new Dictionary<string, object>() {
            { "status", "5,6,7" },
        };
        return await this.fetchContractOrders(symbol, since, limit, this.extend(request, parameters));
    }

    /**
     * @method
     * @name htx#fetchOrders
     * @see https://huobiapi.github.io/docs/spot/v1/en/#search-past-orders
     * @see https://huobiapi.github.io/docs/spot/v1/en/#search-historical-orders-within-48-hours
     * @see https://huobiapi.github.io/docs/usdt_swap/v1/en/#isolated-get-history-orders-new
     * @see https://huobiapi.github.io/docs/usdt_swap/v1/en/#cross-get-history-orders-new
     * @see https://huobiapi.github.io/docs/coin_margined_swap/v1/en/#get-history-orders-new
     * @see https://huobiapi.github.io/docs/coin_margined_swap/v1/en/#query-history-orders-via-multiple-fields-new
     * @description fetches information on multiple orders made by the user
     * @param {string} symbol unified market symbol of the market orders were made in
     * @param {int} [since] the earliest time in ms to fetch orders for
     * @param {int} [limit] the maximum number of order structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {bool} [params.trigger] *contract only* if the orders are trigger trigger orders or not
     * @param {bool} [params.stopLossTakeProfit] *contract only* if the orders are stop-loss or take-profit orders
     * @param {int} [params.until] the latest time in ms to fetch entries for
     * @param {boolean} [params.trailing] *contract only* set to true if you want to fetch trailing stop orders
     * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/?id=order-structure}
     */
    public async override Task<object> fetchOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
        }
        object marketType = null;
        var marketTypeparametersVariable = this.handleMarketTypeAndParams("fetchOrders", market, parameters);
        marketType = ((IList<object>)marketTypeparametersVariable)[0];
        parameters = ((IList<object>)marketTypeparametersVariable)[1];
        object contract = isTrue((isEqual(marketType, "swap"))) || isTrue((isEqual(marketType, "future")));
        if (isTrue(isTrue(contract) && isTrue((isEqual(symbol, null)))))
        {
            throw new ArgumentsRequired ((string)add(add(add(this.id, " fetchOrders() requires a symbol argument for "), marketType), " orders")) ;
        }
        if (isTrue(contract))
        {
            return await this.fetchContractOrders(symbol, since, limit, parameters);
        } else
        {
            return await this.fetchSpotOrders(symbol, since, limit, parameters);
        }
    }

    /**
     * @method
     * @name htx#fetchClosedOrders
     * @see https://huobiapi.github.io/docs/spot/v1/en/#search-past-orders
     * @see https://huobiapi.github.io/docs/spot/v1/en/#search-historical-orders-within-48-hours
     * @see https://huobiapi.github.io/docs/usdt_swap/v1/en/#isolated-get-history-orders-new
     * @see https://huobiapi.github.io/docs/usdt_swap/v1/en/#cross-get-history-orders-new
     * @see https://huobiapi.github.io/docs/coin_margined_swap/v1/en/#get-history-orders-new
     * @see https://huobiapi.github.io/docs/coin_margined_swap/v1/en/#query-history-orders-via-multiple-fields-new
     * @description fetches information on multiple closed orders made by the user
     * @param {string} symbol unified market symbol of the market orders were made in
     * @param {int} [since] the earliest time in ms to fetch orders for
     * @param {int} [limit] the maximum number of order structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {int} [params.until] the latest time in ms to fetch entries for
     * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [availble parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
     * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/?id=order-structure}
     */
    public async override Task<object> fetchClosedOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object paginate = false;
        var paginateparametersVariable = this.handleOptionAndParams(parameters, "fetchClosedOrders", "paginate");
        paginate = ((IList<object>)paginateparametersVariable)[0];
        parameters = ((IList<object>)paginateparametersVariable)[1];
        if (isTrue(paginate))
        {
            return await this.fetchPaginatedCallDynamic("fetchClosedOrders", symbol, since, limit, parameters, 100);
        }
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
        }
        object marketType = null;
        var marketTypeparametersVariable = this.handleMarketTypeAndParams("fetchClosedOrders", market, parameters);
        marketType = ((IList<object>)marketTypeparametersVariable)[0];
        parameters = ((IList<object>)marketTypeparametersVariable)[1];
        if (isTrue(isEqual(marketType, "spot")))
        {
            return await this.fetchClosedSpotOrders(symbol, since, limit, parameters);
        } else
        {
            return await this.fetchClosedContractOrders(symbol, since, limit, parameters);
        }
    }

    /**
     * @method
     * @name htx#fetchOpenOrders
     * @see https://huobiapi.github.io/docs/spot/v1/en/#get-all-open-orders
     * @see https://huobiapi.github.io/docs/usdt_swap/v1/en/#isolated-current-unfilled-order-acquisition
     * @see https://huobiapi.github.io/docs/usdt_swap/v1/en/#cross-current-unfilled-order-acquisition
     * @description fetch all unfilled currently open orders
     * @param {string} symbol unified market symbol
     * @param {int} [since] the earliest time in ms to fetch open orders for
     * @param {int} [limit] the maximum number of open order structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {bool} [params.trigger] *contract only* if the orders are trigger trigger orders or not
     * @param {bool} [params.stopLossTakeProfit] *contract only* if the orders are stop-loss or take-profit orders
     * @param {boolean} [params.trailing] *contract only* set to true if you want to fetch trailing stop orders
     * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/?id=order-structure}
     */
    public async override Task<object> fetchOpenOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
        }
        object request = new Dictionary<string, object>() {};
        object marketType = null;
        var marketTypeparametersVariable = this.handleMarketTypeAndParams("fetchOpenOrders", market, parameters);
        marketType = ((IList<object>)marketTypeparametersVariable)[0];
        parameters = ((IList<object>)marketTypeparametersVariable)[1];
        object subType = null;
        var subTypeparametersVariable = this.handleSubTypeAndParams("fetchOpenOrders", market, parameters, "linear");
        subType = ((IList<object>)subTypeparametersVariable)[0];
        parameters = ((IList<object>)subTypeparametersVariable)[1];
        object response = null;
        if (isTrue(isEqual(marketType, "spot")))
        {
            if (isTrue(!isEqual(symbol, null)))
            {
                ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
            }
            // todo replace with fetchAccountIdByType
            object accountId = this.safeString(parameters, "account-id");
            if (isTrue(isEqual(accountId, null)))
            {
                // pick the first account
                await this.loadAccounts();
                for (object i = 0; isLessThan(i, getArrayLength(this.accounts)); postFixIncrement(ref i))
                {
                    object account = getValue(this.accounts, i);
                    if (isTrue(isEqual(this.safeString(account, "type"), "spot")))
                    {
                        accountId = this.safeString(account, "id");
                        if (isTrue(!isEqual(accountId, null)))
                        {
                            break;
                        }
                    }
                }
            }
            ((IDictionary<string,object>)request)["account-id"] = accountId;
            if (isTrue(!isEqual(limit, null)))
            {
                ((IDictionary<string,object>)request)["size"] = limit;
            }
            parameters = this.omit(parameters, "account-id");
            response = await this.spotPrivateGetV1OrderOpenOrders(this.extend(request, parameters));
        } else
        {
            if (isTrue(!isEqual(symbol, null)))
            {
                // throw new ArgumentsRequired (this.id + ' fetchOpenOrders() requires a symbol argument');
                ((IDictionary<string,object>)request)["contract_code"] = getValue(market, "id");
            }
            if (isTrue(!isEqual(limit, null)))
            {
                ((IDictionary<string,object>)request)["page_size"] = limit;
            }
            object trigger = this.safeBool2(parameters, "stop", "trigger");
            object stopLossTakeProfit = this.safeValue(parameters, "stopLossTakeProfit");
            object trailing = this.safeBool(parameters, "trailing", false);
            parameters = this.omit(parameters, new List<object>() {"stop", "stopLossTakeProfit", "trailing", "trigger"});
            if (isTrue(isEqual(subType, "linear")))
            {
                object marginMode = null;
                var marginModeparametersVariable = this.handleMarginModeAndParams("fetchOpenOrders", parameters);
                marginMode = ((IList<object>)marginModeparametersVariable)[0];
                parameters = ((IList<object>)marginModeparametersVariable)[1];
                marginMode = ((bool) isTrue((isEqual(marginMode, null)))) ? "cross" : marginMode;
                if (isTrue(isEqual(marginMode, "isolated")))
                {
                    if (isTrue(trigger))
                    {
                        response = await this.contractPrivatePostLinearSwapApiV1SwapTriggerOpenorders(this.extend(request, parameters));
                    } else if (isTrue(stopLossTakeProfit))
                    {
                        response = await this.contractPrivatePostLinearSwapApiV1SwapTpslOpenorders(this.extend(request, parameters));
                    } else if (isTrue(trailing))
                    {
                        response = await this.contractPrivatePostLinearSwapApiV1SwapTrackOpenorders(this.extend(request, parameters));
                    } else
                    {
                        response = await this.contractPrivatePostLinearSwapApiV1SwapOpenorders(this.extend(request, parameters));
                    }
                } else if (isTrue(isEqual(marginMode, "cross")))
                {
                    if (isTrue(trigger))
                    {
                        response = await this.contractPrivatePostLinearSwapApiV1SwapCrossTriggerOpenorders(this.extend(request, parameters));
                    } else if (isTrue(stopLossTakeProfit))
                    {
                        response = await this.contractPrivatePostLinearSwapApiV1SwapCrossTpslOpenorders(this.extend(request, parameters));
                    } else if (isTrue(trailing))
                    {
                        response = await this.contractPrivatePostLinearSwapApiV1SwapCrossTrackOpenorders(this.extend(request, parameters));
                    } else
                    {
                        response = await this.contractPrivatePostLinearSwapApiV1SwapCrossOpenorders(this.extend(request, parameters));
                    }
                }
            } else if (isTrue(isEqual(subType, "inverse")))
            {
                if (isTrue(isEqual(marketType, "swap")))
                {
                    if (isTrue(trigger))
                    {
                        response = await this.contractPrivatePostSwapApiV1SwapTriggerOpenorders(this.extend(request, parameters));
                    } else if (isTrue(stopLossTakeProfit))
                    {
                        response = await this.contractPrivatePostSwapApiV1SwapTpslOpenorders(this.extend(request, parameters));
                    } else if (isTrue(trailing))
                    {
                        response = await this.contractPrivatePostSwapApiV1SwapTrackOpenorders(this.extend(request, parameters));
                    } else
                    {
                        response = await this.contractPrivatePostSwapApiV1SwapOpenorders(this.extend(request, parameters));
                    }
                } else if (isTrue(isEqual(marketType, "future")))
                {
                    ((IDictionary<string,object>)request)["symbol"] = this.safeString(market, "settleId", "usdt");
                    if (isTrue(trigger))
                    {
                        response = await this.contractPrivatePostApiV1ContractTriggerOpenorders(this.extend(request, parameters));
                    } else if (isTrue(stopLossTakeProfit))
                    {
                        response = await this.contractPrivatePostApiV1ContractTpslOpenorders(this.extend(request, parameters));
                    } else if (isTrue(trailing))
                    {
                        response = await this.contractPrivatePostApiV1ContractTrackOpenorders(this.extend(request, parameters));
                    } else
                    {
                        response = await this.contractPrivatePostApiV1ContractOpenorders(this.extend(request, parameters));
                    }
                }
            }
        }
        //
        // spot
        //
        //     {
        //         "status":"ok",
        //         "data":[
        //             {
        //                 "symbol":"ethusdt",
        //                 "source":"api",
        //                 "amount":"0.010000000000000000",
        //                 "account-id":1528640,
        //                 "created-at":1561597491963,
        //                 "price":"400.000000000000000000",
        //                 "filled-amount":"0.0",
        //                 "filled-cash-amount":"0.0",
        //                 "filled-fees":"0.0",
        //                 "id":38477101630,
        //                 "state":"submitted",
        //                 "type":"sell-limit"
        //             }
        //         ]
        //     }
        //
        // futures
        //
        //     {
        //         "status": "ok",
        //         "data": {
        //             "orders": [
        //                 {
        //                     "symbol": "ADA",
        //                     "contract_code": "ADA201225",
        //                     "contract_type": "quarter",
        //                     "volume": 1,
        //                     "price": 0.0925,
        //                     "order_price_type": "post_only",
        //                     "order_type": 1,
        //                     "direction": "buy",
        //                     "offset": "close",
        //                     "lever_rate": 20,
        //                     "order_id": 773131315209248768,
        //                     "client_order_id": null,
        //                     "created_at": 1604370469629,
        //                     "trade_volume": 0,
        //                     "trade_turnover": 0,
        //                     "fee": 0,
        //                     "trade_avg_price": null,
        //                     "margin_frozen": 0,
        //                     "profit": 0,
        //                     "status": 3,
        //                     "order_source": "web",
        //                     "order_id_str": "773131315209248768",
        //                     "fee_asset": "ADA",
        //                     "liquidation_type": null,
        //                     "canceled_at": null,
        //                     "is_tpsl": 0,
        //                     "update_time": 1606975980467,
        //                     "real_profit": 0
        //                 }
        //             ],
        //             "total_page": 1,
        //             "current_page": 1,
        //             "total_size": 1
        //         },
        //         "ts": 1604370488518
        //     }
        //
        // trigger
        //
        //     {
        //         "status": "ok",
        //         "data": {
        //             "orders": [
        //                 {
        //                     "contract_type": "swap",
        //                     "business_type": "swap",
        //                     "pair": "BTC-USDT",
        //                     "symbol": "BTC",
        //                     "contract_code": "BTC-USDT",
        //                     "trigger_type": "le",
        //                     "volume": 1.000000000000000000,
        //                     "order_type": 1,
        //                     "direction": "buy",
        //                     "offset": "open",
        //                     "lever_rate": 1,
        //                     "order_id": 1103670703588327424,
        //                     "order_id_str": "1103670703588327424",
        //                     "order_source": "web",
        //                     "trigger_price": 25000.000000000000000000,
        //                     "order_price": 24000.000000000000000000,
        //                     "created_at": 1683177200945,
        //                     "order_price_type": "limit",
        //                     "status": 2,
        //                     "margin_mode": "cross",
        //                     "margin_account": "USDT",
        //                     "trade_partition": "USDT",
        //                     "reduce_only": 0
        //                 }
        //             ],
        //             "total_page": 1,
        //             "current_page": 1,
        //             "total_size": 1
        //         },
        //         "ts": 1683177805320
        //     }
        //
        // stop-loss and take-profit
        //
        //     {
        //         "status": "ok",
        //         "data": {
        //             "orders": [
        //                 {
        //                     "contract_type": "swap",
        //                     "business_type": "swap",
        //                     "pair": "BTC-USDT",
        //                     "symbol": "BTC",
        //                     "contract_code": "BTC-USDT",
        //                     "margin_mode": "cross",
        //                     "margin_account": "USDT",
        //                     "volume": 1.000000000000000000,
        //                     "order_type": 1,
        //                     "direction": "sell",
        //                     "order_id": 1103680386844839936,
        //                     "order_id_str": "1103680386844839936",
        //                     "order_source": "web",
        //                     "trigger_type": "le",
        //                     "trigger_price": 25000.000000000000000000,
        //                     "order_price": 0E-18,
        //                     "created_at": 1683179509613,
        //                     "order_price_type": "market",
        //                     "status": 2,
        //                     "tpsl_order_type": "sl",
        //                     "source_order_id": null,
        //                     "relation_tpsl_order_id": "-1",
        //                     "trade_partition": "USDT"
        //                 }
        //             ],
        //             "total_page": 1,
        //             "current_page": 1,
        //             "total_size": 1
        //         },
        //         "ts": 1683179527011
        //     }
        //
        // trailing
        //
        //     {
        //         "status": "ok",
        //         "data": {
        //             "orders": [
        //                 {
        //                     "contract_type": "swap",
        //                     "business_type": "swap",
        //                     "pair": "BTC-USDT",
        //                     "symbol": "BTC",
        //                     "contract_code": "BTC-USDT",
        //                     "volume": 1.000000000000000000,
        //                     "order_type": 1,
        //                     "direction": "sell",
        //                     "offset": "close",
        //                     "lever_rate": 1,
        //                     "order_id": 1192021437253877761,
        //                     "order_id_str": "1192021437253877761",
        //                     "order_source": "api",
        //                     "created_at": 1704241657328,
        //                     "order_price_type": "formula_price",
        //                     "status": 2,
        //                     "callback_rate": 0.050000000000000000,
        //                     "active_price": 50000.000000000000000000,
        //                     "is_active": 0,
        //                     "margin_mode": "cross",
        //                     "margin_account": "USDT",
        //                     "trade_partition": "USDT",
        //                     "reduce_only": 1
        //                 },
        //             ],
        //             "total_page": 1,
        //             "current_page": 1,
        //             "total_size": 2
        //         },
        //         "ts": 1704242440106
        //     }
        //
        object orders = this.safeValue(response, "data");
        if (!isTrue(((orders is IList<object>) || (orders.GetType().IsGenericType && orders.GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>))))))
        {
            orders = this.safeValue(orders, "orders", new List<object>() {});
        }
        return this.parseOrders(orders, market, since, limit);
    }

    public virtual object parseOrderStatus(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "partial-filled", "open" },
            { "partial-canceled", "canceled" },
            { "filled", "closed" },
            { "canceled", "canceled" },
            { "submitted", "open" },
            { "created", "open" },
            { "1", "open" },
            { "2", "open" },
            { "3", "open" },
            { "4", "open" },
            { "5", "canceled" },
            { "6", "closed" },
            { "7", "canceled" },
            { "11", "canceling" },
        };
        return this.safeString(statuses, status, status);
    }

    public override object parseOrder(object order, object market = null)
    {
        //
        // spot
        //
        //     {
        //         "id":  13997833014,
        //         "symbol": "ethbtc",
        //         "account-id":  3398321,
        //         "amount": "0.045000000000000000",
        //         "price": "0.034014000000000000",
        //         "created-at":  1545836976871,
        //         "type": "sell-limit",
        //         "field-amount": "0.045000000000000000", // they have fixed it for filled-amount
        //         "field-cash-amount": "0.001530630000000000", // they have fixed it for filled-cash-amount
        //         "field-fees": "0.000003061260000000", // they have fixed it for filled-fees
        //         "finished-at":  1545837948214,
        //         "source": "spot-api",
        //         "state": "filled",
        //         "canceled-at":  0
        //     }
        //
        //     {
        //         "id":  20395337822,
        //         "symbol": "ethbtc",
        //         "account-id":  5685075,
        //         "amount": "0.001000000000000000",
        //         "price": "0.0",
        //         "created-at":  1545831584023,
        //         "type": "buy-market",
        //         "field-amount": "0.029100000000000000", // they have fixed it for filled-amount
        //         "field-cash-amount": "0.000999788700000000", // they have fixed it for filled-cash-amount
        //         "field-fees": "0.000058200000000000", // they have fixed it for filled-fees
        //         "finished-at":  1545831584181,
        //         "source": "spot-api",
        //         "state": "filled",
        //         "canceled-at":  0
        //     }
        //
        // linear swap cross margin createOrder
        //
        //     {
        //         "order_id":924660854912552960,
        //         "order_id_str":"924660854912552960"
        //     }
        //
        // contracts fetchOrder
        //
        //     {
        //         "business_type":"swap",
        //         "contract_type":"swap",
        //         "pair":"BTC-USDT",
        //         "symbol":"BTC",
        //         "contract_code":"BTC-USDT",
        //         "volume":1,
        //         "price":3000,
        //         "order_price_type":"limit",
        //         "order_type":1,
        //         "direction":"buy",
        //         "offset":"open",
        //         "lever_rate":1,
        //         "order_id":924912513206878210,
        //         "client_order_id":null,
        //         "created_at":1640557927189,
        //         "trade_volume":0,
        //         "trade_turnover":0,
        //         "fee":0,
        //         "trade_avg_price":null,
        //         "margin_frozen":3.000000000000000000,
        //         "profit":0,
        //         "status":3,
        //         "order_source":"api",
        //         "order_id_str":"924912513206878210",
        //         "fee_asset":"USDT",
        //         "liquidation_type":"0",
        //         "canceled_at":0,
        //         "margin_asset":"USDT",
        //         "margin_account":"USDT",
        //         "margin_mode":"cross",
        //         "is_tpsl":0,
        //         "real_profit":0
        //     }
        //
        // contracts fetchOrder detailed
        //
        //     {
        //         "symbol": "BTC",
        //         "contract_code": "BTC-USDT",
        //         "instrument_price": 0,
        //         "final_interest": 0,
        //         "adjust_value": 0,
        //         "lever_rate": 10,
        //         "direction": "sell",
        //         "offset": "open",
        //         "volume": 1.000000000000000000,
        //         "price": 13059.800000000000000000,
        //         "created_at": 1603703614712,
        //         "canceled_at": 0,
        //         "order_source": "api",
        //         "order_price_type": "opponent",
        //         "margin_frozen": 0,
        //         "profit": 0,
        //         "trades": [
        //             {
        //                 "trade_id": 131560927,
        //                 "trade_price": 13059.800000000000000000,
        //                 "trade_volume": 1.000000000000000000,
        //                 "trade_turnover": 13.059800000000000000,
        //                 "trade_fee": -0.005223920000000000,
        //                 "created_at": 1603703614715,
        //                 "role": "taker",
        //                 "fee_asset": "USDT",
        //                 "profit": 0,
        //                 "real_profit": 0,
        //                 "id": "131560927-770334322963152896-1"
        //             }
        //         ],
        //         "total_page": 1,
        //         "current_page": 1,
        //         "total_size": 1,
        //         "liquidation_type": "0",
        //         "fee_asset": "USDT",
        //         "fee": -0.005223920000000000,
        //         "order_id": 770334322963152896,
        //         "order_id_str": "770334322963152896",
        //         "client_order_id": 57012021045,
        //         "order_type": "1",
        //         "status": 6,
        //         "trade_avg_price": 13059.800000000000000000,
        //         "trade_turnover": 13.059800000000000000,
        //         "trade_volume": 1.000000000000000000,
        //         "margin_asset": "USDT",
        //         "margin_mode": "isolated",
        //         "margin_account": "BTC-USDT",
        //         "real_profit": 0,
        //         "is_tpsl": 0
        //     }
        //
        // future and swap: fetchOrders
        //
        //     {
        //         "order_id": 773131315209248768,
        //         "contract_code": "ADA201225",
        //         "symbol": "ADA",
        //         "lever_rate": 20,
        //         "direction": "buy",
        //         "offset": "close",
        //         "volume": 1,
        //         "price": 0.0925,
        //         "create_date": 1604370469629,
        //         "update_time": 1603704221118,
        //         "order_source": "web",
        //         "order_price_type": 6,
        //         "order_type": 1,
        //         "margin_frozen": 0,
        //         "profit": 0,
        //         "contract_type": "quarter",
        //         "trade_volume": 0,
        //         "trade_turnover": 0,
        //         "fee": 0,
        //         "trade_avg_price": 0,
        //         "status": 3,
        //         "order_id_str": "773131315209248768",
        //         "fee_asset": "ADA",
        //         "liquidation_type": "0",
        //         "is_tpsl": 0,
        //         "real_profit": 0
        //         "margin_asset": "USDT",
        //         "margin_mode": "cross",
        //         "margin_account": "USDT",
        //         "trade_partition": "USDT", // only in isolated & cross of linear
        //         "reduce_only": "1", // only in isolated & cross of linear
        //         "contract_type": "quarter", // only in cross-margin (inverse & linear)
        //         "pair": "BTC-USDT", // only in cross-margin (inverse & linear)
        //         "business_type": "futures" // only in cross-margin (inverse & linear)
        //     }
        //
        // trigger: fetchOpenOrders
        //
        //     {
        //         "contract_type": "swap",
        //         "business_type": "swap",
        //         "pair": "BTC-USDT",
        //         "symbol": "BTC",
        //         "contract_code": "BTC-USDT",
        //         "trigger_type": "le",
        //         "volume": 1.000000000000000000,
        //         "order_type": 1,
        //         "direction": "buy",
        //         "offset": "open",
        //         "lever_rate": 1,
        //         "order_id": 1103670703588327424,
        //         "order_id_str": "1103670703588327424",
        //         "order_source": "web",
        //         "trigger_price": 25000.000000000000000000,
        //         "order_price": 24000.000000000000000000,
        //         "created_at": 1683177200945,
        //         "order_price_type": "limit",
        //         "status": 2,
        //         "margin_mode": "cross",
        //         "margin_account": "USDT",
        //         "trade_partition": "USDT",
        //         "reduce_only": 0
        //     }
        //
        // stop-loss and take-profit: fetchOpenOrders
        //
        //     {
        //         "contract_type": "swap",
        //         "business_type": "swap",
        //         "pair": "BTC-USDT",
        //         "symbol": "BTC",
        //         "contract_code": "BTC-USDT",
        //         "margin_mode": "cross",
        //         "margin_account": "USDT",
        //         "volume": 1.000000000000000000,
        //         "order_type": 1,
        //         "direction": "sell",
        //         "order_id": 1103680386844839936,
        //         "order_id_str": "1103680386844839936",
        //         "order_source": "web",
        //         "trigger_type": "le",
        //         "trigger_price": 25000.000000000000000000,
        //         "order_price": 0E-18,
        //         "created_at": 1683179509613,
        //         "order_price_type": "market",
        //         "status": 2,
        //         "tpsl_order_type": "sl",
        //         "source_order_id": null,
        //         "relation_tpsl_order_id": "-1",
        //         "trade_partition": "USDT"
        //     }
        //
        // trailing: fetchOpenOrders
        //
        //     {
        //         "contract_type": "swap",
        //         "business_type": "swap",
        //         "pair": "BTC-USDT",
        //         "symbol": "BTC",
        //         "contract_code": "BTC-USDT",
        //         "volume": 1.000000000000000000,
        //         "order_type": 1,
        //         "direction": "sell",
        //         "offset": "close",
        //         "lever_rate": 1,
        //         "order_id": 1192021437253877761,
        //         "order_id_str": "1192021437253877761",
        //         "order_source": "api",
        //         "created_at": 1704241657328,
        //         "order_price_type": "formula_price",
        //         "status": 2,
        //         "callback_rate": 0.050000000000000000,
        //         "active_price": 50000.000000000000000000,
        //         "is_active": 0,
        //         "margin_mode": "cross",
        //         "margin_account": "USDT",
        //         "trade_partition": "USDT",
        //         "reduce_only": 1
        //     }
        //
        // trigger: fetchOrders
        //
        //     {
        //         "contract_type": "swap",
        //         "business_type": "swap",
        //         "pair": "BTC-USDT",
        //         "symbol": "BTC",
        //         "contract_code": "BTC-USDT",
        //         "trigger_type": "le",
        //         "volume": 1.000000000000000000,
        //         "order_type": 1,
        //         "direction": "buy",
        //         "offset": "open",
        //         "lever_rate": 1,
        //         "order_id": 1103670703588327424,
        //         "order_id_str": "1103670703588327424",
        //         "relation_order_id": "-1",
        //         "order_price_type": "limit",
        //         "status": 6,
        //         "order_source": "web",
        //         "trigger_price": 25000.000000000000000000,
        //         "triggered_price": null,
        //         "order_price": 24000.000000000000000000,
        //         "created_at": 1683177200945,
        //         "triggered_at": null,
        //         "order_insert_at": 0,
        //         "canceled_at": 1683179075234,
        //         "fail_code": null,
        //         "fail_reason": null,
        //         "margin_mode": "cross",
        //         "margin_account": "USDT",
        //         "update_time": 1683179075958,
        //         "trade_partition": "USDT",
        //         "reduce_only": 0
        //     }
        //
        // stop-loss and take-profit: fetchOrders
        //
        //     {
        //         "contract_type": "swap",
        //         "business_type": "swap",
        //         "pair": "BTC-USDT",
        //         "symbol": "BTC",
        //         "contract_code": "BTC-USDT",
        //         "margin_mode": "cross",
        //         "margin_account": "USDT",
        //         "volume": 1.000000000000000000,
        //         "order_type": 1,
        //         "tpsl_order_type": "sl",
        //         "direction": "sell",
        //         "order_id": 1103680386844839936,
        //         "order_id_str": "1103680386844839936",
        //         "order_source": "web",
        //         "trigger_type": "le",
        //         "trigger_price": 25000.000000000000000000,
        //         "created_at": 1683179509613,
        //         "order_price_type": "market",
        //         "status": 11,
        //         "source_order_id": null,
        //         "relation_tpsl_order_id": "-1",
        //         "canceled_at": 0,
        //         "fail_code": null,
        //         "fail_reason": null,
        //         "triggered_price": null,
        //         "relation_order_id": "-1",
        //         "update_time": 1683179968231,
        //         "order_price": 0E-18,
        //         "trade_partition": "USDT"
        //     }
        //
        // spot: createOrders
        //
        //     [
        //         {
        //             "order-id": 936847569789079,
        //             "client-order-id": "AA03022abc3a55e82c-0087-4fc2-beac-112fdebb1ee9"
        //         },
        //         {
        //             "client-order-id": "AA03022abcdb3baefb-3cfa-4891-8009-082b3d46ca82",
        //             "err-code": "account-frozen-balance-insufficient-error",
        //             "err-msg": "trade account balance is not enough, left: `89`"
        //         }
        //     ]
        //
        // swap and future: createOrders
        //
        //     [
        //         {
        //             "index": 2,
        //             "err_code": 1047,
        //             "err_msg": "Insufficient margin available."
        //         },
        //         {
        //             "order_id": 1172923090632953857,
        //             "index": 1,
        //             "order_id_str": "1172923090632953857"
        //         }
        //     ]
        //
        object rejectedCreateOrders = this.safeString2(order, "err_code", "err-code");
        object status = this.parseOrderStatus(this.safeString2(order, "state", "status"));
        if (isTrue(!isEqual(rejectedCreateOrders, null)))
        {
            status = "rejected";
        }
        object id = this.safeStringN(order, new List<object>() {"id", "order_id_str", "order-id"});
        object side = this.safeString(order, "direction");
        object type = this.safeString(order, "order_price_type");
        if (isTrue(inOp(order, "type")))
        {
            object orderType = ((string)getValue(order, "type")).Split(new [] {((string)"-")}, StringSplitOptions.None).ToList<object>();
            side = getValue(orderType, 0);
            type = getValue(orderType, 1);
        }
        object marketId = this.safeString2(order, "contract_code", "symbol");
        market = this.safeMarket(marketId, market);
        object timestamp = this.safeIntegerN(order, new List<object>() {"created_at", "created-at", "create_date"});
        object clientOrderId = this.safeString2(order, "client_order_id", add("client-or", "der-id")); // transpiler regex trick for php issue
        object cost = null;
        object amount = null;
        if (isTrue(isTrue((!isEqual(type, null))) && isTrue((isGreaterThanOrEqual(getIndexOf(type, "market"), 0)))))
        {
            cost = this.safeString(order, "field-cash-amount");
        } else
        {
            amount = this.safeString2(order, "volume", "amount");
            cost = this.safeStringN(order, new List<object>() {"filled-cash-amount", "field-cash-amount", "trade_turnover"}); // same typo here
        }
        object filled = this.safeStringN(order, new List<object>() {"filled-amount", "field-amount", "trade_volume"}); // typo in their API, filled amount
        object price = this.safeString2(order, "price", "order_price");
        object feeCost = this.safeString2(order, "filled-fees", "field-fees"); // typo in their API, filled feeSide
        feeCost = this.safeString(order, "fee", feeCost);
        object fee = null;
        if (isTrue(!isEqual(feeCost, null)))
        {
            object feeCurrency = null;
            object feeCurrencyId = this.safeString(order, "fee_asset");
            if (isTrue(!isEqual(feeCurrencyId, null)))
            {
                feeCurrency = this.safeCurrencyCode(feeCurrencyId);
            } else
            {
                feeCurrency = ((bool) isTrue((isEqual(side, "sell")))) ? getValue(market, "quote") : getValue(market, "base");
            }
            fee = new Dictionary<string, object>() {
                { "cost", feeCost },
                { "currency", feeCurrency },
            };
        }
        object average = this.safeString(order, "trade_avg_price");
        object trades = this.safeValue(order, "trades");
        object reduceOnlyInteger = this.safeInteger(order, "reduce_only");
        object reduceOnly = null;
        if (isTrue(!isEqual(reduceOnlyInteger, null)))
        {
            reduceOnly = ((bool) isTrue((isEqual(reduceOnlyInteger, 0)))) ? false : true;
        }
        return this.safeOrder(new Dictionary<string, object>() {
            { "info", order },
            { "id", id },
            { "clientOrderId", clientOrderId },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "lastTradeTimestamp", null },
            { "symbol", getValue(market, "symbol") },
            { "type", type },
            { "timeInForce", null },
            { "postOnly", null },
            { "side", side },
            { "price", price },
            { "triggerPrice", this.safeString2(order, "stop-price", "trigger_price") },
            { "average", average },
            { "cost", cost },
            { "amount", amount },
            { "filled", filled },
            { "remaining", null },
            { "status", status },
            { "reduceOnly", reduceOnly },
            { "fee", fee },
            { "trades", trades },
        }, market);
    }

    /**
     * @method
     * @name htx#createMarketBuyOrderWithCost
     * @description create a market buy order by providing the symbol and cost
     * @see https://www.htx.com/en-us/opend/newApiPages/?id=7ec4ee16-7773-11ed-9966-0242ac110003
     * @param {string} symbol unified symbol of the market to create an order in
     * @param {float} cost how much you want to trade in units of the quote currency
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} an [order structure]{@link https://docs.ccxt.com/?id=order-structure}
     */
    public async override Task<object> createMarketBuyOrderWithCost(object symbol, object cost, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        if (!isTrue(getValue(market, "spot")))
        {
            throw new NotSupported ((string)add(this.id, " createMarketBuyOrderWithCost() supports spot orders only")) ;
        }
        ((IDictionary<string,object>)parameters)["createMarketBuyOrderRequiresPrice"] = false;
        return await this.createOrder(symbol, "market", "buy", cost, null, parameters);
    }

    /**
     * @method
     * @name htx#createTrailingPercentOrder
     * @description create a trailing order by providing the symbol, type, side, amount, price and trailingPercent
     * @param {string} symbol unified symbol of the market to create an order in
     * @param {string} type 'market' or 'limit'
     * @param {string} side 'buy' or 'sell'
     * @param {float} amount how much you want to trade in units of the base currency, or number of contracts
     * @param {float} [price] the price for the order to be filled at, in units of the quote currency, ignored in market orders
     * @param {float} trailingPercent the percent to trail away from the current market price
     * @param {float} trailingTriggerPrice the price to activate a trailing order, default uses the price argument
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} an [order structure]{@link https://docs.ccxt.com/?id=order-structure}
     */
    public async override Task<object> createTrailingPercentOrder(object symbol, object type, object side, object amount, object price = null, object trailingPercent = null, object trailingTriggerPrice = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(trailingPercent, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " createTrailingPercentOrder() requires a trailingPercent argument")) ;
        }
        if (isTrue(isEqual(trailingTriggerPrice, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " createTrailingPercentOrder() requires a trailingTriggerPrice argument")) ;
        }
        ((IDictionary<string,object>)parameters)["trailingPercent"] = trailingPercent;
        ((IDictionary<string,object>)parameters)["trailingTriggerPrice"] = trailingTriggerPrice;
        return await this.createOrder(symbol, type, side, amount, price, parameters);
    }

    /**
     * @method
     * @ignore
     * @name htx#createSpotOrderRequest
     * @description helper function to build request
     * @param {string} symbol unified symbol of the market to create an order in
     * @param {string} type 'market' or 'limit'
     * @param {string} side 'buy' or 'sell'
     * @param {float} amount how much you want to trade in units of the base currency
     * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.timeInForce] supports 'IOC' and 'FOK'
     * @param {float} [params.cost] the quote quantity that can be used as an alternative for the amount for market buy orders
     * @returns {object} request to be sent to the exchange
     */
    public async virtual Task<object> createSpotOrderRequest(object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        await this.loadAccounts();
        object market = this.market(symbol);
        object marginMode = null;
        var marginModeparametersVariable = this.handleMarginModeAndParams("createOrder", parameters);
        marginMode = ((IList<object>)marginModeparametersVariable)[0];
        parameters = ((IList<object>)marginModeparametersVariable)[1];
        object accountId = await this.fetchAccountIdByType(getValue(market, "type"), marginMode, symbol);
        object request = new Dictionary<string, object>() {
            { "account-id", accountId },
            { "symbol", getValue(market, "id") },
        };
        object orderType = ((string)type).Replace((string)"buy-", (string)"");
        orderType = ((string)orderType).Replace((string)"sell-", (string)"");
        object options = this.safeValue(this.options, getValue(market, "type"), new Dictionary<string, object>() {});
        object triggerPrice = this.safeStringN(parameters, new List<object>() {"triggerPrice", "stopPrice", "stop-price"});
        if (isTrue(isEqual(triggerPrice, null)))
        {
            object stopOrderTypes = this.safeValue(options, "stopOrderTypes", new Dictionary<string, object>() {});
            if (isTrue(inOp(stopOrderTypes, orderType)))
            {
                throw new ArgumentsRequired ((string)add(this.id, " createOrder() requires a triggerPrice for a trigger order")) ;
            }
        } else
        {
            object defaultOperator = ((bool) isTrue((isEqual(side, "sell")))) ? "lte" : "gte";
            object stopOperator = this.safeString(parameters, "operator", defaultOperator);
            ((IDictionary<string,object>)request)["stop-price"] = this.priceToPrecision(symbol, triggerPrice);
            ((IDictionary<string,object>)request)["operator"] = stopOperator;
            if (isTrue(isTrue((isEqual(orderType, "limit"))) || isTrue((isEqual(orderType, "limit-fok")))))
            {
                orderType = add("stop-", orderType);
            } else if (isTrue(isTrue((!isEqual(orderType, "stop-limit"))) && isTrue((!isEqual(orderType, "stop-limit-fok")))))
            {
                throw new NotSupported ((string)add(add(add(this.id, " createOrder() does not support "), type), " orders")) ;
            }
        }
        object postOnly = null;
        var postOnlyparametersVariable = this.handlePostOnly(isEqual(orderType, "market"), isEqual(orderType, "limit-maker"), parameters);
        postOnly = ((IList<object>)postOnlyparametersVariable)[0];
        parameters = ((IList<object>)postOnlyparametersVariable)[1];
        if (isTrue(postOnly))
        {
            orderType = "limit-maker";
        }
        object timeInForce = this.safeString(parameters, "timeInForce", "GTC");
        if (isTrue(isEqual(timeInForce, "FOK")))
        {
            orderType = add(orderType, "-fok");
        } else if (isTrue(isEqual(timeInForce, "IOC")))
        {
            orderType = "ioc";
        }
        ((IDictionary<string,object>)request)["type"] = add(add(side, "-"), orderType);
        object clientOrderId = this.safeString2(parameters, "clientOrderId", "client-order-id"); // must be 64 chars max and unique within 24 hours
        if (isTrue(isEqual(clientOrderId, null)))
        {
            object broker = this.safeValue(this.options, "broker", new Dictionary<string, object>() {});
            object brokerId = this.safeString(broker, "id");
            ((IDictionary<string,object>)request)["client-order-id"] = add(brokerId, this.uuid());
        } else
        {
            ((IDictionary<string,object>)request)["client-order-id"] = clientOrderId;
        }
        if (isTrue(isEqual(marginMode, "cross")))
        {
            ((IDictionary<string,object>)request)["source"] = "super-margin-api";
        } else if (isTrue(isEqual(marginMode, "isolated")))
        {
            ((IDictionary<string,object>)request)["source"] = "margin-api";
        } else if (isTrue(isEqual(marginMode, "c2c")))
        {
            ((IDictionary<string,object>)request)["source"] = "c2c-margin-api";
        }
        if (isTrue(isTrue((isEqual(orderType, "market"))) && isTrue((isEqual(side, "buy")))))
        {
            object quoteAmount = null;
            object createMarketBuyOrderRequiresPrice = true;
            var createMarketBuyOrderRequiresPriceparametersVariable = this.handleOptionAndParams(parameters, "createOrder", "createMarketBuyOrderRequiresPrice", true);
            createMarketBuyOrderRequiresPrice = ((IList<object>)createMarketBuyOrderRequiresPriceparametersVariable)[0];
            parameters = ((IList<object>)createMarketBuyOrderRequiresPriceparametersVariable)[1];
            object cost = this.safeNumber(parameters, "cost");
            parameters = this.omit(parameters, "cost");
            if (isTrue(!isEqual(cost, null)))
            {
                quoteAmount = this.amountToPrecision(symbol, cost);
            } else if (isTrue(createMarketBuyOrderRequiresPrice))
            {
                if (isTrue(isEqual(price, null)))
                {
                    throw new InvalidOrder ((string)add(this.id, " createOrder() requires the price argument for market buy orders to calculate the total cost to spend (amount * price), alternatively set the createMarketBuyOrderRequiresPrice option or param to false and pass the cost to spend in the amount argument")) ;
                } else
                {
                    // despite that cost = amount * price is in quote currency and should have quote precision
                    // the exchange API requires the cost supplied in 'amount' to be of base precision
                    // more about it here:
                    // https://github.com/ccxt/ccxt/pull/4395
                    // https://github.com/ccxt/ccxt/issues/7611
                    // we use amountToPrecision here because the exchange requires cost in base precision
                    object amountString = this.numberToString(amount);
                    object priceString = this.numberToString(price);
                    quoteAmount = this.amountToPrecision(symbol, Precise.stringMul(amountString, priceString));
                }
            } else
            {
                quoteAmount = this.amountToPrecision(symbol, amount);
            }
            ((IDictionary<string,object>)request)["amount"] = quoteAmount;
        } else
        {
            ((IDictionary<string,object>)request)["amount"] = this.amountToPrecision(symbol, amount);
        }
        object limitOrderTypes = this.safeValue(options, "limitOrderTypes", new Dictionary<string, object>() {});
        if (isTrue(inOp(limitOrderTypes, orderType)))
        {
            ((IDictionary<string,object>)request)["price"] = this.priceToPrecision(symbol, price);
        }
        parameters = this.omit(parameters, new List<object>() {"triggerPrice", "stopPrice", "stop-price", "clientOrderId", "client-order-id", "operator", "timeInForce"});
        return this.extend(request, parameters);
    }

    public virtual object createContractOrderRequest(object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        /**
        * @method
        * @ignore
        * @name htx#createContractOrderRequest
        * @description helper function to build request
        * @param {string} symbol unified symbol of the market to create an order in
        * @param {string} type 'market' or 'limit'
        * @param {string} side 'buy' or 'sell'
        * @param {float} amount how much you want to trade in units of the base currency
        * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {string} [params.timeInForce] supports 'IOC' and 'FOK'
        * @param {float} [params.trailingPercent] *contract only* the percent to trail away from the current market price
        * @param {float} [params.trailingTriggerPrice] *contract only* the price to trigger a trailing order, default uses the price argument
        * @returns {object} request to be sent to the exchange
        */
        parameters ??= new Dictionary<string, object>();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "contract_code", getValue(market, "id") },
            { "volume", this.amountToPrecision(symbol, amount) },
            { "direction", side },
        };
        object postOnly = null;
        var postOnlyparametersVariable = this.handlePostOnly(isEqual(type, "market"), isEqual(type, "post_only"), parameters);
        postOnly = ((IList<object>)postOnlyparametersVariable)[0];
        parameters = ((IList<object>)postOnlyparametersVariable)[1];
        if (isTrue(postOnly))
        {
            type = "post_only";
        }
        object timeInForce = this.safeString(parameters, "timeInForce", "GTC");
        if (isTrue(isEqual(timeInForce, "FOK")))
        {
            type = "fok";
        } else if (isTrue(isEqual(timeInForce, "IOC")))
        {
            type = "ioc";
        }
        object triggerPrice = this.safeNumberN(parameters, new List<object>() {"triggerPrice", "stopPrice", "trigger_price"});
        object stopLossTriggerPrice = this.safeNumber2(parameters, "stopLossPrice", "sl_trigger_price");
        object takeProfitTriggerPrice = this.safeNumber2(parameters, "takeProfitPrice", "tp_trigger_price");
        object trailingPercent = this.safeString2(parameters, "trailingPercent", "callback_rate");
        object trailingTriggerPrice = this.safeNumber(parameters, "trailingTriggerPrice", price);
        object isTrailingPercentOrder = !isEqual(trailingPercent, null);
        object isTrigger = !isEqual(triggerPrice, null);
        object isStopLossTriggerOrder = !isEqual(stopLossTriggerPrice, null);
        object isTakeProfitTriggerOrder = !isEqual(takeProfitTriggerPrice, null);
        if (isTrue(isTrigger))
        {
            object triggerType = this.safeString2(parameters, "triggerType", "trigger_type", "le");
            ((IDictionary<string,object>)request)["trigger_type"] = triggerType;
            ((IDictionary<string,object>)request)["trigger_price"] = this.priceToPrecision(symbol, triggerPrice);
            if (isTrue(!isEqual(price, null)))
            {
                ((IDictionary<string,object>)request)["order_price"] = this.priceToPrecision(symbol, price);
            }
        } else if (isTrue(isTrue(isStopLossTriggerOrder) || isTrue(isTakeProfitTriggerOrder)))
        {
            if (isTrue(isStopLossTriggerOrder))
            {
                ((IDictionary<string,object>)request)["sl_order_price_type"] = type;
                ((IDictionary<string,object>)request)["sl_trigger_price"] = this.priceToPrecision(symbol, stopLossTriggerPrice);
                if (isTrue(!isEqual(price, null)))
                {
                    ((IDictionary<string,object>)request)["sl_order_price"] = this.priceToPrecision(symbol, price);
                }
            } else
            {
                ((IDictionary<string,object>)request)["tp_order_price_type"] = type;
                ((IDictionary<string,object>)request)["tp_trigger_price"] = this.priceToPrecision(symbol, takeProfitTriggerPrice);
                if (isTrue(!isEqual(price, null)))
                {
                    ((IDictionary<string,object>)request)["tp_order_price"] = this.priceToPrecision(symbol, price);
                }
            }
        } else if (isTrue(isTrailingPercentOrder))
        {
            object trailingPercentString = Precise.stringDiv(trailingPercent, "100");
            ((IDictionary<string,object>)request)["callback_rate"] = this.parseToNumeric(trailingPercentString);
            ((IDictionary<string,object>)request)["active_price"] = trailingTriggerPrice;
            ((IDictionary<string,object>)request)["order_price_type"] = this.safeString(parameters, "order_price_type", "formula_price");
        } else
        {
            object clientOrderId = this.safeInteger2(parameters, "client_order_id", "clientOrderId");
            if (isTrue(!isEqual(clientOrderId, null)))
            {
                ((IDictionary<string,object>)request)["client_order_id"] = clientOrderId;
                parameters = this.omit(parameters, new List<object>() {"clientOrderId"});
            }
            if (isTrue(isTrue(isTrue(isTrue(isEqual(type, "limit")) || isTrue(isEqual(type, "ioc"))) || isTrue(isEqual(type, "fok"))) || isTrue(isEqual(type, "post_only"))))
            {
                if (isTrue(!isEqual(price, null)))
                {
                    ((IDictionary<string,object>)request)["price"] = this.priceToPrecision(symbol, price);
                }
            }
        }
        object reduceOnly = this.safeBool2(parameters, "reduceOnly", "reduce_only", false);
        if (isTrue(!isTrue(isStopLossTriggerOrder) && !isTrue(isTakeProfitTriggerOrder)))
        {
            if (isTrue(reduceOnly))
            {
                ((IDictionary<string,object>)request)["reduce_only"] = 1;
            }
            ((IDictionary<string,object>)request)["lever_rate"] = this.safeIntegerN(parameters, new List<object>() {"leverRate", "lever_rate", "leverage"}, 1);
            if (!isTrue(isTrailingPercentOrder))
            {
                ((IDictionary<string,object>)request)["order_price_type"] = type;
            }
        }
        object hedged = this.safeBool(parameters, "hedged", false);
        if (isTrue(hedged))
        {
            if (isTrue(reduceOnly))
            {
                ((IDictionary<string,object>)request)["offset"] = "close";
            } else
            {
                ((IDictionary<string,object>)request)["offset"] = "open";
            }
        }
        object broker = this.safeValue(this.options, "broker", new Dictionary<string, object>() {});
        object brokerId = this.safeString(broker, "id");
        ((IDictionary<string,object>)request)["channel_code"] = brokerId;
        parameters = this.omit(parameters, new List<object>() {"reduceOnly", "triggerPrice", "stopPrice", "stopLossPrice", "takeProfitPrice", "triggerType", "leverRate", "timeInForce", "leverage", "trailingPercent", "trailingTriggerPrice", "hedged"});
        return this.extend(request, parameters);
    }

    /**
     * @method
     * @name htx#createOrder
     * @description create a trade order
     * @see https://huobiapi.github.io/docs/spot/v1/en/#place-a-new-order                   // spot, margin
     * @see https://huobiapi.github.io/docs/coin_margined_swap/v1/en/#place-an-order        // coin-m swap
     * @see https://huobiapi.github.io/docs/coin_margined_swap/v1/en/#place-trigger-order   // coin-m swap trigger
     * @see https://huobiapi.github.io/docs/usdt_swap/v1/en/#cross-place-an-order           // usdt-m swap cross
     * @see https://huobiapi.github.io/docs/usdt_swap/v1/en/#cross-place-trigger-order      // usdt-m swap cross trigger
     * @see https://huobiapi.github.io/docs/usdt_swap/v1/en/#isolated-place-an-order        // usdt-m swap isolated
     * @see https://huobiapi.github.io/docs/usdt_swap/v1/en/#isolated-place-trigger-order   // usdt-m swap isolated trigger
     * @see https://huobiapi.github.io/docs/usdt_swap/v1/en/#isolated-set-a-take-profit-and-stop-loss-order-for-an-existing-position
     * @see https://huobiapi.github.io/docs/usdt_swap/v1/en/#cross-set-a-take-profit-and-stop-loss-order-for-an-existing-position
     * @see https://huobiapi.github.io/docs/dm/v1/en/#place-an-order                        // coin-m futures
     * @see https://huobiapi.github.io/docs/dm/v1/en/#place-trigger-order                   // coin-m futures contract trigger
     * @param {string} symbol unified symbol of the market to create an order in
     * @param {string} type 'market' or 'limit'
     * @param {string} side 'buy' or 'sell'
     * @param {float} amount how much you want to trade in units of the base currency
     * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {float} [params.triggerPrice] the price a trigger order is triggered at
     * @param {string} [params.triggerType] *contract trigger orders only* ge: greater than or equal to, le: less than or equal to
     * @param {float} [params.stopLossPrice] *contract only* the price a stop-loss order is triggered at
     * @param {float} [params.takeProfitPrice] *contract only* the price a take-profit order is triggered at
     * @param {string} [params.operator] *spot and margin only* gte or lte, trigger price condition
     * @param {string} [params.offset] *contract only* 'both' (linear only), 'open', or 'close', required in hedge mode and for inverse markets
     * @param {bool} [params.postOnly] *contract only* true or false
     * @param {int} [params.leverRate] *contract only* required for all contract orders except tpsl, leverage greater than 20x requires prior approval of high-leverage agreement
     * @param {string} [params.timeInForce] supports 'IOC' and 'FOK'
     * @param {float} [params.cost] *spot market buy only* the quote quantity that can be used as an alternative for the amount
     * @param {float} [params.trailingPercent] *contract only* the percent to trail away from the current market price
     * @param {float} [params.trailingTriggerPrice] *contract only* the price to trigger a trailing order, default uses the price argument
     * @param {bool} [params.hedged] *contract only* true for hedged mode, false for one way mode, default is false
     * @returns {object} an [order structure]{@link https://docs.ccxt.com/?id=order-structure}
     */
    public async override Task<object> createOrder(object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object triggerPrice = this.safeNumberN(parameters, new List<object>() {"triggerPrice", "stopPrice", "trigger_price"});
        object stopLossTriggerPrice = this.safeNumber2(parameters, "stopLossPrice", "sl_trigger_price");
        object takeProfitTriggerPrice = this.safeNumber2(parameters, "takeProfitPrice", "tp_trigger_price");
        object trailingPercent = this.safeNumber(parameters, "trailingPercent");
        object isTrailingPercentOrder = !isEqual(trailingPercent, null);
        object isTrigger = !isEqual(triggerPrice, null);
        object isStopLossTriggerOrder = !isEqual(stopLossTriggerPrice, null);
        object isTakeProfitTriggerOrder = !isEqual(takeProfitTriggerPrice, null);
        object response = null;
        if (isTrue(getValue(market, "spot")))
        {
            if (isTrue(isTrailingPercentOrder))
            {
                throw new NotSupported ((string)add(this.id, " createOrder() does not support trailing orders for spot markets")) ;
            }
            object spotRequest = await this.createSpotOrderRequest(symbol, type, side, amount, price, parameters);
            response = await this.spotPrivatePostV1OrderOrdersPlace(spotRequest);
        } else
        {
            object contractRequest = this.createContractOrderRequest(symbol, type, side, amount, price, parameters);
            if (isTrue(getValue(market, "linear")))
            {
                object marginMode = null;
                var marginModecontractRequestVariable = this.handleMarginModeAndParams("createOrder", contractRequest);
                marginMode = ((IList<object>)marginModecontractRequestVariable)[0];
                contractRequest = ((IList<object>)marginModecontractRequestVariable)[1];
                marginMode = ((bool) isTrue((isEqual(marginMode, null)))) ? "cross" : marginMode;
                if (isTrue(isEqual(marginMode, "isolated")))
                {
                    if (isTrue(isTrigger))
                    {
                        response = await this.contractPrivatePostLinearSwapApiV1SwapTriggerOrder(contractRequest);
                    } else if (isTrue(isTrue(isStopLossTriggerOrder) || isTrue(isTakeProfitTriggerOrder)))
                    {
                        response = await this.contractPrivatePostLinearSwapApiV1SwapTpslOrder(contractRequest);
                    } else if (isTrue(isTrailingPercentOrder))
                    {
                        response = await this.contractPrivatePostLinearSwapApiV1SwapTrackOrder(contractRequest);
                    } else
                    {
                        response = await this.contractPrivatePostLinearSwapApiV1SwapOrder(contractRequest);
                    }
                } else if (isTrue(isEqual(marginMode, "cross")))
                {
                    if (isTrue(isTrigger))
                    {
                        response = await this.contractPrivatePostLinearSwapApiV1SwapCrossTriggerOrder(contractRequest);
                    } else if (isTrue(isTrue(isStopLossTriggerOrder) || isTrue(isTakeProfitTriggerOrder)))
                    {
                        response = await this.contractPrivatePostLinearSwapApiV1SwapCrossTpslOrder(contractRequest);
                    } else if (isTrue(isTrailingPercentOrder))
                    {
                        response = await this.contractPrivatePostLinearSwapApiV1SwapCrossTrackOrder(contractRequest);
                    } else
                    {
                        response = await this.contractPrivatePostLinearSwapApiV1SwapCrossOrder(contractRequest);
                    }
                }
            } else if (isTrue(getValue(market, "inverse")))
            {
                object offset = this.safeString(parameters, "offset");
                if (isTrue(isEqual(offset, null)))
                {
                    throw new ArgumentsRequired ((string)add(this.id, " createOrder () requires an extra parameter params[\"offset\"] to be set to \"open\" or \"close\" when placing orders in inverse markets")) ;
                }
                if (isTrue(getValue(market, "swap")))
                {
                    if (isTrue(isTrigger))
                    {
                        response = await this.contractPrivatePostSwapApiV1SwapTriggerOrder(contractRequest);
                    } else if (isTrue(isTrue(isStopLossTriggerOrder) || isTrue(isTakeProfitTriggerOrder)))
                    {
                        response = await this.contractPrivatePostSwapApiV1SwapTpslOrder(contractRequest);
                    } else if (isTrue(isTrailingPercentOrder))
                    {
                        response = await this.contractPrivatePostSwapApiV1SwapTrackOrder(contractRequest);
                    } else
                    {
                        response = await this.contractPrivatePostSwapApiV1SwapOrder(contractRequest);
                    }
                } else if (isTrue(getValue(market, "future")))
                {
                    if (isTrue(isTrigger))
                    {
                        response = await this.contractPrivatePostApiV1ContractTriggerOrder(contractRequest);
                    } else if (isTrue(isTrue(isStopLossTriggerOrder) || isTrue(isTakeProfitTriggerOrder)))
                    {
                        response = await this.contractPrivatePostApiV1ContractTpslOrder(contractRequest);
                    } else if (isTrue(isTrailingPercentOrder))
                    {
                        response = await this.contractPrivatePostApiV1ContractTrackOrder(contractRequest);
                    } else
                    {
                        response = await this.contractPrivatePostApiV1ContractOrder(contractRequest);
                    }
                }
            }
        }
        //
        // spot
        //
        //     {"status":"ok","data":"438398393065481"}
        //
        // swap and future
        //
        //     {
        //         "status": "ok",
        //         "data": {
        //             "order_id": 924660854912552960,
        //             "order_id_str": "924660854912552960"
        //         },
        //         "ts": 1640497927185
        //     }
        //
        // stop-loss and take-profit
        //
        //     {
        //         "status": "ok",
        //         "data": {
        //             "tp_order": {
        //                 "order_id": 1101494204040163328,
        //                 "order_id_str": "1101494204040163328"
        //             },
        //             "sl_order": null
        //         },
        //         "ts": :1682658283024
        //     }
        //
        object data = null;
        object result = null;
        if (isTrue(getValue(market, "spot")))
        {
            return this.safeOrder(new Dictionary<string, object>() {
                { "info", response },
                { "id", this.safeString(response, "data") },
                { "timestamp", null },
                { "datetime", null },
                { "lastTradeTimestamp", null },
                { "status", null },
                { "symbol", null },
                { "type", type },
                { "side", side },
                { "price", price },
                { "amount", amount },
                { "filled", null },
                { "remaining", null },
                { "cost", null },
                { "trades", null },
                { "fee", null },
                { "clientOrderId", null },
                { "average", null },
            }, market);
        } else if (isTrue(isStopLossTriggerOrder))
        {
            data = this.safeValue(response, "data", new Dictionary<string, object>() {});
            result = this.safeValue(data, "sl_order", new Dictionary<string, object>() {});
        } else if (isTrue(isTakeProfitTriggerOrder))
        {
            data = this.safeValue(response, "data", new Dictionary<string, object>() {});
            result = this.safeValue(data, "tp_order", new Dictionary<string, object>() {});
        } else
        {
            result = this.safeValue(response, "data", new Dictionary<string, object>() {});
        }
        return this.parseOrder(result, market);
    }

    /**
     * @method
     * @name htx#createOrders
     * @description create a list of trade orders
     * @see https://huobiapi.github.io/docs/spot/v1/en/#place-a-batch-of-orders
     * @see https://huobiapi.github.io/docs/dm/v1/en/#place-a-batch-of-orders
     * @see https://huobiapi.github.io/docs/coin_margined_swap/v1/en/#place-a-batch-of-orders
     * @see https://huobiapi.github.io/docs/usdt_swap/v1/en/#isolated-place-a-batch-of-orders
     * @see https://huobiapi.github.io/docs/usdt_swap/v1/en/#cross-place-a-batch-of-orders
     * @param {Array} orders list of orders to create, each object should contain the parameters required by createOrder, namely symbol, type, side, amount, price and params
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} an [order structure]{@link https://docs.ccxt.com/?id=order-structure}
     */
    public async override Task<object> createOrders(object orders, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object ordersRequests = new List<object>() {};
        object symbol = null;
        object market = null;
        object marginMode = null;
        for (object i = 0; isLessThan(i, getArrayLength(orders)); postFixIncrement(ref i))
        {
            object rawOrder = getValue(orders, i);
            object marketId = this.safeString(rawOrder, "symbol");
            if (isTrue(isEqual(symbol, null)))
            {
                symbol = marketId;
            } else
            {
                if (isTrue(!isEqual(symbol, marketId)))
                {
                    throw new BadRequest ((string)add(this.id, " createOrders() requires all orders to have the same symbol")) ;
                }
            }
            object type = this.safeString(rawOrder, "type");
            object side = this.safeString(rawOrder, "side");
            object amount = this.safeValue(rawOrder, "amount");
            object price = this.safeValue(rawOrder, "price");
            object orderParams = this.safeValue(rawOrder, "params", new Dictionary<string, object>() {});
            object marginResult = this.handleMarginModeAndParams("createOrders", orderParams);
            object currentMarginMode = getValue(marginResult, 0);
            if (isTrue(!isEqual(currentMarginMode, null)))
            {
                if (isTrue(isEqual(marginMode, null)))
                {
                    marginMode = currentMarginMode;
                } else
                {
                    if (isTrue(!isEqual(marginMode, currentMarginMode)))
                    {
                        throw new BadRequest ((string)add(this.id, " createOrders() requires all orders to have the same margin mode (isolated or cross)")) ;
                    }
                }
            }
            market = this.market(symbol);
            object orderRequest = null;
            if (isTrue(getValue(market, "spot")))
            {
                orderRequest = await this.createSpotOrderRequest(marketId, type, side, amount, price, orderParams);
            } else
            {
                orderRequest = this.createContractOrderRequest(marketId, type, side, amount, price, orderParams);
            }
            orderRequest = this.omit(orderRequest, "marginMode");
            ((IList<object>)ordersRequests).Add(orderRequest);
        }
        object request = new Dictionary<string, object>() {};
        object response = null;
        if (isTrue(getValue(market, "spot")))
        {
            response = await this.privatePostOrderBatchOrders(ordersRequests);
        } else
        {
            ((IDictionary<string,object>)request)["orders_data"] = ordersRequests;
            if (isTrue(getValue(market, "linear")))
            {
                marginMode = ((bool) isTrue((isEqual(marginMode, null)))) ? "cross" : marginMode;
                if (isTrue(isEqual(marginMode, "isolated")))
                {
                    response = await this.contractPrivatePostLinearSwapApiV1SwapBatchorder(request);
                } else if (isTrue(isEqual(marginMode, "cross")))
                {
                    response = await this.contractPrivatePostLinearSwapApiV1SwapCrossBatchorder(request);
                }
            } else if (isTrue(getValue(market, "inverse")))
            {
                if (isTrue(getValue(market, "swap")))
                {
                    response = await this.contractPrivatePostSwapApiV1SwapBatchorder(request);
                } else if (isTrue(getValue(market, "future")))
                {
                    response = await this.contractPrivatePostApiV1ContractBatchorder(request);
                }
            }
        }
        //
        // spot
        //
        //     {
        //         "status": "ok",
        //         "data": [
        //             {
        //                 "order-id": 936847569789079,
        //                 "client-order-id": "AA03022abc3a55e82c-0087-4fc2-beac-112fdebb1ee9"
        //             },
        //             {
        //                 "client-order-id": "AA03022abcdb3baefb-3cfa-4891-8009-082b3d46ca82",
        //                 "err-code": "account-frozen-balance-insufficient-error",
        //                 "err-msg": "trade account balance is not enough, left: `89`"
        //             }
        //         ]
        //     }
        //
        // swap and future
        //
        //     {
        //         "status": "ok",
        //         "data": {
        //             "errors": [
        //                 {
        //                     "index": 2,
        //                     "err_code": 1047,
        //                     "err_msg": "Insufficient margin available."
        //                 }
        //             ],
        //             "success": [
        //                 {
        //                     "order_id": 1172923090632953857,
        //                     "index": 1,
        //                     "order_id_str": "1172923090632953857"
        //                 }
        //             ]
        //         },
        //         "ts": 1699688256671
        //     }
        //
        object result = null;
        if (isTrue(getValue(market, "spot")))
        {
            result = this.safeValue(response, "data", new List<object>() {});
        } else
        {
            object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
            object success = this.safeValue(data, "success", new List<object>() {});
            object errors = this.safeValue(data, "errors", new List<object>() {});
            result = this.arrayConcat(success, errors);
        }
        return this.parseOrders(result, market);
    }

    /**
     * @method
     * @name htx#cancelOrder
     * @description cancels an open order
     * @param {string} id order id
     * @param {string} symbol unified symbol of the market the order was made in
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {boolean} [params.trigger] *contract only* if the order is a trigger trigger order or not
     * @param {boolean} [params.stopLossTakeProfit] *contract only* if the order is a stop-loss or take-profit order
     * @param {boolean} [params.trailing] *contract only* set to true if you want to cancel a trailing order
     * @returns {object} An [order structure]{@link https://docs.ccxt.com/?id=order-structure}
     */
    public async override Task<object> cancelOrder(object id, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
        }
        object marketType = null;
        var marketTypeparametersVariable = this.handleMarketTypeAndParams("cancelOrder", market, parameters);
        marketType = ((IList<object>)marketTypeparametersVariable)[0];
        parameters = ((IList<object>)marketTypeparametersVariable)[1];
        object request = new Dictionary<string, object>() {};
        object response = null;
        if (isTrue(isEqual(marketType, "spot")))
        {
            object clientOrderId = this.safeString2(parameters, "client-order-id", "clientOrderId");
            if (isTrue(isEqual(clientOrderId, null)))
            {
                ((IDictionary<string,object>)request)["order-id"] = id;
                response = await this.spotPrivatePostV1OrderOrdersOrderIdSubmitcancel(this.extend(request, parameters));
            } else
            {
                ((IDictionary<string,object>)request)["client-order-id"] = clientOrderId;
                parameters = this.omit(parameters, new List<object>() {"client-order-id", "clientOrderId"});
                response = await this.spotPrivatePostV1OrderOrdersSubmitCancelClientOrder(this.extend(request, parameters));
            }
        } else
        {
            if (isTrue(isEqual(symbol, null)))
            {
                throw new ArgumentsRequired ((string)add(this.id, " cancelOrder() requires a symbol argument")) ;
            }
            object clientOrderId = this.safeString2(parameters, "client_order_id", "clientOrderId");
            if (isTrue(isEqual(clientOrderId, null)))
            {
                ((IDictionary<string,object>)request)["order_id"] = id;
            } else
            {
                ((IDictionary<string,object>)request)["client_order_id"] = clientOrderId;
                parameters = this.omit(parameters, new List<object>() {"client_order_id", "clientOrderId"});
            }
            if (isTrue(getValue(market, "future")))
            {
                ((IDictionary<string,object>)request)["symbol"] = getValue(market, "settleId");
            } else
            {
                ((IDictionary<string,object>)request)["contract_code"] = getValue(market, "id");
            }
            object trigger = this.safeBool2(parameters, "stop", "trigger");
            object stopLossTakeProfit = this.safeValue(parameters, "stopLossTakeProfit");
            object trailing = this.safeBool(parameters, "trailing", false);
            parameters = this.omit(parameters, new List<object>() {"stop", "stopLossTakeProfit", "trailing", "trigger"});
            if (isTrue(getValue(market, "linear")))
            {
                object marginMode = null;
                var marginModeparametersVariable = this.handleMarginModeAndParams("cancelOrder", parameters);
                marginMode = ((IList<object>)marginModeparametersVariable)[0];
                parameters = ((IList<object>)marginModeparametersVariable)[1];
                marginMode = ((bool) isTrue((isEqual(marginMode, null)))) ? "cross" : marginMode;
                if (isTrue(isEqual(marginMode, "isolated")))
                {
                    if (isTrue(trigger))
                    {
                        response = await this.contractPrivatePostLinearSwapApiV1SwapTriggerCancel(this.extend(request, parameters));
                    } else if (isTrue(stopLossTakeProfit))
                    {
                        response = await this.contractPrivatePostLinearSwapApiV1SwapTpslCancel(this.extend(request, parameters));
                    } else if (isTrue(trailing))
                    {
                        response = await this.contractPrivatePostLinearSwapApiV1SwapTrackCancel(this.extend(request, parameters));
                    } else
                    {
                        response = await this.contractPrivatePostLinearSwapApiV1SwapCancel(this.extend(request, parameters));
                    }
                } else if (isTrue(isEqual(marginMode, "cross")))
                {
                    if (isTrue(trigger))
                    {
                        response = await this.contractPrivatePostLinearSwapApiV1SwapCrossTriggerCancel(this.extend(request, parameters));
                    } else if (isTrue(stopLossTakeProfit))
                    {
                        response = await this.contractPrivatePostLinearSwapApiV1SwapCrossTpslCancel(this.extend(request, parameters));
                    } else if (isTrue(trailing))
                    {
                        response = await this.contractPrivatePostLinearSwapApiV1SwapCrossTrackCancel(this.extend(request, parameters));
                    } else
                    {
                        response = await this.contractPrivatePostLinearSwapApiV1SwapCrossCancel(this.extend(request, parameters));
                    }
                }
            } else if (isTrue(getValue(market, "inverse")))
            {
                if (isTrue(getValue(market, "swap")))
                {
                    if (isTrue(trigger))
                    {
                        response = await this.contractPrivatePostSwapApiV1SwapTriggerCancel(this.extend(request, parameters));
                    } else if (isTrue(stopLossTakeProfit))
                    {
                        response = await this.contractPrivatePostSwapApiV1SwapTpslCancel(this.extend(request, parameters));
                    } else if (isTrue(trailing))
                    {
                        response = await this.contractPrivatePostSwapApiV1SwapTrackCancel(this.extend(request, parameters));
                    } else
                    {
                        response = await this.contractPrivatePostSwapApiV1SwapCancel(this.extend(request, parameters));
                    }
                } else if (isTrue(getValue(market, "future")))
                {
                    if (isTrue(trigger))
                    {
                        response = await this.contractPrivatePostApiV1ContractTriggerCancel(this.extend(request, parameters));
                    } else if (isTrue(stopLossTakeProfit))
                    {
                        response = await this.contractPrivatePostApiV1ContractTpslCancel(this.extend(request, parameters));
                    } else if (isTrue(trailing))
                    {
                        response = await this.contractPrivatePostApiV1ContractTrackCancel(this.extend(request, parameters));
                    } else
                    {
                        response = await this.contractPrivatePostApiV1ContractCancel(this.extend(request, parameters));
                    }
                }
            } else
            {
                throw new NotSupported ((string)add(add(add(this.id, " cancelOrder() does not support "), marketType), " markets")) ;
            }
        }
        //
        // spot
        //
        //     {
        //         "status": "ok",
        //         "data": "10138899000",
        //     }
        //
        // future and swap
        //
        //     {
        //         "status": "ok",
        //         "data": {
        //             "errors": [],
        //             "successes": "924660854912552960"
        //         },
        //         "ts": 1640504486089
        //     }
        //
        return this.extend(this.parseOrder(response, market), new Dictionary<string, object>() {
            { "id", id },
            { "status", "canceled" },
        });
    }

    /**
     * @method
     * @name htx#cancelOrders
     * @description cancel multiple orders
     * @param {string[]} ids order ids
     * @param {string} symbol unified market symbol, default is undefined
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {bool} [params.trigger] *contract only* if the orders are trigger trigger orders or not
     * @param {bool} [params.stopLossTakeProfit] *contract only* if the orders are stop-loss or take-profit orders
     * @returns {object} an list of [order structures]{@link https://docs.ccxt.com/?id=order-structure}
     */
    public async override Task<object> cancelOrders(object ids, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
        }
        object marketType = null;
        var marketTypeparametersVariable = this.handleMarketTypeAndParams("cancelOrders", market, parameters);
        marketType = ((IList<object>)marketTypeparametersVariable)[0];
        parameters = ((IList<object>)marketTypeparametersVariable)[1];
        object request = new Dictionary<string, object>() {};
        object response = null;
        if (isTrue(isEqual(marketType, "spot")))
        {
            object clientOrderIds = this.safeValue2(parameters, "client-order-id", "clientOrderId");
            clientOrderIds = this.safeValue2(parameters, "client-order-ids", "clientOrderIds", clientOrderIds);
            if (isTrue(isEqual(clientOrderIds, null)))
            {
                if (isTrue((clientOrderIds is string)))
                {
                    ((IDictionary<string,object>)request)["order-ids"] = new List<object>() {ids};
                } else
                {
                    ((IDictionary<string,object>)request)["order-ids"] = ids;
                }
            } else
            {
                if (isTrue((clientOrderIds is string)))
                {
                    ((IDictionary<string,object>)request)["client-order-ids"] = new List<object>() {clientOrderIds};
                } else
                {
                    ((IDictionary<string,object>)request)["client-order-ids"] = clientOrderIds;
                }
                parameters = this.omit(parameters, new List<object>() {"client-order-id", "client-order-ids", "clientOrderId", "clientOrderIds"});
            }
            response = await this.spotPrivatePostV1OrderOrdersBatchcancel(this.extend(request, parameters));
        } else
        {
            if (isTrue(isEqual(symbol, null)))
            {
                throw new ArgumentsRequired ((string)add(this.id, " cancelOrders() requires a symbol argument")) ;
            }
            object clientOrderIds = this.safeString2(parameters, "client_order_id", "clientOrderId");
            clientOrderIds = this.safeString2(parameters, "client_order_ids", "clientOrderIds", clientOrderIds);
            if (isTrue(isEqual(clientOrderIds, null)))
            {
                ((IDictionary<string,object>)request)["order_id"] = String.Join(",", ((IList<object>)ids).ToArray());
            } else
            {
                ((IDictionary<string,object>)request)["client_order_id"] = clientOrderIds;
                parameters = this.omit(parameters, new List<object>() {"client_order_id", "client_order_ids", "clientOrderId", "clientOrderIds"});
            }
            if (isTrue(getValue(market, "future")))
            {
                ((IDictionary<string,object>)request)["symbol"] = getValue(market, "settleId");
            } else
            {
                ((IDictionary<string,object>)request)["contract_code"] = getValue(market, "id");
            }
            object trigger = this.safeBool2(parameters, "stop", "trigger");
            object stopLossTakeProfit = this.safeValue(parameters, "stopLossTakeProfit");
            parameters = this.omit(parameters, new List<object>() {"stop", "stopLossTakeProfit", "trigger"});
            if (isTrue(getValue(market, "linear")))
            {
                object marginMode = null;
                var marginModeparametersVariable = this.handleMarginModeAndParams("cancelOrders", parameters);
                marginMode = ((IList<object>)marginModeparametersVariable)[0];
                parameters = ((IList<object>)marginModeparametersVariable)[1];
                marginMode = ((bool) isTrue((isEqual(marginMode, null)))) ? "cross" : marginMode;
                if (isTrue(isEqual(marginMode, "isolated")))
                {
                    if (isTrue(trigger))
                    {
                        response = await this.contractPrivatePostLinearSwapApiV1SwapTriggerCancel(this.extend(request, parameters));
                    } else if (isTrue(stopLossTakeProfit))
                    {
                        response = await this.contractPrivatePostLinearSwapApiV1SwapTpslCancel(this.extend(request, parameters));
                    } else
                    {
                        response = await this.contractPrivatePostLinearSwapApiV1SwapCancel(this.extend(request, parameters));
                    }
                } else if (isTrue(isEqual(marginMode, "cross")))
                {
                    if (isTrue(trigger))
                    {
                        response = await this.contractPrivatePostLinearSwapApiV1SwapCrossTriggerCancel(this.extend(request, parameters));
                    } else if (isTrue(stopLossTakeProfit))
                    {
                        response = await this.contractPrivatePostLinearSwapApiV1SwapCrossTpslCancel(this.extend(request, parameters));
                    } else
                    {
                        response = await this.contractPrivatePostLinearSwapApiV1SwapCrossCancel(this.extend(request, parameters));
                    }
                }
            } else if (isTrue(getValue(market, "inverse")))
            {
                if (isTrue(getValue(market, "swap")))
                {
                    if (isTrue(trigger))
                    {
                        response = await this.contractPrivatePostSwapApiV1SwapTriggerCancel(this.extend(request, parameters));
                    } else if (isTrue(stopLossTakeProfit))
                    {
                        response = await this.contractPrivatePostSwapApiV1SwapTpslCancel(this.extend(request, parameters));
                    } else
                    {
                        response = await this.contractPrivatePostSwapApiV1SwapCancel(this.extend(request, parameters));
                    }
                } else if (isTrue(getValue(market, "future")))
                {
                    if (isTrue(trigger))
                    {
                        response = await this.contractPrivatePostApiV1ContractTriggerCancel(this.extend(request, parameters));
                    } else if (isTrue(stopLossTakeProfit))
                    {
                        response = await this.contractPrivatePostApiV1ContractTpslCancel(this.extend(request, parameters));
                    } else
                    {
                        response = await this.contractPrivatePostApiV1ContractCancel(this.extend(request, parameters));
                    }
                }
            } else
            {
                throw new NotSupported ((string)add(add(add(this.id, " cancelOrders() does not support "), marketType), " markets")) ;
            }
        }
        //
        // spot
        //
        //     {
        //         "status": "ok",
        //         "data": {
        //             "success": [
        //                 "5983466"
        //             ],
        //             "failed": [
        //                 {
        //                     "err-msg": "Incorrect order state",
        //                     "order-state": 7,
        //                     "order-id": "",
        //                     "err-code": "order-orderstate-error",
        //                     "client-order-id": "first"
        //                 },
        //                 {
        //                     "err-msg": "Incorrect order state",
        //                     "order-state": 7,
        //                     "order-id": "",
        //                     "err-code": "order-orderstate-error",
        //                     "client-order-id": "second"
        //                 },
        //                 {
        //                     "err-msg": "The record is not found.",
        //                     "order-id": "",
        //                     "err-code": "base-not-found",
        //                     "client-order-id": "third"
        //                 }
        //             ]
        //         }
        //     }
        //
        // future and swap
        //
        //     {
        //         "status": "ok",
        //         "data": {
        //             "errors": [
        //                 {
        //                     "order_id": "769206471845261312",
        //                     "err_code": 1061,
        //                     "err_msg": "This order doesnt exist."
        //                 }
        //             ],
        //             "successes": "773120304138219520"
        //         },
        //         "ts": 1604367997451
        //     }
        //
        object data = this.safeDict(response, "data");
        return this.parseCancelOrders(data);
    }

    public virtual object parseCancelOrders(object orders)
    {
        //
        //    {
        //        "success": [
        //            "5983466"
        //        ],
        //        "failed": [
        //            {
        //                "err-msg": "Incorrect order state",
        //                "order-state": 7,
        //                "order-id": "",
        //                "err-code": "order-orderstate-error",
        //                "client-order-id": "first"
        //            },
        //            ...
        //        ]
        //    }
        //
        //    {
        //        "errors": [
        //            {
        //                "order_id": "769206471845261312",
        //                "err_code": 1061,
        //                "err_msg": "This order doesnt exist."
        //            }
        //        ],
        //        "successes": "1258075374411399168,1258075393254871040"
        //    }
        //
        object successes = this.safeString(orders, "successes");
        object success = null;
        if (isTrue(!isEqual(successes, null)))
        {
            success = ((string)successes).Split(new [] {((string)",")}, StringSplitOptions.None).ToList<object>();
        } else
        {
            success = this.safeList(orders, "success", new List<object>() {});
        }
        object failed = this.safeList2(orders, "errors", "failed", new List<object>() {});
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(success)); postFixIncrement(ref i))
        {
            object order = getValue(success, i);
            ((IList<object>)result).Add(this.safeOrder(new Dictionary<string, object>() {
                { "info", order },
                { "id", order },
                { "status", "canceled" },
            }));
        }
        for (object i = 0; isLessThan(i, getArrayLength(failed)); postFixIncrement(ref i))
        {
            object order = getValue(failed, i);
            ((IList<object>)result).Add(this.safeOrder(new Dictionary<string, object>() {
                { "info", order },
                { "id", this.safeString2(order, "order-id", "order_id") },
                { "status", "failed" },
                { "clientOrderId", this.safeString(order, "client-order-id") },
            }));
        }
        return result;
    }

    /**
     * @method
     * @name htx#cancelAllOrders
     * @description cancel all open orders
     * @param {string} symbol unified market symbol, only orders in the market of this symbol are cancelled when symbol is not undefined
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {boolean} [params.trigger] *contract only* if the orders are trigger trigger orders or not
     * @param {boolean} [params.stopLossTakeProfit] *contract only* if the orders are stop-loss or take-profit orders
     * @param {boolean} [params.trailing] *contract only* set to true if you want to cancel all trailing orders
     * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/?id=order-structure}
     */
    public async override Task<object> cancelAllOrders(object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
        }
        object marketType = null;
        var marketTypeparametersVariable = this.handleMarketTypeAndParams("cancelAllOrders", market, parameters);
        marketType = ((IList<object>)marketTypeparametersVariable)[0];
        parameters = ((IList<object>)marketTypeparametersVariable)[1];
        object request = new Dictionary<string, object>() {};
        object response = null;
        if (isTrue(isEqual(marketType, "spot")))
        {
            if (isTrue(!isEqual(symbol, null)))
            {
                ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
            }
            response = await this.spotPrivatePostV1OrderOrdersBatchCancelOpenOrders(this.extend(request, parameters));
            //
            //     {
            //         "code": 200,
            //         "data": {
            //             "success-count": 2,
            //             "failed-count": 0,
            //             "next-id": 5454600
            //         }
            //     }
            //
            object data = this.safeDict(response, "data");
            return new List<object> {this.safeOrder(new Dictionary<string, object>() {
    { "info", data },
})};
        } else
        {
            if (isTrue(isEqual(symbol, null)))
            {
                throw new ArgumentsRequired ((string)add(this.id, " cancelAllOrders() requires a symbol argument")) ;
            }
            if (isTrue(getValue(market, "future")))
            {
                ((IDictionary<string,object>)request)["symbol"] = getValue(market, "settleId");
            }
            ((IDictionary<string,object>)request)["contract_code"] = getValue(market, "id");
            object trigger = this.safeBool2(parameters, "stop", "trigger");
            object stopLossTakeProfit = this.safeValue(parameters, "stopLossTakeProfit");
            object trailing = this.safeBool(parameters, "trailing", false);
            parameters = this.omit(parameters, new List<object>() {"stop", "stopLossTakeProfit", "trailing", "trigger"});
            if (isTrue(getValue(market, "linear")))
            {
                object marginMode = null;
                var marginModeparametersVariable = this.handleMarginModeAndParams("cancelAllOrders", parameters);
                marginMode = ((IList<object>)marginModeparametersVariable)[0];
                parameters = ((IList<object>)marginModeparametersVariable)[1];
                marginMode = ((bool) isTrue((isEqual(marginMode, null)))) ? "cross" : marginMode;
                if (isTrue(isEqual(marginMode, "isolated")))
                {
                    if (isTrue(trigger))
                    {
                        response = await this.contractPrivatePostLinearSwapApiV1SwapTriggerCancelall(this.extend(request, parameters));
                    } else if (isTrue(stopLossTakeProfit))
                    {
                        response = await this.contractPrivatePostLinearSwapApiV1SwapTpslCancelall(this.extend(request, parameters));
                    } else if (isTrue(trailing))
                    {
                        response = await this.contractPrivatePostLinearSwapApiV1SwapTrackCancelall(this.extend(request, parameters));
                    } else
                    {
                        response = await this.contractPrivatePostLinearSwapApiV1SwapCancelall(this.extend(request, parameters));
                    }
                } else if (isTrue(isEqual(marginMode, "cross")))
                {
                    if (isTrue(trigger))
                    {
                        response = await this.contractPrivatePostLinearSwapApiV1SwapCrossTriggerCancelall(this.extend(request, parameters));
                    } else if (isTrue(stopLossTakeProfit))
                    {
                        response = await this.contractPrivatePostLinearSwapApiV1SwapCrossTpslCancelall(this.extend(request, parameters));
                    } else if (isTrue(trailing))
                    {
                        response = await this.contractPrivatePostLinearSwapApiV1SwapCrossTrackCancelall(this.extend(request, parameters));
                    } else
                    {
                        response = await this.contractPrivatePostLinearSwapApiV1SwapCrossCancelall(this.extend(request, parameters));
                    }
                }
            } else if (isTrue(getValue(market, "inverse")))
            {
                if (isTrue(getValue(market, "swap")))
                {
                    if (isTrue(trigger))
                    {
                        response = await this.contractPrivatePostSwapApiV1SwapTriggerCancelall(this.extend(request, parameters));
                    } else if (isTrue(stopLossTakeProfit))
                    {
                        response = await this.contractPrivatePostSwapApiV1SwapTpslCancelall(this.extend(request, parameters));
                    } else if (isTrue(trailing))
                    {
                        response = await this.contractPrivatePostSwapApiV1SwapTrackCancelall(this.extend(request, parameters));
                    } else
                    {
                        response = await this.contractPrivatePostSwapApiV1SwapCancelall(this.extend(request, parameters));
                    }
                } else if (isTrue(getValue(market, "future")))
                {
                    if (isTrue(trigger))
                    {
                        response = await this.contractPrivatePostApiV1ContractTriggerCancelall(this.extend(request, parameters));
                    } else if (isTrue(stopLossTakeProfit))
                    {
                        response = await this.contractPrivatePostApiV1ContractTpslCancelall(this.extend(request, parameters));
                    } else if (isTrue(trailing))
                    {
                        response = await this.contractPrivatePostApiV1ContractTrackCancelall(this.extend(request, parameters));
                    } else
                    {
                        response = await this.contractPrivatePostApiV1ContractCancelall(this.extend(request, parameters));
                    }
                }
            } else
            {
                throw new NotSupported ((string)add(add(add(this.id, " cancelAllOrders() does not support "), marketType), " markets")) ;
            }
            //
            //     {
            //         "status": "ok",
            //         "data": {
            //             "errors": [],
            //             "successes": "1104754904426696704"
            //         },
            //         "ts": "1683435723755"
            //     }
            //
            object data = this.safeDict(response, "data");
            return this.parseCancelOrders(data);
        }
    }

    /**
     * @method
     * @name htx#cancelAllOrdersAfter
     * @description dead man's switch, cancel all orders after the given timeout
     * @see https://huobiapi.github.io/docs/spot/v1/en/#dead-man-s-switch
     * @param {number} timeout time in milliseconds, 0 represents cancel the timer
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} the api result
     */
    public async override Task<object> cancelAllOrdersAfter(object timeout, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {
            { "timeout", ((bool) isTrue((isGreaterThan(timeout, 0)))) ? this.parseToInt(divide(timeout, 1000)) : 0 },
        };
        object response = await this.v2PrivatePostAlgoOrdersCancelAllAfter(this.extend(request, parameters));
        //
        //     {
        //         "code": 200,
        //         "message": "success",
        //         "data": {
        //             "currentTime": 1630491627230,
        //             "triggerTime": 1630491637230
        //         }
        //     }
        //
        return response;
    }

    public override object parseDepositAddress(object depositAddress, object currency = null)
    {
        //
        //     {
        //         "currency": "usdt",
        //         "address": "0xf7292eb9ba7bc50358e27f0e025a4d225a64127b",
        //         "addressTag": "",
        //         "chain": "usdterc20", // trc20usdt, hrc20usdt, usdt, algousdt
        //     }
        //
        object address = this.safeString(depositAddress, "address");
        object tag = this.safeString(depositAddress, "addressTag");
        object currencyId = this.safeString(depositAddress, "currency");
        currency = this.safeCurrency(currencyId, currency);
        object code = this.safeCurrencyCode(currencyId, currency);
        object note = this.safeString(depositAddress, "note");
        object networkId = this.safeString(depositAddress, "chain");
        this.checkAddress(address);
        return new Dictionary<string, object>() {
            { "currency", code },
            { "address", address },
            { "tag", tag },
            { "network", this.networkIdToCode(networkId) },
            { "note", note },
            { "info", depositAddress },
        };
    }

    /**
     * @method
     * @see https://www.htx.com/en-us/opend/newApiPages/?id=7ec50029-7773-11ed-9966-0242ac110003
     * @name htx#fetchDepositAddressesByNetwork
     * @description fetch a dictionary of addresses for a currency, indexed by network
     * @param {string} code unified currency code of the currency for the deposit address
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a dictionary of [address structures]{@link https://docs.ccxt.com/?id=address-structure} indexed by the network
     */
    public async override Task<object> fetchDepositAddressesByNetwork(object code, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "currency", getValue(currency, "id") },
        };
        object response = await this.spotPrivateGetV2AccountDepositAddress(this.extend(request, parameters));
        //
        //     {
        //         "code": 200,
        //         "data": [
        //             {
        //                 "currency": "eth",
        //                 "address": "0xf7292eb9ba7bc50358e27f0e025a4d225a64127b",
        //                 "addressTag": "",
        //                 "chain": "eth"
        //             }
        //         ]
        //     }
        //
        object data = this.safeValue(response, "data", new List<object>() {});
        object parsed = this.parseDepositAddresses(data, new List<object>() {getValue(currency, "code")}, false);
        return this.indexBy(parsed, "network");
    }

    /**
     * @method
     * @name htx#fetchDepositAddress
     * @description fetch the deposit address for a currency associated with this account
     * @see https://www.htx.com/en-us/opend/newApiPages/?id=7ec50029-7773-11ed-9966-0242ac110003
     * @param {string} code unified currency code
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} an [address structure]{@link https://docs.ccxt.com/?id=address-structure}
     */
    public async override Task<object> fetchDepositAddress(object code, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        var networkCodeparamsOmitedVariable = this.handleNetworkCodeAndParams(parameters);
        var networkCode = ((IList<object>) networkCodeparamsOmitedVariable)[0];
        var paramsOmited = ((IList<object>) networkCodeparamsOmitedVariable)[1];
        object indexedAddresses = await this.fetchDepositAddressesByNetwork(code, paramsOmited);
        object selectedNetworkCode = this.selectNetworkCodeFromUnifiedNetworks(getValue(currency, "code"), networkCode, indexedAddresses);
        return getValue(indexedAddresses, selectedNetworkCode);
    }

    public async virtual Task<object> fetchWithdrawAddresses(object code, object note = null, object networkCode = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "currency", getValue(currency, "id") },
        };
        object response = await this.spotPrivateGetV2AccountWithdrawAddress(this.extend(request, parameters));
        //
        //     {
        //         "code": 200,
        //         "data": [
        //             {
        //                 "currency": "eth",
        //                 "chain": "eth"
        //                 "note": "Binance - TRC20",
        //                 "addressTag": "",
        //                 "address": "0xf7292eb9ba7bc50358e27f0e025a4d225a64127b",
        //             }
        //         ]
        //     }
        //
        object data = this.safeValue(response, "data", new List<object>() {});
        object allAddresses = ((object)this.parseDepositAddresses(data, new List<object>() {getValue(currency, "code")}, false)); // cjg: to do remove this weird object or array ambiguity
        object addresses = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(allAddresses)); postFixIncrement(ref i))
        {
            object address = getValue(allAddresses, i);
            object noteMatch = isTrue((isEqual(note, null))) || isTrue((isEqual(getValue(address, "note"), note)));
            object networkMatch = isTrue((isEqual(networkCode, null))) || isTrue((isEqual(getValue(address, "network"), networkCode)));
            if (isTrue(isTrue(noteMatch) && isTrue(networkMatch)))
            {
                ((IList<object>)addresses).Add(address);
            }
        }
        return addresses;
    }

    /**
     * @method
     * @name htx#fetchDeposits
     * @see https://www.htx.com/en-us/opend/newApiPages/?id=7ec4f050-7773-11ed-9966-0242ac110003
     * @description fetch all deposits made to an account
     * @param {string} code unified currency code
     * @param {int} [since] the earliest time in ms to fetch deposits for
     * @param {int} [limit] the maximum number of deposits structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/?id=transaction-structure}
     */
    public async override Task<object> fetchDeposits(object code = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isTrue(isEqual(limit, null)) || isTrue(isGreaterThan(limit, 100))))
        {
            limit = 100;
        }
        await this.loadMarkets();
        object currency = null;
        if (isTrue(!isEqual(code, null)))
        {
            currency = this.currency(code);
        }
        object request = new Dictionary<string, object>() {
            { "type", "deposit" },
            { "direct", "next" },
            { "from", 0 },
        };
        if (isTrue(!isEqual(currency, null)))
        {
            ((IDictionary<string,object>)request)["currency"] = getValue(currency, "id");
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["size"] = limit; // max 100
        }
        object response = await this.spotPrivateGetV1QueryDepositWithdraw(this.extend(request, parameters));
        //
        //    {
        //         "status": "ok",
        //         "data": [
        //             {
        //                 "id": "75115912",
        //                 "type": "deposit",
        //                 "sub-type": "NORMAL",
        //                 "request-id": "trc20usdt-a2e229a44ef2a948c874366230bb56aa73631cc0a03d177bd8b4c9d38262d7ff-200",
        //                 "currency": "usdt",
        //                 "chain": "trc20usdt",
        //                 "tx-hash": "a2e229a44ef2a948c874366230bb56aa73631cc0a03d177bd8b4c9d38262d7ff",
        //                 "amount": "12.000000000000000000",
        //                 "from-addr-tag": "",
        //                 "address-id": "0",
        //                 "address": "TRFTd1FxepQE6CnpwzUEMEbFaLm5bJK67s",
        //                 "address-tag": "",
        //                 "fee": "0",
        //                 "state": "safe",
        //                 "wallet-confirm": "2",
        //                 "created-at": "1621843808662",
        //                 "updated-at": "1621843857137"
        //             },
        //         ]
        //     }
        //
        return this.parseTransactions(getValue(response, "data"), currency, since, limit);
    }

    /**
     * @method
     * @name htx#fetchWithdrawals
     * @description fetch all withdrawals made from an account
     * @see https://huobiapi.github.io/docs/spot/v1/en/#search-for-existed-withdraws-and-deposits
     * @param {string} code unified currency code
     * @param {int} [since] the earliest time in ms to fetch withdrawals for
     * @param {int} [limit] the maximum number of withdrawals structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/?id=transaction-structure}
     */
    public async override Task<object> fetchWithdrawals(object code = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isTrue(isEqual(limit, null)) || isTrue(isGreaterThan(limit, 100))))
        {
            limit = 100;
        }
        await this.loadMarkets();
        object currency = null;
        if (isTrue(!isEqual(code, null)))
        {
            currency = this.currency(code);
        }
        object request = new Dictionary<string, object>() {
            { "type", "withdraw" },
            { "direct", "next" },
            { "from", 0 },
        };
        if (isTrue(!isEqual(currency, null)))
        {
            ((IDictionary<string,object>)request)["currency"] = getValue(currency, "id");
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["size"] = limit; // max 100
        }
        object response = await this.spotPrivateGetV1QueryDepositWithdraw(this.extend(request, parameters));
        //
        //    {
        //         "status": "ok",
        //         "data": [
        //             {
        //                 "id": "61335312",
        //                 "type": "withdraw",
        //                 "sub-type": "NORMAL",
        //                 "currency": "usdt",
        //                 "chain": "trc20usdt",
        //                 "tx-hash": "30a3111f2fead74fae45c6218ca3150fc33cab2aa59cfe41526b96aae79ce4ec",
        //                 "amount": "12.000000000000000000",
        //                 "from-addr-tag": "",
        //                 "address-id": "27321591",
        //                 "address": "TRf5JacJQRsF4Nm2zu11W6maDGeiEWQu9e",
        //                 "address-tag": "",
        //                 "fee": "1.000000000000000000",
        //                 "state": "confirmed",
        //                 "created-at": "1621852316553",
        //                 "updated-at": "1621852467041"
        //             },
        //         ]
        //     }
        //
        return this.parseTransactions(getValue(response, "data"), currency, since, limit);
    }

    public override object parseTransaction(object transaction, object currency = null)
    {
        //
        // fetchDeposits
        //
        //     {
        //         "id": "75115912",
        //         "type": "deposit",
        //         "sub-type": "NORMAL",
        //         "request-id": "trc20usdt-a2e229a44ef2a948c874366230bb56aa73631cc0a03d177bd8b4c9d38262d7ff-200",
        //         "currency": "usdt",
        //         "chain": "trc20usdt",
        //         "tx-hash": "a2e229a44ef2a948c874366230bb56aa73631cc0a03d177bd8b4c9d38262d7ff",
        //         "amount": "2849.000000000000000000",
        //         "from-addr-tag": "",
        //         "address-id": "0",
        //         "address": "TRFTd1FxepQE6CnpwzUEMEbFaLm5bJK67s",
        //         "address-tag": "",
        //         "fee": "0",
        //         "state": "safe",
        //         "wallet-confirm": "2",
        //         "created-at": "1621843808662",
        //         "updated-at": "1621843857137"
        //     },
        //
        // fetchWithdrawals
        //
        //     {
        //         "id": "61335312",
        //         "type": "withdraw",
        //         "sub-type": "NORMAL",
        //         "currency": "usdt",
        //         "chain": "trc20usdt",
        //         "tx-hash": "30a3111f2fead74fae45c6218ca3150fc33cab2aa59cfe41526b96aae79ce4ec",
        //         "amount": "12.000000000000000000",
        //         "from-addr-tag": "",
        //         "address-id": "27321591",
        //         "address": "TRf5JacJQRsF4Nm2zu11W6maDGeiEWQu9e",
        //         "address-tag": "",
        //         "fee": "1.000000000000000000",
        //         "state": "confirmed",
        //         "created-at": "1621852316553",
        //         "updated-at": "1621852467041"
        //     }
        //
        // withdraw
        //
        //     {
        //         "status": "ok",
        //         "data": "99562054"
        //     }
        //
        object timestamp = this.safeInteger(transaction, "created-at");
        object code = this.safeCurrencyCode(this.safeString(transaction, "currency"));
        object type = this.safeString(transaction, "type");
        if (isTrue(isEqual(type, "withdraw")))
        {
            type = "withdrawal";
        }
        object feeCost = this.safeString(transaction, "fee");
        if (isTrue(!isEqual(feeCost, null)))
        {
            feeCost = Precise.stringAbs(feeCost);
        }
        object networkId = this.safeString(transaction, "chain");
        object txHash = this.safeString(transaction, "tx-hash");
        if (isTrue(isTrue(isEqual(networkId, "ETH")) && isTrue(isLessThan(getIndexOf(txHash, "0x"), 0))))
        {
            txHash = add("0x", txHash);
        }
        object subType = this.safeString(transaction, "sub-type");
        object intern = isEqual(subType, "FAST");
        return new Dictionary<string, object>() {
            { "info", transaction },
            { "id", this.safeString2(transaction, "id", "data") },
            { "txid", txHash },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "network", this.networkIdToCode(networkId) },
            { "address", this.safeString(transaction, "address") },
            { "addressTo", null },
            { "addressFrom", null },
            { "tag", this.safeString(transaction, "address-tag") },
            { "tagTo", null },
            { "tagFrom", null },
            { "type", type },
            { "amount", this.safeNumber(transaction, "amount") },
            { "currency", code },
            { "status", this.parseTransactionStatus(this.safeString(transaction, "state")) },
            { "updated", this.safeInteger(transaction, "updated-at") },
            { "comment", null },
            { "internal", intern },
            { "fee", new Dictionary<string, object>() {
                { "currency", code },
                { "cost", this.parseNumber(feeCost) },
                { "rate", null },
            } },
        };
    }

    public virtual object parseTransactionStatus(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "unknown", "failed" },
            { "confirming", "pending" },
            { "confirmed", "ok" },
            { "safe", "ok" },
            { "orphan", "failed" },
            { "submitted", "pending" },
            { "canceled", "canceled" },
            { "reexamine", "pending" },
            { "reject", "failed" },
            { "pass", "pending" },
            { "wallet-reject", "failed" },
            { "confirm-error", "failed" },
            { "repealed", "failed" },
            { "wallet-transfer", "pending" },
            { "pre-transfer", "pending" },
            { "verifying", "pending" },
        };
        return this.safeString(statuses, status, status);
    }

    /**
     * @method
     * @name htx#withdraw
     * @see https://www.htx.com/en-us/opend/newApiPages/?id=7ec4cc41-7773-11ed-9966-0242ac110003
     * @description make a withdrawal
     * @param {string} code unified currency code
     * @param {float} amount the amount to withdraw
     * @param {string} address the address to withdraw to
     * @param {string} tag
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/?id=transaction-structure}
     */
    public async override Task<object> withdraw(object code, object amount, object address, object tag = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        var tagparametersVariable = this.handleWithdrawTagAndParams(tag, parameters);
        tag = ((IList<object>)tagparametersVariable)[0];
        parameters = ((IList<object>)tagparametersVariable)[1];
        await this.loadMarkets();
        this.checkAddress(address);
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "address", address },
            { "currency", ((string)getValue(currency, "id")).ToLower() },
        };
        if (isTrue(!isEqual(tag, null)))
        {
            ((IDictionary<string,object>)request)["addr-tag"] = tag; // only for XRP?
        }
        object networkCode = null;
        var networkCodeparametersVariable = this.handleNetworkCodeAndParams(parameters);
        networkCode = ((IList<object>)networkCodeparametersVariable)[0];
        parameters = ((IList<object>)networkCodeparametersVariable)[1];
        if (isTrue(!isEqual(networkCode, null)))
        {
            ((IDictionary<string,object>)request)["chain"] = this.networkCodeToId(networkCode, code);
        }
        amount = parseFloat(this.currencyToPrecision(code, amount, networkCode));
        object withdrawOptions = this.safeValue(this.options, "withdraw", new Dictionary<string, object>() {});
        if (isTrue(this.safeBool(withdrawOptions, "includeFee", false)))
        {
            object fee = this.safeNumber(parameters, "fee");
            if (isTrue(isEqual(fee, null)))
            {
                object currencies = await this.fetchCurrencies();
                this.currencies = this.mapToSafeMap(this.deepExtend(this.currencies, currencies));
                object targetNetwork = this.safeValue(getValue(currency, "networks"), networkCode, new Dictionary<string, object>() {});
                fee = this.safeNumber(targetNetwork, "fee");
                if (isTrue(isEqual(fee, null)))
                {
                    throw new ArgumentsRequired ((string)add(this.id, " withdraw() function can not find withdraw fee for chosen network. You need to re-load markets with \"exchange.loadMarkets(true)\", or provide the \"fee\" parameter")) ;
                }
            }
            // fee needs to be deducted from whole amount
            object feeString = this.currencyToPrecision(code, fee, networkCode);
            parameters = this.omit(parameters, "fee");
            object amountString = this.numberToString(amount);
            object amountSubtractedString = Precise.stringSub(amountString, feeString);
            object amountSubtracted = parseFloat(amountSubtractedString);
            ((IDictionary<string,object>)request)["fee"] = parseFloat(feeString);
            amount = parseFloat(this.currencyToPrecision(code, amountSubtracted, networkCode));
        }
        ((IDictionary<string,object>)request)["amount"] = amount;
        object response = await this.spotPrivatePostV1DwWithdrawApiCreate(this.extend(request, parameters));
        //
        //     {
        //         "status": "ok",
        //         "data": "99562054"
        //     }
        //
        return this.parseTransaction(response, currency);
    }

    public override object parseTransfer(object transfer, object currency = null)
    {
        //
        // transfer
        //
        //     {
        //         "data": 12345,
        //         "status": "ok"
        //     }
        //
        object id = this.safeString(transfer, "data");
        object code = this.safeCurrencyCode(null, currency);
        return new Dictionary<string, object>() {
            { "info", transfer },
            { "id", id },
            { "timestamp", null },
            { "datetime", null },
            { "currency", code },
            { "amount", null },
            { "fromAccount", null },
            { "toAccount", null },
            { "status", null },
        };
    }

    /**
     * @method
     * @name htx#transfer
     * @description transfer currency internally between wallets on the same account
     * @see https://huobiapi.github.io/docs/dm/v1/en/#transfer-margin-between-spot-account-and-future-account
     * @see https://huobiapi.github.io/docs/spot/v1/en/#transfer-fund-between-spot-account-and-future-contract-account
     * @see https://huobiapi.github.io/docs/usdt_swap/v1/en/#general-transfer-margin-between-spot-account-and-usdt-margined-contracts-account
     * @see https://huobiapi.github.io/docs/spot/v1/en/#transfer-asset-from-spot-trading-account-to-cross-margin-account-cross
     * @see https://huobiapi.github.io/docs/spot/v1/en/#transfer-asset-from-spot-trading-account-to-isolated-margin-account-isolated
     * @see https://huobiapi.github.io/docs/spot/v1/en/#transfer-asset-from-cross-margin-account-to-spot-trading-account-cross
     * @see https://huobiapi.github.io/docs/spot/v1/en/#transfer-asset-from-isolated-margin-account-to-spot-trading-account-isolated
     * @param {string} code unified currency code
     * @param {float} amount amount to transfer
     * @param {string} fromAccount account to transfer from 'spot', 'future', 'swap'
     * @param {string} toAccount account to transfer to 'spot', 'future', 'swap'
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.symbol] used for isolated margin transfer
     * @param {string} [params.subType] 'linear' or 'inverse', only used when transfering to/from swap accounts
     * @returns {object} a [transfer structure]{@link https://docs.ccxt.com/?id=transfer-structure}
     */
    public async override Task<object> transfer(object code, object amount, object fromAccount, object toAccount, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "currency", getValue(currency, "id") },
            { "amount", parseFloat(this.currencyToPrecision(code, amount)) },
        };
        object subType = null;
        var subTypeparametersVariable = this.handleSubTypeAndParams("transfer", null, parameters);
        subType = ((IList<object>)subTypeparametersVariable)[0];
        parameters = ((IList<object>)subTypeparametersVariable)[1];
        object fromAccountId = this.convertTypeToAccount(fromAccount);
        object toAccountId = this.convertTypeToAccount(toAccount);
        object toCross = isEqual(toAccountId, "cross");
        object fromCross = isEqual(fromAccountId, "cross");
        object toIsolated = this.inArray(toAccountId, this.ids);
        object fromIsolated = this.inArray(fromAccountId, this.ids);
        object fromSpot = isEqual(fromAccountId, "pro");
        object toSpot = isEqual(toAccountId, "pro");
        if (isTrue(isTrue(fromSpot) && isTrue(toSpot)))
        {
            throw new BadRequest ((string)add(add(add(add(this.id, " transfer () cannot make a transfer between "), fromAccount), " and "), toAccount)) ;
        }
        object fromOrToFuturesAccount = isTrue((isEqual(fromAccountId, "futures"))) || isTrue((isEqual(toAccountId, "futures")));
        object response = null;
        if (isTrue(fromOrToFuturesAccount))
        {
            object type = add(add(fromAccountId, "-to-"), toAccountId);
            type = this.safeString(parameters, "type", type);
            ((IDictionary<string,object>)request)["type"] = type;
            response = await this.spotPrivatePostV1FuturesTransfer(this.extend(request, parameters));
        } else if (isTrue(isTrue(fromSpot) && isTrue(toCross)))
        {
            response = await this.privatePostCrossMarginTransferIn(this.extend(request, parameters));
        } else if (isTrue(isTrue(fromCross) && isTrue(toSpot)))
        {
            response = await this.privatePostCrossMarginTransferOut(this.extend(request, parameters));
        } else if (isTrue(isTrue(fromSpot) && isTrue(toIsolated)))
        {
            ((IDictionary<string,object>)request)["symbol"] = toAccountId;
            response = await this.privatePostDwTransferInMargin(this.extend(request, parameters));
        } else if (isTrue(isTrue(fromIsolated) && isTrue(toSpot)))
        {
            ((IDictionary<string,object>)request)["symbol"] = fromAccountId;
            response = await this.privatePostDwTransferOutMargin(this.extend(request, parameters));
        } else
        {
            if (isTrue(isEqual(subType, "linear")))
            {
                if (isTrue(isTrue((isEqual(fromAccountId, "swap"))) || isTrue((isEqual(fromAccount, "linear-swap")))))
                {
                    fromAccountId = "linear-swap";
                } else
                {
                    toAccountId = "linear-swap";
                }
                // check if cross-margin or isolated
                object symbol = this.safeString(parameters, "symbol");
                parameters = this.omit(parameters, "symbol");
                if (isTrue(!isEqual(symbol, null)))
                {
                    symbol = this.marketId(symbol);
                    ((IDictionary<string,object>)request)["margin-account"] = symbol;
                } else
                {
                    ((IDictionary<string,object>)request)["margin-account"] = "USDT"; // cross-margin
                }
            }
            ((IDictionary<string,object>)request)["from"] = ((bool) isTrue(fromSpot)) ? "spot" : fromAccountId;
            ((IDictionary<string,object>)request)["to"] = ((bool) isTrue(toSpot)) ? "spot" : toAccountId;
            response = await this.v2PrivatePostAccountTransfer(this.extend(request, parameters));
        }
        //
        //    {
        //        "code": "200",
        //        "data": "660150061",
        //        "message": "Succeed",
        //        "success": true,
        //        "print-log": true
        //    }
        //
        return this.parseTransfer(response, currency);
    }

    /**
     * @method
     * @name htx#fetchIsolatedBorrowRates
     * @description fetch the borrow interest rates of all currencies
     * @see https://huobiapi.github.io/docs/spot/v1/en/#get-loan-interest-rate-and-quota-isolated
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a list of [isolated borrow rate structures]{@link https://docs.ccxt.com/?id=isolated-borrow-rate-structure}
     */
    public async override Task<object> fetchIsolatedBorrowRates(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.spotPrivateGetV1MarginLoanInfo(parameters);
        //
        // {
        //     "status": "ok",
        //     "data": [
        //         {
        //             "symbol": "1inchusdt",
        //             "currencies": [
        //                 {
        //                     "currency": "1inch",
        //                     "interest-rate": "0.00098",
        //                     "min-loan-amt": "90.000000000000000000",
        //                     "max-loan-amt": "1000.000000000000000000",
        //                     "loanable-amt": "0.0",
        //                     "actual-rate": "0.00098"
        //                 },
        //                 {
        //                     "currency": "usdt",
        //                     "interest-rate": "0.00098",
        //                     "min-loan-amt": "100.000000000000000000",
        //                     "max-loan-amt": "1000.000000000000000000",
        //                     "loanable-amt": "0.0",
        //                     "actual-rate": "0.00098"
        //                 }
        //             ]
        //         },
        //         ...
        //     ]
        // }
        //
        object data = this.safeValue(response, "data", new List<object>() {});
        return this.parseIsolatedBorrowRates(data);
    }

    public override object parseIsolatedBorrowRate(object info, object market = null)
    {
        //
        //     {
        //         "symbol": "1inchusdt",
        //         "currencies": [
        //             {
        //                 "currency": "1inch",
        //                 "interest-rate": "0.00098",
        //                 "min-loan-amt": "90.000000000000000000",
        //                 "max-loan-amt": "1000.000000000000000000",
        //                 "loanable-amt": "0.0",
        //                 "actual-rate": "0.00098"
        //             },
        //             {
        //                 "currency": "usdt",
        //                 "interest-rate": "0.00098",
        //                 "min-loan-amt": "100.000000000000000000",
        //                 "max-loan-amt": "1000.000000000000000000",
        //                 "loanable-amt": "0.0",
        //                 "actual-rate": "0.00098"
        //             }
        //         ]
        //     },
        //
        object marketId = this.safeString(info, "symbol");
        object symbol = this.safeSymbol(marketId, market);
        object currencies = this.safeValue(info, "currencies", new List<object>() {});
        object baseData = this.safeValue(currencies, 0);
        object quoteData = this.safeValue(currencies, 1);
        object baseId = this.safeString(baseData, "currency");
        object quoteId = this.safeString(quoteData, "currency");
        return new Dictionary<string, object>() {
            { "symbol", symbol },
            { "base", this.safeCurrencyCode(baseId) },
            { "baseRate", this.safeNumber(baseData, "actual-rate") },
            { "quote", this.safeCurrencyCode(quoteId) },
            { "quoteRate", this.safeNumber(quoteData, "actual-rate") },
            { "period", 86400000 },
            { "timestamp", null },
            { "datetime", null },
            { "info", info },
        };
    }

    /**
     * @method
     * @name htx#fetchFundingRateHistory
     * @see https://huobiapi.github.io/docs/usdt_swap/v1/en/#general-query-historical-funding-rate
     * @see https://huobiapi.github.io/docs/coin_margined_swap/v1/en/#query-historical-funding-rate
     * @description fetches historical funding rate prices
     * @param {string} symbol unified symbol of the market to fetch the funding rate history for
     * @param {int} [since] not used by huobi, but filtered internally by ccxt
     * @param {int} [limit] not used by huobi, but filtered internally by ccxt
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [availble parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
     * @returns {object[]} a list of [funding rate structures]{@link https://docs.ccxt.com/?id=funding-rate-history-structure}
     */
    public async override Task<object> fetchFundingRateHistory(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchFundingRateHistory() requires a symbol argument")) ;
        }
        object paginate = false;
        var paginateparametersVariable = this.handleOptionAndParams(parameters, "fetchFundingRateHistory", "paginate");
        paginate = ((IList<object>)paginateparametersVariable)[0];
        parameters = ((IList<object>)paginateparametersVariable)[1];
        if (isTrue(paginate))
        {
            return await this.fetchPaginatedCallCursor("fetchFundingRateHistory", symbol, since, limit, parameters, "current_page", "page_index", 1, 50);
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "contract_code", getValue(market, "id") },
        };
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["page_size"] = limit;
        } else
        {
            ((IDictionary<string,object>)request)["page_size"] = 50; // max
        }
        object response = null;
        if (isTrue(getValue(market, "inverse")))
        {
            response = await this.contractPublicGetSwapApiV1SwapHistoricalFundingRate(this.extend(request, parameters));
        } else if (isTrue(getValue(market, "linear")))
        {
            response = await this.contractPublicGetLinearSwapApiV1SwapHistoricalFundingRate(this.extend(request, parameters));
        } else
        {
            throw new NotSupported ((string)add(this.id, " fetchFundingRateHistory() supports inverse and linear swaps only")) ;
        }
        //
        // {
        //     "status": "ok",
        //     "data": {
        //         "total_page": 62,
        //         "current_page": 1,
        //         "total_size": 1237,
        //         "data": [
        //             {
        //                 "avg_premium_index": "-0.000208064395065541",
        //                 "funding_rate": "0.000100000000000000",
        //                 "realized_rate": "0.000100000000000000",
        //                 "funding_time": "1638921600000",
        //                 "contract_code": "BTC-USDT",
        //                 "symbol": "BTC",
        //                 "fee_asset": "USDT"
        //             },
        //         ]
        //     },
        //     "ts": 1638939294277
        // }
        //
        object data = this.safeValue(response, "data");
        object cursor = this.safeValue(data, "current_page");
        object result = this.safeValue(data, "data", new List<object>() {});
        object rates = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(result)); postFixIncrement(ref i))
        {
            object entry = getValue(result, i);
            ((IDictionary<string,object>)entry)["current_page"] = cursor;
            object marketId = this.safeString(entry, "contract_code");
            object symbolInner = this.safeSymbol(marketId);
            object timestamp = this.safeInteger(entry, "funding_time");
            ((IList<object>)rates).Add(new Dictionary<string, object>() {
                { "info", entry },
                { "symbol", symbolInner },
                { "fundingRate", this.safeNumber(entry, "funding_rate") },
                { "timestamp", timestamp },
                { "datetime", this.iso8601(timestamp) },
            });
        }
        object sorted = this.sortBy(rates, "timestamp");
        return this.filterBySymbolSinceLimit(sorted, getValue(market, "symbol"), since, limit);
    }

    public override object parseFundingRate(object contract, object market = null)
    {
        //
        // {
        //      "status": "ok",
        //      "data": {
        //         "estimated_rate": "0.000100000000000000",
        //         "funding_rate": "0.000100000000000000",
        //         "contract_code": "BCH-USD",
        //         "symbol": "BCH",
        //         "fee_asset": "BCH",
        //         "funding_time": "1639094400000",
        //         "next_funding_time": "1639123200000"
        //     },
        //     "ts": 1639085854775
        // }
        //
        object nextFundingRate = this.safeNumber(contract, "estimated_rate");
        object fundingTimestamp = this.safeInteger(contract, "funding_time");
        object nextFundingTimestamp = this.safeInteger(contract, "next_funding_time");
        object fundingTimeString = this.safeString(contract, "funding_time");
        object nextFundingTimeString = this.safeString(contract, "next_funding_time");
        object millisecondsInterval = Precise.stringSub(nextFundingTimeString, fundingTimeString);
        object marketId = this.safeString(contract, "contract_code");
        object symbol = this.safeSymbol(marketId, market);
        return new Dictionary<string, object>() {
            { "info", contract },
            { "symbol", symbol },
            { "markPrice", null },
            { "indexPrice", null },
            { "interestRate", null },
            { "estimatedSettlePrice", null },
            { "timestamp", null },
            { "datetime", null },
            { "fundingRate", this.safeNumber(contract, "funding_rate") },
            { "fundingTimestamp", fundingTimestamp },
            { "fundingDatetime", this.iso8601(fundingTimestamp) },
            { "nextFundingRate", nextFundingRate },
            { "nextFundingTimestamp", nextFundingTimestamp },
            { "nextFundingDatetime", this.iso8601(nextFundingTimestamp) },
            { "previousFundingRate", null },
            { "previousFundingTimestamp", null },
            { "previousFundingDatetime", null },
            { "interval", this.parseFundingInterval(millisecondsInterval) },
        };
    }

    public virtual object parseFundingInterval(object interval)
    {
        object intervals = new Dictionary<string, object>() {
            { "3600000", "1h" },
            { "14400000", "4h" },
            { "28800000", "8h" },
            { "57600000", "16h" },
            { "86400000", "24h" },
        };
        return this.safeString(intervals, interval, interval);
    }

    /**
     * @method
     * @name htx#fetchFundingRate
     * @description fetch the current funding rate
     * @see https://huobiapi.github.io/docs/coin_margined_swap/v1/en/#query-funding-rate
     * @see https://huobiapi.github.io/docs/usdt_swap/v1/en/#general-query-funding-rate
     * @param {string} symbol unified market symbol
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [funding rate structure]{@link https://docs.ccxt.com/?id=funding-rate-structure}
     */
    public async override Task<object> fetchFundingRate(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "contract_code", getValue(market, "id") },
        };
        object response = null;
        if (isTrue(getValue(market, "inverse")))
        {
            response = await this.contractPublicGetSwapApiV1SwapFundingRate(this.extend(request, parameters));
        } else if (isTrue(getValue(market, "linear")))
        {
            response = await this.contractPublicGetLinearSwapApiV1SwapFundingRate(this.extend(request, parameters));
        } else
        {
            throw new NotSupported ((string)add(this.id, " fetchFundingRate() supports inverse and linear swaps only")) ;
        }
        //
        // {
        //     "status": "ok",
        //     "data": {
        //         "estimated_rate": "0.000100000000000000",
        //         "funding_rate": "0.000100000000000000",
        //         "contract_code": "BTC-USDT",
        //         "symbol": "BTC",
        //         "fee_asset": "USDT",
        //         "funding_time": "1603699200000",
        //         "next_funding_time": "1603728000000"
        //     },
        //     "ts": 1603696494714
        // }
        //
        object result = this.safeValue(response, "data", new Dictionary<string, object>() {});
        return this.parseFundingRate(result, market);
    }

    /**
     * @method
     * @name htx#fetchFundingRates
     * @description fetch the funding rate for multiple markets
     * @see https://huobiapi.github.io/docs/usdt_swap/v1/en/#general-query-a-batch-of-funding-rate
     * @see https://huobiapi.github.io/docs/coin_margined_swap/v1/en/#query-a-batch-of-funding-rate
     * @param {string[]|undefined} symbols list of unified market symbols
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} a list of [funding rate structures]{@link https://docs.ccxt.com/?id=funding-rates-structure}, indexed by market symbols
     */
    public async override Task<object> fetchFundingRates(object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        symbols = this.marketSymbols(symbols);
        object defaultSubType = this.safeString(this.options, "defaultSubType", "linear");
        object subType = null;
        var subTypeparametersVariable = this.handleOptionAndParams(parameters, "fetchFundingRates", "subType", defaultSubType);
        subType = ((IList<object>)subTypeparametersVariable)[0];
        parameters = ((IList<object>)subTypeparametersVariable)[1];
        if (isTrue(!isEqual(symbols, null)))
        {
            object firstSymbol = this.safeString(symbols, 0);
            object market = this.market(firstSymbol);
            object isLinear = getValue(market, "linear");
            subType = ((bool) isTrue(isLinear)) ? "linear" : "inverse";
        }
        object request = new Dictionary<string, object>() {};
        object response = null;
        if (isTrue(isEqual(subType, "linear")))
        {
            response = await this.contractPublicGetLinearSwapApiV1SwapBatchFundingRate(this.extend(request, parameters));
        } else if (isTrue(isEqual(subType, "inverse")))
        {
            response = await this.contractPublicGetSwapApiV1SwapBatchFundingRate(this.extend(request, parameters));
        } else
        {
            throw new NotSupported ((string)add(this.id, " fetchFundingRates() not support this market type")) ;
        }
        //
        //     {
        //         "status": "ok",
        //         "data": [
        //             {
        //                 "estimated_rate": "0.000100000000000000",
        //                 "funding_rate": "0.000100000000000000",
        //                 "contract_code": "MANA-USDT",
        //                 "symbol": "MANA",
        //                 "fee_asset": "USDT",
        //                 "funding_time": "1643356800000",
        //                 "next_funding_time": "1643385600000",
        //                 "trade_partition":"USDT"
        //             },
        //         ],
        //         "ts": 1643346173103
        //     }
        //
        object data = this.safeValue(response, "data", new List<object>() {});
        return this.parseFundingRates(data, symbols);
    }

    /**
     * @method
     * @name htx#fetchBorrowInterest
     * @description fetch the interest owed by the user for borrowing currency for margin trading
     * @see https://huobiapi.github.io/docs/spot/v1/en/#search-past-margin-orders-cross
     * @see https://huobiapi.github.io/docs/spot/v1/en/#search-past-margin-orders-isolated
     * @param {string} code unified currency code
     * @param {string} symbol unified market symbol when fetch interest in isolated markets
     * @param {int} [since] the earliest time in ms to fetch borrrow interest for
     * @param {int} [limit] the maximum number of structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} a list of [borrow interest structures]{@link https://docs.ccxt.com/?id=borrow-interest-structure}
     */
    public async override Task<object> fetchBorrowInterest(object code = null, object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object marginMode = null;
        var marginModeparametersVariable = this.handleMarginModeAndParams("fetchBorrowInterest", parameters);
        marginMode = ((IList<object>)marginModeparametersVariable)[0];
        parameters = ((IList<object>)marginModeparametersVariable)[1];
        marginMode = ((bool) isTrue((isEqual(marginMode, null)))) ? "cross" : marginMode;
        object request = new Dictionary<string, object>() {};
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["start-date"] = this.yyyymmdd(since);
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["size"] = limit;
        }
        object market = null;
        object response = null;
        if (isTrue(isEqual(marginMode, "isolated")))
        {
            if (isTrue(!isEqual(symbol, null)))
            {
                market = this.market(symbol);
                ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
            }
            response = await this.privateGetMarginLoanOrders(this.extend(request, parameters));
        } else
        {
            if (isTrue(!isEqual(code, null)))
            {
                object currency = this.currency(code);
                ((IDictionary<string,object>)request)["currency"] = getValue(currency, "id");
            }
            response = await this.privateGetCrossMarginLoanOrders(this.extend(request, parameters));
        }
        //
        //    {
        //        "status":"ok",
        //        "data":[
        //            {
        //                "loan-balance":"0.100000000000000000",
        //                "interest-balance":"0.000200000000000000",
        //                "loan-amount":"0.100000000000000000",
        //                "accrued-at":1511169724531,
        //                "interest-amount":"0.000200000000000000",
        //                "filled-points":"0.2",
        //                "filled-ht":"0.2",
        //                "currency":"btc",
        //                "id":394,
        //                "state":"accrual",
        //                "account-id":17747,
        //                "user-id":119913,
        //                "created-at":1511169724531
        //            }
        //        ]
        //    }
        //
        object data = this.safeValue(response, "data");
        object interest = this.parseBorrowInterests(data, market);
        return this.filterByCurrencySinceLimit(interest, code, since, limit);
    }

    public override object parseBorrowInterest(object info, object market = null)
    {
        // isolated
        //    {
        //        "interest-rate":"0.000040830000000000",
        //        "user-id":35930539,
        //        "account-id":48916071,
        //        "updated-at":1649320794195,
        //        "deduct-rate":"1",
        //        "day-interest-rate":"0.000980000000000000",
        //        "hour-interest-rate":"0.000040830000000000",
        //        "loan-balance":"100.790000000000000000",
        //        "interest-balance":"0.004115260000000000",
        //        "loan-amount":"100.790000000000000000",
        //        "paid-coin":"0.000000000000000000",
        //        "accrued-at":1649320794148,
        //        "created-at":1649320794148,
        //        "interest-amount":"0.004115260000000000",
        //        "deduct-amount":"0",
        //        "deduct-currency":"",
        //        "paid-point":"0.000000000000000000",
        //        "currency":"usdt",
        //        "symbol":"ltcusdt",
        //        "id":20242721,
        //    }
        //
        // cross
        //   {
        //       "id":3416576,
        //       "user-id":35930539,
        //       "account-id":48956839,
        //       "currency":"usdt",
        //       "loan-amount":"102",
        //       "loan-balance":"102",
        //       "interest-amount":"0.00416466",
        //       "interest-balance":"0.00416466",
        //       "created-at":1649322735333,
        //       "accrued-at":1649322735382,
        //       "state":"accrual",
        //       "filled-points":"0",
        //       "filled-ht":"0"
        //   }
        //
        object marketId = this.safeString(info, "symbol");
        object marginMode = ((bool) isTrue((isEqual(marketId, null)))) ? "cross" : "isolated";
        market = this.safeMarket(marketId);
        object symbol = this.safeString(market, "symbol");
        object timestamp = this.safeInteger(info, "accrued-at");
        return new Dictionary<string, object>() {
            { "info", info },
            { "symbol", symbol },
            { "currency", this.safeCurrencyCode(this.safeString(info, "currency")) },
            { "interest", this.safeNumber(info, "interest-amount") },
            { "interestRate", this.safeNumber(info, "interest-rate") },
            { "amountBorrowed", this.safeNumber(info, "loan-amount") },
            { "marginMode", marginMode },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
        };
    }

    public override object nonce()
    {
        return subtract(this.milliseconds(), getValue(this.options, "timeDifference"));
    }

    public override object sign(object path, object api = null, object method = null, object parameters = null, object headers = null, object body = null)
    {
        api ??= "public";
        method ??= "GET";
        parameters ??= new Dictionary<string, object>();
        object url = "/";
        object query = this.omit(parameters, this.extractParams(path));
        if (isTrue((api is string)))
        {
            // signing implementation for the old endpoints
            if (isTrue(isTrue((isEqual(api, "public"))) || isTrue((isEqual(api, "private")))))
            {
                url = add(url, this.version);
            } else if (isTrue(isTrue((isEqual(api, "v2Public"))) || isTrue((isEqual(api, "v2Private")))))
            {
                url = add(url, "v2");
            }
            url = add(url, add("/", this.implodeParams(path, parameters)));
            if (isTrue(isTrue(isEqual(api, "private")) || isTrue(isEqual(api, "v2Private"))))
            {
                this.checkRequiredCredentials();
                object timestamp = this.ymdhms(this.nonce(), "T");
                object request = new Dictionary<string, object>() {
                    { "SignatureMethod", "HmacSHA256" },
                    { "SignatureVersion", "2" },
                    { "AccessKeyId", this.apiKey },
                    { "Timestamp", timestamp },
                };
                if (isTrue(!isEqual(method, "POST")))
                {
                    request = this.extend(request, query);
                }
                object sortedRequest = this.keysort(request);
                object auth = this.urlencode(sortedRequest, true); // true is a go only requirment
                // unfortunately, PHP demands double quotes for the escaped newline symbol
                object payload = String.Join("\n", ((IList<object>)new List<object>() {method, this.hostname, url, auth}).ToArray()); // eslint-disable-line quotes
                object signature = this.hmac(this.encode(payload), this.encode(this.secret), sha256, "base64");
                auth = add(auth, add("&", this.urlencode(new Dictionary<string, object>() {
    { "Signature", signature },
})));
                url = add(url, add("?", auth));
                if (isTrue(isEqual(method, "POST")))
                {
                    body = this.json(query);
                    headers = new Dictionary<string, object>() {
                        { "Content-Type", "application/json" },
                    };
                } else
                {
                    headers = new Dictionary<string, object>() {
                        { "Content-Type", "application/x-www-form-urlencoded" },
                    };
                }
            } else
            {
                if (isTrue(getArrayLength(new List<object>(((IDictionary<string,object>)query).Keys))))
                {
                    url = add(url, add("?", this.urlencode(query)));
                }
            }
            url = add(this.implodeParams(getValue(getValue(this.urls, "api"), api), new Dictionary<string, object>() {
    { "hostname", this.hostname },
}), url);
        } else
        {
            // signing implementation for the new endpoints
            // const [ type, access ] = api;
            object type = this.safeString(api, 0);
            object access = this.safeString(api, 1);
            object levelOneNestedPath = this.safeString(api, 2);
            object levelTwoNestedPath = this.safeString(api, 3);
            object hostname = null;
            object hostnames = this.safeValue(getValue(this.urls, "hostnames"), type);
            if (isTrue(!(hostnames is string)))
            {
                hostnames = this.safeValue(hostnames, levelOneNestedPath);
                if (isTrue(isTrue((!(hostnames is string))) && isTrue((!isEqual(levelTwoNestedPath, null)))))
                {
                    hostnames = this.safeValue(hostnames, levelTwoNestedPath);
                }
            }
            hostname = hostnames;
            url = add(url, this.implodeParams(path, parameters));
            if (isTrue(isEqual(access, "public")))
            {
                if (isTrue(getArrayLength(new List<object>(((IDictionary<string,object>)query).Keys))))
                {
                    url = add(url, add("?", this.urlencode(query)));
                }
            } else if (isTrue(isEqual(access, "private")))
            {
                this.checkRequiredCredentials();
                if (isTrue(isEqual(method, "POST")))
                {
                    object options = this.safeValue(this.options, "broker", new Dictionary<string, object>() {});
                    object id = this.safeString(options, "id", "AA03022abc");
                    if (isTrue(isTrue(isEqual(getIndexOf(path, "cancel"), -1)) && isTrue(((string)path).EndsWith(((string)"order")))))
                    {
                        // swap order placement
                        object channelCode = this.safeString(parameters, "channel_code");
                        if (isTrue(isEqual(channelCode, null)))
                        {
                            ((IDictionary<string,object>)parameters)["channel_code"] = id;
                        }
                    } else if (isTrue(((string)path).EndsWith(((string)"orders/place"))))
                    {
                        // spot order placement
                        object clientOrderId = this.safeString(parameters, "client-order-id");
                        if (isTrue(isEqual(clientOrderId, null)))
                        {
                            ((IDictionary<string,object>)parameters)["client-order-id"] = add(id, this.uuid());
                        }
                    }
                }
                object timestamp = this.ymdhms(this.nonce(), "T");
                object request = new Dictionary<string, object>() {
                    { "SignatureMethod", "HmacSHA256" },
                    { "SignatureVersion", "2" },
                    { "AccessKeyId", this.apiKey },
                    { "Timestamp", timestamp },
                };
                // sorting needs such flow exactly, before urlencoding (more at: https://github.com/ccxt/ccxt/issues/24930 )
                request = ((object)this.keysort(request));
                if (isTrue(!isEqual(method, "POST")))
                {
                    object sortedQuery = ((object)this.keysort(query));
                    request = this.extend(request, sortedQuery);
                }
                object auth = ((string)this.urlencode(request, true)).Replace((string)"%2c", (string)"%2C"); // in c# it manually needs to be uppercased
                // unfortunately, PHP demands double quotes for the escaped newline symbol
                object payload = String.Join("\n", ((IList<object>)new List<object>() {method, hostname, url, auth}).ToArray()); // eslint-disable-line quotes
                object signature = this.hmac(this.encode(payload), this.encode(this.secret), sha256, "base64");
                auth = add(auth, add("&", this.urlencode(new Dictionary<string, object>() {
    { "Signature", signature },
})));
                url = add(url, add("?", auth));
                if (isTrue(isEqual(method, "POST")))
                {
                    body = this.json(query);
                    if (isTrue(isEqual(getArrayLength(body), 2)))
                    {
                        body = "{}";
                    }
                    headers = new Dictionary<string, object>() {
                        { "Content-Type", "application/json" },
                    };
                } else
                {
                    headers = new Dictionary<string, object>() {
                        { "Content-Type", "application/x-www-form-urlencoded" },
                    };
                }
            }
            url = add(this.implodeParams(getValue(getValue(this.urls, "api"), type), new Dictionary<string, object>() {
    { "hostname", hostname },
}), url);
        }
        return new Dictionary<string, object>() {
            { "url", url },
            { "method", method },
            { "body", body },
            { "headers", headers },
        };
    }

    public override object handleErrors(object httpCode, object reason, object url, object method, object headers, object body, object response, object requestHeaders, object requestBody)
    {
        if (isTrue(isEqual(response, null)))
        {
            return null;  // fallback to default error handler
        }
        if (isTrue(inOp(response, "status")))
        {
            //
            //     {"status":"error","err-code":"o-amount-min-error","err-msg":"limit order amount error, min: `0.001`","data":null}
            //     {"status":"ok","data":{"errors":[{"order_id":"1349442392365359104","err_code":1061,"err_msg":"The order does not exist."}],"successes":""},"ts":1741773744526}
            //
            object status = this.safeString(response, "status");
            if (isTrue(isEqual(status, "error")))
            {
                object code = this.safeString2(response, "err-code", "err_code");
                object feedback = add(add(this.id, " "), body);
                this.throwBroadlyMatchedException(getValue(this.exceptions, "broad"), body, feedback);
                this.throwExactlyMatchedException(getValue(this.exceptions, "exact"), code, feedback);
                object message = this.safeString2(response, "err-msg", "err_msg");
                this.throwExactlyMatchedException(getValue(this.exceptions, "exact"), message, feedback);
                throw new ExchangeError ((string)feedback) ;
            }
        }
        if (isTrue(inOp(response, "code")))
        {
            // {code: '1003', message: 'invalid signature'}
            object feedback = add(add(this.id, " "), body);
            object code = this.safeString(response, "code");
            this.throwExactlyMatchedException(getValue(this.exceptions, "exact"), code, feedback);
        }
        object data = this.safeDict(response, "data");
        object errorsList = this.safeList(data, "errors");
        if (isTrue(!isEqual(errorsList, null)))
        {
            object first = this.safeDict(errorsList, 0);
            object errcode = this.safeString(first, "err_code");
            object errmessage = this.safeString(first, "err_msg");
            object feedBack = add(add(this.id, " "), body);
            this.throwExactlyMatchedException(getValue(this.exceptions, "exact"), errcode, feedBack);
            this.throwExactlyMatchedException(getValue(this.exceptions, "exact"), errmessage, feedBack);
        }
        return null;
    }

    /**
     * @method
     * @name htx#fetchFundingHistory
     * @description fetch the history of funding payments paid and received on this account
     * @see https://huobiapi.github.io/docs/usdt_swap/v1/en/#general-query-account-financial-records-via-multiple-fields-new   // linear swaps
     * @see https://huobiapi.github.io/docs/dm/v1/en/#query-financial-records-via-multiple-fields-new                          // coin-m futures
     * @see https://huobiapi.github.io/docs/coin_margined_swap/v1/en/#query-financial-records-via-multiple-fields-new          // coin-m swaps
     * @param {string} symbol unified market symbol
     * @param {int} [since] the earliest time in ms to fetch funding history for
     * @param {int} [limit] the maximum number of funding history structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [funding history structure]{@link https://docs.ccxt.com/?id=funding-history-structure}
     */
    public async override Task<object> fetchFundingHistory(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        var marketTypequeryVariable = this.handleMarketTypeAndParams("fetchFundingHistory", market, parameters);
        var marketType = ((IList<object>) marketTypequeryVariable)[0];
        var query = ((IList<object>) marketTypequeryVariable)[1];
        object request = new Dictionary<string, object>() {
            { "type", "30,31" },
        };
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["start_date"] = since;
        }
        object response = null;
        if (isTrue(isEqual(marketType, "swap")))
        {
            ((IDictionary<string,object>)request)["contract"] = getValue(market, "id");
            if (isTrue(getValue(market, "linear")))
            {
                //
                //    {
                //        "status": "ok",
                //        "data": {
                //           "financial_record": [
                //               {
                //                   "id": "1320088022",
                //                   "type": "30",
                //                   "amount": "0.004732510000000000",
                //                   "ts": "1641168019321",
                //                   "contract_code": "BTC-USDT",
                //                   "asset": "USDT",
                //                   "margin_account": "BTC-USDT",
                //                   "face_margin_account": ''
                //               },
                //           ],
                //           "remain_size": "0",
                //           "next_id": null
                //        },
                //        "ts": "1641189898425"
                //    }
                //
                object marginMode = null;
                var marginModeparametersVariable = this.handleMarginModeAndParams("fetchFundingHistory", parameters);
                marginMode = ((IList<object>)marginModeparametersVariable)[0];
                parameters = ((IList<object>)marginModeparametersVariable)[1];
                marginMode = ((bool) isTrue((isEqual(marginMode, null)))) ? "cross" : marginMode;
                if (isTrue(isEqual(marginMode, "isolated")))
                {
                    ((IDictionary<string,object>)request)["mar_acct"] = getValue(market, "id");
                } else
                {
                    ((IDictionary<string,object>)request)["mar_acct"] = getValue(market, "quoteId");
                }
                response = await this.contractPrivatePostLinearSwapApiV3SwapFinancialRecordExact(this.extend(request, query));
            } else
            {
                //
                //     {
                //         "code": 200,
                //         "msg": "",
                //         "data": [
                //             {
                //                 "query_id": 138798248,
                //                 "id": 117840,
                //                 "type": 5,
                //                 "amount": -0.024464850000000000,
                //                 "ts": 1638758435635,
                //                 "contract_code": "BTC-USDT-211210",
                //                 "asset": "USDT",
                //                 "margin_account": "USDT",
                //                 "face_margin_account": ""
                //             }
                //         ],
                //         "ts": 1604312615051
                //     }
                //
                response = await this.contractPrivatePostSwapApiV3SwapFinancialRecordExact(this.extend(request, query));
            }
        } else
        {
            ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
            response = await this.contractPrivatePostApiV3ContractFinancialRecordExact(this.extend(request, query));
        }
        object data = this.safeList(response, "data", new List<object>() {});
        return this.parseIncomes(data, market, since, limit);
    }

    /**
     * @method
     * @name htx#setLeverage
     * @description set the level of leverage for a market
     * @see https://huobiapi.github.io/docs/usdt_swap/v1/en/#isolated-switch-leverage
     * @see https://huobiapi.github.io/docs/usdt_swap/v1/en/#cross-switch-leverage
     * @see https://huobiapi.github.io/docs/coin_margined_swap/v1/en/#switch-leverage
     * @see https://huobiapi.github.io/docs/dm/v1/en/#switch-leverage  // Coin-m futures
     * @param {float} leverage the rate of leverage
     * @param {string} symbol unified market symbol
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} response from the exchange
     */
    public async override Task<object> setLeverage(object leverage, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " setLeverage() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        var marketTypequeryVariable = this.handleMarketTypeAndParams("setLeverage", market, parameters);
        var marketType = ((IList<object>) marketTypequeryVariable)[0];
        var query = ((IList<object>) marketTypequeryVariable)[1];
        object request = new Dictionary<string, object>() {
            { "lever_rate", leverage },
        };
        if (isTrue(isTrue(isEqual(marketType, "future")) && isTrue(getValue(market, "inverse"))))
        {
            ((IDictionary<string,object>)request)["symbol"] = getValue(market, "settleId");
        } else
        {
            ((IDictionary<string,object>)request)["contract_code"] = getValue(market, "id");
        }
        object response = null;
        if (isTrue(getValue(market, "linear")))
        {
            object marginMode = null;
            var marginModeparametersVariable = this.handleMarginModeAndParams("setLeverage", parameters);
            marginMode = ((IList<object>)marginModeparametersVariable)[0];
            parameters = ((IList<object>)marginModeparametersVariable)[1];
            marginMode = ((bool) isTrue((isEqual(marginMode, null)))) ? "cross" : marginMode;
            if (isTrue(isEqual(marginMode, "isolated")))
            {
                response = await this.contractPrivatePostLinearSwapApiV1SwapSwitchLeverRate(this.extend(request, query));
            } else if (isTrue(isEqual(marginMode, "cross")))
            {
                response = await this.contractPrivatePostLinearSwapApiV1SwapCrossSwitchLeverRate(this.extend(request, query));
            } else
            {
                throw new NotSupported ((string)add(this.id, " setLeverage() not support this market type")) ;
            }
        } else
        {
            if (isTrue(isEqual(marketType, "future")))
            {
                response = await this.contractPrivatePostApiV1ContractSwitchLeverRate(this.extend(request, query));
            } else if (isTrue(isEqual(marketType, "swap")))
            {
                response = await this.contractPrivatePostSwapApiV1SwapSwitchLeverRate(this.extend(request, query));
            } else
            {
                throw new NotSupported ((string)add(this.id, " setLeverage() not support this market type")) ;
            }
        }
        return response;
    }

    public override object parseIncome(object income, object market = null)
    {
        //
        //     {
        //       "id": "1667161118",
        //       "symbol": "BTC",
        //       "type": "31",
        //       "amount": "-2.11306593188E-7",
        //       "ts": "1641139308983",
        //       "contract_code": "BTC-USD"
        //     }
        //
        object marketId = this.safeString(income, "contract_code");
        object symbol = this.safeSymbol(marketId, market);
        object amount = this.safeNumber(income, "amount");
        object timestamp = this.safeInteger(income, "ts");
        object id = this.safeString(income, "id");
        object currencyId = this.safeString2(income, "symbol", "asset");
        object code = this.safeCurrencyCode(currencyId);
        return new Dictionary<string, object>() {
            { "info", income },
            { "symbol", symbol },
            { "code", code },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "id", id },
            { "amount", amount },
        };
    }

    public override object parsePosition(object position, object market = null)
    {
        //
        //    {
        //        "symbol": "BTC",
        //        "contract_code": "BTC-USDT",
        //        "volume": "1.000000000000000000",
        //        "available": "1.000000000000000000",
        //        "frozen": "0E-18",
        //        "cost_open": "47162.000000000000000000",
        //        "cost_hold": "47151.300000000000000000",
        //        "profit_unreal": "0.007300000000000000",
        //        "profit_rate": "-0.000144183876850008",
        //        "lever_rate": "2",
        //        "position_margin": "23.579300000000000000",
        //        "direction": "buy",
        //        "profit": "-0.003400000000000000",
        //        "last_price": "47158.6",
        //        "margin_asset": "USDT",
        //        "margin_mode": "isolated",
        //        "margin_account": "BTC-USDT",
        //        "margin_balance": "24.973020070000000000",
        //        "margin_position": "23.579300000000000000",
        //        "margin_frozen": "0",
        //        "margin_available": "1.393720070000000000",
        //        "profit_real": "0E-18",
        //        "risk_rate": "1.044107779705080303",
        //        "withdraw_available": "1.386420070000000000000000000000000000",
        //        "liquidation_price": "22353.229148614609571788",
        //        "adjust_factor": "0.015000000000000000",
        //        "margin_static": "24.965720070000000000"
        //    }
        //
        market = this.safeMarket(this.safeString(position, "contract_code"));
        object symbol = getValue(market, "symbol");
        object contracts = this.safeString(position, "volume");
        object contractSize = this.safeValue(market, "contractSize");
        object contractSizeString = this.numberToString(contractSize);
        object entryPrice = this.safeNumber(position, "cost_open");
        object initialMargin = this.safeString(position, "position_margin");
        object rawSide = this.safeString(position, "direction");
        object side = ((bool) isTrue((isEqual(rawSide, "buy")))) ? "long" : "short";
        object unrealizedProfit = this.safeNumber(position, "profit_unreal");
        object marginMode = this.safeString(position, "margin_mode");
        object leverage = this.safeString(position, "lever_rate");
        object percentage = Precise.stringMul(this.safeString(position, "profit_rate"), "100");
        object lastPrice = this.safeString(position, "last_price");
        object faceValue = Precise.stringMul(contracts, contractSizeString);
        object notional = null;
        if (isTrue(getValue(market, "linear")))
        {
            notional = Precise.stringMul(faceValue, lastPrice);
        } else
        {
            notional = Precise.stringDiv(faceValue, lastPrice);
            marginMode = "cross";
        }
        object intialMarginPercentage = Precise.stringDiv(initialMargin, notional);
        object collateral = this.safeString(position, "margin_balance");
        object liquidationPrice = this.safeNumber(position, "liquidation_price");
        object adjustmentFactor = this.safeString(position, "adjust_factor");
        object maintenanceMarginPercentage = Precise.stringDiv(adjustmentFactor, leverage);
        object maintenanceMargin = Precise.stringMul(maintenanceMarginPercentage, notional);
        object marginRatio = Precise.stringDiv(maintenanceMargin, collateral);
        return this.safePosition(new Dictionary<string, object>() {
            { "info", position },
            { "id", null },
            { "symbol", symbol },
            { "contracts", this.parseNumber(contracts) },
            { "contractSize", contractSize },
            { "entryPrice", entryPrice },
            { "collateral", this.parseNumber(collateral) },
            { "side", side },
            { "unrealizedPnl", unrealizedProfit },
            { "leverage", this.parseNumber(leverage) },
            { "percentage", this.parseNumber(percentage) },
            { "marginMode", marginMode },
            { "notional", this.parseNumber(notional) },
            { "markPrice", null },
            { "lastPrice", null },
            { "liquidationPrice", liquidationPrice },
            { "initialMargin", this.parseNumber(initialMargin) },
            { "initialMarginPercentage", this.parseNumber(intialMarginPercentage) },
            { "maintenanceMargin", this.parseNumber(maintenanceMargin) },
            { "maintenanceMarginPercentage", this.parseNumber(maintenanceMarginPercentage) },
            { "marginRatio", this.parseNumber(marginRatio) },
            { "timestamp", null },
            { "datetime", null },
            { "hedged", null },
            { "lastUpdateTimestamp", null },
            { "stopLossPrice", null },
            { "takeProfitPrice", null },
        });
    }

    /**
     * @method
     * @name htx#fetchPositions
     * @description fetch all open positions
     * @see https://huobiapi.github.io/docs/usdt_swap/v1/en/#cross-query-user-39-s-position-information
     * @see https://huobiapi.github.io/docs/usdt_swap/v1/en/#isolated-query-user-s-position-information
     * @see https://huobiapi.github.io/docs/coin_margined_swap/v1/en/#query-user-s-position-information
     * @see https://huobiapi.github.io/docs/dm/v1/en/#query-user-s-position-information
     * @param {string[]} [symbols] list of unified market symbols
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.subType] 'linear' or 'inverse'
     * @param {string} [params.type] *inverse only* 'future', or 'swap'
     * @param {string} [params.marginMode] *linear only* 'cross' or 'isolated'
     * @returns {object[]} a list of [position structure]{@link https://docs.ccxt.com/?id=position-structure}
     */
    public async override Task<object> fetchPositions(object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        symbols = this.marketSymbols(symbols);
        object market = null;
        if (isTrue(!isEqual(symbols, null)))
        {
            object symbolsLength = getArrayLength(symbols);
            if (isTrue(isGreaterThan(symbolsLength, 0)))
            {
                object first = this.safeString(symbols, 0);
                market = this.market(first);
            }
        }
        object marginMode = null;
        var marginModeparametersVariable = this.handleMarginModeAndParams("fetchPositions", parameters, "cross");
        marginMode = ((IList<object>)marginModeparametersVariable)[0];
        parameters = ((IList<object>)marginModeparametersVariable)[1];
        object subType = null;
        var subTypeparametersVariable = this.handleSubTypeAndParams("fetchPositions", market, parameters, "linear");
        subType = ((IList<object>)subTypeparametersVariable)[0];
        parameters = ((IList<object>)subTypeparametersVariable)[1];
        object marketType = null;
        var marketTypeparametersVariable = this.handleMarketTypeAndParams("fetchPositions", market, parameters);
        marketType = ((IList<object>)marketTypeparametersVariable)[0];
        parameters = ((IList<object>)marketTypeparametersVariable)[1];
        if (isTrue(isEqual(marketType, "spot")))
        {
            marketType = "future";
        }
        object response = null;
        if (isTrue(isEqual(subType, "linear")))
        {
            if (isTrue(isEqual(marginMode, "isolated")))
            {
                response = await this.contractPrivatePostLinearSwapApiV1SwapPositionInfo(parameters);
            } else if (isTrue(isEqual(marginMode, "cross")))
            {
                response = await this.contractPrivatePostLinearSwapApiV1SwapCrossPositionInfo(parameters);
            } else
            {
                throw new NotSupported ((string)add(this.id, " fetchPositions() not support this market type")) ;
            }
        } else
        {
            if (isTrue(isEqual(marketType, "future")))
            {
                response = await this.contractPrivatePostApiV1ContractPositionInfo(parameters);
            } else if (isTrue(isEqual(marketType, "swap")))
            {
                response = await this.contractPrivatePostSwapApiV1SwapPositionInfo(parameters);
            } else
            {
                throw new NotSupported ((string)add(this.id, " fetchPositions() not support this market type")) ;
            }
        }
        object data = this.safeValue(response, "data", new List<object>() {});
        object timestamp = this.safeInteger(response, "ts");
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
        {
            object position = getValue(data, i);
            object parsed = this.parsePosition(position);
            ((IList<object>)result).Add(this.extend(parsed, new Dictionary<string, object>() {
                { "timestamp", timestamp },
                { "datetime", this.iso8601(timestamp) },
            }));
        }
        return this.filterByArrayPositions(result, "symbol", symbols, false);
    }

    /**
     * @method
     * @name htx#fetchPosition
     * @description fetch data on a single open contract trade position
     * @see https://huobiapi.github.io/docs/usdt_swap/v1/en/#cross-query-assets-and-positions
     * @see https://huobiapi.github.io/docs/usdt_swap/v1/en/#isolated-query-assets-and-positions
     * @see https://huobiapi.github.io/docs/coin_margined_swap/v1/en/#query-assets-and-positions
     * @see https://huobiapi.github.io/docs/dm/v1/en/#query-assets-and-positions
     * @param {string} symbol unified market symbol of the market the position is held in, default is undefined
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [position structure]{@link https://docs.ccxt.com/?id=position-structure}
     */
    public async override Task<object> fetchPosition(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object marginMode = null;
        var marginModeparametersVariable = this.handleMarginModeAndParams("fetchPosition", parameters);
        marginMode = ((IList<object>)marginModeparametersVariable)[0];
        parameters = ((IList<object>)marginModeparametersVariable)[1];
        marginMode = ((bool) isTrue((isEqual(marginMode, null)))) ? "cross" : marginMode;
        var marketTypequeryVariable = this.handleMarketTypeAndParams("fetchPosition", market, parameters);
        var marketType = ((IList<object>) marketTypequeryVariable)[0];
        var query = ((IList<object>) marketTypequeryVariable)[1];
        object request = new Dictionary<string, object>() {};
        if (isTrue(isTrue(getValue(market, "future")) && isTrue(getValue(market, "inverse"))))
        {
            ((IDictionary<string,object>)request)["symbol"] = getValue(market, "settleId");
        } else
        {
            if (isTrue(isEqual(marginMode, "cross")))
            {
                ((IDictionary<string,object>)request)["margin_account"] = "USDT"; // only allowed value
            }
            ((IDictionary<string,object>)request)["contract_code"] = getValue(market, "id");
        }
        object response = null;
        if (isTrue(getValue(market, "linear")))
        {
            if (isTrue(isEqual(marginMode, "isolated")))
            {
                response = await this.contractPrivatePostLinearSwapApiV1SwapAccountPositionInfo(this.extend(request, query));
            } else if (isTrue(isEqual(marginMode, "cross")))
            {
                response = await this.contractPrivatePostLinearSwapApiV1SwapCrossAccountPositionInfo(this.extend(request, query));
            } else
            {
                throw new NotSupported ((string)add(this.id, " fetchPosition() not support this market type")) ;
            }
        } else
        {
            if (isTrue(isEqual(marketType, "future")))
            {
                response = await this.contractPrivatePostApiV1ContractAccountPositionInfo(this.extend(request, query));
            } else if (isTrue(isEqual(marketType, "swap")))
            {
                response = await this.contractPrivatePostSwapApiV1SwapAccountPositionInfo(this.extend(request, query));
            } else
            {
                throw new NotSupported ((string)add(this.id, " setLeverage() not support this market type")) ;
            }
        }
        object data = this.safeValue(response, "data");
        object account = null;
        if (isTrue(isEqual(marginMode, "cross")))
        {
            account = data;
        } else
        {
            account = this.safeValue(data, 0);
        }
        object omitted = this.omit(account, new List<object>() {"positions"});
        object positions = this.safeValue(account, "positions");
        object position = null;
        if (isTrue(isTrue(getValue(market, "future")) && isTrue(getValue(market, "inverse"))))
        {
            for (object i = 0; isLessThan(i, getArrayLength(positions)); postFixIncrement(ref i))
            {
                object entry = getValue(positions, i);
                if (isTrue(isEqual(getValue(entry, "contract_code"), getValue(market, "id"))))
                {
                    position = entry;
                    break;
                }
            }
        } else
        {
            position = this.safeValue(positions, 0);
        }
        object timestamp = this.safeInteger(response, "ts");
        object parsed = this.parsePosition(this.extend(position, omitted));
        ((IDictionary<string,object>)parsed)["timestamp"] = timestamp;
        ((IDictionary<string,object>)parsed)["datetime"] = this.iso8601(timestamp);
        return parsed;
    }

    public virtual object parseLedgerEntryType(object type)
    {
        object types = new Dictionary<string, object>() {
            { "trade", "trade" },
            { "etf", "trade" },
            { "transact-fee", "fee" },
            { "fee-deduction", "fee" },
            { "transfer", "transfer" },
            { "credit", "credit" },
            { "liquidation", "trade" },
            { "interest", "credit" },
            { "deposit", "deposit" },
            { "withdraw", "withdrawal" },
            { "withdraw-fee", "fee" },
            { "exchange", "exchange" },
            { "other-types", "transfer" },
            { "rebate", "rebate" },
        };
        return this.safeString(types, type, type);
    }

    public override object parseLedgerEntry(object item, object currency = null)
    {
        //
        //     {
        //         "accountId": 10000001,
        //         "currency": "usdt",
        //         "transactAmt": 10.000000000000000000,
        //         "transactType": "transfer",
        //         "transferType": "margin-transfer-out",
        //         "transactId": 0,
        //         "transactTime": 1629882331066,
        //         "transferer": 28483123,
        //         "transferee": 13496526
        //     }
        //
        object currencyId = this.safeString(item, "currency");
        object code = this.safeCurrencyCode(currencyId, currency);
        currency = this.safeCurrency(currencyId, currency);
        object id = this.safeString(item, "transactId");
        object transferType = this.safeString(item, "transferType");
        object timestamp = this.safeInteger(item, "transactTime");
        object account = this.safeString(item, "accountId");
        return this.safeLedgerEntry(new Dictionary<string, object>() {
            { "info", item },
            { "id", id },
            { "direction", this.safeString(item, "direction") },
            { "account", account },
            { "referenceId", id },
            { "referenceAccount", account },
            { "type", this.parseLedgerEntryType(transferType) },
            { "currency", code },
            { "amount", this.safeNumber(item, "transactAmt") },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "before", null },
            { "after", null },
            { "status", null },
            { "fee", null },
        }, currency);
    }

    /**
     * @method
     * @name htx#fetchLedger
     * @description fetch the history of changes, actions done by the user or operations that altered the balance of the user
     * @see https://huobiapi.github.io/docs/spot/v1/en/#get-account-history
     * @param {string} [code] unified currency code, default is undefined
     * @param {int} [since] timestamp in ms of the earliest ledger entry, default is undefined
     * @param {int} [limit] max number of ledger entries to return, default is undefined
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {int} [params.until] the latest time in ms to fetch entries for
     * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [available parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
     * @returns {object} a [ledger structure]{@link https://docs.ccxt.com/?id=ledger-entry-structure}
     */
    public async override Task<object> fetchLedger(object code = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object paginate = false;
        var paginateparametersVariable = this.handleOptionAndParams(parameters, "fetchLedger", "paginate");
        paginate = ((IList<object>)paginateparametersVariable)[0];
        parameters = ((IList<object>)paginateparametersVariable)[1];
        if (isTrue(paginate))
        {
            return await this.fetchPaginatedCallDynamic("fetchLedger", code, since, limit, parameters, 500);
        }
        object accountId = await this.fetchAccountIdByType("spot", null, null, parameters);
        object request = new Dictionary<string, object>() {
            { "accountId", accountId },
        };
        object currency = null;
        if (isTrue(!isEqual(code, null)))
        {
            currency = this.currency(code);
            ((IDictionary<string,object>)request)["currency"] = getValue(currency, "id");
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["startTime"] = since;
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit; // max 500
        }
        var requestparametersVariable = this.handleUntilOption("endTime", request, parameters);
        request = ((IList<object>)requestparametersVariable)[0];
        parameters = ((IList<object>)requestparametersVariable)[1];
        object response = await this.spotPrivateGetV2AccountLedger(this.extend(request, parameters));
        //
        //     {
        //         "code": 200,
        //         "message": "success",
        //         "data": [
        //             {
        //                 "accountId": 10000001,
        //                 "currency": "usdt",
        //                 "transactAmt": 10.000000000000000000,
        //                 "transactType": "transfer",
        //                 "transferType": "margin-transfer-out",
        //                 "transactId": 0,
        //                 "transactTime": 1629882331066,
        //                 "transferer": 28483123,
        //                 "transferee": 13496526
        //             },
        //             {
        //                 "accountId": 10000001,
        //                 "currency": "usdt",
        //                 "transactAmt": -10.000000000000000000,
        //                 "transactType": "transfer",
        //                 "transferType": "margin-transfer-in",
        //                 "transactId": 0,
        //                 "transactTime": 1629882096562,
        //                 "transferer": 13496526,
        //                 "transferee": 28483123
        //             }
        //         ],
        //         "nextId": 1624316679,
        //         "ok": true
        //     }
        //
        object data = this.safeValue(response, "data", new List<object>() {});
        return this.parseLedger(data, currency, since, limit);
    }

    /**
     * @method
     * @name htx#fetchLeverageTiers
     * @description retrieve information on the maximum leverage, and maintenance margin for trades of varying trade sizes
     * @param {string[]|undefined} symbols list of unified market symbols
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a dictionary of [leverage tiers structures]{@link https://docs.ccxt.com/?id=leverage-tiers-structure}, indexed by market symbols
     */
    public async override Task<object> fetchLeverageTiers(object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.contractPublicGetLinearSwapApiV1SwapAdjustfactor(parameters);
        //
        //    {
        //        "status": "ok",
        //        "data": [
        //            {
        //                "symbol": "MANA",
        //                "contract_code": "MANA-USDT",
        //                "margin_mode": "isolated",
        //                "trade_partition": "USDT",
        //                "list": [
        //                    {
        //                        "lever_rate": 75,
        //                        "ladders": [
        //                            {
        //                                "ladder": 0,
        //                                "min_size": 0,
        //                                "max_size": 999,
        //                                "adjust_factor": 0.7
        //                            },
        //                            ...
        //                        ]
        //                    }
        //                    ...
        //                ]
        //            },
        //            ...
        //        ]
        //    }
        //
        object data = this.safeList(response, "data", new List<object>() {});
        return this.parseLeverageTiers(data, symbols, "contract_code");
    }

    public override object parseMarketLeverageTiers(object info, object market = null)
    {
        object currencyId = this.safeString(info, "trade_partition");
        object marketId = this.safeString(info, "contract_code");
        object tiers = new List<object>() {};
        object brackets = this.safeList(info, "list", new List<object>() {});
        for (object i = 0; isLessThan(i, getArrayLength(brackets)); postFixIncrement(ref i))
        {
            object item = getValue(brackets, i);
            object leverage = this.safeString(item, "lever_rate");
            object ladders = this.safeList(item, "ladders", new List<object>() {});
            for (object k = 0; isLessThan(k, getArrayLength(ladders)); postFixIncrement(ref k))
            {
                object bracket = getValue(ladders, k);
                object adjustFactor = this.safeString(bracket, "adjust_factor");
                ((IList<object>)tiers).Add(new Dictionary<string, object>() {
                    { "tier", this.safeInteger(bracket, "ladder") },
                    { "symbol", this.safeSymbol(marketId, market, null, "swap") },
                    { "currency", this.safeCurrencyCode(currencyId) },
                    { "minNotional", this.safeNumber(bracket, "min_size") },
                    { "maxNotional", this.safeNumber(bracket, "max_size") },
                    { "maintenanceMarginRate", this.parseNumber(Precise.stringDiv(adjustFactor, leverage)) },
                    { "maxLeverage", this.parseNumber(leverage) },
                    { "info", bracket },
                });
            }
        }
        return tiers;
    }

    /**
     * @method
     * @name htx#fetchOpenInterestHistory
     * @description Retrieves the open interest history of a currency
     * @see https://huobiapi.github.io/docs/dm/v1/en/#query-information-on-open-interest
     * @see https://huobiapi.github.io/docs/coin_margined_swap/v1/en/#query-information-on-open-interest
     * @see https://huobiapi.github.io/docs/usdt_swap/v1/en/#general-query-information-on-open-interest
     * @param {string} symbol Unified CCXT market symbol
     * @param {string} timeframe '1h', '4h', '12h', or '1d'
     * @param {int} [since] Not used by huobi api, but response parsed by CCXT
     * @param {int} [limit] Default48Data Range [1,200]
     * @param {object} [params] Exchange specific parameters
     * @param {int} [params.amount_type] *required* Open interest unit. 1-cont2-cryptocurrency
     * @param {int} [params.pair] eg BTC-USDT *Only for USDT-M*
     * @returns {object} an array of [open interest structures]{@link https://docs.ccxt.com/?id=open-interest-structure}
     */
    public async override Task<object> fetchOpenInterestHistory(object symbol, object timeframe = null, object since = null, object limit = null, object parameters = null)
    {
        timeframe ??= "1h";
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isTrue(isTrue(isTrue(!isEqual(timeframe, "1h")) && isTrue(!isEqual(timeframe, "4h"))) && isTrue(!isEqual(timeframe, "12h"))) && isTrue(!isEqual(timeframe, "1d"))))
        {
            throw new BadRequest ((string)add(this.id, " fetchOpenInterestHistory cannot only use the 1h, 4h, 12h and 1d timeframe")) ;
        }
        await this.loadMarkets();
        object timeframes = new Dictionary<string, object>() {
            { "1h", "60min" },
            { "4h", "4hour" },
            { "12h", "12hour" },
            { "1d", "1day" },
        };
        object market = this.market(symbol);
        object amountType = this.safeInteger2(parameters, "amount_type", "amountType", 2);
        object request = new Dictionary<string, object>() {
            { "period", getValue(timeframes, timeframe) },
            { "amount_type", amountType },
        };
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["size"] = limit;
        }
        object response = null;
        if (isTrue(getValue(market, "future")))
        {
            ((IDictionary<string,object>)request)["contract_type"] = this.safeString(getValue(market, "info"), "contract_type");
            ((IDictionary<string,object>)request)["symbol"] = getValue(market, "baseId"); // currency code on coin-m futures
            // coin-m futures
            response = await this.contractPublicGetApiV1ContractHisOpenInterest(this.extend(request, parameters));
        } else if (isTrue(getValue(market, "linear")))
        {
            ((IDictionary<string,object>)request)["contract_type"] = "swap";
            ((IDictionary<string,object>)request)["contract_code"] = getValue(market, "id");
            ((IDictionary<string,object>)request)["contract_code"] = getValue(market, "id");
            // USDT-M
            response = await this.contractPublicGetLinearSwapApiV1SwapHisOpenInterest(this.extend(request, parameters));
        } else
        {
            ((IDictionary<string,object>)request)["contract_code"] = getValue(market, "id");
            // coin-m swaps
            response = await this.contractPublicGetSwapApiV1SwapHisOpenInterest(this.extend(request, parameters));
        }
        //
        //  contractPublicGetlinearSwapApiV1SwapHisOpenInterest
        //    {
        //        "status": "ok",
        //        "data": {
        //            "symbol": "BTC",
        //            "tick": [
        //                {
        //                    "volume": "4385.4350000000000000",
        //                    "amount_type": "2",
        //                    "ts": "1648220400000",
        //                    "value": "194059884.1850000000000000"
        //                },
        //                ...
        //            ],
        //            "contract_code": "BTC-USDT",
        //            "business_type": "swap",
        //            "pair": "BTC-USDT",
        //            "contract_type": "swap",
        //            "trade_partition": "USDT"
        //        },
        //        "ts": "1648223733007"
        //    }
        //
        //  contractPublicGetSwapApiV1SwapHisOpenInterest
        //    {
        //        "status": "ok",
        //        "data": {
        //            "symbol": "CRV",
        //            "tick": [
        //                {
        //                    "volume": 19174.0000000000000000,
        //                    "amount_type": 1,
        //                    "ts": 1648224000000
        //                },
        //                ...
        //            ],
        //            "contract_code": "CRV-USD"
        //        },
        //        "ts": 1648226554260
        //    }
        //
        //  contractPublicGetApiV1ContractHisOpenInterest
        //    {
        //         "status": "ok",
        //         "data": {
        //             "symbol": "BTC",
        //             "contract_type": "this_week",
        //             "tick": [
        //                {
        //                     "volume": "48419.0000000000000000",
        //                     "amount_type": 1,
        //                     "ts": 1648224000000
        //                },
        //                ...
        //            ]
        //        },
        //        "ts": 1648227062944
        //    }
        //
        object data = this.safeValue(response, "data");
        object tick = this.safeList(data, "tick");
        return this.parseOpenInterestsHistory(tick, market, since, limit);
    }

    /**
     * @method
     * @name htx#fetchOpenInterests
     * @description Retrieves the open interest for a list of symbols
     * @see https://huobiapi.github.io/docs/dm/v1/en/#get-contract-open-interest-information
     * @see https://huobiapi.github.io/docs/coin_margined_swap/v1/en/#get-swap-open-interest-information
     * @see https://huobiapi.github.io/docs/usdt_swap/v1/en/#general-get-swap-open-interest-information
     * @param {string[]} [symbols] a list of unified CCXT market symbols
     * @param {object} [params] exchange specific parameters
     * @returns {object[]} a list of [open interest structures]{@link https://docs.ccxt.com/?id=open-interest-structure}
     */
    public async override Task<object> fetchOpenInterests(object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        symbols = this.marketSymbols(symbols);
        object market = null;
        if (isTrue(!isEqual(symbols, null)))
        {
            object symbolsLength = getArrayLength(symbols);
            if (isTrue(isGreaterThan(symbolsLength, 0)))
            {
                object first = this.safeString(symbols, 0);
                market = this.market(first);
            }
        }
        object request = new Dictionary<string, object>() {};
        object subType = null;
        var subTypeparametersVariable = this.handleSubTypeAndParams("fetchPositions", market, parameters, "linear");
        subType = ((IList<object>)subTypeparametersVariable)[0];
        parameters = ((IList<object>)subTypeparametersVariable)[1];
        object marketType = null;
        var marketTypeparametersVariable = this.handleMarketTypeAndParams("fetchPositions", market, parameters);
        marketType = ((IList<object>)marketTypeparametersVariable)[0];
        parameters = ((IList<object>)marketTypeparametersVariable)[1];
        object response = null;
        if (isTrue(isEqual(marketType, "future")))
        {
            response = await this.contractPublicGetApiV1ContractOpenInterest(this.extend(request, parameters));
        } else if (isTrue(isEqual(subType, "inverse")))
        {
            response = await this.contractPublicGetSwapApiV1SwapOpenInterest(this.extend(request, parameters));
        } else
        {
            ((IDictionary<string,object>)request)["contract_type"] = "swap";
            response = await this.contractPublicGetLinearSwapApiV1SwapOpenInterest(this.extend(request, parameters));
        }
        object data = this.safeList(response, "data", new List<object>() {});
        return this.parseOpenInterests(data, symbols);
    }

    /**
     * @method
     * @name htx#fetchOpenInterest
     * @description Retrieves the open interest of a currency
     * @see https://huobiapi.github.io/docs/dm/v1/en/#get-contract-open-interest-information
     * @see https://huobiapi.github.io/docs/coin_margined_swap/v1/en/#get-swap-open-interest-information
     * @see https://huobiapi.github.io/docs/usdt_swap/v1/en/#general-get-swap-open-interest-information
     * @param {string} symbol Unified CCXT market symbol
     * @param {object} [params] exchange specific parameters
     * @returns {object} an open interest structure{@link https://docs.ccxt.com/?id=open-interest-structure}
     */
    public async override Task<object> fetchOpenInterest(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        if (!isTrue(getValue(market, "contract")))
        {
            throw new BadRequest ((string)add(this.id, " fetchOpenInterest() supports contract markets only")) ;
        }
        if (isTrue(getValue(market, "option")))
        {
            throw new NotSupported ((string)add(this.id, " fetchOpenInterest() does not currently support option markets")) ;
        }
        object request = new Dictionary<string, object>() {
            { "contract_code", getValue(market, "id") },
        };
        object response = null;
        if (isTrue(getValue(market, "future")))
        {
            ((IDictionary<string,object>)request)["contract_type"] = this.safeString(getValue(market, "info"), "contract_type");
            ((IDictionary<string,object>)request)["symbol"] = getValue(market, "baseId");
            // COIN-M futures
            response = await this.contractPublicGetApiV1ContractOpenInterest(this.extend(request, parameters));
        } else if (isTrue(getValue(market, "linear")))
        {
            ((IDictionary<string,object>)request)["contract_type"] = "swap";
            // USDT-M
            response = await this.contractPublicGetLinearSwapApiV1SwapOpenInterest(this.extend(request, parameters));
        } else
        {
            // COIN-M swaps
            response = await this.contractPublicGetSwapApiV1SwapOpenInterest(this.extend(request, parameters));
        }
        //
        // USDT-M contractPublicGetLinearSwapApiV1SwapOpenInterest
        //
        //     {
        //         "status": "ok",
        //         "data": [
        //             {
        //                 "volume": 7192610.000000000000000000,
        //                 "amount": 7192.610000000000000000,
        //                 "symbol": "BTC",
        //                 "value": 134654290.332000000000000000,
        //                 "contract_code": "BTC-USDT",
        //                 "trade_amount": 70692.804,
        //                 "trade_volume": 70692804,
        //                 "trade_turnover": 1379302592.9518,
        //                 "business_type": "swap",
        //                 "pair": "BTC-USDT",
        //                 "contract_type": "swap",
        //                 "trade_partition": "USDT"
        //             }
        //         ],
        //         "ts": 1664336503144
        //     }
        //
        // COIN-M Swap contractPublicGetSwapApiV1SwapOpenInterest
        //
        //     {
        //         "status": "ok",
        //         "data": [
        //             {
        //                 "volume": 518018.000000000000000000,
        //                 "amount": 2769.675777407074725180,
        //                 "symbol": "BTC",
        //                 "contract_code": "BTC-USD",
        //                 "trade_amount": 9544.4032080046491323463688602729806842458,
        //                 "trade_volume": 1848448,
        //                 "trade_turnover": 184844800.000000000000000000
        //             }
        //         ],
        //         "ts": 1664337226028
        //     }
        //
        // COIN-M Futures contractPublicGetApiV1ContractOpenInterest
        //
        //     {
        //         "status": "ok",
        //         "data": [
        //             {
        //                 "volume": 118850.000000000000000000,
        //                 "amount": 635.502025211544374189,
        //                 "symbol": "BTC",
        //                 "contract_type": "this_week",
        //                 "contract_code": "BTC220930",
        //                 "trade_amount": 1470.9400749347598691119206024033947897351,
        //                 "trade_volume": 286286,
        //                 "trade_turnover": 28628600.000000000000000000
        //             }
        //         ],
        //         "ts": 1664337928805
        //     }
        //
        object data = this.safeValue(response, "data", new List<object>() {});
        object openInterest = this.parseOpenInterest(getValue(data, 0), market);
        object timestamp = this.safeInteger(response, "ts");
        ((IDictionary<string,object>)openInterest)["timestamp"] = timestamp;
        ((IDictionary<string,object>)openInterest)["datetime"] = this.iso8601(timestamp);
        return openInterest;
    }

    public override object parseOpenInterest(object interest, object market = null)
    {
        //
        // fetchOpenInterestHistory
        //
        //    {
        //        "volume": "4385.4350000000000000",
        //        "amount_type": "2",
        //        "ts": "1648220400000",
        //        "value": "194059884.1850000000000000"
        //    }
        //
        // fetchOpenInterest: USDT-M
        //
        //     {
        //         "volume": 7192610.000000000000000000,
        //         "amount": 7192.610000000000000000,
        //         "symbol": "BTC",
        //         "value": 134654290.332000000000000000,
        //         "contract_code": "BTC-USDT",
        //         "trade_amount": 70692.804,
        //         "trade_volume": 70692804,
        //         "trade_turnover": 1379302592.9518,
        //         "business_type": "swap",
        //         "pair": "BTC-USDT",
        //         "contract_type": "swap",
        //         "trade_partition": "USDT"
        //     }
        //
        // fetchOpenInterest: COIN-M Swap
        //
        //     {
        //         "volume": 518018.000000000000000000,
        //         "amount": 2769.675777407074725180,
        //         "symbol": "BTC",
        //         "contract_code": "BTC-USD",
        //         "trade_amount": 9544.4032080046491323463688602729806842458,
        //         "trade_volume": 1848448,
        //         "trade_turnover": 184844800.000000000000000000
        //     }
        //
        // fetchOpenInterest: COIN-M Futures
        //
        //     {
        //         "volume": 118850.000000000000000000,
        //         "amount": 635.502025211544374189,
        //         "symbol": "BTC",
        //         "contract_type": "this_week",
        //         "contract_code": "BTC220930",
        //         "trade_amount": 1470.9400749347598691119206024033947897351,
        //         "trade_volume": 286286,
        //         "trade_turnover": 28628600.000000000000000000
        //     }
        //
        object timestamp = this.safeInteger(interest, "ts");
        object amount = this.safeNumber(interest, "volume");
        object value = this.safeNumber(interest, "value");
        object marketId = this.safeString(interest, "contract_code");
        return this.safeOpenInterest(new Dictionary<string, object>() {
            { "symbol", this.safeSymbol(marketId, market) },
            { "baseVolume", amount },
            { "quoteVolume", value },
            { "openInterestAmount", amount },
            { "openInterestValue", value },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "info", interest },
        }, market);
    }

    /**
     * @method
     * @name htx#borrowIsolatedMargin
     * @description create a loan to borrow margin
     * @see https://huobiapi.github.io/docs/spot/v1/en/#request-a-margin-loan-isolated
     * @see https://huobiapi.github.io/docs/spot/v1/en/#request-a-margin-loan-cross
     * @param {string} symbol unified market symbol, required for isolated margin
     * @param {string} code unified currency code of the currency to borrow
     * @param {float} amount the amount to borrow
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [margin loan structure]{@link https://docs.ccxt.com/?id=margin-loan-structure}
     */
    public async override Task<object> borrowIsolatedMargin(object symbol, object code, object amount, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "currency", getValue(currency, "id") },
            { "amount", this.currencyToPrecision(code, amount) },
            { "symbol", getValue(market, "id") },
        };
        object response = await this.privatePostMarginOrders(this.extend(request, parameters));
        //
        // Isolated
        //
        //     {
        //         "data": 1000
        //     }
        //
        object transaction = this.parseMarginLoan(response, currency);
        return this.extend(transaction, new Dictionary<string, object>() {
            { "amount", amount },
            { "symbol", symbol },
        });
    }

    /**
     * @method
     * @name htx#borrowCrossMargin
     * @description create a loan to borrow margin
     * @see https://huobiapi.github.io/docs/spot/v1/en/#request-a-margin-loan-isolated
     * @see https://huobiapi.github.io/docs/spot/v1/en/#request-a-margin-loan-cross
     * @param {string} code unified currency code of the currency to borrow
     * @param {float} amount the amount to borrow
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [margin loan structure]{@link https://docs.ccxt.com/?id=margin-loan-structure}
     */
    public async override Task<object> borrowCrossMargin(object code, object amount, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "currency", getValue(currency, "id") },
            { "amount", this.currencyToPrecision(code, amount) },
        };
        object response = await this.privatePostCrossMarginOrders(this.extend(request, parameters));
        //
        // Cross
        //
        //     {
        //         "status": "ok",
        //         "data": null
        //     }
        //
        object transaction = this.parseMarginLoan(response, currency);
        return this.extend(transaction, new Dictionary<string, object>() {
            { "amount", amount },
        });
    }

    /**
     * @method
     * @name htx#repayIsolatedMargin
     * @description repay borrowed margin and interest
     * @see https://huobiapi.github.io/docs/spot/v1/en/#repay-margin-loan-cross-isolated
     * @param {string} symbol unified market symbol
     * @param {string} code unified currency code of the currency to repay
     * @param {float} amount the amount to repay
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [margin loan structure]{@link https://docs.ccxt.com/?id=margin-loan-structure}
     */
    public async override Task<object> repayIsolatedMargin(object symbol, object code, object amount, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        object accountId = await this.fetchAccountIdByType("spot", "isolated", symbol, parameters);
        object request = new Dictionary<string, object>() {
            { "currency", getValue(currency, "id") },
            { "amount", this.currencyToPrecision(code, amount) },
            { "accountId", accountId },
        };
        object response = await this.v2PrivatePostAccountRepayment(this.extend(request, parameters));
        //
        //     {
        //         "code":200,
        //         "data": [
        //             {
        //                 "repayId":1174424,
        //                 "repayTime":1600747722018
        //             }
        //         ]
        //     }
        //
        object data = this.safeValue(response, "Data", new List<object>() {});
        object loan = this.safeValue(data, 0);
        object transaction = this.parseMarginLoan(loan, currency);
        return this.extend(transaction, new Dictionary<string, object>() {
            { "amount", amount },
            { "symbol", symbol },
        });
    }

    /**
     * @method
     * @name htx#repayCrossMargin
     * @description repay borrowed margin and interest
     * @see https://huobiapi.github.io/docs/spot/v1/en/#repay-margin-loan-cross-isolated
     * @param {string} code unified currency code of the currency to repay
     * @param {float} amount the amount to repay
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [margin loan structure]{@link https://docs.ccxt.com/?id=margin-loan-structure}
     */
    public async override Task<object> repayCrossMargin(object code, object amount, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        object accountId = await this.fetchAccountIdByType("spot", "cross", null, parameters);
        object request = new Dictionary<string, object>() {
            { "currency", getValue(currency, "id") },
            { "amount", this.currencyToPrecision(code, amount) },
            { "accountId", accountId },
        };
        object response = await this.v2PrivatePostAccountRepayment(this.extend(request, parameters));
        //
        //     {
        //         "code":200,
        //         "data": [
        //             {
        //                 "repayId":1174424,
        //                 "repayTime":1600747722018
        //             }
        //         ]
        //     }
        //
        object data = this.safeValue(response, "Data", new List<object>() {});
        object loan = this.safeValue(data, 0);
        object transaction = this.parseMarginLoan(loan, currency);
        return this.extend(transaction, new Dictionary<string, object>() {
            { "amount", amount },
        });
    }

    public virtual object parseMarginLoan(object info, object currency = null)
    {
        //
        // borrowMargin cross
        //
        //     {
        //         "status": "ok",
        //         "data": null
        //     }
        //
        // borrowMargin isolated
        //
        //     {
        //         "data": 1000
        //     }
        //
        // repayMargin
        //
        //     {
        //         "repayId":1174424,
        //         "repayTime":1600747722018
        //     }
        //
        object timestamp = this.safeInteger(info, "repayTime");
        return new Dictionary<string, object>() {
            { "id", this.safeString2(info, "repayId", "data") },
            { "currency", this.safeCurrencyCode(null, currency) },
            { "amount", null },
            { "symbol", null },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "info", info },
        };
    }

    /**
     * @method
     * @name htx#fetchSettlementHistory
     * @description Fetches historical settlement records
     * @see https://huobiapi.github.io/docs/dm/v1/en/#query-historical-settlement-records-of-the-platform-interface
     * @see https://huobiapi.github.io/docs/coin_margined_swap/v1/en/#query-historical-settlement-records-of-the-platform-interface
     * @see https://huobiapi.github.io/docs/usdt_swap/v1/en/#general-query-historical-settlement-records-of-the-platform-interface
     * @param {string} symbol unified symbol of the market to fetch the settlement history for
     * @param {int} [since] timestamp in ms, value range = current time - 90 daysdefault = current time - 90 days
     * @param {int} [limit] page items, default 20, shall not exceed 50
     * @param {object} [params] exchange specific params
     * @param {int} [params.until] timestamp in ms, value range = start_time -> current timedefault = current time
     * @param {int} [params.page_index] page index, default page 1 if not filled
     * @param {int} [params.code] unified currency code, can be used when symbol is undefined
     * @returns {object[]} a list of [settlement history objects]{@link https://docs.ccxt.com/?id=settlement-history-structure}
     */
    public async virtual Task<object> fetchSettlementHistory(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchSettlementHistory() requires a symbol argument")) ;
        }
        object until = this.safeInteger(parameters, "until");
        parameters = this.omit(parameters, new List<object>() {"until"});
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {};
        if (isTrue(getValue(market, "future")))
        {
            ((IDictionary<string,object>)request)["symbol"] = getValue(market, "baseId");
        } else
        {
            ((IDictionary<string,object>)request)["contract_code"] = getValue(market, "id");
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["start_at"] = since;
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["page_size"] = limit;
        }
        if (isTrue(!isEqual(until, null)))
        {
            ((IDictionary<string,object>)request)["end_at"] = until;
        }
        object response = null;
        if (isTrue(getValue(market, "swap")))
        {
            if (isTrue(getValue(market, "linear")))
            {
                response = await this.contractPublicGetLinearSwapApiV1SwapSettlementRecords(this.extend(request, parameters));
            } else
            {
                response = await this.contractPublicGetSwapApiV1SwapSettlementRecords(this.extend(request, parameters));
            }
        } else
        {
            response = await this.contractPublicGetApiV1ContractSettlementRecords(this.extend(request, parameters));
        }
        //
        // linear swap, coin-m swap
        //
        //    {
        //        "status": "ok",
        //        "data": {
        //        "total_page": 14,
        //        "current_page": 1,
        //        "total_size": 270,
        //        "settlement_record": [
        //            {
        //                "symbol": "ADA",
        //                "contract_code": "ADA-USDT",
        //                "settlement_time": 1652313600000,
        //                "clawback_ratio": 0E-18,
        //                "settlement_price": 0.512303000000000000,
        //                "settlement_type": "settlement",
        //                "business_type": "swap",
        //                "pair": "ADA-USDT",
        //                "trade_partition": "USDT"
        //            },
        //            ...
        //        ],
        //        "ts": 1652338693256
        //    }
        //
        // coin-m future
        //
        //    {
        //        "status": "ok",
        //        "data": {
        //            "total_page": 5,
        //            "current_page": 1,
        //            "total_size": 90,
        //            "settlement_record": [
        //                {
        //                    "symbol": "FIL",
        //                    "settlement_time": 1652342400000,
        //                    "clawback_ratio": 0E-18,
        //                    "list": [
        //                        {
        //                            "contract_code": "FIL220513",
        //                            "settlement_price": 7.016000000000000000,
        //                            "settlement_type": "settlement"
        //                        },
        //                        ...
        //                    ]
        //                },
        //            ]
        //        }
        //    }
        //
        object data = this.safeValue(response, "data");
        object settlementRecord = this.safeValue(data, "settlement_record");
        object settlements = this.parseSettlements(settlementRecord, market);
        return this.sortBy(settlements, "timestamp");
    }

    /**
     * @method
     * @name htx#fetchDepositWithdrawFees
     * @description fetch deposit and withdraw fees
     * @see https://huobiapi.github.io/docs/spot/v1/en/#get-all-supported-currencies-v2
     * @param {string[]|undefined} codes list of unified currency codes
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} a list of [fees structures]{@link https://docs.ccxt.com/?id=fee-structure}
     */
    public async override Task<object> fetchDepositWithdrawFees(object codes = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.spotPublicGetV2ReferenceCurrencies(parameters);
        //
        //    {
        //        "code": 200,
        //        "data": [
        //            {
        //                "currency": "sxp",
        //                "assetType": "1",
        //                "chains": [
        //                    {
        //                        "chain": "sxp",
        //                        "displayName": "ERC20",
        //                        "baseChain": "ETH",
        //                        "baseChainProtocol": "ERC20",
        //                        "isDynamic": true,
        //                        "numOfConfirmations": "12",
        //                        "numOfFastConfirmations": "12",
        //                        "depositStatus": "allowed",
        //                        "minDepositAmt": "0.23",
        //                        "withdrawStatus": "allowed",
        //                        "minWithdrawAmt": "0.23",
        //                        "withdrawPrecision": "8",
        //                        "maxWithdrawAmt": "227000.000000000000000000",
        //                        "withdrawQuotaPerDay": "227000.000000000000000000",
        //                        "withdrawQuotaPerYear": null,
        //                        "withdrawQuotaTotal": null,
        //                        "withdrawFeeType": "fixed",
        //                        "transactFeeWithdraw": "11.1653",
        //                        "addrWithTag": false,
        //                        "addrDepositTag": false
        //                    }
        //                ],
        //                "instStatus": "normal"
        //            }
        //        ]
        //    }
        //
        object data = this.safeList(response, "data");
        return this.parseDepositWithdrawFees(data, codes, "currency");
    }

    public override object parseDepositWithdrawFee(object fee, object currency = null)
    {
        //
        //            {
        //              "currency": "sxp",
        //              "assetType": "1",
        //              "chains": [
        //                  {
        //                      "chain": "sxp",
        //                      "displayName": "ERC20",
        //                      "baseChain": "ETH",
        //                      "baseChainProtocol": "ERC20",
        //                      "isDynamic": true,
        //                      "numOfConfirmations": "12",
        //                      "numOfFastConfirmations": "12",
        //                      "depositStatus": "allowed",
        //                      "minDepositAmt": "0.23",
        //                      "withdrawStatus": "allowed",
        //                      "minWithdrawAmt": "0.23",
        //                      "withdrawPrecision": "8",
        //                      "maxWithdrawAmt": "227000.000000000000000000",
        //                      "withdrawQuotaPerDay": "227000.000000000000000000",
        //                      "withdrawQuotaPerYear": null,
        //                      "withdrawQuotaTotal": null,
        //                      "withdrawFeeType": "fixed",
        //                      "transactFeeWithdraw": "11.1653",
        //                      "addrWithTag": false,
        //                      "addrDepositTag": false
        //                  }
        //              ],
        //              "instStatus": "normal"
        //          }
        //
        object chains = this.safeValue(fee, "chains", new List<object>() {});
        object result = this.depositWithdrawFee(fee);
        for (object j = 0; isLessThan(j, getArrayLength(chains)); postFixIncrement(ref j))
        {
            object chainEntry = getValue(chains, j);
            object networkId = this.safeString(chainEntry, "chain");
            object withdrawFeeType = this.safeString(chainEntry, "withdrawFeeType");
            object networkCode = this.networkIdToCode(networkId);
            object withdrawFee = null;
            object withdrawResult = null;
            if (isTrue(isEqual(withdrawFeeType, "fixed")))
            {
                withdrawFee = this.safeNumber(chainEntry, "transactFeeWithdraw");
                withdrawResult = new Dictionary<string, object>() {
                    { "fee", withdrawFee },
                    { "percentage", false },
                };
            } else
            {
                withdrawFee = this.safeNumber(chainEntry, "transactFeeRateWithdraw");
                withdrawResult = new Dictionary<string, object>() {
                    { "fee", withdrawFee },
                    { "percentage", true },
                };
            }
            ((IDictionary<string,object>)getValue(result, "networks"))[(string)networkCode] = new Dictionary<string, object>() {
                { "withdraw", withdrawResult },
                { "deposit", new Dictionary<string, object>() {
                    { "fee", null },
                    { "percentage", null },
                } },
            };
            result = this.assignDefaultDepositWithdrawFees(result, currency);
        }
        return result;
    }

    public virtual object parseSettlements(object settlements, object market)
    {
        //
        // linear swap, coin-m swap, fetchSettlementHistory
        //
        //    [
        //        {
        //            "symbol": "ADA",
        //            "contract_code": "ADA-USDT",
        //            "settlement_time": 1652313600000,
        //            "clawback_ratio": 0E-18,
        //            "settlement_price": 0.512303000000000000,
        //            "settlement_type": "settlement",
        //            "business_type": "swap",
        //            "pair": "ADA-USDT",
        //            "trade_partition": "USDT"
        //        },
        //        ...
        //    ]
        //
        // coin-m future, fetchSettlementHistory
        //
        //    [
        //        {
        //            "symbol": "FIL",
        //            "settlement_time": 1652342400000,
        //            "clawback_ratio": 0E-18,
        //            "list": [
        //                {
        //                    "contract_code": "FIL220513",
        //                    "settlement_price": 7.016000000000000000,
        //                    "settlement_type": "settlement"
        //                },
        //                ...
        //            ]
        //        },
        //    ]
        //
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(settlements)); postFixIncrement(ref i))
        {
            object settlement = getValue(settlements, i);
            object list = this.safeValue(settlement, "list");
            if (isTrue(!isEqual(list, null)))
            {
                object timestamp = this.safeInteger(settlement, "settlement_time");
                object timestampDetails = new Dictionary<string, object>() {
                    { "timestamp", timestamp },
                    { "datetime", this.iso8601(timestamp) },
                };
                for (object j = 0; isLessThan(j, getArrayLength(list)); postFixIncrement(ref j))
                {
                    object item = getValue(list, j);
                    object parsedSettlement = this.parseSettlement(item, market);
                    ((IList<object>)result).Add(this.extend(parsedSettlement, timestampDetails));
                }
            } else
            {
                ((IList<object>)result).Add(this.parseSettlement(getValue(settlements, i), market));
            }
        }
        return result;
    }

    public virtual object parseSettlement(object settlement, object market)
    {
        //
        // linear swap, coin-m swap, fetchSettlementHistory
        //
        //    {
        //        "symbol": "ADA",
        //        "contract_code": "ADA-USDT",
        //        "settlement_time": 1652313600000,
        //        "clawback_ratio": 0E-18,
        //        "settlement_price": 0.512303000000000000,
        //        "settlement_type": "settlement",
        //        "business_type": "swap",
        //        "pair": "ADA-USDT",
        //        "trade_partition": "USDT"
        //    }
        //
        // coin-m future, fetchSettlementHistory
        //
        //    {
        //        "contract_code": "FIL220513",
        //        "settlement_price": 7.016000000000000000,
        //        "settlement_type": "settlement"
        //    }
        //
        object timestamp = this.safeInteger(settlement, "settlement_time");
        object marketId = this.safeString(settlement, "contract_code");
        return new Dictionary<string, object>() {
            { "info", settlement },
            { "symbol", this.safeSymbol(marketId, market) },
            { "price", this.safeNumber(settlement, "settlement_price") },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
        };
    }

    /**
     * @method
     * @name htx#fetchLiquidations
     * @description retrieves the public liquidations of a trading pair
     * @see https://huobiapi.github.io/docs/usdt_swap/v1/en/#general-query-liquidation-orders-new
     * @see https://huobiapi.github.io/docs/coin_margined_swap/v1/en/#query-liquidation-orders-new
     * @see https://huobiapi.github.io/docs/dm/v1/en/#query-liquidation-order-information-new
     * @param {string} symbol unified CCXT market symbol
     * @param {int} [since] the earliest time in ms to fetch liquidations for
     * @param {int} [limit] the maximum number of liquidation structures to retrieve
     * @param {object} [params] exchange specific parameters for the huobi api endpoint
     * @param {int} [params.until] timestamp in ms of the latest liquidation
     * @param {int} [params.tradeType] default 0, linear swap 0: all liquidated orders, 5: liquidated longs; 6: liquidated shorts, inverse swap and future 0: filled liquidated orders, 5: liquidated close orders, 6: liquidated open orders
     * @returns {object} an array of [liquidation structures]{@link https://docs.ccxt.com/?id=liquidation-structure}
     */
    public async override Task<object> fetchLiquidations(object symbol, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object tradeType = this.safeInteger(parameters, "trade_type", 0);
        object request = new Dictionary<string, object>() {
            { "trade_type", tradeType },
        };
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["start_time"] = since;
        }
        var requestparametersVariable = this.handleUntilOption("end_time", request, parameters);
        request = ((IList<object>)requestparametersVariable)[0];
        parameters = ((IList<object>)requestparametersVariable)[1];
        object response = null;
        if (isTrue(getValue(market, "swap")))
        {
            ((IDictionary<string,object>)request)["contract"] = getValue(market, "id");
            if (isTrue(getValue(market, "linear")))
            {
                response = await this.contractPublicGetLinearSwapApiV3SwapLiquidationOrders(this.extend(request, parameters));
            } else
            {
                response = await this.contractPublicGetSwapApiV3SwapLiquidationOrders(this.extend(request, parameters));
            }
        } else if (isTrue(getValue(market, "future")))
        {
            ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
            response = await this.contractPublicGetApiV3ContractLiquidationOrders(this.extend(request, parameters));
        } else
        {
            throw new NotSupported ((string)add(add(add(this.id, " fetchLiquidations() does not support "), getValue(market, "type")), " orders")) ;
        }
        //
        //     {
        //         "code": 200,
        //         "msg": "",
        //         "data": [
        //             {
        //                 "query_id": 452057,
        //                 "contract_code": "BTC-USDT-211210",
        //                 "symbol": "USDT",
        //                 "direction": "sell",
        //                 "offset": "close",
        //                 "volume": 479.000000000000000000,
        //                 "price": 51441.700000000000000000,
        //                 "created_at": 1638593647864,
        //                 "amount": 0.479000000000000000,
        //                 "trade_turnover": 24640.574300000000000000,
        //                 "business_type": "futures",
        //                 "pair": "BTC-USDT"
        //             }
        //         ],
        //         "ts": 1604312615051
        //     }
        //
        object data = this.safeList(response, "data", new List<object>() {});
        return this.parseLiquidations(data, market, since, limit);
    }

    public override object parseLiquidation(object liquidation, object market = null)
    {
        //
        //     {
        //         "query_id": 452057,
        //         "contract_code": "BTC-USDT-211210",
        //         "symbol": "USDT",
        //         "direction": "sell",
        //         "offset": "close",
        //         "volume": 479.000000000000000000,
        //         "price": 51441.700000000000000000,
        //         "created_at": 1638593647864,
        //         "amount": 0.479000000000000000,
        //         "trade_turnover": 24640.574300000000000000,
        //         "business_type": "futures",
        //         "pair": "BTC-USDT"
        //     }
        //
        object marketId = this.safeString(liquidation, "contract_code");
        object timestamp = this.safeInteger(liquidation, "created_at");
        return this.safeLiquidation(new Dictionary<string, object>() {
            { "info", liquidation },
            { "symbol", this.safeSymbol(marketId, market) },
            { "contracts", this.safeNumber(liquidation, "volume") },
            { "contractSize", this.safeNumber(market, "contractSize") },
            { "price", this.safeNumber(liquidation, "price") },
            { "side", this.safeStringLower(liquidation, "direction") },
            { "baseValue", this.safeNumber(liquidation, "amount") },
            { "quoteValue", this.safeNumber(liquidation, "trade_turnover") },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
        });
    }

    /**
     * @method
     * @name htx#closePositions
     * @description closes open positions for a contract market, requires 'amount' in params, unlike other exchanges
     * @see https://huobiapi.github.io/docs/usdt_swap/v1/en/#isolated-place-lightning-close-order  // USDT-M (isolated)
     * @see https://huobiapi.github.io/docs/usdt_swap/v1/en/#cross-place-lightning-close-position  // USDT-M (cross)
     * @see https://huobiapi.github.io/docs/coin_margined_swap/v1/en/#place-lightning-close-order  // Coin-M swap
     * @see https://huobiapi.github.io/docs/dm/v1/en/#place-flash-close-order                      // Coin-M futures
     * @param {string} symbol unified CCXT market symbol
     * @param {string} side 'buy' or 'sell', the side of the closing order, opposite side as position side
     * @param {object} [params] extra parameters specific to the okx api endpoint
     * @param {string} [params.clientOrderId] client needs to provide unique API and have to maintain the API themselves afterwards. [1, 9223372036854775807]
     * @param {object} [params.marginMode] 'cross' or 'isolated', required for linear markets
     *
     * EXCHANGE SPECIFIC PARAMETERS
     * @param {number} [params.amount] order quantity
     * @param {string} [params.order_price_type] 'lightning' by default, 'lightning_fok': lightning fok type, 'lightning_ioc': lightning ioc type 'market' by default, 'market': market order type, 'lightning_fok': lightning
     * @returns {object} [an order structure]{@link https://docs.ccxt.com/?id=position-structure}
     */
    public async override Task<object> closePosition(object symbol, object side = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object clientOrderId = this.safeString(parameters, "clientOrderId");
        if (!isTrue(getValue(market, "contract")))
        {
            throw new BadRequest ((string)add(this.id, " closePosition() symbol supports contract markets only")) ;
        }
        this.checkRequiredArgument("closePosition", side, "side");
        object request = new Dictionary<string, object>() {
            { "contract_code", getValue(market, "id") },
            { "direction", side },
        };
        if (isTrue(!isEqual(clientOrderId, null)))
        {
            ((IDictionary<string,object>)request)["client_order_id"] = clientOrderId;
        }
        if (isTrue(getValue(market, "inverse")))
        {
            object amount = this.safeString2(parameters, "volume", "amount");
            if (isTrue(isEqual(amount, null)))
            {
                throw new ArgumentsRequired ((string)add(this.id, " closePosition () requires an extra argument params[\"amount\"] for inverse markets")) ;
            }
            ((IDictionary<string,object>)request)["volume"] = this.amountToPrecision(symbol, amount);
        }
        parameters = this.omit(parameters, new List<object>() {"clientOrderId", "volume", "amount"});
        object response = null;
        if (isTrue(getValue(market, "inverse")))
        {
            if (isTrue(getValue(market, "swap")))
            {
                response = await this.contractPrivatePostSwapApiV1SwapLightningClosePosition(this.extend(request, parameters));
            } else
            {
                response = await this.contractPrivatePostApiV1LightningClosePosition(this.extend(request, parameters));
            }
        } else
        {
            object marginMode = null;
            var marginModeparametersVariable = this.handleMarginModeAndParams("closePosition", parameters, "cross");
            marginMode = ((IList<object>)marginModeparametersVariable)[0];
            parameters = ((IList<object>)marginModeparametersVariable)[1];
            if (isTrue(isEqual(marginMode, "cross")))
            {
                response = await this.contractPrivatePostLinearSwapApiV1SwapCrossLightningClosePosition(this.extend(request, parameters));
            } else
            {
                response = await this.contractPrivatePostLinearSwapApiV1SwapLightningClosePosition(this.extend(request, parameters));
            }
        }
        return this.parseOrder(response, market);
    }

    /**
     * @method
     * @name htx#setPositionMode
     * @description set hedged to true or false
     * @see https://huobiapi.github.io/docs/usdt_swap/v1/en/#isolated-switch-position-mode
     * @see https://huobiapi.github.io/docs/usdt_swap/v1/en/#cross-switch-position-mode
     * @param {bool} hedged set to true to for hedged mode, must be set separately for each market in isolated margin mode, only valid for linear markets
     * @param {string} [symbol] unified market symbol, required for isolated margin mode
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.marginMode] "cross" (default) or "isolated"
     * @returns {object} response from the exchange
     */
    public async override Task<object> setPositionMode(object hedged, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object posMode = ((bool) isTrue(hedged)) ? "dual_side" : "single_side";
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
        }
        object marginMode = null;
        var marginModeparametersVariable = this.handleMarginModeAndParams("setPositionMode", parameters, "cross");
        marginMode = ((IList<object>)marginModeparametersVariable)[0];
        parameters = ((IList<object>)marginModeparametersVariable)[1];
        object request = new Dictionary<string, object>() {
            { "position_mode", posMode },
        };
        object response = null;
        if (isTrue(isTrue((!isEqual(market, null))) && isTrue((getValue(market, "inverse")))))
        {
            throw new BadRequest ((string)add(this.id, " setPositionMode can only be used for linear markets")) ;
        }
        if (isTrue(isEqual(marginMode, "isolated")))
        {
            if (isTrue(isEqual(symbol, null)))
            {
                throw new ArgumentsRequired ((string)add(this.id, " setPositionMode requires a symbol argument for isolated margin mode")) ;
            }
            ((IDictionary<string,object>)request)["margin_account"] = getValue(market, "id");
            response = await this.contractPrivatePostLinearSwapApiV1SwapSwitchPositionMode(this.extend(request, parameters));
        } else
        {
            ((IDictionary<string,object>)request)["margin_account"] = "USDT";
            response = await this.contractPrivatePostLinearSwapApiV1SwapCrossSwitchPositionMode(this.extend(request, parameters));
        }
        return response;
    }
}
