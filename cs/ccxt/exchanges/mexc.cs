namespace ccxt;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

public partial class mexc : Exchange
{
    public override object describe()
    {
        return this.deepExtend(base.describe(), new Dictionary<string, object>() {
            { "id", "mexc" },
            { "name", "MEXC Global" },
            { "countries", new List<object>() {"SC"} },
            { "rateLimit", 50 },
            { "version", "v3" },
            { "certified", true },
            { "pro", true },
            { "has", new Dictionary<string, object>() {
                { "CORS", null },
                { "spot", true },
                { "margin", true },
                { "swap", true },
                { "future", false },
                { "option", false },
                { "addMargin", true },
                { "borrowCrossMargin", false },
                { "borrowIsolatedMargin", false },
                { "borrowMargin", false },
                { "cancelAllOrders", true },
                { "cancelOrder", true },
                { "cancelOrders", null },
                { "closeAllPositions", false },
                { "closePosition", false },
                { "createDepositAddress", true },
                { "createMarketBuyOrderWithCost", true },
                { "createMarketOrderWithCost", true },
                { "createMarketSellOrderWithCost", true },
                { "createOrder", true },
                { "createOrders", true },
                { "createPostOnlyOrder", true },
                { "createReduceOnlyOrder", true },
                { "createStopLimitOrder", true },
                { "createStopMarketOrder", true },
                { "createStopOrder", true },
                { "createTriggerOrder", true },
                { "deposit", null },
                { "editOrder", null },
                { "fetchAccounts", true },
                { "fetchBalance", true },
                { "fetchBidsAsks", true },
                { "fetchBorrowInterest", false },
                { "fetchBorrowRate", false },
                { "fetchBorrowRateHistories", false },
                { "fetchBorrowRateHistory", false },
                { "fetchBorrowRates", false },
                { "fetchBorrowRatesPerSymbol", false },
                { "fetchCanceledOrders", true },
                { "fetchClosedOrder", null },
                { "fetchClosedOrders", true },
                { "fetchCrossBorrowRate", false },
                { "fetchCrossBorrowRates", false },
                { "fetchCurrencies", true },
                { "fetchDeposit", null },
                { "fetchDepositAddress", true },
                { "fetchDepositAddresses", null },
                { "fetchDepositAddressesByNetwork", true },
                { "fetchDeposits", true },
                { "fetchDepositWithdrawFee", "emulated" },
                { "fetchDepositWithdrawFees", true },
                { "fetchFundingHistory", true },
                { "fetchFundingInterval", true },
                { "fetchFundingIntervals", false },
                { "fetchFundingRate", true },
                { "fetchFundingRateHistory", true },
                { "fetchFundingRates", false },
                { "fetchIndexOHLCV", true },
                { "fetchIsolatedBorrowRate", false },
                { "fetchIsolatedBorrowRates", false },
                { "fetchIsolatedPositions", false },
                { "fetchL2OrderBook", true },
                { "fetchLedger", null },
                { "fetchLedgerEntry", null },
                { "fetchLeverage", true },
                { "fetchLeverages", false },
                { "fetchLeverageTiers", true },
                { "fetchMarginAdjustmentHistory", false },
                { "fetchMarginMode", false },
                { "fetchMarketLeverageTiers", "emulated" },
                { "fetchMarkets", true },
                { "fetchMarkOHLCV", true },
                { "fetchMyTrades", true },
                { "fetchOHLCV", true },
                { "fetchOpenInterest", false },
                { "fetchOpenInterestHistory", false },
                { "fetchOpenOrder", null },
                { "fetchOpenOrders", true },
                { "fetchOrder", true },
                { "fetchOrderBook", true },
                { "fetchOrderBooks", null },
                { "fetchOrders", true },
                { "fetchOrderTrades", true },
                { "fetchPosition", "emulated" },
                { "fetchPositionHistory", "emulated" },
                { "fetchPositionMode", true },
                { "fetchPositions", true },
                { "fetchPositionsHistory", true },
                { "fetchPositionsRisk", null },
                { "fetchPremiumIndexOHLCV", false },
                { "fetchStatus", true },
                { "fetchTicker", true },
                { "fetchTickers", true },
                { "fetchTime", true },
                { "fetchTrades", true },
                { "fetchTradingFee", true },
                { "fetchTradingFees", false },
                { "fetchTradingLimits", null },
                { "fetchTransactionFee", "emulated" },
                { "fetchTransactionFees", true },
                { "fetchTransactions", null },
                { "fetchTransfer", true },
                { "fetchTransfers", true },
                { "fetchWithdrawal", null },
                { "fetchWithdrawals", true },
                { "reduceMargin", true },
                { "repayCrossMargin", false },
                { "repayIsolatedMargin", false },
                { "setLeverage", true },
                { "setMarginMode", true },
                { "setPositionMode", true },
                { "signIn", null },
                { "transfer", null },
                { "withdraw", true },
            } },
            { "urls", new Dictionary<string, object>() {
                { "logo", "https://user-images.githubusercontent.com/1294454/137283979-8b2a818d-8633-461b-bfca-de89e8c446b2.jpg" },
                { "api", new Dictionary<string, object>() {
                    { "spot", new Dictionary<string, object>() {
                        { "public", "https://api.mexc.com" },
                        { "private", "https://api.mexc.com" },
                    } },
                    { "spot2", new Dictionary<string, object>() {
                        { "public", "https://www.mexc.com/open/api/v2" },
                        { "private", "https://www.mexc.com/open/api/v2" },
                    } },
                    { "contract", new Dictionary<string, object>() {
                        { "public", "https://contract.mexc.com/api/v1/contract" },
                        { "private", "https://contract.mexc.com/api/v1/private" },
                    } },
                    { "broker", new Dictionary<string, object>() {
                        { "private", "https://api.mexc.com/api/v3/broker" },
                    } },
                } },
                { "www", "https://www.mexc.com/" },
                { "doc", new List<object>() {"https://mexcdevelop.github.io/apidocs/"} },
                { "fees", new List<object>() {"https://www.mexc.com/fee"} },
                { "referral", "https://www.mexc.com/register?inviteCode=mexc-1FQ1GNu1" },
            } },
            { "api", new Dictionary<string, object>() {
                { "spot", new Dictionary<string, object>() {
                    { "public", new Dictionary<string, object>() {
                        { "get", new Dictionary<string, object>() {
                            { "ping", 1 },
                            { "time", 1 },
                            { "exchangeInfo", 10 },
                            { "depth", 1 },
                            { "trades", 5 },
                            { "historicalTrades", 1 },
                            { "aggTrades", 1 },
                            { "klines", 1 },
                            { "avgPrice", 1 },
                            { "ticker/24hr", 1 },
                            { "ticker/price", 1 },
                            { "ticker/bookTicker", 1 },
                            { "etf/info", 1 },
                        } },
                    } },
                    { "private", new Dictionary<string, object>() {
                        { "get", new Dictionary<string, object>() {
                            { "order", 2 },
                            { "openOrders", 3 },
                            { "allOrders", 10 },
                            { "account", 10 },
                            { "myTrades", 10 },
                            { "tradeFee", 10 },
                            { "sub-account/list", 1 },
                            { "sub-account/apiKey", 1 },
                            { "capital/config/getall", 10 },
                            { "capital/deposit/hisrec", 1 },
                            { "capital/withdraw/history", 1 },
                            { "capital/withdraw/address", 10 },
                            { "capital/deposit/address", 10 },
                            { "capital/transfer", 1 },
                            { "capital/transfer/tranId", 1 },
                            { "capital/transfer/internal", 1 },
                            { "capital/sub-account/universalTransfer", 1 },
                            { "capital/convert", 1 },
                            { "capital/convert/list", 1 },
                            { "margin/loan", 1 },
                            { "margin/allOrders", 1 },
                            { "margin/myTrades", 1 },
                            { "margin/openOrders", 1 },
                            { "margin/maxTransferable", 1 },
                            { "margin/priceIndex", 1 },
                            { "margin/order", 1 },
                            { "margin/isolated/account", 1 },
                            { "margin/maxBorrowable", 1 },
                            { "margin/repay", 1 },
                            { "margin/isolated/pair", 1 },
                            { "margin/forceLiquidationRec", 1 },
                            { "margin/isolatedMarginData", 1 },
                            { "margin/isolatedMarginTier", 1 },
                            { "rebate/taxQuery", 1 },
                            { "rebate/detail", 1 },
                            { "rebate/detail/kickback", 1 },
                            { "rebate/referCode", 1 },
                            { "rebate/affiliate/commission", 1 },
                            { "rebate/affiliate/withdraw", 1 },
                            { "rebate/affiliate/commission/detail", 1 },
                            { "mxDeduct/enable", 1 },
                            { "userDataStream", 1 },
                            { "selfSymbols", 1 },
                        } },
                        { "post", new Dictionary<string, object>() {
                            { "order", 1 },
                            { "order/test", 1 },
                            { "sub-account/virtualSubAccount", 1 },
                            { "sub-account/apiKey", 1 },
                            { "sub-account/futures", 1 },
                            { "sub-account/margin", 1 },
                            { "batchOrders", 10 },
                            { "capital/withdraw/apply", 1 },
                            { "capital/withdraw", 1 },
                            { "capital/transfer", 1 },
                            { "capital/transfer/internal", 1 },
                            { "capital/deposit/address", 1 },
                            { "capital/sub-account/universalTransfer", 1 },
                            { "capital/convert", 10 },
                            { "mxDeduct/enable", 1 },
                            { "userDataStream", 1 },
                        } },
                        { "put", new Dictionary<string, object>() {
                            { "userDataStream", 1 },
                        } },
                        { "delete", new Dictionary<string, object>() {
                            { "order", 1 },
                            { "openOrders", 1 },
                            { "sub-account/apiKey", 1 },
                            { "margin/order", 1 },
                            { "margin/openOrders", 1 },
                            { "userDataStream", 1 },
                            { "capital/withdraw", 1 },
                        } },
                    } },
                } },
                { "contract", new Dictionary<string, object>() {
                    { "public", new Dictionary<string, object>() {
                        { "get", new Dictionary<string, object>() {
                            { "ping", 2 },
                            { "detail", 100 },
                            { "support_currencies", 2 },
                            { "depth/{symbol}", 2 },
                            { "depth_commits/{symbol}/{limit}", 2 },
                            { "index_price/{symbol}", 2 },
                            { "fair_price/{symbol}", 2 },
                            { "funding_rate/{symbol}", 2 },
                            { "kline/{symbol}", 2 },
                            { "kline/index_price/{symbol}", 2 },
                            { "kline/fair_price/{symbol}", 2 },
                            { "deals/{symbol}", 2 },
                            { "ticker", 2 },
                            { "risk_reverse", 2 },
                            { "risk_reverse/history", 2 },
                            { "funding_rate/history", 2 },
                        } },
                    } },
                    { "private", new Dictionary<string, object>() {
                        { "get", new Dictionary<string, object>() {
                            { "account/assets", 2 },
                            { "account/asset/{currency}", 2 },
                            { "account/transfer_record", 2 },
                            { "position/list/history_positions", 2 },
                            { "position/open_positions", 2 },
                            { "position/funding_records", 2 },
                            { "position/position_mode", 2 },
                            { "order/list/open_orders/{symbol}", 2 },
                            { "order/list/history_orders", 2 },
                            { "order/external/{symbol}/{external_oid}", 2 },
                            { "order/get/{order_id}", 2 },
                            { "order/batch_query", 8 },
                            { "order/deal_details/{order_id}", 2 },
                            { "order/list/order_deals", 2 },
                            { "planorder/list/orders", 2 },
                            { "stoporder/list/orders", 2 },
                            { "stoporder/order_details/{stop_order_id}", 2 },
                            { "account/risk_limit", 2 },
                            { "account/tiered_fee_rate", 2 },
                            { "position/leverage", 2 },
                        } },
                        { "post", new Dictionary<string, object>() {
                            { "position/change_margin", 2 },
                            { "position/change_leverage", 2 },
                            { "position/change_position_mode", 2 },
                            { "order/submit", 2 },
                            { "order/submit_batch", 40 },
                            { "order/cancel", 2 },
                            { "order/cancel_with_external", 2 },
                            { "order/cancel_all", 2 },
                            { "account/change_risk_level", 2 },
                            { "planorder/place", 2 },
                            { "planorder/cancel", 2 },
                            { "planorder/cancel_all", 2 },
                            { "stoporder/cancel", 2 },
                            { "stoporder/cancel_all", 2 },
                            { "stoporder/change_price", 2 },
                            { "stoporder/change_plan_price", 2 },
                        } },
                    } },
                } },
                { "spot2", new Dictionary<string, object>() {
                    { "public", new Dictionary<string, object>() {
                        { "get", new Dictionary<string, object>() {
                            { "market/symbols", 1 },
                            { "market/coin/list", 2 },
                            { "common/timestamp", 1 },
                            { "common/ping", 2 },
                            { "market/ticker", 1 },
                            { "market/depth", 1 },
                            { "market/deals", 1 },
                            { "market/kline", 1 },
                            { "market/api_default_symbols", 2 },
                        } },
                    } },
                    { "private", new Dictionary<string, object>() {
                        { "get", new Dictionary<string, object>() {
                            { "account/info", 1 },
                            { "order/open_orders", 1 },
                            { "order/list", 1 },
                            { "order/query", 1 },
                            { "order/deals", 1 },
                            { "order/deal_detail", 1 },
                            { "asset/deposit/address/list", 2 },
                            { "asset/deposit/list", 2 },
                            { "asset/address/list", 2 },
                            { "asset/withdraw/list", 2 },
                            { "asset/internal/transfer/record", 10 },
                            { "account/balance", 10 },
                            { "asset/internal/transfer/info", 10 },
                            { "market/api_symbols", 2 },
                        } },
                        { "post", new Dictionary<string, object>() {
                            { "order/place", 1 },
                            { "order/place_batch", 1 },
                            { "order/advanced/place_batch", 1 },
                            { "asset/withdraw", 2 },
                            { "asset/internal/transfer", 10 },
                        } },
                        { "delete", new Dictionary<string, object>() {
                            { "order/cancel", 1 },
                            { "order/cancel_by_symbol", 1 },
                            { "asset/withdraw", 2 },
                        } },
                    } },
                } },
                { "broker", new Dictionary<string, object>() {
                    { "private", new Dictionary<string, object>() {
                        { "get", new Dictionary<string, object>() {
                            { "sub-account/universalTransfer", 1 },
                            { "sub-account/list", 1 },
                            { "sub-account/apiKey", 1 },
                            { "capital/deposit/subAddress", 1 },
                            { "capital/deposit/subHisrec", 1 },
                            { "capital/deposit/subHisrec/getall", 1 },
                        } },
                        { "post", new Dictionary<string, object>() {
                            { "sub-account/virtualSubAccount", 1 },
                            { "sub-account/apiKey", 1 },
                            { "capital/deposit/subAddress", 1 },
                            { "capital/withdraw/apply", 1 },
                            { "sub-account/universalTransfer", 1 },
                            { "sub-account/futures", 1 },
                        } },
                        { "delete", new Dictionary<string, object>() {
                            { "sub-account/apiKey", 1 },
                        } },
                    } },
                } },
            } },
            { "precisionMode", TICK_SIZE },
            { "timeframes", new Dictionary<string, object>() {
                { "1m", "1m" },
                { "5m", "5m" },
                { "15m", "15m" },
                { "30m", "30m" },
                { "1h", "1h" },
                { "4h", "4h" },
                { "8h", "8h" },
                { "1d", "1d" },
                { "1w", "1w" },
                { "1M", "1M" },
            } },
            { "fees", new Dictionary<string, object>() {
                { "trading", new Dictionary<string, object>() {
                    { "tierBased", false },
                    { "percentage", true },
                    { "maker", this.parseNumber("0.002") },
                    { "taker", this.parseNumber("0.002") },
                } },
            } },
            { "options", new Dictionary<string, object>() {
                { "adjustForTimeDifference", false },
                { "timeDifference", 0 },
                { "unavailableContracts", new Dictionary<string, object>() {
                    { "BTC/USDT:USDT", true },
                    { "LTC/USDT:USDT", true },
                    { "ETH/USDT:USDT", true },
                } },
                { "fetchMarkets", new Dictionary<string, object>() {
                    { "types", new Dictionary<string, object>() {
                        { "spot", true },
                        { "swap", new Dictionary<string, object>() {
                            { "linear", true },
                            { "inverse", false },
                        } },
                    } },
                } },
                { "useCcxtTradeId", true },
                { "timeframes", new Dictionary<string, object>() {
                    { "spot", new Dictionary<string, object>() {
                        { "1m", "1m" },
                        { "5m", "5m" },
                        { "15m", "15m" },
                        { "30m", "30m" },
                        { "1h", "60m" },
                        { "4h", "4h" },
                        { "1d", "1d" },
                        { "1w", "1W" },
                        { "1M", "1M" },
                    } },
                    { "swap", new Dictionary<string, object>() {
                        { "1m", "Min1" },
                        { "5m", "Min5" },
                        { "15m", "Min15" },
                        { "30m", "Min30" },
                        { "1h", "Min60" },
                        { "4h", "Hour4" },
                        { "8h", "Hour8" },
                        { "1d", "Day1" },
                        { "1w", "Week1" },
                        { "1M", "Month1" },
                    } },
                } },
                { "defaultType", "spot" },
                { "defaultNetwork", "ETH" },
                { "defaultNetworks", new Dictionary<string, object>() {
                    { "ETH", "ETH" },
                    { "USDT", "ERC20" },
                    { "USDC", "ERC20" },
                    { "BTC", "BTC" },
                    { "LTC", "LTC" },
                } },
                { "networks", new Dictionary<string, object>() {
                    { "ZKSYNC", "ZKSYNCERA" },
                    { "TRC20", "TRX" },
                    { "TON", "TONCOIN" },
                    { "ARBITRUM", "ARB" },
                    { "STX", "STACKS" },
                    { "LUNC", "LUNA" },
                    { "STARK", "STARKNET" },
                    { "APT", "APTOS" },
                    { "PEAQ", "PEAQEVM" },
                    { "AVAXC", "AVAX_CCHAIN" },
                    { "ERC20", "ETH" },
                    { "ACA", "ACALA" },
                    { "BEP20", "BSC" },
                    { "OPTIMISM", "OP" },
                    { "ASTR", "ASTAR" },
                    { "BTM", "BTM2" },
                    { "CRC20", "CRONOS" },
                    { "DOT", "DOTASSETHUB" },
                    { "ETHF", "ETF" },
                    { "HRC20", "HECO" },
                    { "OASIS", "ROSE" },
                    { "OKC", "OKT" },
                    { "RSK", "RBTC" },
                } },
                { "networksById", new Dictionary<string, object>() {
                    { "BNB Smart Chain(BEP20-RACAV1)", "BSC" },
                    { "BNB Smart Chain(BEP20-RACAV2)", "BSC" },
                    { "BNB Smart Chain(BEP20)", "BSC" },
                    { "Ethereum(ERC20)", "ERC20" },
                } },
                { "recvWindow", multiply(5, 1000) },
                { "maxTimeTillEnd", subtract(multiply(multiply(90, 86400), 1000), 1) },
                { "broker", "CCXT" },
            } },
            { "features", new Dictionary<string, object>() {
                { "default", new Dictionary<string, object>() {
                    { "sandbox", false },
                    { "createOrder", new Dictionary<string, object>() {
                        { "marginMode", true },
                        { "triggerPrice", false },
                        { "triggerDirection", false },
                        { "triggerPriceType", new Dictionary<string, object>() {
                            { "last", false },
                            { "mark", false },
                            { "index", false },
                        } },
                        { "stopLossPrice", false },
                        { "takeProfitPrice", false },
                        { "attachedStopLossTakeProfit", null },
                        { "timeInForce", new Dictionary<string, object>() {
                            { "IOC", true },
                            { "FOK", true },
                            { "PO", true },
                            { "GTD", false },
                        } },
                        { "hedged", true },
                        { "trailing", false },
                        { "leverage", true },
                        { "marketBuyByCost", true },
                        { "marketBuyRequiresPrice", false },
                        { "selfTradePrevention", false },
                        { "iceberg", false },
                    } },
                    { "createOrders", new Dictionary<string, object>() {
                        { "max", 20 },
                    } },
                    { "fetchMyTrades", new Dictionary<string, object>() {
                        { "marginMode", false },
                        { "limit", 100 },
                        { "daysBack", 30 },
                        { "untilDays", null },
                        { "symbolRequired", true },
                    } },
                    { "fetchOrder", new Dictionary<string, object>() {
                        { "marginMode", false },
                        { "trigger", false },
                        { "trailing", false },
                        { "symbolRequired", true },
                    } },
                    { "fetchOpenOrders", new Dictionary<string, object>() {
                        { "marginMode", true },
                        { "limit", null },
                        { "trigger", false },
                        { "trailing", false },
                        { "symbolRequired", true },
                    } },
                    { "fetchOrders", new Dictionary<string, object>() {
                        { "marginMode", true },
                        { "limit", 1000 },
                        { "daysBack", 7 },
                        { "untilDays", 7 },
                        { "trigger", false },
                        { "trailing", false },
                        { "symbolRequired", true },
                    } },
                    { "fetchClosedOrders", new Dictionary<string, object>() {
                        { "marginMode", true },
                        { "limit", 1000 },
                        { "daysBack", 7 },
                        { "daysBackCanceled", 7 },
                        { "untilDays", 7 },
                        { "trigger", false },
                        { "trailing", false },
                        { "symbolRequired", true },
                    } },
                    { "fetchOHLCV", new Dictionary<string, object>() {
                        { "limit", 1000 },
                    } },
                } },
                { "spot", new Dictionary<string, object>() {
                    { "extends", "default" },
                    { "fetchCurrencies", new Dictionary<string, object>() {
                        { "private", true },
                    } },
                } },
                { "forDerivs", new Dictionary<string, object>() {
                    { "extends", "default" },
                    { "createOrder", new Dictionary<string, object>() {
                        { "triggerPrice", true },
                        { "triggerPriceType", new Dictionary<string, object>() {
                            { "last", true },
                            { "mark", true },
                            { "index", true },
                        } },
                        { "triggerDirection", true },
                        { "stopLossPrice", false },
                        { "takeProfitPrice", false },
                        { "hedged", true },
                        { "leverage", true },
                        { "marketBuyByCost", false },
                    } },
                    { "createOrders", null },
                    { "fetchMyTrades", new Dictionary<string, object>() {
                        { "marginMode", false },
                        { "limit", 100 },
                        { "daysBack", 90 },
                        { "untilDays", 90 },
                    } },
                    { "fetchOrder", new Dictionary<string, object>() {
                        { "marginMode", false },
                    } },
                    { "fetchOpenOrders", new Dictionary<string, object>() {
                        { "marginMode", false },
                        { "limit", 100 },
                        { "trigger", true },
                        { "trailing", false },
                    } },
                    { "fetchOrders", new Dictionary<string, object>() {
                        { "marginMode", false },
                        { "limit", 100 },
                        { "daysBack", 90 },
                        { "untilDays", 90 },
                        { "trigger", true },
                        { "trailing", false },
                    } },
                    { "fetchClosedOrders", new Dictionary<string, object>() {
                        { "marginMode", false },
                        { "limit", 100 },
                        { "daysBack", 90 },
                        { "daysBackCanceled", null },
                        { "untilDays", 90 },
                        { "trigger", true },
                        { "trailing", false },
                    } },
                    { "fetchOHLCV", new Dictionary<string, object>() {
                        { "limit", 2000 },
                    } },
                } },
                { "swap", new Dictionary<string, object>() {
                    { "linear", new Dictionary<string, object>() {
                        { "extends", "forDerivs" },
                    } },
                    { "inverse", new Dictionary<string, object>() {
                        { "extends", "forDerivs" },
                    } },
                } },
                { "future", new Dictionary<string, object>() {
                    { "linear", null },
                    { "inverse", null },
                } },
            } },
            { "commonCurrencies", new Dictionary<string, object>() {
                { "BEYONDPROTOCOL", "BEYOND" },
                { "BIFI", "BIFIF" },
                { "BYN", "BEYONDFI" },
                { "COFI", "COFIX" },
                { "DFI", "DFISTARTER" },
                { "DFT", "DFUTURE" },
                { "DRK", "DRK" },
                { "EGC", "EGORASCREDIT" },
                { "FLUX1", "FLUX" },
                { "FLUX", "FLUX1" },
                { "FREE", "FREEROSSDAO" },
                { "GAS", "GASDAO" },
                { "GASNEO", "GAS" },
                { "GMT", "GMTTOKEN" },
                { "STEPN", "GMT" },
                { "HERO", "STEPHERO" },
                { "MIMO", "MIMOSA" },
                { "PROS", "PROSFINANCE" },
                { "SIN", "SINCITYTOKEN" },
                { "SOUL", "SOULSWAP" },
                { "XBT", "XBT" },
            } },
            { "exceptions", new Dictionary<string, object>() {
                { "exact", new Dictionary<string, object>() {
                    { "-1128", typeof(BadRequest) },
                    { "-2011", typeof(BadRequest) },
                    { "-1121", typeof(BadSymbol) },
                    { "10101", typeof(InsufficientFunds) },
                    { "2009", typeof(InvalidOrder) },
                    { "2011", typeof(BadRequest) },
                    { "30004", typeof(InsufficientFunds) },
                    { "33333", typeof(BadRequest) },
                    { "44444", typeof(BadRequest) },
                    { "1002", typeof(InvalidOrder) },
                    { "30019", typeof(BadRequest) },
                    { "30005", typeof(InvalidOrder) },
                    { "2003", typeof(InvalidOrder) },
                    { "2005", typeof(InsufficientFunds) },
                    { "400", typeof(BadRequest) },
                    { "600", typeof(BadRequest) },
                    { "70011", typeof(PermissionDenied) },
                    { "88004", typeof(InsufficientFunds) },
                    { "88009", typeof(ExchangeError) },
                    { "88013", typeof(InvalidOrder) },
                    { "88015", typeof(InsufficientFunds) },
                    { "700003", typeof(InvalidNonce) },
                    { "26", typeof(ExchangeError) },
                    { "602", typeof(AuthenticationError) },
                    { "10001", typeof(AuthenticationError) },
                    { "10007", typeof(BadSymbol) },
                    { "10015", typeof(BadRequest) },
                    { "10072", typeof(BadRequest) },
                    { "10073", typeof(BadRequest) },
                    { "10095", typeof(InvalidOrder) },
                    { "10096", typeof(InvalidOrder) },
                    { "10097", typeof(InvalidOrder) },
                    { "10098", typeof(InvalidOrder) },
                    { "10099", typeof(BadRequest) },
                    { "10100", typeof(BadRequest) },
                    { "10102", typeof(InvalidOrder) },
                    { "10103", typeof(ExchangeError) },
                    { "10200", typeof(BadRequest) },
                    { "10201", typeof(BadRequest) },
                    { "10202", typeof(BadRequest) },
                    { "10206", typeof(BadRequest) },
                    { "10211", typeof(BadRequest) },
                    { "10212", typeof(BadRequest) },
                    { "10216", typeof(ExchangeError) },
                    { "10219", typeof(ExchangeError) },
                    { "10222", typeof(BadRequest) },
                    { "10232", typeof(BadRequest) },
                    { "10259", typeof(ExchangeError) },
                    { "10265", typeof(ExchangeError) },
                    { "10268", typeof(BadRequest) },
                    { "20001", typeof(ExchangeError) },
                    { "20002", typeof(ExchangeError) },
                    { "22222", typeof(BadRequest) },
                    { "30000", typeof(ExchangeError) },
                    { "30001", typeof(InvalidOrder) },
                    { "30002", typeof(InvalidOrder) },
                    { "30003", typeof(InvalidOrder) },
                    { "30010", typeof(InvalidOrder) },
                    { "30014", typeof(InvalidOrder) },
                    { "30016", typeof(InvalidOrder) },
                    { "30018", typeof(AccountSuspended) },
                    { "30020", typeof(AuthenticationError) },
                    { "30021", typeof(BadRequest) },
                    { "30025", typeof(InvalidOrder) },
                    { "30026", typeof(BadRequest) },
                    { "30027", typeof(InvalidOrder) },
                    { "30028", typeof(InvalidOrder) },
                    { "30029", typeof(InvalidOrder) },
                    { "30032", typeof(InvalidOrder) },
                    { "30041", typeof(InvalidOrder) },
                    { "60005", typeof(ExchangeError) },
                    { "700001", typeof(AuthenticationError) },
                    { "700002", typeof(AuthenticationError) },
                    { "700004", typeof(BadRequest) },
                    { "700005", typeof(InvalidNonce) },
                    { "700006", typeof(BadRequest) },
                    { "700007", typeof(AuthenticationError) },
                    { "700008", typeof(BadRequest) },
                    { "700013", typeof(AuthenticationError) },
                    { "730001", typeof(BadRequest) },
                    { "730002", typeof(BadRequest) },
                    { "730000", typeof(ExchangeError) },
                    { "730003", typeof(ExchangeError) },
                    { "730100", typeof(ExchangeError) },
                    { "730600", typeof(BadRequest) },
                    { "730601", typeof(BadRequest) },
                    { "730602", typeof(BadRequest) },
                    { "730700", typeof(BadRequest) },
                    { "730701", typeof(BadRequest) },
                    { "730702", typeof(BadRequest) },
                    { "730703", typeof(BadRequest) },
                    { "730704", typeof(BadRequest) },
                    { "730705", typeof(BadRequest) },
                    { "730706", typeof(BadRequest) },
                    { "730707", typeof(BadRequest) },
                    { "730101", typeof(BadRequest) },
                    { "140001", typeof(BadRequest) },
                    { "140002", typeof(AuthenticationError) },
                } },
                { "broad", new Dictionary<string, object>() {
                    { "Order quantity error, please try to modify.", typeof(BadRequest) },
                    { "Combination of optional parameters invalid", typeof(BadRequest) },
                    { "api market order is disabled", typeof(BadRequest) },
                    { "Contract not allow place order!", typeof(InvalidOrder) },
                    { "Oversold", typeof(InsufficientFunds) },
                    { "Insufficient position", typeof(InsufficientFunds) },
                    { "Insufficient balance!", typeof(InsufficientFunds) },
                    { "Bid price is great than max allow price", typeof(InvalidOrder) },
                    { "Invalid symbol.", typeof(BadSymbol) },
                    { "Param error!", typeof(BadRequest) },
                    { "maintenance", typeof(OnMaintenance) },
                } },
            } },
        });
    }

    /**
     * @method
     * @name mexc#fetchStatus
     * @description the latest known information on the availability of the exchange API
     * @see https://mexcdevelop.github.io/apidocs/spot_v3_en/#test-connectivity
     * @see https://mexcdevelop.github.io/apidocs/contract_v1_en/#get-the-server-time
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [status structure]{@link https://docs.ccxt.com/#/?id=exchange-status-structure}
     */
    public async override Task<object> fetchStatus(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        var marketTypequeryVariable = this.handleMarketTypeAndParams("fetchStatus", null, parameters);
        var marketType = ((IList<object>) marketTypequeryVariable)[0];
        var query = ((IList<object>) marketTypequeryVariable)[1];
        object response = null;
        object status = null;
        object updated = null;
        if (isTrue(isEqual(marketType, "spot")))
        {
            response = await this.spotPublicGetPing(query);
            //
            //     {}
            //
            object keys = new List<object>(((IDictionary<string,object>)response).Keys);
            object length = getArrayLength(keys);
            status = ((bool) isTrue(length)) ? this.json(response) : "ok";
        } else if (isTrue(isEqual(marketType, "swap")))
        {
            response = await this.contractPublicGetPing(query);
            //
            //     {"success":true,"code":"0","data":"1648124374985"}
            //
            status = ((bool) isTrue(this.safeValue(response, "success"))) ? "ok" : this.json(response);
            updated = this.safeInteger(response, "data");
        }
        return new Dictionary<string, object>() {
            { "status", status },
            { "updated", updated },
            { "url", null },
            { "eta", null },
            { "info", response },
        };
    }

    /**
     * @method
     * @name mexc#fetchTime
     * @description fetches the current integer timestamp in milliseconds from the exchange server
     * @see https://mexcdevelop.github.io/apidocs/spot_v3_en/#check-server-time
     * @see https://mexcdevelop.github.io/apidocs/contract_v1_en/#get-the-server-time
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {int} the current integer timestamp in milliseconds from the exchange server
     */
    public async override Task<object> fetchTime(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        var marketTypequeryVariable = this.handleMarketTypeAndParams("fetchTime", null, parameters);
        var marketType = ((IList<object>) marketTypequeryVariable)[0];
        var query = ((IList<object>) marketTypequeryVariable)[1];
        object response = null;
        if (isTrue(isEqual(marketType, "spot")))
        {
            response = await this.spotPublicGetTime(query);
            //
            //     {"serverTime": "1647519277579"}
            //
            return this.safeInteger(response, "serverTime");
        } else if (isTrue(isEqual(marketType, "swap")))
        {
            response = await this.contractPublicGetPing(query);
            //
            //     {"success":true,"code":"0","data":"1648124374985"}
            //
            return this.safeInteger(response, "data");
        }
        return null;
    }

    /**
     * @method
     * @name mexc#fetchCurrencies
     * @description fetches all available currencies on an exchange
     * @see https://mexcdevelop.github.io/apidocs/spot_v3_en/#query-the-currency-information
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} an associative dictionary of currencies
     */
    public async override Task<object> fetchCurrencies(object parameters = null)
    {
        // this endpoint requires authentication
        // while fetchCurrencies is a public API method by design
        // therefore we check the keys here
        // and fallback to generating the currencies from the markets
        parameters ??= new Dictionary<string, object>();
        if (!isTrue(this.checkRequiredCredentials(false)))
        {
            return new Dictionary<string, object>() {};
        }
        object response = await this.spotPrivateGetCapitalConfigGetall(parameters);
        //
        // {
        //     "coin": "QANX",
        //     "name": "QANplatform",
        //     "networkList": [
        //       {
        //         "coin": "QANX",
        //         "depositDesc": null,
        //         "depositEnable": true,
        //         "minConfirm": "0",
        //         "name": "QANplatform",
        //         "network": "BEP20(BSC)",
        //         "withdrawEnable": false,
        //         "withdrawFee": "42.000000000000000000",
        //         "withdrawIntegerMultiple": null,
        //         "withdrawMax": "24000000.000000000000000000",
        //         "withdrawMin": "20.000000000000000000",
        //         "sameAddress": false,
        //         "contract": "0xAAA7A10a8ee237ea61E8AC46C50A8Db8bCC1baaa"
        //       },
        //       {
        //         "coin": "QANX",
        //         "depositDesc": null,
        //         "depositEnable": true,
        //         "minConfirm": "0",
        //         "name": "QANplatform",
        //         "network": "ERC20",
        //         "withdrawEnable": true,
        //         "withdrawFee": "2732.000000000000000000",
        //         "withdrawIntegerMultiple": null,
        //         "withdrawMax": "24000000.000000000000000000",
        //         "withdrawMin": "240.000000000000000000",
        //         "sameAddress": false,
        //         "contract": "0xAAA7A10a8ee237ea61E8AC46C50A8Db8bCC1baaa"
        //       }
        //     ]
        //   }
        //
        object result = new Dictionary<string, object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(response)); postFixIncrement(ref i))
        {
            object currency = getValue(response, i);
            object id = this.safeString(currency, "coin");
            object code = this.safeCurrencyCode(id);
            object networks = new Dictionary<string, object>() {};
            object chains = this.safeValue(currency, "networkList", new List<object>() {});
            for (object j = 0; isLessThan(j, getArrayLength(chains)); postFixIncrement(ref j))
            {
                object chain = getValue(chains, j);
                object networkId = this.safeString2(chain, "netWork", "network");
                object network = this.networkIdToCode(networkId);
                ((IDictionary<string,object>)networks)[(string)network] = new Dictionary<string, object>() {
                    { "info", chain },
                    { "id", networkId },
                    { "network", network },
                    { "active", null },
                    { "deposit", this.safeBool(chain, "depositEnable", false) },
                    { "withdraw", this.safeBool(chain, "withdrawEnable", false) },
                    { "fee", this.safeNumber(chain, "withdrawFee") },
                    { "precision", null },
                    { "limits", new Dictionary<string, object>() {
                        { "withdraw", new Dictionary<string, object>() {
                            { "min", this.safeString(chain, "withdrawMin") },
                            { "max", this.safeString(chain, "withdrawMax") },
                        } },
                    } },
                    { "contract", this.safeString(chain, "contract") },
                };
            }
            ((IDictionary<string,object>)result)[(string)code] = this.safeCurrencyStructure(new Dictionary<string, object>() {
                { "info", currency },
                { "id", id },
                { "code", code },
                { "name", this.safeString(currency, "name") },
                { "active", null },
                { "deposit", null },
                { "withdraw", null },
                { "fee", null },
                { "precision", null },
                { "limits", new Dictionary<string, object>() {
                    { "amount", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                } },
                { "type", "crypto" },
                { "networks", networks },
            });
        }
        return result;
    }

    /**
     * @method
     * @name mexc#fetchMarkets
     * @description retrieves data on all markets for mexc
     * @see https://mexcdevelop.github.io/apidocs/spot_v3_en/#exchange-information
     * @see https://mexcdevelop.github.io/apidocs/contract_v1_en/#get-the-contract-information
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} an array of objects representing market data
     */
    public async override Task<object> fetchMarkets(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (isTrue(getValue(this.options, "adjustForTimeDifference")))
        {
            await this.loadTimeDifference();
        }
        object spotMarketPromise = this.fetchSpotMarkets(parameters);
        object swapMarketPromise = this.fetchSwapMarkets(parameters);
        var spotMarketswapMarketVariable = await promiseAll(new List<object>() {spotMarketPromise, swapMarketPromise});
        var spotMarket = ((IList<object>) spotMarketswapMarketVariable)[0];
        var swapMarket = ((IList<object>) spotMarketswapMarketVariable)[1];
        return this.arrayConcat(spotMarket, swapMarket);
    }

    /**
     * @ignore
     * @method
     * @name mexc#fetchMarkets
     * @description retrieves data on all spot markets for mexc
     * @see https://mexcdevelop.github.io/apidocs/spot_v3_en/#exchange-information
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} an array of objects representing market data
     */
    public async virtual Task<object> fetchSpotMarkets(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object response = await this.spotPublicGetExchangeInfo(parameters);
        //
        //     {
        //         "timezone": "CST",
        //         "serverTime": 1647521860402,
        //         "rateLimits": [],
        //         "exchangeFilters": [],
        //         "symbols": [
        //           {
        //                "symbol": "OGNUSDT",
        //                "status": "1",
        //                "baseAsset": "OGN",
        //                "baseAssetPrecision": "2",
        //                "quoteAsset": "USDT",
        //                "quoteAssetPrecision": "4",
        //                "orderTypes": [
        //                    "LIMIT",
        //                    "LIMIT_MAKER"
        //                ],
        //                "baseCommissionPrecision": "2",
        //                "quoteCommissionPrecision": "4",
        //                "quoteOrderQtyMarketAllowed": false,
        //                "isSpotTradingAllowed": true,
        //                "isMarginTradingAllowed": true,
        //                "permissions": [
        //                    "SPOT",
        //                    "MARGIN"
        //                ],
        //                "filters": [],
        //                "baseSizePrecision": "0.01", // this turned out to be a minimum base amount for order
        //                "maxQuoteAmount": "5000000",
        //                "makerCommission": "0.002",
        //                "takerCommission": "0.002"
        //                "quoteAmountPrecision": "5", // this turned out to be a minimum cost amount for order
        //                "quotePrecision": "4", // deprecated in favor of 'quoteAssetPrecision' ( https://dev.binance.vision/t/what-is-the-difference-between-quoteprecision-and-quoteassetprecision/4333 )
        //                // note, "icebergAllowed" & "ocoAllowed" fields were recently removed
        //            },
        //         ]
        //     }
        //
        // Notes:
        // - 'quoteAssetPrecision' & 'baseAssetPrecision' are not currency's real blockchain precision (to view currency's actual individual precision, refer to fetchCurrencies() method).
        //
        object data = this.safeValue(response, "symbols", new List<object>() {});
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
        {
            object market = getValue(data, i);
            object id = this.safeString(market, "symbol");
            object baseId = this.safeString(market, "baseAsset");
            object quoteId = this.safeString(market, "quoteAsset");
            object bs = this.safeCurrencyCode(baseId);
            object quote = this.safeCurrencyCode(quoteId);
            object status = this.safeString(market, "status");
            object isSpotTradingAllowed = this.safeValue(market, "isSpotTradingAllowed");
            object active = false;
            if (isTrue(isTrue((isEqual(status, "1"))) && isTrue((isSpotTradingAllowed))))
            {
                active = true;
            }
            object isMarginTradingAllowed = this.safeValue(market, "isMarginTradingAllowed");
            object makerCommission = this.safeNumber(market, "makerCommission");
            object takerCommission = this.safeNumber(market, "takerCommission");
            object maxQuoteAmount = this.safeNumber(market, "maxQuoteAmount");
            ((IList<object>)result).Add(new Dictionary<string, object>() {
                { "id", id },
                { "symbol", add(add(bs, "/"), quote) },
                { "base", bs },
                { "quote", quote },
                { "settle", null },
                { "baseId", baseId },
                { "quoteId", quoteId },
                { "settleId", null },
                { "type", "spot" },
                { "spot", true },
                { "margin", isMarginTradingAllowed },
                { "swap", false },
                { "future", false },
                { "option", false },
                { "active", active },
                { "contract", false },
                { "linear", null },
                { "inverse", null },
                { "taker", takerCommission },
                { "maker", makerCommission },
                { "contractSize", null },
                { "expiry", null },
                { "expiryDatetime", null },
                { "strike", null },
                { "optionType", null },
                { "precision", new Dictionary<string, object>() {
                    { "amount", this.parseNumber(this.parsePrecision(this.safeString(market, "baseAssetPrecision"))) },
                    { "price", this.parseNumber(this.parsePrecision(this.safeString(market, "quoteAssetPrecision"))) },
                } },
                { "limits", new Dictionary<string, object>() {
                    { "leverage", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                    { "amount", new Dictionary<string, object>() {
                        { "min", this.safeNumber(market, "baseSizePrecision") },
                        { "max", null },
                    } },
                    { "price", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                    { "cost", new Dictionary<string, object>() {
                        { "min", this.safeNumber(market, "quoteAmountPrecision") },
                        { "max", maxQuoteAmount },
                    } },
                } },
                { "created", null },
                { "info", market },
            });
        }
        return result;
    }

    /**
     * @ignore
     * @method
     * @name mexc#fetchMarkets
     * @description retrieves data on all swap markets for mexc
     * @see https://mexcdevelop.github.io/apidocs/contract_v1_en/#get-the-contract-information
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} an array of objects representing market data
     */
    public async virtual Task<object> fetchSwapMarkets(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object currentRl = this.rateLimit;
        this.setProperty(this, "rateLimit", 10); // see comment: https://github.com/ccxt/ccxt/pull/23698
        object response = await this.contractPublicGetDetail(parameters);
        this.setProperty(this, "rateLimit", currentRl);
        //
        //     {
        //         "success":true,
        //         "code":0,
        //         "data":[
        //             {
        //                 "symbol":"BTC_USDT",
        //                 "displayName":"BTC_USDT",
        //                 "displayNameEn":"BTC_USDT SWAP",
        //                 "positionOpenType":3,
        //                 "baseCoin":"BTC",
        //                 "quoteCoin":"USDT",
        //                 "settleCoin":"USDT",
        //                 "contractSize":0.0001,
        //                 "minLeverage":1,
        //                 "maxLeverage":125,
        //                 "priceScale":2, // seems useless atm, as it's just how UI shows the price, i.e. 29583.50 for BTC/USDT:USDT, while price ticksize is 0.5
        //                 "volScale":0, // probably: contract amount precision
        //                 "amountScale":4, // probably: quote currency precision
        //                 "priceUnit":0.5, // price tick size
        //                 "volUnit":1, // probably: contract tick size
        //                 "minVol":1,
        //                 "maxVol":1000000,
        //                 "bidLimitPriceRate":0.1,
        //                 "askLimitPriceRate":0.1,
        //                 "takerFeeRate":0.0006,
        //                 "makerFeeRate":0.0002,
        //                 "maintenanceMarginRate":0.004,
        //                 "initialMarginRate":0.008,
        //                 "riskBaseVol":10000,
        //                 "riskIncrVol":200000,
        //                 "riskIncrMmr":0.004,
        //                 "riskIncrImr":0.004,
        //                 "riskLevelLimit":5,
        //                 "priceCoefficientVariation":0.1,
        //                 "indexOrigin":["BINANCE","GATEIO","HUOBI","MXC"],
        //                 "state":0, // 0 enabled, 1 delivery, 2 completed, 3 offline, 4 pause
        //                 "isNew":false,
        //                 "isHot":true,
        //                 "isHidden":false
        //             },
        //         ]
        //     }
        //
        object data = this.safeValue(response, "data", new List<object>() {});
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
        {
            object market = getValue(data, i);
            object id = this.safeString(market, "symbol");
            object baseId = this.safeString(market, "baseCoin");
            object quoteId = this.safeString(market, "quoteCoin");
            object settleId = this.safeString(market, "settleCoin");
            object bs = this.safeCurrencyCode(baseId);
            object quote = this.safeCurrencyCode(quoteId);
            object settle = this.safeCurrencyCode(settleId);
            object state = this.safeString(market, "state");
            object isLinear = isEqual(quote, settle);
            ((IList<object>)result).Add(new Dictionary<string, object>() {
                { "id", id },
                { "symbol", add(add(add(add(bs, "/"), quote), ":"), settle) },
                { "base", bs },
                { "quote", quote },
                { "settle", settle },
                { "baseId", baseId },
                { "quoteId", quoteId },
                { "settleId", settleId },
                { "type", "swap" },
                { "spot", false },
                { "margin", false },
                { "swap", true },
                { "future", false },
                { "option", false },
                { "active", (isEqual(state, "0")) },
                { "contract", true },
                { "linear", isLinear },
                { "inverse", !isTrue(isLinear) },
                { "taker", this.safeNumber(market, "takerFeeRate") },
                { "maker", this.safeNumber(market, "makerFeeRate") },
                { "contractSize", this.safeNumber(market, "contractSize") },
                { "expiry", null },
                { "expiryDatetime", null },
                { "strike", null },
                { "optionType", null },
                { "precision", new Dictionary<string, object>() {
                    { "amount", this.safeNumber(market, "volUnit") },
                    { "price", this.safeNumber(market, "priceUnit") },
                } },
                { "limits", new Dictionary<string, object>() {
                    { "leverage", new Dictionary<string, object>() {
                        { "min", this.safeNumber(market, "minLeverage") },
                        { "max", this.safeNumber(market, "maxLeverage") },
                    } },
                    { "amount", new Dictionary<string, object>() {
                        { "min", this.safeNumber(market, "minVol") },
                        { "max", this.safeNumber(market, "maxVol") },
                    } },
                    { "price", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                    { "cost", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                } },
                { "created", null },
                { "info", market },
            });
        }
        return result;
    }

    /**
     * @method
     * @name mexc#fetchOrderBook
     * @see https://mexcdevelop.github.io/apidocs/spot_v3_en/#order-book
     * @see https://mexcdevelop.github.io/apidocs/contract_v1_en/#get-the-contract-s-depth-information
     * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
     * @param {string} symbol unified symbol of the market to fetch the order book for
     * @param {int} [limit] the maximum amount of order book entries to return
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
     */
    public async override Task<object> fetchOrderBook(object symbol, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        object orderbook = null;
        if (isTrue(getValue(market, "spot")))
        {
            object response = await this.spotPublicGetDepth(this.extend(request, parameters));
            //
            //     {
            //         "lastUpdateId": "744267132",
            //         "bids": [
            //             ["40838.50","0.387864"],
            //             ["40837.95","0.008400"],
            //         ],
            //         "asks": [
            //             ["40838.61","6.544908"],
            //             ["40838.88","0.498000"],
            //         ]
            //     }
            //
            object spotTimestamp = this.safeInteger(response, "timestamp");
            orderbook = this.parseOrderBook(response, symbol, spotTimestamp);
            ((IDictionary<string,object>)orderbook)["nonce"] = this.safeInteger(response, "lastUpdateId");
        } else if (isTrue(getValue(market, "swap")))
        {
            object response = await this.contractPublicGetDepthSymbol(this.extend(request, parameters));
            //
            //     {
            //         "success":true,
            //         "code":0,
            //         "data":{
            //             "asks":[
            //                 [3445.72,48379,1],
            //                 [3445.75,34994,1],
            //             ],
            //             "bids":[
            //                 [3445.55,44081,1],
            //                 [3445.51,24857,1],
            //             ],
            //             "version":2827730444,
            //             "timestamp":1634117846232
            //         }
            //     }
            //
            object data = this.safeValue(response, "data");
            object timestamp = this.safeInteger(data, "timestamp");
            orderbook = this.parseOrderBook(data, symbol, timestamp);
            ((IDictionary<string,object>)orderbook)["nonce"] = this.safeInteger(data, "version");
        }
        return orderbook;
    }

    public override object parseBidAsk(object bidask, object priceKey = null, object amountKey = null, object countOrIdKey = null)
    {
        priceKey ??= 0;
        amountKey ??= 1;
        countOrIdKey ??= 2;
        object countKey = 2;
        object price = this.safeNumber(bidask, priceKey);
        object amount = this.safeNumber(bidask, amountKey);
        object count = this.safeNumber(bidask, countKey);
        if (isTrue(!isEqual(count, null)))
        {
            return new List<object>() {price, amount, count};
        }
        return new List<object>() {price, amount};
    }

    /**
     * @method
     * @name mexc#fetchTrades
     * @see https://mexcdevelop.github.io/apidocs/spot_v3_en/#recent-trades-list
     * @see https://mexcdevelop.github.io/apidocs/spot_v3_en/#compressed-aggregate-trades-list
     * @see https://mexcdevelop.github.io/apidocs/contract_v1_en/#get-contract-transaction-data
     * @description get the list of most recent trades for a particular symbol
     * @param {string} symbol unified symbol of the market to fetch trades for
     * @param {int} [since] timestamp in ms of the earliest trade to fetch
     * @param {int} [limit] the maximum amount of trades to fetch
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {int} [params.until] *spot only* *since must be defined* the latest time in ms to fetch entries for
     * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
     */
    public async override Task<object> fetchTrades(object symbol, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        object trades = null;
        if (isTrue(getValue(market, "spot")))
        {
            object until = this.safeIntegerN(parameters, new List<object>() {"endTime", "until"});
            if (isTrue(!isEqual(since, null)))
            {
                ((IDictionary<string,object>)request)["startTime"] = since;
                if (isTrue(isEqual(until, null)))
                {
                    throw new ArgumentsRequired ((string)add(this.id, " fetchTrades() requires an until parameter when since is provided")) ;
                }
            }
            if (isTrue(!isEqual(until, null)))
            {
                if (isTrue(isEqual(since, null)))
                {
                    throw new ArgumentsRequired ((string)add(this.id, " fetchTrades() requires a since parameter when until is provided")) ;
                }
                ((IDictionary<string,object>)request)["endTime"] = until;
            }
            object method = this.safeString(this.options, "fetchTradesMethod", "spotPublicGetAggTrades");
            method = this.safeString(parameters, "method", method); // AggTrades, HistoricalTrades, Trades
            parameters = this.omit(parameters, new List<object>() {"method"});
            if (isTrue(isEqual(method, "spotPublicGetAggTrades")))
            {
                trades = await this.spotPublicGetAggTrades(this.extend(request, parameters));
            } else if (isTrue(isEqual(method, "spotPublicGetHistoricalTrades")))
            {
                trades = await this.spotPublicGetHistoricalTrades(this.extend(request, parameters));
            } else if (isTrue(isEqual(method, "spotPublicGetTrades")))
            {
                trades = await this.spotPublicGetTrades(this.extend(request, parameters));
            } else
            {
                throw new NotSupported ((string)add(this.id, " fetchTrades() not support this method")) ;
            }
        } else if (isTrue(getValue(market, "swap")))
        {
            object response = await this.contractPublicGetDealsSymbol(this.extend(request, parameters));
            //
            //     {
            //         "success": true,
            //         "code": 0,
            //         "data": [
            //             {
            //                 "p": 31199,
            //                 "v": 18,
            //                 "T": 1,
            //                 "O": 3,
            //                 "M": 2,
            //                 "t": 1609831235985
            //             },
            //         ]
            //     }
            //
            trades = this.safeValue(response, "data");
        }
        return this.parseTrades(trades, market, since, limit);
    }

    public override object parseTrade(object trade, object market = null)
    {
        object id = null;
        object timestamp = null;
        object orderId = null;
        object symbol = null;
        object fee = null;
        object type = null;
        object side = null;
        object takerOrMaker = null;
        object priceString = null;
        object amountString = null;
        object costString = null;
        // if swap
        if (isTrue(inOp(trade, "v")))
        {
            //
            // swap: fetchTrades
            //
            //     {
            //         "p": 31199,
            //         "v": 18,
            //         "T": 1,
            //         "O": 3,
            //         "M": 2,
            //         "t": 1609831235985
            //     }
            //
            timestamp = this.safeInteger(trade, "t");
            market = this.safeMarket(null, market);
            symbol = getValue(market, "symbol");
            priceString = this.safeString(trade, "p");
            amountString = this.safeString(trade, "v");
            side = this.parseOrderSide(this.safeString(trade, "T"));
            takerOrMaker = "taker";
        } else
        {
            //
            // spot: fetchTrades (for aggTrades)
            //
            //         {
            //             "a": null,
            //             "f": null,
            //             "l": null,
            //             "p": "40679",
            //             "q": "0.001309",
            //             "T": 1647551328000,
            //             "m": true,
            //             "M": true
            //         }
            //
            // spot: fetchMyTrades, fetchOrderTrades
            //
            //         {
            //             "symbol": "BTCUSDT",
            //             "id": "133948532984922113",
            //             "orderId": "133948532531949568",
            //             "orderListId": "-1",
            //             "price": "41995.51",
            //             "qty": "0.0002",
            //             "quoteQty": "8.399102",
            //             "commission": "0.016798204",
            //             "commissionAsset": "USDT",
            //             "time": "1647718055000",
            //             "isBuyer": true,
            //             "isMaker": false,
            //             "isBestMatch": true
            //         }
            //
            // swap: fetchMyTrades, fetchOrderTrades
            //
            //         {
            //             "id": "299444585",
            //             "symbol": "STEPN_USDT",
            //             "side": "1",
            //             "vol": "1",
            //             "price": "2.45455",
            //             "feeCurrency": "USDT",
            //             "fee": "0.00147273",
            //             "timestamp": "1648924557000",
            //             "profit": "0",
            //             "category": "1",
            //             "orderId": "265307163526610432",
            //             "positionMode": "1",
            //             "taker": true
            //         }
            //
            object marketId = this.safeString(trade, "symbol");
            market = this.safeMarket(marketId, market);
            symbol = getValue(market, "symbol");
            id = this.safeString2(trade, "id", "a");
            priceString = this.safeString2(trade, "price", "p");
            orderId = this.safeString(trade, "orderId");
            // if swap
            if (isTrue(inOp(trade, "positionMode")))
            {
                timestamp = this.safeInteger(trade, "timestamp");
                amountString = this.safeString(trade, "vol");
                side = this.parseOrderSide(this.safeString(trade, "side"));
                fee = new Dictionary<string, object>() {
                    { "cost", this.safeString(trade, "fee") },
                    { "currency", this.safeCurrencyCode(this.safeString(trade, "feeCurrency")) },
                };
                takerOrMaker = ((bool) isTrue(this.safeValue(trade, "taker"))) ? "taker" : "maker";
            } else
            {
                timestamp = this.safeInteger2(trade, "time", "T");
                amountString = this.safeString2(trade, "qty", "q");
                costString = this.safeString(trade, "quoteQty");
                object isBuyer = this.safeValue(trade, "isBuyer");
                object isMaker = this.safeValue(trade, "isMaker");
                object buyerMaker = this.safeValue2(trade, "isBuyerMaker", "m");
                if (isTrue(!isEqual(isMaker, null)))
                {
                    takerOrMaker = ((bool) isTrue(isMaker)) ? "maker" : "taker";
                }
                if (isTrue(!isEqual(isBuyer, null)))
                {
                    side = ((bool) isTrue(isBuyer)) ? "buy" : "sell";
                }
                if (isTrue(!isEqual(buyerMaker, null)))
                {
                    side = ((bool) isTrue(buyerMaker)) ? "sell" : "buy";
                    takerOrMaker = "taker";
                }
                object feeAsset = this.safeString(trade, "commissionAsset");
                if (isTrue(!isEqual(feeAsset, null)))
                {
                    fee = new Dictionary<string, object>() {
                        { "cost", this.safeString(trade, "commission") },
                        { "currency", this.safeCurrencyCode(feeAsset) },
                    };
                }
            }
        }
        if (isTrue(isTrue(isEqual(id, null)) && isTrue(this.safeBool(this.options, "useCcxtTradeId", true))))
        {
            id = this.createCcxtTradeId(timestamp, side, amountString, priceString, takerOrMaker);
        }
        return this.safeTrade(new Dictionary<string, object>() {
            { "id", id },
            { "order", orderId },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "symbol", symbol },
            { "type", type },
            { "side", side },
            { "takerOrMaker", takerOrMaker },
            { "price", priceString },
            { "amount", amountString },
            { "cost", costString },
            { "fee", fee },
            { "info", trade },
        }, market);
    }

    /**
     * @method
     * @name mexc#fetchOHLCV
     * @see https://mexcdevelop.github.io/apidocs/spot_v3_en/#kline-candlestick-data
     * @see https://mexcdevelop.github.io/apidocs/contract_v1_en/#k-line-data
     * @description fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
     * @param {string} symbol unified symbol of the market to fetch OHLCV data for
     * @param {string} timeframe the length of time each candle represents
     * @param {int} [since] timestamp in ms of the earliest candle to fetch
     * @param {int} [limit] the maximum amount of candles to fetch
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {int} [params.until] timestamp in ms of the latest candle to fetch
     * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [availble parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
     * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
     */
    public async override Task<object> fetchOHLCV(object symbol, object timeframe = null, object since = null, object limit = null, object parameters = null)
    {
        timeframe ??= "1m";
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object maxLimit = ((bool) isTrue((getValue(market, "spot")))) ? 1000 : 2000;
        object paginate = false;
        var paginateparametersVariable = this.handleOptionAndParams(parameters, "fetchOHLCV", "paginate", false);
        paginate = ((IList<object>)paginateparametersVariable)[0];
        parameters = ((IList<object>)paginateparametersVariable)[1];
        if (isTrue(paginate))
        {
            return await this.fetchPaginatedCallDeterministic("fetchOHLCV", symbol, since, limit, timeframe, parameters, maxLimit);
        }
        object options = this.safeValue(this.options, "timeframes", new Dictionary<string, object>() {});
        object timeframes = this.safeValue(options, getValue(market, "type"), new Dictionary<string, object>() {});
        object timeframeValue = this.safeString(timeframes, timeframe);
        object duration = multiply(this.parseTimeframe(timeframe), 1000);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
            { "interval", timeframeValue },
        };
        object candles = null;
        if (isTrue(getValue(market, "spot")))
        {
            object until = this.safeIntegerN(parameters, new List<object>() {"until", "endTime"});
            if (isTrue(!isEqual(since, null)))
            {
                ((IDictionary<string,object>)request)["startTime"] = since;
                if (isTrue(isEqual(until, null)))
                {
                    // we have to calculate it assuming we can get at most 2000 entries per request
                    object end = this.sum(since, multiply(maxLimit, duration));
                    object now = this.milliseconds();
                    ((IDictionary<string,object>)request)["endTime"] = mathMin(end, now);
                }
            }
            if (isTrue(!isEqual(limit, null)))
            {
                ((IDictionary<string,object>)request)["limit"] = limit;
            }
            if (isTrue(!isEqual(until, null)))
            {
                parameters = this.omit(parameters, new List<object>() {"until"});
                ((IDictionary<string,object>)request)["endTime"] = until;
            }
            object response = await this.spotPublicGetKlines(this.extend(request, parameters));
            //
            //     [
            //       [
            //         1640804880000,
            //         "47482.36",
            //         "47482.36",
            //         "47416.57",
            //         "47436.1",
            //         "3.550717",
            //         1640804940000,
            //         "168387.3"
            //       ],
            //     ]
            //
            candles = response;
        } else if (isTrue(getValue(market, "swap")))
        {
            object until = this.safeIntegerProductN(parameters, new List<object>() {"until", "endTime"}, 0.001);
            if (isTrue(!isEqual(since, null)))
            {
                ((IDictionary<string,object>)request)["start"] = this.parseToInt(divide(since, 1000));
            }
            if (isTrue(!isEqual(until, null)))
            {
                parameters = this.omit(parameters, new List<object>() {"until"});
                ((IDictionary<string,object>)request)["end"] = until;
            }
            object priceType = this.safeString(parameters, "price", "default");
            parameters = this.omit(parameters, "price");
            object response = null;
            if (isTrue(isEqual(priceType, "default")))
            {
                response = await this.contractPublicGetKlineSymbol(this.extend(request, parameters));
            } else if (isTrue(isEqual(priceType, "index")))
            {
                response = await this.contractPublicGetKlineIndexPriceSymbol(this.extend(request, parameters));
            } else if (isTrue(isEqual(priceType, "mark")))
            {
                response = await this.contractPublicGetKlineFairPriceSymbol(this.extend(request, parameters));
            } else
            {
                throw new NotSupported ((string)add(this.id, " fetchOHLCV() not support this price type, [default, index, mark]")) ;
            }
            //
            //     {
            //         "success":true,
            //         "code":0,
            //         "data":{
            //             "time":[1634052300,1634052360,1634052420],
            //             "open":[3492.2,3491.3,3495.65],
            //             "close":[3491.3,3495.65,3495.2],
            //             "high":[3495.85,3496.55,3499.4],
            //             "low":[3491.15,3490.9,3494.2],
            //             "vol":[1740.0,351.0,314.0],
            //             "amount":[60793.623,12260.4885,10983.1375],
            //         }
            //     }
            //
            object data = this.safeValue(response, "data");
            candles = this.convertTradingViewToOHLCV(data, "time", "open", "high", "low", "close", "vol");
        }
        return this.parseOHLCVs(candles, market, timeframe, since, limit);
    }

    public override object parseOHLCV(object ohlcv, object market = null)
    {
        return new List<object> {this.safeInteger(ohlcv, 0), this.safeNumber(ohlcv, 1), this.safeNumber(ohlcv, 2), this.safeNumber(ohlcv, 3), this.safeNumber(ohlcv, 4), this.safeNumber(ohlcv, 5)};
    }

    /**
     * @method
     * @name mexc#fetchTickers
     * @description fetches price tickers for multiple markets, statistical information calculated over the past 24 hours for each market
     * @see https://mexcdevelop.github.io/apidocs/spot_v3_en/#24hr-ticker-price-change-statistics
     * @see https://mexcdevelop.github.io/apidocs/contract_v1_en/#get-contract-trend-data
     * @param {string[]|undefined} symbols unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/#/?id=ticker-structure}
     */
    public async override Task<object> fetchTickers(object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object market = null;
        object isSingularMarket = false;
        if (isTrue(!isEqual(symbols, null)))
        {
            object length = getArrayLength(symbols);
            isSingularMarket = isEqual(length, 1);
            object firstSymbol = this.safeString(symbols, 0);
            market = this.market(firstSymbol);
        }
        var marketTypequeryVariable = this.handleMarketTypeAndParams("fetchTickers", market, parameters);
        var marketType = ((IList<object>) marketTypequeryVariable)[0];
        var query = ((IList<object>) marketTypequeryVariable)[1];
        object tickers = null;
        if (isTrue(isSingularMarket))
        {
            ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
        }
        if (isTrue(isEqual(marketType, "spot")))
        {
            tickers = await this.spotPublicGetTicker24hr(this.extend(request, query));
        } else if (isTrue(isEqual(marketType, "swap")))
        {
            object response = await this.contractPublicGetTicker(this.extend(request, query));
            //
            //     {
            //         "success":true,
            //         "code":0,
            //         "data":[
            //             {
            //                 "symbol":"ETH_USDT",
            //                 "lastPrice":3581.3,
            //                 "bid1":3581.25,
            //                 "ask1":3581.5,
            //                 "volume24":4045530,
            //                 "amount24":141331823.5755,
            //                 "holdVol":5832946,
            //                 "lower24Price":3413.4,
            //                 "high24Price":3588.7,
            //                 "riseFallRate":0.0275,
            //                 "riseFallValue":95.95,
            //                 "indexPrice":3580.7852,
            //                 "fairPrice":3581.08,
            //                 "fundingRate":0.000063,
            //                 "maxBidPrice":3938.85,
            //                 "minAskPrice":3222.7,
            //                 "timestamp":1634162885016
            //             },
            //         ]
            //     }
            //
            tickers = this.safeValue(response, "data", new List<object>() {});
        }
        // when it's single symbol request, the returned structure is different (singular object) for both spot & swap, thus we need to wrap inside array
        if (isTrue(isSingularMarket))
        {
            tickers = new List<object>() {tickers};
        }
        return this.parseTickers(tickers, symbols);
    }

    /**
     * @method
     * @name mexc#fetchTicker
     * @description fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
     * @see https://mexcdevelop.github.io/apidocs/spot_v3_en/#24hr-ticker-price-change-statistics
     * @see https://mexcdevelop.github.io/apidocs/contract_v1_en/#get-contract-trend-data
     * @param {string} symbol unified symbol of the market to fetch the ticker for
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
     */
    public async override Task<object> fetchTicker(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        var marketTypequeryVariable = this.handleMarketTypeAndParams("fetchTicker", market, parameters);
        var marketType = ((IList<object>) marketTypequeryVariable)[0];
        var query = ((IList<object>) marketTypequeryVariable)[1];
        object ticker = null;
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        if (isTrue(isEqual(marketType, "spot")))
        {
            ticker = await this.spotPublicGetTicker24hr(this.extend(request, query));
        } else if (isTrue(isEqual(marketType, "swap")))
        {
            object response = await this.contractPublicGetTicker(this.extend(request, query));
            //
            //     {
            //         "success":true,
            //         "code":0,
            //         "data":{
            //             "symbol":"ETH_USDT",
            //             "lastPrice":3581.3,
            //             "bid1":3581.25,
            //             "ask1":3581.5,
            //             "volume24":4045530,
            //             "amount24":141331823.5755,
            //             "holdVol":5832946,
            //             "lower24Price":3413.4,
            //             "high24Price":3588.7,
            //             "riseFallRate":0.0275,
            //             "riseFallValue":95.95,
            //             "indexPrice":3580.7852,
            //             "fairPrice":3581.08,
            //             "fundingRate":0.000063,
            //             "maxBidPrice":3938.85,
            //             "minAskPrice":3222.7,
            //             "timestamp":1634162885016
            //         }
            //     }
            //
            ticker = this.safeValue(response, "data", new Dictionary<string, object>() {});
        }
        // when it's single symbol request, the returned structure is different (singular object) for both spot & swap, thus we need to wrap inside array
        return this.parseTicker(ticker, market);
    }

    public override object parseTicker(object ticker, object market = null)
    {
        object marketId = this.safeString(ticker, "symbol");
        market = this.safeMarket(marketId, market);
        object timestamp = null;
        object bid = null;
        object ask = null;
        object bidVolume = null;
        object askVolume = null;
        object baseVolume = null;
        object quoteVolume = null;
        object open = null;
        object high = null;
        object low = null;
        object changePcnt = null;
        object changeValue = null;
        object prevClose = null;
        object isSwap = this.safeValue(market, "swap");
        // if swap
        if (isTrue(isTrue(isSwap) || isTrue((inOp(ticker, "timestamp")))))
        {
            //
            //     {
            //         "symbol": "ETH_USDT",
            //         "lastPrice": 3581.3,
            //         "bid1": 3581.25,
            //         "ask1": 3581.5,
            //         "volume24": 4045530,
            //         "amount24": 141331823.5755,
            //         "holdVol": 5832946,
            //         "lower24Price": 3413.4,
            //         "high24Price": 3588.7,
            //         "riseFallRate": 0.0275,
            //         "riseFallValue": 95.95,
            //         "indexPrice": 3580.7852,
            //         "fairPrice": 3581.08,
            //         "fundingRate": 0.000063,
            //         "maxBidPrice": 3938.85,
            //         "minAskPrice": 3222.7,
            //         "timestamp": 1634162885016
            //     }
            //
            timestamp = this.safeInteger(ticker, "timestamp");
            bid = this.safeString(ticker, "bid1");
            ask = this.safeString(ticker, "ask1");
            baseVolume = this.safeString(ticker, "volume24");
            quoteVolume = this.safeString(ticker, "amount24");
            high = this.safeString(ticker, "high24Price");
            low = this.safeString(ticker, "lower24Price");
            changeValue = this.safeString(ticker, "riseFallValue");
            changePcnt = this.safeString(ticker, "riseFallRate");
            changePcnt = Precise.stringMul(changePcnt, "100");
        } else
        {
            //
            //     {
            //         "symbol": "BTCUSDT",
            //         "priceChange": "184.34",
            //         "priceChangePercent": "0.00400048",
            //         "prevClosePrice": "46079.37",
            //         "lastPrice": "46263.71",
            //         "lastQty": "",
            //         "bidPrice": "46260.38",
            //         "bidQty": "",
            //         "askPrice": "46260.41",
            //         "askQty": "",
            //         "openPrice": "46079.37",
            //         "highPrice": "47550.01",
            //         "lowPrice": "45555.5",
            //         "volume": "1732.461487",
            //         "quoteVolume": null,
            //         "openTime": 1641349500000,
            //         "closeTime": 1641349582808,
            //         "count": null
            //     }
            //
            timestamp = this.safeInteger(ticker, "closeTime");
            bid = this.safeString(ticker, "bidPrice");
            ask = this.safeString(ticker, "askPrice");
            bidVolume = this.safeString(ticker, "bidQty");
            askVolume = this.safeString(ticker, "askQty");
            if (isTrue(Precise.stringEq(bidVolume, "0")))
            {
                bidVolume = null;
            }
            if (isTrue(Precise.stringEq(askVolume, "0")))
            {
                askVolume = null;
            }
            baseVolume = this.safeString(ticker, "volume");
            quoteVolume = this.safeString(ticker, "quoteVolume");
            open = this.safeString(ticker, "openPrice");
            high = this.safeString(ticker, "highPrice");
            low = this.safeString(ticker, "lowPrice");
            prevClose = this.safeString(ticker, "prevClosePrice");
            changeValue = this.safeString(ticker, "priceChange");
            changePcnt = this.safeString(ticker, "priceChangePercent");
            changePcnt = Precise.stringMul(changePcnt, "100");
        }
        return this.safeTicker(new Dictionary<string, object>() {
            { "symbol", getValue(market, "symbol") },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "open", open },
            { "high", high },
            { "low", low },
            { "close", this.safeString(ticker, "lastPrice") },
            { "bid", bid },
            { "bidVolume", bidVolume },
            { "ask", ask },
            { "askVolume", askVolume },
            { "vwap", null },
            { "previousClose", prevClose },
            { "change", changeValue },
            { "percentage", changePcnt },
            { "average", null },
            { "baseVolume", baseVolume },
            { "quoteVolume", quoteVolume },
            { "info", ticker },
        }, market);
    }

    /**
     * @method
     * @name mexc#fetchBidsAsks
     * @description fetches the bid and ask price and volume for multiple markets
     * @see https://mexcdevelop.github.io/apidocs/spot_v3_en/#symbol-order-book-ticker
     * @param {string[]|undefined} symbols unified symbols of the markets to fetch the bids and asks for, all markets are returned if not assigned
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/#/?id=ticker-structure}
     */
    public async override Task<object> fetchBidsAsks(object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = null;
        object isSingularMarket = false;
        if (isTrue(!isEqual(symbols, null)))
        {
            object length = getArrayLength(symbols);
            isSingularMarket = isEqual(length, 1);
            market = this.market(getValue(symbols, 0));
        }
        var marketTypequeryVariable = this.handleMarketTypeAndParams("fetchBidsAsks", market, parameters);
        var marketType = ((IList<object>) marketTypequeryVariable)[0];
        var query = ((IList<object>) marketTypequeryVariable)[1];
        object tickers = null;
        if (isTrue(isEqual(marketType, "spot")))
        {
            tickers = await this.spotPublicGetTickerBookTicker(query);
        } else if (isTrue(isEqual(marketType, "swap")))
        {
            throw new NotSupported ((string)add(add(add(this.id, " fetchBidsAsks() is not available for "), marketType), " markets")) ;
        }
        // when it's single symbol request, the returned structure is different (singular object) for both spot & swap, thus we need to wrap inside array
        if (isTrue(isSingularMarket))
        {
            tickers = new List<object>() {tickers};
        }
        return this.parseTickers(tickers, symbols);
    }

    /**
     * @method
     * @name mexc#createMarketBuyOrderWithCost
     * @description create a market buy order by providing the symbol and cost
     * @see https://mexcdevelop.github.io/apidocs/spot_v3_en/#new-order
     * @param {string} symbol unified symbol of the market to create an order in
     * @param {float} cost how much you want to trade in units of the quote currency
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> createMarketBuyOrderWithCost(object symbol, object cost, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        if (!isTrue(getValue(market, "spot")))
        {
            throw new NotSupported ((string)add(this.id, " createMarketBuyOrderWithCost() supports spot orders only")) ;
        }
        object req = new Dictionary<string, object>() {
            { "cost", cost },
        };
        return await this.createOrder(symbol, "market", "buy", 0, null, this.extend(req, parameters));
    }

    /**
     * @method
     * @name mexc#createMarketSellOrderWithCost
     * @description create a market sell order by providing the symbol and cost
     * @see https://mexcdevelop.github.io/apidocs/spot_v3_en/#new-order
     * @param {string} symbol unified symbol of the market to create an order in
     * @param {float} cost how much you want to trade in units of the quote currency
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> createMarketSellOrderWithCost(object symbol, object cost, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        if (!isTrue(getValue(market, "spot")))
        {
            throw new NotSupported ((string)add(this.id, " createMarketBuyOrderWithCost() supports spot orders only")) ;
        }
        object req = new Dictionary<string, object>() {
            { "cost", cost },
        };
        return await this.createOrder(symbol, "market", "sell", 0, null, this.extend(req, parameters));
    }

    /**
     * @method
     * @name mexc#createOrder
     * @description create a trade order
     * @see https://mexcdevelop.github.io/apidocs/spot_v3_en/#new-order
     * @see https://mexcdevelop.github.io/apidocs/contract_v1_en/#order-under-maintenance
     * @see https://mexcdevelop.github.io/apidocs/contract_v1_en/#trigger-order-under-maintenance
     * @param {string} symbol unified symbol of the market to create an order in
     * @param {string} type 'market' or 'limit'
     * @param {string} side 'buy' or 'sell'
     * @param {float} amount how much of currency you want to trade in units of base currency
     * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.marginMode] only 'isolated' is supported for spot-margin trading
     * @param {float} [params.triggerPrice] The price at which a trigger order is triggered at
     * @param {bool} [params.postOnly] if true, the order will only be posted if it will be a maker order
     * @param {bool} [params.reduceOnly] *contract only* indicates if this order is to reduce the size of a position
     * @param {bool} [params.hedged] *swap only* true for hedged mode, false for one way mode, default is false
     * @param {string} [params.timeInForce] 'IOC' or 'FOK', default is 'GTC'
     * EXCHANGE SPECIFIC PARAMETERS
     * @param {int} [params.leverage] *contract only* leverage is necessary on isolated margin
     * @param {long} [params.positionId] *contract only* it is recommended to fill in this parameter when closing a position
     * @param {string} [params.externalOid] *contract only* external order ID
     * @param {int} [params.positionMode] *contract only*  1:hedge, 2:one-way, default: the user's current config
     * @param {boolean} [params.test] *spot only* whether to use the test endpoint or not, default is false
     * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> createOrder(object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        var marginModequeryVariable = this.handleMarginModeAndParams("createOrder", parameters);
        var marginMode = ((IList<object>) marginModequeryVariable)[0];
        var query = ((IList<object>) marginModequeryVariable)[1];
        if (isTrue(getValue(market, "spot")))
        {
            return await this.createSpotOrder(market, type, side, amount, price, marginMode, query);
        } else
        {
            return await this.createSwapOrder(market, type, side, amount, price, marginMode, query);
        }
    }

    public virtual object createSpotOrderRequest(object market, object type, object side, object amount, object price = null, object marginMode = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object symbol = getValue(market, "symbol");
        object orderSide = ((string)side).ToUpper();
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
            { "side", orderSide },
            { "type", ((string)type).ToUpper() },
        };
        if (isTrue(isEqual(type, "market")))
        {
            object cost = this.safeNumber2(parameters, "cost", "quoteOrderQty");
            parameters = this.omit(parameters, "cost");
            if (isTrue(!isEqual(cost, null)))
            {
                amount = cost;
                ((IDictionary<string,object>)request)["quoteOrderQty"] = this.costToPrecision(symbol, amount);
            } else
            {
                if (isTrue(isEqual(price, null)))
                {
                    ((IDictionary<string,object>)request)["quantity"] = this.amountToPrecision(symbol, amount);
                } else
                {
                    object amountString = this.numberToString(amount);
                    object priceString = this.numberToString(price);
                    object quoteAmount = Precise.stringMul(amountString, priceString);
                    amount = quoteAmount;
                    ((IDictionary<string,object>)request)["quoteOrderQty"] = this.costToPrecision(symbol, amount);
                }
            }
        } else
        {
            ((IDictionary<string,object>)request)["quantity"] = this.amountToPrecision(symbol, amount);
        }
        if (isTrue(!isEqual(price, null)))
        {
            ((IDictionary<string,object>)request)["price"] = this.priceToPrecision(symbol, price);
        }
        object clientOrderId = this.safeString(parameters, "clientOrderId");
        if (isTrue(!isEqual(clientOrderId, null)))
        {
            ((IDictionary<string,object>)request)["newClientOrderId"] = clientOrderId;
            parameters = this.omit(parameters, new List<object>() {"type", "clientOrderId"});
        }
        if (isTrue(!isEqual(marginMode, null)))
        {
            if (isTrue(!isEqual(marginMode, "isolated")))
            {
                throw new BadRequest ((string)add(add(add(this.id, " createOrder() does not support marginMode "), marginMode), " for spot-margin trading")) ;
            }
        }
        object postOnly = null;
        var postOnlyparametersVariable = this.handlePostOnly(isEqual(type, "market"), isEqual(type, "LIMIT_MAKER"), parameters);
        postOnly = ((IList<object>)postOnlyparametersVariable)[0];
        parameters = ((IList<object>)postOnlyparametersVariable)[1];
        if (isTrue(postOnly))
        {
            ((IDictionary<string,object>)request)["type"] = "LIMIT_MAKER";
        }
        object tif = this.safeString(parameters, "timeInForce");
        if (isTrue(!isEqual(tif, null)))
        {
            parameters = this.omit(parameters, "timeInForce");
            if (isTrue(isEqual(tif, "IOC")))
            {
                ((IDictionary<string,object>)request)["type"] = "IMMEDIATE_OR_CANCEL";
            } else if (isTrue(isEqual(tif, "FOK")))
            {
                ((IDictionary<string,object>)request)["type"] = "FILL_OR_KILL";
            }
        }
        return this.extend(request, parameters);
    }

    /**
     * @ignore
     * @method
     * @name mexc#createSpotOrder
     * @description create a trade order
     * @see https://mexcdevelop.github.io/apidocs/spot_v3_en/#new-order
     * @param {string} market unified symbol of the market to create an order in
     * @param {string} type 'market' or 'limit'
     * @param {string} side 'buy' or 'sell'
     * @param {float} amount how much of currency you want to trade in units of base currency
     * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
     * @param {string} [marginMode] only 'isolated' is supported for spot-margin trading
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {bool} [params.postOnly] if true, the order will only be posted if it will be a maker order
     * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async virtual Task<object> createSpotOrder(object market, object type, object side, object amount, object price = null, object marginMode = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object test = this.safeBool(parameters, "test", false);
        parameters = this.omit(parameters, "test");
        object request = this.createSpotOrderRequest(market, type, side, amount, price, marginMode, parameters);
        object response = null;
        if (isTrue(test))
        {
            response = await this.spotPrivatePostOrderTest(request);
        } else
        {
            response = await this.spotPrivatePostOrder(request);
        }
        //
        // spot
        //
        //     {
        //         "symbol": "BTCUSDT",
        //         "orderId": "123738410679123456",
        //         "orderListId": -1
        //     }
        //
        // margin
        //
        //     {
        //         "symbol": "BTCUSDT",
        //         "orderId": "762634301354414080",
        //         "clientOrderId": null,
        //         "isIsolated": true,
        //         "transactTime": 1661992652132
        //     }
        //
        object order = this.parseOrder(response, market);
        ((IDictionary<string,object>)order)["side"] = side;
        ((IDictionary<string,object>)order)["type"] = type;
        if (isTrue(isEqual(this.safeString(order, "price"), null)))
        {
            ((IDictionary<string,object>)order)["price"] = price;
        }
        if (isTrue(isEqual(this.safeString(order, "amount"), null)))
        {
            ((IDictionary<string,object>)order)["amount"] = amount;
        }
        return order;
    }

    /**
     * @ignore
     * @method
     * @name mexc#createSwapOrder
     * @description create a trade order
     * @see https://mexcdevelop.github.io/apidocs/spot_v3_en/#new-order
     * @see https://mexcdevelop.github.io/apidocs/contract_v1_en/#order-under-maintenance
     * @see https://mexcdevelop.github.io/apidocs/contract_v1_en/#trigger-order-under-maintenance
     * @param {string} market unified symbol of the market to create an order in
     * @param {string} type 'market' or 'limit'
     * @param {string} side 'buy' or 'sell'
     * @param {float} amount how much of currency you want to trade in units of base currency
     * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
     * @param {string} [marginMode] only 'isolated' is supported for spot-margin trading
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {float} [params.triggerPrice] The price at which a trigger order is triggered at
     * @param {bool} [params.postOnly] if true, the order will only be posted if it will be a maker order
     * @param {bool} [params.reduceOnly] indicates if this order is to reduce the size of a position
     * @param {bool} [params.hedged] *swap only* true for hedged mode, false for one way mode, default is false
     *
     * EXCHANGE SPECIFIC PARAMETERS
     * @param {int} [params.leverage] leverage is necessary on isolated margin
     * @param {long} [params.positionId] it is recommended to fill in this parameter when closing a position
     * @param {string} [params.externalOid] external order ID
     * @param {int} [params.positionMode] 1:hedge, 2:one-way, default: the user's current config
     * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async virtual Task<object> createSwapOrder(object market, object type, object side, object amount, object price = null, object marginMode = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object symbol = getValue(market, "symbol");
        object unavailableContracts = this.safeValue(this.options, "unavailableContracts", new Dictionary<string, object>() {});
        object isContractUnavaiable = this.safeBool(unavailableContracts, symbol, false);
        if (isTrue(isContractUnavaiable))
        {
            throw new NotSupported ((string)add(add(this.id, " createSwapOrder() does not support yet this symbol:"), symbol)) ;
        }
        object openType = null;
        if (isTrue(!isEqual(marginMode, null)))
        {
            if (isTrue(isEqual(marginMode, "cross")))
            {
                openType = 2;
            } else if (isTrue(isEqual(marginMode, "isolated")))
            {
                openType = 1;
            } else
            {
                throw new ArgumentsRequired ((string)add(this.id, " createSwapOrder() marginMode parameter should be either \"cross\" or \"isolated\"")) ;
            }
        } else
        {
            openType = this.safeInteger(parameters, "openType", 2); // defaulting to cross margin
        }
        if (isTrue(isTrue(isTrue(isTrue(isTrue(isTrue(isTrue(isTrue((!isEqual(type, "limit"))) && isTrue((!isEqual(type, "market")))) && isTrue((!isEqual(type, 1)))) && isTrue((!isEqual(type, 2)))) && isTrue((!isEqual(type, 3)))) && isTrue((!isEqual(type, 4)))) && isTrue((!isEqual(type, 5)))) && isTrue((!isEqual(type, 6)))))
        {
            throw new InvalidOrder ((string)add(this.id, " createSwapOrder() order type must either limit, market, or 1 for limit orders, 2 for post-only orders, 3 for IOC orders, 4 for FOK orders, 5 for market orders or 6 to convert market price to current price")) ;
        }
        object postOnly = null;
        var postOnlyparametersVariable = this.handlePostOnly(isEqual(type, "market"), isEqual(type, 2), parameters);
        postOnly = ((IList<object>)postOnlyparametersVariable)[0];
        parameters = ((IList<object>)postOnlyparametersVariable)[1];
        if (isTrue(postOnly))
        {
            type = 2;
        } else if (isTrue(isEqual(type, "limit")))
        {
            type = 1;
        } else if (isTrue(isEqual(type, "market")))
        {
            type = 6;
        }
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
            { "vol", parseFloat(this.amountToPrecision(symbol, amount)) },
            { "type", type },
            { "openType", openType },
        };
        if (isTrue(isTrue(isTrue((!isEqual(type, 5))) && isTrue((!isEqual(type, 6)))) && isTrue((!isEqual(type, "market")))))
        {
            ((IDictionary<string,object>)request)["price"] = parseFloat(this.priceToPrecision(symbol, price));
        }
        if (isTrue(isEqual(openType, 1)))
        {
            object leverage = this.safeInteger(parameters, "leverage");
            if (isTrue(isEqual(leverage, null)))
            {
                throw new ArgumentsRequired ((string)add(this.id, " createSwapOrder() requires a leverage parameter for isolated margin orders")) ;
            }
        }
        object reduceOnly = this.safeBool(parameters, "reduceOnly", false);
        object hedged = this.safeBool(parameters, "hedged", false);
        object sideInteger = null;
        if (isTrue(hedged))
        {
            if (isTrue(reduceOnly))
            {
                parameters = this.omit(parameters, "reduceOnly"); // hedged mode does not accept this parameter
                side = ((bool) isTrue((isEqual(side, "buy")))) ? "sell" : "buy";
            }
            sideInteger = ((bool) isTrue((isEqual(side, "buy")))) ? 1 : 3;
            ((IDictionary<string,object>)request)["positionMode"] = 1;
        } else
        {
            if (isTrue(reduceOnly))
            {
                sideInteger = ((bool) isTrue((isEqual(side, "buy")))) ? 2 : 4;
            } else
            {
                sideInteger = ((bool) isTrue((isEqual(side, "buy")))) ? 1 : 3;
            }
        }
        ((IDictionary<string,object>)request)["side"] = sideInteger;
        object clientOrderId = this.safeString2(parameters, "clientOrderId", "externalOid");
        if (isTrue(!isEqual(clientOrderId, null)))
        {
            ((IDictionary<string,object>)request)["externalOid"] = clientOrderId;
        }
        object triggerPrice = this.safeNumber2(parameters, "triggerPrice", "stopPrice");
        parameters = this.omit(parameters, new List<object>() {"clientOrderId", "externalOid", "postOnly", "stopPrice", "triggerPrice", "hedged"});
        object response = null;
        if (isTrue(triggerPrice))
        {
            ((IDictionary<string,object>)request)["triggerPrice"] = this.priceToPrecision(symbol, triggerPrice);
            ((IDictionary<string,object>)request)["triggerType"] = this.safeInteger(parameters, "triggerType", 1);
            ((IDictionary<string,object>)request)["executeCycle"] = this.safeInteger(parameters, "executeCycle", 1);
            ((IDictionary<string,object>)request)["trend"] = this.safeInteger(parameters, "trend", 1);
            ((IDictionary<string,object>)request)["orderType"] = this.safeInteger(parameters, "orderType", 1);
            response = await this.contractPrivatePostPlanorderPlace(this.extend(request, parameters));
        } else
        {
            response = await this.contractPrivatePostOrderSubmit(this.extend(request, parameters));
        }
        //
        // Swap
        //     {"code":200,"data":"2ff3163e8617443cb9c6fc19d42b1ca4"}
        //
        // Trigger
        //     {"success":true,"code":0,"data":259208506303929856}
        //
        object data = this.safeString(response, "data");
        return this.safeOrder(new Dictionary<string, object>() {
            { "id", data },
        }, market);
    }

    /**
     * @method
     * @name mexc#createOrders
     * @description *spot only*  *all orders must have the same symbol* create a list of trade orders
     * @see https://mexcdevelop.github.io/apidocs/spot_v3_en/#batch-orders
     * @param {Array} orders list of orders to create, each object should contain the parameters required by createOrder, namely symbol, type, side, amount, price and params
     * @param {object} [params] extra parameters specific to api endpoint
     * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> createOrders(object orders, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object ordersRequests = new List<object>() {};
        object symbol = null;
        for (object i = 0; isLessThan(i, getArrayLength(orders)); postFixIncrement(ref i))
        {
            object rawOrder = getValue(orders, i);
            object marketId = this.safeString(rawOrder, "symbol");
            object market = this.market(marketId);
            if (!isTrue(getValue(market, "spot")))
            {
                throw new NotSupported ((string)add(this.id, " createOrders() is only supported for spot markets")) ;
            }
            if (isTrue(isEqual(symbol, null)))
            {
                symbol = marketId;
            } else
            {
                if (isTrue(!isEqual(symbol, marketId)))
                {
                    throw new BadRequest ((string)add(this.id, " createOrders() requires all orders to have the same symbol")) ;
                }
            }
            object type = this.safeString(rawOrder, "type");
            object side = this.safeString(rawOrder, "side");
            object amount = this.safeValue(rawOrder, "amount");
            object price = this.safeValue(rawOrder, "price");
            object orderParams = this.safeValue(rawOrder, "params", new Dictionary<string, object>() {});
            object marginMode = null;
            var marginModeparametersVariable = this.handleMarginModeAndParams("createOrder", parameters);
            marginMode = ((IList<object>)marginModeparametersVariable)[0];
            parameters = ((IList<object>)marginModeparametersVariable)[1];
            object orderRequest = this.createSpotOrderRequest(market, type, side, amount, price, marginMode, orderParams);
            ((IList<object>)ordersRequests).Add(orderRequest);
        }
        object request = new Dictionary<string, object>() {
            { "batchOrders", this.json(ordersRequests) },
        };
        object response = await this.spotPrivatePostBatchOrders(request);
        //
        // [
        //     {
        //       "symbol": "BTCUSDT",
        //       "orderId": "1196315350023612316",
        //       "newClientOrderId": "hio8279hbdsds",
        //       "orderListId": -1
        //     },
        //     {
        //       "newClientOrderId": "123456",
        //       "msg": "The minimum transaction volume cannot be less than:0.5USDT",
        //       "code": 30002
        //     },
        //     {
        //       "symbol": "BTCUSDT",
        //       "orderId": "1196315350023612318",
        //       "orderListId": -1
        //     }
        // ]
        //
        return this.parseOrders(response);
    }

    /**
     * @method
     * @name mexc#fetchOrder
     * @description fetches information on an order made by the user
     * @see https://mexcdevelop.github.io/apidocs/spot_v3_en/#query-order
     * @see https://mexcdevelop.github.io/apidocs/contract_v1_en/#query-the-order-based-on-the-order-number
     * @param {string} id order id
     * @param {string} symbol unified symbol of the market the order was made in
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.marginMode] only 'isolated' is supported, for spot-margin trading
     * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> fetchOrder(object id, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchOrder() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object data = null;
        if (isTrue(getValue(market, "spot")))
        {
            object clientOrderId = this.safeString(parameters, "clientOrderId");
            if (isTrue(!isEqual(clientOrderId, null)))
            {
                parameters = this.omit(parameters, "clientOrderId");
                ((IDictionary<string,object>)request)["origClientOrderId"] = clientOrderId;
            } else
            {
                ((IDictionary<string,object>)request)["orderId"] = id;
            }
            var marginModequeryVariable = this.handleMarginModeAndParams("fetchOrder", parameters);
            var marginMode = ((IList<object>) marginModequeryVariable)[0];
            var query = ((IList<object>) marginModequeryVariable)[1];
            if (isTrue(!isEqual(marginMode, null)))
            {
                if (isTrue(!isEqual(marginMode, "isolated")))
                {
                    throw new BadRequest ((string)add(add(add(this.id, " fetchOrder() does not support marginMode "), marginMode), " for spot-margin trading")) ;
                }
                data = await this.spotPrivateGetMarginOrder(this.extend(request, query));
            } else
            {
                data = await this.spotPrivateGetOrder(this.extend(request, query));
            }
        } else if (isTrue(getValue(market, "swap")))
        {
            ((IDictionary<string,object>)request)["order_id"] = id;
            object response = await this.contractPrivateGetOrderGetOrderId(this.extend(request, parameters));
            //
            //     {
            //         "success": true,
            //         "code": "0",
            //         "data": {
            //             "orderId": "264995729269765120",
            //             "symbol": "STEPN_USDT",
            //             "positionId": "0",
            //             "price": "2.2",
            //             "vol": "15",
            //             "leverage": "20",
            //             "side": "1",
            //             "category": "1",
            //             "orderType": "1",
            //             "dealAvgPrice": "0",
            //             "dealVol": "0",
            //             "orderMargin": "2.2528",
            //             "takerFee": "0",
            //             "makerFee": "0",
            //             "profit": "0",
            //             "feeCurrency": "USDT",
            //             "openType": "1",
            //             "state": "2",
            //             "externalOid": "_m_0e9520c256744d64b942985189026d20",
            //             "errorCode": "0",
            //             "usedMargin": "0",
            //             "createTime": "1648850305236",
            //             "updateTime": "1648850305245",
            //             "positionMode": "1"
            //         }
            //     }
            //
            data = this.safeValue(response, "data");
        }
        return this.parseOrder(data, market);
    }

    /**
     * @method
     * @name mexc#fetchOrders
     * @description fetches information on multiple orders made by the user
     * @see https://mexcdevelop.github.io/apidocs/spot_v3_en/#all-orders
     * @see https://mexcdevelop.github.io/apidocs/contract_v1_en/#get-all-of-the-user-39-s-historical-orders
     * @see https://mexcdevelop.github.io/apidocs/contract_v1_en/#gets-the-trigger-order-list
     * @param {string} symbol unified market symbol of the market orders were made in
     * @param {int} [since] the earliest time in ms to fetch orders for
     * @param {int} [limit] the maximum number of order structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {int} [params.until] the latest time in ms to fetch orders for
     * @param {string} [params.marginMode] only 'isolated' is supported, for spot-margin trading
     * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> fetchOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
        }
        object until = this.safeInteger(parameters, "until");
        parameters = this.omit(parameters, "until");
        var marketTypequeryVariable = this.handleMarketTypeAndParams("fetchOrders", market, parameters);
        var marketType = ((IList<object>) marketTypequeryVariable)[0];
        var query = ((IList<object>) marketTypequeryVariable)[1];
        if (isTrue(isEqual(marketType, "spot")))
        {
            if (isTrue(isEqual(symbol, null)))
            {
                throw new ArgumentsRequired ((string)add(this.id, " fetchOrders() requires a symbol argument for spot market")) ;
            }
            var marginModequeryInnerVariable = this.handleMarginModeAndParams("fetchOrders", parameters);
            var marginMode = ((IList<object>) marginModequeryInnerVariable)[0];
            var queryInner = ((IList<object>) marginModequeryInnerVariable)[1];
            if (isTrue(!isEqual(since, null)))
            {
                ((IDictionary<string,object>)request)["startTime"] = since;
            }
            if (isTrue(!isEqual(until, null)))
            {
                ((IDictionary<string,object>)request)["endTime"] = until;
            }
            if (isTrue(!isEqual(limit, null)))
            {
                ((IDictionary<string,object>)request)["limit"] = limit;
            }
            object response = null;
            if (isTrue(!isEqual(marginMode, null)))
            {
                if (isTrue(!isEqual(marginMode, "isolated")))
                {
                    throw new BadRequest ((string)add(add(add(this.id, " fetchOrders() does not support marginMode "), marginMode), " for spot-margin trading")) ;
                }
                response = await this.spotPrivateGetMarginAllOrders(this.extend(request, queryInner));
            } else
            {
                response = await this.spotPrivateGetAllOrders(this.extend(request, queryInner));
            }
            //
            // spot
            //
            //     [
            //         {
            //             "symbol": "BTCUSDT",
            //             "orderId": "133949373632483328",
            //             "orderListId": "-1",
            //             "clientOrderId": null,
            //             "price": "45000",
            //             "origQty": "0.0002",
            //             "executedQty": "0",
            //             "cummulativeQuoteQty": "0",
            //             "status": "NEW",
            //             "timeInForce": null,
            //             "type": "LIMIT",
            //             "side": "SELL",
            //             "stopPrice": null,
            //             "icebergQty": null,
            //             "time": "1647718255000",
            //             "updateTime": "1647718255000",
            //             "isWorking": true,
            //             "origQuoteOrderQty": "9"
            //         },
            //     ]
            //
            // margin
            //
            //     [
            //         {
            //             "symbol": "BTCUSDT",
            //             "orderId": "763307297891028992",
            //             "orderListId": "-1",
            //             "clientOrderId": null,
            //             "price": "18000",
            //             "origQty": "0.0014",
            //             "executedQty": "0",
            //             "cummulativeQuoteQty": "0",
            //             "status": "NEW",
            //             "type": "LIMIT",
            //             "side": "BUY",
            //             "isIsolated": true,
            //             "isWorking": true,
            //             "time": 1662153107000,
            //             "updateTime": 1662153107000
            //         }
            //     ]
            //
            return this.parseOrders(response, market, since, limit);
        } else
        {
            if (isTrue(!isEqual(since, null)))
            {
                ((IDictionary<string,object>)request)["start_time"] = since;
                object end = this.safeInteger(parameters, "end_time", until);
                if (isTrue(isEqual(end, null)))
                {
                    ((IDictionary<string,object>)request)["end_time"] = this.sum(since, getValue(this.options, "maxTimeTillEnd"));
                } else
                {
                    if (isTrue(isGreaterThan((subtract(end, since)), getValue(this.options, "maxTimeTillEnd"))))
                    {
                        throw new BadRequest ((string)add(this.id, " end is invalid, i.e. exceeds allowed 90 days.")) ;
                    } else
                    {
                        ((IDictionary<string,object>)request)["end_time"] = until;
                    }
                }
            } else if (isTrue(!isEqual(until, null)))
            {
                ((IDictionary<string,object>)request)["start_time"] = this.sum(until, multiply(getValue(this.options, "maxTimeTillEnd"), -1));
                ((IDictionary<string,object>)request)["end_time"] = until;
            }
            if (isTrue(!isEqual(limit, null)))
            {
                ((IDictionary<string,object>)request)["page_size"] = limit;
            }
            object method = this.safeString(this.options, "fetchOrders", "contractPrivateGetOrderListHistoryOrders");
            method = this.safeString(query, "method", method);
            object ordersOfRegular = new List<object>() {};
            object ordersOfTrigger = new List<object>() {};
            if (isTrue(isEqual(method, "contractPrivateGetOrderListHistoryOrders")))
            {
                object response = await this.contractPrivateGetOrderListHistoryOrders(this.extend(request, query));
                //
                //     {
                //         "success": true,
                //         "code": "0",
                //         "data": [
                //             {
                //                 "orderId": "265230764677709315",
                //                 "symbol": "STEPN_USDT",
                //                 "positionId": "0",
                //                 "price": "2.1",
                //                 "vol": "102",
                //                 "leverage": "20",
                //                 "side": "1",
                //                 "category": "1",
                //                 "orderType": "1",
                //                 "dealAvgPrice": "0",
                //                 "dealVol": "0",
                //                 "orderMargin": "10.96704",
                //                 "takerFee": "0",
                //                 "makerFee": "0",
                //                 "profit": "0",
                //                 "feeCurrency": "USDT",
                //                 "openType": "1",
                //                 "state": "2",
                //                 "externalOid": "_m_7e42f8df6b324c869e4e200397e2b00f",
                //                 "errorCode": "0",
                //                 "usedMargin": "0",
                //                 "createTime": "1648906342000",
                //                 "updateTime": "1648906342000",
                //                 "positionMode": "1"
                //             },
                //          ]
                //     }
                //
                ordersOfRegular = this.safeValue(response, "data");
            } else
            {
                // the Planorder endpoints work not only for stop-market orders, but also for stop-limit orders that were supposed to have a separate endpoint
                object response = await this.contractPrivateGetPlanorderListOrders(this.extend(request, query));
                //
                //     {
                //         "success": true,
                //         "code": "0",
                //         "data": [
                //             {
                //                 "symbol": "STEPN_USDT",
                //                 "leverage": "20",
                //                 "side": "1",
                //                 "vol": "13",
                //                 "openType": "1",
                //                 "state": "1",
                //                 "orderType": "1",
                //                 "errorCode": "0",
                //                 "createTime": "1648984276000",
                //                 "updateTime": "1648984276000",
                //                 "id": "265557643326564352",
                //                 "triggerType": "1",
                //                 "triggerPrice": "3",
                //                 "price": "2.9", // not present in stop-market, but in stop-limit order
                //                 "executeCycle": "87600",
                //                 "trend": "1",
                //             },
                //         ]
                //     }
                //
                ordersOfTrigger = this.safeValue(response, "data");
            }
            object merged = this.arrayConcat(ordersOfTrigger, ordersOfRegular);
            return this.parseOrders(merged, market, since, limit, parameters);
        }
    }

    public async virtual Task<object> fetchOrdersByIds(object ids, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
        }
        var marketTypequeryVariable = this.handleMarketTypeAndParams("fetchOrdersByIds", market, parameters);
        var marketType = ((IList<object>) marketTypequeryVariable)[0];
        var query = ((IList<object>) marketTypequeryVariable)[1];
        if (isTrue(isEqual(marketType, "spot")))
        {
            throw new BadRequest ((string)add(add(this.id, " fetchOrdersByIds() is not supported for "), marketType)) ;
        } else
        {
            ((IDictionary<string,object>)request)["order_ids"] = String.Join(",", ((IList<object>)ids).ToArray());
            object response = await this.contractPrivateGetOrderBatchQuery(this.extend(request, query));
            //
            //     {
            //         "success": true,
            //         "code": "0",
            //         "data": [
            //             {
            //                 "orderId": "265230764677709315",
            //                 "symbol": "STEPN_USDT",
            //                 "positionId": "0",
            //                 "price": "2.1",
            //                 "vol": "102",
            //                 "leverage": "20",
            //                 "side": "1",
            //                 "category": "1",
            //                 "orderType": "1",
            //                 "dealAvgPrice": "0",
            //                 "dealVol": "0",
            //                 "orderMargin": "10.96704",
            //                 "takerFee": "0",
            //                 "makerFee": "0",
            //                 "profit": "0",
            //                 "feeCurrency": "USDT",
            //                 "openType": "1",
            //                 "state": "2",
            //                 "externalOid": "_m_7e42f8df6b324c869e4e200397e2b00f",
            //                 "errorCode": "0",
            //                 "usedMargin": "0",
            //                 "createTime": "1648906342000",
            //                 "updateTime": "1648906342000",
            //                 "positionMode": "1"
            //             }
            //         ]
            //     }
            //
            object data = this.safeList(response, "data");
            return this.parseOrders(data, market);
        }
    }

    /**
     * @method
     * @name mexc#fetchOpenOrders
     * @description fetch all unfilled currently open orders
     * @see https://mexcdevelop.github.io/apidocs/spot_v3_en/#current-open-orders
     * @see https://mexcdevelop.github.io/apidocs/contract_v1_en/#get-all-of-the-user-39-s-historical-orders
     * @see https://mexcdevelop.github.io/apidocs/contract_v1_en/#gets-the-trigger-order-list
     * @param {string} symbol unified market symbol
     * @param {int} [since] the earliest time in ms to fetch open orders for
     * @param {int} [limit] the maximum number of  open orders structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.marginMode] only 'isolated' is supported, for spot-margin trading
     * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> fetchOpenOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object market = null;
        object marketType = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
        }
        var marketTypeparametersVariable = this.handleMarketTypeAndParams("fetchOpenOrders", market, parameters);
        marketType = ((IList<object>)marketTypeparametersVariable)[0];
        parameters = ((IList<object>)marketTypeparametersVariable)[1];
        if (isTrue(isEqual(marketType, "spot")))
        {
            if (isTrue(isEqual(symbol, null)))
            {
                throw new ArgumentsRequired ((string)add(this.id, " fetchOpenOrders() requires a symbol argument for spot market")) ;
            }
            ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
            var marginModequeryVariable = this.handleMarginModeAndParams("fetchOpenOrders", parameters);
            var marginMode = ((IList<object>) marginModequeryVariable)[0];
            var query = ((IList<object>) marginModequeryVariable)[1];
            object response = null;
            if (isTrue(!isEqual(marginMode, null)))
            {
                if (isTrue(!isEqual(marginMode, "isolated")))
                {
                    throw new BadRequest ((string)add(add(add(this.id, " fetchOpenOrders() does not support marginMode "), marginMode), " for spot-margin trading")) ;
                }
                response = await this.spotPrivateGetMarginOpenOrders(this.extend(request, query));
            } else
            {
                response = await this.spotPrivateGetOpenOrders(this.extend(request, query));
            }
            //
            // spot
            //
            //     [
            //         {
            //             "symbol": "BTCUSDT",
            //             "orderId": "133949373632483328",
            //             "orderListId": "-1",
            //             "clientOrderId": "",
            //             "price": "45000",
            //             "origQty": "0.0002",
            //             "executedQty": "0",
            //             "cummulativeQuoteQty": "0",
            //             "status": "NEW",
            //             "timeInForce": null,
            //             "type": "LIMIT",
            //             "side": "SELL",
            //             "stopPrice": null,
            //             "icebergQty": null,
            //             "time": "1647718255199",
            //             "updateTime": null,
            //             "isWorking": true,
            //             "origQuoteOrderQty": "9"
            //         }
            //     ]
            //
            // margin
            //
            //     [
            //         {
            //             "symbol": "BTCUSDT",
            //             "orderId": "764547676405633024",
            //             "orderListId": "-1",
            //             "clientOrderId": null,
            //             "price": "18000",
            //             "origQty": "0.0013",
            //             "executedQty": "0",
            //             "cummulativeQuoteQty": "0",
            //             "status": "NEW",
            //             "type": "LIMIT",
            //             "side": "BUY",
            //             "isIsolated": true,
            //             "isWorking": true,
            //             "time": 1662448836000,
            //             "updateTime": 1662448836000
            //         }
            //     ]
            //
            return this.parseOrders(response, market, since, limit);
        } else
        {
            // TO_DO: another possible way is through: open_orders/{symbol}, but as they have same ratelimits, and less granularity, i think historical orders are more convenient, as it supports more params (however, theoretically, open-orders endpoint might be sligthly fast)
            return await this.fetchOrdersByState(2, symbol, since, limit, parameters);
        }
    }

    /**
     * @method
     * @name mexc#fetchClosedOrders
     * @description fetches information on multiple closed orders made by the user
     * @see https://mexcdevelop.github.io/apidocs/spot_v3_en/#all-orders
     * @see https://mexcdevelop.github.io/apidocs/contract_v1_en/#get-all-of-the-user-39-s-historical-orders
     * @see https://mexcdevelop.github.io/apidocs/contract_v1_en/#gets-the-trigger-order-list
     * @param {string} symbol unified market symbol of the market orders were made in
     * @param {int} [since] the earliest time in ms to fetch orders for
     * @param {int} [limit] the maximum number of order structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> fetchClosedOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        return await this.fetchOrdersByState(3, symbol, since, limit, parameters);
    }

    /**
     * @method
     * @name mexc#fetchCanceledOrders
     * @description fetches information on multiple canceled orders made by the user
     * @see https://mexcdevelop.github.io/apidocs/spot_v3_en/#all-orders
     * @see https://mexcdevelop.github.io/apidocs/contract_v1_en/#get-all-of-the-user-39-s-historical-orders
     * @see https://mexcdevelop.github.io/apidocs/contract_v1_en/#gets-the-trigger-order-list
     * @param {string} symbol unified market symbol of the market orders were made in
     * @param {int} [since] timestamp in ms of the earliest order, default is undefined
     * @param {int} [limit] max number of orders to return, default is undefined
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async virtual Task<object> fetchCanceledOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        return await this.fetchOrdersByState(4, symbol, since, limit, parameters);
    }

    public async virtual Task<object> fetchOrdersByState(object state, object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
        }
        var marketTypeVariable = this.handleMarketTypeAndParams("fetchOrdersByState", market, parameters);
        var marketType = ((IList<object>) marketTypeVariable)[0];
        if (isTrue(isEqual(marketType, "spot")))
        {
            throw new NotSupported ((string)add(add(this.id, " fetchOrdersByState() is not supported for "), marketType)) ;
        } else
        {
            ((IDictionary<string,object>)request)["states"] = state;
            return await this.fetchOrders(symbol, since, limit, this.extend(request, parameters));
        }
    }

    /**
     * @method
     * @name mexc#cancelOrder
     * @description cancels an open order
     * @see https://mexcdevelop.github.io/apidocs/spot_v3_en/#cancel-order
     * @see https://mexcdevelop.github.io/apidocs/contract_v1_en/#cancel-the-order-under-maintenance
     * @see https://mexcdevelop.github.io/apidocs/contract_v1_en/#cancel-the-stop-limit-trigger-order-under-maintenance
     * @param {string} id order id
     * @param {string} symbol unified symbol of the market the order was made in
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.marginMode] only 'isolated' is supported for spot-margin trading
     * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> cancelOrder(object id, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
        }
        object marketType = null;
        var marketTypeparametersVariable = this.handleMarketTypeAndParams("cancelOrder", market, parameters);
        marketType = ((IList<object>)marketTypeparametersVariable)[0];
        parameters = ((IList<object>)marketTypeparametersVariable)[1];
        var marginModequeryVariable = this.handleMarginModeAndParams("cancelOrder", parameters);
        var marginMode = ((IList<object>) marginModequeryVariable)[0];
        var query = ((IList<object>) marginModequeryVariable)[1];
        object data = null;
        if (isTrue(isEqual(marketType, "spot")))
        {
            if (isTrue(isEqual(symbol, null)))
            {
                throw new ArgumentsRequired ((string)add(this.id, " cancelOrder() requires a symbol argument")) ;
            }
            object requestInner = new Dictionary<string, object>() {
                { "symbol", getValue(market, "id") },
            };
            object clientOrderId = this.safeString(parameters, "clientOrderId");
            if (isTrue(!isEqual(clientOrderId, null)))
            {
                parameters = this.omit(query, "clientOrderId");
                ((IDictionary<string,object>)requestInner)["origClientOrderId"] = clientOrderId;
            } else
            {
                ((IDictionary<string,object>)requestInner)["orderId"] = id;
            }
            if (isTrue(!isEqual(marginMode, null)))
            {
                if (isTrue(!isEqual(marginMode, "isolated")))
                {
                    throw new BadRequest ((string)add(add(add(this.id, " cancelOrder() does not support marginMode "), marginMode), " for spot-margin trading")) ;
                }
                data = await this.spotPrivateDeleteMarginOrder(this.extend(requestInner, query));
            } else
            {
                data = await this.spotPrivateDeleteOrder(this.extend(requestInner, query));
            }
        } else
        {
            // TODO: PlanorderCancel endpoint has bug atm. waiting for fix.
            object method = this.safeString(this.options, "cancelOrder", "contractPrivatePostOrderCancel"); // contractPrivatePostOrderCancel, contractPrivatePostPlanorderCancel
            method = this.safeString(query, "method", method);
            object response = null;
            if (isTrue(isEqual(method, "contractPrivatePostOrderCancel")))
            {
                response = await this.contractPrivatePostOrderCancel(new List<object>() {id}); // the request cannot be changed or extended. This is the only way to send.
            } else if (isTrue(isEqual(method, "contractPrivatePostPlanorderCancel")))
            {
                response = await this.contractPrivatePostPlanorderCancel(new List<object>() {id}); // the request cannot be changed or extended. This is the only way to send.
            } else
            {
                throw new NotSupported ((string)add(this.id, " cancelOrder() not support this method")) ;
            }
            //
            //     {
            //         "success": true,
            //         "code": "0",
            //         "data": [
            //             {
            //                 "orderId": "264995729269765120",
            //                 "errorCode": "0",         // if already canceled: "2041"; if doesn't exist: "2040"
            //                 "errorMsg": "success",    // if already canceled: "order state cannot be cancelled"; if doesn't exist: "order not exist"
            //             }
            //         ]
            //     }
            //
            data = this.safeValue(response, "data");
            object order = this.safeValue(data, 0);
            object errorMsg = this.safeValue(order, "errorMsg", "");
            if (isTrue(!isEqual(errorMsg, "success")))
            {
                throw new InvalidOrder ((string)add(add(add(add(this.id, " cancelOrder() the order with id "), id), " cannot be cancelled: "), errorMsg)) ;
            }
        }
        return this.parseOrder(data, market);
    }

    /**
     * @method
     * @name mexc#cancelOrders
     * @description cancel multiple orders
     * @see https://mexcdevelop.github.io/apidocs/contract_v1_en/#cancel-the-order-under-maintenance
     * @param {string[]} ids order ids
     * @param {string} symbol unified market symbol, default is undefined
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} an list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async virtual Task<object> cancelOrders(object ids, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = ((bool) isTrue((!isEqual(symbol, null)))) ? this.market(symbol) : null;
        var marketTypeVariable = this.handleMarketTypeAndParams("cancelOrders", market, parameters);
        var marketType = ((IList<object>) marketTypeVariable)[0];
        if (isTrue(isEqual(marketType, "spot")))
        {
            throw new BadRequest ((string)add(add(this.id, " cancelOrders() is not supported for "), marketType)) ;
        } else
        {
            object response = await this.contractPrivatePostOrderCancel(ids); // the request cannot be changed or extended. The only way to send.
            //
            //     {
            //         "success": true,
            //         "code": "0",
            //         "data": [
            //             {
            //                 "orderId": "264995729269765120",
            //                 "errorCode": "0",         // if already canceled: "2041"
            //                 "errorMsg": "success",    // if already canceled: "order state cannot be cancelled"
            //             },
            //         ]
            //     }
            //
            object data = this.safeList(response, "data");
            return this.parseOrders(data, market);
        }
    }

    /**
     * @method
     * @name mexc#cancelAllOrders
     * @description cancel all open orders
     * @see https://mexcdevelop.github.io/apidocs/spot_v3_en/#cancel-all-open-orders-on-a-symbol
     * @see https://mexcdevelop.github.io/apidocs/contract_v1_en/#cancel-all-orders-under-a-contract-under-maintenance
     * @see https://mexcdevelop.github.io/apidocs/contract_v1_en/#cancel-all-trigger-orders-under-maintenance
     * @param {string} symbol unified market symbol, only orders in the market of this symbol are cancelled when symbol is not undefined
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.marginMode] only 'isolated' is supported for spot-margin trading
     * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> cancelAllOrders(object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = ((bool) isTrue((!isEqual(symbol, null)))) ? this.market(symbol) : null;
        object request = new Dictionary<string, object>() {};
        object marketType = null;
        var marketTypeparametersVariable = this.handleMarketTypeAndParams("cancelAllOrders", market, parameters);
        marketType = ((IList<object>)marketTypeparametersVariable)[0];
        parameters = ((IList<object>)marketTypeparametersVariable)[1];
        var marginModequeryVariable = this.handleMarginModeAndParams("cancelAllOrders", parameters);
        var marginMode = ((IList<object>) marginModequeryVariable)[0];
        var query = ((IList<object>) marginModequeryVariable)[1];
        if (isTrue(isEqual(marketType, "spot")))
        {
            if (isTrue(isEqual(symbol, null)))
            {
                throw new ArgumentsRequired ((string)add(this.id, " cancelAllOrders() requires a symbol argument on spot")) ;
            }
            ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
            object response = null;
            if (isTrue(!isEqual(marginMode, null)))
            {
                if (isTrue(!isEqual(marginMode, "isolated")))
                {
                    throw new BadRequest ((string)add(add(add(this.id, " cancelAllOrders() does not support marginMode "), marginMode), " for spot-margin trading")) ;
                }
                response = await this.spotPrivateDeleteMarginOpenOrders(this.extend(request, query));
            } else
            {
                response = await this.spotPrivateDeleteOpenOrders(this.extend(request, query));
            }
            //
            // spot
            //
            //     [
            //         {
            //             "symbol": "BTCUSDT",
            //             "orderId": "133926492139692032",
            //             "price": "30000",
            //             "origQty": "0.0002",
            //             "type": "LIMIT",
            //             "side": "BUY"
            //         },
            //     ]
            //
            // margin
            //
            //     [
            //         {
            //             "symbol": "BTCUSDT",
            //             "orderId": "762640232574226432",
            //             "orderListId": "-1",
            //             "clientOrderId": null,
            //             "price": "18000",
            //             "origQty": "0.00147",
            //             "executedQty": "0",
            //             "cummulativeQuoteQty": "0",
            //             "status": "NEW",
            //             "type": "LIMIT",
            //             "side": "BUY",
            //             "isIsolated": true,
            //             "isWorking": true,
            //             "time": 1661994066000,
            //             "updateTime": 1661994066000
            //         }
            //     ]
            //
            return this.parseOrders(response, market);
        } else
        {
            if (isTrue(!isEqual(symbol, null)))
            {
                ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
            }
            // method can be either: contractPrivatePostOrderCancelAll or contractPrivatePostPlanorderCancelAll
            // the Planorder endpoints work not only for stop-market orders but also for stop-limit orders that are supposed to have separate endpoint
            object method = this.safeString(this.options, "cancelAllOrders", "contractPrivatePostOrderCancelAll");
            method = this.safeString(query, "method", method);
            object response = null;
            if (isTrue(isEqual(method, "contractPrivatePostOrderCancelAll")))
            {
                response = await this.contractPrivatePostOrderCancelAll(this.extend(request, query));
            } else if (isTrue(isEqual(method, "contractPrivatePostPlanorderCancelAll")))
            {
                response = await this.contractPrivatePostPlanorderCancelAll(this.extend(request, query));
            }
            //
            //     {
            //         "success": true,
            //         "code": "0"
            //     }
            //
            object data = this.safeList(response, "data", new List<object>() {});
            return this.parseOrders(data, market);
        }
    }

    public override object parseOrder(object order, object market = null)
    {
        //
        // spot
        //    createOrder
        //
        //    {
        //        "symbol": "FARTCOINUSDT",
        //        "orderId": "C02__342252993005723644225",
        //        "orderListId": "-1",
        //        "price": "1.1",
        //        "origQty": "6.3",
        //        "type": "IMMEDIATE_OR_CANCEL",
        //        "side": "SELL",
        //        "transactTime": "1745852205223"
        //    }
        //
        //    unknown endpoint on spot
        //
        //    {
        //         "symbol": "BTCUSDT",
        //         "orderId": "123738410679123456",
        //         "orderListId": -1
        //    }
        //
        // margin: createOrder
        //
        //     {
        //         "symbol": "BTCUSDT",
        //         "orderId": "762634301354414080",
        //         "clientOrderId": null,
        //         "isIsolated": true,
        //         "transactTime": 1661992652132
        //     }
        //
        // spot: cancelOrder, cancelAllOrders
        //
        //     {
        //         "symbol": "BTCUSDT",
        //         "orderId": "133926441921286144",
        //         "price": "30000",
        //         "origQty": "0.0002",
        //         "type": "LIMIT",
        //         "side": "BUY"
        //     }
        //
        // margin: cancelOrder, cancelAllOrders
        //
        //     {
        //         "symbol": "BTCUSDT",
        //         "orderId": "762640232574226432",
        //         "orderListId": "-1",
        //         "clientOrderId": null,
        //         "price": "18000",
        //         "origQty": "0.00147",
        //         "executedQty": "0",
        //         "cummulativeQuoteQty": "0",
        //         "status": "NEW",
        //         "type": "LIMIT",
        //         "side": "BUY",
        //         "isIsolated": true,
        //         "isWorking": true,
        //         "time": 1661994066000,
        //         "updateTime": 1661994066000
        //     }
        //
        // spot: fetchOrder, fetchOpenOrders, fetchOrders
        //
        //     {
        //         "symbol": "BTCUSDT",
        //         "orderId": "133734823834147272",
        //         "orderListId": "-1",
        //         "clientOrderId": null,
        //         "price": "30000",
        //         "origQty": "0.0002",
        //         "executedQty": "0",
        //         "cummulativeQuoteQty": "0",
        //         "status": "CANCELED",
        //         "timeInForce": null,
        //         "type": "LIMIT",
        //         "side": "BUY",
        //         "stopPrice": null,
        //         "icebergQty": null,
        //         "time": "1647667102000",
        //         "updateTime": "1647708567000",
        //         "isWorking": true,
        //         "origQuoteOrderQty": "6"
        //     }
        //
        // margin: fetchOrder, fetchOrders
        //
        //     {
        //         "symbol": "BTCUSDT",
        //         "orderId": "763307297891028992",
        //         "orderListId": "-1",
        //         "clientOrderId": null,
        //         "price": "18000",
        //         "origQty": "0.0014",
        //         "executedQty": "0",
        //         "cummulativeQuoteQty": "0",
        //         "status": "NEW",
        //         "type": "LIMIT",
        //         "side": "BUY",
        //         "isIsolated": true,
        //         "isWorking": true,
        //         "time": 1662153107000,
        //         "updateTime": 1662153107000
        //     }
        //
        // swap: createOrder
        //
        //     2ff3163e8617443cb9c6fc19d42b1ca4
        //
        // swap: fetchOrder, fetchOrders
        //
        //     regular
        //     {
        //         "orderId": "264995729269765120",
        //         "symbol": "STEPN_USDT",
        //         "positionId": "0",
        //         "price": "2.2",
        //         "vol": "15",
        //         "leverage": "20",
        //         "side": "1", // TODO: not unified
        //         "category": "1",
        //         "orderType": "1", // TODO: not unified
        //         "dealAvgPrice": "0",
        //         "dealVol": "0",
        //         "orderMargin": "2.2528",
        //         "takerFee": "0",
        //         "makerFee": "0",
        //         "profit": "0",
        //         "feeCurrency": "USDT",
        //         "openType": "1",
        //         "state": "2", // TODO
        //         "externalOid": "_m_0e9520c256744d64b942985189026d20",
        //         "errorCode": "0",
        //         "usedMargin": "0",
        //         "createTime": "1648850305236",
        //         "updateTime": "1648850305245",
        //         "positionMode": "1"
        //     }
        //
        //     stop
        //     {
        //         "id": "265557643326564352",
        //         "triggerType": "1",
        //         "triggerPrice": "3",
        //         "price": "2.9", // not present in stop-market, but in stop-limit order
        //         "executeCycle": "87600",
        //         "trend": "1",
        //          // below keys are same as in regular order structure
        //         "symbol": "STEPN_USDT",
        //         "leverage": "20",
        //         "side": "1",
        //         "vol": "13",
        //         "openType": "1",
        //         "state": "1",
        //         "orderType": "1",
        //         "errorCode": "0",
        //         "createTime": "1648984276000",
        //         "updateTime": "1648984276000",
        //     }
        //
        // createOrders error
        //
        //     {
        //         "newClientOrderId": "123456",
        //         "msg": "The minimum transaction volume cannot be less than:0.5USDT",
        //         "code": 30002
        //     }
        //
        object code = this.safeInteger(order, "code");
        if (isTrue(!isEqual(code, null)))
        {
            // error upon placing multiple orders
            return this.safeOrder(new Dictionary<string, object>() {
                { "info", order },
                { "status", "rejected" },
                { "clientOrderId", this.safeString(order, "newClientOrderId") },
            });
        }
        object id = null;
        if (isTrue((order is string)))
        {
            id = order;
        } else
        {
            id = this.safeString2(order, "orderId", "id");
        }
        object timeInForce = this.parseOrderTimeInForce(this.safeString(order, "timeInForce"));
        object typeRaw = this.safeString(order, "type");
        if (isTrue(isEqual(timeInForce, null)))
        {
            timeInForce = this.getTifFromRawOrderType(typeRaw);
        }
        object marketId = this.safeString(order, "symbol");
        market = this.safeMarket(marketId, market);
        object timestamp = this.safeIntegerN(order, new List<object>() {"time", "createTime", "transactTime"});
        object fee = null;
        object feeCurrency = this.safeString(order, "feeCurrency");
        if (isTrue(!isEqual(feeCurrency, null)))
        {
            object takerFee = this.safeString(order, "takerFee");
            object makerFee = this.safeString(order, "makerFee");
            object feeSum = Precise.stringAdd(takerFee, makerFee);
            fee = new Dictionary<string, object>() {
                { "currency", feeCurrency },
                { "cost", this.parseNumber(feeSum) },
            };
        }
        return this.safeOrder(new Dictionary<string, object>() {
            { "id", id },
            { "clientOrderId", this.safeString(order, "clientOrderId") },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "lastTradeTimestamp", null },
            { "status", this.parseOrderStatus(this.safeString2(order, "status", "state")) },
            { "symbol", getValue(market, "symbol") },
            { "type", this.parseOrderType(typeRaw) },
            { "timeInForce", timeInForce },
            { "side", this.parseOrderSide(this.safeString(order, "side")) },
            { "price", this.safeNumber(order, "price") },
            { "triggerPrice", this.safeNumber2(order, "stopPrice", "triggerPrice") },
            { "average", this.safeNumber(order, "dealAvgPrice") },
            { "amount", this.safeNumber2(order, "origQty", "vol") },
            { "cost", this.safeNumber(order, "cummulativeQuoteQty") },
            { "filled", this.safeNumber2(order, "executedQty", "dealVol") },
            { "remaining", null },
            { "fee", fee },
            { "trades", null },
            { "info", order },
        }, market);
    }

    public virtual object parseOrderSide(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "BUY", "buy" },
            { "SELL", "sell" },
            { "1", "buy" },
            { "2", "sell" },
        };
        return this.safeString(statuses, status, status);
    }

    public virtual object parseOrderType(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "MARKET", "market" },
            { "LIMIT", "limit" },
            { "LIMIT_MAKER", "limit" },
            { "IMMEDIATE_OR_CANCEL", "limit" },
            { "FILL_OR_KILL", "limit" },
        };
        return this.safeString(statuses, status, status);
    }

    public virtual object parseOrderStatus(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "NEW", "open" },
            { "FILLED", "closed" },
            { "CANCELED", "canceled" },
            { "PARTIALLY_FILLED", "open" },
            { "PARTIALLY_CANCELED", "canceled" },
            { "2", "open" },
            { "3", "closed" },
            { "4", "canceled" },
        };
        return this.safeString(statuses, status, status);
    }

    public virtual object parseOrderTimeInForce(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "GTC", "GTC" },
            { "FOK", "FOK" },
            { "IOC", "IOC" },
        };
        return this.safeString(statuses, status, status);
    }

    public virtual object getTifFromRawOrderType(object orderType = null)
    {
        object statuses = new Dictionary<string, object>() {
            { "LIMIT", "GTC" },
            { "LIMIT_MAKER", "POST_ONLY" },
            { "IMMEDIATE_OR_CANCEL", "IOC" },
            { "FILL_OR_KILL", "FOK" },
            { "MARKET", "IOC" },
        };
        return this.safeString(statuses, orderType, orderType);
    }

    public async virtual Task<object> fetchAccountHelper(object type, object parameters)
    {
        if (isTrue(isEqual(type, "spot")))
        {
            return await this.spotPrivateGetAccount(parameters);
        } else if (isTrue(isEqual(type, "swap")))
        {
            object response = await this.contractPrivateGetAccountAssets(parameters);
            //
            //     {
            //         "success":true,
            //         "code":0,
            //         "data":[
            //            {
            //              "currency":"BSV",
            //              "positionMargin":0,
            //              "availableBalance":0,
            //              "cashBalance":0,
            //              "frozenBalance":0,
            //              "equity":0,
            //              "unrealized":0,
            //              "bonus":0
            //           },
            //         ]
            //     }
            //
            return this.safeValue(response, "data");
        }
        return null;
    }

    /**
     * @method
     * @name mexc#fetchAccounts
     * @description fetch all the accounts associated with a profile
     * @see https://mexcdevelop.github.io/apidocs/spot_v3_en/#account-information
     * @see https://mexcdevelop.github.io/apidocs/contract_v1_en/#get-all-informations-of-user-39-s-asset
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a dictionary of [account structures]{@link https://docs.ccxt.com/#/?id=account-structure} indexed by the account type
     */
    public async override Task<object> fetchAccounts(object parameters = null)
    {
        // TODO: is the below endpoints suitable for fetchAccounts?
        parameters ??= new Dictionary<string, object>();
        var marketTypequeryVariable = this.handleMarketTypeAndParams("fetchAccounts", null, parameters);
        var marketType = ((IList<object>) marketTypequeryVariable)[0];
        var query = ((IList<object>) marketTypequeryVariable)[1];
        await this.loadMarkets();
        object response = await this.fetchAccountHelper(marketType, query);
        object data = this.safeValue(response, "balances", new List<object>() {});
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
        {
            object account = getValue(data, i);
            object currencyId = this.safeString2(account, "asset", "currency");
            object code = this.safeCurrencyCode(currencyId);
            ((IList<object>)result).Add(new Dictionary<string, object>() {
                { "id", this.safeString(account, "id") },
                { "type", this.safeString(account, "type") },
                { "code", code },
                { "info", account },
            });
        }
        return result;
    }

    /**
     * @method
     * @name mexc#fetchTradingFee
     * @description fetch the trading fees for a market
     * @see https://mexcdevelop.github.io/apidocs/spot_v3_en/#query-mx-deduct-status
     * @param {string} symbol unified market symbol
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [fee structure]{@link https://docs.ccxt.com/#/?id=fee-structure}
     */
    public async override Task<object> fetchTradingFee(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        if (!isTrue(getValue(market, "spot")))
        {
            throw new BadRequest ((string)add(this.id, " fetchTradingFee() supports spot markets only")) ;
        }
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object response = await this.spotPrivateGetTradeFee(this.extend(request, parameters));
        //
        //  {
        //      "data":{
        //        "makerCommission":0.003000000000000000,
        //        "takerCommission":0.003000000000000000
        //      },
        //      "code":0,
        //      "msg":"success",
        //      "timestamp":1669109672717
        //  }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        return new Dictionary<string, object>() {
            { "info", data },
            { "symbol", symbol },
            { "maker", this.safeNumber(data, "makerCommission") },
            { "taker", this.safeNumber(data, "takerCommission") },
            { "percentage", null },
            { "tierBased", null },
        };
    }

    public virtual object customParseBalance(object response, object marketType)
    {
        //
        // spot
        //
        //     {
        //         "asset": "USDT",
        //         "free": "0.000000000674",
        //         "locked": "0"
        //     }
        //
        // swap
        //
        //     {
        //         "currency": "BSV",
        //         "positionMargin": 0,
        //         "availableBalance": 0,
        //         "cashBalance": 0,
        //         "frozenBalance": 0,
        //         "equity": 0,
        //         "unrealized": 0,
        //         "bonus": 0
        //     }
        //
        // margin
        //
        //     {
        //         "baseAsset": {
        //             "asset": "BTC",
        //             "borrowEnabled": true,
        //             "borrowed": "0",
        //             "free": "0",
        //             "interest": "0",
        //             "locked": "0",
        //             "netAsset": "0",
        //             "netAssetOfBtc": "0",
        //             "repayEnabled": true,
        //             "totalAsset": "0"
        //         }
        //         "quoteAsset": {
        //             "asset": "USDT",
        //             "borrowEnabled": true,
        //             "borrowed": "0",
        //             "free": "10",
        //             "interest": "0",
        //             "locked": "0",
        //             "netAsset": "10",
        //             "netAssetOfBtc": "0",
        //             "repayEnabled": true,
        //             "totalAsset": "10"
        //         }
        //         "symbol": "BTCUSDT",
        //         "isolatedCreated": true,
        //         "enabled": true,
        //         "marginLevel": "999",
        //         "marginRatio": "9",
        //         "indexPrice": "16741.137068965517241379",
        //         "liquidatePrice": "--",
        //         "liquidateRate": "--",
        //         "tradeEnabled": true
        //     }
        //
        object wallet = null;
        if (isTrue(isEqual(marketType, "margin")))
        {
            wallet = this.safeValue(response, "assets", new List<object>() {});
        } else if (isTrue(isEqual(marketType, "swap")))
        {
            wallet = this.safeValue(response, "data", new List<object>() {});
        } else
        {
            wallet = this.safeValue(response, "balances", new List<object>() {});
        }
        object result = new Dictionary<string, object>() {
            { "info", response },
        };
        if (isTrue(isEqual(marketType, "margin")))
        {
            for (object i = 0; isLessThan(i, getArrayLength(wallet)); postFixIncrement(ref i))
            {
                object entry = getValue(wallet, i);
                object marketId = this.safeString(entry, "symbol");
                object symbol = this.safeSymbol(marketId, null);
                object bs = this.safeValue(entry, "baseAsset", new Dictionary<string, object>() {});
                object quote = this.safeValue(entry, "quoteAsset", new Dictionary<string, object>() {});
                object baseCode = this.safeCurrencyCode(this.safeString(bs, "asset"));
                object quoteCode = this.safeCurrencyCode(this.safeString(quote, "asset"));
                object subResult = new Dictionary<string, object>() {};
                ((IDictionary<string,object>)subResult)[(string)baseCode] = this.parseBalanceHelper(bs);
                ((IDictionary<string,object>)subResult)[(string)quoteCode] = this.parseBalanceHelper(quote);
                ((IDictionary<string,object>)result)[(string)symbol] = this.safeBalance(subResult);
            }
            return result;
        } else if (isTrue(isEqual(marketType, "swap")))
        {
            for (object i = 0; isLessThan(i, getArrayLength(wallet)); postFixIncrement(ref i))
            {
                object entry = getValue(wallet, i);
                object currencyId = this.safeString(entry, "currency");
                object code = this.safeCurrencyCode(currencyId);
                object account = this.account();
                ((IDictionary<string,object>)account)["free"] = this.safeString(entry, "availableBalance");
                ((IDictionary<string,object>)account)["used"] = this.safeString(entry, "frozenBalance");
                ((IDictionary<string,object>)result)[(string)code] = account;
            }
            return this.safeBalance(result);
        } else
        {
            for (object i = 0; isLessThan(i, getArrayLength(wallet)); postFixIncrement(ref i))
            {
                object entry = getValue(wallet, i);
                object currencyId = this.safeString(entry, "asset");
                object code = this.safeCurrencyCode(currencyId);
                object account = this.account();
                ((IDictionary<string,object>)account)["free"] = this.safeString(entry, "free");
                ((IDictionary<string,object>)account)["used"] = this.safeString(entry, "locked");
                ((IDictionary<string,object>)result)[(string)code] = account;
            }
            return this.safeBalance(result);
        }
    }

    public virtual object parseBalanceHelper(object entry)
    {
        object account = this.account();
        ((IDictionary<string,object>)account)["used"] = this.safeString(entry, "locked");
        ((IDictionary<string,object>)account)["free"] = this.safeString(entry, "free");
        ((IDictionary<string,object>)account)["total"] = this.safeString(entry, "totalAsset");
        object debt = this.safeString(entry, "borrowed");
        object interest = this.safeString(entry, "interest");
        ((IDictionary<string,object>)account)["debt"] = Precise.stringAdd(debt, interest);
        return account;
    }

    /**
     * @method
     * @name mexc#fetchBalance
     * @description query for balance and get the amount of funds available for trading or funds locked in orders
     * @see https://mexcdevelop.github.io/apidocs/spot_v3_en/#account-information
     * @see https://mexcdevelop.github.io/apidocs/contract_v1_en/#get-all-informations-of-user-39-s-asset
     * @see https://mexcdevelop.github.io/apidocs/spot_v3_en/#isolated-account
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.symbols] // required for margin, market id's separated by commas
     * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
     */
    public async override Task<object> fetchBalance(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object marketType = null;
        object request = new Dictionary<string, object>() {};
        var marketTypeparametersVariable = this.handleMarketTypeAndParams("fetchBalance", null, parameters);
        marketType = ((IList<object>)marketTypeparametersVariable)[0];
        parameters = ((IList<object>)marketTypeparametersVariable)[1];
        object marginMode = this.safeString(parameters, "marginMode");
        object isMargin = this.safeBool(parameters, "margin", false);
        parameters = this.omit(parameters, new List<object>() {"margin", "marginMode"});
        object response = null;
        if (isTrue(isTrue(isTrue((!isEqual(marginMode, null))) || isTrue((isMargin))) || isTrue((isEqual(marketType, "margin")))))
        {
            object parsedSymbols = null;
            object symbol = this.safeString(parameters, "symbol");
            if (isTrue(isEqual(symbol, null)))
            {
                object symbols = this.safeValue(parameters, "symbols");
                if (isTrue(!isEqual(symbols, null)))
                {
                    parsedSymbols = String.Join(",", ((IList<object>)this.marketIds(symbols)).ToArray());
                }
            } else
            {
                object market = this.market(symbol);
                parsedSymbols = getValue(market, "id");
            }
            this.checkRequiredArgument("fetchBalance", parsedSymbols, "symbol or symbols");
            marketType = "margin";
            ((IDictionary<string,object>)request)["symbols"] = parsedSymbols;
            parameters = this.omit(parameters, new List<object>() {"symbol", "symbols"});
            response = await this.spotPrivateGetMarginIsolatedAccount(this.extend(request, parameters));
        } else if (isTrue(isEqual(marketType, "spot")))
        {
            response = await this.spotPrivateGetAccount(this.extend(request, parameters));
        } else if (isTrue(isEqual(marketType, "swap")))
        {
            response = await this.contractPrivateGetAccountAssets(this.extend(request, parameters));
        } else
        {
            throw new NotSupported ((string)add(this.id, " fetchBalance() not support this method")) ;
        }
        //
        // spot
        //
        //     {
        //         "makerCommission": 0,
        //         "takerCommission": 20,
        //         "buyerCommission": 0,
        //         "sellerCommission": 0,
        //         "canTrade": true,
        //         "canWithdraw": true,
        //         "canDeposit": true,
        //         "updateTime": null,
        //         "accountType": "SPOT",
        //         "balances": [
        //             {
        //                 "asset": "USDT",
        //                 "free": "0.000000000674",
        //                 "locked": "0"
        //             },
        //         ],
        //         "permissions": ["SPOT"]
        //     }
        //
        // swap
        //
        //     {
        //         "success": true,
        //         "code": 0,
        //         "data": [
        //             {
        //                 "currency": "BSV",
        //                 "positionMargin": 0,
        //                 "availableBalance": 0,
        //                 "cashBalance": 0,
        //                 "frozenBalance": 0,
        //                 "equity": 0,
        //                 "unrealized": 0,
        //                 "bonus": 0
        //             },
        //         ]
        //     }
        //
        // margin
        //
        //     {
        //         "assets": [
        //             {
        //                 "baseAsset": {
        //                     "asset": "BTC",
        //                     "borrowEnabled": true,
        //                     "borrowed": "0",
        //                     "free": "0",
        //                     "interest": "0",
        //                     "locked": "0",
        //                     "netAsset": "0",
        //                     "netAssetOfBtc": "0",
        //                     "repayEnabled": true,
        //                     "totalAsset": "0"
        //                 },
        //                 "quoteAsset": {
        //                     "asset": "USDT",
        //                     "borrowEnabled": true,
        //                     "borrowed": "0",
        //                     "free": "10",
        //                     "interest": "0",
        //                     "locked": "0",
        //                     "netAsset": "10",
        //                     "netAssetOfBtc": "0",
        //                     "repayEnabled": true,
        //                     "totalAsset": "10"
        //                 },
        //                 "symbol": "BTCUSDT",
        //                 "isolatedCreated": true,
        //                 "enabled": true,
        //                 "marginLevel": "999",
        //                 "marginRatio": "9",
        //                 "indexPrice": "16741.137068965517241379",
        //                 "liquidatePrice": "--",
        //                 "liquidateRate": "--",
        //                 "tradeEnabled": true
        //             }
        //         ]
        //     }
        //
        return this.customParseBalance(response, marketType);
    }

    /**
     * @method
     * @name mexc#fetchMyTrades
     * @description fetch all trades made by the user
     * @see https://mexcdevelop.github.io/apidocs/spot_v3_en/#account-trade-list
     * @see https://mexcdevelop.github.io/apidocs/contract_v1_en/#get-all-transaction-details-of-the-user-s-order
     * @param {string} symbol unified market symbol
     * @param {int} [since] the earliest time in ms to fetch trades for
     * @param {int} [limit] the maximum number of trades structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {int} [params.until] the latest time in ms to fetch trades for
     * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
     */
    public async override Task<object> fetchMyTrades(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchMyTrades() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object marketType = null;
        var marketTypeparametersVariable = this.handleMarketTypeAndParams("fetchMyTrades", market, parameters);
        marketType = ((IList<object>)marketTypeparametersVariable)[0];
        parameters = ((IList<object>)marketTypeparametersVariable)[1];
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object trades = null;
        if (isTrue(isEqual(marketType, "spot")))
        {
            if (isTrue(!isEqual(since, null)))
            {
                ((IDictionary<string,object>)request)["startTime"] = since;
            }
            if (isTrue(!isEqual(limit, null)))
            {
                ((IDictionary<string,object>)request)["limit"] = limit;
            }
            object until = this.safeInteger(parameters, "until");
            if (isTrue(!isEqual(until, null)))
            {
                parameters = this.omit(parameters, "until");
                ((IDictionary<string,object>)request)["endTime"] = until;
            }
            trades = await this.spotPrivateGetMyTrades(this.extend(request, parameters));
        } else
        {
            if (isTrue(!isEqual(since, null)))
            {
                ((IDictionary<string,object>)request)["start_time"] = since;
                object end = this.safeInteger(parameters, "end_time");
                if (isTrue(isEqual(end, null)))
                {
                    ((IDictionary<string,object>)request)["end_time"] = this.sum(since, getValue(this.options, "maxTimeTillEnd"));
                }
            }
            if (isTrue(!isEqual(limit, null)))
            {
                ((IDictionary<string,object>)request)["page_size"] = limit;
            }
            object response = await this.contractPrivateGetOrderListOrderDeals(this.extend(request, parameters));
            //
            //     {
            //         "success": true,
            //         "code": "0",
            //         "data": [
            //             {
            //                 "id": "299444585",
            //                 "symbol": "STEPN_USDT",
            //                 "side": "1",
            //                 "vol": "1",
            //                 "price": "2.45455",
            //                 "feeCurrency": "USDT",
            //                 "fee": "0.00147273",
            //                 "timestamp": "1648924557000",
            //                 "profit": "0",
            //                 "category": "1",
            //                 "orderId": "265307163526610432",
            //                 "positionMode": "1",
            //                 "taker": true
            //             }
            //         ]
            //     }
            //
            trades = this.safeValue(response, "data");
        }
        return this.parseTrades(trades, market, since, limit);
    }

    /**
     * @method
     * @name mexc#fetchOrderTrades
     * @description fetch all the trades made from a single order
     * @see https://mexcdevelop.github.io/apidocs/spot_v3_en/#account-trade-list
     * @see https://mexcdevelop.github.io/apidocs/contract_v1_en/#query-the-order-based-on-the-order-number
     * @param {string} id order id
     * @param {string} symbol unified market symbol
     * @param {int} [since] the earliest time in ms to fetch trades for
     * @param {int} [limit] the maximum number of trades to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
     */
    public async override Task<object> fetchOrderTrades(object id, object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
        }
        var marketTypequeryVariable = this.handleMarketTypeAndParams("fetchOrderTrades", market, parameters);
        var marketType = ((IList<object>) marketTypequeryVariable)[0];
        var query = ((IList<object>) marketTypequeryVariable)[1];
        object trades = null;
        if (isTrue(isEqual(marketType, "spot")))
        {
            if (isTrue(isEqual(symbol, null)))
            {
                throw new ArgumentsRequired ((string)add(this.id, " fetchOrderTrades() requires a symbol argument")) ;
            }
            ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
            ((IDictionary<string,object>)request)["orderId"] = id;
            trades = await this.spotPrivateGetMyTrades(this.extend(request, query));
        } else
        {
            ((IDictionary<string,object>)request)["order_id"] = id;
            object response = await this.contractPrivateGetOrderDealDetailsOrderId(this.extend(request, query));
            //
            //     {
            //         "success": true,
            //         "code": "0",
            //         "data": [
            //             {
            //                 "id": "299444585",
            //                 "symbol": "STEPN_USDT",
            //                 "side": "1",
            //                 "vol": "1",
            //                 "price": "2.45455",
            //                 "feeCurrency": "USDT",
            //                 "fee": "0.00147273",
            //                 "timestamp": "1648924557000",
            //                 "profit": "0",
            //                 "category": "1",
            //                 "orderId": "265307163526610432",
            //                 "positionMode": "1",
            //                 "taker": true
            //             }
            //         ]
            //     }
            //
            trades = this.safeValue(response, "data");
        }
        return this.parseTrades(trades, market, since, limit, query);
    }

    public async virtual Task<object> modifyMarginHelper(object symbol, object amount, object addOrReduce, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object positionId = this.safeInteger(parameters, "positionId");
        if (isTrue(isEqual(positionId, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " modifyMarginHelper() requires a positionId parameter")) ;
        }
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {
            { "positionId", positionId },
            { "amount", amount },
            { "type", addOrReduce },
        };
        object response = await this.contractPrivatePostPositionChangeMargin(this.extend(request, parameters));
        //
        //     {
        //         "success": true,
        //         "code": 0
        //     }
        return response;
    }

    /**
     * @method
     * @name mexc#reduceMargin
     * @description remove margin from a position
     * @see https://mexcdevelop.github.io/apidocs/contract_v1_en/#increase-or-decrease-margin
     * @param {string} symbol unified market symbol
     * @param {float} amount the amount of margin to remove
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [margin structure]{@link https://docs.ccxt.com/#/?id=reduce-margin-structure}
     */
    public async override Task<object> reduceMargin(object symbol, object amount, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        return await this.modifyMarginHelper(symbol, amount, "SUB", parameters);
    }

    /**
     * @method
     * @name mexc#addMargin
     * @description add margin
     * @see https://mexcdevelop.github.io/apidocs/contract_v1_en/#increase-or-decrease-margin
     * @param {string} symbol unified market symbol
     * @param {float} amount amount of margin to add
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [margin structure]{@link https://docs.ccxt.com/#/?id=add-margin-structure}
     */
    public async override Task<object> addMargin(object symbol, object amount, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        return await this.modifyMarginHelper(symbol, amount, "ADD", parameters);
    }

    /**
     * @method
     * @name mexc#setLeverage
     * @description set the level of leverage for a market
     * @see https://mexcdevelop.github.io/apidocs/contract_v1_en/#switch-leverage
     * @param {float} leverage the rate of leverage
     * @param {string} symbol unified market symbol
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} response from the exchange
     */
    public async override Task<object> setLeverage(object leverage, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {
            { "leverage", leverage },
        };
        object positionId = this.safeInteger(parameters, "positionId");
        if (isTrue(isEqual(positionId, null)))
        {
            object openType = this.safeNumber(parameters, "openType"); // 1 or 2
            object positionType = this.safeNumber(parameters, "positionType"); // 1 or 2
            object market = ((bool) isTrue((!isEqual(symbol, null)))) ? this.market(symbol) : null;
            if (isTrue(isTrue(isTrue((isEqual(openType, null))) || isTrue((isEqual(positionType, null)))) || isTrue((isEqual(market, null)))))
            {
                throw new ArgumentsRequired ((string)add(this.id, " setLeverage() requires a positionId parameter or a symbol argument with openType and positionType parameters, use openType 1 or 2 for isolated or cross margin respectively, use positionType 1 or 2 for long or short positions")) ;
            } else
            {
                ((IDictionary<string,object>)request)["openType"] = openType;
                ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
                ((IDictionary<string,object>)request)["positionType"] = positionType;
            }
        } else
        {
            ((IDictionary<string,object>)request)["positionId"] = positionId;
        }
        return await this.contractPrivatePostPositionChangeLeverage(this.extend(request, parameters));
    }

    /**
     * @method
     * @name mexc#fetchFundingHistory
     * @description fetch the history of funding payments paid and received on this account
     * @see https://mexcdevelop.github.io/apidocs/contract_v1_en/#get-details-of-user-s-funding-rate
     * @param {string} symbol unified market symbol
     * @param {int} [since] the earliest time in ms to fetch funding history for
     * @param {int} [limit] the maximum number of funding history structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [funding history structure]{@link https://docs.ccxt.com/#/?id=funding-history-structure}
     */
    public async override Task<object> fetchFundingHistory(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = null;
        object request = new Dictionary<string, object>() {};
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["page_size"] = limit;
        }
        object response = await this.contractPrivateGetPositionFundingRecords(this.extend(request, parameters));
        //
        //     {
        //         "success": true,
        //         "code": 0,
        //         "data": {
        //             "pageSize": 20,
        //             "totalCount": 2,
        //             "totalPage": 1,
        //             "currentPage": 1,
        //             "resultList": [
        //                 {
        //                     "id": 7423910,
        //                     "symbol": "BTC_USDT",
        //                     "positionType": 1,
        //                     "positionValue": 29.30024,
        //                     "funding": 0.00076180624,
        //                     "rate": -0.000026,
        //                     "settleTime": 1643299200000
        //                 },
        //                 {
        //                     "id": 7416473,
        //                     "symbol": "BTC_USDT",
        //                     "positionType": 1,
        //                     "positionValue": 28.9188,
        //                     "funding": 0.0014748588,
        //                     "rate": -0.000051,
        //                     "settleTime": 1643270400000
        //                 }
        //             ]
        //         }
        //     }
        //
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        object resultList = this.safeValue(data, "resultList", new List<object>() {});
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(resultList)); postFixIncrement(ref i))
        {
            object entry = getValue(resultList, i);
            object timestamp = this.safeInteger(entry, "settleTime");
            ((IList<object>)result).Add(new Dictionary<string, object>() {
                { "info", entry },
                { "symbol", symbol },
                { "code", null },
                { "timestamp", timestamp },
                { "datetime", this.iso8601(timestamp) },
                { "id", this.safeNumber(entry, "id") },
                { "amount", this.safeNumber(entry, "funding") },
            });
        }
        return result;
    }

    public override object parseFundingRate(object contract, object market = null)
    {
        //
        //     {
        //         "symbol": "BTC_USDT",
        //         "fundingRate": 0.000014,
        //         "maxFundingRate": 0.003,
        //         "minFundingRate": -0.003,
        //         "collectCycle": 8,
        //         "nextSettleTime": 1643241600000,
        //         "timestamp": 1643240373359
        //     }
        //
        object nextFundingRate = this.safeNumber(contract, "fundingRate");
        object nextFundingTimestamp = this.safeInteger(contract, "nextSettleTime");
        object marketId = this.safeString(contract, "symbol");
        object symbol = this.safeSymbol(marketId, market, null, "contract");
        object timestamp = this.safeInteger(contract, "timestamp");
        object interval = this.safeString(contract, "collectCycle");
        object intervalString = null;
        if (isTrue(!isEqual(interval, null)))
        {
            intervalString = add(interval, "h");
        }
        return new Dictionary<string, object>() {
            { "info", contract },
            { "symbol", symbol },
            { "markPrice", null },
            { "indexPrice", null },
            { "interestRate", null },
            { "estimatedSettlePrice", null },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "fundingRate", nextFundingRate },
            { "fundingTimestamp", nextFundingTimestamp },
            { "fundingDatetime", this.iso8601(nextFundingTimestamp) },
            { "nextFundingRate", null },
            { "nextFundingTimestamp", null },
            { "nextFundingDatetime", null },
            { "previousFundingRate", null },
            { "previousFundingTimestamp", null },
            { "previousFundingDatetime", null },
            { "interval", intervalString },
        };
    }

    /**
     * @method
     * @name mexc#fetchFundingInterval
     * @description fetch the current funding rate interval
     * @see https://mexcdevelop.github.io/apidocs/contract_v1_en/#get-contract-funding-rate
     * @param {string} symbol unified market symbol
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [funding rate structure]{@link https://docs.ccxt.com/#/?id=funding-rate-structure}
     */
    public async override Task<object> fetchFundingInterval(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        return await this.fetchFundingRate(symbol, parameters);
    }

    /**
     * @method
     * @name mexc#fetchFundingRate
     * @description fetch the current funding rate
     * @see https://mexcdevelop.github.io/apidocs/contract_v1_en/#get-contract-funding-rate
     * @param {string} symbol unified market symbol
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [funding rate structure]{@link https://docs.ccxt.com/#/?id=funding-rate-structure}
     */
    public async override Task<object> fetchFundingRate(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object response = await this.contractPublicGetFundingRateSymbol(this.extend(request, parameters));
        //
        //     {
        //         "success": true,
        //         "code": 0,
        //         "data": {
        //             "symbol": "BTC_USDT",
        //             "fundingRate": 0.000014,
        //             "maxFundingRate": 0.003,
        //             "minFundingRate": -0.003,
        //             "collectCycle": 8,
        //             "nextSettleTime": 1643241600000,
        //             "timestamp": 1643240373359
        //         }
        //     }
        //
        object result = this.safeValue(response, "data", new Dictionary<string, object>() {});
        return this.parseFundingRate(result, market);
    }

    /**
     * @method
     * @name mexc#fetchFundingRateHistory
     * @description fetches historical funding rate prices
     * @see https://mexcdevelop.github.io/apidocs/contract_v1_en/#get-contract-funding-rate-history
     * @param {string} symbol unified symbol of the market to fetch the funding rate history for
     * @param {int} [since] not used by mexc, but filtered internally by ccxt
     * @param {int} [limit] mexc limit is page_size default 20, maximum is 100
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} a list of [funding rate structures]{@link https://docs.ccxt.com/#/?id=funding-rate-history-structure}
     */
    public async override Task<object> fetchFundingRateHistory(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchFundingRateHistory() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["page_size"] = limit;
        }
        object response = await this.contractPublicGetFundingRateHistory(this.extend(request, parameters));
        //
        //    {
        //        "success": true,
        //        "code": 0,
        //        "data": {
        //            "pageSize": 2,
        //            "totalCount": 21,
        //            "totalPage": 11,
        //            "currentPage": 1,
        //            "resultList": [
        //                {
        //                    "symbol": "BTC_USDT",
        //                    "fundingRate": 0.000266,
        //                    "settleTime": 1609804800000
        //                },
        //                {
        //                    "symbol": "BTC_USDT",
        //                    "fundingRate": 0.00029,
        //                    "settleTime": 1609776000000
        //                }
        //            ]
        //        }
        //    }
        //
        object data = this.safeValue(response, "data");
        object result = this.safeValue(data, "resultList", new List<object>() {});
        object rates = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(result)); postFixIncrement(ref i))
        {
            object entry = getValue(result, i);
            object marketId = this.safeString(entry, "symbol");
            object symbolInner = this.safeSymbol(marketId);
            object timestamp = this.safeInteger(entry, "settleTime");
            ((IList<object>)rates).Add(new Dictionary<string, object>() {
                { "info", entry },
                { "symbol", symbolInner },
                { "fundingRate", this.safeNumber(entry, "fundingRate") },
                { "timestamp", timestamp },
                { "datetime", this.iso8601(timestamp) },
            });
        }
        object sorted = this.sortBy(rates, "timestamp");
        return this.filterBySymbolSinceLimit(sorted, getValue(market, "symbol"), since, limit);
    }

    /**
     * @method
     * @name mexc#fetchLeverageTiers
     * @description retrieve information on the maximum leverage, and maintenance margin for trades of varying trade sizes, if a market has a leverage tier of 0, then the leverage tiers cannot be obtained for this market
     * @see https://mexcdevelop.github.io/apidocs/contract_v1_en/#get-the-contract-information
     * @param {string[]} [symbols] list of unified market symbols
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a dictionary of [leverage tiers structures]{@link https://docs.ccxt.com/#/?id=leverage-tiers-structure}, indexed by market symbols
     */
    public async override Task<object> fetchLeverageTiers(object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        symbols = this.marketSymbols(symbols, "swap", true, true);
        object response = await this.contractPublicGetDetail(parameters);
        //
        //     {
        //         "success":true,
        //         "code":0,
        //         "data":[
        //             {
        //                 "symbol": "BTC_USDT",
        //                 "displayName": "BTC_USDT",
        //                 "displayNameEn": "BTC_USDT SWAP",
        //                 "positionOpenType": 3,
        //                 "baseCoin": "BTC",
        //                 "quoteCoin": "USDT",
        //                 "settleCoin": "USDT",
        //                 "contractSize": 0.0001,
        //                 "minLeverage": 1,
        //                 "maxLeverage": 125,
        //                 "priceScale": 2,
        //                 "volScale": 0,
        //                 "amountScale": 4,
        //                 "priceUnit": 0.5,
        //                 "volUnit": 1,
        //                 "minVol": 1,
        //                 "maxVol": 1000000,
        //                 "bidLimitPriceRate": 0.1,
        //                 "askLimitPriceRate": 0.1,
        //                 "takerFeeRate": 0.0006,
        //                 "makerFeeRate": 0.0002,
        //                 "maintenanceMarginRate": 0.004,
        //                 "initialMarginRate": 0.008,
        //                 "riskBaseVol": 10000,
        //                 "riskIncrVol": 200000,
        //                 "riskIncrMmr": 0.004,
        //                 "riskIncrImr": 0.004,
        //                 "riskLevelLimit": 5,
        //                 "priceCoefficientVariation": 0.1,
        //                 "indexOrigin": ["BINANCE","GATEIO","HUOBI","MXC"],
        //                 "state": 0, // 0 enabled, 1 delivery, 2 completed, 3 offline, 4 pause
        //                 "isNew": false,
        //                 "isHot": true,
        //                 "isHidden": false
        //             },
        //             ...
        //         ]
        //     }
        //
        object data = this.safeList(response, "data");
        return this.parseLeverageTiers(data, symbols, "symbol");
    }

    public override object parseMarketLeverageTiers(object info, object market = null)
    {
        //
        //    {
        //        "symbol": "BTC_USDT",
        //        "displayName": "BTC_USDT",
        //        "displayNameEn": "BTC_USDT SWAP",
        //        "positionOpenType": 3,
        //        "baseCoin": "BTC",
        //        "quoteCoin": "USDT",
        //        "settleCoin": "USDT",
        //        "contractSize": 0.0001,
        //        "minLeverage": 1,
        //        "maxLeverage": 125,
        //        "priceScale": 2,
        //        "volScale": 0,
        //        "amountScale": 4,
        //        "priceUnit": 0.5,
        //        "volUnit": 1,
        //        "minVol": 1,
        //        "maxVol": 1000000,
        //        "bidLimitPriceRate": 0.1,
        //        "askLimitPriceRate": 0.1,
        //        "takerFeeRate": 0.0006,
        //        "makerFeeRate": 0.0002,
        //        "maintenanceMarginRate": 0.004,
        //        "initialMarginRate": 0.008,
        //        "riskBaseVol": 10000,
        //        "riskIncrVol": 200000,
        //        "riskIncrMmr": 0.004,
        //        "riskIncrImr": 0.004,
        //        "riskLevelLimit": 5,
        //        "priceCoefficientVariation": 0.1,
        //        "indexOrigin": ["BINANCE","GATEIO","HUOBI","MXC"],
        //        "state": 0, // 0 enabled, 1 delivery, 2 completed, 3 offline, 4 pause
        //        "isNew": false,
        //        "isHot": true,
        //        "isHidden": false
        //    }
        //
        object marketId = this.safeString(info, "symbol");
        object maintenanceMarginRate = this.safeString(info, "maintenanceMarginRate");
        object initialMarginRate = this.safeString(info, "initialMarginRate");
        object maxVol = this.safeString(info, "maxVol");
        object riskIncrVol = this.safeString(info, "riskIncrVol");
        object riskIncrMmr = this.safeString(info, "riskIncrMmr");
        object riskIncrImr = this.safeString(info, "riskIncrImr");
        object floor = "0";
        object tiers = new List<object>() {};
        object quoteId = this.safeString(info, "quoteCoin");
        if (isTrue(isEqual(riskIncrVol, "0")))
        {
            return new List<object>() {new Dictionary<string, object>() {
    { "tier", 0 },
    { "symbol", this.safeSymbol(marketId, market, null, "contract") },
    { "currency", this.safeCurrencyCode(quoteId) },
    { "minNotional", null },
    { "maxNotional", null },
    { "maintenanceMarginRate", null },
    { "maxLeverage", this.safeNumber(info, "maxLeverage") },
    { "info", info },
}};
        }
        while (Precise.stringLt(floor, maxVol))
        {
            object cap = Precise.stringAdd(floor, riskIncrVol);
            ((IList<object>)tiers).Add(new Dictionary<string, object>() {
                { "tier", this.parseNumber(Precise.stringDiv(cap, riskIncrVol)) },
                { "symbol", this.safeSymbol(marketId, market, null, "contract") },
                { "currency", this.safeCurrencyCode(quoteId) },
                { "minNotional", this.parseNumber(floor) },
                { "maxNotional", this.parseNumber(cap) },
                { "maintenanceMarginRate", this.parseNumber(maintenanceMarginRate) },
                { "maxLeverage", this.parseNumber(Precise.stringDiv("1", initialMarginRate)) },
                { "info", info },
            });
            initialMarginRate = Precise.stringAdd(initialMarginRate, riskIncrImr);
            maintenanceMarginRate = Precise.stringAdd(maintenanceMarginRate, riskIncrMmr);
            floor = cap;
        }
        return tiers;
    }

    public override object parseDepositAddress(object depositAddress, object currency = null)
    {
        //
        //    {
        //        coin: "USDT",
        //        network: "BNB Smart Chain(BEP20)",
        //        address: "0x0d48003e0c27c5de62b97c9b4cdb31fdd29da619",
        //        memo:  null
        //    }
        //
        object address = this.safeString(depositAddress, "address");
        object currencyId = this.safeString(depositAddress, "coin");
        object networkId = this.safeString(depositAddress, "netWork");
        this.checkAddress(address);
        return new Dictionary<string, object>() {
            { "info", depositAddress },
            { "currency", this.safeCurrencyCode(currencyId, currency) },
            { "network", this.networkIdToCode(networkId, currencyId) },
            { "address", address },
            { "tag", this.safeString(depositAddress, "memo") },
        };
    }

    /**
     * @method
     * @name mexc#fetchDepositAddressesByNetwork
     * @description fetch a dictionary of addresses for a currency, indexed by network
     * @see https://mexcdevelop.github.io/apidocs/spot_v3_en/#deposit-address-supporting-network
     * @param {string} code unified currency code of the currency for the deposit address
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a dictionary of [address structures]{@link https://docs.ccxt.com/#/?id=address-structure} indexed by the network
     */
    public async override Task<object> fetchDepositAddressesByNetwork(object code, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "coin", getValue(currency, "id") },
        };
        object networkCode = this.safeString(parameters, "network");
        object networkId = null;
        if (isTrue(!isEqual(networkCode, null)))
        {
            // createDepositAddress and fetchDepositAddress use a different network-id compared to withdraw
            object networkUnified = this.networkIdToCode(networkCode, code);
            object networks = this.safeDict(currency, "networks", new Dictionary<string, object>() {});
            if (isTrue(inOp(networks, networkUnified)))
            {
                object network = this.safeDict(networks, networkUnified, new Dictionary<string, object>() {});
                object networkInfo = this.safeValue(network, "info", new Dictionary<string, object>() {});
                networkId = this.safeString(networkInfo, "network");
            } else
            {
                networkId = this.networkCodeToId(networkCode, code);
            }
        }
        if (isTrue(!isEqual(networkId, null)))
        {
            ((IDictionary<string,object>)request)["network"] = networkId;
        }
        parameters = this.omit(parameters, "network");
        object response = await this.spotPrivateGetCapitalDepositAddress(this.extend(request, parameters));
        //
        //    [
        //        {
        //            coin: "USDT",
        //            network: "BNB Smart Chain(BEP20)",
        //            address: "0x0d48003e0c27c5de62b97c9b4cdb31fdd29da619",
        //            memo:  null
        //        }
        //        ...
        //    ]
        //
        object addressStructures = this.parseDepositAddresses(response, null, false);
        return this.indexBy(addressStructures, "network");
    }

    /**
     * @method
     * @name mexc#createDepositAddress
     * @description create a currency deposit address
     * @see https://mexcdevelop.github.io/apidocs/spot_v3_en/#generate-deposit-address-supporting-network
     * @param {string} code unified currency code of the currency for the deposit address
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.network] the blockchain network name
     * @returns {object} an [address structure]{@link https://docs.ccxt.com/#/?id=address-structure}
     */
    public async override Task<object> createDepositAddress(object code, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "coin", getValue(currency, "id") },
        };
        object networkCode = this.safeString(parameters, "network");
        if (isTrue(isEqual(networkCode, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " createDepositAddress requires a `network` parameter")) ;
        }
        // createDepositAddress and fetchDepositAddress use a different network-id compared to withdraw
        object networkId = null;
        object networkUnified = this.networkIdToCode(networkCode, code);
        object networks = this.safeDict(currency, "networks", new Dictionary<string, object>() {});
        if (isTrue(inOp(networks, networkUnified)))
        {
            object network = this.safeDict(networks, networkUnified, new Dictionary<string, object>() {});
            object networkInfo = this.safeValue(network, "info", new Dictionary<string, object>() {});
            networkId = this.safeString(networkInfo, "network");
        } else
        {
            networkId = this.networkCodeToId(networkCode, code);
        }
        if (isTrue(!isEqual(networkId, null)))
        {
            ((IDictionary<string,object>)request)["network"] = networkId;
        }
        parameters = this.omit(parameters, "network");
        object response = await this.spotPrivatePostCapitalDepositAddress(this.extend(request, parameters));
        //     {
        //        "coin": "EOS",
        //        "network": "EOS",
        //        "address": "zzqqqqqqqqqq",
        //        "memo": "MX10068"
        //     }
        return this.parseDepositAddress(response, currency);
    }

    /**
     * @method
     * @name mexc#fetchDepositAddress
     * @description fetch the deposit address for a currency associated with this account
     * @see https://mexcdevelop.github.io/apidocs/spot_v3_en/#deposit-address-supporting-network
     * @param {string} code unified currency code
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.network] the chain of currency, this only apply for multi-chain currency, and there is no need for single chain currency
     * @returns {object} an [address structure]{@link https://docs.ccxt.com/#/?id=address-structure}
     */
    public async override Task<object> fetchDepositAddress(object code, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object network = this.safeString(parameters, "network");
        object addressStructures = await this.fetchDepositAddressesByNetwork(code, parameters);
        object result = null;
        if (isTrue(!isEqual(network, null)))
        {
            result = this.safeDict(addressStructures, this.networkIdToCode(network, code));
        } else
        {
            object options = this.safeDict(this.options, "defaultNetworks");
            object defaultNetworkForCurrency = this.safeString(options, code);
            if (isTrue(!isEqual(defaultNetworkForCurrency, null)))
            {
                result = this.safeDict(addressStructures, defaultNetworkForCurrency);
            } else
            {
                object keys = new List<object>(((IDictionary<string,object>)addressStructures).Keys);
                object key = this.safeString(keys, 0);
                result = this.safeDict(addressStructures, key);
            }
        }
        if (isTrue(isEqual(result, null)))
        {
            throw new InvalidAddress ((string)add(add(add(add(add(this.id, " fetchDepositAddress() cannot find a deposit address for "), code), ", and network"), network), "consider creating one using .createDepositAddress() method or in MEXC website")) ;
        }
        return result;
    }

    /**
     * @method
     * @name mexc#fetchDeposits
     * @description fetch all deposits made to an account
     * @see https://mexcdevelop.github.io/apidocs/spot_v3_en/#deposit-history-supporting-network
     * @param {string} code unified currency code
     * @param {int} [since] the earliest time in ms to fetch deposits for
     * @param {int} [limit] the maximum number of deposits structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
     */
    public async override Task<object> fetchDeposits(object code = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object currency = null;
        if (isTrue(!isEqual(code, null)))
        {
            currency = this.currency(code);
            ((IDictionary<string,object>)request)["coin"] = getValue(currency, "id");
            // currently mexc does not have network names unified so for certain things we might need TRX or TRC-20
            // due to that I'm applying the network parameter directly so the user can control it on its side
            object rawNetwork = this.safeString(parameters, "network");
            if (isTrue(!isEqual(rawNetwork, null)))
            {
                parameters = this.omit(parameters, "network");
                ((IDictionary<string,object>)request)["coin"] = add(add(getValue(request, "coin"), "-"), rawNetwork);
            }
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["startTime"] = since;
        }
        if (isTrue(!isEqual(limit, null)))
        {
            if (isTrue(isGreaterThan(limit, 1000)))
            {
                throw new ExchangeError ((string)"This exchange supports a maximum limit of 1000") ;
            }
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        object response = await this.spotPrivateGetCapitalDepositHisrec(this.extend(request, parameters));
        //
        // [
        //     {
        //         "amount": "10",
        //         "coin": "USDC-TRX",
        //         "network": "TRX",
        //         "status": "5",
        //         "address": "TSMcEDDvkqY9dz8RkFnrS86U59GwEZjfvh",
        //         "txId": "51a8f49e6f03f2c056e71fe3291aa65e1032880be855b65cecd0595a1b8af95b:0",
        //         "insertTime": "1664805021000",
        //         "unlockConfirm": "200",
        //         "confirmTimes": "203",
        //         "memo": "xxyy1122",
        //         "transHash": "51a8f49e6f03f2c056e71fe3291aa65e1032880be855b65cecd0595a1b8af95b",
        //         "updateTime": "1664805621000",
        //         "netWork: "TRX"
        //     }
        // ]
        //
        return this.parseTransactions(response, currency, since, limit);
    }

    /**
     * @method
     * @name mexc#fetchWithdrawals
     * @description fetch all withdrawals made from an account
     * @see https://mexcdevelop.github.io/apidocs/spot_v3_en/#withdraw-history-supporting-network
     * @param {string} code unified currency code
     * @param {int} [since] the earliest time in ms to fetch withdrawals for
     * @param {int} [limit] the maximum number of withdrawals structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
     */
    public async override Task<object> fetchWithdrawals(object code = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object currency = null;
        if (isTrue(!isEqual(code, null)))
        {
            currency = this.currency(code);
            ((IDictionary<string,object>)request)["coin"] = getValue(currency, "id");
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["startTime"] = since;
        }
        if (isTrue(!isEqual(limit, null)))
        {
            if (isTrue(isGreaterThan(limit, 1000)))
            {
                throw new ExchangeError ((string)"This exchange supports a maximum limit of 1000") ;
            }
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        object response = await this.spotPrivateGetCapitalWithdrawHistory(this.extend(request, parameters));
        //
        // [
        //     {
        //       "id": "adcd1c8322154de691b815eedcd10c42",
        //       "txId": "0xc8c918cd69b2246db493ef6225a72ffdc664f15b08da3e25c6879b271d05e9d0:0",
        //       "coin": "USDC-MATIC",
        //       "network": "MATIC",
        //       "address": "0xeE6C7a415995312ED52c53a0f8f03e165e0A5D62",
        //       "amount": "2",
        //       "transferType": "0",
        //       "status": "7",
        //       "transactionFee": "1",
        //       "confirmNo": null,
        //       "applyTime": "1664882739000",
        //       "remark": '',
        //       "memo": null,
        //       "explorerUrl": "https://etherscan.io/tx/0xc8c918cd69b2246db493ef6225a72ffdc664f15b08da3e25c6879b271d05e9d0",
        //       "transHash": "0xc8c918cd69b2246db493ef6225a72ffdc664f15b08da3e25c6879b271d05e9d0",
        //       "updateTime": "1664882799000",
        //       "netWork: "MATIC"
        //     }
        // ]
        //
        return this.parseTransactions(response, currency, since, limit);
    }

    public override object parseTransaction(object transaction, object currency = null)
    {
        //
        // fetchDeposits
        //
        // {
        //     "amount": "10",
        //     "coin": "USDC-TRX",
        //     "network": "TRX",
        //     "status": "5",
        //     "address": "TSMcEDDvkqY9dz8RkFnrS86U59GwEZjfvh",
        //     "txId": "51a8f49e6f03f2c056e71fe3291aa65e1032880be855b65cecd0595a1b8af95b:0",
        //     "insertTime": "1664805021000",
        //     "unlockConfirm": "200",
        //     "confirmTimes": "203",
        //     "memo": "xxyy1122",
        //     "transHash": "51a8f49e6f03f2c056e71fe3291aa65e1032880be855b65cecd0595a1b8af95b",
        //     "updateTime": "1664805621000",
        //     "netWork: "TRX"
        // }
        //
        // fetchWithdrawals
        //
        // {
        //     "id": "adcd1c8322154de691b815eedcd10c42",
        //     "txId": "0xc8c918cd69b2246db493ef6225a72ffdc664f15b08da3e25c6879b271d05e9d0:0",
        //     "coin": "USDC-MATIC",
        //     "network": "MATIC",
        //     "address": "0xeE6C7a415995312ED52c53a0f8f03e165e0A5D62",
        //     "amount": "2",
        //     "transferType": "0",
        //     "status": "7",
        //     "transactionFee": "1",
        //     "confirmNo": null,
        //     "applyTime": "1664882739000",
        //     "remark": "",
        //     "memo": null,
        //     "explorerUrl": "https://etherscan.io/tx/0xc8c918cd69b2246db493ef6225a72ffdc664f15b08da3e25c6879b271d05e9d0",
        //     "transHash": "0xc8c918cd69b2246db493ef6225a72ffdc664f15b08da3e25c6879b271d05e9d0",
        //     "updateTime": "1664882799000",
        //     "netWork: "MATIC"
        //   }
        //
        // withdraw
        //
        //     {
        //         "id":"25fb2831fb6d4fc7aa4094612a26c81d"
        //     }
        //
        // internal withdraw (aka internal-transfer)
        //
        //     {
        //         "tranId":"ad36f0e9c9a24ae794b36fa4f152e471"
        //     }
        //
        object id = this.safeString2(transaction, "id", "tranId");
        object type = ((bool) isTrue((isEqual(id, null)))) ? "deposit" : "withdrawal";
        object timestamp = this.safeInteger2(transaction, "insertTime", "applyTime");
        object updated = this.safeInteger(transaction, "updateTime");
        object currencyId = null;
        object currencyWithNetwork = this.safeString(transaction, "coin");
        if (isTrue(!isEqual(currencyWithNetwork, null)))
        {
            currencyId = getValue(((string)currencyWithNetwork).Split(new [] {((string)"-")}, StringSplitOptions.None).ToList<object>(), 0);
        }
        object network = null;
        object rawNetwork = this.safeString(transaction, "network");
        if (isTrue(!isEqual(rawNetwork, null)))
        {
            network = this.networkIdToCode(rawNetwork);
        }
        object code = this.safeCurrencyCode(currencyId, currency);
        object status = this.parseTransactionStatusByType(this.safeString(transaction, "status"), type);
        object amountString = this.safeString(transaction, "amount");
        object address = this.safeString(transaction, "address");
        object txid = this.safeString2(transaction, "transHash", "txId");
        object fee = null;
        object feeCostString = this.safeString(transaction, "transactionFee");
        if (isTrue(!isEqual(feeCostString, null)))
        {
            fee = new Dictionary<string, object>() {
                { "cost", this.parseNumber(feeCostString) },
                { "currency", code },
            };
        }
        if (isTrue(isEqual(type, "withdrawal")))
        {
            // mexc withdrawal amount includes the fee
            amountString = Precise.stringSub(amountString, feeCostString);
        }
        return new Dictionary<string, object>() {
            { "info", transaction },
            { "id", id },
            { "txid", txid },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "network", network },
            { "address", address },
            { "addressTo", address },
            { "addressFrom", null },
            { "tag", this.safeString(transaction, "memo") },
            { "tagTo", null },
            { "tagFrom", null },
            { "type", type },
            { "amount", this.parseNumber(amountString) },
            { "currency", code },
            { "status", status },
            { "updated", updated },
            { "comment", this.safeString(transaction, "remark") },
            { "internal", null },
            { "fee", fee },
        };
    }

    public virtual object parseTransactionStatusByType(object status, object type = null)
    {
        object statusesByType = new Dictionary<string, object>() {
            { "deposit", new Dictionary<string, object>() {
                { "1", "failed" },
                { "2", "pending" },
                { "3", "pending" },
                { "4", "pending" },
                { "5", "ok" },
                { "6", "pending" },
                { "7", "failed" },
            } },
            { "withdrawal", new Dictionary<string, object>() {
                { "1", "pending" },
                { "2", "pending" },
                { "3", "pending" },
                { "4", "pending" },
                { "5", "pending" },
                { "6", "pending" },
                { "7", "ok" },
                { "8", "failed" },
                { "9", "canceled" },
                { "10", "pending" },
            } },
        };
        object statuses = this.safeValue(statusesByType, type, new Dictionary<string, object>() {});
        return this.safeString(statuses, status, status);
    }

    /**
     * @method
     * @name mexc#fetchPosition
     * @description fetch data on a single open contract trade position
     * @see https://mexcdevelop.github.io/apidocs/contract_v1_en/#get-the-user-s-history-position-information
     * @param {string} symbol unified market symbol of the market the position is held in, default is undefined
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [position structure]{@link https://docs.ccxt.com/#/?id=position-structure}
     */
    public async override Task<object> fetchPosition(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object response = await this.fetchPositions(null, this.extend(request, parameters));
        return this.safeValue(response, 0);
    }

    /**
     * @method
     * @name mexc#fetchPositions
     * @description fetch all open positions
     * @see https://mexcdevelop.github.io/apidocs/contract_v1_en/#get-the-user-s-history-position-information
     * @param {string[]|undefined} symbols list of unified market symbols
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} a list of [position structure]{@link https://docs.ccxt.com/#/?id=position-structure}
     */
    public async override Task<object> fetchPositions(object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.contractPrivateGetPositionOpenPositions(parameters);
        //
        //     {
        //         "success": true,
        //         "code": 0,
        //         "data": [
        //             {
        //                 "positionId": 1394650,
        //                 "symbol": "ETH_USDT",
        //                 "positionType": 1,
        //                 "openType": 1,
        //                 "state": 1,
        //                 "holdVol": 1,
        //                 "frozenVol": 0,
        //                 "closeVol": 0,
        //                 "holdAvgPrice": 1217.3,
        //                 "openAvgPrice": 1217.3,
        //                 "closeAvgPrice": 0,
        //                 "liquidatePrice": 1211.2,
        //                 "oim": 0.1290338,
        //                 "im": 0.1290338,
        //                 "holdFee": 0,
        //                 "realised": -0.0073,
        //                 "leverage": 100,
        //                 "createTime": 1609991676000,
        //                 "updateTime": 1609991676000,
        //                 "autoAddIm": false
        //             }
        //         ]
        //     }
        //
        object data = this.safeList(response, "data", new List<object>() {});
        return this.parsePositions(data, symbols);
    }

    public override object parsePosition(object position, object market = null)
    {
        //
        // fetchPositions
        //
        //     {
        //         "positionId": 1394650,
        //         "symbol": "ETH_USDT",
        //         "positionType": 1,
        //         "openType": 1,
        //         "state": 1,
        //         "holdVol": 1,
        //         "frozenVol": 0,
        //         "closeVol": 0,
        //         "holdAvgPrice": 1217.3,
        //         "openAvgPrice": 1217.3,
        //         "closeAvgPrice": 0,
        //         "liquidatePrice": 1211.2,
        //         "oim": 0.1290338,
        //         "im": 0.1290338,
        //         "holdFee": 0,
        //         "realised": -0.0073,
        //         "leverage": 100,
        //         "createTime": 1609991676000,
        //         "updateTime": 1609991676000,
        //         "autoAddIm": false
        //     }
        //
        // fetchPositionsHistory
        //
        //    {
        //        positionId: '390281084',
        //        symbol: 'RVN_USDT',
        //        positionType: '1',
        //        openType: '2',
        //        state: '3',
        //        holdVol: '0',
        //        frozenVol: '0',
        //        closeVol: '1141',
        //        holdAvgPrice: '0.03491',
        //        holdAvgPriceFullyScale: '0.03491',
        //        openAvgPrice: '0.03491',
        //        openAvgPriceFullyScale: '0.03491',
        //        closeAvgPrice: '0.03494',
        //        liquidatePrice: '0.03433',
        //        oim: '0',
        //        im: '0',
        //        holdFee: '0',
        //        realised: '0.1829',
        //        leverage: '50',
        //        createTime: '1711512408000',
        //        updateTime: '1711512553000',
        //        autoAddIm: false,
        //        version: '4',
        //        profitRatio: '0.0227',
        //        newOpenAvgPrice: '0.03491',
        //        newCloseAvgPrice: '0.03494',
        //        closeProfitLoss: '0.3423',
        //        fee: '0.1593977',
        //        positionShowStatus: 'CLOSED'
        //    }
        //
        market = this.safeMarket(this.safeString(position, "symbol"), market, null, "swap");
        object symbol = getValue(market, "symbol");
        object contracts = this.safeString(position, "holdVol");
        object entryPrice = this.safeNumber(position, "openAvgPrice");
        object initialMargin = this.safeString(position, "im");
        object rawSide = this.safeString(position, "positionType");
        object side = ((bool) isTrue((isEqual(rawSide, "1")))) ? "long" : "short";
        object openType = this.safeString(position, "margin_mode");
        object marginType = ((bool) isTrue((isEqual(openType, "1")))) ? "isolated" : "cross";
        object leverage = this.safeNumber(position, "leverage");
        object liquidationPrice = this.safeNumber(position, "liquidatePrice");
        object timestamp = this.safeInteger(position, "updateTime");
        return this.safePosition(new Dictionary<string, object>() {
            { "info", position },
            { "id", null },
            { "symbol", symbol },
            { "contracts", this.parseNumber(contracts) },
            { "contractSize", null },
            { "entryPrice", entryPrice },
            { "collateral", null },
            { "side", side },
            { "unrealizedPnl", null },
            { "leverage", this.parseNumber(leverage) },
            { "percentage", null },
            { "marginMode", marginType },
            { "notional", null },
            { "markPrice", null },
            { "lastPrice", null },
            { "liquidationPrice", liquidationPrice },
            { "initialMargin", this.parseNumber(initialMargin) },
            { "initialMarginPercentage", null },
            { "maintenanceMargin", null },
            { "maintenanceMarginPercentage", null },
            { "marginRatio", null },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "hedged", null },
            { "stopLossPrice", null },
            { "takeProfitPrice", null },
            { "lastUpdateTimestamp", null },
        });
    }

    /**
     * @method
     * @name mexc#fetchTransfer
     * @description fetches a transfer
     * @see https://mexcdevelop.github.io/apidocs/spot_v2_en/#internal-assets-transfer-order-inquiry
     * @param {string} id transfer id
     * @param {string} [code] not used by mexc fetchTransfer
     * @param {object} params extra parameters specific to the exchange api endpoint
     * @returns {object} a [transfer structure]{@link https://docs.ccxt.com/#/?id=transfer-structure}
     */
    public async override Task<object> fetchTransfer(object id, object code = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        var marketTypequeryVariable = this.handleMarketTypeAndParams("fetchTransfer", null, parameters);
        var marketType = ((IList<object>) marketTypequeryVariable)[0];
        var query = ((IList<object>) marketTypequeryVariable)[1];
        await this.loadMarkets();
        if (isTrue(isEqual(marketType, "spot")))
        {
            object request = new Dictionary<string, object>() {
                { "transact_id", id },
            };
            object response = await this.spot2PrivateGetAssetInternalTransferInfo(this.extend(request, query));
            //
            //     {
            //         "code": "200",
            //         "data": {
            //             "currency": "USDT",
            //             "amount": "1",
            //             "transact_id": "954877a2ef54499db9b28a7cf9ebcf41",
            //             "from": "MAIN",
            //             "to": "CONTRACT",
            //             "transact_state": "SUCCESS"
            //         }
            //     }
            //
            object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
            return this.parseTransfer(data);
        } else if (isTrue(isEqual(marketType, "swap")))
        {
            throw new BadRequest ((string)add(add(this.id, " fetchTransfer() is not supported for "), marketType)) ;
        }
        return null;
    }

    /**
     * @method
     * @name mexc#fetchTransfers
     * @description fetch a history of internal transfers made on an account
     * @see https://mexcdevelop.github.io/apidocs/spot_v2_en/#get-internal-assets-transfer-records
     * @see https://mexcdevelop.github.io/apidocs/contract_v1_en/#get-the-user-39-s-asset-transfer-records
     * @param {string} code unified currency code of the currency transferred
     * @param {int} [since] the earliest time in ms to fetch transfers for
     * @param {int} [limit] the maximum number of  transfers structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} a list of [transfer structures]{@link https://docs.ccxt.com/#/?id=transfer-structure}
     */
    public async override Task<object> fetchTransfers(object code = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        var marketTypequeryVariable = this.handleMarketTypeAndParams("fetchTransfers", null, parameters);
        var marketType = ((IList<object>) marketTypequeryVariable)[0];
        var query = ((IList<object>) marketTypequeryVariable)[1];
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object currency = null;
        object resultList = null;
        if (isTrue(!isEqual(code, null)))
        {
            currency = this.currency(code);
            ((IDictionary<string,object>)request)["currency"] = getValue(currency, "id");
        }
        if (isTrue(isEqual(marketType, "spot")))
        {
            if (isTrue(!isEqual(since, null)))
            {
                ((IDictionary<string,object>)request)["start_time"] = since;
            }
            if (isTrue(!isEqual(limit, null)))
            {
                if (isTrue(isGreaterThan(limit, 50)))
                {
                    throw new ExchangeError ((string)"This exchange supports a maximum limit of 50") ;
                }
                ((IDictionary<string,object>)request)["page-size"] = limit;
            }
            object response = await this.spot2PrivateGetAssetInternalTransferRecord(this.extend(request, query));
            //
            //     {
            //         "code": "200",
            //         "data": {
            //             "total_page": "1",
            //             "total_size": "5",
            //             "result_list": [{
            //                     "currency": "USDT",
            //                     "amount": "1",
            //                     "transact_id": "954877a2ef54499db9b28a7cf9ebcf41",
            //                     "from": "MAIN",
            //                     "to": "CONTRACT",
            //                     "transact_state": "SUCCESS"
            //                 },
            //                 ...
            //             ]
            //         }
            //     }
            //
            object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
            resultList = this.safeValue(data, "result_list", new List<object>() {});
        } else if (isTrue(isEqual(marketType, "swap")))
        {
            if (isTrue(!isEqual(limit, null)))
            {
                ((IDictionary<string,object>)request)["page_size"] = limit;
            }
            object response = await this.contractPrivateGetAccountTransferRecord(this.extend(request, query));
            object data = this.safeValue(response, "data");
            resultList = this.safeValue(data, "resultList");
        }
        return this.parseTransfers(resultList, currency, since, limit);
    }

    /**
     * @method
     * @name mexc#transfer
     * @description transfer currency internally between wallets on the same account
     * @see https://mexcdevelop.github.io/apidocs/spot_v3_en/#user-universal-transfer
     * @param {string} code unified currency code
     * @param {float} amount amount to transfer
     * @param {string} fromAccount account to transfer from
     * @param {string} toAccount account to transfer to
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.symbol] market symbol required for margin account transfers eg:BTCUSDT
     * @returns {object} a [transfer structure]{@link https://docs.ccxt.com/#/?id=transfer-structure}
     */
    public async override Task<object> transfer(object code, object amount, object fromAccount, object toAccount, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        object accounts = new Dictionary<string, object>() {
            { "spot", "SPOT" },
            { "swap", "FUTURES" },
            { "margin", "ISOLATED_MARGIN" },
        };
        object fromId = this.safeString(accounts, fromAccount);
        object toId = this.safeString(accounts, toAccount);
        if (isTrue(isEqual(fromId, null)))
        {
            object keys = new List<object>(((IDictionary<string,object>)accounts).Keys);
            throw new ExchangeError ((string)add(add(this.id, " fromAccount must be one of "), String.Join(", ", ((IList<object>)keys).ToArray()))) ;
        }
        if (isTrue(isEqual(toId, null)))
        {
            object keys = new List<object>(((IDictionary<string,object>)accounts).Keys);
            throw new ExchangeError ((string)add(add(this.id, " toAccount must be one of "), String.Join(", ", ((IList<object>)keys).ToArray()))) ;
        }
        object request = new Dictionary<string, object>() {
            { "asset", getValue(currency, "id") },
            { "amount", amount },
            { "fromAccountType", fromId },
            { "toAccountType", toId },
        };
        if (isTrue(isTrue((isEqual(fromId, "ISOLATED_MARGIN"))) || isTrue((isEqual(toId, "ISOLATED_MARGIN")))))
        {
            object symbol = this.safeString(parameters, "symbol");
            parameters = this.omit(parameters, "symbol");
            if (isTrue(isEqual(symbol, null)))
            {
                throw new ArgumentsRequired ((string)add(this.id, " transfer() requires a symbol argument for isolated margin")) ;
            }
            object market = this.market(symbol);
            ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
        }
        object response = await this.spotPrivatePostCapitalTransfer(this.extend(request, parameters));
        //
        //     {
        //         "tranId": "ebb06123e6a64f4ab234b396c548d57e"
        //     }
        //
        object transaction = this.parseTransfer(response, currency);
        return this.extend(transaction, new Dictionary<string, object>() {
            { "amount", amount },
            { "fromAccount", fromAccount },
            { "toAccount", toAccount },
        });
    }

    public override object parseTransfer(object transfer, object currency = null)
    {
        //
        // spot: fetchTransfer
        //
        //     {
        //         "currency": "USDT",
        //         "amount": "1",
        //         "transact_id": "b60c1df8e7b24b268858003f374ecb75",
        //         "from": "MAIN",
        //         "to": "CONTRACT",
        //         "transact_state": "WAIT"
        //     }
        //
        // swap: fetchTransfer
        //
        //     {
        //         "currency": "USDT",
        //         "amount": "22.90213135",
        //         "txid": "fa8a1e7bf05940a3b7025856dc48d025",
        //         "id": "2980812",
        //         "type": "IN",
        //         "state": "SUCCESS",
        //         "createTime": "1648849076000",
        //         "updateTime": "1648849076000"
        //     }
        //
        // transfer
        //
        //     {
        //         "tranId": "ebb06123e6a64f4ab234b396c548d57e"
        //     }
        //
        object currencyId = this.safeString(transfer, "currency");
        object id = this.safeStringN(transfer, new List<object>() {"transact_id", "txid", "tranId"});
        object timestamp = this.safeInteger(transfer, "createTime");
        object datetime = ((bool) isTrue((!isEqual(timestamp, null)))) ? this.iso8601(timestamp) : null;
        object direction = this.safeString(transfer, "type");
        object accountFrom = null;
        object accountTo = null;
        if (isTrue(!isEqual(direction, null)))
        {
            accountFrom = ((bool) isTrue((isEqual(direction, "IN")))) ? "MAIN" : "CONTRACT";
            accountTo = ((bool) isTrue((isEqual(direction, "IN")))) ? "CONTRACT" : "MAIN";
        } else
        {
            accountFrom = this.safeString(transfer, "from");
            accountTo = this.safeString(transfer, "to");
        }
        return new Dictionary<string, object>() {
            { "info", transfer },
            { "id", id },
            { "timestamp", timestamp },
            { "datetime", datetime },
            { "currency", this.safeCurrencyCode(currencyId, currency) },
            { "amount", this.safeNumber(transfer, "amount") },
            { "fromAccount", this.parseAccountId(accountFrom) },
            { "toAccount", this.parseAccountId(accountTo) },
            { "status", this.parseTransferStatus(this.safeString2(transfer, "transact_state", "state")) },
        };
    }

    public virtual object parseAccountId(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "MAIN", "spot" },
            { "CONTRACT", "swap" },
        };
        return this.safeString(statuses, status, status);
    }

    public virtual object parseTransferStatus(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "SUCCESS", "ok" },
            { "FAILED", "failed" },
            { "WAIT", "pending" },
        };
        return this.safeString(statuses, status, status);
    }

    /**
     * @method
     * @name mexc#withdraw
     * @description make a withdrawal
     * @see https://mexcdevelop.github.io/apidocs/spot_v3_en/#withdraw-new
     * @see https://www.mexc.com/api-docs/spot-v3/wallet-endpoints#internal-transfer
     * @param {string} code unified currency code
     * @param {float} amount the amount to withdraw
     * @param {string} address the address to withdraw to
     * @param {string} tag
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {object} [params.internal] false by default, set to true for an "internal transfer"
     * @param {object} [params.toAccountType] skipped by default, set to 'EMAIL|UID|MOBILE' when making an "internal transfer"
     * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
     */
    public async override Task<object> withdraw(object code, object amount, object address, object tag = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        var tagparametersVariable = this.handleWithdrawTagAndParams(tag, parameters);
        tag = ((IList<object>)tagparametersVariable)[0];
        parameters = ((IList<object>)tagparametersVariable)[1];
        object intern = this.safeBool(parameters, "internal", false);
        if (isTrue(intern))
        {
            parameters = this.omit(parameters, "internal");
            object requestForInternal = new Dictionary<string, object>() {
                { "asset", getValue(currency, "id") },
                { "amount", amount },
                { "toAccount", address },
            };
            object toAccountType = this.safeString(parameters, "toAccountType");
            if (isTrue(isEqual(toAccountType, null)))
            {
                throw new ArgumentsRequired ((string)add(this.id, " withdraw() requires a toAccountType parameter for internal transfer to be of: EMAIL | UID | MOBILE")) ;
            }
            object responseForInternal = await this.spotPrivatePostCapitalTransferInternal(this.extend(requestForInternal, parameters));
            //
            //     {
            //       "id":"7213fea8e94b4a5593d507237e5a555b"
            //     }
            //
            return this.parseTransaction(responseForInternal, currency);
        }
        object networks = this.safeDict(this.options, "networks", new Dictionary<string, object>() {});
        object network = this.safeString2(parameters, "network", "netWork"); // this line allows the user to specify either ERC20 or ETH
        network = this.safeString(networks, network, network); // handle ETH > ERC-20 alias
        network = this.networkCodeToId(network, getValue(currency, "code"));
        this.checkAddress(address);
        object request = new Dictionary<string, object>() {
            { "coin", getValue(currency, "id") },
            { "address", address },
            { "amount", amount },
        };
        if (isTrue(!isEqual(tag, null)))
        {
            ((IDictionary<string,object>)request)["memo"] = tag;
        }
        if (isTrue(!isEqual(network, null)))
        {
            ((IDictionary<string,object>)request)["netWork"] = network;
            parameters = this.omit(parameters, new List<object>() {"network", "netWork"});
        }
        object response = await this.spotPrivatePostCapitalWithdraw(this.extend(request, parameters));
        //
        //     {
        //       "id":"7213fea8e94b4a5593d507237e5a555b"
        //     }
        //
        return this.parseTransaction(response, currency);
    }

    /**
     * @method
     * @name mexc#setPositionMode
     * @description set hedged to true or false for a market
     * @see https://mexcdevelop.github.io/apidocs/contract_v1_en/#change-position-mode
     * @param {bool} hedged set to true to use dualSidePosition
     * @param {string} symbol not used by mexc setPositionMode ()
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} response from the exchange
     */
    public async override Task<object> setPositionMode(object hedged, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object request = new Dictionary<string, object>() {
            { "positionMode", ((bool) isTrue(hedged)) ? 1 : 2 },
        };
        object response = await this.contractPrivatePostPositionChangePositionMode(this.extend(request, parameters));
        //
        //     {
        //         "success":true,
        //         "code":0
        //     }
        //
        return response;
    }

    /**
     * @method
     * @name mexc#fetchPositionMode
     * @description fetchs the position mode, hedged or one way, hedged for binance is set identically for all linear markets or all inverse markets
     * @see https://mexcdevelop.github.io/apidocs/contract_v1_en/#get-position-mode
     * @param {string} symbol not used by mexc fetchPositionMode
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} an object detailing whether the market is in hedged or one-way mode
     */
    public async override Task<object> fetchPositionMode(object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object response = await this.contractPrivateGetPositionPositionMode(parameters);
        //
        //     {
        //         "success":true,
        //         "code":0,
        //         "data":2
        //     }
        //
        object positionMode = this.safeInteger(response, "data");
        return new Dictionary<string, object>() {
            { "info", response },
            { "hedged", (isEqual(positionMode, 1)) },
        };
    }

    /**
     * @method
     * @name mexc#fetchTransactionFees
     * @description fetch deposit and withdrawal fees
     * @see https://mexcdevelop.github.io/apidocs/spot_v3_en/#query-the-currency-information
     * @param {string[]|undefined} codes returns fees for all currencies if undefined
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} a list of [fee structures]{@link https://docs.ccxt.com/#/?id=fee-structure}
     */
    public async override Task<object> fetchTransactionFees(object codes = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.spotPrivateGetCapitalConfigGetall(parameters);
        //
        //    [
        //       {
        //           "coin": "AGLD",
        //           "name": "Adventure Gold",
        //           "networkList": [
        //               {
        //                   "coin": "AGLD",
        //                   "depositDesc": null,
        //                   "depositEnable": true,
        //                   "minConfirm": "0",
        //                   "name": "Adventure Gold",
        //                   "network": "ERC20",
        //                   "withdrawEnable": true,
        //                   "withdrawFee": "10.000000000000000000",
        //                   "withdrawIntegerMultiple": null,
        //                   "withdrawMax": "1200000.000000000000000000",
        //                   "withdrawMin": "20.000000000000000000",
        //                   "sameAddress": false,
        //                   "contract": "0x32353a6c91143bfd6c7d363b546e62a9a2489a20",
        //                   "withdrawTips": null,
        //                   "depositTips": null
        //               }
        //               ...
        //           ]
        //       },
        //       ...
        //    ]
        //
        return this.parseTransactionFees(response, codes);
    }

    public virtual object parseTransactionFees(object response, object codes = null)
    {
        object withdrawFees = new Dictionary<string, object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(response)); postFixIncrement(ref i))
        {
            object entry = getValue(response, i);
            object currencyId = this.safeString(entry, "coin");
            object currency = this.safeCurrency(currencyId);
            object code = this.safeString(currency, "code");
            if (isTrue(isTrue((isEqual(codes, null))) || isTrue((this.inArray(code, codes)))))
            {
                ((IDictionary<string,object>)withdrawFees)[(string)code] = this.parseTransactionFee(entry, currency);
            }
        }
        return new Dictionary<string, object>() {
            { "withdraw", withdrawFees },
            { "deposit", new Dictionary<string, object>() {} },
            { "info", response },
        };
    }

    public virtual object parseTransactionFee(object transaction, object currency = null)
    {
        //
        //    {
        //        "coin": "AGLD",
        //        "name": "Adventure Gold",
        //        "networkList": [
        //            {
        //                "coin": "AGLD",
        //                "depositDesc": null,
        //                "depositEnable": true,
        //                "minConfirm": "0",
        //                "name": "Adventure Gold",
        //                "network": "ERC20",
        //                "withdrawEnable": true,
        //                "withdrawFee": "10.000000000000000000",
        //                "withdrawIntegerMultiple": null,
        //                "withdrawMax": "1200000.000000000000000000",
        //                "withdrawMin": "20.000000000000000000",
        //                "sameAddress": false,
        //                "contract": "0x32353a6c91143bfd6c7d363b546e62a9a2489a20",
        //                "withdrawTips": null,
        //                "depositTips": null
        //            }
        //            ...
        //        ]
        //    }
        //
        object networkList = this.safeValue(transaction, "networkList", new List<object>() {});
        object result = new Dictionary<string, object>() {};
        for (object j = 0; isLessThan(j, getArrayLength(networkList)); postFixIncrement(ref j))
        {
            object networkEntry = getValue(networkList, j);
            object networkId = this.safeString(networkEntry, "network");
            object networkCode = this.safeString(getValue(this.options, "networks"), networkId, networkId);
            object fee = this.safeNumber(networkEntry, "withdrawFee");
            ((IDictionary<string,object>)result)[(string)networkCode] = fee;
        }
        return result;
    }

    /**
     * @method
     * @name mexc#fetchDepositWithdrawFees
     * @description fetch deposit and withdrawal fees
     * @see https://mexcdevelop.github.io/apidocs/spot_v3_en/#query-the-currency-information
     * @param {string[]|undefined} codes returns fees for all currencies if undefined
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} a list of [fee structures]{@link https://docs.ccxt.com/#/?id=fee-structure}
     */
    public async override Task<object> fetchDepositWithdrawFees(object codes = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.spotPrivateGetCapitalConfigGetall(parameters);
        //
        //    [
        //       {
        //           "coin": "AGLD",
        //           "name": "Adventure Gold",
        //           "networkList": [
        //               {
        //                   "coin": "AGLD",
        //                   "depositDesc": null,
        //                   "depositEnable": true,
        //                   "minConfirm": "0",
        //                   "name": "Adventure Gold",
        //                   "network": "ERC20",
        //                   "withdrawEnable": true,
        //                   "withdrawFee": "10.000000000000000000",
        //                   "withdrawIntegerMultiple": null,
        //                   "withdrawMax": "1200000.000000000000000000",
        //                   "withdrawMin": "20.000000000000000000",
        //                   "sameAddress": false,
        //                   "contract": "0x32353a6c91143bfd6c7d363b546e62a9a2489a20",
        //                   "withdrawTips": null,
        //                   "depositTips": null
        //               }
        //               ...
        //           ]
        //       },
        //       ...
        //    ]
        //
        return this.parseDepositWithdrawFees(response, codes, "coin");
    }

    public override object parseDepositWithdrawFee(object fee, object currency = null)
    {
        //
        //    {
        //        "coin": "AGLD",
        //        "name": "Adventure Gold",
        //        "networkList": [
        //            {
        //                "coin": "AGLD",
        //                "depositDesc": null,
        //                "depositEnable": true,
        //                "minConfirm": "0",
        //                "name": "Adventure Gold",
        //                "network": "ERC20",
        //                "withdrawEnable": true,
        //                "withdrawFee": "10.000000000000000000",
        //                "withdrawIntegerMultiple": null,
        //                "withdrawMax": "1200000.000000000000000000",
        //                "withdrawMin": "20.000000000000000000",
        //                "sameAddress": false,
        //                "contract": "0x32353a6c91143bfd6c7d363b546e62a9a2489a20",
        //                "withdrawTips": null,
        //                "depositTips": null
        //            }
        //            ...
        //        ]
        //    }
        //
        object networkList = this.safeValue(fee, "networkList", new List<object>() {});
        object result = this.depositWithdrawFee(fee);
        for (object j = 0; isLessThan(j, getArrayLength(networkList)); postFixIncrement(ref j))
        {
            object networkEntry = getValue(networkList, j);
            object networkId = this.safeString(networkEntry, "network");
            object networkCode = this.networkIdToCode(networkId, this.safeString(currency, "code"));
            ((IDictionary<string,object>)getValue(result, "networks"))[(string)networkCode] = new Dictionary<string, object>() {
                { "withdraw", new Dictionary<string, object>() {
                    { "fee", this.safeNumber(networkEntry, "withdrawFee") },
                    { "percentage", null },
                } },
                { "deposit", new Dictionary<string, object>() {
                    { "fee", null },
                    { "percentage", null },
                } },
            };
        }
        return this.assignDefaultDepositWithdrawFees(result);
    }

    /**
     * @method
     * @name mexc#fetchLeverage
     * @description fetch the set leverage for a market
     * @see https://mexcdevelop.github.io/apidocs/contract_v1_en/#get-leverage
     * @param {string} symbol unified market symbol
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [leverage structure]{@link https://docs.ccxt.com/#/?id=leverage-structure}
     */
    public async override Task<object> fetchLeverage(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object response = await this.contractPrivateGetPositionLeverage(this.extend(request, parameters));
        //
        //     {
        //         "success": true,
        //         "code": 0,
        //         "data": [
        //             {
        //                 "level": 1,
        //                 "maxVol": 463300,
        //                 "mmr": 0.004,
        //                 "imr": 0.005,
        //                 "positionType": 1,
        //                 "openType": 1,
        //                 "leverage": 20,
        //                 "limitBySys": false,
        //                 "currentMmr": 0.004
        //             },
        //             {
        //                 "level": 1,
        //                 "maxVol": 463300,
        //                 "mmr": 0.004,
        //                 "imr": 0.005,
        //                 "positionType": 2,
        //                 "openType": 1,
        //                 "leverage": 20,
        //                 "limitBySys": false,
        //                 "currentMmr": 0.004
        //             }
        //         ]
        //     }
        //
        object data = this.safeList(response, "data", new List<object>() {});
        return this.parseLeverage(data, market);
    }

    public override object parseLeverage(object leverage, object market = null)
    {
        object marginMode = null;
        object longLeverage = null;
        object shortLeverage = null;
        for (object i = 0; isLessThan(i, getArrayLength(leverage)); postFixIncrement(ref i))
        {
            object entry = getValue(leverage, i);
            object openType = this.safeInteger(entry, "openType");
            object positionType = this.safeInteger(entry, "positionType");
            if (isTrue(isEqual(positionType, 1)))
            {
                longLeverage = this.safeInteger(entry, "leverage");
            } else if (isTrue(isEqual(positionType, 2)))
            {
                shortLeverage = this.safeInteger(entry, "leverage");
            }
            marginMode = ((bool) isTrue((isEqual(openType, 1)))) ? "isolated" : "cross";
        }
        return new Dictionary<string, object>() {
            { "info", leverage },
            { "symbol", getValue(market, "symbol") },
            { "marginMode", marginMode },
            { "longLeverage", longLeverage },
            { "shortLeverage", shortLeverage },
        };
    }

    public override object handleMarginModeAndParams(object methodName, object parameters = null, object defaultValue = null)
    {
        /**
        * @ignore
        * @method
        * @description marginMode specified by params["marginMode"], this.options["marginMode"], this.options["defaultMarginMode"], params["margin"] = true or this.options["defaultType"] = 'margin'
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {bool} [params.margin] true for trading spot-margin
        * @returns {Array} the marginMode in lowercase
        */
        parameters ??= new Dictionary<string, object>();
        object defaultType = this.safeString(this.options, "defaultType");
        object isMargin = this.safeBool(parameters, "margin", false);
        object marginMode = null;
        var marginModeparametersVariable = base.handleMarginModeAndParams(methodName, parameters, defaultValue);
        marginMode = ((IList<object>)marginModeparametersVariable)[0];
        parameters = ((IList<object>)marginModeparametersVariable)[1];
        if (isTrue(isTrue((isEqual(defaultType, "margin"))) || isTrue((isEqual(isMargin, true)))))
        {
            marginMode = "isolated";
        }
        return new List<object>() {marginMode, parameters};
    }

    /**
     * @method
     * @name mexc#fetchPositionsHistory
     * @description fetches historical positions
     * @see https://mexcdevelop.github.io/apidocs/contract_v1_en/#get-the-user-s-history-position-information
     * @param {string[]} [symbols] unified contract symbols
     * @param {int} [since] not used by mexc fetchPositionsHistory
     * @param {int} [limit] the maximum amount of candles to fetch, default=1000
     * @param {object} [params] extra parameters specific to the exchange api endpoint
     *
     * EXCHANGE SPECIFIC PARAMETERS
     * @param {int} [params.type] position type1: long, 2: short
     * @param {int} [params.page_num] current page number, default is 1
     * @returns {object[]} a list of [position structures]{@link https://docs.ccxt.com/#/?id=position-structure}
     */
    public async override Task<object> fetchPositionsHistory(object symbols = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        if (isTrue(!isEqual(symbols, null)))
        {
            object symbolsLength = getArrayLength(symbols);
            if (isTrue(isEqual(symbolsLength, 1)))
            {
                object market = this.market(getValue(symbols, 0));
                ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
            }
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["page_size"] = limit;
        }
        object response = await this.contractPrivateGetPositionListHistoryPositions(this.extend(request, parameters));
        //
        //    {
        //        success: true,
        //        code: '0',
        //        data: [
        //            {
        //                positionId: '390281084',
        //                symbol: 'RVN_USDT',
        //                positionType: '1',
        //                openType: '2',
        //                state: '3',
        //                holdVol: '0',
        //                frozenVol: '0',
        //                closeVol: '1141',
        //                holdAvgPrice: '0.03491',
        //                holdAvgPriceFullyScale: '0.03491',
        //                openAvgPrice: '0.03491',
        //                openAvgPriceFullyScale: '0.03491',
        //                closeAvgPrice: '0.03494',
        //                liquidatePrice: '0.03433',
        //                oim: '0',
        //                im: '0',
        //                holdFee: '0',
        //                realised: '0.1829',
        //                leverage: '50',
        //                createTime: '1711512408000',
        //                updateTime: '1711512553000',
        //                autoAddIm: false,
        //                version: '4',
        //                profitRatio: '0.0227',
        //                newOpenAvgPrice: '0.03491',
        //                newCloseAvgPrice: '0.03494',
        //                closeProfitLoss: '0.3423',
        //                fee: '0.1593977',
        //                positionShowStatus: 'CLOSED'
        //            },
        //            ...
        //        ]
        //    }
        //
        object data = this.safeList(response, "data");
        object positions = this.parsePositions(data, symbols, parameters);
        return this.filterBySinceLimit(positions, since, limit);
    }

    /**
     * @method
     * @name mexc#setMarginMode
     * @description set margin mode to 'cross' or 'isolated'
     * @see https://mexcdevelop.github.io/apidocs/contract_v1_en/#switch-leverage
     * @param {string} marginMode 'cross' or 'isolated'
     * @param {string} [symbol] required when there is no position, else provide params["positionId"]
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.positionId] required when a position is set
     * @param {string} [params.direction] "long" or "short" required when there is no position
     * @returns {object} response from the exchange
     */
    public async override Task<object> setMarginMode(object marginMode, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        if (isTrue(getValue(market, "spot")))
        {
            throw new BadSymbol ((string)add(this.id, " setMarginMode() supports contract markets only")) ;
        }
        marginMode = ((string)marginMode).ToLower();
        if (isTrue(isTrue(!isEqual(marginMode, "isolated")) && isTrue(!isEqual(marginMode, "cross"))))
        {
            throw new BadRequest ((string)add(this.id, " setMarginMode() marginMode argument should be isolated or cross")) ;
        }
        object leverage = this.safeInteger(parameters, "leverage");
        if (isTrue(isEqual(leverage, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " setMarginMode() requires a leverage parameter")) ;
        }
        object direction = this.safeStringLower2(parameters, "direction", "positionId");
        object request = new Dictionary<string, object>() {
            { "leverage", leverage },
            { "openType", ((bool) isTrue((isEqual(marginMode, "isolated")))) ? 1 : 2 },
        };
        if (isTrue(!isEqual(symbol, null)))
        {
            ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
        }
        if (isTrue(!isEqual(direction, null)))
        {
            ((IDictionary<string,object>)request)["positionType"] = ((bool) isTrue((isEqual(direction, "short")))) ? 2 : 1;
        }
        parameters = this.omit(parameters, "direction");
        object response = await this.contractPrivatePostPositionChangeLeverage(this.extend(request, parameters));
        //
        // { success: true, code: '0' }
        //
        return ((object)this.parseLeverage(response, market));  // tmp revert type
    }

    public override object nonce()
    {
        return subtract(this.milliseconds(), this.safeInteger(this.options, "timeDifference", 0));
    }

    public override object sign(object path, object api = null, object method = null, object parameters = null, object headers = null, object body = null)
    {
        api ??= "public";
        method ??= "GET";
        parameters ??= new Dictionary<string, object>();
        object section = this.safeString(api, 0);
        object access = this.safeString(api, 1);
        var pathparametersVariable = this.resolvePath(path, parameters);
        path = ((IList<object>)pathparametersVariable)[0];
        parameters = ((IList<object>)pathparametersVariable)[1];
        object url = null;
        if (isTrue(isTrue(isEqual(section, "spot")) || isTrue(isEqual(section, "broker"))))
        {
            if (isTrue(isEqual(section, "broker")))
            {
                url = add(add(getValue(getValue(getValue(this.urls, "api"), section), access), "/"), path);
            } else
            {
                url = add(add(add(add(getValue(getValue(getValue(this.urls, "api"), section), access), "/api/"), this.version), "/"), path);
            }
            object urlParams = parameters;
            if (isTrue(isEqual(access, "private")))
            {
                if (isTrue(isTrue(isEqual(section, "broker")) && isTrue((isTrue(isTrue((isEqual(method, "POST"))) || isTrue((isEqual(method, "PUT")))) || isTrue((isEqual(method, "DELETE")))))))
                {
                    urlParams = new Dictionary<string, object>() {
                        { "timestamp", this.nonce() },
                        { "recvWindow", this.safeInteger(this.options, "recvWindow", 5000) },
                    };
                    body = this.json(parameters);
                } else
                {
                    ((IDictionary<string,object>)urlParams)["timestamp"] = this.nonce();
                    ((IDictionary<string,object>)urlParams)["recvWindow"] = this.safeInteger(this.options, "recvWindow", 5000);
                }
            }
            object paramsEncoded = "";
            if (isTrue(getArrayLength(new List<object>(((IDictionary<string,object>)urlParams).Keys))))
            {
                paramsEncoded = this.urlencode(urlParams);
                url = add(url, add("?", paramsEncoded));
            }
            if (isTrue(isEqual(access, "private")))
            {
                this.checkRequiredCredentials();
                object signature = this.hmac(this.encode(paramsEncoded), this.encode(this.secret), sha256);
                url = add(url, add(add("&", "signature="), signature));
                headers = new Dictionary<string, object>() {
                    { "X-MEXC-APIKEY", this.apiKey },
                    { "source", this.safeString(this.options, "broker", "CCXT") },
                };
            }
            if (isTrue(isTrue(isTrue((isEqual(method, "POST"))) || isTrue((isEqual(method, "PUT")))) || isTrue((isEqual(method, "DELETE")))))
            {
                ((IDictionary<string,object>)headers)["Content-Type"] = "application/json";
            }
        } else if (isTrue(isTrue(isEqual(section, "contract")) || isTrue(isEqual(section, "spot2"))))
        {
            url = add(add(getValue(getValue(getValue(this.urls, "api"), section), access), "/"), this.implodeParams(path, parameters));
            parameters = this.omit(parameters, this.extractParams(path));
            if (isTrue(isEqual(access, "public")))
            {
                if (isTrue(getArrayLength(new List<object>(((IDictionary<string,object>)parameters).Keys))))
                {
                    url = add(url, add("?", this.urlencode(parameters)));
                }
            } else
            {
                this.checkRequiredCredentials();
                object timestamp = ((object)this.nonce()).ToString();
                object auth = "";
                headers = new Dictionary<string, object>() {
                    { "ApiKey", this.apiKey },
                    { "Request-Time", timestamp },
                    { "Content-Type", "application/json" },
                    { "source", this.safeString(this.options, "broker", "CCXT") },
                };
                if (isTrue(isEqual(method, "POST")))
                {
                    auth = this.json(parameters);
                    body = auth;
                } else
                {
                    parameters = this.keysort(parameters);
                    if (isTrue(getArrayLength(new List<object>(((IDictionary<string,object>)parameters).Keys))))
                    {
                        auth = add(auth, this.urlencode(parameters));
                        url = add(url, add("?", auth));
                    }
                }
                auth = add(add(this.apiKey, timestamp), auth);
                object signature = this.hmac(this.encode(auth), this.encode(this.secret), sha256);
                ((IDictionary<string,object>)headers)["Signature"] = signature;
            }
        }
        return new Dictionary<string, object>() {
            { "url", url },
            { "method", method },
            { "body", body },
            { "headers", headers },
        };
    }

    public override object handleErrors(object code, object reason, object url, object method, object headers, object body, object response, object requestHeaders, object requestBody)
    {
        if (isTrue(isEqual(response, null)))
        {
            return null;
        }
        // spot
        //     {"code":-1128,"msg":"Combination of optional parameters invalid.","_extend":null}
        //     {"success":false,"code":123456,"message":"Order quantity error...."}
        //
        // contract
        //
        //     {"code":10232,"msg":"The currency not exist"}
        //     {"code":10216,"msg":"No available deposit address"}
        //     {"success":true, "code":0, "data":1634095541710}
        //
        object success = this.safeBool(response, "success", false); // v1
        if (isTrue(isEqual(success, true)))
        {
            return null;
        }
        object responseCode = this.safeString(response, "code", null);
        if (isTrue(isTrue(isTrue((!isEqual(responseCode, null))) && isTrue((!isEqual(responseCode, "200")))) && isTrue((!isEqual(responseCode, "0")))))
        {
            object feedback = add(add(this.id, " "), body);
            this.throwBroadlyMatchedException(getValue(this.exceptions, "broad"), body, feedback);
            this.throwExactlyMatchedException(getValue(this.exceptions, "exact"), responseCode, feedback);
            throw new ExchangeError ((string)feedback) ;
        }
        return null;
    }
}
