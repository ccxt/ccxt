namespace ccxt;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

public partial class tokocrypto : Exchange
{
    public override object describe()
    {
        return this.deepExtend(base.describe(), new Dictionary<string, object>() {
            { "id", "tokocrypto" },
            { "name", "Tokocrypto" },
            { "countries", new List<object>() {"ID"} },
            { "certified", false },
            { "pro", false },
            { "version", "v1" },
            { "has", new Dictionary<string, object>() {
                { "CORS", null },
                { "spot", true },
                { "margin", true },
                { "swap", false },
                { "future", false },
                { "option", false },
                { "addMargin", null },
                { "borrowMargin", null },
                { "cancelAllOrders", false },
                { "cancelOrder", true },
                { "cancelOrders", null },
                { "createDepositAddress", false },
                { "createMarketBuyOrderWithCost", true },
                { "createMarketOrderWithCost", false },
                { "createMarketSellOrderWithCost", false },
                { "createOrder", true },
                { "createReduceOnlyOrder", null },
                { "createStopLimitOrder", true },
                { "createStopMarketOrder", true },
                { "createStopOrder", true },
                { "fetchAccounts", false },
                { "fetchBalance", true },
                { "fetchBidsAsks", true },
                { "fetchBorrowInterest", null },
                { "fetchBorrowRateHistories", null },
                { "fetchBorrowRateHistory", null },
                { "fetchCanceledOrders", false },
                { "fetchClosedOrder", false },
                { "fetchClosedOrders", "emulated" },
                { "fetchCrossBorrowRate", false },
                { "fetchCrossBorrowRates", false },
                { "fetchCurrencies", false },
                { "fetchDeposit", false },
                { "fetchDepositAddress", true },
                { "fetchDepositAddresses", false },
                { "fetchDepositAddressesByNetwork", false },
                { "fetchDeposits", true },
                { "fetchDepositsWithdrawals", false },
                { "fetchFundingHistory", false },
                { "fetchFundingRate", false },
                { "fetchFundingRateHistory", false },
                { "fetchFundingRates", false },
                { "fetchIndexOHLCV", false },
                { "fetchIsolatedBorrowRate", false },
                { "fetchIsolatedBorrowRates", false },
                { "fetchL3OrderBook", false },
                { "fetchLedger", null },
                { "fetchLeverage", false },
                { "fetchLeverageTiers", false },
                { "fetchMarketLeverageTiers", "emulated" },
                { "fetchMarkets", true },
                { "fetchMarkOHLCV", false },
                { "fetchMyTrades", true },
                { "fetchOHLCV", true },
                { "fetchOpenInterestHistory", false },
                { "fetchOpenOrder", false },
                { "fetchOpenOrders", true },
                { "fetchOrder", true },
                { "fetchOrderBook", true },
                { "fetchOrderBooks", false },
                { "fetchOrders", true },
                { "fetchOrderTrades", false },
                { "fetchPosition", false },
                { "fetchPositions", false },
                { "fetchPositionsRisk", false },
                { "fetchPremiumIndexOHLCV", false },
                { "fetchStatus", false },
                { "fetchTicker", false },
                { "fetchTickers", false },
                { "fetchTime", true },
                { "fetchTrades", true },
                { "fetchTradingFee", false },
                { "fetchTradingFees", false },
                { "fetchTradingLimits", false },
                { "fetchTransactionFee", false },
                { "fetchTransactionFees", false },
                { "fetchTransactions", false },
                { "fetchTransfers", false },
                { "fetchWithdrawal", false },
                { "fetchWithdrawals", true },
                { "fetchWithdrawalWhitelist", false },
                { "reduceMargin", false },
                { "repayCrossMargin", false },
                { "repayIsolatedMargin", false },
                { "setLeverage", false },
                { "setMargin", false },
                { "setMarginMode", false },
                { "setPositionMode", false },
                { "signIn", false },
                { "transfer", false },
                { "withdraw", true },
            } },
            { "timeframes", new Dictionary<string, object>() {
                { "1m", "1m" },
                { "3m", "3m" },
                { "5m", "5m" },
                { "15m", "15m" },
                { "30m", "30m" },
                { "1h", "1h" },
                { "2h", "2h" },
                { "4h", "4h" },
                { "6h", "6h" },
                { "8h", "8h" },
                { "12h", "12h" },
                { "1d", "1d" },
                { "3d", "3d" },
                { "1w", "1w" },
                { "1M", "1M" },
            } },
            { "urls", new Dictionary<string, object>() {
                { "logo", "https://user-images.githubusercontent.com/1294454/183870484-d3398d0c-f6a1-4cce-91b8-d58792308716.jpg" },
                { "api", new Dictionary<string, object>() {
                    { "rest", new Dictionary<string, object>() {
                        { "public", "https://www.tokocrypto.com" },
                        { "binance", "https://api.binance.com/api/v3" },
                        { "private", "https://www.tokocrypto.com" },
                    } },
                } },
                { "www", "https://tokocrypto.com" },
                { "doc", "https://www.tokocrypto.com/apidocs/" },
                { "fees", "https://www.tokocrypto.com/fees/newschedule" },
            } },
            { "api", new Dictionary<string, object>() {
                { "binance", new Dictionary<string, object>() {
                    { "get", new Dictionary<string, object>() {
                        { "ping", 1 },
                        { "time", 1 },
                        { "depth", new Dictionary<string, object>() {
                            { "cost", 1 },
                            { "byLimit", new List<object>() {new List<object>() {100, 1}, new List<object>() {500, 5}, new List<object>() {1000, 10}, new List<object>() {5000, 50}} },
                        } },
                        { "trades", 1 },
                        { "aggTrades", 1 },
                        { "historicalTrades", 5 },
                        { "klines", 1 },
                        { "ticker/24hr", new Dictionary<string, object>() {
                            { "cost", 1 },
                            { "noSymbol", 40 },
                        } },
                        { "ticker/price", new Dictionary<string, object>() {
                            { "cost", 1 },
                            { "noSymbol", 2 },
                        } },
                        { "ticker/bookTicker", new Dictionary<string, object>() {
                            { "cost", 1 },
                            { "noSymbol", 2 },
                        } },
                        { "exchangeInfo", 10 },
                    } },
                    { "put", new Dictionary<string, object>() {
                        { "userDataStream", 1 },
                    } },
                    { "post", new Dictionary<string, object>() {
                        { "userDataStream", 1 },
                    } },
                    { "delete", new Dictionary<string, object>() {
                        { "userDataStream", 1 },
                    } },
                } },
                { "public", new Dictionary<string, object>() {
                    { "get", new Dictionary<string, object>() {
                        { "open/v1/common/time", 1 },
                        { "open/v1/common/symbols", 1 },
                        { "open/v1/market/depth", 1 },
                        { "open/v1/market/trades", 1 },
                        { "open/v1/market/agg-trades", 1 },
                        { "open/v1/market/klines", 1 },
                    } },
                } },
                { "private", new Dictionary<string, object>() {
                    { "get", new Dictionary<string, object>() {
                        { "open/v1/orders/detail", 1 },
                        { "open/v1/orders", 1 },
                        { "open/v1/account/spot", 1 },
                        { "open/v1/account/spot/asset", 1 },
                        { "open/v1/orders/trades", 1 },
                        { "open/v1/withdraws", 1 },
                        { "open/v1/deposits", 1 },
                        { "open/v1/deposits/address", 1 },
                    } },
                    { "post", new Dictionary<string, object>() {
                        { "open/v1/orders", 1 },
                        { "open/v1/orders/cancel", 1 },
                        { "open/v1/orders/oco", 1 },
                        { "open/v1/withdraws", 1 },
                        { "open/v1/user-data-stream", 1 },
                    } },
                } },
            } },
            { "fees", new Dictionary<string, object>() {
                { "trading", new Dictionary<string, object>() {
                    { "tierBased", true },
                    { "percentage", true },
                    { "taker", this.parseNumber("0.0075") },
                    { "maker", this.parseNumber("0.0075") },
                } },
            } },
            { "precisionMode", TICK_SIZE },
            { "options", new Dictionary<string, object>() {
                { "createMarketBuyOrderRequiresPrice", true },
                { "defaultTimeInForce", "GTC" },
                { "hasAlreadyAuthenticatedSuccessfully", false },
                { "warnOnFetchOpenOrdersWithoutSymbol", true },
                { "recvWindow", multiply(5, 1000) },
                { "timeDifference", 0 },
                { "adjustForTimeDifference", false },
                { "newOrderRespType", new Dictionary<string, object>() {
                    { "market", "FULL" },
                    { "limit", "FULL" },
                } },
                { "quoteOrderQty", false },
                { "networks", new Dictionary<string, object>() {
                    { "ERC20", "ETH" },
                    { "TRC20", "TRX" },
                    { "BEP2", "BNB" },
                    { "BEP20", "BSC" },
                    { "OMNI", "OMNI" },
                    { "EOS", "EOS" },
                    { "SPL", "SOL" },
                } },
                { "reverseNetworks", new Dictionary<string, object>() {
                    { "tronscan.org", "TRC20" },
                    { "etherscan.io", "ERC20" },
                    { "bscscan.com", "BSC" },
                    { "explorer.binance.org", "BEP2" },
                    { "bithomp.com", "XRP" },
                    { "bloks.io", "EOS" },
                    { "stellar.expert", "XLM" },
                    { "blockchair.com/bitcoin", "BTC" },
                    { "blockchair.com/bitcoin-cash", "BCH" },
                    { "blockchair.com/ecash", "XEC" },
                    { "explorer.litecoin.net", "LTC" },
                    { "explorer.avax.network", "AVAX" },
                    { "solscan.io", "SOL" },
                    { "polkadot.subscan.io", "DOT" },
                    { "dashboard.internetcomputer.org", "ICP" },
                    { "explorer.chiliz.com", "CHZ" },
                    { "cardanoscan.io", "ADA" },
                    { "mainnet.theoan.com", "AION" },
                    { "algoexplorer.io", "ALGO" },
                    { "explorer.ambrosus.com", "AMB" },
                    { "viewblock.io/zilliqa", "ZIL" },
                    { "viewblock.io/arweave", "AR" },
                    { "explorer.ark.io", "ARK" },
                    { "atomscan.com", "ATOM" },
                    { "www.mintscan.io", "CTK" },
                    { "explorer.bitcoindiamond.org", "BCD" },
                    { "btgexplorer.com", "BTG" },
                    { "bts.ai", "BTS" },
                    { "explorer.celo.org", "CELO" },
                    { "explorer.nervos.org", "CKB" },
                    { "cerebro.cortexlabs.ai", "CTXC" },
                    { "chainz.cryptoid.info", "VIA" },
                    { "explorer.dcrdata.org", "DCR" },
                    { "digiexplorer.info", "DGB" },
                    { "dock.subscan.io", "DOCK" },
                    { "dogechain.info", "DOGE" },
                    { "explorer.elrond.com", "EGLD" },
                    { "blockscout.com", "ETC" },
                    { "explore-fetchhub.fetch.ai", "FET" },
                    { "filfox.info", "FIL" },
                    { "fio.bloks.io", "FIO" },
                    { "explorer.firo.org", "FIRO" },
                    { "neoscan.io", "NEO" },
                    { "ftmscan.com", "FTM" },
                    { "explorer.gochain.io", "GO" },
                    { "block.gxb.io", "GXS" },
                    { "hash-hash.info", "HBAR" },
                    { "www.hiveblockexplorer.com", "HIVE" },
                    { "explorer.helium.com", "HNT" },
                    { "tracker.icon.foundation", "ICX" },
                    { "www.iostabc.com", "IOST" },
                    { "explorer.iota.org", "IOTA" },
                    { "iotexscan.io", "IOTX" },
                    { "irishub.iobscan.io", "IRIS" },
                    { "kava.mintscan.io", "KAVA" },
                    { "scope.klaytn.com", "KLAY" },
                    { "kmdexplorer.io", "KMD" },
                    { "kusama.subscan.io", "KSM" },
                    { "explorer.lto.network", "LTO" },
                    { "polygonscan.com", "POLYGON" },
                    { "explorer.ont.io", "ONT" },
                    { "minaexplorer.com", "MINA" },
                    { "nanolooker.com", "NANO" },
                    { "explorer.nebulas.io", "NAS" },
                    { "explorer.nbs.plus", "NBS" },
                    { "explorer.nebl.io", "NEBL" },
                    { "nulscan.io", "NULS" },
                    { "nxscan.com", "NXS" },
                    { "explorer.harmony.one", "ONE" },
                    { "explorer.poa.network", "POA" },
                    { "qtum.info", "QTUM" },
                    { "explorer.rsk.co", "RSK" },
                    { "www.oasisscan.com", "ROSE" },
                    { "ravencoin.network", "RVN" },
                    { "sc.tokenview.com", "SC" },
                    { "secretnodes.com", "SCRT" },
                    { "explorer.skycoin.com", "SKY" },
                    { "steemscan.com", "STEEM" },
                    { "explorer.stacks.co", "STX" },
                    { "www.thetascan.io", "THETA" },
                    { "scan.tomochain.com", "TOMO" },
                    { "explore.vechain.org", "VET" },
                    { "explorer.vite.net", "VITE" },
                    { "www.wanscan.org", "WAN" },
                    { "wavesexplorer.com", "WAVES" },
                    { "wax.eosx.io", "WAXP" },
                    { "waltonchain.pro", "WTC" },
                    { "chain.nem.ninja", "XEM" },
                    { "verge-blockchain.info", "XVG" },
                    { "explorer.yoyow.org", "YOYOW" },
                    { "explorer.zcha.in", "ZEC" },
                    { "explorer.zensystem.io", "ZEN" },
                } },
                { "impliedNetworks", new Dictionary<string, object>() {
                    { "ETH", new Dictionary<string, object>() {
                        { "ERC20", "ETH" },
                    } },
                    { "TRX", new Dictionary<string, object>() {
                        { "TRC20", "TRX" },
                    } },
                } },
                { "legalMoney", new Dictionary<string, object>() {
                    { "MXN", true },
                    { "UGX", true },
                    { "SEK", true },
                    { "CHF", true },
                    { "VND", true },
                    { "AED", true },
                    { "DKK", true },
                    { "KZT", true },
                    { "HUF", true },
                    { "PEN", true },
                    { "PHP", true },
                    { "USD", true },
                    { "TRY", true },
                    { "EUR", true },
                    { "NGN", true },
                    { "PLN", true },
                    { "BRL", true },
                    { "ZAR", true },
                    { "KES", true },
                    { "ARS", true },
                    { "RUB", true },
                    { "AUD", true },
                    { "NOK", true },
                    { "CZK", true },
                    { "GBP", true },
                    { "UAH", true },
                    { "GHS", true },
                    { "HKD", true },
                    { "CAD", true },
                    { "INR", true },
                    { "JPY", true },
                    { "NZD", true },
                } },
            } },
            { "exceptions", new Dictionary<string, object>() {
                { "exact", new Dictionary<string, object>() {
                    { "System is under maintenance.", typeof(OnMaintenance) },
                    { "System abnormality", typeof(ExchangeError) },
                    { "You are not authorized to execute this request.", typeof(PermissionDenied) },
                    { "API key does not exist", typeof(AuthenticationError) },
                    { "Order would trigger immediately.", typeof(OrderImmediatelyFillable) },
                    { "Stop price would trigger immediately.", typeof(OrderImmediatelyFillable) },
                    { "Order would immediately match and take.", typeof(OrderImmediatelyFillable) },
                    { "Account has insufficient balance for requested action.", typeof(InsufficientFunds) },
                    { "Rest API trading is not enabled.", typeof(ExchangeNotAvailable) },
                    { "You don't have permission.", typeof(PermissionDenied) },
                    { "Market is closed.", typeof(ExchangeNotAvailable) },
                    { "Too many requests. Please try again later.", typeof(DDoSProtection) },
                    { "This action disabled is on this account.", typeof(AccountSuspended) },
                    { "-1000", typeof(ExchangeNotAvailable) },
                    { "-1001", typeof(ExchangeNotAvailable) },
                    { "-1002", typeof(AuthenticationError) },
                    { "-1003", typeof(RateLimitExceeded) },
                    { "-1004", typeof(DDoSProtection) },
                    { "-1005", typeof(PermissionDenied) },
                    { "-1006", typeof(BadResponse) },
                    { "-1007", typeof(RequestTimeout) },
                    { "-1010", typeof(BadResponse) },
                    { "-1011", typeof(PermissionDenied) },
                    { "-1013", typeof(InvalidOrder) },
                    { "-1014", typeof(InvalidOrder) },
                    { "-1015", typeof(RateLimitExceeded) },
                    { "-1016", typeof(ExchangeNotAvailable) },
                    { "-1020", typeof(BadRequest) },
                    { "-1021", typeof(InvalidNonce) },
                    { "-1022", typeof(AuthenticationError) },
                    { "-1023", typeof(BadRequest) },
                    { "-1099", typeof(AuthenticationError) },
                    { "-1100", typeof(BadRequest) },
                    { "-1101", typeof(BadRequest) },
                    { "-1102", typeof(BadRequest) },
                    { "-1103", typeof(BadRequest) },
                    { "-1104", typeof(BadRequest) },
                    { "-1105", typeof(BadRequest) },
                    { "-1106", typeof(BadRequest) },
                    { "-1108", typeof(BadRequest) },
                    { "-1109", typeof(AuthenticationError) },
                    { "-1110", typeof(BadRequest) },
                    { "-1111", typeof(BadRequest) },
                    { "-1112", typeof(InvalidOrder) },
                    { "-1113", typeof(BadRequest) },
                    { "-1114", typeof(BadRequest) },
                    { "-1115", typeof(BadRequest) },
                    { "-1116", typeof(BadRequest) },
                    { "-1117", typeof(BadRequest) },
                    { "-1118", typeof(BadRequest) },
                    { "-1119", typeof(BadRequest) },
                    { "-1120", typeof(BadRequest) },
                    { "-1121", typeof(BadSymbol) },
                    { "-1125", typeof(AuthenticationError) },
                    { "-1127", typeof(BadRequest) },
                    { "-1128", typeof(BadRequest) },
                    { "-1130", typeof(BadRequest) },
                    { "-1131", typeof(BadRequest) },
                    { "-1136", typeof(BadRequest) },
                    { "-2008", typeof(AuthenticationError) },
                    { "-2010", typeof(ExchangeError) },
                    { "-2011", typeof(OrderNotFound) },
                    { "-2013", typeof(OrderNotFound) },
                    { "-2014", typeof(AuthenticationError) },
                    { "-2015", typeof(AuthenticationError) },
                    { "-2016", typeof(BadRequest) },
                    { "-2018", typeof(InsufficientFunds) },
                    { "-2019", typeof(InsufficientFunds) },
                    { "-2020", typeof(OrderNotFillable) },
                    { "-2021", typeof(OrderImmediatelyFillable) },
                    { "-2022", typeof(InvalidOrder) },
                    { "-2023", typeof(InsufficientFunds) },
                    { "-2024", typeof(InsufficientFunds) },
                    { "-2025", typeof(InvalidOrder) },
                    { "-2026", typeof(InvalidOrder) },
                    { "-2027", typeof(InvalidOrder) },
                    { "-2028", typeof(InsufficientFunds) },
                    { "-3000", typeof(ExchangeError) },
                    { "-3001", typeof(AuthenticationError) },
                    { "-3002", typeof(BadSymbol) },
                    { "-3003", typeof(BadRequest) },
                    { "-3004", typeof(ExchangeError) },
                    { "-3005", typeof(InsufficientFunds) },
                    { "-3006", typeof(InsufficientFunds) },
                    { "-3007", typeof(ExchangeError) },
                    { "-3008", typeof(InsufficientFunds) },
                    { "-3009", typeof(BadRequest) },
                    { "-3010", typeof(ExchangeError) },
                    { "-3011", typeof(BadRequest) },
                    { "-3012", typeof(ExchangeError) },
                    { "-3013", typeof(BadRequest) },
                    { "-3014", typeof(AccountSuspended) },
                    { "-3015", typeof(ExchangeError) },
                    { "-3016", typeof(BadRequest) },
                    { "-3017", typeof(ExchangeError) },
                    { "-3018", typeof(AccountSuspended) },
                    { "-3019", typeof(AccountSuspended) },
                    { "-3020", typeof(InsufficientFunds) },
                    { "-3021", typeof(BadRequest) },
                    { "-3022", typeof(AccountSuspended) },
                    { "-3023", typeof(BadRequest) },
                    { "-3024", typeof(ExchangeError) },
                    { "-3025", typeof(BadRequest) },
                    { "-3026", typeof(BadRequest) },
                    { "-3027", typeof(BadSymbol) },
                    { "-3028", typeof(BadSymbol) },
                    { "-3029", typeof(ExchangeError) },
                    { "-3036", typeof(AccountSuspended) },
                    { "-3037", typeof(ExchangeError) },
                    { "-3038", typeof(BadRequest) },
                    { "-3041", typeof(InsufficientFunds) },
                    { "-3042", typeof(BadRequest) },
                    { "-3043", typeof(BadRequest) },
                    { "-3044", typeof(DDoSProtection) },
                    { "-3045", typeof(ExchangeError) },
                    { "-3999", typeof(ExchangeError) },
                    { "-4001", typeof(BadRequest) },
                    { "-4002", typeof(BadRequest) },
                    { "-4003", typeof(BadRequest) },
                    { "-4004", typeof(AuthenticationError) },
                    { "-4005", typeof(RateLimitExceeded) },
                    { "-4006", typeof(BadRequest) },
                    { "-4007", typeof(BadRequest) },
                    { "-4008", typeof(BadRequest) },
                    { "-4010", typeof(BadRequest) },
                    { "-4011", typeof(BadRequest) },
                    { "-4012", typeof(BadRequest) },
                    { "-4013", typeof(AuthenticationError) },
                    { "-4014", typeof(PermissionDenied) },
                    { "-4015", typeof(ExchangeError) },
                    { "-4016", typeof(PermissionDenied) },
                    { "-4017", typeof(PermissionDenied) },
                    { "-4018", typeof(BadSymbol) },
                    { "-4019", typeof(BadSymbol) },
                    { "-4021", typeof(BadRequest) },
                    { "-4022", typeof(BadRequest) },
                    { "-4023", typeof(ExchangeError) },
                    { "-4024", typeof(InsufficientFunds) },
                    { "-4025", typeof(InsufficientFunds) },
                    { "-4026", typeof(InsufficientFunds) },
                    { "-4027", typeof(ExchangeError) },
                    { "-4028", typeof(BadRequest) },
                    { "-4029", typeof(BadRequest) },
                    { "-4030", typeof(ExchangeError) },
                    { "-4031", typeof(ExchangeError) },
                    { "-4032", typeof(ExchangeError) },
                    { "-4033", typeof(BadRequest) },
                    { "-4034", typeof(ExchangeError) },
                    { "-4035", typeof(PermissionDenied) },
                    { "-4036", typeof(BadRequest) },
                    { "-4037", typeof(ExchangeError) },
                    { "-4038", typeof(ExchangeError) },
                    { "-4039", typeof(BadRequest) },
                    { "-4040", typeof(BadRequest) },
                    { "-4041", typeof(ExchangeError) },
                    { "-4042", typeof(ExchangeError) },
                    { "-4043", typeof(BadRequest) },
                    { "-4044", typeof(BadRequest) },
                    { "-4045", typeof(ExchangeError) },
                    { "-4046", typeof(AuthenticationError) },
                    { "-4047", typeof(BadRequest) },
                    { "-5001", typeof(BadRequest) },
                    { "-5002", typeof(InsufficientFunds) },
                    { "-5003", typeof(InsufficientFunds) },
                    { "-5004", typeof(BadRequest) },
                    { "-5005", typeof(InsufficientFunds) },
                    { "-5006", typeof(BadRequest) },
                    { "-5007", typeof(BadRequest) },
                    { "-5008", typeof(InsufficientFunds) },
                    { "-5009", typeof(BadRequest) },
                    { "-5010", typeof(ExchangeError) },
                    { "-5011", typeof(BadRequest) },
                    { "-5012", typeof(ExchangeError) },
                    { "-5013", typeof(InsufficientFunds) },
                    { "-5021", typeof(BadRequest) },
                    { "-6001", typeof(BadRequest) },
                    { "-6003", typeof(BadRequest) },
                    { "-6004", typeof(ExchangeError) },
                    { "-6005", typeof(InvalidOrder) },
                    { "-6006", typeof(BadRequest) },
                    { "-6007", typeof(BadRequest) },
                    { "-6008", typeof(BadRequest) },
                    { "-6009", typeof(RateLimitExceeded) },
                    { "-6011", typeof(BadRequest) },
                    { "-6012", typeof(InsufficientFunds) },
                    { "-6013", typeof(ExchangeError) },
                    { "-6014", typeof(BadRequest) },
                    { "-6015", typeof(BadRequest) },
                    { "-6016", typeof(BadRequest) },
                    { "-6017", typeof(BadRequest) },
                    { "-6018", typeof(BadRequest) },
                    { "-6019", typeof(AuthenticationError) },
                    { "-6020", typeof(BadRequest) },
                    { "-7001", typeof(BadRequest) },
                    { "-7002", typeof(BadRequest) },
                    { "-9000", typeof(InsufficientFunds) },
                    { "-10017", typeof(BadRequest) },
                    { "-11008", typeof(InsufficientFunds) },
                    { "-12014", typeof(RateLimitExceeded) },
                    { "-13000", typeof(BadRequest) },
                    { "-13001", typeof(BadRequest) },
                    { "-13002", typeof(BadRequest) },
                    { "-13003", typeof(BadRequest) },
                    { "-13004", typeof(BadRequest) },
                    { "-13005", typeof(BadRequest) },
                    { "-13006", typeof(InvalidOrder) },
                    { "-13007", typeof(AuthenticationError) },
                    { "-21001", typeof(BadRequest) },
                    { "-21002", typeof(BadRequest) },
                    { "-21003", typeof(BadRequest) },
                    { "100001003", typeof(BadRequest) },
                    { "2202", typeof(InsufficientFunds) },
                    { "3210", typeof(InvalidOrder) },
                    { "3203", typeof(InvalidOrder) },
                    { "3211", typeof(InvalidOrder) },
                    { "3207", typeof(InvalidOrder) },
                    { "3218", typeof(OrderNotFound) },
                } },
                { "broad", new Dictionary<string, object>() {
                    { "has no operation privilege", typeof(PermissionDenied) },
                    { "MAX_POSITION", typeof(InvalidOrder) },
                } },
            } },
        });
    }

    public override object nonce()
    {
        return subtract(this.milliseconds(), getValue(this.options, "timeDifference"));
    }

    public async override Task<object> fetchTime(object parameters = null)
    {
        /**
        * @method
        * @name tokocrypto#fetchTime
        * @see https://www.tokocrypto.com/apidocs/#check-server-time
        * @description fetches the current integer timestamp in milliseconds from the exchange server
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {int} the current integer timestamp in milliseconds from the exchange server
        */
        parameters ??= new Dictionary<string, object>();
        object response = await this.publicGetOpenV1CommonTime(parameters);
        //
        //
        //
        return this.safeInteger(response, "serverTime");
    }

    public async override Task<object> fetchMarkets(object parameters = null)
    {
        /**
        * @method
        * @name tokocrypto#fetchMarkets
        * @see https://www.tokocrypto.com/apidocs/#get-all-supported-trading-symbol
        * @description retrieves data on all markets for tokocrypto
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} an array of objects representing market data
        */
        parameters ??= new Dictionary<string, object>();
        object response = await this.publicGetOpenV1CommonSymbols(parameters);
        //
        //     {
        //         "code":0,
        //         "msg":"Success",
        //         "data":{
        //             "list":[
        //                 {
        //                     "type":1,
        //                     "symbol":"1INCH_BTC",
        //                     "baseAsset":"1INCH",
        //                     "basePrecision":8,
        //                     "quoteAsset":"BTC",
        //                     "quotePrecision":8,
        //                     "filters":[
        //                         {"filterType":"PRICE_FILTER","minPrice":"0.00000001","maxPrice":"1000.00000000","tickSize":"0.00000001","applyToMarket":false},
        //                         {"filterType":"PERCENT_PRICE","multiplierUp":5,"multiplierDown":0.2,"avgPriceMins":"5","applyToMarket":false},
        //                         {"filterType":"LOT_SIZE","minQty":"0.10000000","maxQty":"90000000.00000000","stepSize":"0.10000000","applyToMarket":false},
        //                         {"filterType":"MIN_NOTIONAL","avgPriceMins":"5","minNotional":"0.00010000","applyToMarket":true},
        //                         {"filterType":"ICEBERG_PARTS","applyToMarket":false,"limit":"10"},
        //                         {"filterType":"MARKET_LOT_SIZE","minQty":"0.00000000","maxQty":"79460.14117231","stepSize":"0.00000000","applyToMarket":false},
        //                         {"filterType":"TRAILING_DELTA","applyToMarket":false},
        //                         {"filterType":"MAX_NUM_ORDERS","applyToMarket":false},
        //                         {"filterType":"MAX_NUM_ALGO_ORDERS","applyToMarket":false,"maxNumAlgoOrders":"5"}
        //                     ],
        //                     "orderTypes":["LIMIT","LIMIT_MAKER","MARKET","STOP_LOSS_LIMIT","TAKE_PROFIT_LIMIT"],
        //                     "icebergEnable":1,
        //                     "ocoEnable":1,
        //                     "spotTradingEnable":1,
        //                     "marginTradingEnable":1,
        //                     "permissions":["SPOT","MARGIN"]
        //                 },
        //             ]
        //         },
        //         "timestamp":1659492212507
        //     }
        //
        if (isTrue(getValue(this.options, "adjustForTimeDifference")))
        {
            await this.loadTimeDifference();
        }
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        object list = this.safeValue(data, "list", new List<object>() {});
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(list)); postFixIncrement(ref i))
        {
            object market = getValue(list, i);
            object baseId = this.safeString(market, "baseAsset");
            object quoteId = this.safeString(market, "quoteAsset");
            object id = this.safeString(market, "symbol");
            object lowercaseId = this.safeStringLower(market, "symbol");
            object settleId = this.safeString(market, "marginAsset");
            object bs = this.safeCurrencyCode(baseId);
            object quote = this.safeCurrencyCode(quoteId);
            object settle = this.safeCurrencyCode(settleId);
            object symbol = add(add(bs, "/"), quote);
            object filters = this.safeValue(market, "filters", new List<object>() {});
            object filtersByType = this.indexBy(filters, "filterType");
            object status = this.safeString(market, "spotTradingEnable");
            object active = (isEqual(status, "1"));
            object permissions = this.safeValue(market, "permissions", new List<object>() {});
            for (object j = 0; isLessThan(j, getArrayLength(permissions)); postFixIncrement(ref j))
            {
                if (isTrue(isEqual(getValue(permissions, j), "TRD_GRP_003")))
                {
                    active = false;
                    break;
                }
            }
            object isMarginTradingAllowed = this.safeBool(market, "isMarginTradingAllowed", false);
            object entry = new Dictionary<string, object>() {
                { "id", id },
                { "lowercaseId", lowercaseId },
                { "symbol", symbol },
                { "base", bs },
                { "quote", quote },
                { "settle", settle },
                { "baseId", baseId },
                { "quoteId", quoteId },
                { "settleId", settleId },
                { "type", "spot" },
                { "spot", true },
                { "margin", isMarginTradingAllowed },
                { "swap", false },
                { "future", false },
                { "delivery", false },
                { "option", false },
                { "active", active },
                { "contract", false },
                { "linear", null },
                { "inverse", null },
                { "contractSize", null },
                { "expiry", null },
                { "expiryDatetime", null },
                { "strike", null },
                { "optionType", null },
                { "precision", new Dictionary<string, object>() {
                    { "amount", this.parseNumber(this.parsePrecision(this.safeString(market, "quantityPrecision"))) },
                    { "price", this.parseNumber(this.parsePrecision(this.safeString(market, "pricePrecision"))) },
                    { "base", this.parseNumber(this.parsePrecision(this.safeString(market, "baseAssetPrecision"))) },
                    { "quote", this.parseNumber(this.parsePrecision(this.safeString(market, "quotePrecision"))) },
                } },
                { "limits", new Dictionary<string, object>() {
                    { "leverage", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                    { "amount", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                    { "price", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                    { "cost", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                } },
                { "created", null },
                { "info", market },
            };
            if (isTrue(inOp(filtersByType, "PRICE_FILTER")))
            {
                object filter = this.safeValue(filtersByType, "PRICE_FILTER", new Dictionary<string, object>() {});
                ((IDictionary<string,object>)getValue(entry, "precision"))["price"] = this.safeNumber(filter, "tickSize");
                // PRICE_FILTER reports zero values for maxPrice
                // since they updated filter types in November 2018
                // https://github.com/ccxt/ccxt/issues/4286
                // therefore limits['price']['max'] doesn't have any meaningful value except undefined
                ((IDictionary<string,object>)getValue(entry, "limits"))["price"] = new Dictionary<string, object>() {
                    { "min", this.safeNumber(filter, "minPrice") },
                    { "max", this.safeNumber(filter, "maxPrice") },
                };
                ((IDictionary<string,object>)getValue(entry, "precision"))["price"] = getValue(filter, "tickSize");
            }
            if (isTrue(inOp(filtersByType, "LOT_SIZE")))
            {
                object filter = this.safeValue(filtersByType, "LOT_SIZE", new Dictionary<string, object>() {});
                ((IDictionary<string,object>)getValue(entry, "precision"))["amount"] = this.safeNumber(filter, "stepSize");
                ((IDictionary<string,object>)getValue(entry, "limits"))["amount"] = new Dictionary<string, object>() {
                    { "min", this.safeNumber(filter, "minQty") },
                    { "max", this.safeNumber(filter, "maxQty") },
                };
            }
            if (isTrue(inOp(filtersByType, "MARKET_LOT_SIZE")))
            {
                object filter = this.safeValue(filtersByType, "MARKET_LOT_SIZE", new Dictionary<string, object>() {});
                ((IDictionary<string,object>)getValue(entry, "limits"))["market"] = new Dictionary<string, object>() {
                    { "min", this.safeNumber(filter, "minQty") },
                    { "max", this.safeNumber(filter, "maxQty") },
                };
            }
            if (isTrue(inOp(filtersByType, "MIN_NOTIONAL")))
            {
                object filter = this.safeValue(filtersByType, "MIN_NOTIONAL", new Dictionary<string, object>() {});
                ((IDictionary<string,object>)getValue(getValue(entry, "limits"), "cost"))["min"] = this.safeNumber2(filter, "minNotional", "notional");
            }
            ((IList<object>)result).Add(entry);
        }
        return result;
    }

    public async override Task<object> fetchOrderBook(object symbol, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name tokocrypto#fetchOrderBook
        * @see https://www.tokocrypto.com/apidocs/#order-book
        * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
        * @param {string} symbol unified symbol of the market to fetch the order book for
        * @param {int} [limit] the maximum amount of order book entries to return
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {};
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit; // default 100, max 5000, see https://github.com/binance/binance-spot-api-docs/blob/master/rest-api.md#order-book
        }
        object response = null;
        if (isTrue(isEqual(getValue(market, "quote"), "USDT")))
        {
            ((IDictionary<string,object>)request)["symbol"] = add(getValue(market, "baseId"), getValue(market, "quoteId"));
            response = await this.binanceGetDepth(this.extend(request, parameters));
        } else
        {
            ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
            response = await this.publicGetOpenV1MarketDepth(this.extend(request, parameters));
        }
        //
        // future
        //
        //     {
        //         "lastUpdateId":333598053905,
        //         "E":1618631511986,
        //         "T":1618631511964,
        //         "bids":[
        //             ["2493.56","20.189"],
        //             ["2493.54","1.000"],
        //             ["2493.51","0.005"]
        //         ],
        //         "asks":[
        //             ["2493.57","0.877"],
        //             ["2493.62","0.063"],
        //             ["2493.71","12.054"],
        //         ]
        //     }
        // type not 1
        //     {
        //         "code":0,
        //         "msg":"Success",
        //         "data":{
        //            "lastUpdateId":3204783,
        //            "bids":[],
        //            "asks": []
        //         },
        //         "timestamp":1692262634599
        //     }
        object data = this.safeValue(response, "data", response);
        object timestamp = this.safeInteger2(response, "T", "timestamp");
        object orderbook = this.parseOrderBook(data, symbol, timestamp);
        ((IDictionary<string,object>)orderbook)["nonce"] = this.safeInteger(data, "lastUpdateId");
        return orderbook;
    }

    public override object parseTrade(object trade, object market = null)
    {
        //
        // aggregate trades
        // https://github.com/binance-exchange/binance-official-api-docs/blob/master/rest-api.md#compressedaggregate-trades-list
        //
        //     {
        //         "a": 26129,         // Aggregate tradeId
        //         "p": "0.01633102",  // Price
        //         "q": "4.70443515",  // Quantity
        //         "f": 27781,         // First tradeId
        //         "l": 27781,         // Last tradeId
        //         "T": 1498793709153, // Timestamp
        //         "m": true,          // Was the buyer the maker?
        //         "M": true           // Was the trade the best price match?
        //     }
        //
        // recent public trades and old public trades
        // https://github.com/binance-exchange/binance-official-api-docs/blob/master/rest-api.md#recent-trades-list
        // https://github.com/binance-exchange/binance-official-api-docs/blob/master/rest-api.md#old-trade-lookup-market_data
        //
        //     {
        //         "id": 28457,
        //         "price": "4.00000100",
        //         "qty": "12.00000000",
        //         "time": 1499865549590,
        //         "isBuyerMaker": true,
        //         "isBestMatch": true
        //     }
        //
        // private trades
        // https://github.com/binance-exchange/binance-official-api-docs/blob/master/rest-api.md#account-trade-list-user_data
        //
        //     {
        //         "symbol": "BNBBTC",
        //         "id": 28457,
        //         "orderId": 100234,
        //         "price": "4.00000100",
        //         "qty": "12.00000000",
        //         "commission": "10.10000000",
        //         "commissionAsset": "BNB",
        //         "time": 1499865549590,
        //         "isBuyer": true,
        //         "isMaker": false,
        //         "isBestMatch": true
        //     }
        //
        // futures trades
        // https://binance-docs.github.io/apidocs/futures/en/#account-trade-list-user_data
        //
        //     {
        //       "accountId": 20,
        //       "buyer": False,
        //       "commission": "-0.07819010",
        //       "commissionAsset": "USDT",
        //       "counterPartyId": 653,
        //       "id": 698759,
        //       "maker": False,
        //       "orderId": 25851813,
        //       "price": "7819.01",
        //       "qty": "0.002",
        //       "quoteQty": "0.01563",
        //       "realizedPnl": "-0.91539999",
        //       "side": "SELL",
        //       "symbol": "BTCUSDT",
        //       "time": 1569514978020
        //     }
        //     {
        //       "symbol": "BTCUSDT",
        //       "id": 477128891,
        //       "orderId": 13809777875,
        //       "side": "SELL",
        //       "price": "38479.55",
        //       "qty": "0.001",
        //       "realizedPnl": "-0.00009534",
        //       "marginAsset": "USDT",
        //       "quoteQty": "38.47955",
        //       "commission": "-0.00076959",
        //       "commissionAsset": "USDT",
        //       "time": 1612733566708,
        //       "positionSide": "BOTH",
        //       "maker": true,
        //       "buyer": false
        //     }
        //
        // { respType: FULL }
        //
        //     {
        //       "price": "4000.00000000",
        //       "qty": "1.00000000",
        //       "commission": "4.00000000",
        //       "commissionAsset": "USDT",
        //       "tradeId": "1234",
        //     }
        //
        object timestamp = this.safeInteger2(trade, "T", "time");
        object price = this.safeString2(trade, "p", "price");
        object amount = this.safeString2(trade, "q", "qty");
        object cost = this.safeString2(trade, "quoteQty", "baseQty"); // inverse futures
        object marketId = this.safeString(trade, "symbol");
        object symbol = this.safeSymbol(marketId, market);
        object id = this.safeString2(trade, "t", "a");
        id = this.safeString2(trade, "id", "tradeId", id);
        object side = null;
        object orderId = this.safeString(trade, "orderId");
        object buyerMaker = this.safeValue2(trade, "m", "isBuyerMaker");
        object takerOrMaker = null;
        if (isTrue(!isEqual(buyerMaker, null)))
        {
            side = ((bool) isTrue(buyerMaker)) ? "sell" : "buy"; // this is reversed intentionally
            takerOrMaker = "taker";
        } else if (isTrue(inOp(trade, "side")))
        {
            side = this.safeStringLower(trade, "side");
        } else
        {
            if (isTrue(inOp(trade, "isBuyer")))
            {
                side = ((bool) isTrue(getValue(trade, "isBuyer"))) ? "buy" : "sell"; // this is a true side
            }
        }
        object fee = null;
        if (isTrue(inOp(trade, "commission")))
        {
            fee = new Dictionary<string, object>() {
                { "cost", this.safeString(trade, "commission") },
                { "currency", this.safeCurrencyCode(this.safeString(trade, "commissionAsset")) },
            };
        }
        if (isTrue(inOp(trade, "isMaker")))
        {
            takerOrMaker = ((bool) isTrue(getValue(trade, "isMaker"))) ? "maker" : "taker";
        }
        if (isTrue(inOp(trade, "maker")))
        {
            takerOrMaker = ((bool) isTrue(getValue(trade, "maker"))) ? "maker" : "taker";
        }
        return this.safeTrade(new Dictionary<string, object>() {
            { "info", trade },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "symbol", symbol },
            { "id", id },
            { "order", orderId },
            { "type", null },
            { "side", side },
            { "takerOrMaker", takerOrMaker },
            { "price", price },
            { "amount", amount },
            { "cost", cost },
            { "fee", fee },
        }, market);
    }

    public async override Task<object> fetchTrades(object symbol, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name tokocrypto#fetchTrades
        * @see https://www.tokocrypto.com/apidocs/#recent-trades-list
        * @see https://www.tokocrypto.com/apidocs/#compressedaggregate-trades-list
        * @description get the list of most recent trades for a particular symbol
        * @param {string} symbol unified symbol of the market to fetch trades for
        * @param {int} [since] timestamp in ms of the earliest trade to fetch
        * @param {int} [limit] the maximum amount of trades to fetch
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", this.getMarketIdByType(market) },
        };
        if (isTrue(!isEqual(getValue(market, "quote"), "USDT")))
        {
            if (isTrue(!isEqual(limit, null)))
            {
                ((IDictionary<string,object>)request)["limit"] = limit;
            }
            object responseInner = this.publicGetOpenV1MarketTrades(this.extend(request, parameters));
            //
            //    {
            //       "code": 0,
            //       "msg": "success",
            //       "data": {
            //           "list": [
            //                {
            //                    "id": 28457,
            //                    "price": "4.00000100",
            //                    "qty": "12.00000000",
            //                    "time": 1499865549590,
            //                    "isBuyerMaker": true,
            //                    "isBestMatch": true
            //                }
            //            ]
            //        },
            //        "timestamp": 1571921637091
            //    }
            //
            object data = this.safeDict(responseInner, "data", new Dictionary<string, object>() {});
            object list = this.safeList(data, "list", new List<object>() {});
            return this.parseTrades(list, market, since, limit);
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit; // default = 500, maximum = 1000
        }
        object defaultMethod = "binanceGetTrades";
        object method = this.safeString(this.options, "fetchTradesMethod", defaultMethod);
        object response = null;
        if (isTrue(isTrue((isEqual(method, "binanceGetAggTrades"))) && isTrue((!isEqual(since, null)))))
        {
            ((IDictionary<string,object>)request)["startTime"] = since;
            // https://github.com/ccxt/ccxt/issues/6400
            // https://github.com/binance-exchange/binance-official-api-docs/blob/master/rest-api.md#compressedaggregate-trades-list
            ((IDictionary<string,object>)request)["endTime"] = this.sum(since, 3600000);
            response = await this.binanceGetAggTrades(this.extend(request, parameters));
        } else
        {
            response = await this.binanceGetTrades(this.extend(request, parameters));
        }
        //
        // Caveats:
        // - default limit (500) applies only if no other parameters set, trades up
        //   to the maximum limit may be returned to satisfy other parameters
        // - if both limit and time window is set and time window contains more
        //   trades than the limit then the last trades from the window are returned
        // - 'tradeId' accepted and returned by this method is "aggregate" trade id
        //   which is different from actual trade id
        // - setting both fromId and time window results in error
        //
        // aggregate trades
        //
        //     [
        //         {
        //             "a": 26129,         // Aggregate tradeId
        //             "p": "0.01633102",  // Price
        //             "q": "4.70443515",  // Quantity
        //             "f": 27781,         // First tradeId
        //             "l": 27781,         // Last tradeId
        //             "T": 1498793709153, // Timestamp
        //             "m": true,          // Was the buyer the maker?
        //             "M": true           // Was the trade the best price match?
        //         }
        //     ]
        //
        // recent public trades and historical public trades
        //
        //     [
        //         {
        //             "id": 28457,
        //             "price": "4.00000100",
        //             "qty": "12.00000000",
        //             "time": 1499865549590,
        //             "isBuyerMaker": true,
        //             "isBestMatch": true
        //         }
        //     ]
        //
        return this.parseTrades(response, market, since, limit);
    }

    public override object parseTicker(object ticker, object market = null)
    {
        //
        //     {
        //         "symbol": "ETHBTC",
        //         "priceChange": "0.00068700",
        //         "priceChangePercent": "2.075",
        //         "weightedAvgPrice": "0.03342681",
        //         "prevClosePrice": "0.03310300",
        //         "lastPrice": "0.03378900",
        //         "lastQty": "0.07700000",
        //         "bidPrice": "0.03378900",
        //         "bidQty": "7.16800000",
        //         "askPrice": "0.03379000",
        //         "askQty": "24.00000000",
        //         "openPrice": "0.03310200",
        //         "highPrice": "0.03388900",
        //         "lowPrice": "0.03306900",
        //         "volume": "205478.41000000",
        //         "quoteVolume": "6868.48826294",
        //         "openTime": 1601469986932,
        //         "closeTime": 1601556386932,
        //         "firstId": 196098772,
        //         "lastId": 196186315,
        //         "count": 87544
        //     }
        //
        // coinm
        //     {
        //         "baseVolume": "214549.95171161",
        //         "closeTime": "1621965286847",
        //         "count": "1283779",
        //         "firstId": "152560106",
        //         "highPrice": "39938.3",
        //         "lastId": "153843955",
        //         "lastPrice": "37993.4",
        //         "lastQty": "1",
        //         "lowPrice": "36457.2",
        //         "openPrice": "37783.4",
        //         "openTime": "1621878840000",
        //         "pair": "BTCUSD",
        //         "priceChange": "210.0",
        //         "priceChangePercent": "0.556",
        //         "symbol": "BTCUSD_PERP",
        //         "volume": "81990451",
        //         "weightedAvgPrice": "38215.08713747"
        //     }
        //
        object timestamp = this.safeInteger(ticker, "closeTime");
        object marketId = this.safeString(ticker, "symbol");
        object symbol = this.safeSymbol(marketId, market);
        object last = this.safeString(ticker, "lastPrice");
        object isCoinm = (inOp(ticker, "baseVolume"));
        object baseVolume = null;
        object quoteVolume = null;
        if (isTrue(isCoinm))
        {
            baseVolume = this.safeString(ticker, "baseVolume");
            quoteVolume = this.safeString(ticker, "volume");
        } else
        {
            baseVolume = this.safeString(ticker, "volume");
            quoteVolume = this.safeString(ticker, "quoteVolume");
        }
        return this.safeTicker(new Dictionary<string, object>() {
            { "symbol", symbol },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "high", this.safeString(ticker, "highPrice") },
            { "low", this.safeString(ticker, "lowPrice") },
            { "bid", this.safeString(ticker, "bidPrice") },
            { "bidVolume", this.safeString(ticker, "bidQty") },
            { "ask", this.safeString(ticker, "askPrice") },
            { "askVolume", this.safeString(ticker, "askQty") },
            { "vwap", this.safeString(ticker, "weightedAvgPrice") },
            { "open", this.safeString(ticker, "openPrice") },
            { "close", last },
            { "last", last },
            { "previousClose", this.safeString(ticker, "prevClosePrice") },
            { "change", this.safeString(ticker, "priceChange") },
            { "percentage", this.safeString(ticker, "priceChangePercent") },
            { "average", null },
            { "baseVolume", baseVolume },
            { "quoteVolume", quoteVolume },
            { "info", ticker },
        }, market);
    }

    public async override Task<object> fetchTickers(object symbols = null, object parameters = null)
    {
        /**
        * @method
        * @name tokocrypto#fetchTickers
        * @see https://binance-docs.github.io/apidocs/spot/en/#24hr-ticker-price-change-statistics
        * @description fetches price tickers for multiple markets, statistical information calculated over the past 24 hours for each market
        * @param {string[]|undefined} symbols unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/#/?id=ticker-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.binanceGetTicker24hr(parameters);
        return this.parseTickers(response, symbols);
    }

    public virtual object getMarketIdByType(object market)
    {
        if (isTrue(isEqual(getValue(market, "quote"), "USDT")))
        {
            return add(getValue(market, "baseId"), getValue(market, "quoteId"));
        }
        return getValue(market, "id");
    }

    public async override Task<object> fetchTicker(object symbol, object parameters = null)
    {
        /**
        * @method
        * @name tokocrypto#fetchTicker
        * @see https://binance-docs.github.io/apidocs/spot/en/#24hr-ticker-price-change-statistics
        * @description fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
        * @param {string} symbol unified symbol of the market to fetch the ticker for
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", add(getValue(market, "baseId"), getValue(market, "quoteId")) },
        };
        object response = await this.binanceGetTicker24hr(this.extend(request, parameters));
        if (isTrue(((response is IList<object>) || (response.GetType().IsGenericType && response.GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>))))))
        {
            object firstTicker = this.safeDict(response, 0, new Dictionary<string, object>() {});
            return this.parseTicker(firstTicker, market);
        }
        return this.parseTicker(response, market);
    }

    public async override Task<object> fetchBidsAsks(object symbols = null, object parameters = null)
    {
        /**
        * @method
        * @name tokocrypto#fetchBidsAsks
        * @see https://binance-docs.github.io/apidocs/spot/en/#symbol-order-book-ticker
        * @description fetches the bid and ask price and volume for multiple markets
        * @param {string[]|undefined} symbols unified symbols of the markets to fetch the bids and asks for, all markets are returned if not assigned
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/#/?id=ticker-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.binanceGetTickerBookTicker(parameters);
        return this.parseTickers(response, symbols);
    }

    public override object parseOHLCV(object ohlcv, object market = null)
    {
        // when api method = publicGetKlines || fapiPublicGetKlines || dapiPublicGetKlines
        //     [
        //         1591478520000, // open time
        //         "0.02501300",  // open
        //         "0.02501800",  // high
        //         "0.02500000",  // low
        //         "0.02500000",  // close
        //         "22.19000000", // volume
        //         1591478579999, // close time
        //         "0.55490906",  // quote asset volume
        //         40,            // number of trades
        //         "10.92900000", // taker buy base asset volume
        //         "0.27336462",  // taker buy quote asset volume
        //         "0"            // ignore
        //     ]
        //
        //  when api method = fapiPublicGetMarkPriceKlines || fapiPublicGetIndexPriceKlines
        //     [
        //         [
        //         1591256460000,          // Open time
        //         "9653.29201333",        // Open
        //         "9654.56401333",        // High
        //         "9653.07367333",        // Low
        //         "9653.07367333",        // Close (or latest price)
        //         "0",                    // Ignore
        //         1591256519999,          // Close time
        //         "0",                    // Ignore
        //         60,                     // Number of bisic data
        //         "0",                    // Ignore
        //         "0",                    // Ignore
        //         "0"                     // Ignore
        //         ]
        //     ]
        //
        return new List<object> {this.safeInteger(ohlcv, 0), this.safeNumber(ohlcv, 1), this.safeNumber(ohlcv, 2), this.safeNumber(ohlcv, 3), this.safeNumber(ohlcv, 4), this.safeNumber(ohlcv, 5)};
    }

    public async override Task<object> fetchOHLCV(object symbol, object timeframe = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name tokocrypto#fetchOHLCV
        * @see https://binance-docs.github.io/apidocs/spot/en/#kline-candlestick-data
        * @description fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
        * @param {string} symbol unified symbol of the market to fetch OHLCV data for
        * @param {string} timeframe the length of time each candle represents
        * @param {int} [since] timestamp in ms of the earliest candle to fetch
        * @param {int} [limit] the maximum amount of candles to fetch
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {string} [params.price] "mark" or "index" for mark price and index price candles
        * @param {int} [params.until] timestamp in ms of the latest candle to fetch
        * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
        */
        timeframe ??= "1m";
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        // binance docs say that the default limit 500, max 1500 for futures, max 1000 for spot markets
        // the reality is that the time range wider than 500 candles won't work right
        object defaultLimit = 500;
        object maxLimit = 1500;
        object price = this.safeString(parameters, "price");
        object until = this.safeInteger(parameters, "until");
        parameters = this.omit(parameters, new List<object>() {"price", "until"});
        limit = ((bool) isTrue((isEqual(limit, null)))) ? defaultLimit : mathMin(limit, maxLimit);
        object request = new Dictionary<string, object>() {
            { "interval", this.safeString(this.timeframes, timeframe, timeframe) },
            { "limit", limit },
        };
        if (isTrue(isEqual(price, "index")))
        {
            ((IDictionary<string,object>)request)["pair"] = getValue(market, "id"); // Index price takes this argument instead of symbol
        } else
        {
            ((IDictionary<string,object>)request)["symbol"] = this.getMarketIdByType(market);
        }
        // const duration = this.parseTimeframe (timeframe);
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["startTime"] = since;
        }
        if (isTrue(!isEqual(until, null)))
        {
            ((IDictionary<string,object>)request)["endTime"] = until;
        }
        object response = null;
        if (isTrue(isEqual(getValue(market, "quote"), "USDT")))
        {
            response = await this.binanceGetKlines(this.extend(request, parameters));
        } else
        {
            response = await this.publicGetOpenV1MarketKlines(this.extend(request, parameters));
        }
        //
        //     [
        //         [1591478520000,"0.02501300","0.02501800","0.02500000","0.02500000","22.19000000",1591478579999,"0.55490906",40,"10.92900000","0.27336462","0"],
        //         [1591478580000,"0.02499600","0.02500900","0.02499400","0.02500300","21.34700000",1591478639999,"0.53370468",24,"7.53800000","0.18850725","0"],
        //         [1591478640000,"0.02500800","0.02501100","0.02500300","0.02500800","154.14200000",1591478699999,"3.85405839",97,"5.32300000","0.13312641","0"],
        //     ]
        //
        object data = this.safeList(response, "data", response);
        return this.parseOHLCVs(data, market, timeframe, since, limit);
    }

    public async override Task<object> fetchBalance(object parameters = null)
    {
        /**
        * @method
        * @name tokocrypto#fetchBalance
        * @see https://www.tokocrypto.com/apidocs/#account-information-signed
        * @description query for balance and get the amount of funds available for trading or funds locked in orders
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {string} [params.type] 'future', 'delivery', 'savings', 'funding', or 'spot'
        * @param {string} [params.marginMode] 'cross' or 'isolated', for margin trading, uses this.options.defaultMarginMode if not passed, defaults to undefined/None/null
        * @param {string[]|undefined} [params.symbols] unified market symbols, only used in isolated margin mode
        * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object defaultType = this.safeString2(this.options, "fetchBalance", "defaultType", "spot");
        object type = this.safeString(parameters, "type", defaultType);
        object defaultMarginMode = this.safeString2(this.options, "marginMode", "defaultMarginMode");
        object marginMode = this.safeStringLower(parameters, "marginMode", defaultMarginMode);
        object request = new Dictionary<string, object>() {};
        object response = await this.privateGetOpenV1AccountSpot(this.extend(request, parameters));
        //
        // spot
        //
        //     {
        //         "code":0,
        //         "msg":"Success",
        //         "data":{
        //             "makerCommission":"0.00100000",
        //             "takerCommission":"0.00100000",
        //             "buyerCommission":"0.00000000",
        //             "sellerCommission":"0.00000000",
        //             "canTrade":1,
        //             "canWithdraw":1,
        //             "canDeposit":1,
        //             "status":1,
        //             "accountAssets":[
        //                 {"asset":"1INCH","free":"0","locked":"0"},
        //                 {"asset":"AAVE","free":"0","locked":"0"},
        //                 {"asset":"ACA","free":"0","locked":"0"}
        //             ],
        //         },
        //         "timestamp":1659666786943
        //     }
        //
        return this.parseBalanceCustom(response, type, marginMode);
    }

    public virtual object parseBalanceCustom(object response, object type = null, object marginMode = null)
    {
        object timestamp = this.safeInteger(response, "updateTime");
        object result = new Dictionary<string, object>() {
            { "info", response },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
        };
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        object balances = this.safeValue(data, "accountAssets", new List<object>() {});
        for (object i = 0; isLessThan(i, getArrayLength(balances)); postFixIncrement(ref i))
        {
            object balance = getValue(balances, i);
            object currencyId = this.safeString(balance, "asset");
            object code = this.safeCurrencyCode(currencyId);
            object account = this.account();
            ((IDictionary<string,object>)account)["free"] = this.safeString(balance, "free");
            ((IDictionary<string,object>)account)["used"] = this.safeString(balance, "locked");
            ((IDictionary<string,object>)result)[(string)code] = account;
        }
        return this.safeBalance(result);
    }

    public virtual object parseOrderStatus(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "-2", "open" },
            { "0", "open" },
            { "1", "open" },
            { "2", "closed" },
            { "3", "canceled" },
            { "4", "canceling" },
            { "5", "rejected" },
            { "6", "expired" },
            { "NEW", "open" },
            { "PARTIALLY_FILLED", "open" },
            { "FILLED", "closed" },
            { "CANCELED", "canceled" },
            { "PENDING_CANCEL", "canceling" },
            { "REJECTED", "rejected" },
            { "EXPIRED", "expired" },
        };
        return this.safeString(statuses, status, status);
    }

    public override object parseOrder(object order, object market = null)
    {
        //
        // spot
        //
        //     {
        //         "symbol": "LTCBTC",
        //         "orderId": 1,
        //         "clientOrderId": "myOrder1",
        //         "price": "0.1",
        //         "origQty": "1.0",
        //         "executedQty": "0.0",
        //         "cummulativeQuoteQty": "0.0",
        //         "status": "NEW",
        //         "timeInForce": "GTC",
        //         "type": "LIMIT",
        //         "side": "BUY",
        //         "stopPrice": "0.0",
        //         "icebergQty": "0.0",
        //         "time": 1499827319559,
        //         "updateTime": 1499827319559,
        //         "isWorking": true
        //     }
        // createOrder
        //     {
        //         "orderId": "145265071",
        //         "bOrderListId": "0",
        //         "clientId": "49c09c3c2cd54419a59c05441f517b3c",
        //         "bOrderId": "35247529",
        //         "symbol": "USDT_BIDR",
        //         "symbolType": "1",
        //         "side": "0",
        //         "type": "1",
        //         "price": "11915",
        //         "origQty": "2",
        //         "origQuoteQty": "23830.00",
        //         "executedQty": "0.00000000",
        //         "executedPrice": "0",
        //         "executedQuoteQty": "0.00",
        //         "timeInForce": "1",
        //         "stopPrice": "0",
        //         "icebergQty": "0",
        //         "status": "0",
        //         "createTime": "1662711074372"
        //     }
        //
        // createOrder with { "newOrderRespType": "FULL" }
        //
        //     {
        //       "symbol": "BTCUSDT",
        //       "orderId": 5403233939,
        //       "orderListId": -1,
        //       "clientOrderId": "x-R4BD3S825e669e75b6c14f69a2c43e",
        //       "transactTime": 1617151923742,
        //       "price": "0.00000000",
        //       "origQty": "0.00050000",
        //       "executedQty": "0.00050000",
        //       "cummulativeQuoteQty": "29.47081500",
        //       "status": "FILLED",
        //       "timeInForce": "GTC",
        //       "type": "MARKET",
        //       "side": "BUY",
        //       "fills": [
        //         {
        //           "price": "58941.63000000",
        //           "qty": "0.00050000",
        //           "commission": "0.00007050",
        //           "commissionAsset": "BNB",
        //           "tradeId": 737466631
        //         }
        //       ]
        //     }
        //
        // delivery
        //
        //     {
        //       "orderId": "18742727411",
        //       "symbol": "ETHUSD_PERP",
        //       "pair": "ETHUSD",
        //       "status": "FILLED",
        //       "clientOrderId": "x-xcKtGhcu3e2d1503fdd543b3b02419",
        //       "price": "0",
        //       "avgPrice": "4522.14",
        //       "origQty": "1",
        //       "executedQty": "1",
        //       "cumBase": "0.00221134",
        //       "timeInForce": "GTC",
        //       "type": "MARKET",
        //       "reduceOnly": false,
        //       "closePosition": false,
        //       "side": "SELL",
        //       "positionSide": "BOTH",
        //       "stopPrice": "0",
        //       "workingType": "CONTRACT_PRICE",
        //       "priceProtect": false,
        //       "origType": "MARKET",
        //       "time": "1636061952660",
        //       "updateTime": "1636061952660"
        //     }
        //
        object status = this.parseOrderStatus(this.safeString(order, "status"));
        object marketId = this.safeString(order, "symbol");
        object symbol = this.safeSymbol(marketId, market);
        object filled = this.safeString(order, "executedQty", "0");
        object timestamp = this.safeInteger(order, "createTime");
        object average = this.safeString(order, "avgPrice");
        object price = this.safeString2(order, "price", "executedPrice");
        object amount = this.safeString(order, "origQty");
        // - Spot/Margin market: cummulativeQuoteQty
        //   Note this is not the actual cost, since Binance futures uses leverage to calculate margins.
        object cost = this.safeStringN(order, new List<object>() {"cummulativeQuoteQty", "cumQuote", "executedQuoteQty", "cumBase"});
        object id = this.safeString(order, "orderId");
        object type = this.parseOrderType(this.safeStringLower(order, "type"));
        object side = this.safeStringLower(order, "side");
        if (isTrue(isEqual(side, "0")))
        {
            side = "buy";
        } else if (isTrue(isEqual(side, "1")))
        {
            side = "sell";
        }
        object fills = this.safeValue(order, "fills", new List<object>() {});
        object clientOrderId = this.safeString2(order, "clientOrderId", "clientId");
        object timeInForce = this.safeString(order, "timeInForce");
        if (isTrue(isEqual(timeInForce, "GTX")))
        {
            // GTX means "Good Till Crossing" and is an equivalent way of saying Post Only
            timeInForce = "PO";
        }
        object postOnly = isTrue((isEqual(type, "limit_maker"))) || isTrue((isEqual(timeInForce, "PO")));
        object stopPriceString = this.safeString(order, "stopPrice");
        object stopPrice = this.parseNumber(this.omitZero(stopPriceString));
        return this.safeOrder(new Dictionary<string, object>() {
            { "info", order },
            { "id", id },
            { "clientOrderId", clientOrderId },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "lastTradeTimestamp", null },
            { "symbol", symbol },
            { "type", type },
            { "timeInForce", timeInForce },
            { "postOnly", postOnly },
            { "reduceOnly", this.safeValue(order, "reduceOnly") },
            { "side", side },
            { "price", price },
            { "stopPrice", stopPrice },
            { "triggerPrice", stopPrice },
            { "amount", amount },
            { "cost", cost },
            { "average", average },
            { "filled", filled },
            { "remaining", null },
            { "status", status },
            { "fee", null },
            { "trades", fills },
        }, market);
    }

    public virtual object parseOrderType(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "2", "market" },
            { "1", "limit" },
            { "4", "limit" },
            { "7", "limit" },
        };
        return this.safeString(statuses, status, status);
    }

    public async override Task<object> createOrder(object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        /**
        * @method
        * @name tokocrypto#createOrder
        * @description create a trade order
        * @see https://www.tokocrypto.com/apidocs/#new-order--signed
        * @see https://www.tokocrypto.com/apidocs/#account-trade-list-signed
        * @param {string} symbol unified symbol of the market to create an order in
        * @param {string} type 'market' or 'limit'
        * @param {string} side 'buy' or 'sell'
        * @param {float} amount how much of currency you want to trade in units of base currency
        * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {float} [params.triggerPrice] the price at which a trigger order would be triggered
        * @param {float} [params.cost] for spot market buy orders, the quote quantity that can be used as an alternative for the amount
        * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object clientOrderId = this.safeString2(parameters, "clientOrderId", "clientId");
        object postOnly = this.safeBool(parameters, "postOnly", false);
        // only supported for spot/margin api
        if (isTrue(postOnly))
        {
            type = "LIMIT_MAKER";
        }
        parameters = this.omit(parameters, new List<object>() {"clientId", "clientOrderId"});
        object initialUppercaseType = ((string)type).ToUpper();
        object uppercaseType = initialUppercaseType;
        object stopPrice = this.safeValue2(parameters, "triggerPrice", "stopPrice");
        if (isTrue(!isEqual(stopPrice, null)))
        {
            parameters = this.omit(parameters, new List<object>() {"triggerPrice", "stopPrice"});
            if (isTrue(isEqual(uppercaseType, "MARKET")))
            {
                uppercaseType = "STOP_LOSS";
            } else if (isTrue(isEqual(uppercaseType, "LIMIT")))
            {
                uppercaseType = "STOP_LOSS_LIMIT";
            }
        }
        object validOrderTypes = this.safeValue(getValue(market, "info"), "orderTypes");
        if (!isTrue(this.inArray(uppercaseType, validOrderTypes)))
        {
            if (isTrue(!isEqual(initialUppercaseType, uppercaseType)))
            {
                throw new InvalidOrder ((string)add(add(add(add(add(this.id, " stopPrice parameter is not allowed for "), symbol), " "), type), " orders")) ;
            } else
            {
                throw new InvalidOrder ((string)add(add(add(add(add(this.id, " "), type), " is not a valid order type for the "), symbol), " market")) ;
            }
        }
        object reverseOrderTypeMapping = new Dictionary<string, object>() {
            { "LIMIT", 1 },
            { "MARKET", 2 },
            { "STOP_LOSS", 3 },
            { "STOP_LOSS_LIMIT", 4 },
            { "TAKE_PROFIT", 5 },
            { "TAKE_PROFIT_LIMIT", 6 },
            { "LIMIT_MAKER", 7 },
        };
        object request = new Dictionary<string, object>() {
            { "symbol", add(add(getValue(market, "baseId"), "_"), getValue(market, "quoteId")) },
            { "type", this.safeString(reverseOrderTypeMapping, uppercaseType) },
        };
        if (isTrue(isEqual(side, "buy")))
        {
            ((IDictionary<string,object>)request)["side"] = 0;
        } else if (isTrue(isEqual(side, "sell")))
        {
            ((IDictionary<string,object>)request)["side"] = 1;
        }
        if (isTrue(isEqual(clientOrderId, null)))
        {
            object broker = this.safeValue(this.options, "broker");
            if (isTrue(!isEqual(broker, null)))
            {
                object brokerId = this.safeString(broker, "marketType");
                if (isTrue(!isEqual(brokerId, null)))
                {
                    ((IDictionary<string,object>)request)["clientId"] = add(brokerId, this.uuid22());
                }
            }
        } else
        {
            ((IDictionary<string,object>)request)["clientId"] = clientOrderId;
        }
        // additional required fields depending on the order type
        object priceIsRequired = false;
        object stopPriceIsRequired = false;
        object quantityIsRequired = false;
        //
        // spot/margin
        //
        //     LIMIT                timeInForce, quantity, price
        //     MARKET               quantity or quoteOrderQty
        //     STOP_LOSS            quantity, stopPrice
        //     STOP_LOSS_LIMIT      timeInForce, quantity, price, stopPrice
        //     TAKE_PROFIT          quantity, stopPrice
        //     TAKE_PROFIT_LIMIT    timeInForce, quantity, price, stopPrice
        //     LIMIT_MAKER          quantity, price
        //
        if (isTrue(isEqual(uppercaseType, "MARKET")))
        {
            if (isTrue(isEqual(side, "buy")))
            {
                object precision = getValue(getValue(market, "precision"), "price");
                object quoteAmount = null;
                object createMarketBuyOrderRequiresPrice = true;
                var createMarketBuyOrderRequiresPriceparametersVariable = this.handleOptionAndParams(parameters, "createOrder", "createMarketBuyOrderRequiresPrice", true);
                createMarketBuyOrderRequiresPrice = ((IList<object>)createMarketBuyOrderRequiresPriceparametersVariable)[0];
                parameters = ((IList<object>)createMarketBuyOrderRequiresPriceparametersVariable)[1];
                object cost = this.safeNumber2(parameters, "cost", "quoteOrderQty");
                parameters = this.omit(parameters, new List<object>() {"cost", "quoteOrderQty"});
                if (isTrue(!isEqual(cost, null)))
                {
                    quoteAmount = cost;
                } else if (isTrue(createMarketBuyOrderRequiresPrice))
                {
                    if (isTrue(isEqual(price, null)))
                    {
                        throw new InvalidOrder ((string)add(this.id, " createOrder() requires the price argument for market buy orders to calculate the total cost to spend (amount * price), alternatively set the createMarketBuyOrderRequiresPrice option or param to false and pass the cost to spend (quote quantity) in the amount argument")) ;
                    } else
                    {
                        object amountString = this.numberToString(amount);
                        object priceString = this.numberToString(price);
                        quoteAmount = Precise.stringMul(amountString, priceString);
                    }
                } else
                {
                    quoteAmount = amount;
                }
                ((IDictionary<string,object>)request)["quoteOrderQty"] = this.decimalToPrecision(quoteAmount, TRUNCATE, precision, this.precisionMode);
            } else
            {
                quantityIsRequired = true;
            }
        } else if (isTrue(isEqual(uppercaseType, "LIMIT")))
        {
            priceIsRequired = true;
            quantityIsRequired = true;
        } else if (isTrue(isTrue((isEqual(uppercaseType, "STOP_LOSS"))) || isTrue((isEqual(uppercaseType, "TAKE_PROFIT")))))
        {
            stopPriceIsRequired = true;
            quantityIsRequired = true;
            if (isTrue(isTrue(getValue(market, "linear")) || isTrue(getValue(market, "inverse"))))
            {
                priceIsRequired = true;
            }
        } else if (isTrue(isTrue((isEqual(uppercaseType, "STOP_LOSS_LIMIT"))) || isTrue((isEqual(uppercaseType, "TAKE_PROFIT_LIMIT")))))
        {
            quantityIsRequired = true;
            stopPriceIsRequired = true;
            priceIsRequired = true;
        } else if (isTrue(isEqual(uppercaseType, "LIMIT_MAKER")))
        {
            priceIsRequired = true;
            quantityIsRequired = true;
        }
        if (isTrue(quantityIsRequired))
        {
            ((IDictionary<string,object>)request)["quantity"] = this.amountToPrecision(symbol, amount);
        }
        if (isTrue(priceIsRequired))
        {
            if (isTrue(isEqual(price, null)))
            {
                throw new InvalidOrder ((string)add(add(add(this.id, " createOrder() requires a price argument for a "), type), " order")) ;
            }
            ((IDictionary<string,object>)request)["price"] = this.priceToPrecision(symbol, price);
        }
        if (isTrue(stopPriceIsRequired))
        {
            if (isTrue(isEqual(stopPrice, null)))
            {
                throw new InvalidOrder ((string)add(add(add(this.id, " createOrder() requires a stopPrice extra param for a "), type), " order")) ;
            } else
            {
                ((IDictionary<string,object>)request)["stopPrice"] = this.priceToPrecision(symbol, stopPrice);
            }
        }
        object response = await this.privatePostOpenV1Orders(this.extend(request, parameters));
        //
        //     {
        //         "code": 0,
        //         "msg": "Success",
        //         "data": {
        //             "orderId": 145264846,
        //             "bOrderListId": 0,
        //             "clientId": "4ee2ab5e55e74b358eaf98079c670d17",
        //             "bOrderId": 35247499,
        //             "symbol": "USDT_BIDR",
        //             "symbolType": 1,
        //             "side": 0,
        //             "type": 1,
        //             "price": "11915",
        //             "origQty": "2",
        //             "origQuoteQty": "23830.00",
        //             "executedQty": "0.00000000",
        //             "executedPrice": "0",
        //             "executedQuoteQty": "0.00",
        //             "timeInForce": 1,
        //             "stopPrice": 0,
        //             "icebergQty": "0",
        //             "status": 0,
        //             "createTime": 1662710994848
        //         },
        //         "timestamp": 1662710994975
        //     }
        //
        object rawOrder = this.safeDict(response, "data", new Dictionary<string, object>() {});
        return this.parseOrder(rawOrder, market);
    }

    public async override Task<object> fetchOrder(object id, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name tokocrypto#fetchOrder
        * @see https://www.tokocrypto.com/apidocs/#all-orders-signed
        * @description fetches information on an order made by the user
        * @param {string} symbol unified symbol of the market the order was made in
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        object request = new Dictionary<string, object>() {
            { "orderId", id },
        };
        object response = await this.privateGetOpenV1Orders(this.extend(request, parameters));
        //
        //     {
        //         "code": 0,
        //         "msg": "Success",
        //         "data": {
        //             "list": [{
        //                 "orderId": "145221985",
        //                 "clientId": "201515331fd64d03aedbe687a38152e3",
        //                 "bOrderId": "35239632",
        //                 "bOrderListId": "0",
        //                 "symbol": "USDT_BIDR",
        //                 "symbolType": 1,
        //                 "side": 0,
        //                 "type": 1,
        //                 "price": "11907",
        //                 "origQty": "2",
        //                 "origQuoteQty": "23814",
        //                 "executedQty": "0",
        //                 "executedPrice": "0",
        //                 "executedQuoteQty": "0",
        //                 "timeInForce": 1,
        //                 "stopPrice": "0",
        //                 "icebergQty": "0",
        //                 "status": 0,
        //                 "createTime": 1662699360000
        //             }]
        //         },
        //         "timestamp": 1662710056523
        //     }
        //
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        object list = this.safeValue(data, "list", new List<object>() {});
        object rawOrder = this.safeDict(list, 0, new Dictionary<string, object>() {});
        return this.parseOrder(rawOrder);
    }

    public async override Task<object> fetchOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name tokocrypto#fetchOrders
        * @see https://www.tokocrypto.com/apidocs/#all-orders-signed
        * @description fetches information on multiple orders made by the user
        * @param {string} symbol unified market symbol of the market orders were made in
        * @param {int} [since] the earliest time in ms to fetch orders for
        * @param {int} [limit] the maximum number of order structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchOrders() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["startTime"] = since;
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        object response = await this.privateGetOpenV1Orders(this.extend(request, parameters));
        //
        //     {
        //         "code": 0,
        //         "msg": "success",
        //         "data": {
        //             "list": [
        //                 {
        //                     "orderId": "4", // order id
        //                     "bOrderId": "100001", // binance order id
        //                     "bOrderListId": -1, // Unless part of an OCO, the value will always be -1.
        //                     "clientId": "1aa4f99ad7bc4fab903395afd25d0597", // client custom order id
        //                     "symbol": "ADA_USDT",
        //                     "symbolType": 1,
        //                     "side": 1,
        //                     "type": 1,
        //                     "price": "0.1",
        //                     "origQty": "10",
        //                     "origQuoteQty": "1",
        //                     "executedQty": "0",
        //                     "executedPrice": "0",
        //                     "executedQuoteQty": "0",
        //                     "timeInForce": 1,
        //                     "stopPrice": "0.0000000000000000",
        //                     "icebergQty": "0.0000000000000000",
        //                     "status": 0,
        //                     "isWorking": 0,
        //                     "createTime": 1572692016811
        //                 }
        //             ]
        //         },
        //         "timestamp": 1572860756458
        //     }
        //
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        object orders = this.safeList(data, "list", new List<object>() {});
        return this.parseOrders(orders, market, since, limit);
    }

    public async override Task<object> fetchOpenOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name tokocrypto#fetchOpenOrders
        * @see https://www.tokocrypto.com/apidocs/#all-orders-signed
        * @description fetch all unfilled currently open orders
        * @param {string} symbol unified market symbol
        * @param {int} [since] the earliest time in ms to fetch open orders for
        * @param {int} [limit] the maximum number of  open orders structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        object request = new Dictionary<string, object>() {
            { "type", 1 },
        }; // -1 = all, 1 = open, 2 = closed
        return await this.fetchOrders(symbol, since, limit, this.extend(request, parameters));
    }

    public async override Task<object> fetchClosedOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name tokocrypto#fetchClosedOrders
        * @see https://www.tokocrypto.com/apidocs/#all-orders-signed
        * @description fetches information on multiple closed orders made by the user
        * @param {string} symbol unified market symbol of the market orders were made in
        * @param {int} [since] the earliest time in ms to fetch orders for
        * @param {int} [limit] the maximum number of order structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        object request = new Dictionary<string, object>() {
            { "type", 2 },
        }; // -1 = all, 1 = open, 2 = closed
        return await this.fetchOrders(symbol, since, limit, this.extend(request, parameters));
    }

    public async override Task<object> cancelOrder(object id, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name tokocrypto#cancelOrder
        * @see https://www.tokocrypto.com/apidocs/#cancel-order-signed
        * @description cancels an open order
        * @param {string} id order id
        * @param {string} symbol unified symbol of the market the order was made in
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        object request = new Dictionary<string, object>() {
            { "orderId", id },
        };
        object response = await this.privatePostOpenV1OrdersCancel(this.extend(request, parameters));
        //
        //     {
        //         "code": 0,
        //         "msg": "Success",
        //         "data": {
        //             "orderId": "145221985",
        //             "bOrderListId": "0",
        //             "clientId": "201515331fd64d03aedbe687a38152e3",
        //             "bOrderId": "35239632",
        //             "symbol": "USDT_BIDR",
        //             "symbolType": 1,
        //             "type": 1,
        //             "side": 0,
        //             "price": "11907.0000000000000000",
        //             "origQty": "2.0000000000000000",
        //             "origQuoteQty": "23814.0000000000000000",
        //             "executedPrice": "0.0000000000000000",
        //             "executedQty": "0.00000000",
        //             "executedQuoteQty": "0.00",
        //             "timeInForce": 1,
        //             "stopPrice": "0.0000000000000000",
        //             "icebergQty": "0.0000000000000000",
        //             "status": 3
        //         },
        //         "timestamp": 1662710683634
        //     }
        //
        object rawOrder = this.safeDict(response, "data", new Dictionary<string, object>() {});
        return this.parseOrder(rawOrder);
    }

    public async override Task<object> fetchMyTrades(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name tokocrypto#fetchMyTrades
        * @see https://www.tokocrypto.com/apidocs/#account-trade-list-signed
        * @description fetch all trades made by the user
        * @param {string} symbol unified market symbol
        * @param {int} [since] the earliest time in ms to fetch trades for
        * @param {int} [limit] the maximum number of trades structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
        */
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchMyTrades() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object endTime = this.safeInteger2(parameters, "until", "endTime");
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["startTime"] = since;
        }
        if (isTrue(!isEqual(endTime, null)))
        {
            ((IDictionary<string,object>)request)["endTime"] = endTime;
            parameters = this.omit(parameters, new List<object>() {"endTime", "until"});
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        object response = await this.privateGetOpenV1OrdersTrades(this.extend(request, parameters));
        //
        //     {
        //         "code": 0,
        //         "msg": "success",
        //         "data": {
        //             "list": [
        //                 {
        //                     "tradeId": "3",
        //                     "orderId": "2",
        //                     "symbol": "ADA_USDT",
        //                     "price": "0.04398",
        //                     "qty": "250",
        //                     "quoteQty": "10.995",
        //                     "commission": "0.25",
        //                     "commissionAsset": "ADA",
        //                     "isBuyer": 1,
        //                     "isMaker": 0,
        //                     "isBestMatch": 1,
        //                     "time": "1572920872276"
        //                 }
        //             ]
        //         },
        //         "timestamp": 1573723498893
        //     }
        //
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        object trades = this.safeList(data, "list", new List<object>() {});
        return this.parseTrades(trades, market, since, limit);
    }

    public async override Task<object> fetchDepositAddress(object code, object parameters = null)
    {
        /**
        * @method
        * @name tokocrypto#fetchDepositAddress
        * @description fetch the deposit address for a currency associated with this account
        * @see https://www.tokocrypto.com/apidocs/#deposit-address-signed
        * @param {string} code unified currency code
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} an [address structure]{@link https://docs.ccxt.com/#/?id=address-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "asset", getValue(currency, "id") },
        };
        object networks = this.safeValue(this.options, "networks", new Dictionary<string, object>() {});
        object network = this.safeStringUpper(parameters, "network"); // this line allows the user to specify either ERC20 or ETH
        network = this.safeString(networks, network, network); // handle ERC20>ETH alias
        if (isTrue(!isEqual(network, null)))
        {
            ((IDictionary<string,object>)request)["network"] = network;
            parameters = this.omit(parameters, "network");
        }
        // has support for the 'network' parameter
        // https://binance-docs.github.io/apidocs/spot/en/#deposit-address-supporting-network-user_data
        object response = await this.privateGetOpenV1DepositsAddress(this.extend(request, parameters));
        //
        //     {
        //         "code":0,
        //         "msg":"Success",
        //         "data":{
        //             "uid":"182395",
        //             "asset":"USDT",
        //             "network":"ETH",
        //             "address":"0x101a925704f6ff13295ab8dd7a60988d116aaedf",
        //             "addressTag":"",
        //             "status":1
        //         },
        //         "timestamp":1660685915746
        //     }
        //
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        object address = this.safeString(data, "address");
        object tag = this.safeString(data, "addressTag", "");
        if (isTrue(isEqual(((string)tag).Length, 0)))
        {
            tag = null;
        }
        this.checkAddress(address);
        return new Dictionary<string, object>() {
            { "info", response },
            { "currency", code },
            { "network", this.safeString(data, "network") },
            { "address", address },
            { "tag", tag },
        };
    }

    public async override Task<object> fetchDeposits(object code = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name tokocrypto#fetchDeposits
        * @see https://www.tokocrypto.com/apidocs/#deposit-history-signed
        * @description fetch all deposits made to an account
        * @param {string} code unified currency code
        * @param {int} [since] the earliest time in ms to fetch deposits for
        * @param {int} [limit] the maximum number of deposits structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {int} [params.until] the latest time in ms to fetch deposits for
        * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = null;
        object request = new Dictionary<string, object>() {};
        object until = this.safeInteger(parameters, "until");
        if (isTrue(!isEqual(code, null)))
        {
            currency = this.currency(code);
            ((IDictionary<string,object>)request)["coin"] = getValue(currency, "id");
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["startTime"] = since;
            // max 3 months range https://github.com/ccxt/ccxt/issues/6495
            object endTime = this.sum(since, 7776000000);
            if (isTrue(!isEqual(until, null)))
            {
                endTime = mathMin(endTime, until);
            }
            ((IDictionary<string,object>)request)["endTime"] = endTime;
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        object response = await this.privateGetOpenV1Deposits(this.extend(request, parameters));
        //
        //     {
        //         "code":0,
        //         "msg":"Success",
        //         "data":{
        //             "list":[
        //                 {
        //                     "id":5167969,
        //                     "asset":"BIDR",
        //                     "network":"BSC",
        //                     "address":"0x101a925704f6ff13295ab8dd7a60988d116aaedf",
        //                     "addressTag":"",
        //                     "txId":"113409337867",
        //                     "amount":"15000",
        //                     "transferType":1,
        //                     "status":1,
        //                     "insertTime":"1659429390000"
        //                 },
        //             ]
        //         },
        //         "timestamp":1659758865998
        //     }
        //
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        object deposits = this.safeList(data, "list", new List<object>() {});
        return this.parseTransactions(deposits, currency, since, limit);
    }

    public async override Task<object> fetchWithdrawals(object code = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name tokocrypto#fetchWithdrawals
        * @see https://www.tokocrypto.com/apidocs/#withdraw-signed
        * @description fetch all withdrawals made from an account
        * @param {string} code unified currency code
        * @param {int} [since] the earliest time in ms to fetch withdrawals for
        * @param {int} [limit] the maximum number of withdrawals structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object currency = null;
        if (isTrue(!isEqual(code, null)))
        {
            currency = this.currency(code);
            ((IDictionary<string,object>)request)["coin"] = getValue(currency, "id");
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["startTime"] = since;
            // max 3 months range https://github.com/ccxt/ccxt/issues/6495
            ((IDictionary<string,object>)request)["endTime"] = this.sum(since, 7776000000);
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        object response = await this.privateGetOpenV1Withdraws(this.extend(request, parameters));
        //
        //     {
        //         "code":0,
        //         "msg":"Success",
        //         "data":{
        //             "list":[
        //                 {
        //                     "id":4245859,
        //                     "clientId":"198",
        //                     "asset":"BIDR",
        //                     "network":"BSC",
        //                     "address":"0xff1c75149cc492e7d5566145b859fcafc900b6e9",
        //                     "addressTag":"",
        //                     "amount":"10000",
        //                     "fee":"0",
        //                     "txId":"113501794501",
        //                     "transferType":1,
        //                     "status":10,
        //                     "createTime":1659521314413
        //                 }
        //             ]
        //         },
        //         "timestamp":1659759062187
        //     }
        //
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        object withdrawals = this.safeList(data, "list", new List<object>() {});
        return this.parseTransactions(withdrawals, currency, since, limit);
    }

    public virtual object parseTransactionStatusByType(object status, object type = null)
    {
        object statusesByType = new Dictionary<string, object>() {
            { "deposit", new Dictionary<string, object>() {
                { "0", "pending" },
                { "1", "ok" },
            } },
            { "withdrawal", new Dictionary<string, object>() {
                { "0", "pending" },
                { "1", "canceled" },
                { "2", "pending" },
                { "3", "failed" },
                { "4", "pending" },
                { "5", "failed" },
                { "10", "ok" },
            } },
        };
        object statuses = this.safeValue(statusesByType, type, new Dictionary<string, object>() {});
        return this.safeString(statuses, status, status);
    }

    public override object parseTransaction(object transaction, object currency = null)
    {
        //
        // fetchDeposits
        //
        //     {
        //         "id": 5167969,
        //         "asset": "BIDR",
        //         "network": "BSC",
        //         "address": "0x101a925704f6ff13295ab8dd7a60988d116aaedf",
        //         "addressTag": "",
        //         "txId": "113409337867",
        //         "amount": "15000",
        //         "transferType": 1,
        //         "status": 1,
        //         "insertTime": "1659429390000"
        //     }
        //
        // fetchWithdrawals
        //
        //     {
        //         "id": 4245859,
        //         "clientId": "198",
        //         "asset": "BIDR",
        //         "network": "BSC",
        //         "address": "0xff1c75149cc492e7d5566145b859fcafc900b6e9",
        //         "addressTag": "",
        //         "amount": "10000",
        //         "fee": "0",
        //         "txId": "113501794501",
        //         "transferType": 1,
        //         "status": 10,
        //         "createTime": 1659521314413
        //     }
        //
        // withdraw
        //
        //     {
        //         "code": 0,
        //         "msg": "",
        //         "data": {
        //             "withdrawId":"12"
        //         },
        //         "timestamp": 1571745049095
        //     }
        //
        object address = this.safeString(transaction, "address");
        object tag = this.safeString(transaction, "addressTag"); // set but unused
        if (isTrue(!isEqual(tag, null)))
        {
            if (isTrue(isLessThan(((string)tag).Length, 1)))
            {
                tag = null;
            }
        }
        object txid = this.safeString(transaction, "txId");
        if (isTrue(isTrue((!isEqual(txid, null))) && isTrue((isGreaterThanOrEqual(getIndexOf(txid, "Internal transfer "), 0)))))
        {
            txid = slice(txid, 18, null);
        }
        object currencyId = this.safeString2(transaction, "coin", "fiatCurrency");
        object code = this.safeCurrencyCode(currencyId, currency);
        object timestamp = null;
        object insertTime = this.safeInteger(transaction, "insertTime");
        object createTime = this.safeInteger2(transaction, "createTime", "timestamp");
        object type = this.safeString(transaction, "type");
        if (isTrue(isEqual(type, null)))
        {
            if (isTrue(isTrue((!isEqual(insertTime, null))) && isTrue((isEqual(createTime, null)))))
            {
                type = "deposit";
                timestamp = insertTime;
            } else if (isTrue(isTrue((isEqual(insertTime, null))) && isTrue((!isEqual(createTime, null)))))
            {
                type = "withdrawal";
                timestamp = createTime;
            }
        }
        object feeCost = this.safeNumber2(transaction, "transactionFee", "totalFee");
        object fee = new Dictionary<string, object>() {
            { "currency", null },
            { "cost", null },
            { "rate", null },
        };
        if (isTrue(!isEqual(feeCost, null)))
        {
            ((IDictionary<string,object>)fee)["currency"] = code;
            ((IDictionary<string,object>)fee)["cost"] = feeCost;
        }
        object internalRaw = this.safeInteger(transaction, "transferType");
        object intern = false;
        if (isTrue(!isEqual(internalRaw, null)))
        {
            intern = true;
        }
        object id = this.safeString(transaction, "id");
        if (isTrue(isEqual(id, null)))
        {
            object data = this.safeValue(transaction, "data", new Dictionary<string, object>() {});
            id = this.safeString(data, "withdrawId");
            type = "withdrawal";
        }
        return new Dictionary<string, object>() {
            { "info", transaction },
            { "id", id },
            { "txid", txid },
            { "type", type },
            { "currency", code },
            { "network", this.safeString(transaction, "network") },
            { "amount", this.safeNumber(transaction, "amount") },
            { "status", this.parseTransactionStatusByType(this.safeString(transaction, "status"), type) },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "address", address },
            { "addressFrom", null },
            { "addressTo", address },
            { "tag", tag },
            { "tagFrom", null },
            { "tagTo", tag },
            { "updated", this.safeInteger2(transaction, "successTime", "updateTime") },
            { "comment", null },
            { "internal", intern },
            { "fee", fee },
        };
    }

    public async override Task<object> withdraw(object code, object amount, object address, object tag = null, object parameters = null)
    {
        /**
        * @method
        * @name bybit#withdraw
        * @see https://www.tokocrypto.com/apidocs/#withdraw-signed
        * @description make a withdrawal
        * @param {string} code unified currency code
        * @param {float} amount the amount to withdraw
        * @param {string} address the address to withdraw to
        * @param {string} tag
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
        */
        parameters ??= new Dictionary<string, object>();
        var tagparametersVariable = this.handleWithdrawTagAndParams(tag, parameters);
        tag = ((IList<object>)tagparametersVariable)[0];
        parameters = ((IList<object>)tagparametersVariable)[1];
        await this.loadMarkets();
        this.checkAddress(address);
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "asset", getValue(currency, "id") },
            { "address", address },
            { "amount", this.numberToString(amount) },
        };
        if (isTrue(!isEqual(tag, null)))
        {
            ((IDictionary<string,object>)request)["addressTag"] = tag;
        }
        var networkCodequeryVariable = this.handleNetworkCodeAndParams(parameters);
        var networkCode = ((IList<object>) networkCodequeryVariable)[0];
        var query = ((IList<object>) networkCodequeryVariable)[1];
        object networkId = this.networkCodeToId(networkCode);
        if (isTrue(!isEqual(networkId, null)))
        {
            ((IDictionary<string,object>)request)["network"] = ((string)networkId).ToUpper();
        }
        object response = await this.privatePostOpenV1Withdraws(this.extend(request, query));
        //
        //     {
        //         "code": 0,
        //         "msg": "",
        //         "data": {
        //             "withdrawId":"12"
        //         },
        //         "timestamp": 1571745049095
        //     }
        //
        return this.parseTransaction(response, currency);
    }

    public override object sign(object path, object api = null, object method = null, object parameters = null, object headers = null, object body = null)
    {
        api ??= "public";
        method ??= "GET";
        parameters ??= new Dictionary<string, object>();
        if (!isTrue((inOp(getValue(getValue(this.urls, "api"), "rest"), api))))
        {
            throw new NotSupported ((string)add(add(add(this.id, " does not have a testnet/sandbox URL for "), api), " endpoints")) ;
        }
        object url = getValue(getValue(getValue(this.urls, "api"), "rest"), api);
        url = add(url, add("/", path));
        if (isTrue(isEqual(api, "wapi")))
        {
            url = add(url, ".html");
        }
        object userDataStream = isTrue((isEqual(path, "userDataStream"))) || isTrue((isEqual(path, "listenKey")));
        if (isTrue(userDataStream))
        {
            if (isTrue(this.apiKey))
            {
                // v1 special case for userDataStream
                headers = new Dictionary<string, object>() {
                    { "X-MBX-APIKEY", this.apiKey },
                    { "Content-Type", "application/x-www-form-urlencoded" },
                };
                if (isTrue(!isEqual(method, "GET")))
                {
                    body = this.urlencode(parameters);
                }
            } else
            {
                throw new AuthenticationError ((string)add(this.id, " userDataStream endpoint requires `apiKey` credential")) ;
            }
        } else if (isTrue(isTrue(isTrue(isTrue(isTrue(isTrue(isTrue(isTrue((isEqual(api, "private"))) || isTrue((isTrue(isEqual(api, "sapi")) && isTrue(!isEqual(path, "system/status"))))) || isTrue((isEqual(api, "sapiV3")))) || isTrue((isTrue(isEqual(api, "wapi")) && isTrue(!isEqual(path, "systemStatus"))))) || isTrue((isEqual(api, "dapiPrivate")))) || isTrue((isEqual(api, "dapiPrivateV2")))) || isTrue((isEqual(api, "fapiPrivate")))) || isTrue((isEqual(api, "fapiPrivateV2")))))
        {
            this.checkRequiredCredentials();
            object query = null;
            object defaultRecvWindow = this.safeInteger(this.options, "recvWindow");
            object extendedParams = this.extend(new Dictionary<string, object>() {
                { "timestamp", this.nonce() },
            }, parameters);
            if (isTrue(!isEqual(defaultRecvWindow, null)))
            {
                ((IDictionary<string,object>)extendedParams)["recvWindow"] = defaultRecvWindow;
            }
            object recvWindow = this.safeInteger(parameters, "recvWindow");
            if (isTrue(!isEqual(recvWindow, null)))
            {
                ((IDictionary<string,object>)extendedParams)["recvWindow"] = recvWindow;
            }
            if (isTrue(isTrue((isEqual(api, "sapi"))) && isTrue((isEqual(path, "asset/dust")))))
            {
                query = this.urlencodeWithArrayRepeat(extendedParams);
            } else if (isTrue(isTrue(isTrue(isTrue((isEqual(path, "batchOrders"))) || isTrue((isGreaterThanOrEqual(getIndexOf(path, "sub-account"), 0)))) || isTrue((isEqual(path, "capital/withdraw/apply")))) || isTrue((isGreaterThanOrEqual(getIndexOf(path, "staking"), 0)))))
            {
                query = this.rawencode(extendedParams);
            } else
            {
                query = this.urlencode(extendedParams);
            }
            object signature = this.hmac(this.encode(query), this.encode(this.secret), sha256);
            query = add(query, add(add("&", "signature="), signature));
            headers = new Dictionary<string, object>() {
                { "X-MBX-APIKEY", this.apiKey },
            };
            if (isTrue(isTrue(isTrue((isEqual(method, "GET"))) || isTrue((isEqual(method, "DELETE")))) || isTrue((isEqual(api, "wapi")))))
            {
                url = add(url, add("?", query));
            } else
            {
                body = query;
                ((IDictionary<string,object>)headers)["Content-Type"] = "application/x-www-form-urlencoded";
            }
        } else
        {
            if (isTrue(getArrayLength(new List<object>(((IDictionary<string,object>)parameters).Keys))))
            {
                url = add(url, add("?", this.urlencode(parameters)));
            }
        }
        return new Dictionary<string, object>() {
            { "url", url },
            { "method", method },
            { "body", body },
            { "headers", headers },
        };
    }

    public override object handleErrors(object code, object reason, object url, object method, object headers, object body, object response, object requestHeaders, object requestBody)
    {
        if (isTrue(isTrue((isEqual(code, 418))) || isTrue((isEqual(code, 429)))))
        {
            throw new DDoSProtection ((string)add(add(add(add(add(add(this.id, " "), ((object)code).ToString()), " "), reason), " "), body)) ;
        }
        // error response in a form: { "code": -1013, "msg": "Invalid quantity." }
        // following block cointains legacy checks against message patterns in "msg" property
        // will switch "code" checks eventually, when we know all of them
        if (isTrue(isGreaterThanOrEqual(code, 400)))
        {
            if (isTrue(isGreaterThanOrEqual(getIndexOf(body, "Price * QTY is zero or less"), 0)))
            {
                throw new InvalidOrder ((string)add(add(this.id, " order cost = amount * price is zero or less "), body)) ;
            }
            if (isTrue(isGreaterThanOrEqual(getIndexOf(body, "LOT_SIZE"), 0)))
            {
                throw new InvalidOrder ((string)add(add(this.id, " order amount should be evenly divisible by lot size "), body)) ;
            }
            if (isTrue(isGreaterThanOrEqual(getIndexOf(body, "PRICE_FILTER"), 0)))
            {
                throw new InvalidOrder ((string)add(add(this.id, " order price is invalid, i.e. exceeds allowed price precision, exceeds min price or max price limits or is invalid value in general, use this.priceToPrecision (symbol, amount) "), body)) ;
            }
        }
        if (isTrue(isEqual(response, null)))
        {
            return null;  // fallback to default error handler
        }
        // check success value for wapi endpoints
        // response in format {'msg': 'The coin does not exist.', 'success': true/false}
        object success = this.safeBool(response, "success", true);
        if (!isTrue(success))
        {
            object messageInner = this.safeString(response, "msg");
            object parsedMessage = null;
            if (isTrue(!isEqual(messageInner, null)))
            {
                try
                {
                    parsedMessage = parseJson(messageInner);
                } catch(Exception e)
                {
                    // do nothing
                    parsedMessage = null;
                }
                if (isTrue(!isEqual(parsedMessage, null)))
                {
                    response = parsedMessage;
                }
            }
        }
        object message = this.safeString(response, "msg");
        if (isTrue(!isEqual(message, null)))
        {
            this.throwExactlyMatchedException(getValue(this.exceptions, "exact"), message, add(add(this.id, " "), message));
            this.throwBroadlyMatchedException(getValue(this.exceptions, "broad"), message, add(add(this.id, " "), message));
        }
        // checks against error codes
        object error = this.safeString(response, "code");
        if (isTrue(!isEqual(error, null)))
        {
            // https://github.com/ccxt/ccxt/issues/6501
            // https://github.com/ccxt/ccxt/issues/7742
            if (isTrue(isTrue((isEqual(error, "200"))) || isTrue(Precise.stringEquals(error, "0"))))
            {
                return null;
            }
            // a workaround for {"code":-2015,"msg":"Invalid API-key, IP, or permissions for action."}
            // despite that their message is very confusing, it is raised by Binance
            // on a temporary ban, the API key is valid, but disabled for a while
            if (isTrue(isTrue((isEqual(error, "-2015"))) && isTrue(getValue(this.options, "hasAlreadyAuthenticatedSuccessfully"))))
            {
                throw new DDoSProtection ((string)add(add(this.id, " "), body)) ;
            }
            object feedback = add(add(this.id, " "), body);
            if (isTrue(isEqual(message, "No need to change margin type.")))
            {
                throw new MarginModeAlreadySet ((string)feedback) ;
            }
            this.throwExactlyMatchedException(getValue(this.exceptions, "exact"), error, feedback);
            throw new ExchangeError ((string)feedback) ;
        }
        if (!isTrue(success))
        {
            throw new ExchangeError ((string)add(add(this.id, " "), body)) ;
        }
        return null;
    }

    public override object calculateRateLimiterCost(object api, object method, object path, object parameters, object config = null)
    {
        config ??= new Dictionary<string, object>();
        if (isTrue(isTrue((inOp(config, "noCoin"))) && !isTrue((inOp(parameters, "coin")))))
        {
            return getValue(config, "noCoin");
        } else if (isTrue(isTrue((inOp(config, "noSymbol"))) && !isTrue((inOp(parameters, "symbol")))))
        {
            return getValue(config, "noSymbol");
        } else if (isTrue(isTrue((inOp(config, "noPoolId"))) && !isTrue((inOp(parameters, "poolId")))))
        {
            return getValue(config, "noPoolId");
        } else if (isTrue(isTrue((inOp(config, "byLimit"))) && isTrue((inOp(parameters, "limit")))))
        {
            object limit = getValue(parameters, "limit");
            object byLimit = ((object)getValue(config, "byLimit"));
            for (object i = 0; isLessThan(i, getArrayLength(byLimit)); postFixIncrement(ref i))
            {
                object entry = getValue(byLimit, i);
                if (isTrue(isLessThanOrEqual(limit, getValue(entry, 0))))
                {
                    return getValue(entry, 1);
                }
            }
        }
        return this.safeInteger(config, "cost", 1);
    }
}
