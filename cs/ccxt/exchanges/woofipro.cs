namespace ccxt;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

public partial class woofipro : Exchange
{
    public override object describe()
    {
        return this.deepExtend(base.describe(), new Dictionary<string, object>() {
            { "id", "woofipro" },
            { "name", "WOOFI PRO" },
            { "countries", new List<object>() {"KY"} },
            { "rateLimit", 100 },
            { "version", "v1" },
            { "certified", true },
            { "pro", true },
            { "dex", true },
            { "hostname", "dex.woo.org" },
            { "has", new Dictionary<string, object>() {
                { "CORS", null },
                { "spot", false },
                { "margin", false },
                { "swap", true },
                { "future", false },
                { "option", false },
                { "addMargin", false },
                { "cancelAllOrders", true },
                { "cancelOrder", true },
                { "cancelOrders", true },
                { "cancelWithdraw", false },
                { "closeAllPositions", false },
                { "closePosition", false },
                { "createConvertTrade", false },
                { "createDepositAddress", false },
                { "createMarketBuyOrderWithCost", false },
                { "createMarketOrder", false },
                { "createMarketOrderWithCost", false },
                { "createMarketSellOrderWithCost", false },
                { "createOrder", true },
                { "createOrderWithTakeProfitAndStopLoss", true },
                { "createReduceOnlyOrder", true },
                { "createStopLimitOrder", false },
                { "createStopLossOrder", true },
                { "createStopMarketOrder", false },
                { "createStopOrder", false },
                { "createTakeProfitOrder", true },
                { "createTrailingAmountOrder", false },
                { "createTrailingPercentOrder", false },
                { "createTriggerOrder", true },
                { "fetchAccounts", false },
                { "fetchBalance", true },
                { "fetchCanceledOrders", false },
                { "fetchClosedOrder", false },
                { "fetchClosedOrders", true },
                { "fetchConvertCurrencies", false },
                { "fetchConvertQuote", false },
                { "fetchCurrencies", true },
                { "fetchDepositAddress", false },
                { "fetchDeposits", true },
                { "fetchDepositsWithdrawals", true },
                { "fetchFundingHistory", true },
                { "fetchFundingRate", true },
                { "fetchFundingRateHistory", true },
                { "fetchFundingRates", true },
                { "fetchIndexOHLCV", false },
                { "fetchLedger", true },
                { "fetchLeverage", true },
                { "fetchMarginAdjustmentHistory", false },
                { "fetchMarginMode", false },
                { "fetchMarkets", true },
                { "fetchMarkOHLCV", false },
                { "fetchMyTrades", true },
                { "fetchOHLCV", true },
                { "fetchOpenInterestHistory", false },
                { "fetchOpenOrder", false },
                { "fetchOpenOrders", true },
                { "fetchOrder", true },
                { "fetchOrderBook", true },
                { "fetchOrders", true },
                { "fetchOrderTrades", true },
                { "fetchPosition", true },
                { "fetchPositionMode", false },
                { "fetchPositions", true },
                { "fetchPremiumIndexOHLCV", false },
                { "fetchStatus", true },
                { "fetchTicker", false },
                { "fetchTickers", false },
                { "fetchTime", true },
                { "fetchTrades", true },
                { "fetchTradingFee", false },
                { "fetchTradingFees", true },
                { "fetchTransactions", "emulated" },
                { "fetchTransfers", false },
                { "fetchWithdrawals", true },
                { "reduceMargin", false },
                { "setLeverage", true },
                { "setMargin", false },
                { "setPositionMode", false },
                { "transfer", false },
                { "withdraw", true },
            } },
            { "timeframes", new Dictionary<string, object>() {
                { "1m", "1m" },
                { "5m", "5m" },
                { "15m", "15m" },
                { "30m", "30m" },
                { "1h", "1h" },
                { "4h", "4h" },
                { "12h", "12h" },
                { "1d", "1d" },
                { "1w", "1w" },
                { "1M", "1mon" },
                { "1y", "1y" },
            } },
            { "urls", new Dictionary<string, object>() {
                { "logo", "https://github.com/ccxt/ccxt/assets/43336371/b1e7b348-a0fc-4605-8b7f-91176958fd69" },
                { "api", new Dictionary<string, object>() {
                    { "public", "https://api-evm.orderly.org" },
                    { "private", "https://api-evm.orderly.org" },
                } },
                { "test", new Dictionary<string, object>() {
                    { "public", "https://testnet-api-evm.orderly.org" },
                    { "private", "https://testnet-api-evm.orderly.org" },
                } },
                { "www", "https://dex.woo.org" },
                { "doc", new List<object>() {"https://orderly.network/docs/build-on-evm/building-on-evm"} },
                { "fees", new List<object>() {"https://dex.woo.org/en/orderly"} },
                { "referral", new Dictionary<string, object>() {
                    { "url", "https://dex.woo.org/en/trade?ref=CCXT" },
                    { "discount", 0.05 },
                } },
            } },
            { "api", new Dictionary<string, object>() {
                { "v1", new Dictionary<string, object>() {
                    { "public", new Dictionary<string, object>() {
                        { "get", new Dictionary<string, object>() {
                            { "public/volume/stats", 1 },
                            { "public/broker/name", 1 },
                            { "public/chain_info/{broker_id}", 1 },
                            { "public/system_info", 1 },
                            { "public/vault_balance", 1 },
                            { "public/insurancefund", 1 },
                            { "public/chain_info", 1 },
                            { "faucet/usdc", 1 },
                            { "public/account", 1 },
                            { "get_account", 1 },
                            { "registration_nonce", 1 },
                            { "get_orderly_key", 1 },
                            { "public/liquidation", 1 },
                            { "public/liquidated_positions", 1 },
                            { "public/config", 1 },
                            { "public/campaign/ranking", 10 },
                            { "public/campaign/stats", 10 },
                            { "public/campaign/user", 10 },
                            { "public/campaign/stats/details", 10 },
                            { "public/campaigns", 10 },
                            { "public/points/leaderboard", 1 },
                            { "client/points", 1 },
                            { "public/points/epoch", 1 },
                            { "public/points/epoch_dates", 1 },
                            { "public/referral/check_ref_code", 1 },
                            { "public/referral/verify_ref_code", 1 },
                            { "referral/admin_info", 1 },
                            { "referral/info", 1 },
                            { "referral/referee_info", 1 },
                            { "referral/referee_rebate_summary", 1 },
                            { "referral/referee_history", 1 },
                            { "referral/referral_history", 1 },
                            { "referral/rebate_summary", 1 },
                            { "client/distribution_history", 1 },
                            { "tv/config", 1 },
                            { "tv/history", 1 },
                            { "tv/symbol_info", 1 },
                            { "public/funding_rate_history", 1 },
                            { "public/funding_rate/{symbol}", 0.33 },
                            { "public/funding_rates", 1 },
                            { "public/info", 1 },
                            { "public/info/{symbol}", 1 },
                            { "public/market_trades", 1 },
                            { "public/token", 1 },
                            { "public/futures", 1 },
                            { "public/futures/{symbol}", 1 },
                        } },
                        { "post", new Dictionary<string, object>() {
                            { "register_account", 1 },
                        } },
                    } },
                    { "private", new Dictionary<string, object>() {
                        { "get", new Dictionary<string, object>() {
                            { "client/key_info", 6 },
                            { "client/orderly_key_ip_restriction", 6 },
                            { "order/{oid}", 1 },
                            { "client/order/{client_order_id}", 1 },
                            { "algo/order/{oid}", 1 },
                            { "algo/client/order/{client_order_id}", 1 },
                            { "orders", 1 },
                            { "algo/orders", 1 },
                            { "trade/{tid}", 1 },
                            { "trades", 1 },
                            { "order/{oid}/trades", 1 },
                            { "client/liquidator_liquidations", 1 },
                            { "liquidations", 1 },
                            { "asset/history", 60 },
                            { "client/holding", 1 },
                            { "withdraw_nonce", 1 },
                            { "settle_nonce", 1 },
                            { "pnl_settlement/history", 1 },
                            { "volume/user/daily", 60 },
                            { "volume/user/stats", 60 },
                            { "client/statistics", 60 },
                            { "client/info", 60 },
                            { "client/statistics/daily", 60 },
                            { "positions", 3.33 },
                            { "position/{symbol}", 3.33 },
                            { "funding_fee/history", 30 },
                            { "notification/inbox/notifications", 60 },
                            { "notification/inbox/unread", 60 },
                            { "volume/broker/daily", 60 },
                            { "broker/fee_rate/default", 10 },
                            { "broker/user_info", 10 },
                            { "orderbook/{symbol}", 1 },
                            { "kline", 1 },
                        } },
                        { "post", new Dictionary<string, object>() {
                            { "orderly_key", 1 },
                            { "client/set_orderly_key_ip_restriction", 6 },
                            { "client/reset_orderly_key_ip_restriction", 6 },
                            { "order", 1 },
                            { "batch-order", 10 },
                            { "algo/order", 1 },
                            { "liquidation", 1 },
                            { "claim_insurance_fund", 1 },
                            { "withdraw_request", 1 },
                            { "settle_pnl", 1 },
                            { "notification/inbox/mark_read", 60 },
                            { "notification/inbox/mark_read_all", 60 },
                            { "client/leverage", 120 },
                            { "client/maintenance_config", 60 },
                            { "delegate_signer", 10 },
                            { "delegate_orderly_key", 10 },
                            { "delegate_settle_pnl", 10 },
                            { "delegate_withdraw_request", 10 },
                            { "broker/fee_rate/set", 10 },
                            { "broker/fee_rate/set_default", 10 },
                            { "broker/fee_rate/default", 10 },
                            { "referral/create", 10 },
                            { "referral/update", 10 },
                            { "referral/bind", 10 },
                            { "referral/edit_split", 10 },
                        } },
                        { "put", new Dictionary<string, object>() {
                            { "order", 1 },
                            { "algo/order", 1 },
                        } },
                        { "delete", new Dictionary<string, object>() {
                            { "order", 1 },
                            { "algo/order", 1 },
                            { "client/order", 1 },
                            { "algo/client/order", 1 },
                            { "algo/orders", 1 },
                            { "orders", 1 },
                            { "batch-order", 1 },
                            { "client/batch-order", 1 },
                        } },
                    } },
                } },
            } },
            { "requiredCredentials", new Dictionary<string, object>() {
                { "apiKey", true },
                { "secret", true },
                { "accountId", true },
                { "privateKey", false },
            } },
            { "fees", new Dictionary<string, object>() {
                { "trading", new Dictionary<string, object>() {
                    { "tierBased", true },
                    { "percentage", true },
                    { "maker", this.parseNumber("0.0002") },
                    { "taker", this.parseNumber("0.0005") },
                } },
            } },
            { "options", new Dictionary<string, object>() {
                { "sandboxMode", false },
                { "brokerId", "CCXT" },
                { "verifyingContractAddress", "0x6F7a338F2aA472838dEFD3283eB360d4Dff5D203" },
            } },
            { "commonCurrencies", new Dictionary<string, object>() {} },
            { "exceptions", new Dictionary<string, object>() {
                { "exact", new Dictionary<string, object>() {
                    { "-1000", typeof(ExchangeError) },
                    { "-1001", typeof(AuthenticationError) },
                    { "-1002", typeof(AuthenticationError) },
                    { "-1003", typeof(RateLimitExceeded) },
                    { "-1004", typeof(BadRequest) },
                    { "-1005", typeof(BadRequest) },
                    { "-1006", typeof(InvalidOrder) },
                    { "-1007", typeof(BadRequest) },
                    { "-1008", typeof(InvalidOrder) },
                    { "-1009", typeof(InsufficientFunds) },
                    { "-1011", typeof(NetworkError) },
                    { "-1012", typeof(BadRequest) },
                    { "-1101", typeof(InsufficientFunds) },
                    { "-1102", typeof(InvalidOrder) },
                    { "-1103", typeof(InvalidOrder) },
                    { "-1104", typeof(InvalidOrder) },
                    { "-1105", typeof(InvalidOrder) },
                    { "-1201", typeof(BadRequest) },
                    { "-1202", typeof(BadRequest) },
                    { "29", typeof(BadRequest) },
                    { "9", typeof(AuthenticationError) },
                    { "3", typeof(AuthenticationError) },
                    { "2", typeof(BadRequest) },
                    { "15", typeof(BadRequest) },
                } },
                { "broad", new Dictionary<string, object>() {} },
            } },
            { "precisionMode", TICK_SIZE },
        });
    }

    public override void setSandboxMode(object enable)
    {
        base.setSandboxMode(enable);
        ((IDictionary<string,object>)this.options)["sandboxMode"] = enable;
    }

    public async override Task<object> fetchStatus(object parameters = null)
    {
        /**
        * @method
        * @name woofipro#fetchStatus
        * @description the latest known information on the availability of the exchange API
        * @see https://orderly.network/docs/build-on-evm/evm-api/restful-api/public/get-system-maintenance-status
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [status structure]{@link https://docs.ccxt.com/#/?id=exchange-status-structure}
        */
        parameters ??= new Dictionary<string, object>();
        object response = await this.v1PublicGetPublicSystemInfo(parameters);
        //
        //     {
        //         "success": true,
        //         "data": {
        //             "status": 0,
        //             "msg": "System is functioning properly."
        //         },
        //         "timestamp": "1709274106602"
        //     }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        object status = this.safeString(data, "status");
        if (isTrue(isEqual(status, null)))
        {
            status = "error";
        } else if (isTrue(isEqual(status, "0")))
        {
            status = "ok";
        } else
        {
            status = "maintenance";
        }
        return new Dictionary<string, object>() {
            { "status", status },
            { "updated", null },
            { "eta", null },
            { "url", null },
            { "info", response },
        };
    }

    public async override Task<object> fetchTime(object parameters = null)
    {
        /**
        * @method
        * @name woofipro#fetchTime
        * @description fetches the current integer timestamp in milliseconds from the exchange server
        * @see https://orderly.network/docs/build-on-evm/evm-api/restful-api/public/get-system-maintenance-status
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {int} the current integer timestamp in milliseconds from the exchange server
        */
        parameters ??= new Dictionary<string, object>();
        object response = await this.v1PublicGetPublicSystemInfo(parameters);
        //
        //     {
        //         "success": true,
        //         "data": {
        //             "status": 0,
        //             "msg": "System is functioning properly."
        //         },
        //         "timestamp": "1709274106602"
        //     }
        //
        return this.safeInteger(response, "timestamp");
    }

    public override object parseMarket(object market)
    {
        //
        //   {
        //     "symbol": "PERP_BTC_USDC",
        //     "quote_min": 123,
        //     "quote_max": 100000,
        //     "quote_tick": 0.1,
        //     "base_min": 0.00001,
        //     "base_max": 20,
        //     "base_tick": 0.00001,
        //     "min_notional": 1,
        //     "price_range": 0.02,
        //     "price_scope": 0.4,
        //     "std_liquidation_fee": 0.03,
        //     "liquidator_fee": 0.015,
        //     "claim_insurance_fund_discount": 0.0075,
        //     "funding_period": 8,
        //     "cap_funding": 0.000375,
        //     "floor_funding": -0.000375,
        //     "interest_rate": 0.0001,
        //     "created_time": 1684140107326,
        //     "updated_time": 1685345968053,
        //     "base_mmr": 0.05,
        //     "base_imr": 0.1,
        //     "imr_factor": 0.0002512,
        //     "liquidation_tier": "1"
        //   }
        //
        object marketId = this.safeString(market, "symbol");
        object parts = ((string)marketId).Split(new [] {((string)"_")}, StringSplitOptions.None).ToList<object>();
        object marketType = "swap";
        object baseId = this.safeString(parts, 1);
        object quoteId = this.safeString(parts, 2);
        object bs = this.safeCurrencyCode(baseId);
        object quote = this.safeCurrencyCode(quoteId);
        object settleId = this.safeString(parts, 2);
        object settle = this.safeCurrencyCode(settleId);
        object symbol = add(add(add(add(bs, "/"), quote), ":"), settle);
        return new Dictionary<string, object>() {
            { "id", marketId },
            { "symbol", symbol },
            { "base", bs },
            { "quote", quote },
            { "settle", settle },
            { "baseId", baseId },
            { "quoteId", quoteId },
            { "settleId", settleId },
            { "type", marketType },
            { "spot", false },
            { "margin", false },
            { "swap", true },
            { "future", false },
            { "option", false },
            { "active", null },
            { "contract", true },
            { "linear", true },
            { "inverse", null },
            { "contractSize", this.parseNumber("1") },
            { "expiry", null },
            { "expiryDatetime", null },
            { "strike", null },
            { "optionType", null },
            { "precision", new Dictionary<string, object>() {
                { "amount", this.safeNumber(market, "base_tick") },
                { "price", this.safeNumber(market, "quote_tick") },
            } },
            { "limits", new Dictionary<string, object>() {
                { "leverage", new Dictionary<string, object>() {
                    { "min", null },
                    { "max", null },
                } },
                { "amount", new Dictionary<string, object>() {
                    { "min", this.safeNumber(market, "base_min") },
                    { "max", this.safeNumber(market, "base_max") },
                } },
                { "price", new Dictionary<string, object>() {
                    { "min", this.safeNumber(market, "quote_min") },
                    { "max", this.safeNumber(market, "quote_max") },
                } },
                { "cost", new Dictionary<string, object>() {
                    { "min", this.safeNumber(market, "min_notional") },
                    { "max", null },
                } },
            } },
            { "created", this.safeInteger(market, "created_time") },
            { "info", market },
        };
    }

    public async override Task<object> fetchMarkets(object parameters = null)
    {
        /**
        * @method
        * @name woofipro#fetchMarkets
        * @description retrieves data on all markets for woofipro
        * @see https://orderly.network/docs/build-on-evm/evm-api/restful-api/public/get-available-symbols
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} an array of objects representing market data
        */
        parameters ??= new Dictionary<string, object>();
        object response = await this.v1PublicGetPublicInfo(parameters);
        //
        //   {
        //     "success": true,
        //     "timestamp": 1702989203989,
        //     "data": {
        //       "rows": [
        //         {
        //           "symbol": "PERP_BTC_USDC",
        //           "quote_min": 123,
        //           "quote_max": 100000,
        //           "quote_tick": 0.1,
        //           "base_min": 0.00001,
        //           "base_max": 20,
        //           "base_tick": 0.00001,
        //           "min_notional": 1,
        //           "price_range": 0.02,
        //           "price_scope": 0.4,
        //           "std_liquidation_fee": 0.03,
        //           "liquidator_fee": 0.015,
        //           "claim_insurance_fund_discount": 0.0075,
        //           "funding_period": 8,
        //           "cap_funding": 0.000375,
        //           "floor_funding": -0.000375,
        //           "interest_rate": 0.0001,
        //           "created_time": 1684140107326,
        //           "updated_time": 1685345968053,
        //           "base_mmr": 0.05,
        //           "base_imr": 0.1,
        //           "imr_factor": 0.0002512,
        //           "liquidation_tier": "1"
        //         }
        //       ]
        //     }
        //   }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        object rows = this.safeList(data, "rows", new List<object>() {});
        return this.parseMarkets(rows);
    }

    public async override Task<object> fetchCurrencies(object parameters = null)
    {
        /**
        * @method
        * @name woofipro#fetchCurrencies
        * @description fetches all available currencies on an exchange
        * @see https://orderly.network/docs/build-on-evm/evm-api/restful-api/public/get-token-info
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} an associative dictionary of currencies
        */
        parameters ??= new Dictionary<string, object>();
        object result = new Dictionary<string, object>() {};
        object response = await this.v1PublicGetPublicToken(parameters);
        //
        // {
        //     "success": true,
        //     "timestamp": 1702989203989,
        //     "data": {
        //       "rows": [{
        //         "token": "USDC",
        //         "decimals": 6,
        //         "minimum_withdraw_amount": 0.000001,
        //         "token_hash": "0xd6aca1be9729c13d677335161321649cccae6a591554772516700f986f942eaa",
        //         "chain_details": [{
        //             "chain_id": 43113,
        //             "contract_address": "0x5d64c9cfb0197775b4b3ad9be4d3c7976e0d8dc3",
        //             "cross_chain_withdrawal_fee": 123,
        //             "decimals": 6,
        //             "withdraw_fee": 2
        //             }]
        //         }
        //       ]
        //     }
        // }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        object tokenRows = this.safeList(data, "rows", new List<object>() {});
        for (object i = 0; isLessThan(i, getArrayLength(tokenRows)); postFixIncrement(ref i))
        {
            object token = getValue(tokenRows, i);
            object currencyId = this.safeString(token, "token");
            object networks = this.safeList(token, "chain_details");
            object code = this.safeCurrencyCode(currencyId);
            object minPrecision = null;
            object resultingNetworks = new Dictionary<string, object>() {};
            for (object j = 0; isLessThan(j, getArrayLength(networks)); postFixIncrement(ref j))
            {
                object network = getValue(networks, j);
                // TODO: transform chain id to human readable name
                object networkId = this.safeString(network, "chain_id");
                object precision = this.parsePrecision(this.safeString(network, "decimals"));
                if (isTrue(!isEqual(precision, null)))
                {
                    minPrecision = ((bool) isTrue((isEqual(minPrecision, null)))) ? precision : Precise.stringMin(precision, minPrecision);
                }
                ((IDictionary<string,object>)resultingNetworks)[(string)networkId] = new Dictionary<string, object>() {
                    { "id", networkId },
                    { "network", networkId },
                    { "limits", new Dictionary<string, object>() {
                        { "withdraw", new Dictionary<string, object>() {
                            { "min", null },
                            { "max", null },
                        } },
                        { "deposit", new Dictionary<string, object>() {
                            { "min", null },
                            { "max", null },
                        } },
                    } },
                    { "active", null },
                    { "deposit", null },
                    { "withdraw", null },
                    { "fee", this.safeNumber(network, "withdrawal_fee") },
                    { "precision", this.parseNumber(precision) },
                    { "info", network },
                };
            }
            ((IDictionary<string,object>)result)[(string)code] = new Dictionary<string, object>() {
                { "id", currencyId },
                { "name", currencyId },
                { "code", code },
                { "precision", this.parseNumber(minPrecision) },
                { "active", null },
                { "fee", null },
                { "networks", resultingNetworks },
                { "deposit", null },
                { "withdraw", null },
                { "limits", new Dictionary<string, object>() {
                    { "deposit", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                    { "withdraw", new Dictionary<string, object>() {
                        { "min", this.safeNumber(token, "minimum_withdraw_amount") },
                        { "max", null },
                    } },
                } },
                { "info", token },
            };
        }
        return result;
    }

    public virtual object parseTokenAndFeeTemp(object item, object feeTokenKey, object feeAmountKey)
    {
        object feeCost = this.safeString(item, feeAmountKey);
        object fee = null;
        if (isTrue(!isEqual(feeCost, null)))
        {
            object feeCurrencyId = this.safeString(item, feeTokenKey);
            object feeCurrencyCode = this.safeCurrencyCode(feeCurrencyId);
            fee = new Dictionary<string, object>() {
                { "cost", feeCost },
                { "currency", feeCurrencyCode },
            };
        }
        return fee;
    }

    public override object parseTrade(object trade, object market = null)
    {
        //
        // public/market_trades
        //
        //     {
        //         "symbol": "SPOT_BTC_USDT",
        //         "side": "SELL",
        //         "executed_price": 46222.35,
        //         "executed_quantity": 0.0012,
        //         "executed_timestamp": "1683878609166"
        //     }
        //
        // fetchOrderTrades, fetchOrder
        //
        //     {
        //         "id": "99119876",
        //         "symbol": "SPOT_WOO_USDT",
        //         "fee": "0.0024",
        //         "side": "BUY",
        //         "executed_timestamp": "1641481113084",
        //         "order_id": "87001234",
        //         "order_tag": "default", <-- this param only in "fetchOrderTrades"
        //         "executed_price": "1",
        //         "executed_quantity": "12",
        //         "fee_asset": "WOO",
        //         "is_maker": "1"
        //     }
        //
        object isFromFetchOrder = (inOp(trade, "id"));
        object timestamp = this.safeInteger(trade, "executed_timestamp");
        object marketId = this.safeString(trade, "symbol");
        market = this.safeMarket(marketId, market);
        object symbol = getValue(market, "symbol");
        object price = this.safeString(trade, "executed_price");
        object amount = this.safeString(trade, "executed_quantity");
        object order_id = this.safeString(trade, "order_id");
        object fee = this.parseTokenAndFeeTemp(trade, "fee_asset", "fee");
        object feeCost = this.safeString(fee, "cost");
        if (isTrue(!isEqual(feeCost, null)))
        {
            ((IDictionary<string,object>)fee)["cost"] = feeCost;
        }
        object cost = Precise.stringMul(price, amount);
        object side = this.safeStringLower(trade, "side");
        object id = this.safeString(trade, "id");
        object takerOrMaker = null;
        if (isTrue(isFromFetchOrder))
        {
            object isMaker = isEqual(this.safeString(trade, "is_maker"), "1");
            takerOrMaker = ((bool) isTrue(isMaker)) ? "maker" : "taker";
        }
        return this.safeTrade(new Dictionary<string, object>() {
            { "id", id },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "symbol", symbol },
            { "side", side },
            { "price", price },
            { "amount", amount },
            { "cost", cost },
            { "order", order_id },
            { "takerOrMaker", takerOrMaker },
            { "type", null },
            { "fee", fee },
            { "info", trade },
        }, market);
    }

    public async override Task<object> fetchTrades(object symbol, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name woofipro#fetchTrades
        * @description get the list of most recent trades for a particular symbol
        * @see https://orderly.network/docs/build-on-evm/evm-api/restful-api/public/get-market-trades
        * @param {string} symbol unified symbol of the market to fetch trades for
        * @param {int} [since] timestamp in ms of the earliest trade to fetch
        * @param {int} [limit] the maximum amount of trades to fetch
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        object response = await this.v1PublicGetPublicMarketTrades(this.extend(request, parameters));
        //
        // {
        //     "success": true,
        //     "timestamp": 1702989203989,
        //     "data": {
        //       "rows": [{
        //         "symbol": "PERP_ETH_USDC",
        //         "side": "BUY",
        //         "executed_price": 2050,
        //         "executed_quantity": 1,
        //         "executed_timestamp": 1683878609166
        //       }]
        //     }
        // }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        object rows = this.safeList(data, "rows", new List<object>() {});
        return this.parseTrades(rows, market, since, limit);
    }

    public override object parseFundingRate(object fundingRate, object market = null)
    {
        //
        //         {
        //             "symbol":"PERP_AAVE_USDT",
        //             "est_funding_rate":-0.00003447,
        //             "est_funding_rate_timestamp":1653633959001,
        //             "last_funding_rate":-0.00002094,
        //             "last_funding_rate_timestamp":1653631200000,
        //             "next_funding_time":1653634800000,
        //            "sum_unitary_funding": 521.367
        //         }
        //
        object symbol = this.safeString(fundingRate, "symbol");
        market = this.market(symbol);
        object nextFundingTimestamp = this.safeInteger(fundingRate, "next_funding_time");
        object estFundingRateTimestamp = this.safeInteger(fundingRate, "est_funding_rate_timestamp");
        object lastFundingRateTimestamp = this.safeInteger(fundingRate, "last_funding_rate_timestamp");
        object fundingTimeString = this.safeString(fundingRate, "last_funding_rate_timestamp");
        object nextFundingTimeString = this.safeString(fundingRate, "next_funding_time");
        object millisecondsInterval = Precise.stringSub(nextFundingTimeString, fundingTimeString);
        return new Dictionary<string, object>() {
            { "info", fundingRate },
            { "symbol", getValue(market, "symbol") },
            { "markPrice", null },
            { "indexPrice", null },
            { "interestRate", this.parseNumber("0") },
            { "estimatedSettlePrice", null },
            { "timestamp", estFundingRateTimestamp },
            { "datetime", this.iso8601(estFundingRateTimestamp) },
            { "fundingRate", this.safeNumber(fundingRate, "est_funding_rate") },
            { "fundingTimestamp", nextFundingTimestamp },
            { "fundingDatetime", this.iso8601(nextFundingTimestamp) },
            { "nextFundingRate", null },
            { "nextFundingTimestamp", null },
            { "nextFundingDatetime", null },
            { "previousFundingRate", this.safeNumber(fundingRate, "last_funding_rate") },
            { "previousFundingTimestamp", lastFundingRateTimestamp },
            { "previousFundingDatetime", this.iso8601(lastFundingRateTimestamp) },
            { "interval", this.parseFundingInterval(millisecondsInterval) },
        };
    }

    public virtual object parseFundingInterval(object interval)
    {
        object intervals = new Dictionary<string, object>() {
            { "3600000", "1h" },
            { "14400000", "4h" },
            { "28800000", "8h" },
            { "57600000", "16h" },
            { "86400000", "24h" },
        };
        return this.safeString(intervals, interval, interval);
    }

    public async override Task<object> fetchFundingRate(object symbol, object parameters = null)
    {
        /**
        * @method
        * @name woofipro#fetchFundingRate
        * @description fetch the current funding rate
        * @see https://orderly.network/docs/build-on-evm/evm-api/restful-api/public/get-predicted-funding-rate-for-one-market
        * @param {string} symbol unified market symbol
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [funding rate structure]{@link https://docs.ccxt.com/#/?id=funding-rate-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object response = await this.v1PublicGetPublicFundingRateSymbol(this.extend(request, parameters));
        //
        // {
        //     "success": true,
        //     "timestamp": 1702989203989,
        //     "data": {
        //         "symbol": "PERP_ETH_USDC",
        //         "est_funding_rate": 123,
        //         "est_funding_rate_timestamp": 1683880020000,
        //         "last_funding_rate": 0.0001,
        //         "last_funding_rate_timestamp": 1683878400000,
        //         "next_funding_time": 1683907200000,
        //         "sum_unitary_funding": 521.367
        //     }
        // }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        return this.parseFundingRate(data, market);
    }

    public async override Task<object> fetchFundingRates(object symbols = null, object parameters = null)
    {
        /**
        * @method
        * @name woofipro#fetchFundingRates
        * @description fetch the current funding rate for multiple markets
        * @see https://orderly.network/docs/build-on-evm/evm-api/restful-api/public/get-predicted-funding-rates-for-all-markets
        * @param {string[]} symbols unified market symbols
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} an array of [funding rate structures]{@link https://docs.ccxt.com/#/?id=funding-rate-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        symbols = this.marketSymbols(symbols);
        object response = await this.v1PublicGetPublicFundingRates(parameters);
        //
        // {
        //     "success": true,
        //     "timestamp": 1702989203989,
        //     "data": {
        //       "rows": [{
        //         "symbol": "PERP_ETH_USDC",
        //         "est_funding_rate": 123,
        //         "est_funding_rate_timestamp": 1683880020000,
        //         "last_funding_rate": 0.0001,
        //         "last_funding_rate_timestamp": 1683878400000,
        //         "next_funding_time": 1683907200000,
        //         "sum_unitary_funding": 521.367
        //       }]
        //     }
        // }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        object rows = this.safeList(data, "rows", new List<object>() {});
        object result = this.parseFundingRates(rows);
        return this.filterByArray(result, "symbol", symbols);
    }

    public async override Task<object> fetchFundingRateHistory(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name woofipro#fetchFundingRateHistory
        * @description fetches historical funding rate prices
        * @see https://orderly.network/docs/build-on-evm/evm-api/restful-api/public/get-funding-rate-history-for-one-market
        * @param {string} symbol unified symbol of the market to fetch the funding rate history for
        * @param {int} [since] timestamp in ms of the earliest funding rate to fetch
        * @param {int} [limit] the maximum amount of [funding rate structures]{@link https://docs.ccxt.com/#/?id=funding-rate-history-structure} to fetch
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {int} [params.until] timestamp in ms of the latest funding rate
        * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [availble parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
        * @returns {object[]} a list of [funding rate structures]{@link https://docs.ccxt.com/#/?id=funding-rate-history-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object paginate = false;
        var paginateparametersVariable = this.handleOptionAndParams(parameters, "fetchFundingRateHistory", "paginate");
        paginate = ((IList<object>)paginateparametersVariable)[0];
        parameters = ((IList<object>)paginateparametersVariable)[1];
        if (isTrue(paginate))
        {
            return await this.fetchPaginatedCallIncremental("fetchFundingRateHistory", symbol, since, limit, parameters, "page", 25);
        }
        object request = new Dictionary<string, object>() {};
        if (isTrue(!isEqual(symbol, null)))
        {
            object market = this.market(symbol);
            symbol = getValue(market, "symbol");
            ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["start_t"] = since;
        }
        var requestparametersVariable = this.handleUntilOption("end_t", request, parameters, 0.001);
        request = ((IList<object>)requestparametersVariable)[0];
        parameters = ((IList<object>)requestparametersVariable)[1];
        object response = await this.v1PublicGetPublicFundingRateHistory(this.extend(request, parameters));
        //
        // {
        //     "success": true,
        //     "timestamp": 1702989203989,
        //     "data": {
        //       "rows": [{
        //         "symbol": "PERP_ETH_USDC",
        //         "funding_rate": 0.0001,
        //         "funding_rate_timestamp": 1684224000000,
        //         "next_funding_time": 1684252800000
        //       }],
        //       "meta": {
        //         "total": 9,
        //         "records_per_page": 25,
        //         "current_page": 1
        //       }
        //     }
        // }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        object result = this.safeList(data, "rows", new List<object>() {});
        object rates = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(result)); postFixIncrement(ref i))
        {
            object entry = getValue(result, i);
            object marketId = this.safeString(entry, "symbol");
            object timestamp = this.safeInteger(entry, "funding_rate_timestamp");
            ((IList<object>)rates).Add(new Dictionary<string, object>() {
                { "info", entry },
                { "symbol", this.safeSymbol(marketId) },
                { "fundingRate", this.safeNumber(entry, "funding_rate") },
                { "timestamp", timestamp },
                { "datetime", this.iso8601(timestamp) },
            });
        }
        object sorted = this.sortBy(rates, "timestamp");
        return this.filterBySymbolSinceLimit(sorted, symbol, since, limit);
    }

    public async override Task<object> fetchTradingFees(object parameters = null)
    {
        /**
        * @method
        * @name woofipro#fetchTradingFees
        * @description fetch the trading fees for multiple markets
        * @see https://orderly.network/docs/build-on-evm/evm-api/restful-api/private/get-account-information
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a dictionary of [fee structures]{@link https://docs.ccxt.com/#/?id=fee-structure} indexed by market symbols
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.v1PrivateGetClientInfo(parameters);
        //
        // {
        //     "success": true,
        //     "timestamp": 1702989203989,
        //     "data": {
        //         "account_id": "<string>",
        //         "email": "test@test.com",
        //         "account_mode": "FUTURES",
        //         "max_leverage": 20,
        //         "taker_fee_rate": 123,
        //         "maker_fee_rate": 123,
        //         "futures_taker_fee_rate": 123,
        //         "futures_maker_fee_rate": 123,
        //         "maintenance_cancel_orders": true,
        //         "imr_factor": {
        //             "PERP_BTC_USDC": 123,
        //             "PERP_ETH_USDC": 123,
        //             "PERP_NEAR_USDC": 123
        //         },
        //         "max_notional": {
        //             "PERP_BTC_USDC": 123,
        //             "PERP_ETH_USDC": 123,
        //             "PERP_NEAR_USDC": 123
        //         }
        //     }
        // }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        object maker = this.safeString(data, "futures_maker_fee_rate");
        object taker = this.safeString(data, "futures_taker_fee_rate");
        object result = new Dictionary<string, object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(this.symbols)); postFixIncrement(ref i))
        {
            object symbol = getValue(this.symbols, i);
            ((IDictionary<string,object>)result)[(string)symbol] = new Dictionary<string, object>() {
                { "info", response },
                { "symbol", symbol },
                { "maker", this.parseNumber(Precise.stringDiv(maker, "10000")) },
                { "taker", this.parseNumber(Precise.stringDiv(taker, "10000")) },
                { "percentage", true },
                { "tierBased", true },
            };
        }
        return result;
    }

    public async override Task<object> fetchOrderBook(object symbol, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name woofipro#fetchOrderBook
        * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
        * @see https://orderly.network/docs/build-on-evm/evm-api/restful-api/private/orderbook-snapshot
        * @param {string} symbol unified symbol of the market to fetch the order book for
        * @param {int} [limit] the maximum amount of order book entries to return
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        if (isTrue(!isEqual(limit, null)))
        {
            limit = mathMin(limit, 1000);
            ((IDictionary<string,object>)request)["max_level"] = limit;
        }
        object response = await this.v1PrivateGetOrderbookSymbol(this.extend(request, parameters));
        //
        // {
        //     "success": true,
        //     "timestamp": 1702989203989,
        //     "data": {
        //       "asks": [{
        //         "price": 10669.4,
        //         "quantity": 1.56263218
        //       }],
        //       "bids": [{
        //         "price": 10669.4,
        //         "quantity": 1.56263218
        //       }],
        //       "timestamp": 123
        //     }
        // }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        object timestamp = this.safeInteger(data, "timestamp");
        return this.parseOrderBook(data, symbol, timestamp, "bids", "asks", "price", "quantity");
    }

    public override object parseOHLCV(object ohlcv, object market = null)
    {
        return new List<object> {this.safeInteger(ohlcv, "start_timestamp"), this.safeNumber(ohlcv, "open"), this.safeNumber(ohlcv, "high"), this.safeNumber(ohlcv, "low"), this.safeNumber(ohlcv, "close"), this.safeNumber(ohlcv, "volume")};
    }

    public async override Task<object> fetchOHLCV(object symbol, object timeframe = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name woofipro#fetchOHLCV
        * @see https://orderly.network/docs/build-on-evm/evm-api/restful-api/private/get-kline
        * @description fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
        * @param {string} symbol unified symbol of the market to fetch OHLCV data for
        * @param {string} timeframe the length of time each candle represents
        * @param {int} [since] timestamp in ms of the earliest candle to fetch
        * @param {int} [limit] max=1000, max=100 when since is defined and is less than (now - (999 * (timeframe in ms)))
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
        */
        timeframe ??= "1m";
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
            { "type", this.safeString(this.timeframes, timeframe, timeframe) },
        };
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = mathMin(limit, 1000);
        }
        object response = await this.v1PrivateGetKline(this.extend(request, parameters));
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        //
        // {
        //     "success": true,
        //     "timestamp": 1702989203989,
        //     "data": {
        //       "rows": [{
        //         "open": 66166.23,
        //         "close": 66124.56,
        //         "low": 66038.06,
        //         "high": 66176.97,
        //         "volume": 23.45528526,
        //         "amount": 1550436.21725288,
        //         "symbol": "PERP_BTC_USDC",
        //         "type": "1m",
        //         "start_timestamp": 1636388220000,
        //         "end_timestamp": 1636388280000
        //       }]
        //     }
        // }
        //
        object rows = this.safeList(data, "rows", new List<object>() {});
        return this.parseOHLCVs(rows, market, timeframe, since, limit);
    }

    public override object parseOrder(object order, object market = null)
    {
        //
        // Possible input functions:
        // * createOrder
        // * createOrders
        // * cancelOrder
        // * fetchOrder
        // * fetchOrders
        // const isFromFetchOrder = ('order_tag' in order); TO_DO
        //
        // stop order after creating it:
        //   {
        //     "orderId": "1578938",
        //     "clientOrderId": "0",
        //     "algoType": "STOP_LOSS",
        //     "quantity": "0.1"
        //   }
        // stop order after fetching it:
        //   {
        //       "algoOrderId": "1578958",
        //       "clientOrderId": "0",
        //       "rootAlgoOrderId": "1578958",
        //       "parentAlgoOrderId": "0",
        //       "symbol": "SPOT_LTC_USDT",
        //       "orderTag": "default",
        //       "algoType": "STOP_LOSS",
        //       "side": "BUY",
        //       "quantity": "0.1",
        //       "isTriggered": false,
        //       "triggerPrice": "100",
        //       "triggerStatus": "USELESS",
        //       "type": "LIMIT",
        //       "rootAlgoStatus": "CANCELLED",
        //       "algoStatus": "CANCELLED",
        //       "triggerPriceType": "MARKET_PRICE",
        //       "price": "75",
        //       "triggerTime": "0",
        //       "totalExecutedQuantity": "0",
        //       "averageExecutedPrice": "0",
        //       "totalFee": "0",
        //       "feeAsset": '',
        //       "reduceOnly": false,
        //       "createdTime": "1686149609.744",
        //       "updatedTime": "1686149903.362"
        //   }
        //
        object timestamp = this.safeIntegerN(order, new List<object>() {"timestamp", "created_time", "createdTime"});
        object orderId = this.safeStringN(order, new List<object>() {"order_id", "orderId", "algoOrderId"});
        object clientOrderId = this.omitZero(this.safeString2(order, "client_order_id", "clientOrderId")); // Somehow, this always returns 0 for limit order
        object marketId = this.safeString(order, "symbol");
        market = this.safeMarket(marketId, market);
        object symbol = getValue(market, "symbol");
        object price = this.safeString2(order, "order_price", "price");
        object amount = this.safeString2(order, "order_quantity", "quantity"); // This is base amount
        object cost = this.safeString2(order, "order_amount", "amount"); // This is quote amount
        object orderType = this.safeStringLower2(order, "order_type", "type");
        object status = this.safeValue2(order, "status", "algoStatus");
        object success = this.safeBool(order, "success");
        if (isTrue(!isEqual(success, null)))
        {
            status = ((bool) isTrue((success))) ? "NEW" : "REJECTED";
        }
        object side = this.safeStringLower(order, "side");
        object filled = this.omitZero(this.safeValue2(order, "executed", "totalExecutedQuantity"));
        object average = this.omitZero(this.safeString2(order, "average_executed_price", "averageExecutedPrice"));
        object remaining = Precise.stringSub(cost, filled);
        object fee = this.safeValue2(order, "total_fee", "totalFee");
        object feeCurrency = this.safeString2(order, "fee_asset", "feeAsset");
        object transactions = this.safeValue(order, "Transactions");
        object stopPrice = this.safeNumber(order, "triggerPrice");
        object takeProfitPrice = null;
        object stopLossPrice = null;
        object childOrders = this.safeValue(order, "childOrders");
        if (isTrue(!isEqual(childOrders, null)))
        {
            object first = this.safeValue(childOrders, 0);
            object innerChildOrders = this.safeValue(first, "childOrders", new List<object>() {});
            object innerChildOrdersLength = getArrayLength(innerChildOrders);
            if (isTrue(isGreaterThan(innerChildOrdersLength, 0)))
            {
                object takeProfitOrder = this.safeValue(innerChildOrders, 0);
                object stopLossOrder = this.safeValue(innerChildOrders, 1);
                takeProfitPrice = this.safeNumber(takeProfitOrder, "triggerPrice");
                stopLossPrice = this.safeNumber(stopLossOrder, "triggerPrice");
            }
        }
        object lastUpdateTimestamp = this.safeInteger2(order, "updatedTime", "updated_time");
        return this.safeOrder(new Dictionary<string, object>() {
            { "id", orderId },
            { "clientOrderId", clientOrderId },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "lastTradeTimestamp", null },
            { "lastUpdateTimestamp", lastUpdateTimestamp },
            { "status", this.parseOrderStatus(status) },
            { "symbol", symbol },
            { "type", this.parseOrderType(orderType) },
            { "timeInForce", this.parseTimeInForce(orderType) },
            { "postOnly", null },
            { "reduceOnly", this.safeBool(order, "reduce_only") },
            { "side", side },
            { "price", price },
            { "stopPrice", stopPrice },
            { "triggerPrice", stopPrice },
            { "takeProfitPrice", takeProfitPrice },
            { "stopLossPrice", stopLossPrice },
            { "average", average },
            { "amount", amount },
            { "filled", filled },
            { "remaining", remaining },
            { "cost", cost },
            { "trades", transactions },
            { "fee", new Dictionary<string, object>() {
                { "cost", fee },
                { "currency", feeCurrency },
            } },
            { "info", order },
        }, market);
    }

    public virtual object parseTimeInForce(object timeInForce)
    {
        object timeInForces = new Dictionary<string, object>() {
            { "ioc", "IOC" },
            { "fok", "FOK" },
            { "post_only", "PO" },
        };
        return this.safeString(timeInForces, timeInForce, null);
    }

    public virtual object parseOrderStatus(object status)
    {
        if (isTrue(!isEqual(status, null)))
        {
            object statuses = new Dictionary<string, object>() {
                { "NEW", "open" },
                { "FILLED", "closed" },
                { "CANCEL_SENT", "canceled" },
                { "CANCEL_ALL_SENT", "canceled" },
                { "CANCELLED", "canceled" },
                { "PARTIAL_FILLED", "open" },
                { "REJECTED", "rejected" },
                { "INCOMPLETE", "open" },
                { "COMPLETED", "closed" },
            };
            return this.safeString(statuses, status, status);
        }
        return status;
    }

    public virtual object parseOrderType(object type)
    {
        object types = new Dictionary<string, object>() {
            { "LIMIT", "limit" },
            { "MARKET", "market" },
            { "POST_ONLY", "limit" },
        };
        return this.safeStringLower(types, type, type);
    }

    public virtual object createOrderRequest(object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        /**
        * @method
        * @ignore
        * @name woofipro#createOrderRequest
        * @description helper function to build the request
        * @param {string} symbol unified symbol of the market to create an order in
        * @param {string} type 'market' or 'limit'
        * @param {string} side 'buy' or 'sell'
        * @param {float} amount how much you want to trade in units of the base currency
        * @param {float} [price] the price that the order is to be fulfilled, in units of the quote currency, ignored in market orders
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} request to be sent to the exchange
        */
        parameters ??= new Dictionary<string, object>();
        object reduceOnly = this.safeBool2(parameters, "reduceOnly", "reduce_only");
        object orderType = ((string)type).ToUpper();
        object market = this.market(symbol);
        object orderSide = ((string)side).ToUpper();
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
            { "side", orderSide },
        };
        object stopPrice = this.safeString2(parameters, "triggerPrice", "stopPrice");
        object stopLoss = this.safeValue(parameters, "stopLoss");
        object takeProfit = this.safeValue(parameters, "takeProfit");
        object algoType = this.safeString(parameters, "algoType");
        object isStop = isTrue(isTrue(isTrue(!isEqual(stopPrice, null)) || isTrue(!isEqual(stopLoss, null))) || isTrue(!isEqual(takeProfit, null))) || isTrue((!isEqual(this.safeValue(parameters, "childOrders"), null)));
        object isMarket = isEqual(orderType, "MARKET");
        object timeInForce = this.safeStringLower(parameters, "timeInForce");
        object postOnly = this.isPostOnly(isMarket, null, parameters);
        object orderQtyKey = ((bool) isTrue(isStop)) ? "quantity" : "order_quantity";
        object priceKey = ((bool) isTrue(isStop)) ? "price" : "order_price";
        object typeKey = ((bool) isTrue(isStop)) ? "type" : "order_type";
        ((IDictionary<string,object>)request)[(string)typeKey] = orderType; // LIMIT/MARKET/IOC/FOK/POST_ONLY/ASK/BID
        if (!isTrue(isStop))
        {
            if (isTrue(postOnly))
            {
                ((IDictionary<string,object>)request)["order_type"] = "POST_ONLY";
            } else if (isTrue(isEqual(timeInForce, "fok")))
            {
                ((IDictionary<string,object>)request)["order_type"] = "FOK";
            } else if (isTrue(isEqual(timeInForce, "ioc")))
            {
                ((IDictionary<string,object>)request)["order_type"] = "IOC";
            }
        }
        if (isTrue(reduceOnly))
        {
            ((IDictionary<string,object>)request)["reduce_only"] = reduceOnly;
        }
        if (isTrue(!isEqual(price, null)))
        {
            ((IDictionary<string,object>)request)[(string)priceKey] = this.priceToPrecision(symbol, price);
        }
        if (isTrue(isTrue(isMarket) && !isTrue(isStop)))
        {
            ((IDictionary<string,object>)request)[(string)orderQtyKey] = this.amountToPrecision(symbol, amount);
        } else if (isTrue(!isEqual(algoType, "POSITIONAL_TP_SL")))
        {
            ((IDictionary<string,object>)request)[(string)orderQtyKey] = this.amountToPrecision(symbol, amount);
        }
        object clientOrderId = this.safeStringN(parameters, new List<object>() {"clOrdID", "clientOrderId", "client_order_id"});
        if (isTrue(!isEqual(clientOrderId, null)))
        {
            ((IDictionary<string,object>)request)["client_order_id"] = clientOrderId;
        }
        if (isTrue(!isEqual(stopPrice, null)))
        {
            ((IDictionary<string,object>)request)["trigger_price"] = this.priceToPrecision(symbol, stopPrice);
            ((IDictionary<string,object>)request)["algo_type"] = "STOP";
        } else if (isTrue(isTrue((!isEqual(stopLoss, null))) || isTrue((!isEqual(takeProfit, null)))))
        {
            ((IDictionary<string,object>)request)["algo_type"] = "TP_SL";
            object outterOrder = new Dictionary<string, object>() {
                { "symbol", getValue(market, "id") },
                { "reduce_only", false },
                { "algo_type", "POSITIONAL_TP_SL" },
                { "child_orders", new List<object>() {} },
            };
            object closeSide = ((bool) isTrue((isEqual(orderSide, "BUY")))) ? "SELL" : "BUY";
            if (isTrue(!isEqual(stopLoss, null)))
            {
                object stopLossPrice = this.safeNumber2(stopLoss, "triggerPrice", "price", stopLoss);
                object stopLossOrder = new Dictionary<string, object>() {
                    { "side", closeSide },
                    { "algo_type", "TP_SL" },
                    { "trigger_price", this.priceToPrecision(symbol, stopLossPrice) },
                    { "type", "LIMIT" },
                    { "reduce_only", true },
                };
                ((IList<object>)getValue(outterOrder, "child_orders")).Add(stopLossOrder);
            }
            if (isTrue(!isEqual(takeProfit, null)))
            {
                object takeProfitPrice = this.safeNumber2(takeProfit, "triggerPrice", "price", takeProfit);
                object takeProfitOrder = new Dictionary<string, object>() {
                    { "side", closeSide },
                    { "algo_type", "TP_SL" },
                    { "trigger_price", this.priceToPrecision(symbol, takeProfitPrice) },
                    { "type", "LIMIT" },
                    { "reduce_only", true },
                };
                ((IList<object>)getValue(outterOrder, "child_orders")).Add(takeProfitOrder);
            }
            ((IDictionary<string,object>)request)["child_orders"] = new List<object>() {outterOrder};
        }
        parameters = this.omit(parameters, new List<object>() {"reduceOnly", "reduce_only", "clOrdID", "clientOrderId", "client_order_id", "postOnly", "timeInForce", "stopPrice", "triggerPrice", "stopLoss", "takeProfit"});
        return this.extend(request, parameters);
    }

    public async override Task<object> createOrder(object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        /**
        * @method
        * @name woofipro#createOrder
        * @description create a trade order
        * @see https://orderly.network/docs/build-on-evm/evm-api/restful-api/private/create-order
        * @see https://orderly.network/docs/build-on-evm/evm-api/restful-api/private/create-algo-order
        * @param {string} symbol unified symbol of the market to create an order in
        * @param {string} type 'market' or 'limit'
        * @param {string} side 'buy' or 'sell'
        * @param {float} amount how much of currency you want to trade in units of base currency
        * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {float} [params.triggerPrice] The price a trigger order is triggered at
        * @param {object} [params.takeProfit] *takeProfit object in params* containing the triggerPrice at which the attached take profit order will be triggered (perpetual swap markets only)
        * @param {float} [params.takeProfit.triggerPrice] take profit trigger price
        * @param {object} [params.stopLoss] *stopLoss object in params* containing the triggerPrice at which the attached stop loss order will be triggered (perpetual swap markets only)
        * @param {float} [params.stopLoss.triggerPrice] stop loss trigger price
        * @param {float} [params.algoType] 'STOP'or 'TP_SL' or 'POSITIONAL_TP_SL'
        * @param {float} [params.cost] *spot market buy only* the quote quantity that can be used as an alternative for the amount
        * @param {string} [params.clientOrderId] a unique id for the order
        * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = this.createOrderRequest(symbol, type, side, amount, price, parameters);
        object stopPrice = this.safeString2(parameters, "triggerPrice", "stopPrice");
        object stopLoss = this.safeValue(parameters, "stopLoss");
        object takeProfit = this.safeValue(parameters, "takeProfit");
        object isStop = isTrue(isTrue(isTrue(!isEqual(stopPrice, null)) || isTrue(!isEqual(stopLoss, null))) || isTrue(!isEqual(takeProfit, null))) || isTrue((!isEqual(this.safeValue(parameters, "childOrders"), null)));
        object response = null;
        if (isTrue(isStop))
        {
            response = await this.v1PrivatePostAlgoOrder(request);
        } else
        {
            response = await this.v1PrivatePostOrder(request);
        }
        object data = this.safeDict(response, "data");
        ((IDictionary<string,object>)data)["timestamp"] = this.safeInteger(response, "timestamp");
        object order = this.parseOrder(data, market);
        ((IDictionary<string,object>)order)["type"] = type;
        return order;
    }

    public async override Task<object> createOrders(object orders, object parameters = null)
    {
        /**
        * @method
        * @name woofipro#createOrders
        * @description *contract only* create a list of trade orders
        * @see https://orderly.network/docs/build-on-evm/evm-api/restful-api/private/batch-create-order
        * @param {Array} orders list of orders to create, each object should contain the parameters required by createOrder, namely symbol, type, side, amount, price and params
        * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object ordersRequests = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(orders)); postFixIncrement(ref i))
        {
            object rawOrder = getValue(orders, i);
            object marketId = this.safeString(rawOrder, "symbol");
            object type = this.safeString(rawOrder, "type");
            object side = this.safeString(rawOrder, "side");
            object amount = this.safeValue(rawOrder, "amount");
            object price = this.safeValue(rawOrder, "price");
            object orderParams = this.safeDict(rawOrder, "params", new Dictionary<string, object>() {});
            object stopPrice = this.safeString2(orderParams, "triggerPrice", "stopPrice");
            object stopLoss = this.safeValue(orderParams, "stopLoss");
            object takeProfit = this.safeValue(orderParams, "takeProfit");
            object isStop = isTrue(isTrue(isTrue(!isEqual(stopPrice, null)) || isTrue(!isEqual(stopLoss, null))) || isTrue(!isEqual(takeProfit, null))) || isTrue((!isEqual(this.safeValue(orderParams, "childOrders"), null)));
            if (isTrue(isStop))
            {
                throw new NotSupported ((string)add(this.id, "createOrders() only support non-stop order")) ;
            }
            object orderRequest = this.createOrderRequest(marketId, type, side, amount, price, orderParams);
            ((IList<object>)ordersRequests).Add(orderRequest);
        }
        object request = new Dictionary<string, object>() {
            { "orders", ordersRequests },
        };
        object response = await this.v1PrivatePostBatchOrder(this.extend(request, parameters));
        //
        //     {
        //         "success": true,
        //         "timestamp": 1702989203989,
        //         "data": {
        //             "rows": [{
        //                 "order_id": 13,
        //                 "client_order_id": "testclientid",
        //                 "order_type": "LIMIT",
        //                 "order_price": 100.12,
        //                 "order_quantity": 0.987654,
        //                 "order_amount": 0.8,
        //                 "error_message": "none"
        //             }]
        //         }
        //     }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        object rows = this.safeList(data, "rows", new List<object>() {});
        return this.parseOrders(rows);
    }

    public async override Task<object> editOrder(object id, object symbol, object type, object side, object amount = null, object price = null, object parameters = null)
    {
        /**
        * @method
        * @name woofipro#editOrder
        * @description edit a trade order
        * @see https://orderly.network/docs/build-on-evm/evm-api/restful-api/private/edit-order
        * @see https://orderly.network/docs/build-on-evm/evm-api/restful-api/private/edit-algo-order
        * @param {string} id order id
        * @param {string} symbol unified symbol of the market to create an order in
        * @param {string} type 'market' or 'limit'
        * @param {string} side 'buy' or 'sell'
        * @param {float} amount how much of currency you want to trade in units of base currency
        * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {float} [params.triggerPrice] The price a trigger order is triggered at
        * @param {float} [params.stopLossPrice] price to trigger stop-loss orders
        * @param {float} [params.takeProfitPrice] price to trigger take-profit orders
        * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "order_id", id },
        };
        object stopPrice = this.safeStringN(parameters, new List<object>() {"triggerPrice", "stopPrice", "takeProfitPrice", "stopLossPrice"});
        if (isTrue(!isEqual(stopPrice, null)))
        {
            ((IDictionary<string,object>)request)["triggerPrice"] = this.priceToPrecision(symbol, stopPrice);
        }
        object isStop = isTrue((!isEqual(stopPrice, null))) || isTrue((!isEqual(this.safeValue(parameters, "childOrders"), null)));
        object orderQtyKey = ((bool) isTrue(isStop)) ? "quantity" : "order_quantity";
        object priceKey = ((bool) isTrue(isStop)) ? "price" : "order_price";
        if (isTrue(!isEqual(price, null)))
        {
            ((IDictionary<string,object>)request)[(string)priceKey] = this.priceToPrecision(symbol, price);
        }
        if (isTrue(!isEqual(amount, null)))
        {
            ((IDictionary<string,object>)request)[(string)orderQtyKey] = this.amountToPrecision(symbol, amount);
        }
        parameters = this.omit(parameters, new List<object>() {"stopPrice", "triggerPrice", "takeProfitPrice", "stopLossPrice", "trailingTriggerPrice", "trailingAmount", "trailingPercent"});
        object response = null;
        if (isTrue(isStop))
        {
            response = await this.v1PrivatePutAlgoOrder(this.extend(request, parameters));
        } else
        {
            ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
            ((IDictionary<string,object>)request)["side"] = ((string)side).ToUpper();
            object orderType = ((string)type).ToUpper();
            object timeInForce = this.safeStringLower(parameters, "timeInForce");
            object isMarket = isEqual(orderType, "MARKET");
            object postOnly = this.isPostOnly(isMarket, null, parameters);
            if (isTrue(postOnly))
            {
                ((IDictionary<string,object>)request)["order_type"] = "POST_ONLY";
            } else if (isTrue(isEqual(timeInForce, "fok")))
            {
                ((IDictionary<string,object>)request)["order_type"] = "FOK";
            } else if (isTrue(isEqual(timeInForce, "ioc")))
            {
                ((IDictionary<string,object>)request)["order_type"] = "IOC";
            } else
            {
                ((IDictionary<string,object>)request)["order_type"] = orderType;
            }
            object clientOrderId = this.safeStringN(parameters, new List<object>() {"clOrdID", "clientOrderId", "client_order_id"});
            parameters = this.omit(parameters, new List<object>() {"clOrdID", "clientOrderId", "client_order_id", "postOnly", "timeInForce"});
            if (isTrue(!isEqual(clientOrderId, null)))
            {
                ((IDictionary<string,object>)request)["client_order_id"] = clientOrderId;
            }
            // request['side'] = side.toUpperCase ();
            // request['symbol'] = market['id'];
            response = await this.v1PrivatePutOrder(this.extend(request, parameters));
        }
        //
        // {
        //     "success": true,
        //     "timestamp": 1702989203989,
        //     "data": {
        //       "status": "EDIT_SENT"
        //     }
        // }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        ((IDictionary<string,object>)data)["timestamp"] = this.safeInteger(response, "timestamp");
        return this.parseOrder(data, market);
    }

    public async override Task<object> cancelOrder(object id, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name woofipro#cancelOrder
        * @see https://orderly.network/docs/build-on-evm/evm-api/restful-api/private/cancel-order
        * @see https://orderly.network/docs/build-on-evm/evm-api/restful-api/private/cancel-order-by-client_order_id
        * @see https://orderly.network/docs/build-on-evm/evm-api/restful-api/private/cancel-algo-order
        * @see https://orderly.network/docs/build-on-evm/evm-api/restful-api/private/cancel-algo-order-by-client_order_id
        * @description cancels an open order
        * @param {string} id order id
        * @param {string} symbol unified symbol of the market the order was made in
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {boolean} [params.trigger] whether the order is a stop/algo order
        * @param {string} [params.clientOrderId] a unique id for the order
        * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        object stop = this.safeBool2(parameters, "stop", "trigger", false);
        parameters = this.omit(parameters, new List<object>() {"stop", "trigger"});
        if (isTrue(!isTrue(stop) && isTrue((isEqual(symbol, null)))))
        {
            throw new ArgumentsRequired ((string)add(this.id, " cancelOrder() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
        }
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object clientOrderIdUnified = this.safeString2(parameters, "clOrdID", "clientOrderId");
        object clientOrderIdExchangeSpecific = this.safeString(parameters, "client_order_id", clientOrderIdUnified);
        object isByClientOrder = !isEqual(clientOrderIdExchangeSpecific, null);
        object response = null;
        if (isTrue(stop))
        {
            if (isTrue(isByClientOrder))
            {
                ((IDictionary<string,object>)request)["client_order_id"] = clientOrderIdExchangeSpecific;
                parameters = this.omit(parameters, new List<object>() {"clOrdID", "clientOrderId", "client_order_id"});
                response = await this.v1PrivateDeleteAlgoClientOrder(this.extend(request, parameters));
            } else
            {
                ((IDictionary<string,object>)request)["order_id"] = id;
                response = await this.v1PrivateDeleteAlgoOrder(this.extend(request, parameters));
            }
        } else
        {
            if (isTrue(isByClientOrder))
            {
                ((IDictionary<string,object>)request)["client_order_id"] = clientOrderIdExchangeSpecific;
                parameters = this.omit(parameters, new List<object>() {"clOrdID", "clientOrderId", "client_order_id"});
                response = await this.v1PrivateDeleteClientOrder(this.extend(request, parameters));
            } else
            {
                ((IDictionary<string,object>)request)["order_id"] = id;
                response = await this.v1PrivateDeleteOrder(this.extend(request, parameters));
            }
        }
        //
        // {
        //     "success": true,
        //     "timestamp": 1702989203989,
        //     "data": {
        //       "status": "CANCEL_SENT"
        //     }
        // }
        //
        // {
        //     "success": true,
        //     "timestamp": 1702989203989,
        //     "status": "CANCEL_SENT"
        // }
        //
        object extendParams = new Dictionary<string, object>() {
            { "symbol", symbol },
        };
        if (isTrue(isByClientOrder))
        {
            ((IDictionary<string,object>)extendParams)["client_order_id"] = clientOrderIdExchangeSpecific;
        } else
        {
            ((IDictionary<string,object>)extendParams)["id"] = id;
        }
        if (isTrue(stop))
        {
            return this.extend(this.parseOrder(response), extendParams);
        }
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        return this.extend(this.parseOrder(data), extendParams);
    }

    public async virtual Task<object> cancelOrders(object ids, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name woofipro#cancelOrders
        * @description cancel multiple orders
        * @see https://orderly.network/docs/build-on-evm/evm-api/restful-api/private/batch-cancel-orders
        * @see https://orderly.network/docs/build-on-evm/evm-api/restful-api/private/batch-cancel-orders-by-client_order_id
        * @param {string[]} ids order ids
        * @param {string} [symbol] unified market symbol
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {string[]} [params.client_order_ids] max length 10 e.g. ["my_id_1","my_id_2"], encode the double quotes. No space after comma
        * @returns {object} an list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object clientOrderIds = this.safeListN(parameters, new List<object>() {"clOrdIDs", "clientOrderIds", "client_order_ids"});
        parameters = this.omit(parameters, new List<object>() {"clOrdIDs", "clientOrderIds", "client_order_ids"});
        object request = new Dictionary<string, object>() {};
        object response = null;
        if (isTrue(clientOrderIds))
        {
            ((IDictionary<string,object>)request)["client_order_ids"] = String.Join(",", ((IList<object>)clientOrderIds).ToArray());
            response = await this.v1PrivateDeleteClientBatchOrder(this.extend(request, parameters));
        } else
        {
            ((IDictionary<string,object>)request)["order_ids"] = String.Join(",", ((IList<object>)ids).ToArray());
            response = await this.v1PrivateDeleteBatchOrder(this.extend(request, parameters));
        }
        //
        // {
        //     "success": true,
        //     "timestamp": 1702989203989,
        //     "data": {
        //         "status": "CANCEL_ALL_SENT"
        //     }
        // }
        //
        return new List<object> {this.safeOrder(new Dictionary<string, object>() {
    { "info", response },
})};
    }

    public async override Task<object> cancelAllOrders(object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name woofipro#cancelAllOrders
        * @see https://orderly.network/docs/build-on-evm/evm-api/restful-api/private/cancel-all-pending-algo-orders
        * @see https://orderly.network/docs/build-on-evm/evm-api/restful-api/private/cancel-orders-in-bulk
        * @description cancel all open orders in a market
        * @param {string} symbol unified market symbol
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {boolean} [params.trigger] whether the order is a stop/algo order
        * @returns {object} an list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object stop = this.safeBool2(parameters, "stop", "trigger");
        parameters = this.omit(parameters, new List<object>() {"stop", "trigger"});
        object request = new Dictionary<string, object>() {};
        if (isTrue(!isEqual(symbol, null)))
        {
            object market = this.market(symbol);
            ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
        }
        object response = null;
        if (isTrue(stop))
        {
            response = await this.v1PrivateDeleteAlgoOrders(this.extend(request, parameters));
        } else
        {
            response = await this.v1PrivateDeleteOrders(this.extend(request, parameters));
        }
        // stop
        // {
        //     "success": true,
        //     "timestamp": 1702989203989,
        //      "status": "CANCEL_ALL_SENT"
        // }
        //
        // {
        //     "success": true,
        //     "timestamp": 1702989203989,
        //     "data": {
        //       "status": "CANCEL_ALL_SENT"
        //     }
        // }
        //
        return new List<object>() {new Dictionary<string, object>() {
    { "info", response },
}};
    }

    public async override Task<object> fetchOrder(object id, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name woofipro#fetchOrder
        * @see https://orderly.network/docs/build-on-evm/evm-api/restful-api/private/get-order-by-order_id
        * @see https://orderly.network/docs/build-on-evm/evm-api/restful-api/private/get-order-by-client_order_id
        * @see https://orderly.network/docs/build-on-evm/evm-api/restful-api/private/get-algo-order-by-order_id
        * @see https://orderly.network/docs/build-on-evm/evm-api/restful-api/private/get-algo-order-by-client_order_id
        * @description fetches information on an order made by the user
        * @param {string} id the order id
        * @param {string} symbol unified symbol of the market the order was made in
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {boolean} [params.trigger] whether the order is a stop/algo order
        * @param {string} [params.clientOrderId] a unique id for the order
        * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = ((bool) isTrue((!isEqual(symbol, null)))) ? this.market(symbol) : null;
        object stop = this.safeBool2(parameters, "stop", "trigger", false);
        object request = new Dictionary<string, object>() {};
        object clientOrderId = this.safeStringN(parameters, new List<object>() {"clOrdID", "clientOrderId", "client_order_id"});
        parameters = this.omit(parameters, new List<object>() {"stop", "trigger", "clOrdID", "clientOrderId", "client_order_id"});
        object response = null;
        if (isTrue(stop))
        {
            if (isTrue(clientOrderId))
            {
                ((IDictionary<string,object>)request)["client_order_id"] = clientOrderId;
                response = await this.v1PrivateGetAlgoClientOrderClientOrderId(this.extend(request, parameters));
            } else
            {
                ((IDictionary<string,object>)request)["oid"] = id;
                response = await this.v1PrivateGetAlgoOrderOid(this.extend(request, parameters));
            }
        } else
        {
            if (isTrue(clientOrderId))
            {
                ((IDictionary<string,object>)request)["client_order_id"] = clientOrderId;
                response = await this.v1PrivateGetClientOrderClientOrderId(this.extend(request, parameters));
            } else
            {
                ((IDictionary<string,object>)request)["oid"] = id;
                response = await this.v1PrivateGetOrderOid(this.extend(request, parameters));
            }
        }
        //
        // {
        //     "success": true,
        //     "timestamp": 1702989203989,
        //     "data": {
        //         "order_id": 78151,
        //         "user_id": 12345,
        //         "price": 0.67772,
        //         "type": "LIMIT",
        //         "quantity": 20,
        //         "amount": 10,
        //         "executed_quantity": 20,
        //         "total_executed_quantity": 20,
        //         "visible_quantity": 1,
        //         "symbol": "PERP_WOO_USDC",
        //         "side": "BUY",
        //         "status": "FILLED",
        //         "total_fee": 0.5,
        //         "fee_asset": "WOO",
        //         "client_order_id": 1,
        //         "average_executed_price": 0.67772,
        //         "created_time": 1653563963000,
        //         "updated_time": 1653564213000,
        //         "realized_pnl": 123
        //     }
        // }
        //
        object orders = this.safeDict(response, "data", response);
        return this.parseOrder(orders, market);
    }

    public async override Task<object> fetchOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name woofipro#fetchOrders
        * @description fetches information on multiple orders made by the user
        * @see https://orderly.network/docs/build-on-evm/evm-api/restful-api/private/get-orders
        * @see https://orderly.network/docs/build-on-evm/evm-api/restful-api/private/get-algo-orders
        * @param {string} symbol unified market symbol of the market orders were made in
        * @param {int} [since] the earliest time in ms to fetch orders for
        * @param {int} [limit] the maximum number of order structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {boolean} [params.trigger] whether the order is a stop/algo order
        * @param {boolean} [params.is_triggered] whether the order has been triggered (false by default)
        * @param {string} [params.side] 'buy' or 'sell'
        * @param {boolean} [params.paginate] set to true if you want to fetch orders with pagination
        * @param {int} params.until timestamp in ms of the latest order to fetch
        * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object paginate = false;
        object isTrigger = this.safeBool2(parameters, "stop", "trigger", false);
        object maxLimit = ((bool) isTrue((isTrigger))) ? 100 : 500;
        var paginateparametersVariable = this.handleOptionAndParams(parameters, "fetchOrders", "paginate");
        paginate = ((IList<object>)paginateparametersVariable)[0];
        parameters = ((IList<object>)paginateparametersVariable)[1];
        if (isTrue(paginate))
        {
            return await this.fetchPaginatedCallIncremental("fetchOrders", symbol, since, limit, parameters, "page", maxLimit);
        }
        object request = new Dictionary<string, object>() {};
        object market = null;
        parameters = this.omit(parameters, new List<object>() {"stop", "trigger"});
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["start_t"] = since;
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["size"] = limit;
        } else
        {
            ((IDictionary<string,object>)request)["size"] = maxLimit;
        }
        if (isTrue(isTrigger))
        {
            ((IDictionary<string,object>)request)["algo_type"] = "STOP";
        }
        var requestparametersVariable = this.handleUntilOption("end_t", request, parameters);
        request = ((IList<object>)requestparametersVariable)[0];
        parameters = ((IList<object>)requestparametersVariable)[1];
        object response = null;
        if (isTrue(isTrigger))
        {
            response = await this.v1PrivateGetAlgoOrders(this.extend(request, parameters));
        } else
        {
            response = await this.v1PrivateGetOrders(this.extend(request, parameters));
        }
        //
        //     {
        //         "success": true,
        //         "timestamp": 1702989203989,
        //         "data": {
        //             "meta": {
        //                 "total": 9,
        //                 "records_per_page": 25,
        //                 "current_page": 1
        //             },
        //             "rows": [{
        //                 "order_id": 78151,
        //                 "user_id": 12345,
        //                 "price": 0.67772,
        //                 "type": "LIMIT",
        //                 "quantity": 20,
        //                 "amount": 10,
        //                 "executed_quantity": 20,
        //                 "total_executed_quantity": 20,
        //                 "visible_quantity": 1,
        //                 "symbol": "PERP_WOO_USDC",
        //                 "side": "BUY",
        //                 "status": "FILLED",
        //                 "total_fee": 0.5,
        //                 "fee_asset": "WOO",
        //                 "client_order_id": 1,
        //                 "average_executed_price": 0.67772,
        //                 "created_time": 1653563963000,
        //                 "updated_time": 1653564213000,
        //                 "realized_pnl": 123
        //             }]
        //         }
        //     }
        //
        object data = this.safeValue(response, "data", response);
        object orders = this.safeList(data, "rows");
        return this.parseOrders(orders, market, since, limit);
    }

    public async override Task<object> fetchOpenOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name woofipro#fetchOpenOrders
        * @description fetches information on multiple orders made by the user
        * @see https://orderly.network/docs/build-on-evm/evm-api/restful-api/private/get-orders
        * @see https://orderly.network/docs/build-on-evm/evm-api/restful-api/private/get-algo-orders
        * @param {string} symbol unified market symbol of the market orders were made in
        * @param {int} [since] the earliest time in ms to fetch orders for
        * @param {int} [limit] the maximum number of order structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {boolean} [params.trigger] whether the order is a stop/algo order
        * @param {boolean} [params.is_triggered] whether the order has been triggered (false by default)
        * @param {string} [params.side] 'buy' or 'sell'
        * @param {int} params.until timestamp in ms of the latest order to fetch
        * @param {boolean} [params.paginate] set to true if you want to fetch orders with pagination
        * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object extendedParams = this.extend(parameters, new Dictionary<string, object>() {
            { "status", "INCOMPLETE" },
        });
        return await this.fetchOrders(symbol, since, limit, extendedParams);
    }

    public async override Task<object> fetchClosedOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name woofipro#fetchClosedOrders
        * @description fetches information on multiple orders made by the user
        * @see https://orderly.network/docs/build-on-evm/evm-api/restful-api/private/get-orders
        * @see https://orderly.network/docs/build-on-evm/evm-api/restful-api/private/get-algo-orders
        * @param {string} symbol unified market symbol of the market orders were made in
        * @param {int} [since] the earliest time in ms to fetch orders for
        * @param {int} [limit] the maximum number of order structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {boolean} [params.trigger] whether the order is a stop/algo order
        * @param {boolean} [params.is_triggered] whether the order has been triggered (false by default)
        * @param {string} [params.side] 'buy' or 'sell'
        * @param {int} params.until timestamp in ms of the latest order to fetch
        * @param {boolean} [params.paginate] set to true if you want to fetch orders with pagination
        * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object extendedParams = this.extend(parameters, new Dictionary<string, object>() {
            { "status", "COMPLETED" },
        });
        return await this.fetchOrders(symbol, since, limit, extendedParams);
    }

    public async override Task<object> fetchOrderTrades(object id, object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name woofipro#fetchOrderTrades
        * @description fetch all the trades made from a single order
        * @see https://orderly.network/docs/build-on-evm/evm-api/restful-api/private/get-all-trades-of-specific-order
        * @param {string} id order id
        * @param {string} symbol unified market symbol
        * @param {int} [since] the earliest time in ms to fetch trades for
        * @param {int} [limit] the maximum number of trades to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
        }
        object request = new Dictionary<string, object>() {
            { "oid", id },
        };
        object response = await this.v1PrivateGetOrderOidTrades(this.extend(request, parameters));
        //
        // {
        //     "success": true,
        //     "timestamp": 1702989203989,
        //     "data": {
        //       "rows": [{
        //         "id": 2,
        //         "symbol": "PERP_BTC_USDC",
        //         "fee": 0.0001,
        //         "fee_asset": "USDC",
        //         "side": "BUY",
        //         "order_id": 1,
        //         "executed_price": 123,
        //         "executed_quantity": 0.05,
        //         "executed_timestamp": 1567382401000,
        //         "is_maker": 1,
        //         "realized_pnl": 123
        //       }]
        //     }
        // }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        object trades = this.safeList(data, "rows", new List<object>() {});
        return this.parseTrades(trades, market, since, limit, parameters);
    }

    public async override Task<object> fetchMyTrades(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name woofipro#fetchMyTrades
        * @see https://orderly.network/docs/build-on-evm/evm-api/restful-api/private/get-trades
        * @description fetch all trades made by the user
        * @param {string} symbol unified market symbol
        * @param {int} [since] the earliest time in ms to fetch trades for
        * @param {int} [limit] the maximum number of trades structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {boolean} [params.paginate] set to true if you want to fetch trades with pagination
        * @param {int} params.until timestamp in ms of the latest trade to fetch
        * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object paginate = false;
        var paginateparametersVariable = this.handleOptionAndParams(parameters, "fetchMyTrades", "paginate");
        paginate = ((IList<object>)paginateparametersVariable)[0];
        parameters = ((IList<object>)paginateparametersVariable)[1];
        if (isTrue(paginate))
        {
            return await this.fetchPaginatedCallIncremental("fetchMyTrades", symbol, since, limit, parameters, "page", 500);
        }
        object request = new Dictionary<string, object>() {};
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["start_t"] = since;
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["size"] = limit;
        } else
        {
            ((IDictionary<string,object>)request)["size"] = 500;
        }
        var requestparametersVariable = this.handleUntilOption("end_t", request, parameters);
        request = ((IList<object>)requestparametersVariable)[0];
        parameters = ((IList<object>)requestparametersVariable)[1];
        object response = await this.v1PrivateGetTrades(this.extend(request, parameters));
        //
        // {
        //     "success": true,
        //     "timestamp": 1702989203989,
        //     "data": {
        //       "meta": {
        //         "total": 9,
        //         "records_per_page": 25,
        //         "current_page": 1
        //       },
        //       "rows": [{
        //         "id": 2,
        //         "symbol": "PERP_BTC_USDC",
        //         "fee": 0.0001,
        //         "fee_asset": "USDC",
        //         "side": "BUY",
        //         "order_id": 1,
        //         "executed_price": 123,
        //         "executed_quantity": 0.05,
        //         "executed_timestamp": 1567382401000,
        //         "is_maker": 1,
        //         "realized_pnl": 123
        //       }]
        //     }
        // }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        object trades = this.safeList(data, "rows", new List<object>() {});
        return this.parseTrades(trades, market, since, limit, parameters);
    }

    public override object parseBalance(object response)
    {
        object result = new Dictionary<string, object>() {
            { "info", response },
        };
        object balances = this.safeList(response, "holding", new List<object>() {});
        for (object i = 0; isLessThan(i, getArrayLength(balances)); postFixIncrement(ref i))
        {
            object balance = getValue(balances, i);
            object code = this.safeCurrencyCode(this.safeString(balance, "token"));
            object account = this.account();
            ((IDictionary<string,object>)account)["total"] = this.safeString(balance, "holding");
            ((IDictionary<string,object>)account)["frozen"] = this.safeString(balance, "frozen");
            ((IDictionary<string,object>)result)[(string)code] = account;
        }
        return this.safeBalance(result);
    }

    public async override Task<object> fetchBalance(object parameters = null)
    {
        /**
        * @method
        * @name woofipro#fetchBalance
        * @description query for balance and get the amount of funds available for trading or funds locked in orders
        * @see https://orderly.network/docs/build-on-evm/evm-api/restful-api/private/get-current-holding
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.v1PrivateGetClientHolding(parameters);
        //
        // {
        //     "success": true,
        //     "timestamp": 1702989203989,
        //     "data": {
        //       "holding": [{
        //         "updated_time": 1580794149000,
        //         "token": "BTC",
        //         "holding": -28.000752,
        //         "frozen": 123,
        //         "pending_short": -2000
        //       }]
        //     }
        // }
        //
        object data = this.safeDict(response, "data");
        return this.parseBalance(data);
    }

    public async virtual Task<object> getAssetHistoryRows(object code = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object currency = null;
        if (isTrue(!isEqual(code, null)))
        {
            currency = this.currency(code);
            ((IDictionary<string,object>)request)["balance_token"] = getValue(currency, "id");
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["start_t"] = since;
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["pageSize"] = limit;
        }
        object transactionType = this.safeString(parameters, "type");
        parameters = this.omit(parameters, "type");
        if (isTrue(!isEqual(transactionType, null)))
        {
            ((IDictionary<string,object>)request)["type"] = transactionType;
        }
        object response = await this.v1PrivateGetAssetHistory(this.extend(request, parameters));
        //
        // {
        //     "success": true,
        //     "timestamp": 1702989203989,
        //     "data": {
        //       "meta": {
        //         "total": 9,
        //         "records_per_page": 25,
        //         "current_page": 1
        //       },
        //       "rows": [{
        //         "id": "230707030600002",
        //         "tx_id": "0x4b0714c63cc7abae72bf68e84e25860b88ca651b7d27dad1e32bf4c027fa5326",
        //         "side": "WITHDRAW",
        //         "token": "USDC",
        //         "amount": 555,
        //         "fee": 123,
        //         "trans_status": "FAILED",
        //         "created_time": 1688699193034,
        //         "updated_time": 1688699193096,
        //         "chain_id": "986532"
        //       }]
        //     }
        // }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        return new List<object>() {currency, this.safeList(data, "rows", new List<object>() {})};
    }

    public override object parseLedgerEntry(object item, object currency = null)
    {
        object currencyId = this.safeString(item, "token");
        object code = this.safeCurrencyCode(currencyId, currency);
        currency = this.safeCurrency(currencyId, currency);
        object amount = this.safeNumber(item, "amount");
        object side = this.safeString(item, "token_side");
        object direction = ((bool) isTrue((isEqual(side, "DEPOSIT")))) ? "in" : "out";
        object timestamp = this.safeInteger(item, "created_time");
        object fee = this.parseTokenAndFeeTemp(item, "fee_token", "fee_amount");
        return this.safeLedgerEntry(new Dictionary<string, object>() {
            { "id", this.safeString(item, "id") },
            { "currency", code },
            { "account", this.safeString(item, "account") },
            { "referenceAccount", null },
            { "referenceId", this.safeString(item, "tx_id") },
            { "status", this.parseTransactionStatus(this.safeString(item, "status")) },
            { "amount", amount },
            { "before", null },
            { "after", null },
            { "fee", fee },
            { "direction", direction },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "type", this.parseLedgerEntryType(this.safeString(item, "type")) },
            { "info", item },
        }, currency);
    }

    public virtual object parseLedgerEntryType(object type)
    {
        object types = new Dictionary<string, object>() {
            { "BALANCE", "transaction" },
            { "COLLATERAL", "transfer" },
        };
        return this.safeString(types, type, type);
    }

    public async override Task<object> fetchLedger(object code = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name woofipro#fetchLedger
        * @description fetch the history of changes, actions done by the user or operations that altered the balance of the user
        * @see https://orderly.network/docs/build-on-evm/evm-api/restful-api/private/get-asset-history
        * @param {string} [code] unified currency code, default is undefined
        * @param {int} [since] timestamp in ms of the earliest ledger entry, default is undefined
        * @param {int} [limit] max number of ledger entries to return, default is undefined
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [ledger structure]{@link https://docs.ccxt.com/#/?id=ledger-structure}
        */
        parameters ??= new Dictionary<string, object>();
        var currencyrowsVariable = await this.getAssetHistoryRows(code, since, limit, parameters);
        var currency = ((IList<object>) currencyrowsVariable)[0];
        var rows = ((IList<object>) currencyrowsVariable)[1];
        return this.parseLedger(rows, currency, since, limit, parameters);
    }

    public override object parseTransaction(object transaction, object currency = null)
    {
        // example in fetchLedger
        object code = this.safeString(transaction, "token");
        object movementDirection = this.safeStringLower(transaction, "token_side");
        if (isTrue(isEqual(movementDirection, "withdraw")))
        {
            movementDirection = "withdrawal";
        }
        object fee = this.parseTokenAndFeeTemp(transaction, "fee_token", "fee_amount");
        object addressTo = this.safeString(transaction, "target_address");
        object addressFrom = this.safeString(transaction, "source_address");
        object timestamp = this.safeInteger(transaction, "created_time");
        return new Dictionary<string, object>() {
            { "info", transaction },
            { "id", this.safeString2(transaction, "id", "withdraw_id") },
            { "txid", this.safeString(transaction, "tx_id") },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "address", null },
            { "addressFrom", addressFrom },
            { "addressTo", addressTo },
            { "tag", this.safeString(transaction, "extra") },
            { "tagFrom", null },
            { "tagTo", null },
            { "type", movementDirection },
            { "amount", this.safeNumber(transaction, "amount") },
            { "currency", code },
            { "status", this.parseTransactionStatus(this.safeString(transaction, "status")) },
            { "updated", this.safeInteger(transaction, "updated_time") },
            { "comment", null },
            { "internal", null },
            { "fee", fee },
            { "network", null },
        };
    }

    public virtual object parseTransactionStatus(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "NEW", "pending" },
            { "CONFIRMING", "pending" },
            { "PROCESSING", "pending" },
            { "COMPLETED", "ok" },
            { "CANCELED", "canceled" },
        };
        return this.safeString(statuses, status, status);
    }

    public async override Task<object> fetchDeposits(object code = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name woofipro#fetchDeposits
        * @description fetch all deposits made to an account
        * @see https://orderly.network/docs/build-on-evm/evm-api/restful-api/private/get-asset-history
        * @param {string} code unified currency code
        * @param {int} [since] the earliest time in ms to fetch deposits for
        * @param {int} [limit] the maximum number of deposits structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
        */
        parameters ??= new Dictionary<string, object>();
        object request = new Dictionary<string, object>() {
            { "side", "DEPOSIT" },
        };
        return await this.fetchDepositsWithdrawals(code, since, limit, this.extend(request, parameters));
    }

    public async override Task<object> fetchWithdrawals(object code = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name woofipro#fetchWithdrawals
        * @description fetch all withdrawals made from an account
        * @see https://orderly.network/docs/build-on-evm/evm-api/restful-api/private/get-asset-history
        * @param {string} code unified currency code
        * @param {int} [since] the earliest time in ms to fetch withdrawals for
        * @param {int} [limit] the maximum number of withdrawals structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
        */
        parameters ??= new Dictionary<string, object>();
        object request = new Dictionary<string, object>() {
            { "side", "WITHDRAW" },
        };
        return await this.fetchDepositsWithdrawals(code, since, limit, this.extend(request, parameters));
    }

    public async override Task<object> fetchDepositsWithdrawals(object code = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name woofipro#fetchDepositsWithdrawals
        * @description fetch history of deposits and withdrawals
        * @see https://orderly.network/docs/build-on-evm/evm-api/restful-api/private/get-asset-history
        * @param {string} [code] unified currency code for the currency of the deposit/withdrawals, default is undefined
        * @param {int} [since] timestamp in ms of the earliest deposit/withdrawal, default is undefined
        * @param {int} [limit] max number of deposit/withdrawals to return, default is undefined
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a list of [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
        */
        parameters ??= new Dictionary<string, object>();
        object request = new Dictionary<string, object>() {};
        var currencyrowsVariable = await this.getAssetHistoryRows(code, since, limit, this.extend(request, parameters));
        var currency = ((IList<object>) currencyrowsVariable)[0];
        var rows = ((IList<object>) currencyrowsVariable)[1];
        //
        //     {
        //         "rows":[],
        //         "meta":{
        //             "total":0,
        //             "records_per_page":25,
        //             "current_page":1
        //         },
        //         "success":true
        //     }
        //
        return this.parseTransactions(rows, currency, since, limit, parameters);
    }

    public async virtual Task<object> getWithdrawNonce(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object response = await this.v1PrivateGetWithdrawNonce(parameters);
        //
        //     {
        //         "success": true,
        //         "timestamp": 1702989203989,
        //         "data": {
        //             "withdraw_nonce": 1
        //         }
        //     }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        return this.safeNumber(data, "withdraw_nonce");
    }

    public virtual object hashMessage(object message)
    {
        return add("0x", this.hash(message, keccak, "hex"));
    }

    public virtual object signHash(object hash, object privateKey)
    {
        object signature = ecdsa(slice(hash, -64, null), slice(privateKey, -64, null), secp256k1, null);
        object r = getValue(signature, "r");
        object s = getValue(signature, "s");
        object v = this.intToBase16(this.sum(27, getValue(signature, "v")));
        return add(add(add("0x", (r as String).PadLeft(Convert.ToInt32(64), Convert.ToChar("0"))), (s as String).PadLeft(Convert.ToInt32(64), Convert.ToChar("0"))), v);
    }

    public virtual object signMessage(object message, object privateKey)
    {
        return this.signHash(this.hashMessage(message), slice(privateKey, -64, null));
    }

    public async override Task<object> withdraw(object code, object amount, object address, object tag = null, object parameters = null)
    {
        /**
        * @method
        * @name woofipro#withdraw
        * @description make a withdrawal
        * @see https://orderly.network/docs/build-on-evm/evm-api/restful-api/private/create-withdraw-request
        * @param {string} code unified currency code
        * @param {float} amount the amount to withdraw
        * @param {string} address the address to withdraw to
        * @param {string} tag
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        this.checkAddress(address);
        if (isTrue(!isEqual(code, null)))
        {
            code = ((string)code).ToUpper();
            if (isTrue(!isEqual(code, "USDC")))
            {
                throw new NotSupported ((string)add(this.id, "withdraw() only support USDC")) ;
            }
        }
        object currency = this.currency(code);
        object verifyingContractAddress = this.safeString(this.options, "verifyingContractAddress");
        object chainId = this.safeString(parameters, "chainId");
        object currencyNetworks = this.safeDict(currency, "networks", new Dictionary<string, object>() {});
        object coinNetwork = this.safeDict(currencyNetworks, chainId, new Dictionary<string, object>() {});
        object coinNetworkId = this.safeNumber(coinNetwork, "id");
        if (isTrue(isEqual(coinNetworkId, null)))
        {
            throw new BadRequest ((string)add(this.id, " withdraw() require chainId parameter")) ;
        }
        object withdrawNonce = await this.getWithdrawNonce(parameters);
        object nonce = this.nonce();
        object domain = new Dictionary<string, object>() {
            { "chainId", chainId },
            { "name", "Orderly" },
            { "verifyingContract", verifyingContractAddress },
            { "version", "1" },
        };
        object messageTypes = new Dictionary<string, object>() {
            { "Withdraw", new List<object>() {new Dictionary<string, object>() {
    { "name", "brokerId" },
    { "type", "string" },
}, new Dictionary<string, object>() {
    { "name", "chainId" },
    { "type", "uint256" },
}, new Dictionary<string, object>() {
    { "name", "receiver" },
    { "type", "address" },
}, new Dictionary<string, object>() {
    { "name", "token" },
    { "type", "string" },
}, new Dictionary<string, object>() {
    { "name", "amount" },
    { "type", "uint256" },
}, new Dictionary<string, object>() {
    { "name", "withdrawNonce" },
    { "type", "uint64" },
}, new Dictionary<string, object>() {
    { "name", "timestamp" },
    { "type", "uint64" },
}} },
        };
        object withdrawRequest = new Dictionary<string, object>() {
            { "brokerId", this.safeString(this.options, "keyBrokerId", "woofi_pro") },
            { "chainId", this.parseToInt(chainId) },
            { "receiver", address },
            { "token", code },
            { "amount", ((object)amount).ToString() },
            { "withdrawNonce", withdrawNonce },
            { "timestamp", nonce },
        };
        object msg = this.ethEncodeStructuredData(domain, messageTypes, withdrawRequest);
        object signature = this.signMessage(msg, this.privateKey);
        object request = new Dictionary<string, object>() {
            { "signature", signature },
            { "userAddress", address },
            { "verifyingContract", verifyingContractAddress },
            { "message", withdrawRequest },
        };
        parameters = this.omit(parameters, "chainId");
        object response = await this.v1PrivatePostWithdrawRequest(this.extend(request, parameters));
        //
        //     {
        //         "success": true,
        //         "timestamp": 1702989203989,
        //         "data": {
        //             "withdraw_id": 123
        //         }
        //     }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        return this.parseTransaction(data, currency);
    }

    public override object parseLeverage(object leverage, object market = null)
    {
        object leverageValue = this.safeInteger(leverage, "max_leverage");
        return new Dictionary<string, object>() {
            { "info", leverage },
            { "symbol", getValue(market, "symbol") },
            { "marginMode", null },
            { "longLeverage", leverageValue },
            { "shortLeverage", leverageValue },
        };
    }

    public async override Task<object> fetchLeverage(object symbol, object parameters = null)
    {
        /**
        * @method
        * @name woofipro#fetchLeverage
        * @description fetch the set leverage for a market
        * @see https://orderly.network/docs/build-on-evm/evm-api/restful-api/private/get-account-information
        * @param {string} symbol unified market symbol
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [leverage structure]{@link https://docs.ccxt.com/#/?id=leverage-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object response = await this.v1PrivateGetClientInfo(parameters);
        //
        // {
        //     "success": true,
        //     "timestamp": 1702989203989,
        //     "data": {
        //         "account_id": "<string>",
        //         "email": "test@test.com",
        //         "account_mode": "FUTURES",
        //         "max_leverage": 20,
        //         "taker_fee_rate": 123,
        //         "maker_fee_rate": 123,
        //         "futures_taker_fee_rate": 123,
        //         "futures_maker_fee_rate": 123,
        //         "maintenance_cancel_orders": true,
        //         "imr_factor": {
        //             "PERP_BTC_USDC": 123,
        //             "PERP_ETH_USDC": 123,
        //             "PERP_NEAR_USDC": 123
        //         },
        //         "max_notional": {
        //             "PERP_BTC_USDC": 123,
        //             "PERP_ETH_USDC": 123,
        //             "PERP_NEAR_USDC": 123
        //         }
        //     }
        // }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        return this.parseLeverage(data, market);
    }

    public async override Task<object> setLeverage(object leverage, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name woofipro#setLeverage
        * @description set the level of leverage for a market
        * @see https://orderly.network/docs/build-on-evm/evm-api/restful-api/private/update-leverage-setting
        * @param {string} symbol unified market symbol
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} response from the exchange
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        if (isTrue(isTrue((isLessThan(leverage, 1))) || isTrue((isGreaterThan(leverage, 50)))))
        {
            throw new BadRequest ((string)add(this.id, " leverage should be between 1 and 50")) ;
        }
        object request = new Dictionary<string, object>() {
            { "leverage", leverage },
        };
        return await this.v1PrivatePostClientLeverage(this.extend(request, parameters));
    }

    public override object parsePosition(object position, object market = null)
    {
        //
        // {
        //     "IMR_withdraw_orders": 0.1,
        //     "MMR_with_orders": 0.05,
        //     "average_open_price": 27908.14386047,
        //     "cost_position": -139329.358492,
        //     "est_liq_price": 117335.92899428,
        //     "fee_24_h": 123,
        //     "imr": 0.1,
        //     "last_sum_unitary_funding": 70.38,
        //     "mark_price": 27794.9,
        //     "mmr": 0.05,
        //     "pending_long_qty": 123,
        //     "pending_short_qty": 123,
        //     "pnl_24_h": 123,
        //     "position_qty": -5,
        //     "settle_price": 27865.8716984,
        //     "symbol": "PERP_BTC_USDC",
        //     "timestamp": 1685429350571,
        //     "unsettled_pnl": 354.858492
        // }
        //
        object contract = this.safeString(position, "symbol");
        market = this.safeMarket(contract, market);
        object size = this.safeString(position, "position_qty");
        object side = null;
        if (isTrue(Precise.stringGt(size, "0")))
        {
            side = "long";
        } else
        {
            side = "short";
        }
        object contractSize = this.safeString(market, "contractSize");
        object markPrice = this.safeString(position, "mark_price");
        object timestamp = this.safeInteger(position, "timestamp");
        object entryPrice = this.safeString(position, "average_open_price");
        object unrealisedPnl = this.safeString(position, "unsettled_pnl");
        size = Precise.stringAbs(size);
        object notional = Precise.stringMul(size, markPrice);
        return this.safePosition(new Dictionary<string, object>() {
            { "info", position },
            { "id", null },
            { "symbol", this.safeString(market, "symbol") },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "lastUpdateTimestamp", null },
            { "initialMargin", null },
            { "initialMarginPercentage", null },
            { "maintenanceMargin", null },
            { "maintenanceMarginPercentage", null },
            { "entryPrice", this.parseNumber(entryPrice) },
            { "notional", this.parseNumber(notional) },
            { "leverage", null },
            { "unrealizedPnl", this.parseNumber(unrealisedPnl) },
            { "contracts", this.parseNumber(size) },
            { "contractSize", this.parseNumber(contractSize) },
            { "marginRatio", null },
            { "liquidationPrice", this.safeNumber(position, "est_liq_price") },
            { "markPrice", this.parseNumber(markPrice) },
            { "lastPrice", null },
            { "collateral", null },
            { "marginMode", "cross" },
            { "marginType", null },
            { "side", side },
            { "percentage", null },
            { "hedged", null },
            { "stopLossPrice", null },
            { "takeProfitPrice", null },
        });
    }

    public async override Task<object> fetchPosition(object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name woofipro#fetchPosition
        * @see https://orderly.network/docs/build-on-evm/evm-api/restful-api/private/get-one-position-info
        * @description fetch data on an open position
        * @param {string} symbol unified market symbol of the market the position is held in
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [position structure]{@link https://docs.ccxt.com/#/?id=position-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object response = await this.v1PrivateGetPositionSymbol(this.extend(request, parameters));
        //
        // {
        //     "success": true,
        //     "timestamp": 1702989203989,
        //     "data": {
        //         "IMR_withdraw_orders": 0.1,
        //         "MMR_with_orders": 0.05,
        //         "average_open_price": 27908.14386047,
        //         "cost_position": -139329.358492,
        //         "est_liq_price": 117335.92899428,
        //         "fee_24_h": 123,
        //         "imr": 0.1,
        //         "last_sum_unitary_funding": 70.38,
        //         "mark_price": 27794.9,
        //         "mmr": 0.05,
        //         "pending_long_qty": 123,
        //         "pending_short_qty": 123,
        //         "pnl_24_h": 123,
        //         "position_qty": -5,
        //         "settle_price": 27865.8716984,
        //         "symbol": "PERP_BTC_USDC",
        //         "timestamp": 1685429350571,
        //         "unsettled_pnl": 354.858492
        //     }
        // }
        //
        object data = this.safeDict(response, "data");
        return this.parsePosition(data, market);
    }

    public async override Task<object> fetchPositions(object symbols = null, object parameters = null)
    {
        /**
        * @method
        * @name woofipro#fetchPositions
        * @description fetch all open positions
        * @see https://orderly.network/docs/build-on-evm/evm-api/restful-api/private/get-all-positions-info
        * @param {string[]} [symbols] list of unified market symbols
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {string} [method] method name to call, "positionRisk", "account" or "option", default is "positionRisk"
        * @returns {object[]} a list of [position structure]{@link https://docs.ccxt.com/#/?id=position-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.v1PrivateGetPositions(parameters);
        //
        // {
        //     "success": true,
        //     "timestamp": 1702989203989,
        //     "data": {
        //         "current_margin_ratio_with_orders": 1.2385,
        //         "free_collateral": 450315.09115,
        //         "initial_margin_ratio": 0.1,
        //         "initial_margin_ratio_with_orders": 0.1,
        //         "maintenance_margin_ratio": 0.05,
        //         "maintenance_margin_ratio_with_orders": 0.05,
        //         "margin_ratio": 1.2385,
        //         "open_margin_ratio": 1.2102,
        //         "total_collateral_value": 489865.71329,
        //         "total_pnl_24_h": 123,
        //         "rows": [{
        //             "IMR_withdraw_orders": 0.1,
        //             "MMR_with_orders": 0.05,
        //             "average_open_price": 27908.14386047,
        //             "cost_position": -139329.358492,
        //             "est_liq_price": 117335.92899428,
        //             "fee_24_h": 123,
        //             "imr": 0.1,
        //             "last_sum_unitary_funding": 70.38,
        //             "mark_price": 27794.9,
        //             "mmr": 0.05,
        //             "pending_long_qty": 123,
        //             "pending_short_qty": 123,
        //             "pnl_24_h": 123,
        //             "position_qty": -5,
        //             "settle_price": 27865.8716984,
        //             "symbol": "PERP_BTC_USDC",
        //             "timestamp": 1685429350571,
        //             "unsettled_pnl": 354.858492
        //         }]
        //     }
        // }
        //
        object result = this.safeDict(response, "data", new Dictionary<string, object>() {});
        object positions = this.safeList(result, "rows", new List<object>() {});
        return this.parsePositions(positions, symbols);
    }

    public override object nonce()
    {
        return this.milliseconds();
    }

    public override object sign(object path, object section = null, object method = null, object parameters = null, object headers = null, object body = null)
    {
        section ??= "public";
        method ??= "GET";
        parameters ??= new Dictionary<string, object>();
        object version = getValue(section, 0);
        object access = getValue(section, 1);
        object pathWithParams = this.implodeParams(path, parameters);
        object url = this.implodeHostname(getValue(getValue(this.urls, "api"), access));
        url = add(url, add(add("/", version), "/"));
        parameters = this.omit(parameters, this.extractParams(path));
        parameters = this.keysort(parameters);
        if (isTrue(isEqual(access, "public")))
        {
            url = add(url, pathWithParams);
            if (isTrue(getArrayLength(new List<object>(((IDictionary<string,object>)parameters).Keys))))
            {
                url = add(url, add("?", this.urlencode(parameters)));
            }
        } else
        {
            this.checkRequiredCredentials();
            if (isTrue(isTrue((isTrue(isEqual(method, "POST")) || isTrue(isEqual(method, "PUT")))) && isTrue((isTrue(isTrue(isEqual(path, "algo/order")) || isTrue(isEqual(path, "order"))) || isTrue(isEqual(path, "batch-order"))))))
            {
                object isSandboxMode = this.safeBool(this.options, "sandboxMode", false);
                if (!isTrue(isSandboxMode))
                {
                    object brokerId = this.safeString(this.options, "brokerId", "CCXT");
                    if (isTrue(isEqual(path, "batch-order")))
                    {
                        object ordersList = this.safeList(parameters, "orders", new List<object>() {});
                        for (object i = 0; isLessThan(i, getArrayLength(ordersList)); postFixIncrement(ref i))
                        {
                            ((IDictionary<string,object>)getValue(getValue(parameters, "orders"), i))["order_tag"] = brokerId;
                        }
                    } else
                    {
                        ((IDictionary<string,object>)parameters)["order_tag"] = brokerId;
                    }
                }
                parameters = this.keysort(parameters);
            }
            object auth = "";
            object ts = ((object)this.nonce()).ToString();
            url = add(url, pathWithParams);
            headers = new Dictionary<string, object>() {
                { "orderly-account-id", this.accountId },
                { "orderly-key", this.apiKey },
                { "orderly-timestamp", ts },
            };
            auth = add(add(add(add(add(ts, method), "/"), version), "/"), pathWithParams);
            if (isTrue(isTrue(isEqual(method, "POST")) || isTrue(isEqual(method, "PUT"))))
            {
                body = this.json(parameters);
                auth = add(auth, body);
                ((IDictionary<string,object>)headers)["content-type"] = "application/json";
            } else
            {
                if (isTrue(getArrayLength(new List<object>(((IDictionary<string,object>)parameters).Keys))))
                {
                    url = add(url, add("?", this.urlencode(parameters)));
                    auth = add(auth, add("?", this.rawencode(parameters)));
                }
                ((IDictionary<string,object>)headers)["content-type"] = "application/x-www-form-urlencoded";
                if (isTrue(isEqual(method, "DELETE")))
                {
                    body = "";
                }
            }
            object secret = this.secret;
            if (isTrue(isGreaterThanOrEqual(getIndexOf(secret, "ed25519:"), 0)))
            {
                object parts = ((string)secret).Split(new [] {((string)"ed25519:")}, StringSplitOptions.None).ToList<object>();
                secret = getValue(parts, 1);
            }
            object signature = eddsa(this.encode(auth), this.base58ToBinary(secret), ed25519);
            ((IDictionary<string,object>)headers)["orderly-signature"] = this.urlencodeBase64(this.base64ToBinary(signature));
        }
        return new Dictionary<string, object>() {
            { "url", url },
            { "method", method },
            { "body", body },
            { "headers", headers },
        };
    }

    public override object handleErrors(object httpCode, object reason, object url, object method, object headers, object body, object response, object requestHeaders, object requestBody)
    {
        if (!isTrue(response))
        {
            return null;  // fallback to default error handler
        }
        //
        //     400 Bad Request {"success":false,"code":-1012,"message":"Amount is required for buy market orders when margin disabled."}
        //                     {"code":"-1011","message":"The system is under maintenance.","success":false}
        //
        object success = this.safeBool(response, "success");
        object errorCode = this.safeString(response, "code");
        if (!isTrue(success))
        {
            object feedback = add(add(this.id, " "), this.json(response));
            this.throwBroadlyMatchedException(getValue(this.exceptions, "broad"), body, feedback);
            this.throwExactlyMatchedException(getValue(this.exceptions, "exact"), errorCode, feedback);
            throw new ExchangeError ((string)feedback) ;
        }
        return null;
    }
}
