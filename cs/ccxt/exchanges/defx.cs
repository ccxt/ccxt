namespace ccxt;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

public partial class defx : Exchange
{
    public override object describe()
    {
        return this.deepExtend(base.describe(), new Dictionary<string, object>() {
            { "id", "defx" },
            { "name", "Defx X" },
            { "rateLimit", 100 },
            { "version", "v1" },
            { "certified", false },
            { "pro", false },
            { "hostname", "defx.com" },
            { "dex", true },
            { "has", new Dictionary<string, object>() {
                { "CORS", null },
                { "spot", false },
                { "margin", false },
                { "swap", true },
                { "future", false },
                { "option", false },
                { "addMargin", true },
                { "cancelAllOrders", true },
                { "cancelAllOrdersAfter", false },
                { "cancelOrder", true },
                { "cancelWithdraw", false },
                { "closeAllPositions", true },
                { "closePosition", true },
                { "createConvertTrade", false },
                { "createDepositAddress", false },
                { "createMarketBuyOrderWithCost", false },
                { "createMarketOrder", false },
                { "createMarketOrderWithCost", false },
                { "createMarketSellOrderWithCost", false },
                { "createOrder", true },
                { "createOrderWithTakeProfitAndStopLoss", true },
                { "createReduceOnlyOrder", true },
                { "createStopLimitOrder", false },
                { "createStopLossOrder", false },
                { "createStopMarketOrder", false },
                { "createStopOrder", false },
                { "createTakeProfitOrder", true },
                { "createTrailingAmountOrder", false },
                { "createTrailingPercentOrder", false },
                { "createTriggerOrder", true },
                { "fetchAccounts", false },
                { "fetchBalance", true },
                { "fetchCanceledOrders", true },
                { "fetchClosedOrder", false },
                { "fetchClosedOrders", true },
                { "fetchConvertCurrencies", false },
                { "fetchConvertQuote", false },
                { "fetchConvertTrade", false },
                { "fetchConvertTradeHistory", false },
                { "fetchCurrencies", false },
                { "fetchDepositAddress", false },
                { "fetchDepositAddresses", false },
                { "fetchDepositAddressesByNetwork", false },
                { "fetchDeposits", false },
                { "fetchDepositsWithdrawals", false },
                { "fetchFundingHistory", false },
                { "fetchFundingInterval", false },
                { "fetchFundingIntervals", false },
                { "fetchFundingRate", true },
                { "fetchFundingRateHistory", false },
                { "fetchFundingRates", false },
                { "fetchIndexOHLCV", false },
                { "fetchLedger", true },
                { "fetchLeverage", false },
                { "fetchMarginAdjustmentHistory", false },
                { "fetchMarginMode", false },
                { "fetchMarkets", true },
                { "fetchMarkOHLCV", false },
                { "fetchMarkPrice", false },
                { "fetchMarkPrices", false },
                { "fetchMyTrades", true },
                { "fetchOHLCV", true },
                { "fetchOpenInterestHistory", false },
                { "fetchOpenOrder", false },
                { "fetchOpenOrders", true },
                { "fetchOrder", true },
                { "fetchOrderBook", true },
                { "fetchOrders", true },
                { "fetchOrderTrades", false },
                { "fetchPosition", true },
                { "fetchPositionHistory", false },
                { "fetchPositionMode", false },
                { "fetchPositions", true },
                { "fetchPositionsHistory", false },
                { "fetchPremiumIndexOHLCV", false },
                { "fetchStatus", true },
                { "fetchTicker", true },
                { "fetchTickers", true },
                { "fetchTime", true },
                { "fetchTrades", true },
                { "fetchTradingFee", false },
                { "fetchTradingFees", false },
                { "fetchTransactions", false },
                { "fetchTransfers", false },
                { "fetchWithdrawals", false },
                { "reduceMargin", false },
                { "sandbox", true },
                { "setLeverage", true },
                { "setMargin", false },
                { "setPositionMode", false },
                { "transfer", false },
                { "withdraw", true },
            } },
            { "timeframes", new Dictionary<string, object>() {
                { "1m", "1m" },
                { "3m", "3m" },
                { "5m", "5m" },
                { "15m", "15m" },
                { "30m", "30m" },
                { "1h", "1h" },
                { "2h", "2h" },
                { "4h", "4h" },
                { "12h", "12h" },
                { "1d", "1d" },
                { "1w", "1w" },
                { "1M", "1M" },
            } },
            { "urls", new Dictionary<string, object>() {
                { "logo", "https://github.com/user-attachments/assets/4e92bace-d7a9-45ea-92be-122168dc87e4" },
                { "api", new Dictionary<string, object>() {
                    { "public", "https://api.{hostname}" },
                    { "private", "https://api.{hostname}" },
                } },
                { "test", new Dictionary<string, object>() {
                    { "public", "https://api.testnet.{hostname}" },
                    { "private", "https://api.testnet.{hostname}" },
                } },
                { "www", "https://defx.com/home" },
                { "doc", new List<object>() {"https://docs.defx.com/docs", "https://api-docs.defx.com/"} },
                { "fees", new List<object>() {""} },
                { "referral", new Dictionary<string, object>() {
                    { "url", "https://app.defx.com/join/6I2CZ7" },
                } },
            } },
            { "api", new Dictionary<string, object>() {
                { "v1", new Dictionary<string, object>() {
                    { "public", new Dictionary<string, object>() {
                        { "get", new Dictionary<string, object>() {
                            { "healthcheck/ping", 1 },
                            { "symbols/{symbol}/ohlc", 1 },
                            { "symbols/{symbol}/trades", 1 },
                            { "symbols/{symbol}/prices", 1 },
                            { "symbols/{symbol}/ticker/24hr", 1 },
                            { "symbols/{symbol}/depth/{level}/{slab}", 1 },
                            { "ticker/24HrAgg", 1 },
                            { "c/markets", 1 },
                            { "c/markets/metadata", 1 },
                            { "analytics/market/stats/newUsers", 1 },
                            { "analytics/market/stats/tvl", 1 },
                            { "analytics/market/stats/volumeByInstrument", 1 },
                            { "analytics/market/stats/liquidation", 1 },
                            { "analytics/market/stats/totalVolume", 1 },
                            { "analytics/market/stats/openInterest", 1 },
                            { "analytics/market/stats/totalTrades", 1 },
                            { "analytics/market/stats/basis", 1 },
                            { "analytics/market/stats/insuranceFund", 1 },
                            { "analytics/market/stats/longAndShortRatio", 1 },
                            { "analytics/market/stats/fundingRate", 1 },
                            { "analytics/market/overview", 1 },
                            { "explorer/search", 1 },
                            { "explorer/transactions", 1 },
                            { "explorer/blocks", 1 },
                        } },
                    } },
                    { "private", new Dictionary<string, object>() {
                        { "get", new Dictionary<string, object>() {
                            { "api/order/{orderId}", 1 },
                            { "api/orders", 1 },
                            { "api/orders/oco/{parentOrderId}", 1 },
                            { "api/trades", 1 },
                            { "api/position/active", 1 },
                            { "api/users/metadata/leverage", 1 },
                            { "api/users/metadata/feeMultiplier", 1 },
                            { "api/users/metadata/slippage", 1 },
                            { "api/users/referral", 1 },
                            { "api/users/apikeys", 1 },
                            { "connection-signature-message/evm", 1 },
                            { "api/users/profile/wallets", 1 },
                            { "api/notifications", 1 },
                            { "api/wallet/balance", 1 },
                            { "api/wallet/transactions", 1 },
                            { "api/analytics/user/overview", 1 },
                            { "api/analytics/user/pnl", 1 },
                            { "api/analytics/points/overview", 1 },
                            { "api/analytics/points/history", 1 },
                        } },
                        { "post", new Dictionary<string, object>() {
                            { "api/order", 1 },
                            { "api/position/oco", 1 },
                            { "api/users/socket/listenKeys", 1 },
                            { "api/users/metadata/leverage", 1 },
                            { "api/users/metadata/feeMultiplier", 1 },
                            { "api/users/metadata/slippage", 1 },
                            { "api/users/referral/recordReferralSignup", 1 },
                            { "api/users/apikeys", 1 },
                            { "api/users/profile/wallets", 1 },
                            { "api/transfers/withdrawal", 1 },
                            { "api/transfers/bridge/withdrawal", 1 },
                        } },
                        { "put", new Dictionary<string, object>() {
                            { "api/position/updatePositionMargin", 1 },
                            { "api/users/socket/listenKeys/{listenKey}", 1 },
                            { "api/users/apikeys/{accessKey}/status", 1 },
                            { "api/users/referral", 1 },
                        } },
                        { "patch", new Dictionary<string, object>() {
                            { "api/users/apikeys/{accessKey}", 1 },
                        } },
                        { "delete", new Dictionary<string, object>() {
                            { "api/orders/allOpen", 1 },
                            { "api/order/{orderId}", 1 },
                            { "api/position/{positionId}", 1 },
                            { "api/position/all", 1 },
                            { "api/users/socket/listenKeys/{listenKey}", 1 },
                            { "api/users/apikeys/{accessKey}", 1 },
                        } },
                    } },
                } },
            } },
            { "fees", new Dictionary<string, object>() {
                { "trading", new Dictionary<string, object>() {
                    { "tierBased", true },
                    { "percentage", true },
                    { "maker", this.parseNumber("0.0002") },
                    { "taker", this.parseNumber("0.0005") },
                } },
            } },
            { "options", new Dictionary<string, object>() {
                { "sandboxMode", false },
            } },
            { "features", new Dictionary<string, object>() {
                { "spot", null },
                { "forDerivatives", new Dictionary<string, object>() {
                    { "sandbox", true },
                    { "createOrder", new Dictionary<string, object>() {
                        { "marginMode", false },
                        { "triggerPrice", true },
                        { "triggerPriceType", new Dictionary<string, object>() {
                            { "last", true },
                            { "mark", true },
                            { "index", false },
                        } },
                        { "triggerDirection", false },
                        { "stopLossPrice", false },
                        { "takeProfitPrice", false },
                        { "attachedStopLossTakeProfit", null },
                        { "timeInForce", new Dictionary<string, object>() {
                            { "IOC", true },
                            { "FOK", true },
                            { "PO", true },
                            { "GTD", false },
                        } },
                        { "hedged", false },
                        { "selfTradePrevention", false },
                        { "trailing", false },
                        { "iceberg", false },
                        { "leverage", false },
                        { "marketBuyByCost", false },
                        { "marketBuyRequiresPrice", false },
                    } },
                    { "createOrders", null },
                    { "fetchMyTrades", new Dictionary<string, object>() {
                        { "marginMode", false },
                        { "limit", 1000 },
                        { "daysBack", null },
                        { "untilDays", null },
                    } },
                    { "fetchOrder", new Dictionary<string, object>() {
                        { "marginMode", false },
                        { "trigger", false },
                        { "trailing", false },
                    } },
                    { "fetchOpenOrders", new Dictionary<string, object>() {
                        { "marginMode", true },
                        { "limit", 100 },
                        { "trigger", false },
                        { "trailing", false },
                    } },
                    { "fetchOrders", new Dictionary<string, object>() {
                        { "marginMode", false },
                        { "limit", 500 },
                        { "daysBack", 100000 },
                        { "untilDays", 100000 },
                        { "trigger", false },
                        { "trailing", false },
                    } },
                    { "fetchClosedOrders", new Dictionary<string, object>() {
                        { "marginMode", false },
                        { "limit", 500 },
                        { "daysBack", 100000 },
                        { "daysBackCanceled", 1 },
                        { "untilDays", 100000 },
                        { "trigger", false },
                        { "trailing", false },
                    } },
                    { "fetchOHLCV", new Dictionary<string, object>() {
                        { "limit", 1000 },
                    } },
                } },
                { "swap", new Dictionary<string, object>() {
                    { "linear", new Dictionary<string, object>() {
                        { "extends", "forDerivatives" },
                    } },
                    { "inverse", null },
                } },
                { "future", new Dictionary<string, object>() {
                    { "linear", null },
                    { "inverse", null },
                } },
            } },
            { "commonCurrencies", new Dictionary<string, object>() {} },
            { "exceptions", new Dictionary<string, object>() {
                { "exact", new Dictionary<string, object>() {
                    { "404", typeof(BadRequest) },
                    { "missing_auth_signature", typeof(AuthenticationError) },
                    { "order_rejected", typeof(InvalidOrder) },
                    { "invalid_order_id", typeof(InvalidOrder) },
                    { "filter_lotsize_maxqty", typeof(InvalidOrder) },
                    { "filter_notional_min", typeof(InvalidOrder) },
                    { "failed_index_price_up_multiplier_filter", typeof(InvalidOrder) },
                    { "no_open_orders", typeof(InvalidOrder) },
                    { "active_position_not_found", typeof(InvalidOrder) },
                    { "position_inactive", typeof(InvalidOrder) },
                    { "invalid_position_id", typeof(InvalidOrder) },
                    { "Internal server error", typeof(ExchangeError) },
                } },
                { "broad", new Dictionary<string, object>() {
                    { "Bad Request", typeof(BadRequest) },
                } },
            } },
            { "precisionMode", TICK_SIZE },
        });
    }

    /**
     * @method
     * @name defx#fetchStatus
     * @description the latest known information on the availability of the exchange API
     * @see https://api-docs.defx.com/#4b03bb3b-a0fa-4dfb-b96c-237bde0ce9e6
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [status structure]{@link https://docs.ccxt.com/#/?id=exchange-status-structure}
     */
    public async override Task<object> fetchStatus(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object response = await this.v1PublicGetHealthcheckPing(parameters);
        //
        // {
        //     "success": true,
        //     "t": 1709705048323,
        //     "v": "0.0.7",
        //     "msg": "A programmer’s wife tells him, “While you’re at the grocery store, buy some eggs.” He never comes back."
        // }
        //
        object status = null;
        object success = this.safeBool(response, "success");
        if (isTrue(success))
        {
            status = "ok";
        } else
        {
            status = "error";
        }
        return new Dictionary<string, object>() {
            { "status", status },
            { "updated", null },
            { "eta", null },
            { "url", null },
            { "info", response },
        };
    }

    /**
     * @method
     * @name defx#fetchTime
     * @description fetches the current integer timestamp in milliseconds from the exchange server
     * @see https://api-docs.defx.com/#4b03bb3b-a0fa-4dfb-b96c-237bde0ce9e6
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {int} the current integer timestamp in milliseconds from the exchange server
     */
    public async override Task<object> fetchTime(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object response = await this.v1PublicGetHealthcheckPing(parameters);
        //
        // {
        //     "success": true,
        //     "t": 1709705048323,
        //     "v": "0.0.7",
        //     "msg": "A programmer’s wife tells him, “While you’re at the grocery store, buy some eggs.” He never comes back."
        // }
        //
        return this.safeInteger(response, "t");
    }

    /**
     * @method
     * @name defx#fetchMarkets
     * @description retrieves data on all markets for defx
     * @see https://api-docs.defx.com/#73cce0c8-f842-4891-9145-01bb6d61324d
     * @see https://api-docs.defx.com/#24fd4e5b-840e-451e-99e0-7fea47c7f371
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} an array of objects representing market data
     */
    public async override Task<object> fetchMarkets(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object request = new Dictionary<string, object>() {
            { "type", "perps" },
        };
        object promises = new List<object> {this.v1PublicGetCMarkets(this.extend(request, parameters)), this.v1PublicGetCMarketsMetadata(this.extend(request, parameters))};
        object responses = await promiseAll(promises);
        //
        // {
        //     "data": [
        //       {
        //         "market": "DOGE_USDC",
        //         "candleWindows": [
        //           "1m",
        //           "3m",
        //           "5m",
        //           "15m",
        //           "30m",
        //           "1h",
        //           "2h",
        //           "4h",
        //           "12h",
        //           "1d",
        //           "1w",
        //           "1M"
        //         ],
        //         "depthSlabs": [
        //           "0.00001",
        //           "0.00005",
        //           "0.0001",
        //           "0.001",
        //           "0.01"
        //         ],
        //         "filters": [
        //           {
        //             "filterType": "LOT_SIZE",
        //             "minQty": "1.00000",
        //             "maxQty": "1500000.00000",
        //             "stepSize": "1.00000"
        //           },
        //           {
        //             "filterType": "MARKET_LOT_SIZE",
        //             "minQty": "1.00000",
        //             "maxQty": "750000.00000",
        //             "stepSize": "1.00000"
        //           },
        //           {
        //             "filterType": "PRICE_FILTER",
        //             "minPrice": "0.00244000",
        //             "maxPrice": "30.00000000",
        //             "tickSize": "0.00001"
        //           },
        //           {
        //             "filterType": "NOTIONAL",
        //             "minNotional": "100.00000000"
        //           },
        //           {
        //             "filterType": "PERCENT_PRICE_BY_SIDE",
        //             "bidMultiplierUp": "1.5",
        //             "bidMultiplierDown": "0.5",
        //             "askMultiplierUp": "1.5",
        //             "askMultiplierDown": "0.5"
        //           },
        //           {
        //             "filterType": "INDEX_PRICE_FILTER",
        //             "multiplierUp": "1.3",
        //             "multiplierDown": "0.7"
        //           }
        //         ],
        //         "cappedLeverage": "25",
        //         "maintenanceMarginTiers": [
        //           {
        //             "tier": "1",
        //             "minMaintenanceMargin": "0",
        //             "maxMaintenanceMargin": "2500",
        //             "leverage": "25"
        //           },
        //           {
        //             "tier": "2",
        //             "minMaintenanceMargin": "2500",
        //             "maxMaintenanceMargin": "12500",
        //             "leverage": "20"
        //           },
        //           {
        //             "tier": "3",
        //             "minMaintenanceMargin": "12500",
        //             "maxMaintenanceMargin": "25000",
        //             "leverage": "15"
        //           },
        //           {
        //             "tier": "4",
        //             "minMaintenanceMargin": "25000",
        //             "maxMaintenanceMargin": "50000",
        //             "leverage": "10"
        //           },
        //           {
        //             "tier": "5",
        //             "minMaintenanceMargin": "50000",
        //             "maxMaintenanceMargin": "75000",
        //             "leverage": "8"
        //           },
        //           {
        //             "tier": "6",
        //             "minMaintenanceMargin": "75000",
        //             "maxMaintenanceMargin": "125000",
        //             "leverage": "7"
        //           },
        //           {
        //             "tier": "7",
        //             "minMaintenanceMargin": "125000",
        //             "maxMaintenanceMargin": "187500",
        //             "leverage": "5"
        //           },
        //           {
        //             "tier": "8",
        //             "minMaintenanceMargin": "187500",
        //             "maxMaintenanceMargin": "250000",
        //             "leverage": "3"
        //           },
        //           {
        //             "tier": "9",
        //             "minMaintenanceMargin": "250000",
        //             "maxMaintenanceMargin": "375000",
        //             "leverage": "2"
        //           },
        //           {
        //             "tier": "10",
        //             "minMaintenanceMargin": "375000",
        //             "maxMaintenanceMargin": "500000",
        //             "leverage": "1"
        //           }
        //         ],
        //         "fees": {
        //           "maker": "0.08",
        //           "taker": "0.1"
        //         }
        //       },
        //     ]
        // }
        //
        object activeMarkets = this.safeList(getValue(responses, 0), "data");
        object activeMarketsByType = this.indexBy(activeMarkets, "market");
        object marketMetadatas = this.safeList(getValue(responses, 1), "data");
        for (object i = 0; isLessThan(i, getArrayLength(marketMetadatas)); postFixIncrement(ref i))
        {
            object marketId = getValue(getValue(marketMetadatas, i), "market");
            object status = null;
            if (isTrue(inOp(activeMarketsByType, marketId)))
            {
                status = getValue(getValue(activeMarketsByType, marketId), "status");
            }
            ((IDictionary<string,object>)getValue(marketMetadatas, i))["status"] = status;
        }
        return this.parseMarkets(marketMetadatas);
    }

    public override object parseMarket(object market)
    {
        object marketId = this.safeString(market, "market");
        object parts = ((string)marketId).Split(new [] {((string)"_")}, StringSplitOptions.None).ToList<object>();
        object baseId = this.safeString(parts, 0);
        object quoteId = this.safeString(parts, 1);
        object bs = this.safeCurrencyCode(baseId);
        object quote = this.safeCurrencyCode(quoteId);
        object symbol = add(add(add(add(bs, "/"), quote), ":"), quote);
        object filters = this.safeList(market, "filters", new List<object>() {});
        object fees = this.safeDict(market, "fees", new Dictionary<string, object>() {});
        object filtersByType = this.indexBy(filters, "filterType");
        object priceFilter = this.safeDict(filtersByType, "PRICE_FILTER", new Dictionary<string, object>() {});
        object lotFilter = this.safeDict(filtersByType, "LOT_SIZE", new Dictionary<string, object>() {});
        object marketLotFilter = this.safeDict(filtersByType, "MARKET_LOT_SIZE", new Dictionary<string, object>() {});
        object notionalFilter = this.safeDict(filtersByType, "NOTIONAL", new Dictionary<string, object>() {});
        return new Dictionary<string, object>() {
            { "id", marketId },
            { "symbol", symbol },
            { "base", bs },
            { "quote", quote },
            { "settle", quote },
            { "baseId", baseId },
            { "quoteId", quoteId },
            { "settleId", quoteId },
            { "type", "swap" },
            { "spot", false },
            { "margin", false },
            { "swap", true },
            { "future", false },
            { "option", false },
            { "active", isEqual(this.safeString(market, "status", ""), "active") },
            { "contract", true },
            { "linear", true },
            { "inverse", null },
            { "taker", this.safeNumber(fees, "taker") },
            { "maker", this.safeNumber(fees, "maker") },
            { "contractSize", this.parseNumber("1") },
            { "expiry", null },
            { "expiryDatetime", null },
            { "strike", null },
            { "optionType", null },
            { "precision", new Dictionary<string, object>() {
                { "amount", this.safeNumber(lotFilter, "stepSize") },
                { "price", this.safeNumber(priceFilter, "tickSize") },
            } },
            { "limits", new Dictionary<string, object>() {
                { "leverage", new Dictionary<string, object>() {
                    { "min", null },
                    { "max", this.safeNumber(market, "cappedLeverage") },
                } },
                { "amount", new Dictionary<string, object>() {
                    { "min", this.safeNumber(lotFilter, "minQty") },
                    { "max", this.safeNumber(lotFilter, "maxQty") },
                } },
                { "price", new Dictionary<string, object>() {
                    { "min", this.safeNumber(priceFilter, "minPrice") },
                    { "max", this.safeNumber(priceFilter, "maxPrice") },
                } },
                { "cost", new Dictionary<string, object>() {
                    { "min", this.safeNumber(notionalFilter, "minNotional") },
                    { "max", null },
                } },
                { "market", new Dictionary<string, object>() {
                    { "min", this.safeNumber(marketLotFilter, "minQty") },
                    { "max", this.safeNumber(marketLotFilter, "maxQty") },
                } },
            } },
            { "created", null },
            { "info", market },
        };
    }

    /**
     * @method
     * @name defx#fetchTicker
     * @description fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
     * @see https://api-docs.defx.com/#fe6f81d0-2f3a-4eee-976f-c8fc8f4c5d56
     * @param {string} symbol unified symbol of the market to fetch the ticker for
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
     */
    public async override Task<object> fetchTicker(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object response = await this.v1PublicGetSymbolsSymbolTicker24hr(this.extend(request, parameters));
        //
        // {
        //     "symbol": "BTC_USDC",
        //     "priceChange": "0",
        //     "priceChangePercent": "0",
        //     "weightedAvgPrice": "0",
        //     "lastPrice": "2.00",
        //     "lastQty": "10.000",
        //     "bestBidPrice": "1646.00",
        //     "bestBidQty": "10.000",
        //     "bestAskPrice": "1646.00",
        //     "bestAskQty": "10.000",
        //     "openPrice": "0.00",
        //     "highPrice": "0.00",
        //     "lowPrice": "0.00",
        //     "volume": "0.000",
        //     "quoteVolume": "0.00",
        //     "openTime": 1700142658697,
        //     "closeTime": 1700142658697,
        //     "openInterestBase": "1.000",
        //     "openInterestQuote": "0.43112300"
        // }
        //
        return this.parseTicker(response, market);
    }

    /**
     * @method
     * @name defx#fetchTickers
     * @description fetches price tickers for multiple markets, statistical information calculated over the past 24 hours for each market
     * @see https://api-docs.defx.com/#8c61cfbd-40d9-410e-b014-f5b36eba51d1
     * @param {string[]|undefined} symbols unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/#/?id=ticker-structure}
     */
    public async override Task<object> fetchTickers(object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = null;
        if (isTrue(!isEqual(symbols, null)))
        {
            symbols = this.marketSymbols(symbols);
            object firstSymbol = this.safeString(symbols, 0);
            if (isTrue(!isEqual(firstSymbol, null)))
            {
                market = this.market(firstSymbol);
            }
        }
        object type = null;
        var typeparametersVariable = this.handleMarketTypeAndParams("fetchTickers", market, parameters);
        type = ((IList<object>)typeparametersVariable)[0];
        parameters = ((IList<object>)typeparametersVariable)[1];
        if (isTrue(isEqual(type, "spot")))
        {
            throw new NotSupported ((string)add(add(add(this.id, " fetchTickers() is not supported for "), type), " markets")) ;
        }
        object response = await this.v1PublicGetTicker24HrAgg(parameters);
        //
        // {
        //     "ETH_USDC": {
        //       "priceChange": "0",
        //       "priceChangePercent": "0",
        //       "openPrice": "1646.15",
        //       "highPrice": "1646.15",
        //       "lowPrice": "1646.15",
        //       "lastPrice": "1646.15",
        //       "quoteVolume": "13.17",
        //       "volume": "0.008",
        //       "markPrice": "1645.15"
        //     }
        // }
        //
        return this.parseTickers(response, symbols);
    }

    public override object parseTicker(object ticker, object market = null)
    {
        //
        // fetchTicker
        //
        // {
        //     "symbol": "BTC_USDC",
        //     "priceChange": "0",
        //     "priceChangePercent": "0",
        //     "weightedAvgPrice": "0",
        //     "lastPrice": "2.00",
        //     "lastQty": "10.000",
        //     "bestBidPrice": "1646.00",
        //     "bestBidQty": "10.000",
        //     "bestAskPrice": "1646.00",
        //     "bestAskQty": "10.000",
        //     "openPrice": "0.00",
        //     "highPrice": "0.00",
        //     "lowPrice": "0.00",
        //     "volume": "0.000",
        //     "quoteVolume": "0.00",
        //     "openTime": 1700142658697,
        //     "closeTime": 1700142658697,
        //     "openInterestBase": "1.000",
        //     "openInterestQuote": "0.43112300"
        // }
        //
        // fetchTickers
        //
        //     "ETH_USDC": {
        //       "priceChange": "0",
        //       "priceChangePercent": "0",
        //       "openPrice": "1646.15",
        //       "highPrice": "1646.15",
        //       "lowPrice": "1646.15",
        //       "lastPrice": "1646.15",
        //       "quoteVolume": "13.17",
        //       "volume": "0.008",
        //       "markPrice": "1645.15"
        //     }
        //
        // fetchMarkPrice
        //
        // {
        //     "markPrice": "100.00",
        //     "indexPrice": "100.00",
        //     "ltp": "101.34",
        //     "movingFundingRate": "0.08",
        //     "payoutFundingRate": "-0.03",
        //     "nextFundingPayout": 1711555532146
        // }
        //
        object marketId = this.safeString(ticker, "symbol");
        if (isTrue(!isEqual(marketId, null)))
        {
            market = this.market(marketId);
        }
        object symbol = getValue(market, "symbol");
        object open = this.safeString(ticker, "openPrice");
        object high = this.safeString(ticker, "highPrice");
        object low = this.safeString(ticker, "lowPrice");
        object close = this.safeString(ticker, "lastPrice");
        object quoteVolume = this.safeString(ticker, "quoteVolume");
        object baseVolume = this.safeString(ticker, "volume");
        object percentage = this.safeString(ticker, "priceChangePercent");
        object change = this.safeString(ticker, "priceChange");
        object ts = this.safeInteger(ticker, "closeTime");
        if (isTrue(isEqual(ts, 0)))
        {
            ts = null;
        }
        object datetime = this.iso8601(ts);
        object bid = this.safeString(ticker, "bestBidPrice");
        object bidVolume = this.safeString(ticker, "bestBidQty");
        object ask = this.safeString(ticker, "bestAskPrice");
        object askVolume = this.safeString(ticker, "bestAskQty");
        return this.safeTicker(new Dictionary<string, object>() {
            { "symbol", symbol },
            { "timestamp", ts },
            { "datetime", datetime },
            { "high", high },
            { "low", low },
            { "bid", bid },
            { "bidVolume", bidVolume },
            { "ask", ask },
            { "askVolume", askVolume },
            { "vwap", null },
            { "open", open },
            { "close", close },
            { "last", null },
            { "previousClose", null },
            { "change", change },
            { "percentage", percentage },
            { "average", null },
            { "baseVolume", baseVolume },
            { "quoteVolume", quoteVolume },
            { "markPrice", this.safeString(ticker, "markPrice") },
            { "indexPrice", this.safeString(ticker, "indexPrice") },
            { "info", ticker },
        }, market);
    }

    /**
     * @method
     * @name defx#fetchOHLCV
     * @see https://api-docs.defx.com/#54b71951-1472-4670-b5af-4c2dc41e73d0
     * @description fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
     * @param {string} symbol unified symbol of the market to fetch OHLCV data for
     * @param {string} timeframe the length of time each candle represents
     * @param {int} [since] timestamp in ms of the earliest candle to fetch
     * @param {int} [limit] max=1000, max=100 when since is defined and is less than (now - (999 * (timeframe in ms)))
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {int} [params.until] the latest time in ms to fetch orders for
     * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
     */
    public async override Task<object> fetchOHLCV(object symbol, object timeframe = null, object since = null, object limit = null, object parameters = null)
    {
        timeframe ??= "1m";
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object maxLimit = 1000;
        if (isTrue(isEqual(limit, null)))
        {
            limit = maxLimit;
        }
        limit = mathMin(maxLimit, limit);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
            { "interval", this.safeString(this.timeframes, timeframe, timeframe) },
            { "limit", limit },
        };
        object until = this.safeInteger2(parameters, "until", "till");
        parameters = this.omit(parameters, new List<object>() {"until", "till"});
        ((IDictionary<string,object>)request)["endTime"] = ((bool) isTrue((isEqual(until, null)))) ? this.milliseconds() : until;
        if (isTrue(isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["startTime"] = 0;
        } else
        {
            ((IDictionary<string,object>)request)["startTime"] = since;
            if (isTrue(isEqual(until, null)))
            {
                object timeframeInSeconds = this.parseTimeframe(timeframe);
                object timeframeInMilliseconds = multiply(timeframeInSeconds, 1000);
                object totalTimeframeInMilliseconds = multiply(limit, timeframeInMilliseconds);
                ((IDictionary<string,object>)request)["endTime"] = this.sum(since, totalTimeframeInMilliseconds);
            }
        }
        object response = await this.v1PublicGetSymbolsSymbolOhlc(this.extend(request, parameters));
        //
        // [
        //     {
        //       "symbol": "BTC_USDC",
        //       "open": "0.00",
        //       "high": "0.00",
        //       "low": "0.00",
        //       "close": "0.00",
        //       "volume": "0.000",
        //       "quoteAssetVolume": "0.00",
        //       "takerBuyAssetVolume": "0.000",
        //       "takerBuyQuoteAssetVolume": "0.00",
        //       "numberOfTrades": 0,
        //       "start": 1702453663894,
        //       "end": 1702453663894,
        //       "isClosed": true
        //     }
        // ]
        //
        return this.parseOHLCVs(response, market, timeframe, since, limit);
    }

    public override object parseOHLCV(object ohlcv, object market = null)
    {
        // example response in fetchOHLCV
        return new List<object> {this.safeInteger(ohlcv, "start"), this.safeNumber(ohlcv, "open"), this.safeNumber(ohlcv, "high"), this.safeNumber(ohlcv, "low"), this.safeNumber(ohlcv, "close"), this.safeNumber(ohlcv, "volume")};
    }

    /**
     * @method
     * @name defx#fetchTrades
     * @description get the list of most recent trades for a particular symbol
     * @see https://api-docs.defx.com/#5865452f-ea32-4f13-bfbc-03af5f5574fd
     * @param {string} symbol unified symbol of the market to fetch trades for
     * @param {int} [since] timestamp in ms of the earliest trade to fetch
     * @param {int} [limit] the maximum amount of trades to fetch
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
     */
    public async override Task<object> fetchTrades(object symbol, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object maxLimit = 50;
        if (isTrue(isEqual(limit, null)))
        {
            limit = maxLimit;
        }
        limit = mathMin(maxLimit, limit);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
            { "limit", limit },
        };
        object response = await this.v1PublicGetSymbolsSymbolTrades(this.extend(request, parameters));
        //
        // [
        //     {
        //       "buyerMaker": "false",
        //       "price": "2.0000",
        //       "qty": "10.0000",
        //       "symbol": "BTC_USDC",
        //       "timestamp": "1702453663894"
        //     }
        // ]
        //
        return this.parseTrades(response, market, since, limit);
    }

    /**
     * @method
     * @name defx#fetchTrades
     * @description fetch all trades made by the user
     * @see https://api-docs.defx.com/#06b5b33c-2fc6-48de-896c-fc316f5871a7
     * @param {string} symbol unified symbol of the market to fetch trades for
     * @param {int} [since] timestamp in ms of the earliest trade to fetch
     * @param {int} [limit] the maximum amount of trades to fetch
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
     */
    public async override Task<object> fetchMyTrades(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        if (isTrue(!isEqual(symbol, null)))
        {
            object market = this.market(symbol);
            ((IDictionary<string,object>)request)["symbols"] = getValue(market, "id");
        }
        if (isTrue(!isEqual(limit, null)))
        {
            object maxLimit = 100;
            limit = mathMin(maxLimit, limit);
            ((IDictionary<string,object>)request)["pageSize"] = limit;
        }
        object response = await this.v1PrivateGetApiTrades(this.extend(request, parameters));
        //
        // {
        //     "data": [
        //         {
        //             "id": "0192f665-c05b-7ba0-a080-8b6c99083489",
        //             "orderId": "757730811259651728",
        //             "time": "2024-11-04T08:58:36.474Z",
        //             "symbol": "SOL_USDC",
        //             "side": "SELL",
        //             "price": "160.43600000",
        //             "qty": "1.00",
        //             "fee": "0.08823980",
        //             "role": "TAKER",
        //             "pnl": "0.00000000"
        //         }
        //     ]
        // }
        //
        object data = this.safeList(response, "data", new List<object>() {});
        return this.parseTrades(data, null, since, limit);
    }

    public override object parseTrade(object trade, object market = null)
    {
        //
        // fetchTrades
        //     {
        //       "buyerMaker": "false",
        //       "price": "2.0000",
        //       "qty": "10.0000",
        //       "symbol": "BTC_USDC",
        //       "timestamp": "1702453663894"
        //     }
        //
        // fetchMyTrades
        //     {
        //         "id": "0192f665-c05b-7ba0-a080-8b6c99083489",
        //         "orderId": "757730811259651728",
        //         "time": "2024-11-04T08:58:36.474Z",
        //         "symbol": "SOL_USDC",
        //         "side": "SELL",
        //         "price": "160.43600000",
        //         "qty": "1.00",
        //         "fee": "0.08823980",
        //         "role": "TAKER",
        //         "pnl": "0.00000000"
        //     }
        //
        object time = this.safeString(trade, "time");
        object timestamp = this.safeInteger(trade, "timestamp", this.parse8601(time));
        object marketId = this.safeString(trade, "symbol");
        market = this.safeMarket(marketId, market);
        object symbol = getValue(market, "symbol");
        object price = this.safeString(trade, "price");
        object amount = this.safeString(trade, "qty");
        object id = this.safeString(trade, "id");
        object oid = this.safeString(trade, "orderId");
        object takerOrMaker = this.safeStringLower(trade, "role");
        object buyerMaker = this.safeBool(trade, "buyerMaker");
        object side = this.safeStringLower(trade, "side");
        if (isTrue(!isEqual(buyerMaker, null)))
        {
            if (isTrue(buyerMaker))
            {
                side = "sell";
            } else
            {
                side = "buy";
            }
        }
        return this.safeTrade(new Dictionary<string, object>() {
            { "id", id },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "symbol", symbol },
            { "side", side },
            { "price", price },
            { "amount", amount },
            { "cost", null },
            { "order", oid },
            { "takerOrMaker", takerOrMaker },
            { "type", null },
            { "fee", new Dictionary<string, object>() {
                { "cost", this.safeString(trade, "fee") },
                { "currency", "USDC" },
            } },
            { "info", trade },
        }, market);
    }

    /**
     * @method
     * @name defx#fetchOrderBook
     * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
     * @see https://api-docs.defx.com/#6c1a2971-8325-4e7d-9962-e0bfcaacf9c4
     * @param {string} symbol unified symbol of the market to fetch the order book for
     * @param {int} [limit] the maximum amount of order book entries to return
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.slab] slab from market.info.depthSlabs
     * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
     */
    public async override Task<object> fetchOrderBook(object symbol, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        if (isTrue(isEqual(limit, null)))
        {
            limit = 10; // limit must be one of [5, 10, 20]
        }
        object marketInfo = this.safeDict(market, "info", new Dictionary<string, object>() {});
        object slab = this.safeList(marketInfo, "depthSlabs", new List<object>() {});
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
            { "level", limit },
            { "slab", this.safeString(slab, 0) },
        };
        object response = await this.v1PublicGetSymbolsSymbolDepthLevelSlab(this.extend(request, parameters));
        //
        // {
        //     "symbol": "ETH_USDC",
        //     "level": "5",
        //     "slab": "1",
        //     "lastTradeTimestamp": "1708313446812",
        //     "timestamp": "1708313446812",
        //     "bids": [
        //       {
        //         "price": "1646.16",
        //         "qty": "0.001"
        //       }
        //     ],
        //     "asks": [
        //       {
        //         "price": "1646.16",
        //         "qty": "0.001"
        //       }
        //     ]
        // }
        //
        object timestamp = this.safeInteger(response, "timestamp");
        return this.parseOrderBook(response, symbol, timestamp, "bids", "asks", "price", "qty");
    }

    /**
     * @method
     * @name defx#fetchMarkPrice
     * @description fetches mark price for the market
     * @see https://api-docs.defx.com/#12168192-4e7b-4458-a001-e8b80961f0b7
     * @param {string} symbol unified symbol of the market to fetch the ticker for
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.subType] "linear" or "inverse"
     * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/#/?id=ticker-structure}
     */
    public async override Task<object> fetchMarkPrice(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object response = await this.v1PublicGetSymbolsSymbolPrices(this.extend(request, parameters));
        //
        // {
        //     "markPrice": "100.00",
        //     "indexPrice": "100.00",
        //     "ltp": "101.34",
        //     "movingFundingRate": "0.08",
        //     "payoutFundingRate": "-0.03",
        //     "nextFundingPayout": 1711555532146
        // }
        //
        return this.parseTicker(response, market);
    }

    /**
     * @method
     * @name defx#fetchFundingRate
     * @description fetch the current funding rate
     * @see https://api-docs.defx.com/#12168192-4e7b-4458-a001-e8b80961f0b7
     * @param {string} symbol unified market symbol
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [funding rate structure]{@link https://docs.ccxt.com/#/?id=funding-rate-structure}
     */
    public async override Task<object> fetchFundingRate(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object response = await this.v1PublicGetSymbolsSymbolPrices(this.extend(request, parameters));
        //
        // {
        //     "markPrice": "100.00",
        //     "indexPrice": "100.00",
        //     "ltp": "101.34",
        //     "movingFundingRate": "0.08",
        //     "payoutFundingRate": "-0.03",
        //     "nextFundingPayout": 1711555532146
        // }
        //
        return this.parseFundingRate(response, market);
    }

    public override object parseFundingRate(object contract, object market = null)
    {
        //
        // {
        //     "markPrice": "100.00",
        //     "indexPrice": "100.00",
        //     "ltp": "101.34",
        //     "movingFundingRate": "0.08",
        //     "payoutFundingRate": "-0.03",
        //     "nextFundingPayout": 1711555532146
        // }
        //
        object markPrice = this.safeNumber(contract, "markPrice");
        object indexPrice = this.safeNumber(contract, "indexPrice");
        object fundingRate = this.safeNumber(contract, "payoutFundingRate");
        object fundingTime = this.safeInteger(contract, "nextFundingPayout");
        return new Dictionary<string, object>() {
            { "info", contract },
            { "symbol", getValue(market, "symbol") },
            { "markPrice", markPrice },
            { "indexPrice", indexPrice },
            { "interestRate", null },
            { "estimatedSettlePrice", null },
            { "timestamp", null },
            { "datetime", null },
            { "fundingRate", fundingRate },
            { "fundingTimestamp", fundingTime },
            { "fundingDatetime", this.iso8601(fundingTime) },
            { "nextFundingRate", null },
            { "nextFundingTimestamp", null },
            { "nextFundingDatetime", null },
            { "previousFundingRate", null },
            { "previousFundingTimestamp", null },
            { "previousFundingDatetime", null },
            { "interval", null },
        };
    }

    /**
     * @method
     * @name defx#fetchBalance
     * @description query for balance and get the amount of funds available for trading or funds locked in orders
     * @see https://api-docs.defx.com/#26414338-14f7-40a1-b246-f8ea8571493f
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
     */
    public async override Task<object> fetchBalance(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.v1PrivateGetApiWalletBalance(parameters);
        //
        // {
        //     "assets": [
        //       {
        //         "asset": "USDC",
        //         "balance": "0.000"
        //       }
        //     ]
        // }
        //
        object data = this.safeList(response, "assets");
        return this.parseBalance(data);
    }

    public override object parseBalance(object balances)
    {
        object result = new Dictionary<string, object>() {
            { "info", balances },
        };
        for (object i = 0; isLessThan(i, getArrayLength(balances)); postFixIncrement(ref i))
        {
            object balance = getValue(balances, i);
            object code = this.safeCurrencyCode(this.safeString(balance, "asset"));
            object account = this.account();
            ((IDictionary<string,object>)account)["total"] = this.safeString(balance, "balance");
            ((IDictionary<string,object>)result)[(string)code] = account;
        }
        return this.safeBalance(result);
    }

    /**
     * @method
     * @name defx#createOrder
     * @description create a trade order
     * @see https://api-docs.defx.com/#ba222d88-8856-4d3c-87a9-7cec07bb2622
     * @param {string} symbol unified symbol of the market to create an order in
     * @param {string} type 'market' or 'limit'
     * @param {string} side 'buy' or 'sell'
     * @param {float} amount how much of currency you want to trade in units of base currency
     * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {float} [params.triggerPrice] The price a trigger order is triggered at
     * @param {string} [params.reduceOnly] for swap and future reduceOnly is a string 'true' or 'false' that cant be sent with close position set to true or in hedge mode. For spot margin and option reduceOnly is a boolean.
     * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> createOrder(object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object reduceOnly = this.safeBool2(parameters, "reduceOnly", "reduce_only");
        parameters = this.omit(parameters, new List<object>() {"reduceOnly", "reduce_only"});
        object orderType = ((string)type).ToUpper();
        object orderSide = ((string)side).ToUpper();
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
            { "side", orderSide },
            { "type", orderType },
        };
        object takeProfitPrice = this.safeString(parameters, "takeProfitPrice");
        object triggerPrice = this.safeString2(parameters, "stopPrice", "triggerPrice");
        object isMarket = isEqual(orderType, "MARKET");
        object isLimit = isEqual(orderType, "LIMIT");
        object timeInForce = this.safeStringUpper(parameters, "timeInForce");
        if (isTrue(!isEqual(timeInForce, null)))
        {
            // GTC, IOC, FOK, AON
            ((IDictionary<string,object>)request)["timeInForce"] = timeInForce;
        } else
        {
            if (isTrue(isLimit))
            {
                ((IDictionary<string,object>)request)["timeInForce"] = "GTC";
            }
        }
        if (isTrue(reduceOnly))
        {
            ((IDictionary<string,object>)request)["reduceOnly"] = reduceOnly;
        }
        object clientOrderId = this.safeString(parameters, "clientOrderId");
        if (isTrue(!isEqual(clientOrderId, null)))
        {
            ((IDictionary<string,object>)request)["newClientOrderId"] = clientOrderId;
        }
        if (isTrue(isTrue(!isEqual(triggerPrice, null)) || isTrue(!isEqual(takeProfitPrice, null))))
        {
            ((IDictionary<string,object>)request)["workingType"] = "MARK_PRICE";
            if (isTrue(!isEqual(takeProfitPrice, null)))
            {
                ((IDictionary<string,object>)request)["stopPrice"] = this.priceToPrecision(symbol, takeProfitPrice);
                if (isTrue(isMarket))
                {
                    ((IDictionary<string,object>)request)["type"] = "TAKE_PROFIT_MARKET";
                } else
                {
                    ((IDictionary<string,object>)request)["type"] = "TAKE_PROFIT_LIMIT";
                }
            } else
            {
                ((IDictionary<string,object>)request)["stopPrice"] = this.priceToPrecision(symbol, triggerPrice);
                if (isTrue(isMarket))
                {
                    ((IDictionary<string,object>)request)["type"] = "STOP_MARKET";
                } else
                {
                    ((IDictionary<string,object>)request)["type"] = "STOP_LIMIT";
                }
            }
        }
        if (isTrue(isTrue(isLimit) && isTrue(!isEqual(price, null))))
        {
            ((IDictionary<string,object>)request)["price"] = this.priceToPrecision(symbol, price);
        }
        ((IDictionary<string,object>)request)["quantity"] = this.amountToPrecision(symbol, amount);
        parameters = this.omit(parameters, new List<object>() {"clOrdID", "clientOrderId", "client_order_id", "postOnly", "timeInForce", "stopPrice", "triggerPrice", "takeProfitPrice"});
        object response = await this.v1PrivatePostApiOrder(this.extend(request, parameters));
        //
        // {
        //     "success": true,
        //     "data": {
        //       "orderId": "",
        //       "clientOrderId": "",
        //       "cumulativeQty": "",
        //       "cumulativeQuote": "",
        //       "executedQty": "",
        //       "avgPrice": "",
        //       "origQty": "",
        //       "price": "",
        //       "reduceOnly": true,
        //       "side": "",
        //       "status": "",
        //       "symbol": "",
        //       "timeInForce": "",
        //       "type": "",
        //       "workingType": ""
        //     }
        // }
        //
        object data = this.safeDict(response, "data");
        return this.parseOrder(data, market);
    }

    public virtual object parseOrderStatus(object status)
    {
        if (isTrue(!isEqual(status, null)))
        {
            object statuses = new Dictionary<string, object>() {
                { "NEW", "open" },
                { "OPEN", "open" },
                { "CANCELLED", "canceled" },
                { "REJECTED", "rejected" },
                { "FILLED", "closed" },
            };
            return this.safeString(statuses, status, status);
        }
        return status;
    }

    public override object parseOrder(object order, object market = null)
    {
        //
        // {
        //     "orderId": "746472647227344528",
        //     "createdAt": "2024-10-25T16:49:31.077Z",
        //     "updatedAt": "2024-10-25T16:49:31.378Z",
        //     "clientOrderId": "0192c495-49c3-71ee-b3d3-7442a2090807",
        //     "reduceOnly": false,
        //     "side": "SELL",
        //     "status": "FILLED",
        //     "symbol": "SOL_USDC",
        //     "timeInForce": "GTC",
        //     "type": "MARKET",
        //     "origQty": "0.80",
        //     "executedQty": "0.80",
        //     "cumulativeQuote": "137.87440000",
        //     "avgPrice": "172.34300000",
        //     "totalPnL": "0.00000000",
        //     "totalFee": "0.07583092",
        //     "workingType": null,
        //     "postOnly": false,
        //     "linkedOrderParentType": null,
        //     "isTriggered": false,
        //     "slippagePercentage": "5"
        // }
        //
        object orderId = this.safeString(order, "orderId");
        object clientOrderId = this.safeString(order, "clientOrderId");
        object marketId = this.safeString(order, "symbol");
        market = this.safeMarket(marketId, market);
        object symbol = getValue(market, "symbol");
        object price = this.safeString(order, "price");
        object amount = this.safeString(order, "origQty");
        object orderType = this.safeStringLower(order, "type");
        object status = this.safeString(order, "status");
        object side = this.safeStringLower(order, "side");
        object filled = this.omitZero(this.safeString(order, "executedQty"));
        object average = this.omitZero(this.safeString(order, "avgPrice"));
        object timeInForce = this.safeStringLower(order, "timeInForce");
        object takeProfitPrice = null;
        object triggerPrice = null;
        if (isTrue(!isEqual(orderType, null)))
        {
            if (isTrue(isGreaterThanOrEqual(getIndexOf(orderType, "take_profit"), 0)))
            {
                takeProfitPrice = this.safeString(order, "stopPrice");
            } else
            {
                triggerPrice = this.safeString(order, "stopPrice");
            }
        }
        object timestamp = this.parse8601(this.safeString(order, "createdAt"));
        object lastTradeTimestamp = this.parse8601(this.safeString(order, "updatedAt"));
        return this.safeOrder(new Dictionary<string, object>() {
            { "id", orderId },
            { "clientOrderId", clientOrderId },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "lastTradeTimestamp", lastTradeTimestamp },
            { "lastUpdateTimestamp", lastTradeTimestamp },
            { "status", this.parseOrderStatus(status) },
            { "symbol", symbol },
            { "type", orderType },
            { "timeInForce", timeInForce },
            { "postOnly", this.safeBool(order, "postOnly") },
            { "reduceOnly", this.safeBool(order, "reduceOnly") },
            { "side", side },
            { "price", price },
            { "triggerPrice", triggerPrice },
            { "takeProfitPrice", takeProfitPrice },
            { "stopLossPrice", null },
            { "average", average },
            { "amount", amount },
            { "filled", filled },
            { "remaining", null },
            { "cost", null },
            { "trades", null },
            { "fee", new Dictionary<string, object>() {
                { "cost", this.safeString(order, "totalFee") },
                { "currency", "USDC" },
            } },
            { "info", order },
        }, market);
    }

    /**
     * @method
     * @name defx#cancelOrder
     * @see https://api-docs.defx.com/#09186f23-f8d1-4993-acf4-9974d8a6ddb0
     * @description cancels an open order
     * @param {string} id order id
     * @param {string} symbol unified symbol of the market the order was made in
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> cancelOrder(object id, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {
            { "orderId", id },
            { "idType", "orderId" },
        };
        object clientOrderId = this.safeStringN(parameters, new List<object>() {"clOrdID", "clientOrderId", "client_order_id"});
        object isByClientOrder = !isEqual(clientOrderId, null);
        if (isTrue(isByClientOrder))
        {
            if (isTrue(isEqual(symbol, null)))
            {
                throw new ArgumentsRequired ((string)add(this.id, " cancelOrder() requires a symbol argument")) ;
            }
            object market = this.market(symbol);
            ((IDictionary<string,object>)request)["orderId"] = clientOrderId;
            ((IDictionary<string,object>)request)["idType"] = "clientOrderId";
            ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
        }
        parameters = this.omit(parameters, new List<object>() {"clOrdID", "clientOrderId", "client_order_id"});
        object response = await this.v1PrivateDeleteApiOrderOrderId(this.extend(request, parameters));
        //
        // {
        //     "success": true
        // }
        //
        object extendParams = new Dictionary<string, object>() {
            { "symbol", symbol },
        };
        if (isTrue(isByClientOrder))
        {
            ((IDictionary<string,object>)extendParams)["clientOrderId"] = clientOrderId;
        } else
        {
            ((IDictionary<string,object>)extendParams)["id"] = id;
        }
        return this.extend(this.parseOrder(response), extendParams);
    }

    /**
     * @method
     * @name defx#cancelAllOrders
     * @description cancel all open orders
     * @see https://api-docs.defx.com/#db5531da-3692-4a53-841f-6ad6495f823a
     * @param {string} symbol unified market symbol, only orders in the market of this symbol are cancelled when symbol is not undefined
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> cancelAllOrders(object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbols", new List<object>() {getValue(market, "id")} },
        };
        object response = await this.v1PrivateDeleteApiOrdersAllOpen(this.extend(request, parameters));
        //
        // {
        //     "data": {
        //         "msg": "The operation of cancel all open order is done."
        //     }
        // }
        //
        return response;
    }

    /**
     * @method
     * @name defx#fetchPosition
     * @description fetch data on a single open contract trade position
     * @see https://api-docs.defx.com/#d89dbb86-9aba-4f59-ac5d-a97ff25ea80e
     * @param {string} symbol unified market symbol of the market the position is held in, default is undefined
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [position structure]{@link https://docs.ccxt.com/#/?id=position-structure}
     */
    public async override Task<object> fetchPosition(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchPosition() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object response = await this.v1PrivateGetApiPositionActive(this.extend(request, parameters));
        //
        // {
        //     "data": [
        //         {
        //             "positionId": "0192c495-4a68-70ee-9081-9d368bd16dfc",
        //             "symbol": "SOL_USDC",
        //             "positionSide": "SHORT",
        //             "entryPrice": "172.34300000",
        //             "quantity": "0.80",
        //             "marginAmount": "20.11561173",
        //             "marginAsset": "USDC",
        //             "pnl": "0.00000000"
        //         }
        //     ]
        // }
        //
        object data = this.safeList(response, "data", new List<object>() {});
        object first = this.safeDict(data, 0, new Dictionary<string, object>() {});
        return this.parsePosition(first, market);
    }

    /**
     * @method
     * @name defx#fetchPositions
     * @description fetch all open positions
     * @see https://api-docs.defx.com/#d89dbb86-9aba-4f59-ac5d-a97ff25ea80e
     * @param {string[]} [symbols] list of unified market symbols
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} a list of [position structure]{@link https://docs.ccxt.com/#/?id=position-structure}
     */
    public async override Task<object> fetchPositions(object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.v1PrivateGetApiPositionActive(parameters);
        //
        // {
        //     "data": [
        //         {
        //             "positionId": "0192c495-4a68-70ee-9081-9d368bd16dfc",
        //             "symbol": "SOL_USDC",
        //             "positionSide": "SHORT",
        //             "entryPrice": "172.34300000",
        //             "quantity": "0.80",
        //             "marginAmount": "20.11561173",
        //             "marginAsset": "USDC",
        //             "pnl": "0.00000000"
        //         }
        //     ]
        // }
        //
        object positions = this.safeList(response, "data", new List<object>() {});
        return this.parsePositions(positions, symbols);
    }

    public override object parsePosition(object position, object market = null)
    {
        //
        // {
        //     "positionId": "0192c495-4a68-70ee-9081-9d368bd16dfc",
        //     "symbol": "SOL_USDC",
        //     "positionSide": "SHORT",
        //     "entryPrice": "172.34300000",
        //     "quantity": "0.80",
        //     "marginAmount": "20.11561173",
        //     "marginAsset": "USDC",
        //     "pnl": "0.00000000"
        // }
        //
        object marketId = this.safeString(position, "symbol");
        market = this.safeMarket(marketId, market);
        object size = Precise.stringAbs(this.safeString(position, "quantity"));
        object side = this.safeStringLower(position, "positionSide");
        object unrealisedPnl = this.omitZero(this.safeString(position, "pnl"));
        object entryPrice = this.omitZero(this.safeString(position, "entryPrice"));
        object initialMargin = this.safeString(position, "marginAmount");
        return this.safePosition(new Dictionary<string, object>() {
            { "info", position },
            { "id", this.safeString(position, "positionId") },
            { "symbol", getValue(market, "symbol") },
            { "timestamp", null },
            { "datetime", null },
            { "lastUpdateTimestamp", null },
            { "initialMargin", this.parseNumber(initialMargin) },
            { "initialMarginPercentage", null },
            { "maintenanceMargin", null },
            { "maintenanceMarginPercentage", null },
            { "entryPrice", this.parseNumber(entryPrice) },
            { "notional", null },
            { "leverage", null },
            { "unrealizedPnl", this.parseNumber(unrealisedPnl) },
            { "realizedPnl", null },
            { "contracts", this.parseNumber(size) },
            { "contractSize", this.safeNumber(market, "contractSize") },
            { "marginRatio", null },
            { "liquidationPrice", null },
            { "markPrice", null },
            { "lastPrice", null },
            { "collateral", null },
            { "marginMode", null },
            { "side", side },
            { "percentage", null },
            { "stopLossPrice", null },
            { "takeProfitPrice", null },
            { "hedged", null },
        });
    }

    /**
     * @method
     * @name defx#fetchOrder
     * @description fetches information on an order made by the user
     * @see https://api-docs.defx.com/#44f82dd5-26b3-4e1f-b4aa-88ceddd65237
     * @param {string} id the order id
     * @param {string} symbol unified symbol of the market the order was made in
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> fetchOrder(object id, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {
            { "orderId", id },
            { "idType", "orderId" },
        };
        object clientOrderId = this.safeStringN(parameters, new List<object>() {"clOrdID", "clientOrderId", "client_order_id"});
        parameters = this.omit(parameters, new List<object>() {"clOrdID", "clientOrderId", "client_order_id"});
        if (isTrue(!isEqual(clientOrderId, null)))
        {
            if (isTrue(isEqual(symbol, null)))
            {
                throw new ArgumentsRequired ((string)add(this.id, " fetchOrder() requires a symbol argument")) ;
            }
            object market = this.market(symbol);
            ((IDictionary<string,object>)request)["orderId"] = clientOrderId;
            ((IDictionary<string,object>)request)["idType"] = "clientOrderId";
            ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
        }
        object response = await this.v1PrivateGetApiOrderOrderId(this.extend(request, parameters));
        //
        // {
        //     "success": true,
        //     "data": {
        //         "orderId": "555068654076559792",
        //         "createdAt": "2024-05-08T05:45:42.148Z",
        //         "updatedAt": "2024-05-08T05:45:42.166Z",
        //         "clientOrderId": "dummyClientOrderId",
        //         "reduceOnly": false,
        //         "side": "SELL",
        //         "status": "REJECTED",
        //         "symbol": "BTC_USDC",
        //         "timeInForce": "GTC",
        //         "type": "TAKE_PROFIT_MARKET",
        //         "origQty": "1.000",
        //         "executedQty": "0.000",
        //         "cumulativeQuote": "0.00",
        //         "avgPrice": "0.00",
        //         "stopPrice": "65000.00",
        //         "totalPnL": "0.00",
        //         "workingType": "MARK_PRICE",
        //         "postOnly": false
        //     }
        // }
        //
        object data = this.safeDict(response, "data");
        return this.parseOrder(data);
    }

    /**
     * @method
     * @name defx#fetchOrders
     * @description fetches information on multiple orders made by the user
     * @see https://api-docs.defx.com/#ab200038-8acb-4170-b05e-4fcb4cc13751
     * @param {string} symbol unified market symbol
     * @param {int} [since] the earliest time in ms to fetch open orders for
     * @param {int} [limit] the maximum number of open order structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {int} [params.until] the latest time in ms to fetch orders for
     * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> fetchOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        if (isTrue(!isEqual(symbol, null)))
        {
            object market = this.market(symbol);
            ((IDictionary<string,object>)request)["symbols"] = getValue(market, "id");
        }
        object until = this.safeInteger(parameters, "until");
        if (isTrue(!isEqual(until, null)))
        {
            parameters = this.omit(parameters, "until");
            ((IDictionary<string,object>)request)["end"] = this.iso8601(until);
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["start"] = this.iso8601(since);
        }
        if (isTrue(!isEqual(limit, null)))
        {
            object maxLimit = 100;
            limit = mathMin(maxLimit, limit);
            ((IDictionary<string,object>)request)["pageSize"] = limit;
        }
        object response = await this.v1PrivateGetApiOrders(this.extend(request, parameters));
        //
        // {
        //     "data": [
        //         {
        //             "orderId": "746472647227344528",
        //             "createdAt": "2024-10-25T16:49:31.077Z",
        //             "updatedAt": "2024-10-25T16:49:31.378Z",
        //             "clientOrderId": "0192c495-49c3-71ee-b3d3-7442a2090807",
        //             "reduceOnly": false,
        //             "side": "SELL",
        //             "status": "FILLED",
        //             "symbol": "SOL_USDC",
        //             "timeInForce": "GTC",
        //             "type": "MARKET",
        //             "origQty": "0.80",
        //             "executedQty": "0.80",
        //             "cumulativeQuote": "137.87440000",
        //             "avgPrice": "172.34300000",
        //             "totalPnL": "0.00000000",
        //             "totalFee": "0.07583092",
        //             "workingType": null,
        //             "postOnly": false,
        //             "linkedOrderParentType": null,
        //             "isTriggered": false,
        //             "slippagePercentage": 5
        //         }
        //     ]
        // }
        //
        object data = this.safeList(response, "data", new List<object>() {});
        return this.parseOrders(data, null, since, limit);
    }

    /**
     * @method
     * @name defx#fetchOpenOrders
     * @description fetch all unfilled currently open orders
     * @see https://api-docs.defx.com/#ab200038-8acb-4170-b05e-4fcb4cc13751
     * @param {string} symbol unified market symbol
     * @param {int} [since] the earliest time in ms to fetch open orders for
     * @param {int} [limit] the maximum number of open order structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {int} [params.until] the latest time in ms to fetch orders for
     * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> fetchOpenOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object req = new Dictionary<string, object>() {
            { "statuses", "OPEN" },
        };
        return await this.fetchOrders(symbol, since, limit, this.extend(req, parameters));
    }

    /**
     * @method
     * @name defx#fetchClosedOrders
     * @description fetches information on multiple closed orders made by the user
     * @see https://api-docs.defx.com/#ab200038-8acb-4170-b05e-4fcb4cc13751
     * @param {string} symbol unified market symbol
     * @param {int} [since] the earliest time in ms to fetch open orders for
     * @param {int} [limit] the maximum number of open order structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {int} [params.until] the latest time in ms to fetch orders for
     * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> fetchClosedOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object req = new Dictionary<string, object>() {
            { "statuses", "FILLED" },
        };
        return await this.fetchOrders(symbol, since, limit, this.extend(req, parameters));
    }

    /**
     * @method
     * @name defx#fetchCanceledOrders
     * @description fetches information on multiple canceled orders made by the user
     * @see https://api-docs.defx.com/#ab200038-8acb-4170-b05e-4fcb4cc13751
     * @param {string} symbol unified market symbol
     * @param {int} [since] the earliest time in ms to fetch open orders for
     * @param {int} [limit] the maximum number of open order structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {int} [params.until] the latest time in ms to fetch orders for
     * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async virtual Task<object> fetchCanceledOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object req = new Dictionary<string, object>() {
            { "statuses", "CANCELED" },
        };
        return await this.fetchOrders(symbol, since, limit, this.extend(req, parameters));
    }

    /**
     * @method
     * @name defx#closePosition
     * @description closes an open position for a market
     * @see https://api-docs.defx.com/#b2c08074-c4d9-4e50-b637-0d6c498fa29e
     * @param {string} symbol unified CCXT market symbol
     * @param {string} [side] one-way mode: 'buy' or 'sell', hedge-mode: 'long' or 'short'
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.positionId] the position id you want to close
     * @param {string} [params.type] 'MARKET' or 'LIMIT'
     * @param {string} [params.quantity] how much of currency you want to trade in units of base currency
     * @param {string} [params.price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
     * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> closePosition(object symbol, object side = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object positionId = this.safeString(parameters, "positionId");
        if (isTrue(isEqual(positionId, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " closePosition() requires a positionId")) ;
        }
        object type = this.safeStringUpper(parameters, "type");
        if (isTrue(isEqual(type, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " closePosition() requires a type")) ;
        }
        object quantity = this.safeString(parameters, "quantity");
        if (isTrue(isEqual(quantity, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " closePosition() requires a quantity")) ;
        }
        object request = new Dictionary<string, object>() {
            { "positionId", positionId },
            { "type", type },
            { "quantity", quantity },
        };
        if (isTrue(!isEqual(type, "MARKET")))
        {
            object price = this.safeString(parameters, "price");
            if (isTrue(isEqual(price, null)))
            {
                throw new ArgumentsRequired ((string)add(this.id, " closePosition() requires a price")) ;
            }
            ((IDictionary<string,object>)request)["price"] = price;
        }
        parameters = this.omit(parameters, new List<object>() {"positionId", "type", "quantity", "price"});
        object response = await this.v1PrivateDeleteApiPositionPositionId(this.extend(request, parameters));
        //
        //     {}
        //
        return response;
    }

    /**
     * @method
     * @name defx#closeAllPositions
     * @description closes all open positions for a market type
     * @see https://api-docs.defx.com/#d6f63b43-100e-47a9-998c-8b6c0c72d204
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} A list of [position structures]{@link https://docs.ccxt.com/#/?id=position-structure}
     */
    public async override Task<object> closeAllPositions(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.v1PrivateDeleteApiPositionAll(parameters);
        //
        // {
        //     "data": [
        //         {
        //             "positionId": "d6ca1a27-28ad-47ae-b244-0bda5ac37b2b",
        //             "success": true
        //         }
        //     ]
        // }
        //
        object data = this.safeList(response, "data", new List<object>() {});
        return this.parsePositions(data, null, parameters);
    }

    /**
     * @method
     * @name defx#fetchLedger
     * @description fetch the history of changes, actions done by the user or operations that altered the balance of the user
     * @see https://api-docs.defx.com/#38cc8974-794f-48c0-b959-db045a0ee565
     * @param {string} [code] unified currency code
     * @param {int} [since] timestamp in ms of the earliest ledger entry
     * @param {int} [limit] max number of ledger entries to return
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {int} [params.until] timestamp in ms of the latest ledger entry
     * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [available parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
     * @returns {object} a [ledger structure]{@link https://docs.ccxt.com/#/?id=ledger}
     */
    public async override Task<object> fetchLedger(object code = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object paginate = false;
        var paginateparametersVariable = this.handleOptionAndParams(parameters, "fetchLedger", "paginate");
        paginate = ((IList<object>)paginateparametersVariable)[0];
        parameters = ((IList<object>)paginateparametersVariable)[1];
        if (isTrue(paginate))
        {
            return await this.fetchPaginatedCallDynamic("fetchLedger", code, since, limit, parameters);
        }
        object request = new Dictionary<string, object>() {};
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["start"] = since;
        } else
        {
            ((IDictionary<string,object>)request)["start"] = 0;
        }
        object until = this.safeInteger(parameters, "until");
        if (isTrue(!isEqual(until, null)))
        {
            parameters = this.omit(parameters, "until");
            ((IDictionary<string,object>)request)["end"] = until;
        } else
        {
            ((IDictionary<string,object>)request)["end"] = this.milliseconds();
        }
        object response = await this.v1PrivateGetApiWalletTransactions(this.extend(request, parameters));
        object data = this.safeList(response, "transactions", new List<object>() {});
        return this.parseLedger(data, null, since, limit);
    }

    public override object parseLedgerEntry(object item, object currency = null)
    {
        //
        // {
        //     "id": "01JCSZS6H5VQND3GF5P98SJ29C",
        //     "timestamp": 1731744012054,
        //     "type": "FundingFee",
        //     "amount": "0.02189287",
        //     "asset": "USDC",
        //     "operation": "CREDIT"
        // }
        //
        object amount = this.safeString(item, "amount");
        object currencyId = this.safeString(item, "asset");
        object code = this.safeCurrencyCode(currencyId, currency);
        currency = this.safeCurrency(currencyId, currency);
        object timestamp = this.safeInteger(item, "timestamp");
        object type = this.safeString(item, "type");
        return this.safeLedgerEntry(new Dictionary<string, object>() {
            { "info", item },
            { "id", this.safeString(item, "id") },
            { "direction", null },
            { "account", null },
            { "referenceAccount", null },
            { "referenceId", null },
            { "type", this.parseLedgerEntryType(type) },
            { "currency", code },
            { "amount", this.parseNumber(amount) },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "before", null },
            { "after", null },
            { "status", null },
            { "fee", null },
        }, currency);
    }

    public virtual object parseLedgerEntryType(object type)
    {
        object ledgerType = new Dictionary<string, object>() {
            { "FundingFee", "fee" },
            { "FeeRebate", "fee" },
            { "FeeKickback", "fee" },
            { "RealizedPnl", "trade" },
            { "LiquidationClearance", "trade" },
            { "Transfer", "transfer" },
            { "ReferralPayout", "referral" },
            { "Commission", "commission" },
        };
        return this.safeString(ledgerType, type, type);
    }

    /**
     * @method
     * @name defx#withdraw
     * @description make a withdrawal
     * @see https://api-docs.defx.com/#2600f503-63ed-4672-b8f6-69ea5f03203b
     * @param {string} code unified currency code
     * @param {float} amount the amount to withdraw
     * @param {string} address the address to withdraw to
     * @param {string} tag
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
     */
    public async override Task<object> withdraw(object code, object amount, object address, object tag = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "amount", this.currencyToPrecision(code, amount) },
            { "asset", getValue(currency, "id") },
        };
        object response = await this.v1PrivatePostApiTransfersBridgeWithdrawal(this.extend(request, parameters));
        //
        // {
        //     "transactionId": "0x301e5851e5aefa733abfbc8b30817ca3b61601e0ddf1df8c59656fb888b0bc9c"
        // }
        //
        return this.parseTransaction(response, currency);
    }

    public override object parseTransaction(object transaction, object currency = null)
    {
        //
        // withdraw
        //
        // {
        //     "transactionId": "0x301e5851e5aefa733abfbc8b30817ca3b61601e0ddf1df8c59656fb888b0bc9c"
        // }
        //
        object txid = this.safeString(transaction, "transactionId");
        return new Dictionary<string, object>() {
            { "info", transaction },
            { "id", null },
            { "txid", txid },
            { "timestamp", null },
            { "datetime", null },
            { "network", null },
            { "address", null },
            { "addressTo", null },
            { "addressFrom", null },
            { "tag", null },
            { "tagTo", null },
            { "tagFrom", null },
            { "type", null },
            { "amount", null },
            { "currency", this.safeCurrencyCode(null, currency) },
            { "status", null },
            { "updated", null },
            { "internal", null },
            { "comment", null },
            { "fee", null },
        };
    }

    /**
     * @method
     * @name defx#setLeverage
     * @description set the level of leverage for a market
     * @see https://api-docs.defx.com/#4cb4ecc4-6c61-4194-8353-be67faaf7ca7
     * @param {float} leverage the rate of leverage
     * @param {string} symbol unified market symbol
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} response from the exchange
     */
    public async override Task<object> setLeverage(object leverage, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " setLeverage() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {
            { "leverage", this.numberToString(leverage) },
        };
        object market = this.market(symbol);
        ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
        object response = await this.v1PrivatePostApiUsersMetadataLeverage(this.extend(request, parameters));
        //
        // {
        //     "success": true,
        //     "data": {
        //       "leverage": "11",
        //       "symbol": "BTC_USDC"
        //     }
        // }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        return this.parseLeverage(data, market);
    }

    public override object parseLeverage(object leverage, object market = null)
    {
        //
        //     "data": {
        //       "leverage": "11",
        //       "symbol": "BTC_USDC"
        //     }
        //
        object marketId = this.safeString(leverage, "symbol");
        object leverageValue = this.safeInteger(leverage, "leverage");
        return new Dictionary<string, object>() {
            { "info", leverage },
            { "symbol", this.safeSymbol(marketId, market) },
            { "marginMode", null },
            { "longLeverage", leverageValue },
            { "shortLeverage", leverageValue },
        };
    }

    public override object nonce()
    {
        return this.milliseconds();
    }

    public override object sign(object path, object section = null, object method = null, object parameters = null, object headers = null, object body = null)
    {
        section ??= "public";
        method ??= "GET";
        parameters ??= new Dictionary<string, object>();
        object version = getValue(section, 0);
        object access = getValue(section, 1);
        object pathWithParams = this.implodeParams(path, parameters);
        object url = this.implodeHostname(getValue(getValue(this.urls, "api"), access));
        url = add(url, add(add("/", version), "/"));
        parameters = this.omit(parameters, this.extractParams(path));
        parameters = this.keysort(parameters);
        if (isTrue(isEqual(access, "public")))
        {
            url = add(url, add("open/", pathWithParams));
            if (isTrue(getArrayLength(new List<object>(((IDictionary<string,object>)parameters).Keys))))
            {
                url = add(url, add("?", this.rawencode(parameters)));
            }
        } else
        {
            this.checkRequiredCredentials();
            headers = new Dictionary<string, object>() {
                { "X-DEFX-SOURCE", "ccxt" },
            };
            url = add(url, add("auth/", pathWithParams));
            object nonce = ((object)this.milliseconds()).ToString();
            object payload = nonce;
            if (isTrue(isTrue(isEqual(method, "GET")) || isTrue(isEqual(path, "api/order/{orderId}"))))
            {
                payload = add(payload, this.rawencode(parameters));
                if (isTrue(getArrayLength(new List<object>(((IDictionary<string,object>)parameters).Keys))))
                {
                    url = add(url, add("?", this.rawencode(parameters)));
                }
            } else
            {
                if (isTrue(!isEqual(parameters, null)))
                {
                    body = this.json(parameters);
                    payload = add(payload, body);
                }
                ((IDictionary<string,object>)headers)["Content-Type"] = "application/json";
            }
            object signature = this.hmac(this.encode(payload), this.encode(this.secret), sha256);
            ((IDictionary<string,object>)headers)["X-DEFX-APIKEY"] = this.apiKey;
            ((IDictionary<string,object>)headers)["X-DEFX-TIMESTAMP"] = nonce;
            ((IDictionary<string,object>)headers)["X-DEFX-SIGNATURE"] = signature;
        }
        return new Dictionary<string, object>() {
            { "url", url },
            { "method", method },
            { "body", body },
            { "headers", headers },
        };
    }

    public override object handleErrors(object httpCode, object reason, object url, object method, object headers, object body, object response, object requestHeaders, object requestBody)
    {
        if (!isTrue(response))
        {
            return null;  // fallback to default error handler
        }
        // {"errorCode":404,"errorMessage":"Not Found"}
        // {"msg":"Missing auth signature","code":"missing_auth_signature"}
        // {"success":false,"err":{"msg":"Invalid order id","code":"invalid_order_id"}}
        object success = this.safeBool(response, "success");
        object err = this.safeDict(response, "err", response);
        object errorCode = this.safeString2(err, "errorCode", "code");
        if (!isTrue(success))
        {
            object feedback = add(add(this.id, " "), this.json(response));
            this.throwBroadlyMatchedException(getValue(this.exceptions, "broad"), body, feedback);
            this.throwExactlyMatchedException(getValue(this.exceptions, "exact"), errorCode, feedback);
        }
        return null;
    }

    public virtual object defaultNetworkCodeForCurrency(object code)
    {
        object currencyItem = this.currency(code);
        object networks = getValue(currencyItem, "networks");
        object networkKeys = new List<object>(((IDictionary<string,object>)networks).Keys);
        for (object i = 0; isLessThan(i, getArrayLength(networkKeys)); postFixIncrement(ref i))
        {
            object network = getValue(networkKeys, i);
            if (isTrue(isEqual(network, "ETH")))
            {
                return network;
            }
        }
        // if it was not returned according to above options, then return the first network of currency
        return this.safeValue(networkKeys, 0);
    }

    public override void setSandboxMode(object enable)
    {
        base.setSandboxMode(enable);
        ((IDictionary<string,object>)this.options)["sandboxMode"] = enable;
    }
}
