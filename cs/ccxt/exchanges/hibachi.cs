namespace ccxt;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

public partial class hibachi : Exchange
{
    public override object describe()
    {
        return this.deepExtend(base.describe(), new Dictionary<string, object>() {
            { "id", "hibachi" },
            { "name", "Hibachi" },
            { "countries", new List<object>() {"US"} },
            { "rateLimit", 100 },
            { "userAgent", getValue(this.userAgents, "chrome") },
            { "certified", false },
            { "pro", false },
            { "dex", true },
            { "has", new Dictionary<string, object>() {
                { "CORS", null },
                { "spot", false },
                { "margin", false },
                { "swap", true },
                { "future", false },
                { "option", false },
                { "addMargin", false },
                { "cancelAllOrders", true },
                { "cancelOrder", true },
                { "cancelOrders", true },
                { "cancelWithdraw", false },
                { "closeAllPositions", false },
                { "closePosition", false },
                { "createConvertTrade", false },
                { "createDepositAddress", false },
                { "createMarketBuyOrderWithCost", false },
                { "createMarketOrder", false },
                { "createMarketOrderWithCost", false },
                { "createMarketSellOrderWithCost", false },
                { "createOrder", true },
                { "createOrders", true },
                { "createOrderWithTakeProfitAndStopLoss", false },
                { "createReduceOnlyOrder", false },
                { "createStopLimitOrder", false },
                { "createStopLossOrder", false },
                { "createStopMarketOrder", false },
                { "createStopOrder", false },
                { "createTakeProfitOrder", false },
                { "createTrailingAmountOrder", false },
                { "createTrailingPercentOrder", false },
                { "createTriggerOrder", false },
                { "editOrder", true },
                { "editOrders", true },
                { "fetchAccounts", false },
                { "fetchBalance", true },
                { "fetchCanceledOrders", false },
                { "fetchClosedOrder", false },
                { "fetchClosedOrders", false },
                { "fetchConvertCurrencies", false },
                { "fetchConvertQuote", false },
                { "fetchCurrencies", true },
                { "fetchDepositAddress", true },
                { "fetchDeposits", true },
                { "fetchDepositsWithdrawals", false },
                { "fetchFundingHistory", false },
                { "fetchFundingInterval", false },
                { "fetchFundingIntervals", false },
                { "fetchFundingRate", true },
                { "fetchFundingRateHistory", true },
                { "fetchFundingRates", false },
                { "fetchIndexOHLCV", false },
                { "fetchLedger", true },
                { "fetchLeverage", false },
                { "fetchMarginAdjustmentHistory", false },
                { "fetchMarginMode", false },
                { "fetchMarkets", true },
                { "fetchMyTrades", true },
                { "fetchOHLCV", true },
                { "fetchOpenInterest", true },
                { "fetchOpenInterestHistory", false },
                { "fetchOpenOrder", false },
                { "fetchOpenOrders", true },
                { "fetchOrder", true },
                { "fetchOrderBook", true },
                { "fetchOrders", false },
                { "fetchOrderTrades", false },
                { "fetchPosition", false },
                { "fetchPositionMode", false },
                { "fetchPositions", true },
                { "fetchPremiumIndexOHLCV", false },
                { "fetchStatus", false },
                { "fetchTicker", true },
                { "fetchTickers", false },
                { "fetchTime", true },
                { "fetchTrades", true },
                { "fetchTradingFee", false },
                { "fetchTradingFees", true },
                { "fetchTradingLimits", false },
                { "fetchTransactions", "emulated" },
                { "fetchTransfers", false },
                { "fetchWithdrawals", true },
                { "reduceMargin", false },
                { "setLeverage", false },
                { "setMargin", false },
                { "setPositionMode", false },
                { "transfer", false },
                { "withdraw", true },
            } },
            { "timeframes", new Dictionary<string, object>() {
                { "1m", "1min" },
                { "5m", "5min" },
                { "15m", "15min" },
                { "1h", "1h" },
                { "4h", "4h" },
                { "1d", "1d" },
                { "1w", "1w" },
            } },
            { "urls", new Dictionary<string, object>() {
                { "logo", "https://github.com/user-attachments/assets/7301bbb1-4f27-4167-8a55-75f74b14e973" },
                { "api", new Dictionary<string, object>() {
                    { "public", "https://data-api.hibachi.xyz" },
                    { "private", "https://api.hibachi.xyz" },
                } },
                { "www", "https://www.hibachi.xyz/" },
                { "referral", new Dictionary<string, object>() {
                    { "url", "hibachi.xyz/r/ZBL2YFWIHU" },
                } },
            } },
            { "api", new Dictionary<string, object>() {
                { "public", new Dictionary<string, object>() {
                    { "get", new Dictionary<string, object>() {
                        { "market/exchange-info", 1 },
                        { "market/data/trades", 1 },
                        { "market/data/prices", 1 },
                        { "market/data/stats", 1 },
                        { "market/data/klines", 1 },
                        { "market/data/orderbook", 1 },
                        { "market/data/open-interest", 1 },
                        { "market/data/funding-rates", 1 },
                        { "exchange/utc-timestamp", 1 },
                    } },
                } },
                { "private", new Dictionary<string, object>() {
                    { "get", new Dictionary<string, object>() {
                        { "capital/deposit-info", 1 },
                        { "capital/history", 1 },
                        { "trade/account/trading_history", 1 },
                        { "trade/account/info", 1 },
                        { "trade/order", 1 },
                        { "trade/account/trades", 1 },
                        { "trade/orders", 1 },
                    } },
                    { "put", new Dictionary<string, object>() {
                        { "trade/order", 1 },
                    } },
                    { "delete", new Dictionary<string, object>() {
                        { "trade/order", 1 },
                        { "trade/orders", 1 },
                    } },
                    { "post", new Dictionary<string, object>() {
                        { "trade/order", 1 },
                        { "trade/orders", 1 },
                        { "capital/withdraw", 1 },
                    } },
                } },
            } },
            { "requiredCredentials", new Dictionary<string, object>() {
                { "apiKey", true },
                { "secret", false },
                { "accountId", true },
                { "privateKey", true },
            } },
            { "fees", new Dictionary<string, object>() {
                { "trading", new Dictionary<string, object>() {
                    { "tierBased", false },
                    { "percentage", true },
                    { "maker", this.parseNumber("0.00015") },
                    { "taker", this.parseNumber("0.00045") },
                } },
            } },
            { "options", new Dictionary<string, object>() {} },
            { "features", new Dictionary<string, object>() {
                { "default", new Dictionary<string, object>() {
                    { "sandbox", false },
                    { "createOrder", new Dictionary<string, object>() {
                        { "marginMode", false },
                        { "triggerPrice", true },
                        { "triggerPriceType", null },
                        { "triggerDirection", null },
                        { "stopLossPrice", false },
                        { "takeProfitPrice", false },
                        { "attachedStopLossTakeProfit", null },
                        { "timeInForce", new Dictionary<string, object>() {
                            { "IOC", true },
                            { "FOK", false },
                            { "PO", true },
                            { "GTD", false },
                        } },
                        { "hedged", false },
                        { "trailing", false },
                        { "leverage", false },
                        { "marketBuyByCost", false },
                        { "marketBuyRequiresPrice", false },
                        { "selfTradePrevention", false },
                        { "iceberg", false },
                    } },
                    { "createOrders", null },
                    { "fetchMyTrades", new Dictionary<string, object>() {
                        { "marginMode", false },
                        { "limit", null },
                        { "daysBack", null },
                        { "untilDays", null },
                        { "symbolRequired", false },
                    } },
                    { "fetchOrder", new Dictionary<string, object>() {
                        { "marginMode", false },
                        { "trigger", false },
                        { "trailing", false },
                        { "symbolRequired", false },
                    } },
                    { "fetchOpenOrders", new Dictionary<string, object>() {
                        { "marginMode", false },
                        { "limit", null },
                        { "trigger", false },
                        { "trailing", false },
                        { "symbolRequired", false },
                    } },
                    { "fetchOrders", null },
                    { "fetchClosedOrders", null },
                    { "fetchOHLCV", new Dictionary<string, object>() {
                        { "limit", null },
                    } },
                } },
                { "swap", new Dictionary<string, object>() {
                    { "linear", new Dictionary<string, object>() {
                        { "extends", "default" },
                    } },
                    { "inverse", null },
                } },
                { "future", new Dictionary<string, object>() {
                    { "linear", new Dictionary<string, object>() {
                        { "extends", "default" },
                    } },
                    { "inverse", null },
                } },
            } },
            { "commonCurrencies", new Dictionary<string, object>() {} },
            { "exceptions", new Dictionary<string, object>() {
                { "exact", new Dictionary<string, object>() {
                    { "2", typeof(BadRequest) },
                    { "3", typeof(OrderNotFound) },
                    { "4", typeof(BadRequest) },
                } },
                { "broad", new Dictionary<string, object>() {} },
            } },
            { "precisionMode", TICK_SIZE },
        });
    }

    public virtual object getAccountId()
    {
        this.checkRequiredCredentials();
        object id = this.parseToInt(this.accountId);
        return id;
    }

    public override object parseMarket(object market)
    {
        object marketId = this.safeString(market, "symbol");
        object numericId = this.safeNumber(market, "id");
        object marketType = "swap";
        object baseId = this.safeString(market, "underlyingSymbol");
        object quoteId = this.safeString(market, "settlementSymbol");
        object bs = this.safeCurrencyCode(baseId);
        object quote = this.safeCurrencyCode(quoteId);
        object settleId = this.safeString(market, "settlementSymbol");
        object settle = this.safeCurrencyCode(settleId);
        object symbol = add(add(add(add(bs, "/"), quote), ":"), settle);
        object created = this.safeIntegerProduct(market, "marketCreationTimestamp", 1000);
        return new Dictionary<string, object>() {
            { "id", marketId },
            { "numericId", numericId },
            { "symbol", symbol },
            { "base", bs },
            { "quote", quote },
            { "settle", settle },
            { "baseId", baseId },
            { "quoteId", quoteId },
            { "settleId", settleId },
            { "type", marketType },
            { "spot", false },
            { "margin", false },
            { "swap", true },
            { "future", false },
            { "option", false },
            { "active", isEqual(this.safeString(market, "status"), "LIVE") },
            { "contract", true },
            { "linear", true },
            { "inverse", false },
            { "contractSize", this.parseNumber("1") },
            { "expiry", null },
            { "expiryDatetime", null },
            { "strike", null },
            { "optionType", null },
            { "precision", new Dictionary<string, object>() {
                { "amount", this.parseNumber(this.parsePrecision(this.safeString(market, "underlyingDecimals"))) },
                { "price", divide(this.parseNumber(getValue(this.safeList(market, "orderbookGranularities"), 0)), 10000) },
            } },
            { "limits", new Dictionary<string, object>() {
                { "leverage", new Dictionary<string, object>() {
                    { "min", null },
                    { "max", null },
                } },
                { "amount", new Dictionary<string, object>() {
                    { "min", null },
                    { "max", null },
                } },
                { "price", new Dictionary<string, object>() {
                    { "min", null },
                    { "max", null },
                } },
                { "cost", new Dictionary<string, object>() {
                    { "min", this.safeNumber(market, "minNotional") },
                    { "max", null },
                } },
            } },
            { "created", created },
            { "info", market },
        };
    }

    /**
     * @method
     * @name hibachi#fetchMarkets
     * @description retrieves data on all markets for hibachi
     * @see https://api-doc.hibachi.xyz/#183981da-8df5-40a0-a155-da15015dd536
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} an array of objects representing market data
     */
    public async override Task<object> fetchMarkets(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object response = await this.publicGetMarketExchangeInfo(parameters);
        // {
        //     "displayName": "ETH/USDT Perps",
        //     "id": 1,
        //     "maintenanceFactorForPositions": "0.030000",
        //     "marketCloseTimestamp": null,
        //     "marketOpenTimestamp": null,
        //     "minNotional": "1",
        //     "minOrderSize": "0.000000001",
        //     "orderbookGranularities": [
        //         "0.01",
        //         "0.1",
        //         "1",
        //         "10"
        //     ],
        //     "riskFactorForOrders": "0.066667",
        //     "riskFactorForPositions": "0.030000",
        //     "settlementDecimals": 6,
        //     "settlementSymbol": "USDT",
        //     "status": "LIVE",
        //     "stepSize": "0.000000001",
        //     "symbol": "ETH/USDT-P",
        //     "tickSize": "0.000001",
        //     "underlyingDecimals": 9,
        //     "underlyingSymbol": "ETH"
        // },
        object rows = this.safeList(response, "futureContracts");
        return this.parseMarkets(rows);
    }

    /**
     * @method
     * @name hibachi#fetchCurrencies
     * @description fetches all available currencies on an exchange
     * @see https://api-doc.hibachi.xyz/#183981da-8df5-40a0-a155-da15015dd536
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} an associative dictionary of currencies
     */
    public async override Task<object> fetchCurrencies(object parameters = null)
    {
        // Hibachi only supports USDT on Arbitrum at this time
        // We don't have an API endpoint to expose this information yet
        parameters ??= new Dictionary<string, object>();
        object result = new Dictionary<string, object>() {};
        object networks = new Dictionary<string, object>() {};
        object networkId = "ARBITRUM";
        ((IDictionary<string,object>)networks)[(string)networkId] = new Dictionary<string, object>() {
            { "id", networkId },
            { "network", networkId },
            { "limits", new Dictionary<string, object>() {
                { "withdraw", new Dictionary<string, object>() {
                    { "min", null },
                    { "max", null },
                } },
                { "deposit", new Dictionary<string, object>() {
                    { "min", null },
                    { "max", null },
                } },
            } },
            { "active", null },
            { "deposit", null },
            { "withdraw", null },
            { "info", new Dictionary<string, object>() {} },
        };
        object code = this.safeCurrencyCode("USDT");
        ((IDictionary<string,object>)result)[(string)code] = this.safeCurrencyStructure(new Dictionary<string, object>() {
            { "id", "USDT" },
            { "name", "USDT" },
            { "type", "fiat" },
            { "code", code },
            { "precision", this.parseNumber("0.000001") },
            { "active", true },
            { "fee", null },
            { "networks", networks },
            { "deposit", true },
            { "withdraw", true },
            { "limits", new Dictionary<string, object>() {
                { "deposit", new Dictionary<string, object>() {
                    { "min", null },
                    { "max", null },
                } },
                { "withdraw", new Dictionary<string, object>() {
                    { "min", null },
                    { "max", null },
                } },
            } },
            { "info", new Dictionary<string, object>() {} },
        });
        return result;
    }

    public override object parseBalance(object response)
    {
        object result = new Dictionary<string, object>() {
            { "info", response },
        };
        // Hibachi only supports USDT on Arbitrum at this time
        object code = this.safeCurrencyCode("USDT");
        object account = this.account();
        ((IDictionary<string,object>)account)["total"] = this.safeString(response, "balance");
        ((IDictionary<string,object>)account)["free"] = this.safeString(response, "maximalWithdraw");
        ((IDictionary<string,object>)result)[(string)code] = account;
        return this.safeBalance(result);
    }

    /**
     * @method
     * @name hibachi#fetchBalance
     * @description query for balance and get the amount of funds available for trading or funds locked in orders
     * @see https://api-doc.hibachi.xyz/#69aafedb-8274-4e21-bbaf-91dace8b8f31
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
     */
    public async override Task<object> fetchBalance(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object request = new Dictionary<string, object>() {
            { "accountId", this.getAccountId() },
        };
        object response = await this.privateGetTradeAccountInfo(this.extend(request, parameters));
        //
        // {
        //     assets: [ { quantity: '3.000000', symbol: 'USDT' } ],
        //     balance: '3.000000',
        //     maximalWithdraw: '3.000000',
        //     numFreeTransfersRemaining: '100',
        //     positions: [],
        //     totalOrderNotional: '0.000000',
        //     totalPositionNotional: '0.000000',
        //     totalUnrealizedFundingPnl: '0.000000',
        //     totalUnrealizedPnl: '0.000000',
        //     totalUnrealizedTradingPnl: '0.000000',
        //     tradeMakerFeeRate: '0.00000000',
        //     tradeTakerFeeRate: '0.00020000'
        // }
        //
        return this.parseBalance(response);
    }

    public override object parseTicker(object ticker, object market = null)
    {
        object prices = this.safeDict(ticker, "prices");
        object stats = this.safeDict(ticker, "stats");
        object bid = this.safeNumber(prices, "bidPrice");
        object ask = this.safeNumber(prices, "askPrice");
        object last = this.safeNumber(prices, "tradePrice");
        object high = this.safeNumber(stats, "high24h");
        object low = this.safeNumber(stats, "low24h");
        object volume = this.safeNumber(stats, "volume24h");
        return this.safeTicker(new Dictionary<string, object>() {
            { "symbol", this.safeSymbol(null, market) },
            { "timestamp", null },
            { "datetime", null },
            { "bid", bid },
            { "ask", ask },
            { "last", last },
            { "high", high },
            { "low", low },
            { "bidVolume", null },
            { "askVolume", null },
            { "vwap", null },
            { "open", null },
            { "close", last },
            { "previousClose", null },
            { "change", null },
            { "percentage", null },
            { "average", null },
            { "baseVolume", null },
            { "quoteVolume", volume },
            { "info", ticker },
        }, market);
    }

    public override object parseTrade(object trade, object market = null)
    {
        // public fetchTrades:
        //      {
        //          "price": "3512.431902",
        //          "quantity": "1.414780098",
        //          "takerSide": "Buy",
        //          "timestamp": 1712692147
        //      }
        //
        // private fetchMyTrades:
        //      {
        //          "askAccountId": 221,
        //          "askOrderId": 589168494921909200,
        //          "bidAccountId": 132,
        //          "bidOrderId": 589168494829895700,
        //          "fee": "0.000477",
        //          "id": 199511136,
        //          "orderType": "MARKET",
        //          "price": "119257.90000",
        //          "quantity": "0.0000200000",
        //          "realizedPnl": "-0.000352",
        //          "side": "Sell",
        //          "symbol": "BTC/USDT-P",
        //          "timestamp": 1752543391
        //      }
        object marketId = this.safeString(trade, "symbol");
        market = this.safeMarket(marketId, market);
        object symbol = getValue(market, "symbol");
        object id = this.safeString(trade, "id");
        object price = this.safeString(trade, "price");
        object amount = this.safeString(trade, "quantity");
        object timestamp = this.safeIntegerProduct(trade, "timestamp", 1000);
        object cost = Precise.stringMul(price, amount);
        object side = null;
        object fee = null;
        object orderType = null;
        object orderId = null;
        object takerOrMaker = null;
        if (isTrue(isEqual(id, null)))
        {
            // public trades
            side = this.safeStringLower(trade, "takerSide");
            takerOrMaker = "taker";
        } else
        {
            // private trades
            side = this.safeStringLower(trade, "side");
            fee = new Dictionary<string, object>() {
                { "cost", this.safeString(trade, "fee") },
                { "currency", "USDT" },
            };
            orderType = this.safeStringLower(trade, "orderType");
            if (isTrue(isEqual(side, "buy")))
            {
                orderId = this.safeString(trade, "bidOrderId");
            } else
            {
                orderId = this.safeString(trade, "askOrderId");
            }
        }
        return this.safeTrade(new Dictionary<string, object>() {
            { "id", id },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "symbol", symbol },
            { "side", side },
            { "price", price },
            { "amount", amount },
            { "cost", cost },
            { "order", orderId },
            { "takerOrMaker", takerOrMaker },
            { "type", orderType },
            { "fee", fee },
            { "info", trade },
        }, market);
    }

    /**
     * @method
     * @name hibachi#fetchTrades
     * @description get the list of most recent trades for a particular symbol
     * @see https://api-doc.hibachi.xyz/#86a53bc1-d3bb-4b93-8a11-7034d4698caa
     * @param {string} symbol unified market symbol
     * @param {int} [since] timestamp in ms of the earliest trade to fetch
     * @param {int} [limit] the maximum amount of trades to fetch (maximum value is 100)
     * @param {object} [params] extra parameters specific to the hibachi api endpoint
     * @returns {object[]} a list of recent [trade structures]
     */
    public async override Task<object> fetchTrades(object symbol, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object response = await this.publicGetMarketDataTrades(this.extend(request, parameters));
        //
        // {
        //     "trades": [
        //         {
        //             "price": "111091.38352",
        //             "quantity": "0.0090090093",
        //             "takerSide": "Buy",
        //             "timestamp": 1752095479
        //         },
        //     ]
        // }
        //
        object trades = this.safeList(response, "trades", new List<object>() {});
        return this.parseTrades(trades, market);
    }

    /**
     * @method
     * @name hibachi#fetchTicker
     * @see https://api-doc.hibachi.xyz/#4abb30c4-e5c7-4b0f-9ade-790111dbfa47
     * @description fetches a price ticker and the related information for the past 24h
     * @param {string} symbol unified symbol of the market
     * @param {object} [params] extra parameters specific to the hibachi api endpoint
     * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
     */
    public async override Task<object> fetchTicker(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object rawPromises = new List<object> {this.publicGetMarketDataPrices(this.extend(request, parameters)), this.publicGetMarketDataStats(this.extend(request, parameters))};
        object promises = await promiseAll(rawPromises);
        object pricesResponse = getValue(promises, 0);
        // {
        //     "askPrice": "3514.650296",
        //     "bidPrice": "3513.596112",
        //     "fundingRateEstimation": {
        //         "estimatedFundingRate": "0.000001",
        //         "nextFundingTimestamp": 1712707200
        //     },
        //     "markPrice": "3514.288858",
        //     "spotPrice": "3514.715000",
        //     "symbol": "ETH/USDT-P",
        //     "tradePrice": "2372.746570"
        // }
        object statsResponse = getValue(promises, 1);
        // {
        //     "high24h": "3819.507827",
        //     "low24h": "3754.474162",
        //     "symbol": "ETH/USDT-P",
        //     "volume24h": "23554.858590416"
        // }
        object ticker = new Dictionary<string, object>() {
            { "prices", pricesResponse },
            { "stats", statsResponse },
        };
        return this.parseTicker(ticker, market);
    }

    public virtual object parseOrderStatus(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "PENDING", "open" },
            { "CHILD_PENDING", "open" },
            { "SCHEDULED_TWAP", "open" },
            { "PLACED", "open" },
            { "PARTIALLY_FILLED", "open" },
            { "FILLED", "closed" },
            { "CANCELLED", "canceled" },
            { "REJECTED", "rejected" },
        };
        return this.safeString(statuses, status, status);
    }

    public override object parseOrder(object order, object market = null)
    {
        object marketId = this.safeString(order, "symbol");
        market = this.safeMarket(marketId, market);
        object status = this.safeString(order, "status");
        object type = this.safeStringLower(order, "orderType");
        object price = this.safeString(order, "price");
        object rawSide = this.safeString(order, "side");
        object side = null;
        if (isTrue(isEqual(rawSide, "BID")))
        {
            side = "buy";
        } else if (isTrue(isEqual(rawSide, "ASK")))
        {
            side = "sell";
        }
        object amount = this.safeString(order, "totalQuantity");
        object remaining = this.safeString(order, "availableQuantity");
        object totalQuantity = this.safeString(order, "totalQuantity");
        object availableQuantity = this.safeString(order, "availableQuantity");
        object filled = null;
        if (isTrue(isTrue(!isEqual(totalQuantity, null)) && isTrue(!isEqual(availableQuantity, null))))
        {
            filled = Precise.stringSub(totalQuantity, availableQuantity);
        }
        object timeInForce = "GTC";
        object orderFlags = this.safeValue(order, "orderFlags");
        object postOnly = false;
        object reduceOnly = false;
        if (isTrue(isEqual(orderFlags, "POST_ONLY")))
        {
            timeInForce = "PO";
            postOnly = true;
        } else if (isTrue(isEqual(orderFlags, "IOC")))
        {
            timeInForce = "IOC";
        } else if (isTrue(isEqual(orderFlags, "REDUCE_ONLY")))
        {
            reduceOnly = true;
        }
        return this.safeOrder(new Dictionary<string, object>() {
            { "info", order },
            { "id", this.safeString(order, "orderId") },
            { "clientOrderId", null },
            { "datetime", null },
            { "timestamp", null },
            { "lastTradeTimestamp", null },
            { "lastUpdateTimestamp", null },
            { "status", this.parseOrderStatus(status) },
            { "symbol", getValue(market, "symbol") },
            { "type", type },
            { "timeInForce", timeInForce },
            { "side", side },
            { "price", price },
            { "average", null },
            { "amount", amount },
            { "filled", filled },
            { "remaining", remaining },
            { "cost", null },
            { "trades", null },
            { "fee", null },
            { "reduceOnly", reduceOnly },
            { "postOnly", postOnly },
            { "triggerPrice", this.safeNumber(order, "triggerPrice") },
        }, market);
    }

    /**
     * @method
     * @name hibachi#fetchOrder
     * @description fetches information on an order made by the user
     * @see https://api-doc.hibachi.xyz/#096a8854-b918-4de8-8731-b2a28d26b96d
     * @param {string} id the order id
     * @param {string} symbol unified symbol of the market the order was made in
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> fetchOrder(object id, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
        }
        object request = new Dictionary<string, object>() {
            { "orderId", id },
            { "accountId", this.getAccountId() },
        };
        object response = await this.privateGetTradeOrder(this.extend(request, parameters));
        return this.parseOrder(response, market);
    }

    /**
     * @method
     * @name hibachi#fetchTradingFees
     * @description fetch the trading fee
     * @param params extra parameters
     * @returns {object} a map of market symbols to [fee structures]{@link https://docs.ccxt.com/#/?id=fee-structure}
     */
    public async override Task<object> fetchTradingFees(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {
            { "accountId", this.getAccountId() },
        };
        object response = await this.privateGetTradeAccountInfo(this.extend(request, parameters));
        //    {
        //        "tradeMakerFeeRate": "0.00000000",
        //        "tradeTakerFeeRate": "0.00020000"
        //    },
        object makerFeeRate = this.safeNumber(response, "tradeMakerFeeRate");
        object takerFeeRate = this.safeNumber(response, "tradeTakerFeeRate");
        object result = new Dictionary<string, object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(this.symbols)); postFixIncrement(ref i))
        {
            object symbol = getValue(this.symbols, i);
            ((IDictionary<string,object>)result)[(string)symbol] = new Dictionary<string, object>() {
                { "info", response },
                { "symbol", symbol },
                { "maker", makerFeeRate },
                { "taker", takerFeeRate },
                { "percentage", true },
            };
        }
        return result;
    }

    public virtual object orderMessage(object market, object nonce, object feeRate, object type, object side, object amount, object price = null)
    {
        object sideInternal = 0;
        if (isTrue(isEqual(side, "sell")))
        {
            sideInternal = 0;
        } else if (isTrue(isEqual(side, "buy")))
        {
            sideInternal = 1;
        }
        // Converting them to internal representation:
        // - Quantity: Internal = External * (10^underlyingDecimals)
        // - Price: Internal = External * (2^32) * (10^(settlementDecimals-underlyingDecimals))
        // - FeeRate: Internal = External * (10^8)
        object amountStr = this.amountToPrecision(this.safeString(market, "symbol"), amount);
        object feeRateStr = this.numberToString(feeRate);
        object info = this.safeDict(market, "info");
        object underlying = add("1e", this.safeString(info, "underlyingDecimals"));
        object settlement = add("1e", this.safeString(info, "settlementDecimals"));
        object one = "1";
        object feeRateFactor = "100000000"; // 10^8
        object priceFactor = "4294967296"; // 2^32
        object quantityInternal = Precise.stringDiv(Precise.stringMul(amountStr, underlying), one, 0);
        object feeRateInternal = Precise.stringDiv(Precise.stringMul(feeRateStr, feeRateFactor), one, 0);
        // Encoding
        object nonce16 = this.intToBase16(nonce);
        object noncePadded = (nonce16 as String).PadLeft(Convert.ToInt32(16), Convert.ToChar("0"));
        object encodedNonce = this.base16ToBinary(noncePadded);
        object numericId = this.intToBase16(this.safeInteger(market, "numericId"));
        object numericIdPadded = (numericId as String).PadLeft(Convert.ToInt32(8), Convert.ToChar("0"));
        object encodedMarketId = this.base16ToBinary(numericIdPadded);
        object quantity16 = this.intToBase16(this.parseToInt(quantityInternal));
        object quantityPadded = (quantity16 as String).PadLeft(Convert.ToInt32(16), Convert.ToChar("0"));
        object encodedQuantity = this.base16ToBinary(quantityPadded);
        object sideInternal16 = this.intToBase16(sideInternal);
        object sidePadded = (sideInternal16 as String).PadLeft(Convert.ToInt32(8), Convert.ToChar("0"));
        object encodedSide = this.base16ToBinary(sidePadded);
        object feeRateInternal16 = this.intToBase16(this.parseToInt(feeRateInternal));
        object feeRatePadded = (feeRateInternal16 as String).PadLeft(Convert.ToInt32(16), Convert.ToChar("0"));
        object encodedFeeRate = this.base16ToBinary(feeRatePadded);
        object encodedPrice = this.binaryConcat();
        if (isTrue(isEqual(type, "limit")))
        {
            object priceStr = this.priceToPrecision(this.safeString(market, "symbol"), price);
            object priceInternal = Precise.stringDiv(Precise.stringDiv(Precise.stringMul(Precise.stringMul(priceStr, priceFactor), settlement), underlying), one, 0);
            object price16 = this.intToBase16(this.parseToInt(priceInternal));
            object pricePadded = (price16 as String).PadLeft(Convert.ToInt32(16), Convert.ToChar("0"));
            encodedPrice = this.base16ToBinary(pricePadded);
        }
        object message = this.binaryConcat(encodedNonce, encodedMarketId, encodedQuantity, encodedSide, encodedPrice, encodedFeeRate);
        return message;
    }

    public virtual object createOrderRequest(object nonce, object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object market = this.market(symbol);
        object feeRate = mathMax(this.safeNumber(market, "taker"), this.safeNumber(market, "maker"));
        object sideInternal = "";
        if (isTrue(isEqual(side, "sell")))
        {
            sideInternal = "ASK";
        } else if (isTrue(isEqual(side, "buy")))
        {
            sideInternal = "BID";
        }
        object priceInternal = "";
        if (isTrue(price))
        {
            priceInternal = this.priceToPrecision(symbol, price);
        }
        object message = this.orderMessage(market, nonce, feeRate, type, side, amount, price);
        object signature = this.signMessage(message, this.privateKey);
        object request = new Dictionary<string, object>() {
            { "symbol", this.safeString(market, "id") },
            { "nonce", nonce },
            { "side", sideInternal },
            { "orderType", ((string)type).ToUpper() },
            { "quantity", this.amountToPrecision(symbol, amount) },
            { "price", priceInternal },
            { "signature", signature },
            { "maxFeesPercent", this.numberToString(feeRate) },
        };
        object postOnly = this.isPostOnly(isEqual(((string)type).ToUpper(), "MARKET"), null, parameters);
        object reduceOnly = this.safeBool2(parameters, "reduceOnly", "reduce_only");
        object timeInForce = this.safeStringLower(parameters, "timeInForce");
        object triggerPrice = this.safeString2(parameters, "triggerPrice", "stopPrice");
        if (isTrue(postOnly))
        {
            ((IDictionary<string,object>)request)["orderFlags"] = "POST_ONLY";
        } else if (isTrue(isEqual(timeInForce, "ioc")))
        {
            ((IDictionary<string,object>)request)["orderFlags"] = "IOC";
        } else if (isTrue(reduceOnly))
        {
            ((IDictionary<string,object>)request)["orderFlags"] = "REDUCE_ONLY";
        }
        if (isTrue(!isEqual(triggerPrice, null)))
        {
            ((IDictionary<string,object>)request)["triggerPrice"] = triggerPrice;
        }
        parameters = this.omit(parameters, new List<object>() {"reduceOnly", "reduce_only", "postOnly", "timeInForce", "stopPrice", "triggerPrice"});
        return this.extend(request, parameters);
    }

    /**
     * @method
     * @name hibachi#createOrder
     * @description create a trade order
     * @see https://api-doc.hibachi.xyz/#00f6d5ad-5275-41cb-a1a8-19ed5d142124
     * @param {string} symbol unified symbol of the market to create an order in
     * @param {string} type 'market' or 'limit'
     * @param {string} side 'buy' or 'sell'
     * @param {float} amount how much of currency you want to trade in units of base currency
     * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> createOrder(object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object nonce = this.nonce();
        object request = this.createOrderRequest(nonce, symbol, type, side, amount, price, parameters);
        ((IDictionary<string,object>)request)["accountId"] = this.getAccountId();
        object response = await this.privatePostTradeOrder(request);
        //
        // {
        //     "orderId": "578721673790138368"
        // }
        //
        return this.safeOrder(new Dictionary<string, object>() {
            { "id", this.safeString(response, "orderId") },
            { "status", "pending" },
        });
    }

    /**
     * @method
     * @name hibachi#createOrders
     * @description *contract only* create a list of trade orders
     * @see https://api-doc.hibachi.xyz/#c2840b9b-f02c-44ed-937d-dc2819f135b4
     * @param {Array} orders list of orders to create, each object should contain the parameters required by createOrder, namely symbol, type, side, amount, price and params
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> createOrders(object orders, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object nonce = this.nonce();
        object requestOrders = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(orders)); postFixIncrement(ref i))
        {
            object rawOrder = getValue(orders, i);
            object symbol = this.safeString(rawOrder, "symbol");
            object type = this.safeString(rawOrder, "type");
            object side = this.safeString(rawOrder, "side");
            object amount = this.safeValue(rawOrder, "amount");
            object price = this.safeValue(rawOrder, "price");
            object orderParams = this.safeDict(rawOrder, "params", new Dictionary<string, object>() {});
            object orderRequest = this.createOrderRequest(add(nonce, i), symbol, type, side, amount, price, orderParams);
            ((IDictionary<string,object>)orderRequest)["action"] = "place";
            ((IList<object>)requestOrders).Add(orderRequest);
        }
        object request = new Dictionary<string, object>() {
            { "accountId", this.getAccountId() },
            { "orders", requestOrders },
        };
        object response = await this.privatePostTradeOrders(this.extend(request, parameters));
        //
        // { "orders": [ { nonce: '1754349993908', orderId: '589642085255349248' } ] }
        //
        object ret = new List<object>() {};
        object responseOrders = this.safeList(response, "orders");
        for (object i = 0; isLessThan(i, getArrayLength(responseOrders)); postFixIncrement(ref i))
        {
            object responseOrder = getValue(responseOrders, i);
            ((IList<object>)ret).Add(this.safeOrder(new Dictionary<string, object>() {
                { "info", responseOrder },
                { "id", this.safeString(responseOrder, "orderId") },
                { "status", "pending" },
            }));
        }
        return ret;
    }

    public virtual object editOrderRequest(object nonce, object id, object symbol, object type, object side, object amount = null, object price = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object market = this.market(symbol);
        object feeRate = mathMax(this.safeNumber(market, "taker"), this.safeNumber(market, "maker"));
        object message = this.orderMessage(market, nonce, feeRate, type, side, amount, price);
        object signature = this.signMessage(message, this.privateKey);
        object request = new Dictionary<string, object>() {
            { "orderId", id },
            { "nonce", nonce },
            { "updatedQuantity", this.amountToPrecision(symbol, amount) },
            { "updatedPrice", this.priceToPrecision(symbol, price) },
            { "maxFeesPercent", this.numberToString(feeRate) },
            { "signature", signature },
        };
        return this.extend(request, parameters);
    }

    /**
     * @method
     * @name hibachi#editOrder
     * @description edit a limit order that is not matched
     * @see https://api-doc.hibachi.xyz/#94d2cdaf-1c71-440f-a981-da1112824810
     * @param {string} id order id
     * @param {string} symbol unified symbol of the market to create an order in
     * @param {string} type must be 'limit'
     * @param {string} side 'buy' or 'sell', should stay the same with original side
     * @param {float} amount how much of currency you want to trade in units of base currency
     * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> editOrder(object id, object symbol, object type, object side, object amount = null, object price = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object nonce = this.nonce();
        object request = this.editOrderRequest(nonce, id, symbol, type, side, amount, price, parameters);
        ((IDictionary<string,object>)request)["accountId"] = this.getAccountId();
        await this.privatePutTradeOrder(request);
        // At this time the response body is empty. A 200 response means the update request is accepted and sent to process
        //
        // {}
        //
        return this.safeOrder(new Dictionary<string, object>() {
            { "id", id },
            { "status", "pending" },
        });
    }

    /**
     * @method
     * @name hibachi#editOrders
     * @description edit a list of trade orders
     * @see https://api-doc.hibachi.xyz/#c2840b9b-f02c-44ed-937d-dc2819f135b4
     * @param {Array} orders list of orders to edit, each object should contain the parameters required by editOrder, namely id, symbol, type, side, amount, price and params
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> editOrders(object orders, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object nonce = this.nonce();
        object requestOrders = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(orders)); postFixIncrement(ref i))
        {
            object rawOrder = getValue(orders, i);
            object id = this.safeString(rawOrder, "id");
            object symbol = this.safeString(rawOrder, "symbol");
            object type = this.safeString(rawOrder, "type");
            object side = this.safeString(rawOrder, "side");
            object amount = this.safeValue(rawOrder, "amount");
            object price = this.safeValue(rawOrder, "price");
            object orderParams = this.safeDict(rawOrder, "params", new Dictionary<string, object>() {});
            object orderRequest = this.editOrderRequest(add(nonce, i), id, symbol, type, side, amount, price, orderParams);
            ((IDictionary<string,object>)orderRequest)["action"] = "modify";
            ((IList<object>)requestOrders).Add(orderRequest);
        }
        object request = new Dictionary<string, object>() {
            { "accountId", this.getAccountId() },
            { "orders", requestOrders },
        };
        object response = await this.privatePostTradeOrders(this.extend(request, parameters));
        //
        // { "orders": [ { "orderId": "589636801329628160" } ] }
        //
        object ret = new List<object>() {};
        object responseOrders = this.safeList(response, "orders");
        for (object i = 0; isLessThan(i, getArrayLength(responseOrders)); postFixIncrement(ref i))
        {
            object responseOrder = getValue(responseOrders, i);
            ((IList<object>)ret).Add(this.safeOrder(new Dictionary<string, object>() {
                { "info", responseOrder },
                { "id", this.safeString(responseOrder, "orderId") },
                { "status", "pending" },
            }));
        }
        return ret;
    }

    public virtual object cancelOrderRequest(object id)
    {
        object bigid = this.convertToBigInt(id);
        object idbase16 = this.intToBase16(bigid);
        object idPadded = (idbase16 as String).PadLeft(Convert.ToInt32(16), Convert.ToChar("0"));
        object message = this.base16ToBinary(idPadded);
        object signature = this.signMessage(message, this.privateKey);
        return new Dictionary<string, object>() {
            { "orderId", id },
            { "signature", signature },
        };
    }

    /**
     * @method
     * @name hibachi#cancelOrder
     * @see https://api-doc.hibachi.xyz/#e99c4f48-e610-4b7c-b7f6-1b4bb7af0271
     * @description cancels an open order
     * @param {string} id order id
     * @param {string} symbol is unused
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> cancelOrder(object id, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object request = this.cancelOrderRequest(id);
        ((IDictionary<string,object>)request)["accountId"] = this.getAccountId();
        object response = await this.privateDeleteTradeOrder(this.extend(request, parameters));
        // At this time the response body is empty. A 200 response means the cancel request is accepted and sent to cancel
        //
        // {}
        //
        return this.safeOrder(new Dictionary<string, object>() {
            { "info", response },
            { "id", id },
            { "status", "canceled" },
        });
    }

    /**
     * @method
     * @name hibachi#cancelOrders
     * @description cancel multiple orders
     * @see https://api-doc.hibachi.xyz/#c2840b9b-f02c-44ed-937d-dc2819f135b4
     * @param {string[]} ids order ids
     * @param {string} [symbol] unified market symbol, unused
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} an list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async virtual Task<object> cancelOrders(object ids, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object orders = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(ids)); postFixIncrement(ref i))
        {
            object orderRequest = this.cancelOrderRequest(getValue(ids, i));
            ((IDictionary<string,object>)orderRequest)["action"] = "cancel";
            ((IList<object>)orders).Add(orderRequest);
        }
        object request = new Dictionary<string, object>() {
            { "accountId", this.getAccountId() },
            { "orders", orders },
        };
        object response = await this.privatePostTradeOrders(this.extend(request, parameters));
        //
        // { "orders": [ { "orderId": "589636801329628160" } ] }
        //
        object ret = new List<object>() {};
        object responseOrders = this.safeList(response, "orders");
        for (object i = 0; isLessThan(i, getArrayLength(responseOrders)); postFixIncrement(ref i))
        {
            object responseOrder = getValue(responseOrders, i);
            ((IList<object>)ret).Add(this.safeOrder(new Dictionary<string, object>() {
                { "info", responseOrder },
                { "id", this.safeString(responseOrder, "orderId") },
                { "status", "canceled" },
            }));
        }
        return ret;
    }

    /**
     * @method
     * @name hibachi#cancelAllOrders
     * @see https://api-doc.hibachi.xyz/#8ed24695-016e-49b2-a72d-7511ca921fee
     * @description cancel all open orders in a market
     * @param {string} symbol unified market symbol
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} an list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> cancelAllOrders(object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object nonce = this.nonce();
        object nonce16 = this.intToBase16(nonce);
        object noncePadded = (nonce16 as String).PadLeft(Convert.ToInt32(16), Convert.ToChar("0"));
        object message = this.base16ToBinary(noncePadded);
        object signature = this.signMessage(message, this.privateKey);
        object request = new Dictionary<string, object>() {
            { "accountId", this.getAccountId() },
            { "nonce", nonce },
            { "signature", signature },
        };
        if (isTrue(!isEqual(symbol, null)))
        {
            object market = this.market(symbol);
            ((IDictionary<string,object>)request)["contractId"] = this.safeInteger(market, "numericId");
        }
        object response = await this.privateDeleteTradeOrders(this.extend(request, parameters));
        // At this time the response body is empty. A 200 response means the cancel request is accepted and sent to process
        //
        // {}
        //
        return new List<object> {this.safeOrder(new Dictionary<string, object>() {
    { "info", response },
})};
    }

    public virtual object encodeWithdrawMessage(object amount, object maxFees, object address)
    {
        // Converting them to internal representation:
        // - Quantity: Internal = External * (10^6)
        // - maxFees: Internal = External * (10^6)
        // We only have USDT as our currency as this time
        object USDTAssetId = 1;
        object USDTFactor = "1000000";
        object amountStr = this.numberToString(amount);
        object maxFeesStr = this.numberToString(maxFees);
        object one = "1";
        object quantityInternal = Precise.stringDiv(Precise.stringMul(amountStr, USDTFactor), one, 0);
        object maxFeesInternal = Precise.stringDiv(Precise.stringMul(maxFeesStr, USDTFactor), one, 0);
        // Encoding
        object usdtAsset16 = this.intToBase16(USDTAssetId);
        object usdtAssetPadded = (usdtAsset16 as String).PadLeft(Convert.ToInt32(8), Convert.ToChar("0"));
        object encodedAssetId = this.base16ToBinary(usdtAssetPadded);
        object quantity16 = this.intToBase16(this.parseToInt(quantityInternal));
        object quantityPadded = (quantity16 as String).PadLeft(Convert.ToInt32(16), Convert.ToChar("0"));
        object encodedQuantity = this.base16ToBinary(quantityPadded);
        object maxFees16 = this.intToBase16(this.parseToInt(maxFeesInternal));
        object maxFeesPadded = (maxFees16 as String).PadLeft(Convert.ToInt32(16), Convert.ToChar("0"));
        object encodedMaxFees = this.base16ToBinary(maxFeesPadded);
        object encodedAddress = this.base16ToBinary(address);
        object message = this.binaryConcat(encodedAssetId, encodedQuantity, encodedMaxFees, encodedAddress);
        return message;
    }

    /**
     * @method
     * @name hibachi#withdraw
     * @description make a withdrawal
     * @see https://api-doc.hibachi.xyz/#6421625d-3e45-45fa-be9b-d2a0e780c090
     * @param {string} code unified currency code, only support USDT
     * @param {float} amount the amount to withdraw
     * @param {string} address the address to withdraw to
     * @param {string} tag
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
     */
    public async override Task<object> withdraw(object code, object amount, object address, object tag = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object withdrawAddress = slice(address, -40, null);
        // Get the withdraw fees
        object exchangeInfo = await this.publicGetMarketExchangeInfo(parameters);
        // {
        //      "feeConfig": {
        //          "depositFees": "0.004518",
        //          "tradeMakerFeeRate": "0.00000000",
        //          "tradeTakerFeeRate": "0.00020000",
        //          "transferFeeRate": "0.00010000",
        //          "withdrawalFees": "0.012050"
        //    },
        // }
        object feeConfig = this.safeDict(exchangeInfo, "feeConfig");
        object maxFees = this.safeNumber(feeConfig, "withdrawalFees");
        // Generate the signature
        object message = this.encodeWithdrawMessage(amount, maxFees, withdrawAddress);
        object signature = this.signMessage(message, this.privateKey);
        object request = new Dictionary<string, object>() {
            { "accountId", this.getAccountId() },
            { "coin", "USDT" },
            { "network", "ARBITRUM" },
            { "withdrawAddress", withdrawAddress },
            { "selfWithdrawal", false },
            { "quantity", this.numberToString(amount) },
            { "maxFees", this.numberToString(maxFees) },
            { "signature", signature },
        };
        await this.privatePostCapitalWithdraw(this.extend(request, parameters));
        // At this time the response body is empty. A 200 response means the withdraw request is accepted and sent to process
        //
        // {}
        //
        return new Dictionary<string, object>() {
            { "info", null },
            { "id", null },
            { "txid", null },
            { "timestamp", this.milliseconds() },
            { "datetime", null },
            { "address", null },
            { "addressFrom", null },
            { "addressTo", withdrawAddress },
            { "tag", null },
            { "tagFrom", null },
            { "tagTo", null },
            { "type", "withdrawal" },
            { "amount", amount },
            { "currency", code },
            { "status", "pending" },
            { "fee", new Dictionary<string, object>() {
                { "currency", "USDT" },
                { "cost", maxFees },
            } },
            { "network", "ARBITRUM" },
            { "updated", null },
            { "comment", null },
            { "internal", null },
        };
    }

    public override object nonce()
    {
        return this.milliseconds();
    }

    public virtual object signMessage(object message, object privateKey)
    {
        if (isTrue(isEqual(getArrayLength(privateKey), 44)))
        {
            // For Exchange Managed account, the key length is 44 and we use HMAC to sign the message
            return this.hmac(message, this.encode(privateKey), sha256, "hex");
        } else
        {
            // For Trustless account, the key length is 66 including '0x' and we use ECDSA to sign the message
            object hash = this.hash(this.encode(message), sha256, "hex");
            object signature = ecdsa(slice(hash, -64, null), slice(privateKey, -64, null), secp256k1, null);
            object r = getValue(signature, "r");
            object s = getValue(signature, "s");
            object v = getValue(signature, "v");
            return add(add((r as String).PadLeft(Convert.ToInt32(64), Convert.ToChar("0")), (s as String).PadLeft(Convert.ToInt32(64), Convert.ToChar("0"))), (this.intToBase16(v) as String).PadLeft(Convert.ToInt32(2), Convert.ToChar("0")));
        }
    }

    /**
     * @method
     * @name hibachi#fetchOrderBook
     * @description fetches the state of the open orders on the orderbook
     * @see https://api-doc.hibachi.xyz/#4abb30c4-e5c7-4b0f-9ade-790111dbfa47
     * @param {string} symbol unified symbol of the market
     * @param {int} [limit] currently unused
     * @param {object} [params] extra parameters to be passed -- see documentation link above
     * @returns {object} A dictionary containg [orderbook information]{@link https://docs.ccxt.com/#/?id=order-book-structure}
     */
    public async override Task<object> fetchOrderBook(object symbol, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object response = await this.publicGetMarketDataOrderbook(this.extend(request, parameters));
        object formattedResponse = new Dictionary<string, object>() {};
        ((IDictionary<string,object>)formattedResponse)["ask"] = this.safeList(this.safeDict(response, "ask"), "levels");
        ((IDictionary<string,object>)formattedResponse)["bid"] = this.safeList(this.safeDict(response, "bid"), "levels");
        // {
        //     "ask": {
        //         "endPrice": "3512.63",
        //         "levels": [
        //             {
        //                 "price": "3511.93",
        //                 "quantity": "0.284772482"
        //             },
        //             {
        //                 "price": "3512.28",
        //                 "quantity": "0.569544964"
        //             },
        //             {
        //                 "price": "3512.63",
        //                 "quantity": "0.854317446"
        //             }
        //         ],
        //         "startPrice": "3511.93"
        //     },
        //     "bid": {
        //         "endPrice": "3510.87",
        //         "levels": [
        //             {
        //                 "price": "3515.39",
        //                 "quantity": "2.345153070"
        //             },
        //             {
        //                 "price": "3511.22",
        //                 "quantity": "0.284772482"
        //             },
        //             {
        //                 "price": "3510.87",
        //                 "quantity": "0.569544964"
        //             }
        //         ],
        //         "startPrice": "3515.39"
        //     }
        // }
        return this.parseOrderBook(formattedResponse, symbol, this.milliseconds(), "bid", "ask", "price", "quantity");
    }

    /**
     * @method
     * @name hibachi#fetchMyTrades
     * @see https://api-doc.hibachi.xyz/#0adbf143-189f-40e0-afdc-88af4cba3c79
     * @description fetch all trades made by the user
     * @param {string} symbol unified market symbol
     * @param {int} [since] the earliest time in ms to fetch trades for
     * @param {int} [limit] the maximum number of trades structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
     */
    public async override Task<object> fetchMyTrades(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
        }
        object request = new Dictionary<string, object>() {
            { "accountId", this.getAccountId() },
        };
        object response = await this.privateGetTradeAccountTrades(this.extend(request, parameters));
        //
        // {
        //     "trades": [
        //         {
        //             "askAccountId": 221,
        //             "askOrderId": 589168494921909200,
        //             "bidAccountId": 132,
        //             "bidOrderId": 589168494829895700,
        //             "fee": "0.000477",
        //             "id": 199511136,
        //             "orderType": "MARKET",
        //             "price": "119257.90000",
        //             "quantity": "0.0000200000",
        //             "realizedPnl": "-0.000352",
        //             "side": "Sell",
        //             "symbol": "BTC/USDT-P",
        //             "timestamp": 1752543391
        //         }
        //     ]
        // }
        //
        object trades = this.safeList(response, "trades");
        return this.parseTrades(trades, market, since, limit, parameters);
    }

    public override object parseOHLCV(object ohlcv, object market = null)
    {
        //
        // [
        //     {
        //       "close": "3704.751036",
        //       "high": "3716.530378",
        //       "interval": "1h",
        //       "low": "3699.627883",
        //       "open": "3716.406894",
        //       "timestamp": 1712628000,
        //       "volumeNotional": "1637355.846362"
        //     }
        //   ]
        //
        return new List<object> {this.safeIntegerProduct(ohlcv, "timestamp", 1000), this.safeNumber(ohlcv, "open"), this.safeNumber(ohlcv, "high"), this.safeNumber(ohlcv, "low"), this.safeNumber(ohlcv, "close"), this.safeNumber(ohlcv, "volumeNotional")};
    }

    /**
     * @method
     * @name hibachi#fetchOpenOrders
     * @description fetches all current open orders
     * @see https://api-doc.hibachi.xyz/#3243f8a0-086c-44c5-ab8a-71bbb7bab403
     * @param {string} [symbol] unified market symbol to filter by
     * @param {int} [since] milisecond timestamp of the earliest order
     * @param {int} [limit] the maximum number of open orders to return
     * @param {object} [params] extra parameters
     * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> fetchOpenOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
        }
        object request = new Dictionary<string, object>() {
            { "accountId", this.getAccountId() },
        };
        object response = await this.privateGetTradeOrders(this.extend(request, parameters));
        // [
        //     {
        //         "accountId": 12452,
        //         "availableQuantity": "0.0000230769",
        //         "contractId": 2,
        //         "creationTime": 1752684501,
        //         "orderId": "589205486123876352",
        //         "orderType": "LIMIT",
        //         "price": "130000.00000",
        //         "side": "ASK",
        //         "status": "PLACED",
        //         "symbol": "BTC/USDT-P",
        //         "totalQuantity": "0.0000230769"
        //     },
        //     {
        //         "accountId": 12452,
        //         "availableQuantity": "1.234000000",
        //         "contractId": 1,
        //         "creationTime": 1752240682,
        //         "orderId": "589089141754429441",
        //         "orderType": "LIMIT",
        //         "price": "1.234000",
        //         "side": "BID",
        //         "status": "PLACED",
        //         "symbol": "ETH/USDT-P",
        //         "totalQuantity": "1.234000000"
        //     }
        // ]
        return this.parseOrders(response, market, since, limit);
    }

    /**
     * @name hibachi#fetchOHLCV
     * @see  https://api-doc.hibachi.xyz/#4f0eacec-c61e-4d51-afb3-23c51c2c6bac
     * @description fetches historical candlestick data containing the close, high, low, open prices, interval and the volumeNotional
     * @param {string} symbol unified symbol of the market to fetch OHLCV data for
     * @param {string} timeframe the length of time each candle represents
     * @param {int} [since] timestamp in ms of the earliest candle to fetch
     * @param {int} [limit] the maximum amount of candles to fetch
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {int} [params.until] timestamp in ms of the latest candle to fetch
     * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
     */
    public async override Task<object> fetchOHLCV(object symbol, object timeframe = null, object since = null, object limit = null, object parameters = null)
    {
        timeframe ??= "1m";
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        timeframe = this.safeString(this.timeframes, timeframe, timeframe);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
            { "interval", timeframe },
        };
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["fromMs"] = since;
        }
        object until = null;
        var untilparametersVariable = this.handleOptionAndParams(parameters, "fetchOHLCV", "until");
        until = ((IList<object>)untilparametersVariable)[0];
        parameters = ((IList<object>)untilparametersVariable)[1];
        if (isTrue(!isEqual(until, null)))
        {
            ((IDictionary<string,object>)request)["toMs"] = until;
        }
        object response = await this.publicGetMarketDataKlines(this.extend(request, parameters));
        //
        // [
        //     {
        //       "close": "3704.751036",
        //       "high": "3716.530378",
        //       "interval": "1h",
        //       "low": "3699.627883",
        //       "open": "3716.406894",
        //       "timestamp": 1712628000,
        //       "volumeNotional": "1637355.846362"
        //     }
        //   ]
        //
        object klines = this.safeList(response, "klines", new List<object>() {});
        return this.parseOHLCVs(klines, market, timeframe, since, limit);
    }

    /**
     * @method
     * @name hibachi#fetchPositions
     * @description fetch all open positions
     * @see https://api-doc.hibachi.xyz/#69aafedb-8274-4e21-bbaf-91dace8b8f31
     * @param {string[]} [symbols] list of unified market symbols
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} a list of [position structure]{@link https://docs.ccxt.com/#/?id=position-structure}
     */
    public async override Task<object> fetchPositions(object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        symbols = this.marketSymbols(symbols);
        object request = new Dictionary<string, object>() {
            { "accountId", this.getAccountId() },
        };
        object response = await this.privateGetTradeAccountInfo(this.extend(request, parameters));
        //
        // {
        //     "assets": [
        //       {
        //         "quantity": "14.130626",
        //         "symbol": "USDT"
        //       }
        //     ],
        //     "balance": "14.186087",
        //     "maximalWithdraw": "4.152340",
        //     "numFreeTransfersRemaining": 96,
        //     "positions": [
        //       {
        //         "direction": "Short",
        //         "entryNotional": "10.302213",
        //         "notionalValue": "10.225008",
        //         "quantity": "0.004310550",
        //         "symbol": "ETH/USDT-P",
        //         "unrealizedFundingPnl": "0.000000",
        //         "unrealizedTradingPnl": "0.077204"
        //       },
        //       {
        //         "direction": "Short",
        //         "entryNotional": "2.000016",
        //         "notionalValue": "1.999390",
        //         "quantity": "0.0000328410",
        //         "symbol": "BTC/USDT-P",
        //         "unrealizedFundingPnl": "0.000000",
        //         "unrealizedTradingPnl": "0.000625"
        //       },
        //       {
        //         "direction": "Short",
        //         "entryNotional": "2.000015",
        //         "notionalValue": "2.022384",
        //         "quantity": "0.01470600",
        //         "symbol": "SOL/USDT-P",
        //         "unrealizedFundingPnl": "0.000000",
        //         "unrealizedTradingPnl": "-0.022369"
        //       }
        //     ],
        //   }
        //
        object data = this.safeList(response, "positions", new List<object>() {});
        return this.parsePositions(data, symbols);
    }

    public override object parsePosition(object position, object market = null)
    {
        //
        // {
        //     "direction": "Short",
        //     "entryNotional": "10.302213",
        //     "notionalValue": "10.225008",
        //     "quantity": "0.004310550",
        //     "symbol": "ETH/USDT-P",
        //     "unrealizedFundingPnl": "0.000000",
        //     "unrealizedTradingPnl": "0.077204"
        // }
        //
        object marketId = this.safeString(position, "symbol");
        market = this.safeMarket(marketId, market);
        object symbol = getValue(market, "symbol");
        object side = this.safeStringLower(position, "direction");
        object quantity = this.safeString(position, "quantity");
        object unrealizedFunding = this.safeString(position, "unrealizedFundingPnl", "0");
        object unrealizedTrading = this.safeString(position, "unrealizedTradingPnl", "0");
        object unrealizedPnl = Precise.stringAdd(unrealizedFunding, unrealizedTrading);
        return this.safePosition(new Dictionary<string, object>() {
            { "info", position },
            { "id", null },
            { "symbol", symbol },
            { "entryPrice", this.safeString(position, "average_entry_price") },
            { "markPrice", null },
            { "notional", this.safeString(position, "notionalValue") },
            { "collateral", null },
            { "unrealizedPnl", unrealizedPnl },
            { "side", side },
            { "contracts", this.parseNumber(quantity) },
            { "contractSize", null },
            { "timestamp", null },
            { "datetime", null },
            { "hedged", null },
            { "maintenanceMargin", null },
            { "maintenanceMarginPercentage", null },
            { "initialMargin", null },
            { "initialMarginPercentage", null },
            { "leverage", null },
            { "liquidationPrice", null },
            { "marginRatio", null },
            { "marginMode", null },
            { "percentage", null },
        });
    }

    public override object sign(object path, object api = null, object method = null, object parameters = null, object headers = null, object body = null)
    {
        api ??= "public";
        method ??= "GET";
        parameters ??= new Dictionary<string, object>();
        object endpoint = add("/", this.implodeParams(path, parameters));
        object url = add(getValue(getValue(this.urls, "api"), api), endpoint);
        headers = new Dictionary<string, object>() {};
        if (isTrue(isEqual(method, "GET")))
        {
            object request = this.omit(parameters, this.extractParams(path));
            object query = this.urlencode(request);
            if (isTrue(!isEqual(getArrayLength(query), 0)))
            {
                url = add(url, add("?", query));
            }
        }
        if (isTrue(isTrue(isTrue(isEqual(method, "POST")) || isTrue(isEqual(method, "PUT"))) || isTrue(isEqual(method, "DELETE"))))
        {
            ((IDictionary<string,object>)headers)["Content-Type"] = "application/json";
            body = this.json(parameters);
        }
        if (isTrue(isEqual(api, "private")))
        {
            this.checkRequiredCredentials();
            ((IDictionary<string,object>)headers)["Authorization"] = this.apiKey;
        }
        return new Dictionary<string, object>() {
            { "url", url },
            { "method", method },
            { "body", body },
            { "headers", headers },
        };
    }

    public override object handleErrors(object httpCode, object reason, object url, object method, object headers, object body, object response, object requestHeaders, object requestBody)
    {
        if (isTrue(isEqual(response, null)))
        {
            return null;  // fallback to default error handler
        }
        if (isTrue(inOp(response, "status")))
        {
            //
            //     {"errorCode":4,"message":"Invalid input: Invalid quantity: 0","status":"failed"}
            //
            object status = this.safeString(response, "status");
            if (isTrue(isEqual(status, "failed")))
            {
                object code = this.safeString(response, "errorCode");
                object feedback = add(add(this.id, " "), body);
                this.throwBroadlyMatchedException(getValue(this.exceptions, "broad"), body, feedback);
                this.throwExactlyMatchedException(getValue(this.exceptions, "exact"), code, feedback);
                object message = this.safeString(response, "message");
                this.throwExactlyMatchedException(getValue(this.exceptions, "exact"), message, feedback);
                throw new ExchangeError ((string)feedback) ;
            }
        }
        return null;
    }

    public virtual object parseTransactionType(object type)
    {
        object types = new Dictionary<string, object>() {
            { "deposit", "transaction" },
            { "withdrawal", "transaction" },
            { "transfer-in", "transfer" },
            { "transfer-out", "transfer" },
        };
        return this.safeString(types, type, type);
    }

    public virtual object parseTransactionStatus(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "pending", "pending" },
            { "claimable", "pending" },
            { "completed", "ok" },
            { "failed", "canceled" },
        };
        return this.safeString(statuses, status, status);
    }

    public override object parseLedgerEntry(object item, object currency = null)
    {
        object transactionType = this.safeString(item, "transactionType");
        object timestamp = null;
        object type = null;
        object direction = null;
        object amount = null;
        object fee = null;
        object referenceId = null;
        object referenceAccount = null;
        object status = null;
        if (isTrue(isEqual(transactionType, null)))
        {
            // response from TradeAccountTradingHistory
            timestamp = this.safeIntegerProduct(item, "timestamp", 1000);
            type = "trade";
            object amountStr = this.safeString(item, "realizedPnl");
            if (isTrue(Precise.stringLt(amountStr, "0")))
            {
                direction = "out";
                amountStr = Precise.stringNeg(amountStr);
            } else
            {
                direction = "in";
            }
            amount = this.parseNumber(amountStr);
            fee = new Dictionary<string, object>() {
                { "currency", "USDT" },
                { "cost", this.safeNumber(item, "fee") },
            };
            status = "ok";
        } else
        {
            // response from CapitalHistory
            timestamp = this.safeIntegerProduct(item, "timestampSec", 1000);
            amount = this.safeNumber(item, "quantity");
            direction = ((bool) isTrue((isTrue(isEqual(transactionType, "deposit")) || isTrue(isEqual(transactionType, "transfer-in"))))) ? "in" : "out";
            type = this.parseTransactionType(transactionType);
            status = this.parseTransactionStatus(this.safeString(item, "status"));
            if (isTrue(isEqual(transactionType, "transfer-in")))
            {
                referenceAccount = this.safeString(item, "srcAccountId");
            } else if (isTrue(isEqual(transactionType, "transfer-out")))
            {
                referenceAccount = this.safeString(item, "receivingAccountId");
            }
            referenceId = this.safeString(item, "transactionHash");
        }
        return this.safeLedgerEntry(new Dictionary<string, object>() {
            { "id", this.safeString(item, "id") },
            { "currency", this.currency("USDT") },
            { "account", this.numberToString(this.accountId) },
            { "referenceAccount", referenceAccount },
            { "referenceId", referenceId },
            { "status", status },
            { "amount", amount },
            { "before", null },
            { "after", null },
            { "fee", fee },
            { "direction", direction },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "type", type },
            { "info", item },
        }, currency);
    }

    /**
     * @method
     * @name hibachi#fetchLedger
     * @description fetch the history of changes, actions done by the user or operations that altered the balance of the user
     * @see https://api-doc.hibachi.xyz/#35125e3f-d154-4bfd-8276-a48bb1c62020
     * @param {string} [code] unified currency code, default is undefined
     * @param {int} [since] timestamp in ms of the earliest ledger entry, default is undefined
     * @param {int} [limit] max number of ledger entries to return, default is undefined
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [ledger structure]{@link https://docs.ccxt.com/#/?id=ledger}
     */
    public async override Task<object> fetchLedger(object code = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency("USDT");
        object request = new Dictionary<string, object>() {
            { "accountId", this.getAccountId() },
        };
        object rawPromises = new List<object> {this.privateGetCapitalHistory(this.extend(request, parameters)), this.privateGetTradeAccountTradingHistory(this.extend(request, parameters))};
        object promises = await promiseAll(rawPromises);
        object responseCapitalHistory = getValue(promises, 0);
        //
        // {
        //     "transactions": [
        //         {
        //             "assetId": 1,
        //             "blockNumber": 358396669,
        //             "chain": "Arbitrum",
        //             "etaTsSec": null,
        //             "id": 358396669,
        //             "quantity": "0.999500",
        //             "status": "pending",
        //             "timestampSec": 1752692872,
        //             "token": "USDT",
        //             "transactionHash": "0x408e48881e0ba77d8638e3fe57bc06bdec513ddaa8b672e0aefa7e22e2f18b5e",
        //             "transactionType": "deposit"
        //         },
        //         {
        //             "assetId": 1,
        //             "etaTsSec": null,
        //             "id": 13116,
        //             "instantWithdrawalChain": null,
        //             "instantWithdrawalToken": null,
        //             "isInstantWithdrawal": false,
        //             "quantity": "0.040000",
        //             "status": "completed",
        //             "timestampSec": 1752542708,
        //             "transactionHash": "0xe89cf90b2408d1a273dc9427654145def102d9449e5e2cfc10690ccffc3d7e28",
        //             "transactionType": "withdrawal",
        //             "withdrawalAddress": "0x23625d5fc6a6e32638d908eb4c3a3415e5121f76"
        //         },
        //         {
        //             "assetId": 1,
        //             "id": 167,
        //             "quantity": "10.000000",
        //             "srcAccountId": 175,
        //             "srcAddress": "0xc2f77ce029438a3fdfe68ddee25991a9fb985a86",
        //             "status": "completed",
        //             "timestampSec": 1732224729,
        //             "transactionType": "transfer-in"
        //         },
        //         {
        //             "assetId": 1,
        //             "id": 170,
        //             "quantity": "10.000000",
        //             "receivingAccountId": 175,
        //             "receivingAddress": "0xc2f77ce029438a3fdfe68ddee25991a9fb985a86",
        //             "status": "completed",
        //             "timestampSec": 1732225631,
        //             "transactionType": "transfer-out"
        //         },
        //     ]
        // }
        //
        object rowsCapitalHistory = this.safeList(responseCapitalHistory, "transactions");
        object responseTradingHistory = getValue(promises, 1);
        //
        // {
        //     "tradingHistory": [
        //         {
        //             "eventType": "MARKET",
        //             "fee": "0.000008",
        //             "priceOrFundingRate": "119687.82481",
        //             "quantity": "0.0000003727",
        //             "realizedPnl": "0.004634",
        //             "side": "Sell",
        //             "symbol": "BTC/USDT-P",
        //             "timestamp": 1752522571
        //         },
        //         {
        //             "eventType": "FundingEvent",
        //             "fee": "0",
        //             "priceOrFundingRate": "0.000203",
        //             "quantity": "0.0000003727",
        //             "realizedPnl": "-0.000009067899008751979",
        //             "side": "Long",
        //             "symbol": "BTC/USDT-P",
        //             "timestamp": 1752508800
        //         },
        //     ]
        // }
        //
        object rowsTradingHistory = this.safeList(responseTradingHistory, "tradingHistory");
        object rows = this.arrayConcat(rowsCapitalHistory, rowsTradingHistory);
        return this.parseLedger(rows, currency, since, limit, parameters);
    }

    /**
     * @method
     * @name hibachi#fetchDepositAddress
     * @description fetch deposit address for given currency and chain. currently, we have a single EVM address across multiple EVM chains. Note: This method is currently only supported for trustless accounts
     * @param {string} code unified currency code
     * @param {object} [params] extra parameters for API
     * @param {string} [params.publicKey] your public key, you can get it from UI after creating API key
     * @returns {object} an [address structure]{@link https://docs.ccxt.com/#/?id=address-structure}
     */
    public async override Task<object> fetchDepositAddress(object code, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object request = new Dictionary<string, object>() {
            { "publicKey", this.safeString(parameters, "publicKey") },
            { "accountId", this.getAccountId() },
        };
        object response = await this.privateGetCapitalDepositInfo(this.extend(request, parameters));
        // {
        //     "depositAddressEvm": "0x0b95d90b9345dadf1460bd38b9f4bb0d2f4ed788"
        // }
        return new Dictionary<string, object>() {
            { "info", response },
            { "currency", "USDT" },
            { "network", "ARBITRUM" },
            { "address", this.safeString(response, "depositAddressEvm") },
            { "tag", null },
        };
    }

    public override object parseTransaction(object transaction, object currency = null)
    {
        object timestamp = this.safeIntegerProduct(transaction, "timestampSec", 1000);
        object address = this.safeString(transaction, "withdrawalAddress");
        object transactionType = this.safeString(transaction, "transactionType");
        if (isTrue(isTrue(!isEqual(transactionType, "deposit")) && isTrue(!isEqual(transactionType, "withdrawal"))))
        {
            transactionType = this.parseTransactionType(transactionType);
        }
        return new Dictionary<string, object>() {
            { "info", transaction },
            { "id", this.safeString(transaction, "id") },
            { "txid", this.safeString(transaction, "transactionHash") },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "network", "ARBITRUM" },
            { "address", address },
            { "addressTo", address },
            { "addressFrom", null },
            { "tag", null },
            { "tagTo", null },
            { "tagFrom", null },
            { "type", transactionType },
            { "amount", this.safeNumber(transaction, "quantity") },
            { "currency", "USDT" },
            { "status", this.parseTransactionStatus(this.safeString(transaction, "status")) },
            { "updated", null },
            { "internal", null },
            { "comment", null },
            { "fee", null },
        };
    }

    /**
     * @method
     * @name hibachi#fetchDeposits
     * @description fetch deposits made to account
     * @see https://api-doc.hibachi.xyz/#35125e3f-d154-4bfd-8276-a48bb1c62020
     * @param {string} [code] unified currency code
     * @param {int} [since] filter by earliest timestamp (ms)
     * @param {int} [limit] maximum number of deposits to be returned
     * @param {object} [params] extra parameters to be passed to API
     * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
     */
    public async override Task<object> fetchDeposits(object code = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object currency = this.safeCurrency(code);
        object request = new Dictionary<string, object>() {
            { "accountId", this.getAccountId() },
        };
        object response = await this.privateGetCapitalHistory(this.extend(request, parameters));
        // {
        //     "transactions": [
        //         {
        //             "assetId": 1,
        //             "blockNumber": 0,
        //             "chain": null,
        //             "etaTsSec": 1752758789,
        //             "id": 42688,
        //             "quantity": "6.130000",
        //             "status": "completed",
        //             "timestampSec": 1752758788,
        //             "token": null,
        //             "transactionHash": "0x8dcd7bd1155b5624fb5e38a1365888f712ec633a57434340e05080c70b0e3bba",
        //             "transactionType": "deposit"
        //         },
        //         {
        //             "assetId": 1,
        //             "etaTsSec": null,
        //             "id": 12993,
        //             "instantWithdrawalChain": null,
        //             "instantWithdrawalToken": null,
        //             "isInstantWithdrawal": false,
        //             "quantity": "0.111930",
        //             "status": "completed",
        //             "timestampSec": 1752387891,
        //             "transactionHash": "0x32ab5fe5b90f6d753bab83523ebc8465eb9daef54580e13cb9ff031d400c5620",
        //             "transactionType": "withdrawal",
        //             "withdrawalAddress": "0x43f15ef2ef2ab5e61e987ee3d652a5872aea8a6c"
        //         },
        //     ]
        // }
        object transactions = this.safeList(response, "transactions");
        object deposits = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(transactions)); postFixIncrement(ref i))
        {
            object transaction = getValue(transactions, i);
            if (isTrue(isEqual(this.safeString(transaction, "transactionType"), "deposit")))
            {
                ((IList<object>)deposits).Add(transaction);
            }
        }
        return this.parseTransactions(deposits, currency, since, limit, parameters);
    }

    /**
     * @method
     * @name hibachi#fetchWithdrawals
     * @description fetch withdrawals made from account
     * @see https://api-doc.hibachi.xyz/#35125e3f-d154-4bfd-8276-a48bb1c62020
     * @param {string} [code] unified currency code
     * @param {int} [since] filter by earliest timestamp (ms)
     * @param {int} [limit] maximum number of deposits to be returned
     * @param {object} [params] extra parameters to be passed to API
     * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
     */
    public async override Task<object> fetchWithdrawals(object code = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object currency = this.safeCurrency(code);
        object request = new Dictionary<string, object>() {
            { "accountId", this.getAccountId() },
        };
        object response = await this.privateGetCapitalHistory(this.extend(request, parameters));
        // {
        //     "transactions": [
        //         {
        //             "assetId": 1,
        //             "blockNumber": 0,
        //             "chain": null,
        //             "etaTsSec": 1752758789,
        //             "id": 42688,
        //             "quantity": "6.130000",
        //             "status": "completed",
        //             "timestampSec": 1752758788,
        //             "token": null,
        //             "transactionHash": "0x8dcd7bd1155b5624fb5e38a1365888f712ec633a57434340e05080c70b0e3bba",
        //             "transactionType": "deposit"
        //         },
        //         {
        //             "assetId": 1,
        //             "etaTsSec": null,
        //             "id": 12993,
        //             "instantWithdrawalChain": null,
        //             "instantWithdrawalToken": null,
        //             "isInstantWithdrawal": false,
        //             "quantity": "0.111930",
        //             "status": "completed",
        //             "timestampSec": 1752387891,
        //             "transactionHash": "0x32ab5fe5b90f6d753bab83523ebc8465eb9daef54580e13cb9ff031d400c5620",
        //             "transactionType": "withdrawal",
        //             "withdrawalAddress": "0x43f15ef2ef2ab5e61e987ee3d652a5872aea8a6c"
        //         },
        //     ]
        // }
        object transactions = this.safeList(response, "transactions");
        object withdrawals = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(transactions)); postFixIncrement(ref i))
        {
            object transaction = getValue(transactions, i);
            if (isTrue(isEqual(this.safeString(transaction, "transactionType"), "withdrawal")))
            {
                ((IList<object>)withdrawals).Add(transaction);
            }
        }
        return this.parseTransactions(withdrawals, currency, since, limit, parameters);
    }

    /**
     * @method
     * @name hibachi#fetchTime
     * @description fetches the current integer timestamp in milliseconds from the exchange server
     * @see http://api-doc.hibachi.xyz/#b5c6a3bc-243d-4d35-b6d4-a74c92495434
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {int} the current integer timestamp in milliseconds from the exchange server
     */
    public async override Task<object> fetchTime(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object response = await this.publicGetExchangeUtcTimestamp(parameters);
        //
        //     { "timestampMs":1754077574040 }
        //
        return this.safeInteger(response, "timestampMs");
    }

    /**
     * @method
     * @name hibachi#fetchOpenInterest
     * @description retrieves the open interest of a contract trading pair
     * @see https://api-doc.hibachi.xyz/#bc34e8ae-e094-4802-8d56-3efe3a7bad49
     * @param {string} symbol unified CCXT market symbol
     * @param {object} [params] exchange specific parameters
     * @returns {object} an open interest structure{@link https://docs.ccxt.com/#/?id=open-interest-structure}
     */
    public async override Task<object> fetchOpenInterest(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object response = await this.publicGetMarketDataOpenInterest(this.extend(request, parameters));
        //
        //   { "totalQuantity" : "2.3299770166" }
        //
        object timestamp = this.milliseconds();
        return this.safeOpenInterest(new Dictionary<string, object>() {
            { "symbol", symbol },
            { "openInterestAmount", this.safeString(response, "totalQuantity") },
            { "openInterestValue", null },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "info", response },
        }, market);
    }

    /**
     * @method
     * @name hibachi#fetchFundingRate
     * @description fetch the current funding rate
     * @see https://api-doc.hibachi.xyz/#bca696ca-b9b2-4072-8864-5d6b8c09807e
     * @param {string} symbol unified market symbol
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [funding rate structure]{@link https://docs.ccxt.com/#/?id=funding-rate-structure}
     */
    public async override Task<object> fetchFundingRate(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object response = await this.publicGetMarketDataPrices(this.extend(request, parameters));
        //
        // {
        //     "askPrice": "3514.650296",
        //     "bidPrice": "3513.596112",
        //     "fundingRateEstimation": {
        //         "estimatedFundingRate": "0.000001",
        //         "nextFundingTimestamp": 1712707200
        //     },
        //     "markPrice": "3514.288858",
        //     "spotPrice": "3514.715000",
        //     "symbol": "ETH/USDT-P",
        //     "tradePrice": "2372.746570"
        // }
        //
        object funding = this.safeDict(response, "fundingRateEstimation", new Dictionary<string, object>() {});
        object timestamp = this.milliseconds();
        object nextFundingTimestamp = this.safeIntegerProduct(funding, "nextFundingTimestamp", 1000);
        return new Dictionary<string, object>() {
            { "info", funding },
            { "symbol", getValue(market, "symbol") },
            { "markPrice", null },
            { "indexPrice", null },
            { "interestRate", this.parseNumber("0") },
            { "estimatedSettlePrice", null },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "fundingRate", this.safeNumber(funding, "estimatedFundingRate") },
            { "fundingTimestamp", nextFundingTimestamp },
            { "fundingDatetime", this.iso8601(nextFundingTimestamp) },
            { "nextFundingRate", null },
            { "nextFundingTimestamp", null },
            { "nextFundingDatetime", null },
            { "previousFundingRate", null },
            { "previousFundingTimestamp", null },
            { "previousFundingDatetime", null },
            { "interval", "8h" },
        };
    }

    /**
     * @method
     * @name hibachi#fetchFundingRateHistory
     * @description fetches historical funding rate prices
     * @see https://api-doc.hibachi.xyz/#4abb30c4-e5c7-4b0f-9ade-790111dbfa47
     * @param {string} symbol unified symbol of the market to fetch the funding rate history for
     * @param {int} [since] timestamp in ms of the earliest funding rate to fetch
     * @param {int} [limit] the maximum amount of [funding rate structures]{@link https://docs.ccxt.com/#/?id=funding-rate-history-structure} to fetch
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} a list of [funding rate structures]{@link https://docs.ccxt.com/#/?id=funding-rate-history-structure}
     */
    public async override Task<object> fetchFundingRateHistory(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object response = await this.publicGetMarketDataFundingRates(this.extend(request, parameters));
        //
        // {
        //     "data": [
        //         {
        //             "contractId": 2,
        //             "fundingTimestamp": 1753488000,
        //             "fundingRate": "0.000137",
        //             "indexPrice": "117623.65010"
        //         }
        //     ]
        // }
        //
        object data = this.safeList(response, "data");
        object rates = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
        {
            object entry = getValue(data, i);
            object timestamp = this.safeIntegerProduct(entry, "fundingTimestamp", 1000);
            ((IList<object>)rates).Add(new Dictionary<string, object>() {
                { "info", entry },
                { "symbol", symbol },
                { "fundingRate", this.safeNumber(entry, "fundingRate") },
                { "timestamp", timestamp },
                { "datetime", this.iso8601(timestamp) },
            });
        }
        object sorted = this.sortBy(rates, "timestamp");
        return this.filterBySymbolSinceLimit(sorted, symbol, since, limit);
    }
}
