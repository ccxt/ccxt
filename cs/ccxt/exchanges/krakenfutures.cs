namespace ccxt;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

public partial class krakenfutures : Exchange
{
    public override object describe()
    {
        return this.deepExtend(base.describe(), new Dictionary<string, object>() {
            { "id", "krakenfutures" },
            { "name", "Kraken Futures" },
            { "countries", new List<object>() {"US"} },
            { "version", "v3" },
            { "userAgent", null },
            { "rateLimit", 600 },
            { "pro", true },
            { "has", new Dictionary<string, object>() {
                { "CORS", null },
                { "spot", false },
                { "margin", false },
                { "swap", true },
                { "future", true },
                { "option", false },
                { "cancelAllOrders", true },
                { "cancelAllOrdersAfter", true },
                { "cancelOrder", true },
                { "cancelOrders", true },
                { "createMarketOrder", true },
                { "createOrder", true },
                { "createPostOnlyOrder", true },
                { "createReduceOnlyOrder", true },
                { "createStopLimitOrder", true },
                { "createStopMarketOrder", true },
                { "createStopOrder", true },
                { "createTriggerOrder", true },
                { "editOrder", true },
                { "fetchBalance", true },
                { "fetchBorrowRateHistories", false },
                { "fetchBorrowRateHistory", false },
                { "fetchCanceledOrders", true },
                { "fetchClosedOrders", true },
                { "fetchCrossBorrowRate", false },
                { "fetchCrossBorrowRates", false },
                { "fetchCurrencies", false },
                { "fetchDepositAddress", false },
                { "fetchDepositAddresses", false },
                { "fetchDepositAddressesByNetwork", false },
                { "fetchFundingHistory", null },
                { "fetchFundingRate", "emulated" },
                { "fetchFundingRateHistory", true },
                { "fetchFundingRates", true },
                { "fetchIndexOHLCV", false },
                { "fetchIsolatedBorrowRate", false },
                { "fetchIsolatedBorrowRates", false },
                { "fetchIsolatedPositions", false },
                { "fetchLeverage", true },
                { "fetchLeverages", true },
                { "fetchLeverageTiers", true },
                { "fetchMarketLeverageTiers", "emulated" },
                { "fetchMarkets", true },
                { "fetchMarkOHLCV", true },
                { "fetchMyTrades", true },
                { "fetchOHLCV", true },
                { "fetchOpenOrders", true },
                { "fetchOrder", true },
                { "fetchOrderBook", true },
                { "fetchOrders", true },
                { "fetchPositions", true },
                { "fetchPremiumIndexOHLCV", false },
                { "fetchTickers", true },
                { "fetchTrades", true },
                { "sandbox", true },
                { "setLeverage", true },
                { "setMarginMode", false },
                { "transfer", true },
            } },
            { "urls", new Dictionary<string, object>() {
                { "test", new Dictionary<string, object>() {
                    { "public", "https://demo-futures.kraken.com/derivatives/api/" },
                    { "private", "https://demo-futures.kraken.com/derivatives/api/" },
                    { "charts", "https://demo-futures.kraken.com/api/charts/" },
                    { "history", "https://demo-futures.kraken.com/api/history/" },
                    { "www", "https://demo-futures.kraken.com" },
                } },
                { "logo", "https://user-images.githubusercontent.com/24300605/81436764-b22fd580-9172-11ea-9703-742783e6376d.jpg" },
                { "api", new Dictionary<string, object>() {
                    { "charts", "https://futures.kraken.com/api/charts/" },
                    { "history", "https://futures.kraken.com/api/history/" },
                    { "feeschedules", "https://futures.kraken.com/api/feeschedules/" },
                    { "public", "https://futures.kraken.com/derivatives/api/" },
                    { "private", "https://futures.kraken.com/derivatives/api/" },
                } },
                { "www", "https://futures.kraken.com/" },
                { "doc", new List<object>() {"https://docs.kraken.com/api/docs/futures-api/trading/market-data/"} },
                { "fees", "https://support.kraken.com/hc/en-us/articles/360022835771-Transaction-fees-and-rebates-for-Kraken-Futures" },
                { "referral", null },
            } },
            { "api", new Dictionary<string, object>() {
                { "public", new Dictionary<string, object>() {
                    { "get", new List<object>() {"feeschedules", "instruments", "orderbook", "tickers", "history", "historicalfundingrates"} },
                } },
                { "private", new Dictionary<string, object>() {
                    { "get", new List<object>() {"feeschedules/volumes", "openpositions", "notifications", "accounts", "openorders", "recentorders", "fills", "transfers", "leveragepreferences", "pnlpreferences", "assignmentprogram/current", "assignmentprogram/history", "orders/status"} },
                    { "post", new List<object>() {"sendorder", "editorder", "cancelorder", "transfer", "batchorder", "cancelallorders", "cancelallordersafter", "withdrawal", "assignmentprogram/add", "assignmentprogram/delete"} },
                    { "put", new List<object>() {"leveragepreferences", "pnlpreferences"} },
                } },
                { "charts", new Dictionary<string, object>() {
                    { "get", new List<object>() {"{price_type}/{symbol}/{interval}"} },
                } },
                { "history", new Dictionary<string, object>() {
                    { "get", new List<object>() {"orders", "executions", "triggers", "accountlogcsv", "account-log", "market/{symbol}/orders", "market/{symbol}/executions"} },
                } },
            } },
            { "fees", new Dictionary<string, object>() {
                { "trading", new Dictionary<string, object>() {
                    { "tierBased", true },
                    { "percentage", true },
                    { "taker", this.parseNumber("0.0005") },
                    { "maker", this.parseNumber("0.0002") },
                    { "tiers", new Dictionary<string, object>() {
                        { "taker", new List<object>() {new List<object> {this.parseNumber("0"), this.parseNumber("0.0005")}, new List<object> {this.parseNumber("100000"), this.parseNumber("0.0004")}, new List<object> {this.parseNumber("1000000"), this.parseNumber("0.0003")}, new List<object> {this.parseNumber("5000000"), this.parseNumber("0.00025")}, new List<object> {this.parseNumber("10000000"), this.parseNumber("0.0002")}, new List<object> {this.parseNumber("20000000"), this.parseNumber("0.00015")}, new List<object> {this.parseNumber("50000000"), this.parseNumber("0.000125")}, new List<object> {this.parseNumber("100000000"), this.parseNumber("0.0001")}} },
                        { "maker", new List<object>() {new List<object> {this.parseNumber("0"), this.parseNumber("0.0002")}, new List<object> {this.parseNumber("100000"), this.parseNumber("0.0015")}, new List<object> {this.parseNumber("1000000"), this.parseNumber("0.000125")}, new List<object> {this.parseNumber("5000000"), this.parseNumber("0.0001")}, new List<object> {this.parseNumber("10000000"), this.parseNumber("0.000075")}, new List<object> {this.parseNumber("20000000"), this.parseNumber("0.00005")}, new List<object> {this.parseNumber("50000000"), this.parseNumber("0.000025")}, new List<object> {this.parseNumber("100000000"), this.parseNumber("0")}} },
                    } },
                } },
            } },
            { "exceptions", new Dictionary<string, object>() {
                { "exact", new Dictionary<string, object>() {
                    { "apiLimitExceeded", typeof(RateLimitExceeded) },
                    { "marketUnavailable", typeof(ContractUnavailable) },
                    { "requiredArgumentMissing", typeof(BadRequest) },
                    { "unavailable", typeof(ExchangeNotAvailable) },
                    { "authenticationError", typeof(AuthenticationError) },
                    { "accountInactive", typeof(ExchangeError) },
                    { "invalidAccount", typeof(BadRequest) },
                    { "invalidAmount", typeof(BadRequest) },
                    { "insufficientFunds", typeof(InsufficientFunds) },
                    { "Bad Request", typeof(BadRequest) },
                    { "Unavailable", typeof(ExchangeNotAvailable) },
                    { "invalidUnit", typeof(BadRequest) },
                    { "Json Parse Error", typeof(ExchangeError) },
                    { "nonceBelowThreshold", typeof(InvalidNonce) },
                    { "nonceDuplicate", typeof(InvalidNonce) },
                    { "notFound", typeof(BadRequest) },
                    { "Server Error", typeof(ExchangeError) },
                    { "unknownError", typeof(ExchangeError) },
                } },
                { "broad", new Dictionary<string, object>() {
                    { "invalidArgument", typeof(BadRequest) },
                    { "nonceBelowThreshold", typeof(InvalidNonce) },
                    { "nonceDuplicate", typeof(InvalidNonce) },
                } },
            } },
            { "precisionMode", TICK_SIZE },
            { "options", new Dictionary<string, object>() {
                { "access", new Dictionary<string, object>() {
                    { "history", new Dictionary<string, object>() {
                        { "GET", new Dictionary<string, object>() {
                            { "orders", "private" },
                            { "executions", "private" },
                            { "triggers", "private" },
                            { "accountlogcsv", "private" },
                            { "account-log", "private" },
                        } },
                    } },
                } },
                { "settlementCurrencies", new Dictionary<string, object>() {
                    { "flex", new List<object>() {"USDT", "BTC", "USD", "GBP", "EUR", "USDC"} },
                } },
                { "symbol", new Dictionary<string, object>() {
                    { "quoteIds", new List<object>() {"USD", "XBT"} },
                    { "reversed", false },
                } },
                { "versions", new Dictionary<string, object>() {
                    { "public", new Dictionary<string, object>() {
                        { "GET", new Dictionary<string, object>() {
                            { "historicalfundingrates", "v4" },
                        } },
                    } },
                    { "charts", new Dictionary<string, object>() {
                        { "GET", new Dictionary<string, object>() {
                            { "{price_type}/{symbol}/{interval}", "v1" },
                        } },
                    } },
                    { "history", new Dictionary<string, object>() {
                        { "GET", new Dictionary<string, object>() {
                            { "orders", "v2" },
                            { "executions", "v2" },
                            { "triggers", "v2" },
                            { "accountlogcsv", "v2" },
                        } },
                    } },
                } },
                { "fetchTrades", new Dictionary<string, object>() {
                    { "method", "historyGetMarketSymbolExecutions" },
                } },
            } },
            { "features", new Dictionary<string, object>() {
                { "default", new Dictionary<string, object>() {
                    { "sandbox", true },
                    { "createOrder", new Dictionary<string, object>() {
                        { "marginMode", false },
                        { "triggerPrice", true },
                        { "triggerPriceType", new Dictionary<string, object>() {
                            { "last", true },
                            { "mark", true },
                            { "index", true },
                        } },
                        { "triggerDirection", false },
                        { "stopLossPrice", true },
                        { "takeProfitPrice", true },
                        { "attachedStopLossTakeProfit", null },
                        { "timeInForce", new Dictionary<string, object>() {
                            { "IOC", true },
                            { "FOK", true },
                            { "PO", true },
                            { "GTD", false },
                        } },
                        { "hedged", false },
                        { "trailing", false },
                        { "leverage", false },
                        { "marketBuyByCost", false },
                        { "marketBuyRequiresPrice", false },
                        { "selfTradePrevention", false },
                        { "iceberg", false },
                    } },
                    { "createOrders", new Dictionary<string, object>() {
                        { "max", 100 },
                    } },
                    { "fetchMyTrades", new Dictionary<string, object>() {
                        { "marginMode", false },
                        { "limit", null },
                        { "daysBack", null },
                        { "untilDays", 100000 },
                        { "symbolRequired", false },
                    } },
                    { "fetchOrder", null },
                    { "fetchOpenOrders", new Dictionary<string, object>() {
                        { "marginMode", false },
                        { "limit", null },
                        { "trigger", false },
                        { "trailing", false },
                        { "symbolRequired", false },
                    } },
                    { "fetchOrders", null },
                    { "fetchClosedOrders", new Dictionary<string, object>() {
                        { "marginMode", false },
                        { "limit", null },
                        { "daysBack", null },
                        { "daysBackCanceled", null },
                        { "untilDays", null },
                        { "trigger", false },
                        { "trailing", false },
                        { "symbolRequired", false },
                    } },
                    { "fetchOHLCV", new Dictionary<string, object>() {
                        { "limit", 2000 },
                    } },
                } },
                { "spot", null },
                { "swap", new Dictionary<string, object>() {
                    { "linear", new Dictionary<string, object>() {
                        { "extends", "default" },
                    } },
                    { "inverse", new Dictionary<string, object>() {
                        { "extends", "default" },
                    } },
                } },
                { "future", new Dictionary<string, object>() {
                    { "linear", new Dictionary<string, object>() {
                        { "extends", "default" },
                    } },
                    { "inverse", new Dictionary<string, object>() {
                        { "extends", "default" },
                    } },
                } },
            } },
            { "timeframes", new Dictionary<string, object>() {
                { "1m", "1m" },
                { "5m", "5m" },
                { "15m", "15m" },
                { "30m", "30m" },
                { "1h", "1h" },
                { "4h", "4h" },
                { "12h", "12h" },
                { "1d", "1d" },
                { "1w", "1w" },
            } },
        });
    }

    /**
     * @method
     * @name krakenfutures#fetchMarkets
     * @description Fetches the available trading markets from the exchange, Multi-collateral markets are returned as linear markets, but can be settled in multiple currencies
     * @see https://docs.kraken.com/api/docs/futures-api/trading/get-instruments
     * @param {object} [params] exchange specific params
     * @returns An array of market structures
     */
    public async override Task<object> fetchMarkets(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object response = await this.publicGetInstruments(parameters);
        //
        //    {
        //        "result": "success",
        //        "instruments": [
        //            {
        //                "symbol": "fi_ethusd_180928",
        //                "type": "futures_inverse", // futures_vanilla  // spot index
        //                "underlying": "rr_ethusd",
        //                "lastTradingTime": "2018-09-28T15:00:00.000Z",
        //                "tickSize": 0.1,
        //                "contractSize": 1,
        //                "tradeable": true,
        //                "marginLevels": [
        //                    {
        //                        "contracts":0,
        //                        "initialMargin":0.02,
        //                        "maintenanceMargin":0.01
        //                    },
        //                    {
        //                        "contracts":250000,
        //                        "initialMargin":0.04,
        //                        "maintenanceMargin":0.02
        //                    },
        //                    ...
        //                ],
        //                "isin": "GB00JVMLMP88",
        //                "retailMarginLevels": [
        //                    {
        //                        "contracts": 0,
        //                        "initialMargin": 0.5,
        //                        "maintenanceMargin": 0.25
        //                    }
        //                ],
        //                "tags": [],
        //            },
        //            {
        //                "symbol": "in_xbtusd",
        //                "type": "spot index",
        //                "tradeable":false
        //            }
        //        ]
        //        "serverTime": "2018-07-19T11:32:39.433Z"
        //    }
        //
        object instruments = this.safeValue(response, "instruments", new List<object>() {});
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(instruments)); postFixIncrement(ref i))
        {
            object market = getValue(instruments, i);
            object id = this.safeString(market, "symbol");
            object marketType = this.safeString(market, "type");
            object type = null;
            object index = (isGreaterThanOrEqual(getIndexOf(marketType, " index"), 0));
            object linear = null;
            object inverse = null;
            object expiry = null;
            if (!isTrue(index))
            {
                linear = (isGreaterThanOrEqual(getIndexOf(marketType, "_vanilla"), 0));
                inverse = !isTrue(linear);
                object settleTime = this.safeString(market, "lastTradingTime");
                type = ((bool) isTrue((isEqual(settleTime, null)))) ? "swap" : "future";
                expiry = this.parse8601(settleTime);
            } else
            {
                type = "index";
            }
            object swap = (isEqual(type, "swap"));
            object future = (isEqual(type, "future"));
            object symbol = id;
            object split = ((string)id).Split(new [] {((string)"_")}, StringSplitOptions.None).ToList<object>();
            object splitMarket = this.safeString(split, 1);
            object baseId = slice(splitMarket, 0, subtract(((string)splitMarket).Length, 3));
            object quoteId = "usd"; // always USD
            object bs = this.safeCurrencyCode(baseId);
            object quote = this.safeCurrencyCode(quoteId);
            // swap == perpetual
            object settle = null;
            object settleId = null;
            object cvtp = this.safeString(market, "contractValueTradePrecision");
            object amountPrecision = this.parseNumber(this.integerPrecisionToAmount(cvtp));
            object pricePrecision = this.safeNumber(market, "tickSize");
            object contract = (isTrue(isTrue(swap) || isTrue(future)) || isTrue(index));
            object swapOrFutures = (isTrue(swap) || isTrue(future));
            if (isTrue(swapOrFutures))
            {
                object exchangeType = this.safeString(market, "type");
                if (isTrue(isEqual(exchangeType, "futures_inverse")))
                {
                    settle = bs;
                    settleId = baseId;
                    inverse = true;
                } else
                {
                    settle = quote;
                    settleId = quoteId;
                    inverse = false;
                }
                linear = !isTrue(inverse);
                symbol = add(add(add(add(bs, "/"), quote), ":"), settle);
                if (isTrue(future))
                {
                    symbol = add(add(symbol, "-"), this.yymmdd(expiry));
                }
            }
            ((IList<object>)result).Add(new Dictionary<string, object>() {
                { "id", id },
                { "symbol", symbol },
                { "base", bs },
                { "quote", quote },
                { "settle", settle },
                { "baseId", baseId },
                { "quoteId", quoteId },
                { "settleId", settleId },
                { "type", type },
                { "spot", false },
                { "margin", false },
                { "swap", swap },
                { "future", future },
                { "option", false },
                { "index", index },
                { "active", this.safeBool(market, "tradeable") },
                { "contract", contract },
                { "linear", linear },
                { "inverse", inverse },
                { "contractSize", this.safeNumber(market, "contractSize") },
                { "maintenanceMarginRate", null },
                { "expiry", expiry },
                { "expiryDatetime", this.iso8601(expiry) },
                { "strike", null },
                { "optionType", null },
                { "precision", new Dictionary<string, object>() {
                    { "amount", amountPrecision },
                    { "price", pricePrecision },
                } },
                { "limits", new Dictionary<string, object>() {
                    { "leverage", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                    { "amount", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                    { "price", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                    { "cost", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                } },
                { "created", this.parse8601(this.safeString(market, "openingDate")) },
                { "info", market },
            });
        }
        object settlementCurrencies = getValue(getValue(this.options, "settlementCurrencies"), "flex");
        object currencies = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(settlementCurrencies)); postFixIncrement(ref i))
        {
            object code = getValue(settlementCurrencies, i);
            ((IList<object>)currencies).Add(new Dictionary<string, object>() {
                { "id", ((string)code).ToLower() },
                { "numericId", null },
                { "code", code },
                { "precision", null },
            });
        }
        this.currencies = this.mapToSafeMap(this.deepExtend(currencies, this.currencies));
        return result;
    }

    /**
     * @method
     * @name krakenfutures#fetchOrderBook
     * @see https://docs.kraken.com/api/docs/futures-api/trading/get-orderbook
     * @description Fetches a list of open orders in a market
     * @param {string} symbol Unified market symbol
     * @param {int} [limit] Not used by krakenfutures
     * @param {object} [params] exchange specific params
     * @returns An [order book structure]{@link https://docs.ccxt.com/?id=order-book-structure}
     */
    public async override Task<object> fetchOrderBook(object symbol, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object response = await this.publicGetOrderbook(this.extend(request, parameters));
        //
        //    {
        //       "result": "success",
        //       "serverTime": "2016-02-25T09:45:53.818Z",
        //       "orderBook": {
        //          "bids": [
        //                [
        //                    4213,
        //                    2000,
        //                ],
        //                [
        //                    4210,
        //                    4000,
        //                ],
        //                ...
        //            ],
        //            "asks": [
        //                [
        //                    4218,
        //                    4000,
        //                ],
        //                [
        //                    4220,
        //                    5000,
        //                ],
        //                ...
        //            ],
        //        },
        //    }
        //
        object timestamp = this.parse8601(getValue(response, "serverTime"));
        return this.parseOrderBook(getValue(response, "orderBook"), symbol, timestamp);
    }

    /**
     * @method
     * @name krakenfutures#fetchTickers
     * @description fetches price tickers for multiple markets, statistical information calculated over the past 24 hours for each market
     * @see https://docs.kraken.com/api/docs/futures-api/trading/get-tickers
     * @param {string[]} symbols unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} an array of [ticker structures]{@link https://docs.ccxt.com/?id=ticker-structure}
     */
    public async override Task<object> fetchTickers(object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.publicGetTickers(parameters);
        //
        //    {
        //        "result": "success",
        //        "tickers": [
        //            {
        //                "tag": 'semiannual',  // 'month', 'quarter', "perpetual", "semiannual",
        //                "pair": "ETH:USD",
        //                "symbol": "fi_ethusd_220624",
        //                "markPrice": "2925.72",
        //                "bid": "2923.8",
        //                "bidSize": "16804",
        //                "ask": "2928.65",
        //                "askSize": "1339",
        //                "vol24h": "860493",
        //                "openInterest": "3023363.00000000",
        //                "open24h": "3021.25",
        //                "indexPrice": "2893.71",
        //                "last": "2942.25",
        //                "lastTime": "2022-02-18T14:08:15.578Z",
        //                "lastSize": "151",
        //                "suspended": false
        //            },
        //            {
        //                "symbol": "in_xbtusd", // "rr_xbtusd",
        //                "last": "40411",
        //                "lastTime": "2022-02-18T14:16:28.000Z"
        //            },
        //            ...
        //        ],
        //        "serverTime": "2022-02-18T14:16:29.440Z"
        //    }
        //
        object tickers = this.safeList(response, "tickers");
        return this.parseTickers(tickers, symbols);
    }

    public override object parseTicker(object ticker, object market = null)
    {
        //
        //    {
        //        "tag": 'semiannual',  // 'month', 'quarter', "perpetual", "semiannual",
        //        "pair": "ETH:USD",
        //        "symbol": "fi_ethusd_220624",
        //        "markPrice": "2925.72",
        //        "bid": "2923.8",
        //        "bidSize": "16804",
        //        "ask": "2928.65",
        //        "askSize": "1339",
        //        "vol24h": "860493",
        //        "openInterest": "3023363.00000000",
        //        "open24h": "3021.25",
        //        "indexPrice": "2893.71",
        //        "last": "2942.25",
        //        "lastTime": "2022-02-18T14:08:15.578Z",
        //        "lastSize": "151",
        //        "suspended": false
        //    }
        //
        //    {
        //        "symbol": "in_xbtusd", // "rr_xbtusd",
        //        "last": "40411",
        //        "lastTime": "2022-02-18T14:16:28.000Z"
        //    }
        //
        object marketId = this.safeString(ticker, "symbol");
        market = this.safeMarket(marketId, market);
        object symbol = getValue(market, "symbol");
        object timestamp = this.parse8601(this.safeString(ticker, "lastTime"));
        object open = this.safeString(ticker, "open24h");
        object last = this.safeString(ticker, "last");
        object change = Precise.stringSub(last, open);
        object percentage = Precise.stringMul(Precise.stringDiv(change, open), "100");
        object average = Precise.stringDiv(Precise.stringAdd(open, last), "2");
        object volume = this.safeString(ticker, "vol24h");
        object baseVolume = null;
        object quoteVolume = null;
        object isIndex = this.safeBool(market, "index", false);
        if (!isTrue(isIndex))
        {
            if (isTrue(getValue(market, "linear")))
            {
                baseVolume = volume;
            } else if (isTrue(getValue(market, "inverse")))
            {
                quoteVolume = volume;
            }
        }
        return this.safeTicker(new Dictionary<string, object>() {
            { "symbol", symbol },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "high", null },
            { "low", null },
            { "bid", this.safeString(ticker, "bid") },
            { "bidVolume", this.safeString(ticker, "bidSize") },
            { "ask", this.safeString(ticker, "ask") },
            { "askVolume", this.safeString(ticker, "askSize") },
            { "vwap", null },
            { "open", open },
            { "close", last },
            { "last", last },
            { "previousClose", null },
            { "change", change },
            { "percentage", percentage },
            { "average", average },
            { "baseVolume", baseVolume },
            { "quoteVolume", quoteVolume },
            { "markPrice", this.safeString(ticker, "markPrice") },
            { "indexPrice", this.safeString(ticker, "indexPrice") },
            { "info", ticker },
        });
    }

    /**
     * @method
     * @name krakenfutures#fetchOHLCV
     * @see https://docs.kraken.com/api/docs/futures-api/charts/candles
     * @description fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
     * @param {string} symbol unified symbol of the market to fetch OHLCV data for
     * @param {string} timeframe the length of time each candle represents
     * @param {int} [since] timestamp in ms of the earliest candle to fetch
     * @param {int} [limit] the maximum amount of candles to fetch
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [availble parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
     * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
     */
    public async override Task<object> fetchOHLCV(object symbol, object timeframe = null, object since = null, object limit = null, object parameters = null)
    {
        timeframe ??= "1m";
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object paginate = false;
        var paginateparametersVariable = this.handleOptionAndParams(parameters, "fetchOHLCV", "paginate");
        paginate = ((IList<object>)paginateparametersVariable)[0];
        parameters = ((IList<object>)paginateparametersVariable)[1];
        if (isTrue(paginate))
        {
            return await this.fetchPaginatedCallDeterministic("fetchOHLCV", symbol, since, limit, timeframe, parameters, 2000);
        }
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
            { "price_type", this.safeString(parameters, "price", "trade") },
            { "interval", this.safeString(this.timeframes, timeframe, timeframe) },
        };
        parameters = this.omit(parameters, "price");
        if (isTrue(!isEqual(since, null)))
        {
            object duration = this.parseTimeframe(timeframe);
            ((IDictionary<string,object>)request)["from"] = this.parseToInt(divide(since, 1000));
            if (isTrue(isEqual(limit, null)))
            {
                limit = 2000;
            }
            limit = mathMin(limit, 2000);
            object toTimestamp = this.sum(getValue(request, "from"), subtract(multiply(limit, duration), 1));
            object currentTimestamp = this.seconds();
            ((IDictionary<string,object>)request)["to"] = mathMin(toTimestamp, currentTimestamp);
        } else if (isTrue(!isEqual(limit, null)))
        {
            limit = mathMin(limit, 2000);
            object duration = this.parseTimeframe(timeframe);
            ((IDictionary<string,object>)request)["to"] = this.seconds();
            ((IDictionary<string,object>)request)["from"] = this.parseToInt(subtract(getValue(request, "to"), (multiply(duration, limit))));
        }
        object response = await this.chartsGetPriceTypeSymbolInterval(this.extend(request, parameters));
        //
        //    {
        //        "candles": [
        //            {
        //                "time": 1645198500000,
        //                "open": "309.15000000000",
        //                "high": "309.15000000000",
        //                "low": "308.70000000000",
        //                "close": "308.85000000000",
        //                "volume": 0
        //            }
        //        ],
        //        "more_candles": true
        //    }
        //
        object candles = this.safeList(response, "candles");
        return this.parseOHLCVs(candles, market, timeframe, since, limit);
    }

    public override object parseOHLCV(object ohlcv, object market = null)
    {
        //
        //    {
        //        "time": 1645198500000,
        //        "open": "309.15000000000",
        //        "high": "309.15000000000",
        //        "low": "308.70000000000",
        //        "close": "308.85000000000",
        //        "volume": 0
        //    }
        //
        return new List<object> {this.safeInteger(ohlcv, "time"), this.safeNumber(ohlcv, "open"), this.safeNumber(ohlcv, "high"), this.safeNumber(ohlcv, "low"), this.safeNumber(ohlcv, "close"), this.safeNumber(ohlcv, "volume")};
    }

    /**
     * @method
     * @name krakenfutures#fetchTrades
     * @see https://docs.kraken.com/api/docs/futures-api/trading/get-history
     * @see https://docs.kraken.com/api/docs/futures-api/history/get-public-execution-events
     * @description Fetch a history of filled trades that this account has made
     * @param {string} symbol Unified CCXT market symbol
     * @param {int} [since] Timestamp in ms of earliest trade. Not used by krakenfutures except in combination with params.until
     * @param {int} [limit] Total number of trades, cannot exceed 100
     * @param {object} [params] Exchange specific params
     * @param {int} [params.until] Timestamp in ms of latest trade
     * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [availble parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
     * @param {string} [params.method] The method to use to fetch trades. Can be 'historyGetMarketSymbolExecutions' or 'publicGetHistory' default is 'historyGetMarketSymbolExecutions'
     * @returns An array of [trade structures]{@link https://docs.ccxt.com/?id=trade-structure}
     */
    public async override Task<object> fetchTrades(object symbol, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object paginate = false;
        var paginateparametersVariable = this.handleOptionAndParams(parameters, "fetchTrades", "paginate");
        paginate = ((IList<object>)paginateparametersVariable)[0];
        parameters = ((IList<object>)paginateparametersVariable)[1];
        if (isTrue(paginate))
        {
            return await this.fetchPaginatedCallDynamic("fetchTrades", symbol, since, limit, parameters);
        }
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object method = null;
        var methodparametersVariable = this.handleOptionAndParams(parameters, "fetchTrades", "method", "historyGetMarketSymbolExecutions");
        method = ((IList<object>)methodparametersVariable)[0];
        parameters = ((IList<object>)methodparametersVariable)[1];
        object rawTrades = null;
        object isFullHistoryEndpoint = (isEqual(method, "historyGetMarketSymbolExecutions"));
        if (isTrue(isFullHistoryEndpoint))
        {
            var requestparametersVariable = this.handleUntilOption("before", request, parameters);
            request = ((IList<object>)requestparametersVariable)[0];
            parameters = ((IList<object>)requestparametersVariable)[1];
            if (isTrue(!isEqual(since, null)))
            {
                ((IDictionary<string,object>)request)["since"] = since;
                ((IDictionary<string,object>)request)["sort"] = "asc";
            }
            if (isTrue(!isEqual(limit, null)))
            {
                ((IDictionary<string,object>)request)["count"] = limit;
            }
            object response = await this.historyGetMarketSymbolExecutions(this.extend(request, parameters));
            //
            //    {
            //        "elements": [
            //            {
            //                "uid": "a5105030-f054-44cc-98ab-30d5cae96bef",
            //                "timestamp": "1710150778607",
            //                "event": {
            //                    "Execution": {
            //                        "execution": {
            //                            "uid": "2d485b71-cd28-4a1e-9364-371a127550d2",
            //                            "makerOrder": {
            //                                "uid": "0a25f66b-1109-49ec-93a3-d17bf9e9137e",
            //                                "tradeable": "PF_XBTUSD",
            //                                "direction": "Buy",
            //                                "quantity": "0.26500",
            //                                "timestamp": "1710150778570",
            //                                "limitPrice": "71907",
            //                                "orderType": "Post",
            //                                "reduceOnly": false,
            //                                "lastUpdateTimestamp": "1710150778570"
            //                            },
            //                            "takerOrder": {
            //                                "uid": "04de3ee0-9125-4960-bf8f-f63b577b6790",
            //                                "tradeable": "PF_XBTUSD",
            //                                "direction": "Sell",
            //                                "quantity": "0.0002",
            //                                "timestamp": "1710150778607",
            //                                "limitPrice": "71187.00",
            //                                "orderType": "Market",
            //                                "reduceOnly": false,
            //                                "lastUpdateTimestamp": "1710150778607"
            //                            },
            //                            "timestamp": "1710150778607",
            //                            "quantity": "0.0002",
            //                            "price": "71907",
            //                            "markPrice": "71903.32715463147",
            //                            "limitFilled": false,
            //                            "usdValue": "14.38"
            //                        },
            //                        "takerReducedQuantity": ""
            //                    }
            //                }
            //            },
            //            ... followed by older items
            //        ],
            //        "len": "1000",
            //        "continuationToken": "QTexMDE0OTe33NTcyXy8xNDIzAjc1NjY5MwI="
            //    }
            //
            object elements = this.safeList(response, "elements", new List<object>() {});
            // we need to reverse the list to fix chronology
            rawTrades = new List<object>() {};
            object length = getArrayLength(elements);
            for (object i = 0; isLessThan(i, length); postFixIncrement(ref i))
            {
                object index = subtract(subtract(length, 1), i);
                object element = getValue(elements, index);
                object eventVar = this.safeDict(element, "event", new Dictionary<string, object>() {});
                object executionContainer = this.safeDict(eventVar, "Execution", new Dictionary<string, object>() {});
                object rawTrade = this.safeDict(executionContainer, "execution", new Dictionary<string, object>() {});
                ((IList<object>)rawTrades).Add(rawTrade);
            }
        } else
        {
            var requestparametersVariable = this.handleUntilOption("lastTime", request, parameters);
            request = ((IList<object>)requestparametersVariable)[0];
            parameters = ((IList<object>)requestparametersVariable)[1];
            object response = await this.publicGetHistory(this.extend(request, parameters));
            //
            //    {
            //        "result": "success",
            //        "history": [
            //            {
            //                "time": "2022-03-18T04:55:37.692Z",
            //                "trade_id": 100,
            //                "price": 0.7921,
            //                "size": 1068,
            //                "side": "sell",
            //                "type": "fill",
            //                "uid": "6c5da0b0-f1a8-483f-921f-466eb0388265"
            //            },
            //            ...
            //        ],
            //        "serverTime": "2022-03-18T06:39:18.056Z"
            //    }
            //
            rawTrades = this.safeList(response, "history", new List<object>() {});
        }
        return this.parseTrades(rawTrades, market, since, limit);
    }

    public override object parseTrade(object trade, object market = null)
    {
        //
        // fetchTrades (recent trades)
        //
        //    {
        //        "time": "2019-02-14T09:25:33.920Z",
        //        "trade_id": 100,
        //        "price": 3574,
        //        "size": 100,
        //        "side": "buy",
        //        "type": "fill" // fill, liquidation, assignment, termination
        //        "uid": "11c3d82c-9e70-4fe9-8115-f643f1b162d4"
        //    }
        //
        // fetchTrades (executions history)
        //
        //    {
        //        "timestamp": "1710152516830",
        //        "price": "71927.0",
        //        "quantity": "0.0695",
        //        "markPrice": "71936.38701675525",
        //        "limitFilled": true,
        //        "usdValue": "4998.93",
        //        "uid": "116ae634-253f-470b-bd20-fa9d429fb8b1",
        //        "makerOrder": { "uid": "17bfe4de-c01e-4938-926c-617d2a2d0597", "tradeable": "PF_XBTUSD", "direction": "Buy", "quantity": "0.0695", "timestamp": "1710152515836", "limitPrice": "71927.0", "orderType": "Post", "reduceOnly": false, "lastUpdateTimestamp": "1710152515836" },
        //        "takerOrder": { "uid": "d3e437b4-aa70-4108-b5cf-b1eecb9845b5", "tradeable": "PF_XBTUSD", "direction": "Sell", "quantity": "0.940100", "timestamp": "1710152516830", "limitPrice": "71915", "orderType": "IoC", "reduceOnly": false, "lastUpdateTimestamp": "1710152516830" }
        //    }
        //
        // fetchMyTrades (private)
        //
        //    {
        //        "fillTime": "2016-02-25T09:47:01.000Z",
        //        "order_id": "c18f0c17-9971-40e6-8e5b-10df05d422f0",
        //        "fill_id": "522d4e08-96e7-4b44-9694-bfaea8fe215e",
        //        "cliOrdId": "d427f920-ec55-4c18-ba95-5fe241513b30",     // OPTIONAL
        //        "symbol": "fi_xbtusd_180615",
        //        "side": "buy",
        //        "size": 2000,
        //        "price": 4255,
        //        "fillType": "maker"                                     // taker, takerAfterEdit, maker, liquidation, assignee
        //    }
        //
        // execution report (createOrder, editOrder)
        //
        //    {
        //        "executionId": "e1ec9f63-2338-4c44-b40a-43486c6732d7",
        //        "price": 7244.5,
        //        "amount": 10,
        //        "orderPriorEdit": null,
        //        "orderPriorExecution": {
        //            "orderId": "61ca5732-3478-42fe-8362-abbfd9465294",
        //            "cliOrdId": null,
        //            "type": "lmt",
        //            "symbol": "pi_xbtusd",
        //            "side": "buy",
        //            "quantity": 10,
        //            "filled": 0,
        //            "limitPrice": 7500,
        //            "reduceOnly": false,
        //            "timestamp": "2019-12-11T17:17:33.888Z",
        //            "lastUpdateTimestamp": "2019-12-11T17:17:33.888Z"
        //        },
        //        "takerReducedQuantity": null,
        //        "type": "EXECUTION"
        //    }
        //
        object timestamp = this.parse8601(this.safeString2(trade, "time", "fillTime"));
        object price = this.safeString(trade, "price");
        object amount = this.safeStringN(trade, new List<object>() {"size", "amount", "quantity"}, "0.0");
        object id = this.safeString2(trade, "uid", "fill_id");
        if (isTrue(isEqual(id, null)))
        {
            id = this.safeString(trade, "executionId");
        }
        object order = this.safeString(trade, "order_id");
        object marketId = this.safeString(trade, "symbol");
        object side = this.safeString(trade, "side");
        object type = null;
        object priorEdit = this.safeValue(trade, "orderPriorEdit");
        object priorExecution = this.safeValue(trade, "orderPriorExecution");
        if (isTrue(!isEqual(priorExecution, null)))
        {
            order = this.safeString(priorExecution, "orderId");
            marketId = this.safeString(priorExecution, "symbol");
            side = this.safeString(priorExecution, "side");
            type = this.safeString(priorExecution, "type");
        } else if (isTrue(!isEqual(priorEdit, null)))
        {
            order = this.safeString(priorEdit, "orderId");
            marketId = this.safeString(priorEdit, "symbol");
            side = this.safeString(priorEdit, "type");
            type = this.safeString(priorEdit, "type");
        }
        if (isTrue(!isEqual(type, null)))
        {
            type = this.parseOrderType(type);
        }
        market = this.safeMarket(marketId, market);
        object cost = null;
        object linear = this.safeBool(market, "linear");
        if (isTrue(isTrue(isTrue((!isEqual(amount, null))) && isTrue((!isEqual(price, null)))) && isTrue((!isEqual(market, null)))))
        {
            if (isTrue(linear))
            {
                cost = Precise.stringMul(amount, price); // in quote
            } else
            {
                cost = Precise.stringDiv(amount, price); // in base
            }
            object contractSize = this.safeString(market, "contractSize");
            cost = Precise.stringMul(cost, contractSize);
        }
        object takerOrMaker = null;
        object fillType = this.safeString(trade, "fillType");
        if (isTrue(!isEqual(fillType, null)))
        {
            if (isTrue(isGreaterThanOrEqual(getIndexOf(fillType, "taker"), 0)))
            {
                takerOrMaker = "taker";
            } else if (isTrue(isGreaterThanOrEqual(getIndexOf(fillType, "maker"), 0)))
            {
                takerOrMaker = "maker";
            }
        }
        object isHistoricalExecution = (inOp(trade, "takerOrder"));
        if (isTrue(isHistoricalExecution))
        {
            timestamp = this.safeInteger(trade, "timestamp");
            object taker = this.safeDict(trade, "takerOrder", new Dictionary<string, object>() {});
            if (isTrue(!isEqual(taker, null)))
            {
                side = this.safeStringLower(taker, "direction");
                takerOrMaker = "taker";
            }
        }
        return this.safeTrade(new Dictionary<string, object>() {
            { "info", trade },
            { "id", id },
            { "symbol", this.safeString(market, "symbol") },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "order", order },
            { "type", type },
            { "side", side },
            { "takerOrMaker", takerOrMaker },
            { "price", price },
            { "amount", ((bool) isTrue(linear)) ? amount : null },
            { "cost", cost },
            { "fee", null },
        });
    }

    public virtual object createOrderRequest(object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object market = this.market(symbol);
        symbol = getValue(market, "symbol");
        type = this.safeString(parameters, "orderType", type);
        object timeInForce = this.safeString(parameters, "timeInForce");
        object postOnly = false;
        var postOnlyparametersVariable = this.handlePostOnly(isEqual(type, "market"), isEqual(type, "post"), parameters);
        postOnly = ((IList<object>)postOnlyparametersVariable)[0];
        parameters = ((IList<object>)postOnlyparametersVariable)[1];
        if (isTrue(postOnly))
        {
            type = "post";
        } else if (isTrue(isEqual(timeInForce, "ioc")))
        {
            type = "ioc";
        } else if (isTrue(isEqual(type, "limit")))
        {
            type = "lmt";
        } else if (isTrue(isEqual(type, "market")))
        {
            type = "mkt";
        }
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
            { "side", side },
            { "size", this.amountToPrecision(symbol, amount) },
        };
        object clientOrderId = this.safeString2(parameters, "clientOrderId", "cliOrdId");
        if (isTrue(!isEqual(clientOrderId, null)))
        {
            ((IDictionary<string,object>)request)["cliOrdId"] = clientOrderId;
        }
        object triggerPrice = this.safeString2(parameters, "triggerPrice", "stopPrice");
        object isTriggerOrder = !isEqual(triggerPrice, null);
        object stopLossTriggerPrice = this.safeString(parameters, "stopLossPrice");
        object takeProfitTriggerPrice = this.safeString(parameters, "takeProfitPrice");
        object isStopLossTriggerOrder = !isEqual(stopLossTriggerPrice, null);
        object isTakeProfitTriggerOrder = !isEqual(takeProfitTriggerPrice, null);
        object isStopLossOrTakeProfitTrigger = isTrue(isStopLossTriggerOrder) || isTrue(isTakeProfitTriggerOrder);
        object triggerSignal = this.safeString(parameters, "triggerSignal", "last");
        object reduceOnly = this.safeValue(parameters, "reduceOnly");
        if (isTrue(isTrue(isStopLossOrTakeProfitTrigger) || isTrue(isTriggerOrder)))
        {
            ((IDictionary<string,object>)request)["triggerSignal"] = triggerSignal;
        }
        if (isTrue(isTriggerOrder))
        {
            type = "stp";
            ((IDictionary<string,object>)request)["stopPrice"] = this.priceToPrecision(symbol, triggerPrice);
        } else if (isTrue(isStopLossOrTakeProfitTrigger))
        {
            reduceOnly = true;
            if (isTrue(isStopLossTriggerOrder))
            {
                type = "stp";
                ((IDictionary<string,object>)request)["stopPrice"] = this.priceToPrecision(symbol, stopLossTriggerPrice);
            } else if (isTrue(isTakeProfitTriggerOrder))
            {
                type = "take_profit";
                ((IDictionary<string,object>)request)["stopPrice"] = this.priceToPrecision(symbol, takeProfitTriggerPrice);
            }
        }
        if (isTrue(reduceOnly))
        {
            ((IDictionary<string,object>)request)["reduceOnly"] = true;
        }
        ((IDictionary<string,object>)request)["orderType"] = type;
        if (isTrue(!isEqual(price, null)))
        {
            ((IDictionary<string,object>)request)["limitPrice"] = this.priceToPrecision(symbol, price);
        }
        parameters = this.omit(parameters, new List<object>() {"clientOrderId", "timeInForce", "triggerPrice", "stopLossPrice", "takeProfitPrice"});
        return this.extend(request, parameters);
    }

    /**
     * @method
     * @name krakenfutures#createOrder
     * @description Create an order on the exchange
     * @see https://docs.kraken.com/api/docs/futures-api/trading/send-order
     * @param {string} symbol unified market symbol
     * @param {string} type 'limit' or 'market'
     * @param {string} side 'buy' or 'sell'
     * @param {float} amount number of contracts
     * @param {float} [price] limit order price
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {bool} [params.reduceOnly] set as true if you wish the order to only reduce an existing position, any order which increases an existing position will be rejected, default is false
     * @param {bool} [params.postOnly] set as true if you wish to make a postOnly order, default is false
     * @param {string} [params.clientOrderId] UUID The order identity that is specified from the user, It must be globally unique
     * @param {float} [params.triggerPrice] the price that a stop order is triggered at
     * @param {float} [params.stopLossPrice] the price that a stop loss order is triggered at
     * @param {float} [params.takeProfitPrice] the price that a take profit order is triggered at
     * @param {string} [params.triggerSignal] for triggerPrice, stopLossPrice and takeProfitPrice orders, the trigger price type, 'last', 'mark' or 'index', default is 'last'
     * @returns {object} an [order structure]{@link https://docs.ccxt.com/?id=order-structure}
     */
    public async override Task<object> createOrder(object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object orderRequest = this.createOrderRequest(symbol, type, side, amount, price, parameters);
        object response = await this.privatePostSendorder(orderRequest);
        //
        //    {
        //        "result": "success",
        //        "sendStatus": {
        //            "order_id": "salf320-e337-47ac-b345-30sdfsalj",
        //            "status": "placed",
        //            "receivedTime": "2022-02-28T19:32:17.122Z",
        //            "orderEvents": [
        //                {
        //                    "order": {
        //                        "orderId": "salf320-e337-47ac-b345-30sdfsalj",
        //                        "cliOrdId": null,
        //                        "type": "lmt",
        //                        "symbol": "pi_xrpusd",
        //                        "side": "buy",
        //                        "quantity": 1,
        //                        "filled": 0,
        //                        "limitPrice": 0.7,
        //                        "reduceOnly": false,
        //                        "timestamp": "2022-02-28T19:32:17.122Z",
        //                        "lastUpdateTimestamp": "2022-02-28T19:32:17.122Z"
        //                    },
        //                    "reducedQuantity": null,
        //                    "type": "PLACE"
        //                }
        //            ]
        //        },
        //        "serverTime": "2022-02-28T19:32:17.122Z"
        //    }
        //
        object sendStatus = this.safeValue(response, "sendStatus");
        object status = this.safeString(sendStatus, "status");
        this.verifyOrderActionSuccess(status, "createOrder", new List<object>() {"filled"});
        return this.parseOrder(sendStatus, market);
    }

    /**
     * @method
     * @name krakenfutures#createOrders
     * @description create a list of trade orders
     * @see https://docs.kraken.com/api/docs/futures-api/trading/send-batch-order
     * @param {Array} orders list of orders to create, each object should contain the parameters required by createOrder, namely symbol, type, side, amount, price and params
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} an [order structure]{@link https://docs.ccxt.com/?id=order-structure}
     */
    public async override Task<object> createOrders(object orders, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object ordersRequests = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(orders)); postFixIncrement(ref i))
        {
            object rawOrder = getValue(orders, i);
            object marketId = this.safeString(rawOrder, "symbol");
            object type = this.safeString(rawOrder, "type");
            object side = this.safeString(rawOrder, "side");
            object amount = this.safeValue(rawOrder, "amount");
            object price = this.safeValue(rawOrder, "price");
            object orderParams = this.safeValue(rawOrder, "params", new Dictionary<string, object>() {});
            object extendedParams = this.extend(orderParams, parameters); // the request does not accept extra params since it's a list, so we're extending each order with the common params
            if (!isTrue((inOp(extendedParams, "order_tag"))))
            {
                // order tag is mandatory so we will generate one if not provided
                ((IDictionary<string,object>)extendedParams)["order_tag"] = ((object)this.sum(i, 1)).ToString(); // sequential counter
            }
            ((IDictionary<string,object>)extendedParams)["order"] = "send";
            object orderRequest = this.createOrderRequest(marketId, type, side, amount, price, extendedParams);
            ((IList<object>)ordersRequests).Add(orderRequest);
        }
        object request = new Dictionary<string, object>() {
            { "batchOrder", ordersRequests },
        };
        object response = await this.privatePostBatchorder(this.extend(request, parameters));
        //
        // {
        //     "result": "success",
        //     "serverTime": "2023-10-24T08:40:57.339Z",
        //     "batchStatus": [
        //        {
        //           "status": "requiredArgumentMissing",
        //           "orderEvents": []
        //        },
        //        {
        //           "status": "requiredArgumentMissing",
        //           "orderEvents": []
        //        }
        //     ]
        // }
        //
        object data = this.safeList(response, "batchStatus", new List<object>() {});
        return this.parseOrders(data);
    }

    /**
     * @method
     * @name krakenfutures#editOrder
     * @see https://docs.kraken.com/api/docs/futures-api/trading/edit-order-spring
     * @description Edit an open order on the exchange
     * @param {string} id order id
     * @param {string} symbol Not used by Krakenfutures
     * @param {string} type Not used by Krakenfutures
     * @param {string} side Not used by Krakenfutures
     * @param {float} amount Order size
     * @param {float} [price] Price to fill order at
     * @param {object} [params] Exchange specific params
     * @returns An [order structure]{@link https://docs.ccxt.com/?id=order-structure}
     */
    public async override Task<object> editOrder(object id, object symbol, object type, object side, object amount = null, object price = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {
            { "orderId", id },
        };
        if (isTrue(!isEqual(amount, null)))
        {
            ((IDictionary<string,object>)request)["size"] = amount;
        }
        if (isTrue(!isEqual(price, null)))
        {
            ((IDictionary<string,object>)request)["limitPrice"] = price;
        }
        object response = await this.privatePostEditorder(this.extend(request, parameters));
        object status = this.safeString(getValue(response, "editStatus"), "status");
        this.verifyOrderActionSuccess(status, "editOrder", new List<object>() {"filled"});
        object order = this.parseOrder(getValue(response, "editStatus"));
        ((IDictionary<string,object>)order)["info"] = response;
        return order;
    }

    /**
     * @method
     * @name krakenfutures#cancelOrder
     * @see https://docs.kraken.com/api/docs/futures-api/trading/cancel-order
     * @description Cancel an open order on the exchange
     * @param {string} id Order id
     * @param {string} symbol Not used by Krakenfutures
     * @param {object} [params] Exchange specific params
     * @returns An [order structure]{@link https://docs.ccxt.com/?id=order-structure}
     */
    public async override Task<object> cancelOrder(object id, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.privatePostCancelorder(this.extend(new Dictionary<string, object>() {
            { "order_id", id },
        }, parameters));
        object status = this.safeString(this.safeValue(response, "cancelStatus", new Dictionary<string, object>() {}), "status");
        this.verifyOrderActionSuccess(status, "cancelOrder");
        object order = new Dictionary<string, object>() {};
        if (isTrue(inOp(response, "cancelStatus")))
        {
            order = this.parseOrder(getValue(response, "cancelStatus"));
        }
        return this.extend(new Dictionary<string, object>() {
            { "info", response },
        }, order);
    }

    /**
     * @method
     * @name krakenfutures#cancelOrders
     * @description cancel multiple orders
     * @see https://docs.kraken.com/api/docs/futures-api/trading/send-batch-order
     * @param {string[]} ids order ids
     * @param {string} [symbol] unified market symbol
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     *
     * EXCHANGE SPECIFIC PARAMETERS
     * @param {string[]} [params.clientOrderIds] max length 10 e.g. ["my_id_1","my_id_2"]
     * @returns {object} an list of [order structures]{@link https://docs.ccxt.com/?id=order-structure}
     */
    public async override Task<object> cancelOrders(object ids, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object orders = new List<object>() {};
        object clientOrderIds = this.safeValue(parameters, "clientOrderIds", new List<object>() {});
        object clientOrderIdsLength = getArrayLength(clientOrderIds);
        if (isTrue(isGreaterThan(clientOrderIdsLength, 0)))
        {
            for (object i = 0; isLessThan(i, getArrayLength(clientOrderIds)); postFixIncrement(ref i))
            {
                ((IList<object>)orders).Add(new Dictionary<string, object>() {
                    { "order", "cancel" },
                    { "cliOrdId", getValue(clientOrderIds, i) },
                });
            }
        } else
        {
            for (object i = 0; isLessThan(i, getArrayLength(ids)); postFixIncrement(ref i))
            {
                ((IList<object>)orders).Add(new Dictionary<string, object>() {
                    { "order", "cancel" },
                    { "order_id", getValue(ids, i) },
                });
            }
        }
        object request = new Dictionary<string, object>() {
            { "batchOrder", orders },
        };
        object response = await this.privatePostBatchorder(this.extend(request, parameters));
        // {
        //     "result": "success",
        //     "serverTime": "2023-10-23T16:36:51.327Z",
        //     "batchStatus": [
        //       {
        //         "status": "cancelled",
        //         "order_id": "101c2327-f12e-45f2-8445-7502b87afc0b",
        //         "orderEvents": [
        //           {
        //             "uid": "101c2327-f12e-45f2-8445-7502b87afc0b",
        //             "order": {
        //               "orderId": "101c2327-f12e-45f2-8445-7502b87afc0b",
        //               "cliOrdId": null,
        //               "type": "lmt",
        //               "symbol": "PF_LTCUSD",
        //               "side": "buy",
        //               "quantity": "0.10000000000",
        //               "filled": "0E-11",
        //               "limitPrice": "50.00000000000",
        //               "reduceOnly": false,
        //               "timestamp": "2023-10-20T10:29:13.005Z",
        //               "lastUpdateTimestamp": "2023-10-20T10:29:13.005Z"
        //             },
        //             "type": "CANCEL"
        //           }
        //         ]
        //       }
        //     ]
        // }
        object batchStatus = this.safeList(response, "batchStatus", new List<object>() {});
        return this.parseOrders(batchStatus);
    }

    /**
     * @method
     * @name krakenfutures#cancelAllOrders
     * @see https://docs.kraken.com/api/docs/futures-api/trading/cancel-all-orders
     * @description Cancels all orders on the exchange, including trigger orders
     * @param {str} symbol Unified market symbol
     * @param {dict} [params] Exchange specific params
     * @returns Response from exchange api
     */
    public async override Task<object> cancelAllOrders(object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object request = new Dictionary<string, object>() {};
        if (isTrue(!isEqual(symbol, null)))
        {
            ((IDictionary<string,object>)request)["symbol"] = this.marketId(symbol);
        }
        object response = await this.privatePostCancelallorders(this.extend(request, parameters));
        //
        //    {
        //        result: 'success',
        //        cancelStatus: {
        //          receivedTime: '2024-06-06T01:12:44.814Z',
        //          cancelOnly: 'PF_XRPUSD',
        //          status: 'cancelled',
        //          cancelledOrders: [ { order_id: '272fd0ac-45c0-4003-b84d-d39b9e86bd36' } ],
        //          orderEvents: [
        //            {
        //              uid: '272fd0ac-45c0-4003-b84d-d39b9e86bd36',
        //              order: {
        //                orderId: '272fd0ac-45c0-4003-b84d-d39b9e86bd36',
        //                cliOrdId: null,
        //                type: 'lmt',
        //                symbol: 'PF_XRPUSD',
        //                side: 'buy',
        //                quantity: '10',
        //                filled: '0',
        //                limitPrice: '0.4',
        //                reduceOnly: false,
        //                timestamp: '2024-06-06T01:11:16.045Z',
        //                lastUpdateTimestamp: '2024-06-06T01:11:16.045Z'
        //              },
        //              type: 'CANCEL'
        //            }
        //          ]
        //        },
        //        serverTime: '2024-06-06T01:12:44.814Z'
        //    }
        //
        object cancelStatus = this.safeDict(response, "cancelStatus");
        object orderEvents = this.safeList(cancelStatus, "orderEvents", new List<object>() {});
        object orders = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(orderEvents)); postFixIncrement(ref i))
        {
            object orderEvent = this.safeDict(orderEvents, 0);
            object order = this.safeDict(orderEvent, "order", new Dictionary<string, object>() {});
            ((IList<object>)orders).Add(order);
        }
        return this.parseOrders(orders);
    }

    /**
     * @method
     * @name krakenfutures#cancelAllOrdersAfter
     * @description dead man's switch, cancel all orders after the given timeout
     * @see https://docs.kraken.com/api/docs/futures-api/trading/cancel-all-orders-after
     * @param {number} timeout time in milliseconds, 0 represents cancel the timer
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} the api result
     */
    public async override Task<object> cancelAllOrdersAfter(object timeout, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {
            { "timeout", ((bool) isTrue((isGreaterThan(timeout, 0)))) ? (this.parseToInt(divide(timeout, 1000))) : 0 },
        };
        object response = await this.privatePostCancelallordersafter(this.extend(request, parameters));
        //
        //     {
        //         "result": "success",
        //         "serverTime": "2018-06-19T16:51:23.839Z",
        //         "status": {
        //             "currentTime": "2018-06-19T16:51:23.839Z",
        //             "triggerTime": "0"
        //         }
        //     }
        //
        return response;
    }

    /**
     * @method
     * @name krakenfutures#fetchOpenOrders
     * @see https://docs.kraken.com/api/docs/futures-api/trading/get-open-orders
     * @description Gets all open orders, including trigger orders, for an account from the exchange api
     * @param {string} symbol Unified market symbol
     * @param {int} [since] Timestamp (ms) of earliest order. (Not used by kraken api but filtered internally by CCXT)
     * @param {int} [limit] How many orders to return. (Not used by kraken api but filtered internally by CCXT)
     * @param {object} [params] Exchange specific parameters
     * @returns An array of [order structures]{@link https://docs.ccxt.com/?id=order-structure}
     */
    public async override Task<object> fetchOpenOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
        }
        object response = await this.privateGetOpenorders(parameters);
        object orders = this.safeList(response, "openOrders", new List<object>() {});
        return this.parseOrders(orders, market, since, limit);
    }

    /**
     * @method
     * @name krakenfutures#fetchOrders
     * @see https://docs.kraken.com/api/docs/futures-api/trading/get-order-status/
     * @description Gets all orders for an account from the exchange api
     * @param {string} symbol Unified market symbol
     * @param {int} [since] Timestamp (ms) of earliest order. (Not used by kraken api but filtered internally by CCXT)
     * @param {int} [limit] How many orders to return. (Not used by kraken api but filtered internally by CCXT)
     * @param {object} [params] Exchange specific parameters
     * @returns An array of [order structures]{@link https://docs.ccxt.com/?id=order-structure}
     */
    public async override Task<object> fetchOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
        }
        object response = await this.privateGetOrdersStatus(parameters);
        object orders = this.safeList(response, "orders", new List<object>() {});
        return this.parseOrders(orders, market, since, limit);
    }

    /**
     * @method
     * @name krakenfutures#fetchOrder
     * @description fetches information on an order made by the user
     * @see https://docs.kraken.com/api/docs/futures-api/trading/get-order-status/
     * @param {string} id the order id
     * @param {string} symbol unified market symbol that the order was made in
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} An [order structure]{@link https://docs.ccxt.com/?id=order-structure}
     */
    public async override Task<object> fetchOrder(object id, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {
            { "orderIds", new List<object>() {id} },
        };
        object orders = await this.fetchOrders(null, null, null, this.extend(request, parameters));
        object order = this.safeDict(orders, 0);
        if (isTrue(isEqual(order, null)))
        {
            throw new OrderNotFound ((string)add(add(this.id, " fetchOrder could not find order id "), id)) ;
        }
        return order;
    }

    /**
     * @method
     * @name krakenfutures#fetchClosedOrders
     * @see https://docs.futures.kraken.com/#http-api-history-account-history-get-order-events
     * @description Gets all closed orders, including trigger orders, for an account from the exchange api
     * @param {string} symbol Unified market symbol
     * @param {int} [since] Timestamp (ms) of earliest order.
     * @param {int} [limit] How many orders to return.
     * @param {object} [params] Exchange specific parameters
     * @param {bool} [params.trigger] set to true if you wish to fetch only trigger orders
     * @returns An array of [order structures]{@link https://docs.ccxt.com/?id=order-structure}
     */
    public async override Task<object> fetchClosedOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
        }
        object request = new Dictionary<string, object>() {};
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["count"] = limit;
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["from"] = since;
        }
        object isTrigger = this.safeBool2(parameters, "trigger", "stop", false);
        object response = null;
        if (isTrue(isTrigger))
        {
            parameters = this.omit(parameters, new List<object>() {"trigger", "stop"});
            response = await this.historyGetTriggers(this.extend(request, parameters));
        } else
        {
            response = await this.historyGetOrders(this.extend(request, parameters));
        }
        object allOrders = this.safeList(response, "elements", new List<object>() {});
        object closedOrders = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(allOrders)); postFixIncrement(ref i))
        {
            object order = getValue(allOrders, i);
            object eventVar = this.safeDict(order, "event", new Dictionary<string, object>() {});
            object orderPlaced = this.safeDict2(eventVar, "OrderPlaced", "OrderTriggerActivated");
            if (isTrue(!isEqual(orderPlaced, null)))
            {
                object innerOrder = this.safeDict(orderPlaced, "order", new Dictionary<string, object>() {});
                object filled = this.safeString(innerOrder, "filled");
                if (isTrue(!isEqual(filled, "0")))
                {
                    ((IDictionary<string,object>)innerOrder)["status"] = "closed"; // status not available in the response
                    ((IList<object>)closedOrders).Add(innerOrder);
                }
            }
        }
        return this.parseOrders(closedOrders, market, since, limit);
    }

    /**
     * @method
     * @name krakenfutures#fetchCanceledOrders
     * @see https://docs.kraken.com/api/docs/futures-api/history/get-order-events
     * @description Gets all canceled orders, including trigger orders, for an account from the exchange api
     * @param {string} symbol Unified market symbol
     * @param {int} [since] Timestamp (ms) of earliest order.
     * @param {int} [limit] How many orders to return.
     * @param {object} [params] Exchange specific parameters
     * @param {bool} [params.trigger] set to true if you wish to fetch only trigger orders
     * @returns An array of [order structures]{@link https://docs.ccxt.com/?id=order-structure}
     */
    public async override Task<object> fetchCanceledOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
        }
        object request = new Dictionary<string, object>() {};
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["count"] = limit;
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["from"] = since;
        }
        object response = null;
        object isTrigger = this.safeBool2(parameters, "trigger", "stop", false);
        if (isTrue(isTrigger))
        {
            parameters = this.omit(parameters, new List<object>() {"trigger", "stop"});
            response = await this.historyGetTriggers(this.extend(request, parameters));
        } else
        {
            response = await this.historyGetOrders(this.extend(request, parameters));
        }
        object allOrders = this.safeList(response, "elements", new List<object>() {});
        object canceledAndRejected = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(allOrders)); postFixIncrement(ref i))
        {
            object order = getValue(allOrders, i);
            object eventVar = this.safeDict(order, "event", new Dictionary<string, object>() {});
            object isCancelledTriggerOrder = (inOp(eventVar, "OrderTriggerCancelled"));
            object orderPlaced = this.safeDict2(eventVar, "OrderPlaced", "OrderTriggerCancelled");
            if (isTrue(!isEqual(orderPlaced, null)))
            {
                object innerOrder = this.safeDict(orderPlaced, "order", new Dictionary<string, object>() {});
                object filled = this.safeString(innerOrder, "filled");
                if (isTrue(isTrue(isEqual(filled, "0")) || isTrue(isCancelledTriggerOrder)))
                {
                    ((IDictionary<string,object>)innerOrder)["status"] = "canceled"; // status not available in the response
                    ((IList<object>)canceledAndRejected).Add(innerOrder);
                }
            }
            object orderCanceled = this.safeDict(eventVar, "OrderCancelled");
            if (isTrue(!isEqual(orderCanceled, null)))
            {
                object innerOrder = this.safeDict(orderCanceled, "order", new Dictionary<string, object>() {});
                ((IDictionary<string,object>)innerOrder)["status"] = "canceled"; // status not available in the response
                ((IList<object>)canceledAndRejected).Add(innerOrder);
            }
            object orderRejected = this.safeDict(eventVar, "OrderRejected");
            if (isTrue(!isEqual(orderRejected, null)))
            {
                object innerOrder = this.safeDict(orderRejected, "order", new Dictionary<string, object>() {});
                ((IDictionary<string,object>)innerOrder)["status"] = "rejected"; // status not available in the response
                ((IList<object>)canceledAndRejected).Add(innerOrder);
            }
        }
        return this.parseOrders(canceledAndRejected, market, since, limit);
    }

    public virtual object parseOrderType(object orderType)
    {
        object typesMap = new Dictionary<string, object>() {
            { "lmt", "limit" },
            { "mkt", "market" },
            { "post", "limit" },
            { "ioc", "market" },
        };
        return this.safeString(typesMap, orderType, orderType);
    }

    public virtual void verifyOrderActionSuccess(object status, object method, object omit = null)
    {
        omit ??= new List<object>();
        object errors = new Dictionary<string, object>() {
            { "invalidOrderType", typeof(InvalidOrder) },
            { "invalidSide", typeof(InvalidOrder) },
            { "invalidSize", typeof(InvalidOrder) },
            { "invalidPrice", typeof(InvalidOrder) },
            { "insufficientAvailableFunds", typeof(InsufficientFunds) },
            { "selfFill", typeof(ExchangeError) },
            { "tooManySmallOrders", typeof(ExchangeError) },
            { "maxPositionViolation", typeof(BadRequest) },
            { "marketSuspended", typeof(ExchangeNotAvailable) },
            { "marketInactive", typeof(ExchangeNotAvailable) },
            { "clientOrderIdAlreadyExist", typeof(DuplicateOrderId) },
            { "clientOrderIdTooLong", typeof(BadRequest) },
            { "outsidePriceCollar", typeof(InvalidOrder) },
            { "postWouldExecute", typeof(OrderImmediatelyFillable) },
            { "iocWouldNotExecute", typeof(OrderNotFillable) },
            { "wouldNotReducePosition", typeof(ExchangeError) },
            { "orderForEditNotFound", typeof(OrderNotFound) },
            { "orderForEditNotAStop", typeof(InvalidOrder) },
            { "filled", typeof(OrderNotFound) },
            { "notFound", typeof(OrderNotFound) },
        };
        if (isTrue(isTrue((inOp(errors, status))) && !isTrue(this.inArray(status, omit))))
        {
            throwDynamicException(getValue(errors, status), add(add(add(add(this.id, ": "), method), " failed due to "), status));
        }
    }

    public virtual object parseOrderStatus(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "placed", "open" },
            { "cancelled", "canceled" },
            { "invalidOrderType", "rejected" },
            { "invalidSide", "rejected" },
            { "invalidSize", "rejected" },
            { "invalidPrice", "rejected" },
            { "insufficientAvailableFunds", "rejected" },
            { "selfFill", "rejected" },
            { "tooManySmallOrders", "rejected" },
            { "maxPositionViolation", "rejected" },
            { "marketSuspended", "rejected" },
            { "marketInactive", "rejected" },
            { "clientOrderIdAlreadyExist", "rejected" },
            { "clientOrderIdTooLong", "rejected" },
            { "outsidePriceCollar", "rejected" },
            { "postWouldExecute", "rejected" },
            { "iocWouldNotExecute", "rejected" },
            { "wouldNotReducePosition", "rejected" },
            { "edited", "open" },
            { "orderForEditNotFound", "rejected" },
            { "orderForEditNotAStop", "rejected" },
            { "filled", "closed" },
            { "notFound", "rejected" },
            { "untouched", "open" },
            { "partiallyFilled", "open" },
        };
        return this.safeString(statuses, status, status);
    }

    public override object parseOrder(object order, object market = null)
    {
        //
        // LIMIT
        //
        //    {
        //        "order_id": "179f9af8-e45e-469d-b3e9-2fd4675cb7d0",
        //        "status": "placed",
        //        "receivedTime": "2019-09-05T16:33:50.734Z",
        //        "orderEvents": [
        //            {
        //                "uid": "614a5298-0071-450f-83c6-0617ce8c6bc4",
        //                "order": {
        //                    "orderId": "179f9af8-e45e-469d-b3e9-2fd4675cb7d0",
        //                    "cliOrdId": null,
        //                    "type": "lmt",
        //                    "symbol": "pi_xbtusd",
        //                    "side": "buy",
        //                    "quantity": 10000,
        //                    "filled": 0,
        //                    "limitPrice": 9400,
        //                    "reduceOnly": false,
        //                    "timestamp": "2019-09-05T16:33:50.734Z",
        //                    "lastUpdateTimestamp": "2019-09-05T16:33:50.734Z"
        //                },
        //                "reducedQuantity": null,
        //                "reason": "WOULD_NOT_REDUCE_POSITION", // REJECTED
        //                "type": "PLACE"
        //            }
        //        ]
        //    }
        //
        // CONDITIONAL
        //
        //    {
        //        "order_id": "1abfd3c6-af93-4b30-91cc-e4a93797f3f5",
        //        "status": "placed",
        //        "receivedTime": "2019-12-05T10:20:50.701Z",
        //        "orderEvents": [
        //            {
        //                "orderTrigger": {
        //                    "uid": "1abfd3c6-af93-4b30-91cc-e4a93797f3f5",
        //                    "clientId":null,
        //                    "type": "lmt",                                // "ioc" if stop market
        //                    "symbol": "pi_xbtusd",
        //                    "side": "buy",
        //                    "quantity":10,
        //                    "limitPrice":15000,
        //                    "triggerPrice":9500,
        //                    "triggerSide": "trigger_below",
        //                    "triggerSignal": "mark_price",
        //                    "reduceOnly":false,
        //                    "timestamp": "2019-12-05T10:20:50.701Z",
        //                    "lastUpdateTimestamp": "2019-12-05T10:20:50.701Z"
        //                },
        //                "type": "PLACE"
        //            }
        //        ]
        //    }
        //
        // EXECUTION
        //
        //    {
        //        "order_id": "61ca5732-3478-42fe-8362-abbfd9465294",
        //        "status": "placed",
        //        "receivedTime": "2019-12-11T17:17:33.888Z",
        //        "orderEvents": [
        //            {
        //                "executionId": "e1ec9f63-2338-4c44-b40a-43486c6732d7",
        //                "price": 7244.5,
        //                "amount": 10,
        //                "orderPriorEdit": null,
        //                "orderPriorExecution": {
        //                    "orderId": "61ca5732-3478-42fe-8362-abbfd9465294",
        //                    "cliOrdId": null,
        //                    "type": "lmt",
        //                    "symbol": "pi_xbtusd",
        //                    "side": "buy",
        //                    "quantity": 10,
        //                    "filled": 0,
        //                    "limitPrice": 7500,
        //                    "reduceOnly": false,
        //                    "timestamp": "2019-12-11T17:17:33.888Z",
        //                    "lastUpdateTimestamp": "2019-12-11T17:17:33.888Z"
        //                },
        //                "takerReducedQuantity": null,
        //                "type": "EXECUTION"
        //            }
        //        ]
        //    }
        //
        // EDIT ORDER
        //
        //    {
        //        "status": "edited",
        //        "orderId": "022774bc-2c4a-4f26-9317-436c8d85746d",
        //        "receivedTime": "2019-09-05T16:47:47.521Z",
        //        "orderEvents": [
        //            {
        //                "old": {
        //                    "orderId": "022774bc-2c4a-4f26-9317-436c8d85746d",
        //                    "cliOrdId":null,
        //                    "type": "lmt",
        //                    "symbol": "pi_xbtusd",
        //                    "side": "buy",
        //                    "quantity":1000,
        //                    "filled":0,
        //                    "limitPrice":9400.0,
        //                    "reduceOnly":false,
        //                    "timestamp": "2019-09-05T16:41:35.173Z",
        //                    "lastUpdateTimestamp": "2019-09-05T16:41:35.173Z"
        //                },
        //                "new": {
        //                    "orderId": "022774bc-2c4a-4f26-9317-436c8d85746d",
        //                    "cliOrdId": null,
        //                    "type": "lmt",
        //                    "symbol": "pi_xbtusd",
        //                    "side": "buy",
        //                    "quantity": 1501,
        //                    "filled": 0,
        //                    "limitPrice": 7200,
        //                    "reduceOnly": false,
        //                    "timestamp": "2019-09-05T16:41:35.173Z",
        //                    "lastUpdateTimestamp": "2019-09-05T16:47:47.519Z"
        //                },
        //                "reducedQuantity": null,
        //                "type": "EDIT"
        //            }
        //        ]
        //    }
        //
        // CANCEL ORDER
        //
        //    {
        //        "status": "cancelled",
        //        "orderEvents": [
        //            {
        //                "uid": "85c40002-3f20-4e87-9302-262626c3531b",
        //                "order": {
        //                    "orderId": "85c40002-3f20-4e87-9302-262626c3531b",
        //                    "cliOrdId": null,
        //                    "type": "lmt",
        //                    "symbol": "pi_xbtusd",
        //                    "side": "buy",
        //                    "quantity": 1000,
        //                    "filled": 0,
        //                    "limitPrice": 10144,
        //                    "stopPrice": null,
        //                    "reduceOnly": false,
        //                    "timestamp": "2019-08-01T15:26:27.790Z"
        //                },
        //                "type": "CANCEL"
        //            }
        //        ]
        //    }
        //
        // cancelAllOrders
        //
        //    {
        //        "orderId": "85c40002-3f20-4e87-9302-262626c3531b",
        //        "cliOrdId": null,
        //        "type": "lmt",
        //        "symbol": "pi_xbtusd",
        //        "side": "buy",
        //        "quantity": 1000,
        //        "filled": 0,
        //        "limitPrice": 10144,
        //        "stopPrice": null,
        //        "reduceOnly": false,
        //        "timestamp": "2019-08-01T15:26:27.790Z"
        //    }
        //
        // FETCH OPEN ORDERS
        //
        //    {
        //        "order_id": "59302619-41d2-4f0b-941f-7e7914760ad3",
        //        "symbol": "pi_xbtusd",
        //        "side": "sell",
        //        "orderType": "lmt",
        //        "limitPrice": 10640,
        //        "unfilledSize": 304,
        //        "receivedTime": "2019-09-05T17:01:17.410Z",
        //        "status": "untouched",
        //        "filledSize": 0,
        //        "reduceOnly": true,
        //        "lastUpdateTime": "2019-09-05T17:01:17.410Z"
        //    }
        //
        // createOrders error
        //    {
        //       "status": "requiredArgumentMissing",
        //       "orderEvents": []
        //    }
        // closed orders
        //    {
        //        uid: '2f00cd63-e61d-44f8-8569-adabde885941',
        //        timestamp: '1707258274849',
        //        event: {
        //          OrderPlaced: {
        //            order: {
        //              uid: '85805e01-9eed-4395-8360-ed1a228237c9',
        //              accountUid: '406142dd-7c5c-4a8b-acbc-5f16eca30009',
        //              tradeable: 'PF_LTCUSD',
        //              direction: 'Buy',
        //              quantity: '0',
        //              filled: '0.1',
        //              timestamp: '1707258274849',
        //              limitPrice: '69.2200000000',
        //              orderType: 'IoC',
        //              clientId: '',
        //              reduceOnly: false,
        //              lastUpdateTimestamp: '1707258274849'
        //            },
        //            reason: 'new_user_order',
        //            reducedQuantity: '',
        //            algoId: ''
        //          }
        //        }
        //    }
        //
        //   {
        //     uid: '85805e01-9eed-4395-8360-ed1a228237c9',
        //     accountUid: '406142dd-7c5c-4a8b-acbc-5f16eca30009',
        //     tradeable: 'PF_LTCUSD',
        //     direction: 'Buy',
        //     quantity: '0',
        //     filled: '0.1',
        //     timestamp: '1707258274849',
        //     limitPrice: '69.2200000000',
        //     orderType: 'IoC',
        //     clientId: '',
        //     reduceOnly: false,
        //     lastUpdateTimestamp: '1707258274849',
        //     status: 'closed'
        //   }
        //
        object orderEvents = this.safeValue(order, "orderEvents", new List<object>() {});
        object errorStatus = this.safeString(order, "status");
        object orderEventsLength = getArrayLength(orderEvents);
        if (isTrue(isTrue(isTrue((inOp(order, "orderEvents"))) && isTrue((!isEqual(errorStatus, null)))) && isTrue((isEqual(orderEventsLength, 0)))))
        {
            // creteOrders error response
            return this.safeOrder(new Dictionary<string, object>() {
                { "info", order },
                { "status", "rejected" },
            });
        }
        object details = null;
        object isPrior = false;
        object fixedVar = false;
        object statusId = null;
        object price = null;
        object trades = new List<object>() {};
        if (isTrue(orderEventsLength))
        {
            object executions = new List<object>() {};
            for (object i = 0; isLessThan(i, getArrayLength(orderEvents)); postFixIncrement(ref i))
            {
                object item = getValue(orderEvents, i);
                if (isTrue(isEqual(this.safeString(item, "type"), "EXECUTION")))
                {
                    ((IList<object>)executions).Add(item);
                }
                // Final order (after placement / editing / execution / canceling)
                object orderTrigger = this.safeValue(item, "orderTrigger");
                if (isTrue(isEqual(details, null)))
                {
                    details = this.safeValue2(item, "new", "order", orderTrigger);
                    if (isTrue(!isEqual(details, null)))
                    {
                        isPrior = false;
                        fixedVar = true;
                    } else if (!isTrue(fixedVar))
                    {
                        object orderPriorExecution = this.safeValue(item, "orderPriorExecution");
                        details = this.safeValue2(item, "orderPriorExecution", "orderPriorEdit");
                        price = this.safeString(orderPriorExecution, "limitPrice");
                        if (isTrue(!isEqual(details, null)))
                        {
                            isPrior = true;
                        }
                    }
                }
            }
            trades = this.parseTrades(executions);
            statusId = this.safeString(order, "status");
        }
        if (isTrue(isEqual(details, null)))
        {
            details = order;
        }
        if (isTrue(isEqual(statusId, null)))
        {
            statusId = this.safeString(details, "status");
        }
        // This may be incorrectly marked as "open" if only execution report is given,
        // but will be fixed below
        object status = this.parseOrderStatus(statusId);
        object isClosed = this.inArray(status, new List<object>() {"canceled", "rejected", "closed"});
        object marketId = this.safeString(details, "symbol");
        market = this.safeMarket(marketId, market);
        object timestamp = this.parse8601(this.safeString2(details, "timestamp", "receivedTime"));
        object lastUpdateTimestamp = this.parse8601(this.safeString(details, "lastUpdateTime"));
        if (isTrue(isEqual(price, null)))
        {
            price = this.safeString(details, "limitPrice");
        }
        object amount = this.safeString(details, "quantity");
        object filled = this.safeString2(details, "filledSize", "filled", "0.0");
        object remaining = this.safeString(details, "unfilledSize");
        object average = null;
        object filled2 = "0.0";
        object tradesLength = getArrayLength(trades);
        if (isTrue(isGreaterThan(tradesLength, 0)))
        {
            object vwapSum = "0.0";
            for (object i = 0; isLessThan(i, getArrayLength(trades)); postFixIncrement(ref i))
            {
                object trade = getValue(trades, i);
                object tradeAmount = this.safeString(trade, "amount");
                object tradePrice = this.safeString(trade, "price");
                filled2 = Precise.stringAdd(filled2, tradeAmount);
                vwapSum = Precise.stringAdd(vwapSum, Precise.stringMul(tradeAmount, tradePrice));
            }
            average = Precise.stringDiv(vwapSum, filled2);
            if (isTrue(isTrue(isTrue(isTrue((!isEqual(amount, null))) && isTrue((!isTrue(isClosed)))) && isTrue(isPrior)) && isTrue(Precise.stringGe(filled2, amount))))
            {
                status = "closed";
                isClosed = true;
            }
            if (isTrue(isPrior))
            {
                filled = Precise.stringAdd(filled, filled2);
            } else
            {
                filled = Precise.stringMax(filled, filled2);
            }
        }
        if (isTrue(isEqual(remaining, null)))
        {
            if (isTrue(isPrior))
            {
                if (isTrue(!isEqual(amount, null)))
                {
                    // remaining amount before execution minus executed amount
                    remaining = Precise.stringSub(amount, filled2);
                }
            } else
            {
                remaining = amount;
            }
        }
        // if fetchOpenOrders are parsed
        if (isTrue(isTrue(isTrue((isEqual(amount, null))) && isTrue((!isTrue(isPrior)))) && isTrue((!isEqual(remaining, null)))))
        {
            amount = Precise.stringAdd(filled, remaining);
        }
        object cost = null;
        if (isTrue(isTrue((!isEqual(filled, null))) && isTrue((!isEqual(market, null)))))
        {
            object whichPrice = ((bool) isTrue((!isEqual(average, null)))) ? average : price;
            if (isTrue(!isEqual(whichPrice, null)))
            {
                if (isTrue(getValue(market, "linear")))
                {
                    cost = Precise.stringMul(filled, whichPrice); // in quote
                } else
                {
                    cost = Precise.stringDiv(filled, whichPrice); // in base
                }
            }
        }
        object id = this.safeString2(order, "order_id", "orderId");
        if (isTrue(isEqual(id, null)))
        {
            id = this.safeString2(details, "orderId", "uid");
        }
        object type = this.safeStringLower2(details, "type", "orderType");
        object timeInForce = "gtc";
        if (isTrue(isTrue(isEqual(type, "ioc")) || isTrue(isEqual(this.parseOrderType(type), "market"))))
        {
            timeInForce = "ioc";
        }
        object symbol = this.safeString(market, "symbol");
        if (isTrue(inOp(details, "tradeable")))
        {
            symbol = this.safeSymbol(this.safeString(details, "tradeable"), market);
        }
        object ts = this.safeInteger(details, "timestamp", timestamp);
        return this.safeOrder(new Dictionary<string, object>() {
            { "info", order },
            { "id", id },
            { "clientOrderId", this.safeStringN(details, new List<object>() {"clientOrderId", "clientId", "cliOrdId"}) },
            { "timestamp", ts },
            { "datetime", this.iso8601(ts) },
            { "lastTradeTimestamp", null },
            { "lastUpdateTimestamp", this.safeInteger(details, "lastUpdateTimestamp", lastUpdateTimestamp) },
            { "symbol", symbol },
            { "type", this.parseOrderType(type) },
            { "timeInForce", timeInForce },
            { "postOnly", isEqual(type, "post") },
            { "reduceOnly", this.safeBool2(details, "reduceOnly", "reduce_only") },
            { "side", this.safeStringLower2(details, "side", "direction") },
            { "price", price },
            { "triggerPrice", this.safeString(details, "triggerPrice") },
            { "amount", amount },
            { "cost", cost },
            { "average", average },
            { "filled", filled },
            { "remaining", remaining },
            { "status", status },
            { "fee", null },
            { "fees", null },
            { "trades", trades },
        });
    }

    /**
     * @method
     * @name krakenfutures#fetchMyTrades
     * @description fetch all trades made by the user
     * @see https://docs.kraken.com/api/docs/futures-api/trading/get-fills
     * @param {string} symbol unified market symbol
     * @param {int} [since] *not used by the  api* the earliest time in ms to fetch trades for
     * @param {int} [limit] the maximum number of trades structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {int} [params.until] the latest time in ms to fetch entries for
     * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/?id=trade-structure}
     */
    public async override Task<object> fetchMyTrades(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
        }
        // todo: lastFillTime: this.iso8601(end)
        object response = await this.privateGetFills(parameters);
        //
        //    {
        //        "result": "success",
        //        "serverTime": "2016-02-25T09:45:53.818Z",
        //        "fills": [
        //            {
        //                "fillTime": "2016-02-25T09:47:01.000Z",
        //                "order_id": "c18f0c17-9971-40e6-8e5b-10df05d422f0",
        //                "fill_id": "522d4e08-96e7-4b44-9694-bfaea8fe215e",
        //                "cliOrdId": "d427f920-ec55-4c18-ba95-5fe241513b30", // EXTRA
        //                "symbol": "fi_xbtusd_180615",
        //                "side": "buy",
        //                "size": 2000,
        //                "price": 4255,
        //                "fillType": "maker"
        //            },
        //            ...
        //        ]
        //    }
        //
        return this.parseTrades(getValue(response, "fills"), market, since, limit);
    }

    /**
     * @method
     * @name krakenfutures#fetchBalance
     * @see https://docs.kraken.com/api/docs/futures-api/trading/get-accounts
     * @description Fetch the balance for a sub-account, all sub-account balances are inside 'info' in the response
     * @param {object} [params] Exchange specific parameters
     * @param {string} [params.type] The sub-account type to query the balance of, possible values include 'flex', 'cash'/'main'/'funding', or a market symbol * defaults to 'flex' *
     * @param {string} [params.symbol] A unified market symbol, when assigned the balance for a trading market that matches the symbol is returned
     * @returns A [balance structure]{@link https://docs.ccxt.com/?id=balance-structure}
     */
    public async override Task<object> fetchBalance(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object type = this.safeString2(parameters, "type", "account");
        object symbol = this.safeString(parameters, "symbol");
        parameters = this.omit(parameters, new List<object>() {"type", "account", "symbol"});
        object response = await this.privateGetAccounts(parameters);
        //
        //    {
        //        "result": "success",
        //        "accounts": {
        //            "fi_xbtusd": {
        //                "auxiliary": { usd: "0", pv: '0.0', pnl: '0.0', af: '0.0', funding: "0.0" },
        //                "marginRequirements": { im: '0.0', mm: '0.0', lt: '0.0', tt: "0.0" },
        //                "triggerEstimates": { im: '0', mm: '0', lt: "0", tt: "0" },
        //                "balances": { xbt: "0.0" },
        //                "currency": "xbt",
        //                "type": "marginAccount"
        //            },
        //            "cash": {
        //                "balances": {
        //                    "eur": "0.0",
        //                    "gbp": "0.0",
        //                    "bch": "0.0",
        //                    "xrp": "2.20188538338",
        //                    "usd": "0.0",
        //                    "eth": "0.0",
        //                    "usdt": "0.0",
        //                    "ltc": "0.0",
        //                    "usdc": "0.0",
        //                    "xbt": "0.0"
        //                },
        //                "type": "cashAccount"
        //            },
        //            "fv_xrpxbt": {
        //                "auxiliary": { usd: "0", pv: '0.0', pnl: '0.0', af: '0.0', funding: "0.0" },
        //                "marginRequirements": { im: '0.0', mm: '0.0', lt: '0.0', tt: "0.0" },
        //                "triggerEstimates": { im: '0', mm: '0', lt: "0", tt: "0" },
        //                "balances": { xbt: "0.0" },
        //                "currency": "xbt",
        //                "type": "marginAccount"
        //            },
        //            "fi_xrpusd": {
        //                "auxiliary": { usd: "0", pv: '11.0', pnl: '0.0', af: '11.0', funding: "0.0" },
        //                "marginRequirements": { im: '0.0', mm: '0.0', lt: '0.0', tt: "0.0" },
        //                "triggerEstimates": { im: '0', mm: '0', lt: "0", tt: "0" },
        //                "balances": { xrp: "11.0" },
        //                "currency": "xrp",
        //                "type": "marginAccount"
        //            },
        //            "fi_ethusd": {
        //                "auxiliary": { usd: "0", pv: '0.0', pnl: '0.0', af: '0.0', funding: "0.0" },
        //                "marginRequirements": { im: '0.0', mm: '0.0', lt: '0.0', tt: "0.0" },
        //                "triggerEstimates": { im: '0', mm: '0', lt: "0", tt: "0" },
        //                "balances": { eth: "0.0" },
        //                "currency": "eth",
        //                "type": "marginAccount"
        //            },
        //            "fi_ltcusd": {
        //                "auxiliary": { usd: "0", pv: '0.0', pnl: '0.0', af: '0.0', funding: "0.0" },
        //                "marginRequirements": { im: '0.0', mm: '0.0', lt: '0.0', tt: "0.0" },
        //                "triggerEstimates": { im: '0', mm: '0', lt: "0", tt: "0" },
        //                "balances": { ltc: "0.0" },
        //                "currency": "ltc",
        //                "type": "marginAccount"
        //            },
        //            "fi_bchusd": {
        //                "auxiliary": { usd: "0", pv: '0.0', pnl: '0.0', af: '0.0', funding: "0.0" },
        //                "marginRequirements": { im: '0.0', mm: '0.0', lt: '0.0', tt: "0.0" },
        //                "triggerEstimates": { im: '0', mm: '0', lt: "0", tt: "0" },
        //                "balances": { bch: "0.0" },
        //                "currency": "bch",
        //                "type": "marginAccount"
        //            },
        //            "flex": {
        //                "currencies": {},
        //                "initialMargin": "0.0",
        //                "initialMarginWithOrders": "0.0",
        //                "maintenanceMargin": "0.0",
        //                "balanceValue": "0.0",
        //                "portfolioValue": "0.0",
        //                "collateralValue": "0.0",
        //                "pnl": "0.0",
        //                "unrealizedFunding": "0.0",
        //                "totalUnrealized": "0.0",
        //                "totalUnrealizedAsMargin": "0.0",
        //                "availableMargin": "0.0",
        //                "marginEquity": "0.0",
        //                "type": "multiCollateralMarginAccount"
        //            }
        //        },
        //        "serverTime": "2022-04-12T07:48:07.475Z"
        //    }
        //
        object datetime = this.safeString(response, "serverTime");
        if (isTrue(isTrue(isEqual(type, "marginAccount")) || isTrue(isEqual(type, "margin"))))
        {
            if (isTrue(isEqual(symbol, null)))
            {
                throw new ArgumentsRequired ((string)add(this.id, " fetchBalance requires symbol argument for margin accounts")) ;
            }
            type = symbol;
        }
        if (isTrue(isEqual(type, null)))
        {
            type = ((bool) isTrue((isEqual(symbol, null)))) ? "flex" : symbol;
        }
        object accountName = this.parseAccount(type);
        object accounts = this.safeValue(response, "accounts");
        object account = this.safeValue(accounts, accountName);
        if (isTrue(isEqual(account, null)))
        {
            type = ((bool) isTrue((isEqual(type, null)))) ? "" : type;
            symbol = ((bool) isTrue((isEqual(symbol, null)))) ? "" : symbol;
            throw new BadRequest ((string)add(add(this.id, " fetchBalance has no account for "), type)) ;
        }
        object balance = this.parseBalance(account);
        ((IDictionary<string,object>)balance)["info"] = response;
        ((IDictionary<string,object>)balance)["timestamp"] = this.parse8601(datetime);
        ((IDictionary<string,object>)balance)["datetime"] = datetime;
        return balance;
    }

    public override object parseBalance(object response)
    {
        //
        // cashAccount
        //
        //    {
        //        "balances": {
        //            "eur": "0.0",
        //            "gbp": "0.0",
        //            "bch": "0.0",
        //            "xrp": "2.20188538338",
        //            "usd": "0.0",
        //            "eth": "0.0",
        //            "usdt": "0.0",
        //            "ltc": "0.0",
        //            "usdc": "0.0",
        //            "xbt": "0.0"
        //        },
        //        "type": "cashAccount"
        //    }
        //
        // marginAccount e,g, fi_xrpusd
        //
        //    {
        //        "auxiliary": {
        //            "usd": "0",
        //            "pv": "11.0",
        //            "pnl": "0.0",
        //            "af": "11.0",
        //            "funding": "0.0"
        //        },
        //        "marginRequirements": { im: '0.0', mm: '0.0', lt: '0.0', tt: "0.0" },
        //        "triggerEstimates": { im: '0', mm: '0', lt: "0", tt: "0" },
        //        "balances": { xrp: "11.0" },
        //        "currency": "xrp",
        //        "type": "marginAccount"
        //    }
        //
        // flex/multiCollateralMarginAccount
        //
        //    {
        //       "currencies": {
        //            "USDT": {
        //                "quantity": "1",
        //                "value": "1.0001",
        //                "collateral": "0.9477197625",
        //                "available": "1.0"
        //             }
        //       },
        //       "initialMargin": "0.0",
        //       "initialMarginWithOrders": "0.0",
        //       "maintenanceMargin": "0.0",
        //       "balanceValue": "1.0",
        //       "portfolioValue": "1.0",
        //       "collateralValue": "0.95",
        //       "pnl": "0.0",
        //       "unrealizedFunding": "0.0",
        //       "totalUnrealized": "0.0",
        //       "totalUnrealizedAsMargin": "0.0",
        //       "availableMargin": "0.95",
        //       "marginEquity": "0.95",
        //       "type": "multiCollateralMarginAccount"
        //    }
        //
        object accountType = this.safeString2(response, "accountType", "type");
        object isFlex = (isEqual(accountType, "multiCollateralMarginAccount"));
        object isCash = (isEqual(accountType, "cashAccount"));
        object balances = this.safeValue2(response, "balances", "currencies", new Dictionary<string, object>() {});
        object result = new Dictionary<string, object>() {};
        object currencyIds = new List<object>(((IDictionary<string,object>)balances).Keys);
        for (object i = 0; isLessThan(i, getArrayLength(currencyIds)); postFixIncrement(ref i))
        {
            object currencyId = getValue(currencyIds, i);
            object balance = getValue(balances, currencyId);
            object code = this.safeCurrencyCode(currencyId);
            object splitCode = ((string)code).Split(new [] {((string)"_")}, StringSplitOptions.None).ToList<object>();
            object codeLength = getArrayLength(splitCode);
            if (isTrue(isGreaterThan(codeLength, 1)))
            {
                continue;
            }
            object account = this.account();
            if (isTrue(isFlex))
            {
                ((IDictionary<string,object>)account)["total"] = this.safeString(balance, "quantity");
                ((IDictionary<string,object>)account)["free"] = this.safeString(balance, "available");
            } else if (isTrue(isCash))
            {
                ((IDictionary<string,object>)account)["used"] = "0.0";
                ((IDictionary<string,object>)account)["total"] = balance;
            } else
            {
                object auxiliary = this.safeValue(response, "auxiliary");
                ((IDictionary<string,object>)account)["free"] = this.safeString(auxiliary, "af");
                ((IDictionary<string,object>)account)["total"] = this.safeString(auxiliary, "pv");
            }
            ((IDictionary<string,object>)result)[(string)code] = account;
        }
        return this.safeBalance(result);
    }

    /**
     * @method
     * @name krakenfutures#fetchFundingRates
     * @description fetch the current funding rates for multiple markets
     * @see https://docs.kraken.com/api/docs/futures-api/trading/get-tickers
     * @param {string[]} symbols unified market symbols
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {Order[]} an array of [funding rate structures]{@link https://docs.ccxt.com/?id=funding-rate-structure}
     */
    public async override Task<object> fetchFundingRates(object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object marketIds = this.marketIds(symbols);
        object response = await this.publicGetTickers(parameters);
        object tickers = this.safeList(response, "tickers", new List<object>() {});
        object fundingRates = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(tickers)); postFixIncrement(ref i))
        {
            object entry = getValue(tickers, i);
            object entry_symbol = this.safeValue(entry, "symbol");
            if (isTrue(!isEqual(marketIds, null)))
            {
                if (!isTrue(this.inArray(entry_symbol, marketIds)))
                {
                    continue;
                }
            }
            object market = this.safeMarket(entry_symbol);
            object parsed = this.parseFundingRate(entry, market);
            ((IList<object>)fundingRates).Add(parsed);
        }
        return ((object)this.indexBy(fundingRates, "symbol"));
    }

    public override object parseFundingRate(object ticker, object market = null)
    {
        //
        //     {
        //         "symbol": "PF_ENJUSD",
        //         "last": 0.0433,
        //         "lastTime": "2025-10-22T11:02:25.599Z",
        //         "tag": "perpetual",
        //         "pair": "ENJ:USD",
        //         "markPrice": 0.0434,
        //         "bid": 0.0433,
        //         "bidSize": 4609,
        //         "ask": 0.0435,
        //         "askSize": 4609,
        //         "vol24h": 1696,
        //         "volumeQuote": 73.5216,
        //         "openInterest": 72513.00000000000,
        //         "open24h": 0.0435,
        //         "high24h": 0.0435,
        //         "low24h": 0.0433,
        //         "lastSize": 1272,
        //         "fundingRate": -0.000000756414717067,
        //         "fundingRatePrediction": 0.000000195218676,
        //         "suspended": false,
        //         "indexPrice": 0.043392,
        //         "postOnly": false,
        //         "change24h": -0.46
        //     }
        //
        object marketId = this.safeString(ticker, "symbol");
        object symbol = this.symbol(marketId);
        object timestamp = this.parse8601(this.safeString(ticker, "lastTime"));
        object markPriceString = this.safeString(ticker, "markPrice");
        object fundingRateString = this.safeString(ticker, "fundingRate");
        object fundingRateResult = Precise.stringDiv(fundingRateString, markPriceString);
        object nextFundingRateString = this.safeString(ticker, "fundingRatePrediction");
        object nextFundingRateResult = Precise.stringDiv(nextFundingRateString, markPriceString);
        if (isTrue(isGreaterThan(fundingRateResult, "0.25")))
        {
            fundingRateResult = "0.25";
        } else if (isTrue(isGreaterThan(fundingRateResult, "-0.25")))
        {
            fundingRateResult = "-0.25";
        }
        if (isTrue(isGreaterThan(nextFundingRateResult, "0.25")))
        {
            nextFundingRateResult = "0.25";
        } else if (isTrue(isGreaterThan(nextFundingRateResult, "-0.25")))
        {
            nextFundingRateResult = "-0.25";
        }
        return new Dictionary<string, object>() {
            { "info", ticker },
            { "symbol", symbol },
            { "markPrice", this.parseNumber(markPriceString) },
            { "indexPrice", this.safeNumber(ticker, "indexPrice") },
            { "interestRate", null },
            { "estimatedSettlePrice", null },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "fundingRate", this.parseNumber(fundingRateResult) },
            { "fundingTimestamp", null },
            { "fundingDatetime", null },
            { "nextFundingRate", this.parseNumber(nextFundingRateResult) },
            { "nextFundingTimestamp", null },
            { "nextFundingDatetime", null },
            { "previousFundingRate", null },
            { "previousFundingTimestamp", null },
            { "previousFundingDatetime", null },
            { "interval", "1h" },
        };
    }

    /**
     * @method
     * @name krakenfutures#fetchFundingRateHistory
     * @description fetches historical funding rate prices
     * @see https://docs.kraken.com/api/docs/futures-api/trading/historical-funding-rates
     * @param {string} symbol unified symbol of the market to fetch the funding rate history for
     * @param {int} [since] timestamp in ms of the earliest funding rate to fetch
     * @param {int} [limit] the maximum amount of [funding rate structures]{@link https://docs.ccxt.com/?id=funding-rate-history-structure} to fetch
     * @param {object} [params] extra parameters specific to the api endpoint
     * @returns {object[]} a list of [funding rate structures]{@link https://docs.ccxt.com/?id=funding-rate-history-structure}
     */
    public async override Task<object> fetchFundingRateHistory(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchFundingRateHistory() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        if (!isTrue(getValue(market, "swap")))
        {
            throw new BadRequest ((string)add(this.id, " fetchFundingRateHistory() supports swap contracts only")) ;
        }
        object request = new Dictionary<string, object>() {
            { "symbol", ((string)getValue(market, "id")).ToUpper() },
        };
        object response = await this.publicGetHistoricalfundingrates(this.extend(request, parameters));
        //
        //    {
        //        "rates": [
        //          {
        //            "timestamp": '2018-08-31T16:00:00.000Z',
        //            "fundingRate": '2.18900669884E-7',
        //            "relativeFundingRate": '0.000060779960000000'
        //          },
        //          ...
        //        ]
        //    }
        //
        object rates = this.safeValue(response, "rates");
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(rates)); postFixIncrement(ref i))
        {
            object item = getValue(rates, i);
            object datetime = this.safeString(item, "timestamp");
            ((IList<object>)result).Add(new Dictionary<string, object>() {
                { "info", item },
                { "symbol", symbol },
                { "fundingRate", this.safeNumber(item, "relativeFundingRate") },
                { "timestamp", this.parse8601(datetime) },
                { "datetime", datetime },
            });
        }
        object sorted = this.sortBy(result, "timestamp");
        return this.filterBySymbolSinceLimit(sorted, symbol, since, limit);
    }

    /**
     * @method
     * @name krakenfutures#fetchPositions
     * @see https://docs.kraken.com/api/docs/futures-api/trading/get-open-positions
     * @description Fetches current contract trading positions
     * @param {string[]} symbols List of unified symbols
     * @param {object} [params] Not used by krakenfutures
     * @returns Parsed exchange response for positions
     */
    public async override Task<object> fetchPositions(object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object response = await this.privateGetOpenpositions(request);
        //
        //    {
        //        "result": "success",
        //        "openPositions": [
        //            {
        //                "side": "long",
        //                "symbol": "pi_xrpusd",
        //                "price": "0.7533",
        //                "fillTime": "2022-03-03T22:51:16.566Z",
        //                "size": "230",
        //                "unrealizedFunding": "-0.001878596918214635"
        //            }
        //        ],
        //        "serverTime": "2022-03-03T22:51:16.566Z"
        //    }
        //
        object result = this.parsePositions(response);
        return this.filterByArrayPositions(result, "symbol", symbols, false);
    }

    public override object parsePositions(object response, object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object result = new List<object>() {};
        object positions = this.safeValue(response, "openPositions");
        for (object i = 0; isLessThan(i, getArrayLength(positions)); postFixIncrement(ref i))
        {
            object position = this.parsePosition(getValue(positions, i));
            ((IList<object>)result).Add(position);
        }
        return result;
    }

    public override object parsePosition(object position, object market = null)
    {
        // cross
        //    {
        //        "side": "long",
        //        "symbol": "pi_xrpusd",
        //        "price": "0.7533",
        //        "fillTime": "2022-03-03T22:51:16.566Z",
        //        "size": "230",
        //        "unrealizedFunding": "-0.001878596918214635"
        //    }
        //
        // isolated
        //    {
        //        "side":"long",
        //        "symbol":"pf_ftmusd",
        //        "price":"0.4921",
        //        "fillTime":"2023-02-22T11:37:16.685Z",
        //        "size":"1",
        //        "unrealizedFunding":"-8.155240068885155E-8",
        //        "pnlCurrency":"USD",
        //        "maxFixedLeverage":"1.0"
        //    }
        //
        object leverage = this.safeNumber(position, "maxFixedLeverage");
        object marginType = "cross";
        if (isTrue(!isEqual(leverage, null)))
        {
            marginType = "isolated";
        }
        object datetime = this.safeString(position, "fillTime");
        object marketId = this.safeString(position, "symbol");
        market = this.safeMarket(marketId, market);
        return new Dictionary<string, object>() {
            { "info", position },
            { "symbol", getValue(market, "symbol") },
            { "timestamp", this.parse8601(datetime) },
            { "datetime", datetime },
            { "initialMargin", null },
            { "initialMarginPercentage", null },
            { "maintenanceMargin", null },
            { "maintenanceMarginPercentage", null },
            { "entryPrice", this.safeNumber(position, "price") },
            { "notional", null },
            { "leverage", leverage },
            { "unrealizedPnl", null },
            { "contracts", this.safeNumber(position, "size") },
            { "contractSize", this.safeNumber(market, "contractSize") },
            { "marginRatio", null },
            { "liquidationPrice", null },
            { "markPrice", null },
            { "collateral", null },
            { "marginType", marginType },
            { "side", this.safeString(position, "side") },
            { "percentage", null },
        };
    }

    /**
     * @method
     * @name krakenfutures#fetchLeverageTiers
     * @description retrieve information on the maximum leverage, and maintenance margin for trades of varying trade sizes
     * @see https://docs.kraken.com/api/docs/futures-api/trading/get-instruments
     * @param {string[]|undefined} symbols list of unified market symbols
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a dictionary of [leverage tiers structures]{@link https://docs.ccxt.com/?id=leverage-tiers-structure}, indexed by market symbols
     */
    public async override Task<object> fetchLeverageTiers(object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.publicGetInstruments(parameters);
        //
        //    {
        //        "result": "success",
        //        "instruments": [
        //            {
        //                "symbol": "fi_ethusd_180928",
        //                "type": "futures_inverse",  // futures_vanilla  // spot index
        //                "underlying": "rr_ethusd",
        //                "lastTradingTime": "2018-09-28T15:00:00.000Z",
        //                "tickSize": 0.1,
        //                "contractSize": 1,
        //                "tradeable": true,
        //                "marginLevels": [
        //                    {
        //                        "contracts":0,
        //                        "initialMargin":0.02,
        //                        "maintenanceMargin":0.01
        //                    },
        //                    {
        //                        "contracts":250000,
        //                        "initialMargin":0.04,
        //                        "maintenanceMargin":0.02
        //                    },
        //                    ...
        //                ],
        //                "isin": "GB00JVMLMP88",
        //                "retailMarginLevels": [
        //                    {
        //                        "contracts": 0,
        //                        "initialMargin": 0.5,
        //                        "maintenanceMargin": 0.25
        //                    }
        //                ],
        //                "tags": [],
        //            },
        //            {
        //                "symbol": "in_xbtusd",
        //                "type": "spot index",
        //                "tradeable":false
        //            }
        //        ]
        //        "serverTime": "2018-07-19T11:32:39.433Z"
        //    }
        //
        object data = this.safeList(response, "instruments");
        return this.parseLeverageTiers(data, symbols, "symbol");
    }

    public override object parseMarketLeverageTiers(object info, object market = null)
    {
        /**
         * @method
         * @ignore
         * @param info Exchange market response for 1 market
         * @param market CCXT market
         */
        //
        //    {
        //        "symbol": "fi_ethusd_180928",
        //        "type": "futures_inverse",  // futures_vanilla  // spot index
        //        "underlying": "rr_ethusd",
        //        "lastTradingTime": "2018-09-28T15:00:00.000Z",
        //        "tickSize": 0.1,
        //        "contractSize": 1,
        //        "tradeable": true,
        //        "marginLevels": [
        //            {
        //                "contracts":0,
        //                "initialMargin":0.02,
        //                "maintenanceMargin":0.01
        //            },
        //            {
        //                "contracts":250000,
        //                "initialMargin":0.04,
        //                "maintenanceMargin":0.02
        //            },
        //            ...
        //        ],
        //        "isin": "GB00JVMLMP88",
        //        "retailMarginLevels": [
        //            {
        //                "contracts": 0,
        //                "initialMargin": 0.5,
        //                "maintenanceMargin": 0.25
        //            }
        //        ],
        //        "tags": [],
        //    }
        //
        object marginLevels = this.safeValue(info, "marginLevels");
        object marketId = this.safeString(info, "symbol");
        market = this.safeMarket(marketId, market);
        object tiers = new List<object>() {};
        if (isTrue(isEqual(marginLevels, null)))
        {
            return tiers;
        }
        for (object i = 0; isLessThan(i, getArrayLength(marginLevels)); postFixIncrement(ref i))
        {
            object tier = getValue(marginLevels, i);
            object initialMargin = this.safeString(tier, "initialMargin");
            object minNotional = this.safeNumber(tier, "numNonContractUnits");
            if (isTrue(!isEqual(i, 0)))
            {
                object tiersLength = getArrayLength(tiers);
                object previousTier = getValue(tiers, subtract(tiersLength, 1));
                ((IDictionary<string,object>)previousTier)["maxNotional"] = minNotional;
            }
            ((IList<object>)tiers).Add(new Dictionary<string, object>() {
                { "tier", this.sum(i, 1) },
                { "symbol", this.safeSymbol(marketId, market) },
                { "currency", getValue(market, "quote") },
                { "minNotional", minNotional },
                { "maxNotional", null },
                { "maintenanceMarginRate", this.safeNumber(tier, "maintenanceMargin") },
                { "maxLeverage", this.parseNumber(Precise.stringDiv("1", initialMargin)) },
                { "info", tier },
            });
        }
        return tiers;
    }

    public override object parseTransfer(object transfer, object currency = null)
    {
        //
        // transfer
        //
        //    {
        //        "result": "success",
        //        "serverTime": "2022-04-12T01:22:53.420Z"
        //    }
        //
        object datetime = this.safeString(transfer, "serverTime");
        return new Dictionary<string, object>() {
            { "info", transfer },
            { "id", null },
            { "timestamp", this.parse8601(datetime) },
            { "datetime", datetime },
            { "currency", this.safeString(currency, "code") },
            { "amount", null },
            { "fromAccount", null },
            { "toAccount", null },
            { "status", this.safeString(transfer, "result") },
        };
    }

    public override object parseAccount(object account)
    {
        object accountByType = new Dictionary<string, object>() {
            { "main", "cash" },
            { "funding", "cash" },
            { "future", "cash" },
            { "futures", "cash" },
            { "cashAccount", "cash" },
            { "multiCollateralMarginAccount", "flex" },
            { "multiCollateral", "flex" },
            { "multiCollateralMargin", "flex" },
        };
        if (isTrue(inOp(accountByType, account)))
        {
            return getValue(accountByType, account);
        } else if (isTrue(inOp(this.markets, account)))
        {
            object market = this.market(account);
            object marketId = getValue(market, "id");
            object splitId = ((string)marketId).Split(new [] {((string)"_")}, StringSplitOptions.None).ToList<object>();
            if (isTrue(getValue(market, "inverse")))
            {
                return add("fi_", this.safeString(splitId, 1));
            } else
            {
                return add("fv_", this.safeString(splitId, 1));
            }
        } else
        {
            return account;
        }
    }

    /**
     * @method
     * @name krakenfutures#transferOut
     * @description transfer from futures wallet to spot wallet
     * @param {str} code Unified currency code
     * @param {float} amount Size of the transfer
     * @param {dict} [params] Exchange specific parameters
     * @returns a [transfer structure]{@link https://docs.ccxt.com/?id=transfer-structure}
     */
    public async virtual Task<object> transferOut(object code, object amount, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        return await this.transfer(code, amount, "future", "spot", parameters);
    }

    /**
     * @method
     * @name krakenfutures#transfer
     * @see https://docs.kraken.com/api/docs/futures-api/trading/transfer
     * @see https://docs.kraken.com/api/docs/futures-api/trading/sub-account-transfer
     * @description transfers currencies between sub-accounts
     * @param {string} code Unified currency code
     * @param {float} amount Size of the transfer
     * @param {string} fromAccount 'main'/'funding'/'future', 'flex', or a unified market symbol
     * @param {string} toAccount 'main'/'funding', 'flex', 'spot' or a unified market symbol
     * @param {object} [params] Exchange specific parameters
     * @returns a [transfer structure]{@link https://docs.ccxt.com/?id=transfer-structure}
     */
    public async override Task<object> transfer(object code, object amount, object fromAccount, object toAccount, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        if (isTrue(isEqual(fromAccount, "spot")))
        {
            throw new BadRequest ((string)add(this.id, " transfer does not yet support transfers from spot")) ;
        }
        object request = new Dictionary<string, object>() {
            { "amount", amount },
        };
        object response = null;
        if (isTrue(isEqual(toAccount, "spot")))
        {
            if (isTrue(!isEqual(this.parseAccount(fromAccount), "cash")))
            {
                throw new BadRequest ((string)add(add(add(add(this.id, " transfer cannot transfer from "), fromAccount), " to "), toAccount)) ;
            }
            ((IDictionary<string,object>)request)["currency"] = getValue(currency, "id");
            response = await this.privatePostWithdrawal(this.extend(request, parameters));
        } else
        {
            ((IDictionary<string,object>)request)["fromAccount"] = this.parseAccount(fromAccount);
            ((IDictionary<string,object>)request)["toAccount"] = this.parseAccount(toAccount);
            ((IDictionary<string,object>)request)["unit"] = getValue(currency, "id");
            response = await this.privatePostTransfer(this.extend(request, parameters));
        }
        //
        //    {
        //        "result": "success",
        //        "serverTime": "2022-04-12T01:22:53.420Z"
        //    }
        //
        object transfer = this.parseTransfer(response, currency);
        return this.extend(transfer, new Dictionary<string, object>() {
            { "amount", amount },
            { "fromAccount", fromAccount },
            { "toAccount", toAccount },
        });
    }

    /**
     * @method
     * @name krakenfutures#setLeverage
     * @description set the level of leverage for a market
     * @see https://docs.kraken.com/api/docs/futures-api/trading/set-leverage-setting
     * @param {float} leverage the rate of leverage
     * @param {string} symbol unified market symbol
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} response from the exchange
     */
    public async override Task<object> setLeverage(object leverage, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " setLeverage() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {
            { "maxLeverage", leverage },
            { "symbol", ((string)this.marketId(symbol)).ToUpper() },
        };
        //
        // { result: "success", serverTime: "2023-08-01T09:40:32.345Z" }
        //
        return await this.privatePutLeveragepreferences(this.extend(request, parameters));
    }

    /**
     * @method
     * @name krakenfutures#fetchLeverages
     * @description fetch the set leverage for all contract and margin markets
     * @see https://docs.kraken.com/api/docs/futures-api/trading/get-leverage-setting
     * @param {string[]} [symbols] a list of unified market symbols
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a list of [leverage structures]{@link https://docs.ccxt.com/?id=leverage-structure}
     */
    public async override Task<object> fetchLeverages(object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.privateGetLeveragepreferences(parameters);
        //
        //     {
        //         "result": "success",
        //         "serverTime": "2024-03-06T02:35:46.336Z",
        //         "leveragePreferences": [
        //             {
        //                 "symbol": "PF_ETHUSD",
        //                 "maxLeverage": 30.00
        //             },
        //         ]
        //     }
        //
        object leveragePreferences = this.safeList(response, "leveragePreferences", new List<object>() {});
        return this.parseLeverages(leveragePreferences, symbols, "symbol");
    }

    /**
     * @method
     * @name krakenfutures#fetchLeverage
     * @description fetch the set leverage for a market
     * @see https://docs.kraken.com/api/docs/futures-api/trading/get-leverage-setting
     * @param {string} symbol unified market symbol
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [leverage structure]{@link https://docs.ccxt.com/?id=leverage-structure}
     */
    public async override Task<object> fetchLeverage(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchLeverage() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", ((string)this.marketId(symbol)).ToUpper() },
        };
        object response = await this.privateGetLeveragepreferences(this.extend(request, parameters));
        //
        //     {
        //         "result": "success",
        //         "serverTime": "2023-08-01T09:54:08.900Z",
        //         "leveragePreferences": [ { symbol: "PF_LTCUSD", maxLeverage: "5.00" } ]
        //     }
        //
        object leveragePreferences = this.safeList(response, "leveragePreferences", new List<object>() {});
        object data = this.safeDict(leveragePreferences, 0, new Dictionary<string, object>() {});
        return this.parseLeverage(data, market);
    }

    public override object parseLeverage(object leverage, object market = null)
    {
        object marketId = this.safeString(leverage, "symbol");
        object leverageValue = this.safeInteger(leverage, "maxLeverage");
        return new Dictionary<string, object>() {
            { "info", leverage },
            { "symbol", this.safeSymbol(marketId, market) },
            { "marginMode", null },
            { "longLeverage", leverageValue },
            { "shortLeverage", leverageValue },
        };
    }

    public override object handleErrors(object code, object reason, object url, object method, object headers, object body, object response, object requestHeaders, object requestBody)
    {
        if (isTrue(isEqual(response, null)))
        {
            return null;
        }
        if (isTrue(isEqual(code, 429)))
        {
            throw new DDoSProtection ((string)add(add(this.id, " "), body)) ;
        }
        object errors = this.safeValue(response, "errors");
        object firstError = this.safeValue(errors, 0);
        object firtErrorMessage = this.safeString(firstError, "message");
        object message = this.safeString(response, "error", firtErrorMessage);
        if (isTrue(isEqual(message, null)))
        {
            return null;
        }
        object feedback = add(add(this.id, " "), body);
        this.throwExactlyMatchedException(getValue(this.exceptions, "exact"), message, feedback);
        this.throwBroadlyMatchedException(getValue(this.exceptions, "broad"), message, feedback);
        if (isTrue(isEqual(code, 400)))
        {
            throw new BadRequest ((string)feedback) ;
        }
        throw new ExchangeError ((string)feedback) ;
    }

    public override object sign(object path, object api = null, object method = null, object parameters = null, object headers = null, object body = null)
    {
        api ??= "public";
        method ??= "GET";
        parameters ??= new Dictionary<string, object>();
        object apiVersions = this.safeValue(getValue(this.options, "versions"), api, new Dictionary<string, object>() {});
        object methodVersions = this.safeValue(apiVersions, method, new Dictionary<string, object>() {});
        object defaultVersion = this.safeString(methodVersions, path, this.version);
        object version = this.safeString(parameters, "version", defaultVersion);
        parameters = this.omit(parameters, "version");
        object apiAccess = this.safeValue(getValue(this.options, "access"), api, new Dictionary<string, object>() {});
        object methodAccess = this.safeValue(apiAccess, method, new Dictionary<string, object>() {});
        object access = this.safeString(methodAccess, path, "public");
        object endpoint = add(add(version, "/"), this.implodeParams(path, parameters));
        parameters = this.omit(parameters, this.extractParams(path));
        object query = endpoint;
        object postData = "";
        if (isTrue(isEqual(path, "batchorder")))
        {
            postData = add("json=", this.json(parameters));
            body = postData;
        } else if (isTrue(getArrayLength(new List<object>(((IDictionary<string,object>)parameters).Keys))))
        {
            if (isTrue(inOp(parameters, "orderIds")))
            {
                postData = this.urlencodeWithArrayRepeat(parameters);
            } else
            {
                postData = this.urlencode(parameters);
            }
            query = add(query, add("?", postData));
        }
        object url = add(getValue(getValue(this.urls, "api"), api), query);
        if (isTrue(isTrue(isEqual(api, "private")) || isTrue(isEqual(access, "private"))))
        {
            this.checkRequiredCredentials();
            object auth = add(postData, "/api/");
            if (isTrue(!isEqual(api, "private")))
            {
                auth = add(auth, add(api, "/"));
            }
            auth = add(auth, endpoint); // 1
            object hash = this.hash(this.encode(auth), sha256, "binary"); // 2
            object secret = this.base64ToBinary(this.secret); // 3
            object signature = this.hmac(hash, secret, sha512, "base64"); // 4-5
            headers = new Dictionary<string, object>() {
                { "Content-Type", "application/x-www-form-urlencoded" },
                { "Accept", "application/json" },
                { "APIKey", this.apiKey },
                { "Authent", signature },
            };
        }
        return new Dictionary<string, object>() {
            { "url", url },
            { "method", method },
            { "body", body },
            { "headers", headers },
        };
    }
}
