namespace ccxt;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

public partial class aster : Exchange
{
    public override object describe()
    {
        return this.deepExtend(base.describe(), new Dictionary<string, object>() {
            { "id", "aster" },
            { "name", "Aster" },
            { "countries", new List<object>() {"US"} },
            { "rateLimit", 333 },
            { "hostname", "aster.markets" },
            { "certified", false },
            { "pro", true },
            { "dex", true },
            { "urls", new Dictionary<string, object>() {
                { "logo", "https://github.com/user-attachments/assets/4982201b-73cd-4d7a-8907-e69e239e9609" },
                { "www", "https://www.asterdex.com/en" },
                { "api", new Dictionary<string, object>() {
                    { "fapiPublic", "https://fapi.asterdex.com/fapi" },
                    { "fapiPrivate", "https://fapi.asterdex.com/fapi" },
                    { "sapiPublic", "https://sapi.asterdex.com/api" },
                    { "sapiPrivate", "https://sapi.asterdex.com/api" },
                } },
                { "doc", "https://github.com/asterdex/api-docs" },
                { "fees", "https://docs.asterdex.com/product/asterex-simple/fees-and-slippage" },
                { "referral", new Dictionary<string, object>() {
                    { "url", "https://www.asterdex.com/en/referral/aA1c2B" },
                    { "discount", 0.1 },
                } },
            } },
            { "has", new Dictionary<string, object>() {
                { "CORS", null },
                { "spot", false },
                { "margin", false },
                { "swap", false },
                { "future", false },
                { "option", false },
                { "addMargin", true },
                { "borrowCrossMargin", false },
                { "borrowIsolatedMargin", false },
                { "cancelAllOrders", true },
                { "cancelOrder", true },
                { "cancelOrders", true },
                { "closeAllPositions", false },
                { "closePosition", false },
                { "createConvertTrade", false },
                { "createDepositAddress", false },
                { "createLimitBuyOrder", false },
                { "createLimitSellOrder", false },
                { "createMarketBuyOrder", false },
                { "createMarketBuyOrderWithCost", false },
                { "createMarketOrderWithCost", false },
                { "createMarketSellOrder", false },
                { "createMarketSellOrderWithCost", false },
                { "createOrder", true },
                { "createOrders", false },
                { "createOrderWithTakeProfitAndStopLoss", false },
                { "createPostOnlyOrder", false },
                { "createReduceOnlyOrder", false },
                { "createStopLimitOrder", false },
                { "createStopLossOrder", false },
                { "createStopMarketOrder", false },
                { "createStopOrder", false },
                { "createTakeProfitOrder", false },
                { "createTrailingPercentOrder", false },
                { "createTriggerOrder", false },
                { "editOrder", false },
                { "editOrders", false },
                { "fetchAccounts", null },
                { "fetchBalance", true },
                { "fetchBidsAsks", false },
                { "fetchBorrowInterest", false },
                { "fetchBorrowRateHistories", false },
                { "fetchBorrowRateHistory", false },
                { "fetchCanceledAndClosedOrders", "emulated" },
                { "fetchCanceledOrders", "emulated" },
                { "fetchClosedOrder", false },
                { "fetchClosedOrders", "emulated" },
                { "fetchConvertCurrencies", false },
                { "fetchConvertQuote", false },
                { "fetchConvertTrade", false },
                { "fetchConvertTradeHistory", false },
                { "fetchCrossBorrowRate", false },
                { "fetchCrossBorrowRates", false },
                { "fetchCurrencies", true },
                { "fetchDeposit", false },
                { "fetchDepositAddress", false },
                { "fetchDepositAddresses", false },
                { "fetchDepositAddressesByNetwork", false },
                { "fetchDeposits", false },
                { "fetchDepositsWithdrawals", false },
                { "fetchDepositWithdrawFee", "emulated" },
                { "fetchDepositWithdrawFees", false },
                { "fetchFundingHistory", true },
                { "fetchFundingInterval", "emulated" },
                { "fetchFundingIntervals", true },
                { "fetchFundingRate", true },
                { "fetchFundingRateHistory", true },
                { "fetchFundingRates", true },
                { "fetchGreeks", false },
                { "fetchIndexOHLCV", false },
                { "fetchIsolatedBorrowRate", "emulated" },
                { "fetchIsolatedBorrowRates", false },
                { "fetchL3OrderBook", false },
                { "fetchLastPrices", false },
                { "fetchLedger", true },
                { "fetchLedgerEntry", false },
                { "fetchLeverage", "emulated" },
                { "fetchLeverages", true },
                { "fetchLeverageTiers", false },
                { "fetchLiquidations", false },
                { "fetchLongShortRatio", false },
                { "fetchLongShortRatioHistory", false },
                { "fetchMarginAdjustmentHistory", true },
                { "fetchMarginMode", "emulated" },
                { "fetchMarginModes", true },
                { "fetchMarketLeverageTiers", "emulated" },
                { "fetchMarkets", true },
                { "fetchMarkOHLCV", false },
                { "fetchMarkPrice", false },
                { "fetchMarkPrices", false },
                { "fetchMyLiquidations", false },
                { "fetchMySettlementHistory", false },
                { "fetchMyTrades", true },
                { "fetchOHLCV", true },
                { "fetchOpenInterest", false },
                { "fetchOpenInterestHistory", false },
                { "fetchOpenOrder", true },
                { "fetchOpenOrders", true },
                { "fetchOption", false },
                { "fetchOptionChain", false },
                { "fetchOrder", true },
                { "fetchOrderBook", true },
                { "fetchOrderBooks", false },
                { "fetchOrders", true },
                { "fetchOrderTrades", false },
                { "fetchPosition", false },
                { "fetchPositionHistory", false },
                { "fetchPositionMode", true },
                { "fetchPositions", true },
                { "fetchPositionsHistory", false },
                { "fetchPositionsRisk", true },
                { "fetchPremiumIndexOHLCV", false },
                { "fetchSettlementHistory", false },
                { "fetchStatus", false },
                { "fetchTicker", true },
                { "fetchTickers", true },
                { "fetchTime", true },
                { "fetchTrades", true },
                { "fetchTradingFee", true },
                { "fetchTradingFees", false },
                { "fetchTradingLimits", "emulated" },
                { "fetchTransactionFee", "emulated" },
                { "fetchTransactionFees", false },
                { "fetchTransactions", false },
                { "fetchTransfer", false },
                { "fetchTransfers", false },
                { "fetchUnderlyingAssets", false },
                { "fetchVolatilityHistory", false },
                { "fetchWithdrawAddresses", false },
                { "fetchWithdrawal", false },
                { "fetchWithdrawals", false },
                { "fetchWithdrawalWhitelist", false },
                { "reduceMargin", true },
                { "repayCrossMargin", false },
                { "repayIsolatedMargin", false },
                { "sandbox", false },
                { "setLeverage", true },
                { "setMargin", false },
                { "setMarginMode", true },
                { "setPositionMode", true },
                { "signIn", false },
                { "transfer", true },
                { "withdraw", true },
            } },
            { "api", new Dictionary<string, object>() {
                { "fapiPublic", new Dictionary<string, object>() {
                    { "get", new List<object>() {"v1/ping", "v1/time", "v1/exchangeInfo", "v1/depth", "v1/trades", "v1/historicalTrades", "v1/aggTrades", "v1/klines", "v1/indexPriceKlines", "v1/markPriceKlines", "v1/premiumIndex", "v1/fundingRate", "v1/fundingInfo", "v1/ticker/24hr", "v1/ticker/price", "v1/ticker/bookTicker", "v1/adlQuantile", "v1/forceOrders"} },
                    { "post", new List<object>() {"v1/listenKey"} },
                    { "put", new List<object>() {"v1/listenKey"} },
                    { "delete", new List<object>() {"v1/listenKey"} },
                } },
                { "fapiPrivate", new Dictionary<string, object>() {
                    { "get", new List<object>() {"v1/positionSide/dual", "v1/multiAssetsMargin", "v1/order", "v1/openOrder", "v1/openOrders", "v1/allOrders", "v2/balance", "v3/balance", "v3/account", "v4/account", "v1/positionMargin/history", "v2/positionRisk", "v3/positionRisk", "v1/userTrades", "v1/income", "v1/leverageBracket", "v1/commissionRate"} },
                    { "post", new List<object>() {"v1/positionSide/dual", "v1/multiAssetsMargin", "v1/order", "v1/order/test", "v1/batchOrders", "v1/asset/wallet/transfer", "v1/countdownCancelAll", "v1/leverage", "v1/marginType", "v1/positionMargin"} },
                    { "delete", new List<object>() {"v1/order", "v1/allOpenOrders", "v1/batchOrders"} },
                } },
                { "sapiPublic", new Dictionary<string, object>() {
                    { "get", new List<object>() {"v1/ping", "v1/time", "v1/exchangeInfo", "v1/depth", "v1/trades", "v1/historicalTrades", "v1/aggTrades", "v1/klines", "v1/ticker/24hr", "v1/ticker/price", "v1/ticker/bookTicker", "v1/aster/withdraw/estimateFee"} },
                    { "post", new List<object>() {"v1/getNonce", "v1/createApiKey", "v1/listenKey"} },
                    { "put", new List<object>() {"v1/listenKey"} },
                    { "delete", new List<object>() {"v1/listenKey"} },
                } },
                { "sapiPrivate", new Dictionary<string, object>() {
                    { "get", new List<object>() {"v1/commissionRate", "v1/order", "v1/openOrders", "v1/allOrders", "v1/transactionHistory", "v1/account", "v1/userTrades"} },
                    { "post", new List<object>() {"v1/order", "v1/asset/wallet/transfer", "v1/asset/sendToAddress", "v1/aster/user-withdraw"} },
                    { "delete", new List<object>() {"v1/order", "v1/allOpenOrders"} },
                } },
            } },
            { "timeframes", new Dictionary<string, object>() {
                { "1m", "1m" },
                { "3m", "3m" },
                { "5m", "5m" },
                { "15m", "15m" },
                { "30m", "30m" },
                { "1h", "1h" },
                { "2h", "2h" },
                { "4h", "4h" },
                { "6h", "6h" },
                { "8h", "8h" },
                { "12h", "12h" },
                { "1d", "1d" },
                { "3d", "3d" },
                { "1w", "1w" },
                { "1M", "1M" },
            } },
            { "precisionMode", TICK_SIZE },
            { "requiredCredentials", new Dictionary<string, object>() {
                { "apiKey", true },
                { "secret", true },
            } },
            { "fees", new Dictionary<string, object>() {
                { "trading", new Dictionary<string, object>() {
                    { "tierBased", true },
                    { "percentage", true },
                    { "maker", this.parseNumber("0.0001") },
                    { "taker", this.parseNumber("0.00035") },
                } },
            } },
            { "options", new Dictionary<string, object>() {
                { "recvWindow", multiply(10, 1000) },
                { "defaultTimeInForce", "GTC" },
                { "zeroAddress", "0x0000000000000000000000000000000000000000" },
                { "quoteOrderQty", true },
                { "accountsByType", new Dictionary<string, object>() {
                    { "spot", "SPOT" },
                    { "future", "FUTURE" },
                    { "linear", "FUTURE" },
                    { "swap", "FUTURE" },
                } },
                { "networks", new Dictionary<string, object>() {
                    { "ERC20", "ETH" },
                    { "BEP20", "BSC" },
                    { "ARB", "Arbitrum" },
                } },
                { "networksToChainId", new Dictionary<string, object>() {
                    { "ETH", 1 },
                    { "BSC", 56 },
                    { "Arbitrum", 42161 },
                } },
            } },
            { "exceptions", new Dictionary<string, object>() {
                { "exact", new Dictionary<string, object>() {
                    { "-1000", typeof(OperationFailed) },
                    { "-1001", typeof(NetworkError) },
                    { "-1002", typeof(AuthenticationError) },
                    { "-1003", typeof(RateLimitExceeded) },
                    { "-1004", typeof(DuplicateOrderId) },
                    { "-1005", typeof(BadRequest) },
                    { "-1006", typeof(BadResponse) },
                    { "-1007", typeof(RequestTimeout) },
                    { "-1010", typeof(OperationFailed) },
                    { "-1011", typeof(PermissionDenied) },
                    { "-1013", typeof(BadRequest) },
                    { "-1014", typeof(OrderNotFillable) },
                    { "-1015", typeof(RateLimitExceeded) },
                    { "-1016", typeof(ExchangeClosedByUser) },
                    { "-1020", typeof(NotSupported) },
                    { "-1021", typeof(InvalidNonce) },
                    { "-1022", typeof(AuthenticationError) },
                    { "-1023", typeof(BadRequest) },
                    { "-1100", typeof(BadRequest) },
                    { "-1101", typeof(BadRequest) },
                    { "-1102", typeof(ArgumentsRequired) },
                    { "-1103", typeof(BadRequest) },
                    { "-1104", typeof(BadRequest) },
                    { "-1105", typeof(ArgumentsRequired) },
                    { "-1106", typeof(BadRequest) },
                    { "-1108", typeof(BadRequest) },
                    { "-1109", typeof(BadRequest) },
                    { "-1110", typeof(BadSymbol) },
                    { "-1111", typeof(BadRequest) },
                    { "-1112", typeof(BadRequest) },
                    { "-1113", typeof(BadRequest) },
                    { "-1114", typeof(BadRequest) },
                    { "-1115", typeof(InvalidOrder) },
                    { "-1116", typeof(InvalidOrder) },
                    { "-1117", typeof(InvalidOrder) },
                    { "-1118", typeof(InvalidOrder) },
                    { "-1119", typeof(InvalidOrder) },
                    { "-1120", typeof(BadRequest) },
                    { "-1121", typeof(BadSymbol) },
                    { "-1125", typeof(AuthenticationError) },
                    { "-1127", typeof(BadRequest) },
                    { "-1128", typeof(BadRequest) },
                    { "-1130", typeof(BadRequest) },
                    { "-1136", typeof(InvalidOrder) },
                    { "-2010", typeof(InvalidOrder) },
                    { "-2011", typeof(OrderNotFound) },
                    { "-2013", typeof(OrderNotFound) },
                    { "-2014", typeof(AuthenticationError) },
                    { "-2015", typeof(AuthenticationError) },
                    { "-2016", typeof(MarketClosed) },
                    { "-2018", typeof(InsufficientFunds) },
                    { "-2019", typeof(InsufficientFunds) },
                    { "-2020", typeof(OrderNotFillable) },
                    { "-2021", typeof(OrderImmediatelyFillable) },
                    { "-2022", typeof(OperationRejected) },
                    { "-2023", typeof(AccountSuspended) },
                    { "-2024", typeof(InsufficientFunds) },
                    { "-2025", typeof(RateLimitExceeded) },
                    { "-2026", typeof(NotSupported) },
                    { "-2027", typeof(BadRequest) },
                    { "-2028", typeof(BadRequest) },
                    { "-4000", typeof(InvalidOrder) },
                    { "-4001", typeof(InvalidOrder) },
                    { "-4002", typeof(InvalidOrder) },
                    { "-4003", typeof(InvalidOrder) },
                    { "-4004", typeof(InvalidOrder) },
                    { "-4005", typeof(InvalidOrder) },
                    { "-4006", typeof(InvalidOrder) },
                    { "-4007", typeof(InvalidOrder) },
                    { "-4008", typeof(InvalidOrder) },
                    { "-4009", typeof(InvalidOrder) },
                    { "-4010", typeof(InvalidOrder) },
                    { "-4011", typeof(InvalidOrder) },
                    { "-4012", typeof(RateLimitExceeded) },
                    { "-4013", typeof(InvalidOrder) },
                    { "-4014", typeof(InvalidOrder) },
                    { "-4015", typeof(InvalidOrder) },
                    { "-4016", typeof(InvalidOrder) },
                    { "-4017", typeof(InvalidOrder) },
                    { "-4018", typeof(InvalidOrder) },
                    { "-4019", typeof(BadRequest) },
                    { "-4020", typeof(BadRequest) },
                    { "-4021", typeof(BadRequest) },
                    { "-4022", typeof(MarketClosed) },
                    { "-4023", typeof(InvalidOrder) },
                    { "-4024", typeof(InvalidOrder) },
                    { "-4025", typeof(BadRequest) },
                    { "-4026", typeof(BadRequest) },
                    { "-4027", typeof(BadRequest) },
                    { "-4028", typeof(BadRequest) },
                    { "-4029", typeof(BadRequest) },
                    { "-4030", typeof(BadRequest) },
                    { "-4031", typeof(BadRequest) },
                    { "-4032", typeof(RateLimitExceeded) },
                    { "-4033", typeof(AccountNotEnabled) },
                    { "-4044", typeof(BadRequest) },
                    { "-4045", typeof(RateLimitExceeded) },
                    { "-4046", typeof(NoChange) },
                    { "-4047", typeof(OperationRejected) },
                    { "-4048", typeof(OperationRejected) },
                    { "-4049", typeof(OperationRejected) },
                    { "-4050", typeof(InsufficientFunds) },
                    { "-4051", typeof(InsufficientFunds) },
                    { "-4052", typeof(NoChange) },
                    { "-4053", typeof(OperationRejected) },
                    { "-4054", typeof(OperationRejected) },
                    { "-4055", typeof(ArgumentsRequired) },
                    { "-4056", typeof(AuthenticationError) },
                    { "-4057", typeof(AuthenticationError) },
                    { "-4058", typeof(InvalidOrder) },
                    { "-4059", typeof(NoChange) },
                    { "-4060", typeof(InvalidOrder) },
                    { "-4061", typeof(InvalidOrder) },
                    { "-4062", typeof(OperationRejected) },
                    { "-4063", typeof(BadRequest) },
                    { "-4064", typeof(BadRequest) },
                    { "-4065", typeof(BadRequest) },
                    { "-4066", typeof(BadRequest) },
                    { "-4067", typeof(OperationRejected) },
                    { "-4068", typeof(OperationRejected) },
                    { "-4069", typeof(BadRequest) },
                    { "-4070", typeof(InvalidOrder) },
                    { "-4071", typeof(InvalidOrder) },
                    { "-4072", typeof(NoChange) },
                    { "-4073", typeof(BadRequest) },
                    { "-4074", typeof(InvalidOrder) },
                    { "-4075", typeof(OperationRejected) },
                    { "-4076", typeof(OperationRejected) },
                    { "-4077", typeof(RateLimitExceeded) },
                    { "-4078", typeof(BadRequest) },
                    { "-4079", typeof(BadRequest) },
                    { "-4080", typeof(BadRequest) },
                    { "-4081", typeof(BadRequest) },
                    { "-4082", typeof(RateLimitExceeded) },
                    { "-4083", typeof(OperationFailed) },
                    { "-4084", typeof(NotSupported) },
                    { "-4085", typeof(BadRequest) },
                    { "-4086", typeof(BadRequest) },
                    { "-4087", typeof(PermissionDenied) },
                    { "-4088", typeof(PermissionDenied) },
                    { "-4104", typeof(BadSymbol) },
                    { "-4114", typeof(InvalidOrder) },
                    { "-4115", typeof(DuplicateOrderId) },
                    { "-4118", typeof(InsufficientFunds) },
                    { "-4131", typeof(InvalidOrder) },
                    { "-4135", typeof(InvalidOrder) },
                    { "-4137", typeof(InvalidOrder) },
                    { "-4138", typeof(OperationRejected) },
                    { "-4139", typeof(InvalidOrder) },
                    { "-4140", typeof(OperationRejected) },
                    { "-4141", typeof(MarketClosed) },
                    { "-4142", typeof(InvalidOrder) },
                    { "-4144", typeof(BadSymbol) },
                    { "-4161", typeof(OperationRejected) },
                    { "-4164", typeof(InvalidOrder) },
                    { "-4165", typeof(BadRequest) },
                    { "-4183", typeof(InvalidOrder) },
                    { "-4184", typeof(InvalidOrder) },
                    { "-5060", typeof(OperationRejected) },
                    { "-5076", typeof(OperationRejected) },
                } },
                { "broad", new Dictionary<string, object>() {} },
            } },
        });
    }

    public virtual object isInverse(object type, object subType = null)
    {
        if (isTrue(isEqual(subType, null)))
        {
            return (isEqual(type, "delivery"));
        } else
        {
            return isEqual(subType, "inverse");
        }
    }

    public virtual object isLinear(object type, object subType = null)
    {
        if (isTrue(isEqual(subType, null)))
        {
            return isTrue((isEqual(type, "future"))) || isTrue((isEqual(type, "swap")));
        } else
        {
            return isEqual(subType, "linear");
        }
    }

    /**
     * @method
     * @name aster#fetchCurrencies
     * @description fetches all available currencies on an exchange
     * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-spot-api.md#trading-specification-information
     * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-futures-api.md#exchange-information
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} an associative dictionary of currencies
     */
    public async override Task<object> fetchCurrencies(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object promises = new List<object> {this.sapiPublicGetV1ExchangeInfo(parameters), this.fapiPublicGetV1ExchangeInfo(parameters)};
        object results = await promiseAll(promises);
        object sapiResult = this.safeDict(results, 0, new Dictionary<string, object>() {});
        object sapiRows = this.safeList(sapiResult, "assets", new List<object>() {});
        object fapiResult = this.safeDict(results, 1, new Dictionary<string, object>() {});
        object fapiRows = this.safeList(fapiResult, "assets", new List<object>() {});
        object rows = this.arrayConcat(sapiRows, fapiRows);
        //
        //     [
        //         {
        //             "asset": "USDT",
        //             "marginAvailable": true,
        //             "autoAssetExchange": "-10000"
        //         }
        //     ]
        //
        object result = new Dictionary<string, object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(rows)); postFixIncrement(ref i))
        {
            object currency = getValue(rows, i);
            object currencyId = this.safeString(currency, "asset");
            object code = this.safeCurrencyCode(currencyId);
            ((IDictionary<string,object>)result)[(string)code] = this.safeCurrencyStructure(new Dictionary<string, object>() {
                { "info", currency },
                { "code", code },
                { "id", currencyId },
                { "name", code },
                { "active", null },
                { "deposit", null },
                { "withdraw", null },
                { "fee", null },
                { "precision", null },
                { "limits", new Dictionary<string, object>() {
                    { "amount", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                    { "withdraw", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                    { "deposit", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                } },
                { "networks", null },
                { "type", "crypto" },
            });
        }
        return result;
    }

    /**
     * @method
     * @name aster#fetchMarkets
     * @description retrieves data on all markets for bigone
     * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-spot-api.md#trading-specification-information
     * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-futures-api.md#exchange-information
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} an array of objects representing market data
     */
    public async override Task<object> fetchMarkets(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object promises = new List<object> {this.sapiPublicGetV1ExchangeInfo(parameters), this.fapiPublicGetV1ExchangeInfo(parameters)};
        object results = await promiseAll(promises);
        object sapiResult = this.safeDict(results, 0, new Dictionary<string, object>() {});
        object sapiRows = this.safeList(sapiResult, "symbols", new List<object>() {});
        object fapiResult = this.safeDict(results, 1, new Dictionary<string, object>() {});
        object fapiRows = this.safeList(fapiResult, "symbols", new List<object>() {});
        object rows = this.arrayConcat(sapiRows, fapiRows);
        //
        //     [
        //         {
        //             "symbol": "BTCUSDT",
        //             "pair": "BTCUSDT",
        //             "contractType": "PERPETUAL",
        //             "deliveryDate": 4133404800000,
        //             "onboardDate": 1627628400000,
        //             "status": "TRADING",
        //             "maintMarginPercent": "2.5000",
        //             "requiredMarginPercent": "5.0000",
        //             "baseAsset": "BTC",
        //             "quoteAsset": "USDT",
        //             "marginAsset": "USDT",
        //             "pricePrecision": 1,
        //             "quantityPrecision": 3,
        //             "baseAssetPrecision": 8,
        //             "quotePrecision": 8,
        //             "underlyingType": "COIN",
        //             "underlyingSubType": [],
        //             "settlePlan": 0,
        //             "triggerProtect": "0.0200",
        //             "liquidationFee": "0.025000",
        //             "marketTakeBound": "0.02",
        //             "filters": [
        //                 {
        //                     "minPrice": "1",
        //                     "maxPrice": "1000000",
        //                     "filterType": "PRICE_FILTER",
        //                     "tickSize": "0.1"
        //                 },
        //                 {
        //                     "stepSize": "0.001",
        //                     "filterType": "LOT_SIZE",
        //                     "maxQty": "100",
        //                     "minQty": "0.001"
        //                 },
        //                 {
        //                     "stepSize": "0.001",
        //                     "filterType": "MARKET_LOT_SIZE",
        //                     "maxQty": "10",
        //                     "minQty": "0.001"
        //                 },
        //                 {
        //                     "limit": 200,
        //                     "filterType": "MAX_NUM_ORDERS"
        //                 },
        //                 {
        //                     "limit": 10,
        //                     "filterType": "MAX_NUM_ALGO_ORDERS"
        //                 },
        //                 {
        //                     "notional": "5",
        //                     "filterType": "MIN_NOTIONAL"
        //                 },
        //                 {
        //                     "multiplierDown": "0.9800",
        //                     "multiplierUp": "1.0200",
        //                     "multiplierDecimal": "4",
        //                     "filterType": "PERCENT_PRICE"
        //                 }
        //             ],
        //             "orderTypes": [
        //                 "LIMIT",
        //                 "MARKET",
        //                 "STOP",
        //                 "STOP_MARKET",
        //                 "TAKE_PROFIT",
        //                 "TAKE_PROFIT_MARKET",
        //                 "TRAILING_STOP_MARKET"
        //             ],
        //             "timeInForce": [
        //                 "GTC",
        //                 "IOC",
        //                 "FOK",
        //                 "GTX",
        //                 "RPI"
        //             ]
        //         }
        //     ]
        //
        object fees = this.fees;
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(rows)); postFixIncrement(ref i))
        {
            object swap = false;
            object market = getValue(rows, i);
            object id = this.safeString(market, "symbol");
            object baseId = this.safeString(market, "baseAsset");
            object quoteId = this.safeString(market, "quoteAsset");
            object bs = this.safeCurrencyCode(baseId);
            object quote = this.safeCurrencyCode(quoteId);
            object contractType = this.safeString(market, "contractType");
            object contract = !isEqual(contractType, null);
            object spot = true;
            if (isTrue(isEqual(contractType, "PERPETUAL")))
            {
                swap = true;
                spot = false;
            }
            object contractSize = null;
            object linear = null;
            object inverse = null;
            object symbol = add(add(bs, "/"), quote);
            object settle = null;
            object settleId = null;
            if (isTrue(contract))
            {
                settleId = this.safeString(market, "marginAsset");
                settle = this.safeCurrencyCode(settleId);
                if (isTrue(swap))
                {
                    symbol = add(add(symbol, ":"), settle);
                }
                linear = isEqual(settle, quote);
                inverse = isEqual(settle, bs);
                contractSize = this.safeNumber2(market, "contractSize", "unit", this.parseNumber("1"));
            }
            object unifiedType = null;
            if (isTrue(spot))
            {
                unifiedType = "spot";
            } else if (isTrue(swap))
            {
                unifiedType = "swap";
            }
            object status = this.safeString(market, "status");
            object active = isEqual(status, "TRADING");
            object filters = this.safeList(market, "filters", new List<object>() {});
            object filtersByType = this.indexBy(filters, "filterType");
            object entry = this.safeMarketStructure(new Dictionary<string, object>() {
                { "id", id },
                { "symbol", symbol },
                { "base", bs },
                { "quote", quote },
                { "settle", settle },
                { "baseId", baseId },
                { "quoteId", quoteId },
                { "settleId", settleId },
                { "type", unifiedType },
                { "spot", spot },
                { "margin", false },
                { "swap", swap },
                { "future", false },
                { "option", false },
                { "active", active },
                { "contract", contract },
                { "linear", linear },
                { "inverse", inverse },
                { "taker", getValue(getValue(fees, "trading"), "taker") },
                { "maker", getValue(getValue(fees, "trading"), "maker") },
                { "contractSize", contractSize },
                { "expiry", null },
                { "expiryDatetime", null },
                { "strike", null },
                { "optionType", null },
                { "precision", new Dictionary<string, object>() {
                    { "amount", this.parseNumber(this.parsePrecision(this.safeString(market, "quantityPrecision"))) },
                    { "price", this.parseNumber(this.parsePrecision(this.safeString(market, "pricePrecision"))) },
                    { "base", this.parseNumber(this.parsePrecision(this.safeString(market, "baseAssetPrecision"))) },
                    { "quote", this.parseNumber(this.parsePrecision(this.safeString(market, "quotePrecision"))) },
                } },
                { "limits", new Dictionary<string, object>() {
                    { "leverage", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                    { "amount", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                    { "price", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                    { "cost", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                } },
                { "created", this.safeInteger(market, "onboardDate") },
                { "info", market },
            });
            if (isTrue(inOp(filtersByType, "PRICE_FILTER")))
            {
                object filter = this.safeDict(filtersByType, "PRICE_FILTER", new Dictionary<string, object>() {});
                ((IDictionary<string,object>)getValue(entry, "limits"))["price"] = new Dictionary<string, object>() {
                    { "min", this.safeNumber(filter, "minPrice") },
                    { "max", this.safeNumber(filter, "maxPrice") },
                };
                ((IDictionary<string,object>)getValue(entry, "precision"))["price"] = this.safeNumber(filter, "tickSize");
            }
            if (isTrue(inOp(filtersByType, "LOT_SIZE")))
            {
                object filter = this.safeDict(filtersByType, "LOT_SIZE", new Dictionary<string, object>() {});
                ((IDictionary<string,object>)getValue(entry, "precision"))["amount"] = this.safeNumber(filter, "stepSize");
                ((IDictionary<string,object>)getValue(entry, "limits"))["amount"] = new Dictionary<string, object>() {
                    { "min", this.safeNumber(filter, "minQty") },
                    { "max", this.safeNumber(filter, "maxQty") },
                };
            }
            if (isTrue(inOp(filtersByType, "MARKET_LOT_SIZE")))
            {
                object filter = this.safeDict(filtersByType, "MARKET_LOT_SIZE", new Dictionary<string, object>() {});
                ((IDictionary<string,object>)getValue(entry, "limits"))["market"] = new Dictionary<string, object>() {
                    { "min", this.safeNumber(filter, "minQty") },
                    { "max", this.safeNumber(filter, "maxQty") },
                };
            }
            if (isTrue(isTrue((inOp(filtersByType, "MIN_NOTIONAL"))) || isTrue((inOp(filtersByType, "NOTIONAL")))))
            {
                object filter = this.safeDict2(filtersByType, "MIN_NOTIONAL", "NOTIONAL", new Dictionary<string, object>() {});
                ((IDictionary<string,object>)getValue(getValue(entry, "limits"), "cost"))["min"] = this.safeNumber(filter, "notional");
            }
            ((IList<object>)result).Add(entry);
        }
        return result;
    }

    /**
     * @method
     * @name aster#fetchTime
     * @description fetches the current integer timestamp in milliseconds from the exchange server
     * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-futures-api.md#check-server-time
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {int} the current integer timestamp in milliseconds from the exchange server
     */
    public async override Task<object> fetchTime(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object response = await this.fapiPublicGetV1Time(parameters);
        //
        //     {
        //         "serverTime": 1499827319559
        //     }
        //
        return this.safeInteger(response, "serverTime");
    }

    public override object parseOHLCV(object ohlcv, object market = null)
    {
        //
        //     [
        //         1631158560000,
        //         "208.1850",
        //         "208.1850",
        //         "208.1850",
        //         "208.1850",
        //         "11.84",
        //         1631158619999,
        //         "2464.910400",
        //         1,
        //         "11.84",
        //         "2464.910400",
        //         "0"
        //     ]
        //
        return new List<object> {this.safeInteger(ohlcv, 0), this.safeNumber(ohlcv, 1), this.safeNumber(ohlcv, 2), this.safeNumber(ohlcv, 3), this.safeNumber(ohlcv, 4), this.safeNumber(ohlcv, 5)};
    }

    /**
     * @method
     * @name aster#fetchOHLCV
     * @description fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
     * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-spot-api.md#k-line-data
     * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-futures-api.md#klinecandlestick-data
     * @param {string} symbol unified symbol of the market to fetch OHLCV data for
     * @param {string} timeframe the length of time each candle represents
     * @param {int} [since] timestamp in ms of the earliest candle to fetch
     * @param {int} [limit] the maximum amount of candles to fetch
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.price] "mark" or "index" for mark price and index price candles
     * @param {int} [params.until] the latest time in ms to fetch orders for
     * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
     */
    public async override Task<object> fetchOHLCV(object symbol, object timeframe = null, object since = null, object limit = null, object parameters = null)
    {
        timeframe ??= "1m";
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchOHLCV() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {};
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["startTime"] = since;
        }
        if (isTrue(!isEqual(limit, null)))
        {
            if (isTrue(isGreaterThan(limit, 1500)))
            {
                limit = 1500; // Default 500; max 1500.
            }
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        var requestparametersVariable = this.handleUntilOption("endTime", request, parameters);
        request = ((IList<object>)requestparametersVariable)[0];
        parameters = ((IList<object>)requestparametersVariable)[1];
        ((IDictionary<string,object>)request)["interval"] = this.safeString(this.timeframes, timeframe, timeframe);
        object price = this.safeString(parameters, "price");
        object isMark = (isEqual(price, "mark"));
        object isIndex = (isEqual(price, "index"));
        parameters = this.omit(parameters, "price");
        object response = null;
        if (isTrue(isMark))
        {
            ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
            response = await this.fapiPublicGetV1MarkPriceKlines(this.extend(request, parameters));
        } else if (isTrue(isIndex))
        {
            ((IDictionary<string,object>)request)["pair"] = getValue(market, "id");
            response = await this.fapiPublicGetV1IndexPriceKlines(this.extend(request, parameters));
        } else
        {
            ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
            if (isTrue(getValue(market, "linear")))
            {
                response = await this.fapiPublicGetV1Klines(this.extend(request, parameters));
            } else
            {
                response = await this.sapiPublicGetV1Klines(this.extend(request, parameters));
            }
        }
        //
        //     [
        //         [
        //             1631158560000,
        //             "208.1850",
        //             "208.1850",
        //             "208.1850",
        //             "208.1850",
        //             "11.84",
        //             1631158619999,
        //             "2464.910400",
        //             1,
        //             "11.84",
        //             "2464.910400",
        //             "0"
        //         ]
        //     ]
        //
        return this.parseOHLCVs(response, market, timeframe, since, limit);
    }

    public override object parseTrade(object trade, object market = null)
    {
        //
        // fetchTrades
        //
        //     {
        //         "id": 3913206,
        //         "price": "644.100",
        //         "qty": "0.08",
        //         "quoteQty": "51.528",
        //         "time": 1749784506633,
        //         "isBuyerMaker": true
        //     }
        //
        //     {
        //         "id": 657,
        //         "price": "1.01000000",
        //         "qty": "5.00000000",
        //         "baseQty": "4.95049505",
        //         "time": 1755156533943,
        //         "isBuyerMaker": false
        //     }
        //
        // fetchMyTrades
        //
        //     {
        //         "buyer": false,
        //         "commission": "-0.07819010",
        //         "commissionAsset": "USDT",
        //         "id": 698759,
        //         "maker": false,
        //         "orderId": 25851813,
        //         "price": "7819.01",
        //         "qty": "0.002",
        //         "quoteQty": "15.63802",
        //         "realizedPnl": "-0.91539999",
        //         "side": "SELL",
        //         "positionSide": "SHORT",
        //         "symbol": "BTCUSDT",
        //         "time": 1569514978020
        //     }
        //
        object id = this.safeString(trade, "id");
        object symbol = getValue(market, "symbol");
        object currencyId = this.safeString(trade, "commissionAsset");
        object currencyCode = this.safeCurrencyCode(currencyId);
        object amountString = this.safeString(trade, "qty");
        object priceString = this.safeString(trade, "price");
        object costString = this.safeString2(trade, "quoteQty", "baseQty");
        object timestamp = this.safeInteger(trade, "time");
        object side = this.safeStringLower(trade, "side");
        object isMaker = this.safeBool(trade, "maker");
        object takerOrMaker = null;
        if (isTrue(!isEqual(isMaker, null)))
        {
            takerOrMaker = ((bool) isTrue(isMaker)) ? "maker" : "taker";
        }
        object isBuyerMaker = this.safeBool(trade, "isBuyerMaker");
        if (isTrue(!isEqual(isBuyerMaker, null)))
        {
            side = ((bool) isTrue(isBuyerMaker)) ? "sell" : "buy";
        }
        return this.safeTrade(new Dictionary<string, object>() {
            { "id", id },
            { "info", trade },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "symbol", symbol },
            { "order", this.safeString(trade, "orderId") },
            { "type", null },
            { "side", side },
            { "takerOrMaker", takerOrMaker },
            { "price", priceString },
            { "amount", amountString },
            { "cost", costString },
            { "fee", new Dictionary<string, object>() {
                { "cost", this.parseNumber(Precise.stringAbs(this.safeString(trade, "commission"))) },
                { "currency", currencyCode },
            } },
        }, market);
    }

    /**
     * @method
     * @name aster#fetchTrades
     * @description get the list of most recent trades for a particular symbol
     * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-spot-api.md#recent-trades-list
     * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-futures-api.md#recent-trades-list
     * @param {string} symbol unified symbol of the market to fetch trades for
     * @param {int} [since] timestamp in ms of the earliest trade to fetch
     * @param {int} [limit] the maximum amount of trades to fetch
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
     */
    public async override Task<object> fetchTrades(object symbol, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchTrades() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        if (isTrue(!isEqual(limit, null)))
        {
            if (isTrue(isGreaterThan(limit, 1000)))
            {
                limit = 1000; // Default 500; max 1000.
            }
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        object response = null;
        if (isTrue(getValue(market, "swap")))
        {
            response = await this.fapiPublicGetV1Trades(this.extend(request, parameters));
        } else
        {
            response = await this.sapiPublicGetV1Trades(this.extend(request, parameters));
        }
        return this.parseTrades(response, market, since, limit);
    }

    /**
     * @method
     * @name aster#fetchMyTrades
     * @description fetch all trades made by the user
     * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-spot-api.md#account-trade-history-user_data
     * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-futures-api.md#account-trade-list-user_data
     * @param {string} [symbol] unified market symbol
     * @param {int} [since] the earliest time in ms to fetch trades for
     * @param {int} [limit] the maximum number of trades structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {int} [params.until] timestamp in ms for the ending date filter, default is undefined
     * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
     */
    public async override Task<object> fetchMyTrades(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchMyTrades() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["startTime"] = since;
        }
        if (isTrue(!isEqual(limit, null)))
        {
            if (isTrue(isGreaterThan(limit, 1000)))
            {
                limit = 1000; // Default 500; max 1000.
            }
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        var requestparametersVariable = this.handleUntilOption("endTime", request, parameters);
        request = ((IList<object>)requestparametersVariable)[0];
        parameters = ((IList<object>)requestparametersVariable)[1];
        object response = null;
        if (isTrue(getValue(market, "swap")))
        {
            response = await this.fapiPrivateGetV1UserTrades(this.extend(request, parameters));
        } else
        {
            response = await this.sapiPrivateGetV1UserTrades(this.extend(request, parameters));
        }
        //
        //     [
        //         {
        //             "buyer": false,
        //             "commission": "-0.07819010",
        //             "commissionAsset": "USDT",
        //             "id": 698759,
        //             "maker": false,
        //             "orderId": 25851813,
        //             "price": "7819.01",
        //             "qty": "0.002",
        //             "quoteQty": "15.63802",
        //             "realizedPnl": "-0.91539999",
        //             "side": "SELL",
        //             "positionSide": "SHORT",
        //             "symbol": "BTCUSDT",
        //             "time": 1569514978020
        //         }
        //     ]
        //
        return this.parseTrades(response, market, since, limit, parameters);
    }

    /**
     * @method
     * @name aster#fetchOrderBook
     * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
     * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-spot-api.md#depth-information
     * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-futures-api.md#order-book
     * @param {string} symbol unified symbol of the market to fetch the order book for
     * @param {int} [limit] the maximum amount of order book entries to return
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
     */
    public async override Task<object> fetchOrderBook(object symbol, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchOrderBook() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        if (isTrue(!isEqual(limit, null)))
        {
            // limit: [5, 10, 20, 50, 100, 500, 1000]. Default: 500
            if (isTrue(isGreaterThan(limit, 1000)))
            {
                limit = 1000; // Default 500; max 1000.
            }
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        object response = null;
        if (isTrue(getValue(market, "swap")))
        {
            response = await this.fapiPublicGetV1Depth(this.extend(request, parameters));
        } else
        {
            response = await this.sapiPublicGetV1Depth(this.extend(request, parameters));
        }
        //
        //     {
        //         "lastUpdateId": 1027024,
        //         "E": 1589436922972, //     Message output time
        //         "T": 1589436922959, //     Transaction time
        //         "bids": [
        //             [
        //                 "4.00000000", //     PRICE
        //                 "431.00000000" //     QTY
        //             ]
        //         ],
        //         "asks": [
        //             [
        //                 "4.00000200",
        //                 "12.00000000"
        //             ]
        //         ]
        //     }
        //
        object timestamp = this.safeInteger(response, "T");
        return this.parseOrderBook(response, symbol, timestamp, "bids", "asks");
    }

    /**
     * @method
     * @name aster#fetchFundingRateHistory
     * @description fetches historical funding rate prices
     * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-futures-api.md#get-funding-rate-history
     * @param {string} symbol unified symbol of the market to fetch the funding rate history for
     * @param {int} [since] timestamp in ms of the earliest funding rate to fetch
     * @param {int} [limit] the maximum amount of [funding rate structures]{@link https://docs.ccxt.com/#/?id=funding-rate-history-structure} to fetch
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {int} [params.until] timestamp in ms of the latest funding rate
     * @returns {object[]} a list of [funding rate structures]{@link https://docs.ccxt.com/#/?id=funding-rate-history-structure}
     */
    public async override Task<object> fetchFundingRateHistory(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        if (isTrue(!isEqual(symbol, null)))
        {
            object market = this.market(symbol);
            ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["startTime"] = since;
        }
        if (isTrue(!isEqual(limit, null)))
        {
            if (isTrue(isGreaterThan(limit, 1000)))
            {
                limit = 1000; // Default 100; max 1000
            }
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        var requestparametersVariable = this.handleUntilOption("endTime", request, parameters);
        request = ((IList<object>)requestparametersVariable)[0];
        parameters = ((IList<object>)requestparametersVariable)[1];
        object response = await this.fapiPublicGetV1FundingRate(this.extend(request, parameters));
        //
        //     [
        //         {
        //             "symbol": "BTCUSDT",
        //             "fundingTime": 1747209600000,
        //             "fundingRate": "0.00010000"
        //         }
        //     ]
        //
        object rates = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(response)); postFixIncrement(ref i))
        {
            object entry = getValue(response, i);
            object timestamp = this.safeInteger(entry, "fundingTime");
            ((IList<object>)rates).Add(new Dictionary<string, object>() {
                { "info", entry },
                { "symbol", this.safeSymbol(this.safeString(entry, "symbol"), null, null, "swap") },
                { "fundingRate", this.safeNumber(entry, "fundingRate") },
                { "timestamp", timestamp },
                { "datetime", this.iso8601(timestamp) },
            });
        }
        object sorted = this.sortBy(rates, "timestamp");
        return this.filterBySymbolSinceLimit(sorted, symbol, since, limit);
    }

    public override object parseTicker(object ticker, object market = null)
    {
        //
        // spot
        //     {
        //         "symbol": "BTCUSDT",
        //         "priceChange": "-2274.38",
        //         "priceChangePercent": "-2.049",
        //         "weightedAvgPrice": "109524.37084136",
        //         "lastPrice": "108738.78",
        //         "lastQty": "0.00034",
        //         "openPrice": "111013.16",
        //         "highPrice": "111975.81",
        //         "lowPrice": "107459.25",
        //         "volume": "28.67876",
        //         "quoteVolume": "3141023.14551030",
        //         "openTime": "1760578800000",
        //         "closeTime": "1760665024749",
        //         "firstId": "37447",
        //         "lastId": "39698",
        //         "count": "2252",
        //         "baseAsset": "BTC",
        //         "quoteAsset": "USDT",
        //         "bidPrice": "108705.11",
        //         "bidQty": "0.03351",
        //         "askPrice": "108725.99",
        //         "askQty": "0.08724"
        //     }
        // swap
        //     {
        //         "symbol": "BTCUSDT",
        //         "priceChange": "1845.7",
        //         "priceChangePercent": "1.755",
        //         "weightedAvgPrice": "105515.5",
        //         "lastPrice": "107037.7",
        //         "lastQty": "0.004",
        //         "openPrice": "105192.0",
        //         "highPrice": "107223.5",
        //         "lowPrice": "104431.6",
        //         "volume": "8753.286",
        //         "quoteVolume": "923607368.61",
        //         "openTime": 1749976620000,
        //         "closeTime": 1750063053754,
        //         "firstId": 24195078,
        //         "lastId": 24375783,
        //         "count": 180706
        //     }
        //
        object timestamp = this.safeInteger(ticker, "closeTime");
        object marketType = null;
        if (isTrue(inOp(ticker, "bidQty")))
        {
            marketType = "spot";
        } else
        {
            marketType = "contract";
        }
        object marketId = this.safeString(ticker, "symbol");
        market = this.safeMarket(marketId, market, null, marketType);
        object symbol = getValue(market, "symbol");
        object last = this.safeString(ticker, "lastPrice");
        object open = this.safeString(ticker, "openPrice");
        object percentage = this.safeString(ticker, "priceChangePercent");
        percentage = Precise.stringMul(percentage, "100");
        object quoteVolume = this.safeString(ticker, "quoteVolume");
        object baseVolume = this.safeString(ticker, "volume");
        object high = this.safeString(ticker, "highPrice");
        object low = this.safeString(ticker, "lowPrice");
        return this.safeTicker(new Dictionary<string, object>() {
            { "symbol", symbol },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "high", high },
            { "low", low },
            { "bid", this.safeString(ticker, "bidPrice") },
            { "bidVolume", this.safeString(ticker, "bidQty") },
            { "ask", this.safeString(ticker, "askPrice") },
            { "askVolume", this.safeString(ticker, "askQty") },
            { "vwap", null },
            { "open", open },
            { "close", last },
            { "last", last },
            { "previousClose", null },
            { "change", null },
            { "percentage", percentage },
            { "average", null },
            { "baseVolume", baseVolume },
            { "quoteVolume", quoteVolume },
            { "markPrice", null },
            { "indexPrice", null },
            { "info", ticker },
        }, market);
    }

    /**
     * @method
     * @name aster#fetchTicker
     * @description fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
     * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-spot-api.md#24h-price-change
     * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-futures-api.md#24hr-ticker-price-change-statistics
     * @param {string} symbol unified symbol of the market to fetch the ticker for
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
     */
    public async override Task<object> fetchTicker(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchTicker() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object response = null;
        if (isTrue(getValue(market, "swap")))
        {
            response = await this.fapiPublicGetV1Ticker24hr(this.extend(request, parameters));
        } else
        {
            response = await this.sapiPublicGetV1Ticker24hr(this.extend(request, parameters));
        }
        return this.parseTicker(response, market);
    }

    /**
     * @method
     * @name aster#fetchTickers
     * @description fetches price tickers for multiple markets, statistical information calculated over the past 24 hours for each market
     * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-spot-api.md#24h-price-change
     * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-futures-api.md#24hr-ticker-price-change-statistics
     * @param {string[]} symbols unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.subType] "linear" or "inverse"
     * @param {string} [params.type] 'spot', 'option', use params["subType"] for swap and future markets
     * @returns {object} an array of [ticker structures]{@link https://docs.ccxt.com/#/?id=ticker-structure}
     */
    public async override Task<object> fetchTickers(object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        symbols = this.marketSymbols(symbols, null, true, true, true);
        object market = this.getMarketFromSymbols(symbols);
        object type = null;
        var typeparametersVariable = this.handleMarketTypeAndParams("fetchTickers", market, parameters);
        type = ((IList<object>)typeparametersVariable)[0];
        parameters = ((IList<object>)typeparametersVariable)[1];
        object subType = null;
        var subTypeparametersVariable = this.handleSubTypeAndParams("fetchTickers", market, parameters);
        subType = ((IList<object>)subTypeparametersVariable)[0];
        parameters = ((IList<object>)subTypeparametersVariable)[1];
        object response = null;
        if (isTrue(this.isLinear(type, subType)))
        {
            response = await this.fapiPublicGetV1Ticker24hr(parameters);
        } else if (isTrue(isEqual(type, "spot")))
        {
            response = await this.sapiPublicGetV1Ticker24hr(parameters);
        } else
        {
            throw new NotSupported ((string)add(add(add(this.id, " fetchTickers() does not support "), type), " markets yet")) ;
        }
        //
        //     [
        //         {
        //             "symbol": "BTCUSDT",
        //             "priceChange": "1845.7",
        //             "priceChangePercent": "1.755",
        //             "weightedAvgPrice": "105515.5",
        //             "lastPrice": "107037.7",
        //             "lastQty": "0.004",
        //             "openPrice": "105192.0",
        //             "highPrice": "107223.5",
        //             "lowPrice": "104431.6",
        //             "volume": "8753.286",
        //             "quoteVolume": "923607368.61",
        //             "openTime": 1749976620000,
        //             "closeTime": 1750063053754,
        //             "firstId": 24195078,
        //             "lastId": 24375783,
        //             "count": 180706
        //         }
        //     ]
        //
        return this.parseTickers(response, symbols);
    }

    public override object parseFundingRate(object contract, object market = null)
    {
        //
        //     {
        //         "symbol": "BTCUSDT",
        //         "markPrice": "106729.84047826",
        //         "indexPrice": "106775.72673913",
        //         "estimatedSettlePrice": "106708.84997006",
        //         "lastFundingRate": "0.00010000",
        //         "interestRate": "0.00010000",
        //         "nextFundingTime": 1750147200000,
        //         "time": 1750146970000
        //     }
        //     {
        //         "symbol": "INJUSDT",
        //         "interestRate": "0.00010000",
        //         "time": 1756197479000,
        //         "fundingIntervalHours": 8,
        //         "fundingFeeCap": 0.03,
        //         "fundingFeeFloor": -0.03
        //     }
        //
        object marketId = this.safeString(contract, "symbol");
        object nextFundingTimestamp = this.safeInteger(contract, "nextFundingTime");
        object timestamp = this.safeInteger(contract, "time");
        object interval = this.safeString(contract, "fundingIntervalHours");
        object intervalString = null;
        if (isTrue(!isEqual(interval, null)))
        {
            intervalString = add(interval, "h");
        }
        return new Dictionary<string, object>() {
            { "info", contract },
            { "symbol", this.safeSymbol(marketId, market, null, "contract") },
            { "markPrice", this.safeNumber(contract, "markPrice") },
            { "indexPrice", this.safeNumber(contract, "indexPrice") },
            { "interestRate", this.safeNumber(contract, "interestRate") },
            { "estimatedSettlePrice", this.safeNumber(contract, "estimatedSettlePrice") },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "fundingRate", this.safeNumber(contract, "lastFundingRate") },
            { "fundingTimestamp", null },
            { "fundingDatetime", null },
            { "nextFundingRate", null },
            { "nextFundingTimestamp", nextFundingTimestamp },
            { "nextFundingDatetime", this.iso8601(nextFundingTimestamp) },
            { "previousFundingRate", null },
            { "previousFundingTimestamp", null },
            { "previousFundingDatetime", null },
            { "interval", intervalString },
        };
    }

    /**
     * @method
     * @name aster#fetchFundingRate
     * @description fetch the current funding rate
     * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-futures-api.md#mark-price
     * @param {string} symbol unified market symbol
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [funding rate structure]{@link https://docs.ccxt.com/#/?id=funding-rate-structure}
     */
    public async override Task<object> fetchFundingRate(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchFundingRate() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object response = await this.fapiPublicGetV1PremiumIndex(this.extend(request, parameters));
        //
        //     {
        //         "symbol": "BTCUSDT",
        //         "markPrice": "106729.84047826",
        //         "indexPrice": "106775.72673913",
        //         "estimatedSettlePrice": "106708.84997006",
        //         "lastFundingRate": "0.00010000",
        //         "interestRate": "0.00010000",
        //         "nextFundingTime": 1750147200000,
        //         "time": 1750146970000
        //     }
        //
        return this.parseFundingRate(response, market);
    }

    /**
     * @method
     * @name aster#fetchFundingRates
     * @description fetch the current funding rate for multiple symbols
     * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-futures-api.md#24hr-ticker-price-change-statistics
     * @param {string[]} [symbols] list of unified market symbols
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} a list of [funding rate structures]{@link https://docs.ccxt.com/#/?id=funding-rate-structure}
     */
    public async override Task<object> fetchFundingRates(object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        symbols = this.marketSymbols(symbols);
        object response = await this.fapiPublicGetV1PremiumIndex(this.extend(parameters));
        //
        //     [
        //         {
        //             "symbol": "BTCUSDT",
        //             "markPrice": "106729.84047826",
        //             "indexPrice": "106775.72673913",
        //             "estimatedSettlePrice": "106708.84997006",
        //             "lastFundingRate": "0.00010000",
        //             "interestRate": "0.00010000",
        //             "nextFundingTime": 1750147200000,
        //             "time": 1750146970000
        //         }
        //     ]
        //
        return this.parseFundingRates(response, symbols);
    }

    /**
     * @method
     * @name aster#fetchFundingIntervals
     * @description fetch the funding rate interval for multiple markets
     * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-futures-api.md#get-funding-rate-config
     * @param {string[]} [symbols] list of unified market symbols
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} a list of [funding rate structures]{@link https://docs.ccxt.com/#/?id=funding-rate-structure}
     */
    public async override Task<object> fetchFundingIntervals(object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        if (isTrue(!isEqual(symbols, null)))
        {
            symbols = this.marketSymbols(symbols);
        }
        object response = await this.fapiPublicGetV1FundingInfo(parameters);
        //
        //     [
        //         {
        //             "symbol": "INJUSDT",
        //             "interestRate": "0.00010000",
        //             "time": 1756197479000,
        //             "fundingIntervalHours": 8,
        //             "fundingFeeCap": 0.03,
        //             "fundingFeeFloor": -0.03
        //         }
        //     ]
        //
        return this.parseFundingRates(response, symbols);
    }

    public override object parseBalance(object response)
    {
        object result = new Dictionary<string, object>() {
            { "info", response },
        };
        for (object i = 0; isLessThan(i, getArrayLength(response)); postFixIncrement(ref i))
        {
            object balance = getValue(response, i);
            object currencyId = this.safeString(balance, "asset");
            object code = this.safeCurrencyCode(currencyId);
            object account = this.account();
            ((IDictionary<string,object>)account)["free"] = this.safeString2(balance, "free", "maxWithdrawAmount");
            ((IDictionary<string,object>)account)["used"] = this.safeString(balance, "locked");
            ((IDictionary<string,object>)account)["total"] = this.safeString(balance, "walletBalance");
            ((IDictionary<string,object>)result)[(string)code] = account;
        }
        return this.safeBalance(result);
    }

    /**
     * @method
     * @name aster#fetchBalance
     * @description query for balance and get the amount of funds available for trading or funds locked in orders
     * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-futures-api.md#account-information-v4-user_data
     * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-spot-api.md#account-information-user_data
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.subType] "linear" or "inverse"
     * @param {string} [params.type] 'spot', 'option', use params["subType"] for swap and future markets
     * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
     */
    public async override Task<object> fetchBalance(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object type = null;
        var typeparametersVariable = this.handleMarketTypeAndParams("fetchBalance", null, parameters);
        type = ((IList<object>)typeparametersVariable)[0];
        parameters = ((IList<object>)typeparametersVariable)[1];
        object subType = null;
        var subTypeparametersVariable = this.handleSubTypeAndParams("fetchBalance", null, parameters);
        subType = ((IList<object>)subTypeparametersVariable)[0];
        parameters = ((IList<object>)subTypeparametersVariable)[1];
        object response = null;
        object data = null;
        if (isTrue(this.isLinear(type, subType)))
        {
            response = await this.fapiPrivateGetV4Account(parameters);
            data = this.safeList(response, "assets", new List<object>() {});
        } else if (isTrue(isEqual(type, "spot")))
        {
            response = await this.sapiPrivateGetV1Account(parameters);
            data = this.safeList(response, "balances", new List<object>() {});
        } else
        {
            throw new NotSupported ((string)add(add(add(this.id, " fetchBalance() does not support "), type), " markets yet")) ;
        }
        return this.parseBalance(data);
    }

    /**
     * @method
     * @name aster#setMarginMode
     * @description set margin mode to 'cross' or 'isolated'
     * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-futures-api.md#change-margin-type-trade
     * @param {string} marginMode 'cross' or 'isolated'
     * @param {string} symbol unified market symbol
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} response from the exchange
     */
    public async override Task<object> setMarginMode(object marginMode, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " setMarginMode() requires a symbol argument")) ;
        }
        marginMode = ((string)marginMode).ToUpper();
        if (isTrue(isEqual(marginMode, "CROSS")))
        {
            marginMode = "CROSSED";
        }
        if (isTrue(isTrue((!isEqual(marginMode, "ISOLATED"))) && isTrue((!isEqual(marginMode, "CROSSED")))))
        {
            throw new BadRequest ((string)add(this.id, " marginMode must be either isolated or cross")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
            { "marginType", marginMode },
        };
        object response = await this.fapiPrivatePostV1MarginType(this.extend(request, parameters));
        //
        //     {
        //         "amount": 100.0,
        //         "code": 200,
        //         "msg": "Successfully modify position margin.",
        //         "type": 1
        //     }
        //
        return response;
    }

    /**
     * @method
     * @name aster#fetchPositionMode
     * @description fetchs the position mode, hedged or one way, hedged for aster is set identically for all linear markets or all inverse markets
     * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-futures-api.md#get-current-position-modeuser_data
     * @param {string} symbol unified symbol of the market to fetch the order book for
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} an object detailing whether the market is in hedged or one-way mode
     */
    public async override Task<object> fetchPositionMode(object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object response = await this.fapiPrivateGetV1PositionSideDual(parameters);
        //
        //     {
        //         "dualSidePosition": true // "true": Hedge Mode; "false": One-way Mode
        //     }
        //
        object dualSidePosition = this.safeBool(response, "dualSidePosition");
        return new Dictionary<string, object>() {
            { "info", response },
            { "hedged", (isEqual(dualSidePosition, true)) },
        };
    }

    /**
     * @method
     * @name aster#setPositionMode
     * @description set hedged to true or false for a market
     * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-futures-api.md#change-position-modetrade
     * @param {bool} hedged set to true to use dualSidePosition
     * @param {string} symbol not used by bingx setPositionMode ()
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} response from the exchange
     */
    public async override Task<object> setPositionMode(object hedged, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object request = new Dictionary<string, object>() {
            { "dualSidePosition", hedged },
        };
        //
        //     {
        //         "code": 200,
        //         "msg": "success"
        //     }
        //
        return await this.fapiPrivatePostV1PositionSideDual(this.extend(request, parameters));
    }

    public virtual object parseTradingFee(object fee, object market = null)
    {
        object marketId = this.safeString(fee, "symbol");
        market = this.safeMarket(marketId, market);
        object symbol = this.safeSymbol(marketId, market);
        return new Dictionary<string, object>() {
            { "info", fee },
            { "symbol", symbol },
            { "maker", this.safeNumber(fee, "makerCommissionRate") },
            { "taker", this.safeNumber(fee, "takerCommissionRate") },
            { "percentage", false },
            { "tierBased", false },
        };
    }

    /**
     * @method
     * @name aster#fetchTradingFee
     * @description fetch the trading fees for a market
     * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-spot-api.md#get-symbol-fees
     * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-futures-api.md#user-commission-rate-user_data
     * @param {string} symbol unified market symbol
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [fee structure]{@link https://docs.ccxt.com/#/?id=fee-structure}
     */
    public async override Task<object> fetchTradingFee(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object response = null;
        if (isTrue(getValue(market, "swap")))
        {
            response = await this.fapiPrivateGetV1CommissionRate(this.extend(request, parameters));
        } else
        {
            response = await this.sapiPrivateGetV1CommissionRate(this.extend(request, parameters));
        }
        //
        //     {
        //         "symbol": "BTCUSDT",
        //         "makerCommissionRate": "0.0002",
        //         "takerCommissionRate": "0.0004"
        //     }
        //
        return this.parseTradingFee(response, market);
    }

    public virtual object parseOrderStatus(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "NEW", "open" },
            { "PARTIALLY_FILLED", "open" },
            { "FILLED", "closed" },
            { "CANCELED", "canceled" },
            { "REJECTED", "canceled" },
            { "EXPIRED", "canceled" },
        };
        return this.safeString(statuses, status, status);
    }

    public virtual object parseOrderType(object type)
    {
        object types = new Dictionary<string, object>() {
            { "LIMIT", "limit" },
            { "MARKET", "market" },
            { "STOP", "limit" },
            { "STOP_MARKET", "market" },
            { "TAKE_PROFIT", "limit" },
            { "TAKE_PROFIT_MARKET", "market" },
            { "TRAILING_STOP_MARKET", "market" },
        };
        return this.safeString(types, type, type);
    }

    public override object parseOrder(object order, object market = null)
    {
        //
        // swap
        //     {
        //         "avgPrice": "0.00000",
        //         "clientOrderId": "abc",
        //         "cumQuote": "0",
        //         "executedQty": "0",
        //         "orderId": 1917641,
        //         "origQty": "0.40",
        //         "origType": "TRAILING_STOP_MARKET",
        //         "price": "0",
        //         "reduceOnly": false,
        //         "side": "BUY",
        //         "positionSide": "SHORT",
        //         "status": "NEW",
        //         "stopPrice": "9300",
        //         "closePosition": false,
        //         "symbol": "BTCUSDT",
        //         "time": 1579276756075,
        //         "timeInForce": "GTC",
        //         "type": "TRAILING_STOP_MARKET",
        //         "activatePrice": "9020",
        //         "priceRate": "0.3",
        //         "updateTime": 1579276756075,
        //         "workingType": "CONTRACT_PRICE",
        //         "priceProtect": false
        //     }
        // spot
        //     {
        //         "orderId": 38,
        //         "symbol": "ADA25SLP25",
        //         "status": "FILLED",
        //         "clientOrderId": "afMd4GBQyHkHpGWdiy34Li",
        //         "price": "20",
        //         "avgPrice": "12.0000000000000000",
        //         "origQty": "10",
        //         "executedQty": "10",
        //         "cumQuote": "120",
        //         "timeInForce": "GTC",
        //         "type": "LIMIT",
        //         "side": "BUY",
        //         "stopPrice": "0",
        //         "origType": "LIMIT",
        //         "time": 1649913186270,
        //         "updateTime": 1649913186297
        //     }
        //
        object info = order;
        object marketId = this.safeString(order, "symbol");
        market = this.safeMarket(marketId, market);
        object side = this.safeStringLower(order, "side");
        object timestamp = this.safeInteger(order, "time");
        object lastTradeTimestamp = this.safeInteger(order, "updateTime");
        object statusId = this.safeStringUpper(order, "status");
        object rawType = this.safeStringUpper(order, "type");
        object stopPriceString = this.safeString(order, "stopPrice");
        object triggerPrice = this.parseNumber(this.omitZero(stopPriceString));
        return this.safeOrder(new Dictionary<string, object>() {
            { "info", info },
            { "id", this.safeString(order, "orderId") },
            { "clientOrderId", this.safeString(order, "clientOrderId") },
            { "symbol", this.safeSymbol(marketId, market) },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "lastTradeTimestamp", lastTradeTimestamp },
            { "lastUpdateTimestamp", this.safeInteger(order, "updateTime") },
            { "type", this.parseOrderType(rawType) },
            { "timeInForce", this.safeString(order, "timeInForce") },
            { "postOnly", null },
            { "side", side },
            { "price", this.safeString(order, "price") },
            { "triggerPrice", triggerPrice },
            { "average", this.safeString(order, "avgPrice") },
            { "cost", this.safeString(order, "cumQuote") },
            { "amount", this.safeString(order, "origQty") },
            { "filled", this.safeString(order, "executedQty") },
            { "remaining", null },
            { "status", this.parseOrderStatus(statusId) },
            { "fee", null },
            { "trades", null },
            { "reduceOnly", this.safeBool2(order, "reduceOnly", "ro") },
        }, market);
    }

    /**
     * @method
     * @name aster#fetchOrder
     * @description fetches information on an order made by the user
     * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-spot-api.md#query-order-user_data
     * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-futures-api.md#query-order-user_data
     * @param {string} id the order id
     * @param {string} symbol unified symbol of the market the order was made in
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.clientOrderId] a unique id for the order
     * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> fetchOrder(object id, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchOrder() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object clientOrderId = this.safeString2(parameters, "clientOrderId", "clientOid");
        parameters = this.omit(parameters, new List<object>() {"clientOrderId", "clientOid"});
        if (isTrue(!isEqual(clientOrderId, null)))
        {
            ((IDictionary<string,object>)request)["origClientOrderId"] = clientOrderId;
        } else
        {
            ((IDictionary<string,object>)request)["orderId"] = id;
        }
        object response = null;
        if (isTrue(getValue(market, "swap")))
        {
            response = await this.fapiPrivateGetV1Order(this.extend(request, parameters));
        } else
        {
            response = await this.sapiPrivateGetV1Order(this.extend(request, parameters));
        }
        return this.parseOrder(response, market);
    }

    /**
     * @method
     * @name aster#fetchOpenOrder
     * @description fetch an open order by the id
     * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-futures-api.md#query-current-open-order-user_data
     * @param {string} id order id
     * @param {string} symbol unified market symbol
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async virtual Task<object> fetchOpenOrder(object id, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchOpenOrder() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object clientOrderId = this.safeString2(parameters, "clientOrderId", "clientOid");
        parameters = this.omit(parameters, new List<object>() {"clientOrderId", "clientOid"});
        if (isTrue(!isEqual(clientOrderId, null)))
        {
            ((IDictionary<string,object>)request)["origClientOrderId"] = clientOrderId;
        } else
        {
            ((IDictionary<string,object>)request)["orderId"] = id;
        }
        object response = await this.fapiPrivateGetV1OpenOrder(this.extend(request, parameters));
        return this.parseOrder(response, market);
    }

    /**
     * @method
     * @name aster#fetchOrders
     * @description fetches information on multiple orders made by the user
     * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-spot-api.md#query-all-orders-user_data
     * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-futures-api.md#all-orders-user_data
     * @param {string} symbol unified market symbol of the market orders were made in
     * @param {int} [since] the earliest time in ms to fetch orders for
     * @param {int} [limit] the maximum number of order structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {int} [params.until] the latest time in ms to fetch orders for
     * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> fetchOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchOrders() requires a symbol argument")) ;
        }
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["startTime"] = since;
        }
        if (isTrue(!isEqual(limit, null)))
        {
            if (isTrue(isGreaterThan(limit, 1000)))
            {
                limit = 1000; // Default 500; max 1000
            }
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        var requestparametersVariable = this.handleUntilOption("endTime", request, parameters);
        request = ((IList<object>)requestparametersVariable)[0];
        parameters = ((IList<object>)requestparametersVariable)[1];
        object response = null;
        if (isTrue(getValue(market, "swap")))
        {
            response = await this.fapiPrivateGetV1AllOrders(this.extend(request, parameters));
        } else
        {
            response = await this.sapiPrivateGetV1AllOrders(this.extend(request, parameters));
        }
        return this.parseOrders(response, market, since, limit);
    }

    /**
     * @method
     * @name aster#fetchOpenOrders
     * @description fetch all unfilled currently open orders
     * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-spot-api.md#current-open-orders-user_data
     * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-futures-api.md#current-all-open-orders-user_data
     * @param {string} symbol unified market symbol
     * @param {int} [since] the earliest time in ms to fetch open orders for
     * @param {int} [limit] the maximum number of  open orders structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.subType] "linear" or "inverse"
     * @param {string} [params.type] 'spot', 'option', use params["subType"] for swap and future markets
     * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> fetchOpenOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object market = null;
        object type = null;
        object subType = null;
        var subTypeparametersVariable = this.handleSubTypeAndParams("fetchOpenOrders", market, parameters);
        subType = ((IList<object>)subTypeparametersVariable)[0];
        parameters = ((IList<object>)subTypeparametersVariable)[1];
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
        }
        var typeparametersVariable = this.handleMarketTypeAndParams("fetchOpenOrders", market, parameters);
        type = ((IList<object>)typeparametersVariable)[0];
        parameters = ((IList<object>)typeparametersVariable)[1];
        object response = null;
        if (isTrue(this.isLinear(type, subType)))
        {
            response = await this.fapiPrivateGetV1OpenOrders(this.extend(request, parameters));
        } else if (isTrue(isEqual(type, "spot")))
        {
            response = await this.sapiPrivateGetV1OpenOrders(this.extend(request, parameters));
        } else
        {
            throw new NotSupported ((string)add(add(add(this.id, " fetchOpenOrders() does not support "), type), " markets yet")) ;
        }
        //
        //     [
        //         {
        //             "avgPrice": "0.00000",
        //             "clientOrderId": "abc",
        //             "cumQuote": "0",
        //             "executedQty": "0",
        //             "orderId": 1917641,
        //             "origQty": "0.40",
        //             "origType": "TRAILING_STOP_MARKET",
        //             "price": "0",
        //             "reduceOnly": false,
        //             "side": "BUY",
        //             "positionSide": "SHORT",
        //             "status": "NEW",
        //             "stopPrice": "9300",
        //             "closePosition": false,
        //             "symbol": "BTCUSDT",
        //             "time": 1579276756075,
        //             "timeInForce": "GTC",
        //             "type": "TRAILING_STOP_MARKET",
        //             "activatePrice": "9020",
        //             "priceRate": "0.3",
        //             "updateTime": 1579276756075,
        //             "workingType": "CONTRACT_PRICE",
        //             "priceProtect": false
        //         }
        //     ]
        //
        return this.parseOrders(response, market, since, limit);
    }

    /**
     * @method
     * @name aster#createOrder
     * @description create a trade order
     * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-spot-api.md#place-order-trade
     * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-futures-api.md#new-order--trade
     * @param {string} symbol unified symbol of the market to create an order in
     * @param {string} type 'market' or 'limit' or 'STOP' or 'STOP_MARKET' or 'TAKE_PROFIT' or 'TAKE_PROFIT_MARKET' or 'TRAILING_STOP_MARKET'
     * @param {string} side 'buy' or 'sell'
     * @param {float} amount how much of you want to trade in units of the base currency
     * @param {float} [price] the price that the order is to be fulfilled, in units of the quote currency, ignored in market orders
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.reduceOnly] for swap and future reduceOnly is a string 'true' or 'false' that cant be sent with close position set to true or in hedge mode. For spot margin and option reduceOnly is a boolean.
     * @param {boolean} [params.test] whether to use the test endpoint or not, default is false
     * @param {float} [params.trailingPercent] the percent to trail away from the current market price
     * @param {float} [params.trailingTriggerPrice] the price to trigger a trailing order, default uses the price argument
     * @param {string} [params.positionSide] "BOTH" for one-way mode, "LONG" for buy side of hedged mode, "SHORT" for sell side of hedged mode
     * @param {float} [params.triggerPrice] the price that a trigger order is triggered at
     * @param {float} [params.stopLossPrice] the price that a stop loss order is triggered at
     * @param {float} [params.takeProfitPrice] the price that a take profit order is triggered at
     * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> createOrder(object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object test = this.safeBool(parameters, "test", false);
        parameters = this.omit(parameters, "test");
        object request = this.createOrderRequest(symbol, type, side, amount, price, parameters);
        object response = null;
        if (isTrue(getValue(market, "swap")))
        {
            if (isTrue(test))
            {
                response = await this.fapiPrivatePostV1OrderTest(request);
            } else
            {
                response = await this.fapiPrivatePostV1Order(request);
            }
        } else
        {
            response = await this.sapiPrivatePostV1Order(request);
        }
        return this.parseOrder(response, market);
    }

    /**
     * @method
     * @name aster#createOrders
     * @description create a list of trade orders
     * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-futures-api.md#place-multiple-orders--trade
     * @param {Array} orders list of orders to create, each object should contain the parameters required by createOrder, namely symbol, type, side, amount, price and params
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> createOrders(object orders, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object ordersRequests = new List<object>() {};
        object orderSymbols = new List<object>() {};
        if (isTrue(isGreaterThan(getArrayLength(orders), 5)))
        {
            throw new InvalidOrder ((string)add(this.id, " createOrders() order list max 5 orders")) ;
        }
        for (object i = 0; isLessThan(i, getArrayLength(orders)); postFixIncrement(ref i))
        {
            object rawOrder = getValue(orders, i);
            object marketId = this.safeString(rawOrder, "symbol");
            object type = this.safeString(rawOrder, "type");
            object side = this.safeString(rawOrder, "side");
            object amount = this.safeValue(rawOrder, "amount");
            object price = this.safeValue(rawOrder, "price");
            object orderParams = this.safeDict(rawOrder, "params", new Dictionary<string, object>() {});
            object orderRequest = this.createOrderRequest(marketId, type, side, amount, price, orderParams);
            ((IList<object>)ordersRequests).Add(orderRequest);
        }
        orderSymbols = this.marketSymbols(orderSymbols, null, false, true, true);
        object market = this.market(getValue(orderSymbols, 0));
        if (isTrue(getValue(market, "spot")))
        {
            throw new NotSupported ((string)add(add(add(this.id, " createOrders() does not support "), getValue(market, "type")), " orders")) ;
        }
        object request = new Dictionary<string, object>() {
            { "batchOrders", ordersRequests },
        };
        object response = await this.fapiPrivatePostV1BatchOrders(this.extend(request, parameters));
        return this.parseOrders(response);
    }

    public virtual object createOrderRequest(object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        /**
        * @method
        * @ignore
        * @name aster#createOrderRequest
        * @description helper function to build the request
        * @param {string} symbol unified symbol of the market to create an order in
        * @param {string} type 'market' or 'limit'
        * @param {string} side 'buy' or 'sell'
        * @param {float} amount how much you want to trade in units of the base currency
        * @param {float} [price] the price that the order is to be fulfilled, in units of the quote currency, ignored in market orders
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} request to be sent to the exchange
        */
        parameters ??= new Dictionary<string, object>();
        object market = this.market(symbol);
        object initialUppercaseType = ((string)type).ToUpper();
        object isMarketOrder = isEqual(initialUppercaseType, "MARKET");
        object isLimitOrder = isEqual(initialUppercaseType, "LIMIT");
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
            { "side", ((string)side).ToUpper() },
        };
        object clientOrderId = this.safeString2(parameters, "newClientOrderId", "clientOrderId");
        if (isTrue(!isEqual(clientOrderId, null)))
        {
            ((IDictionary<string,object>)request)["newClientOrderId"] = clientOrderId;
        }
        object triggerPrice = this.safeString2(parameters, "triggerPrice", "stopPrice");
        object stopLossPrice = this.safeString(parameters, "stopLossPrice", triggerPrice);
        object takeProfitPrice = this.safeString(parameters, "takeProfitPrice");
        object trailingDelta = this.safeString(parameters, "trailingDelta");
        object trailingTriggerPrice = this.safeString2(parameters, "trailingTriggerPrice", "activationPrice");
        object trailingPercent = this.safeStringN(parameters, new List<object>() {"trailingPercent", "callbackRate", "trailingDelta"});
        object isTrailingPercentOrder = !isEqual(trailingPercent, null);
        object isStopLoss = isTrue(!isEqual(stopLossPrice, null)) || isTrue(!isEqual(trailingDelta, null));
        object isTakeProfit = !isEqual(takeProfitPrice, null);
        object uppercaseType = initialUppercaseType;
        object stopPrice = null;
        if (isTrue(isTrailingPercentOrder))
        {
            if (isTrue(getValue(market, "swap")))
            {
                uppercaseType = "TRAILING_STOP_MARKET";
                ((IDictionary<string,object>)request)["callbackRate"] = trailingPercent;
                if (isTrue(!isEqual(trailingTriggerPrice, null)))
                {
                    ((IDictionary<string,object>)request)["activationPrice"] = this.priceToPrecision(symbol, trailingTriggerPrice);
                }
            }
        } else if (isTrue(isStopLoss))
        {
            stopPrice = stopLossPrice;
            if (isTrue(isMarketOrder))
            {
                uppercaseType = "STOP_MARKET";
            } else if (isTrue(isLimitOrder))
            {
                uppercaseType = "STOP";
            }
        } else if (isTrue(isTakeProfit))
        {
            stopPrice = takeProfitPrice;
            if (isTrue(isMarketOrder))
            {
                uppercaseType = "TAKE_PROFIT_MARKET";
            } else if (isTrue(isLimitOrder))
            {
                uppercaseType = "TAKE_PROFIT";
            }
        }
        object postOnly = this.isPostOnly(isMarketOrder, null, parameters);
        if (isTrue(postOnly))
        {
            ((IDictionary<string,object>)request)["timeInForce"] = "GTX";
        }
        //
        // spot
        // LIMIT timeInForce, quantity, price
        // MARKET quantity or quoteOrderQty
        // STOP and TAKE_PROFIT quantity, price, stopPrice
        // STOP_MARKET and TAKE_PROFIT_MARKET quantity, stopPrice
        // future
        // LIMIT timeInForce, quantity, price
        // MARKET quantity
        // STOP/TAKE_PROFIT quantity, price, stopPrice
        // STOP_MARKET/TAKE_PROFIT_MARKET stopPrice
        // TRAILING_STOP_MARKET callbackRate
        //
        // additional required fields depending on the order type
        object closePosition = this.safeBool(parameters, "closePosition", false);
        object timeInForceIsRequired = false;
        object priceIsRequired = false;
        object triggerPriceIsRequired = false;
        object quantityIsRequired = false;
        ((IDictionary<string,object>)request)["type"] = uppercaseType;
        if (isTrue(isEqual(uppercaseType, "MARKET")))
        {
            if (isTrue(getValue(market, "spot")))
            {
                object quoteOrderQty = this.safeBool(this.options, "quoteOrderQty", true);
                if (isTrue(quoteOrderQty))
                {
                    object quoteOrderQtyNew = this.safeString2(parameters, "quoteOrderQty", "cost");
                    object precision = getValue(getValue(market, "precision"), "price");
                    if (isTrue(!isEqual(quoteOrderQtyNew, null)))
                    {
                        ((IDictionary<string,object>)request)["quoteOrderQty"] = this.decimalToPrecision(quoteOrderQtyNew, TRUNCATE, precision, this.precisionMode);
                    } else if (isTrue(!isEqual(price, null)))
                    {
                        object amountString = this.numberToString(amount);
                        object priceString = this.numberToString(price);
                        object quoteOrderQuantity = Precise.stringMul(amountString, priceString);
                        ((IDictionary<string,object>)request)["quoteOrderQty"] = this.decimalToPrecision(quoteOrderQuantity, TRUNCATE, precision, this.precisionMode);
                    } else
                    {
                        quantityIsRequired = true;
                    }
                } else
                {
                    quantityIsRequired = true;
                }
            } else
            {
                quantityIsRequired = true;
            }
        } else if (isTrue(isEqual(uppercaseType, "LIMIT")))
        {
            timeInForceIsRequired = true;
            quantityIsRequired = true;
            priceIsRequired = true;
        } else if (isTrue(isTrue((isEqual(uppercaseType, "STOP"))) || isTrue((isEqual(uppercaseType, "TAKE_PROFIT")))))
        {
            quantityIsRequired = true;
            priceIsRequired = true;
            triggerPriceIsRequired = true;
        } else if (isTrue(isTrue((isEqual(uppercaseType, "STOP_MARKET"))) || isTrue((isEqual(uppercaseType, "TAKE_PROFIT_MARKET")))))
        {
            if (!isTrue(closePosition))
            {
                quantityIsRequired = true;
            }
            triggerPriceIsRequired = true;
        } else if (isTrue(isEqual(uppercaseType, "TRAILING_STOP_MARKET")))
        {
            ((IDictionary<string,object>)request)["callbackRate"] = trailingPercent;
            if (isTrue(!isEqual(trailingTriggerPrice, null)))
            {
                ((IDictionary<string,object>)request)["activationPrice"] = this.priceToPrecision(symbol, trailingTriggerPrice);
            }
        }
        if (isTrue(quantityIsRequired))
        {
            object marketAmountPrecision = this.safeString(getValue(market, "precision"), "amount");
            object isPrecisionAvailable = (!isEqual(marketAmountPrecision, null));
            if (isTrue(isPrecisionAvailable))
            {
                ((IDictionary<string,object>)request)["quantity"] = this.amountToPrecision(symbol, amount);
            } else
            {
                ((IDictionary<string,object>)request)["quantity"] = this.parseToNumeric(amount);
            }
        }
        if (isTrue(priceIsRequired))
        {
            if (isTrue(isEqual(price, null)))
            {
                throw new InvalidOrder ((string)add(add(add(this.id, " createOrder() requires a price argument for a "), type), " order")) ;
            }
            object pricePrecision = this.safeString(getValue(market, "precision"), "price");
            object isPricePrecisionAvailable = (!isEqual(pricePrecision, null));
            if (isTrue(isPricePrecisionAvailable))
            {
                ((IDictionary<string,object>)request)["price"] = this.priceToPrecision(symbol, price);
            } else
            {
                ((IDictionary<string,object>)request)["price"] = this.parseToNumeric(price);
            }
        }
        if (isTrue(triggerPriceIsRequired))
        {
            if (isTrue(isEqual(stopPrice, null)))
            {
                throw new InvalidOrder ((string)add(add(add(this.id, " createOrder() requires a stopPrice extra param for a "), type), " order")) ;
            }
            if (isTrue(!isEqual(stopPrice, null)))
            {
                ((IDictionary<string,object>)request)["stopPrice"] = this.priceToPrecision(symbol, stopPrice);
            }
        }
        if (isTrue(isTrue(isTrue(timeInForceIsRequired) && isTrue((isEqual(this.safeString(parameters, "timeInForce"), null)))) && isTrue((isEqual(this.safeString(request, "timeInForce"), null)))))
        {
            ((IDictionary<string,object>)request)["timeInForce"] = this.safeString(this.options, "defaultTimeInForce"); // 'GTC' = Good To Cancel (default), 'IOC' = Immediate Or Cancel
        }
        object requestParams = this.omit(parameters, new List<object>() {"newClientOrderId", "clientOrderId", "stopPrice", "triggerPrice", "trailingTriggerPrice", "trailingPercent", "trailingDelta", "stopPrice", "stopLossPrice", "takeProfitPrice"});
        return this.extend(request, requestParams);
    }

    /**
     * @method
     * @name aster#cancelAllOrders
     * @description cancel all open orders in a market
     * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-spot-api.md#cancel-all-open-orders-trade
     * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-futures-api.md#cancel-all-open-orders-trade
     * @param {string} symbol unified market symbol of the market to cancel orders in
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> cancelAllOrders(object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " cancelAllOrders() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object response = null;
        if (isTrue(getValue(market, "swap")))
        {
            response = await this.fapiPrivateDeleteV1AllOpenOrders(this.extend(request, parameters));
        } else
        {
            response = await this.sapiPrivateDeleteV1AllOpenOrders(this.extend(request, parameters));
        }
        //
        //     {
        //         "code": "200",
        //         "msg": "The operation of cancel all open order is done."
        //     }
        //
        return new List<object> {this.safeOrder(new Dictionary<string, object>() {
    { "info", response },
})};
    }

    /**
     * @method
     * @name aster#cancelOrder
     * @description cancels an open order
     * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-spot-api.md#cancel-order-trade
     * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-futures-api.md#cancel-order-trade
     * @param {string} id order id
     * @param {string} symbol unified symbol of the market the order was made in
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> cancelOrder(object id, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " cancelOrder() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object clientOrderId = this.safeStringN(parameters, new List<object>() {"origClientOrderId", "clientOrderId", "newClientStrategyId"});
        if (isTrue(!isEqual(clientOrderId, null)))
        {
            ((IDictionary<string,object>)request)["origClientOrderId"] = clientOrderId;
        } else
        {
            ((IDictionary<string,object>)request)["orderId"] = id;
        }
        parameters = this.omit(parameters, new List<object>() {"origClientOrderId", "clientOrderId", "newClientStrategyId"});
        object response = null;
        if (isTrue(getValue(market, "swap")))
        {
            response = await this.fapiPrivateDeleteV1Order(this.extend(request, parameters));
        } else
        {
            response = await this.sapiPrivateDeleteV1Order(this.extend(request, parameters));
        }
        return this.parseOrder(response, market);
    }

    /**
     * @method
     * @name aster#cancelOrders
     * @description cancel multiple orders
     * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-futures-api.md#cancel-multiple-orders-trade
     * @param {string[]} ids order ids
     * @param {string} [symbol] unified market symbol
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     *
     * EXCHANGE SPECIFIC PARAMETERS
     * @param {string[]} [params.origClientOrderIdList] max length 10 e.g. ["my_id_1","my_id_2"], encode the double quotes. No space after comma
     * @param {int[]} [params.recvWindow]
     * @returns {object} an list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> cancelOrders(object ids, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " cancelOrders() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        if (isTrue(getValue(market, "spot")))
        {
            throw new NotSupported ((string)add(add(add(this.id, " cancelOrders() does not support "), getValue(market, "type")), " orders")) ;
        }
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object clientOrderIdList = this.safeList(parameters, "origClientOrderIdList");
        if (isTrue(!isEqual(clientOrderIdList, null)))
        {
            ((IDictionary<string,object>)request)["origClientOrderIdList"] = clientOrderIdList;
        } else
        {
            ((IDictionary<string,object>)request)["orderIdList"] = ids;
        }
        object response = await this.fapiPrivateDeleteV1BatchOrders(this.extend(request, parameters));
        //
        //    [
        //        {
        //            "clientOrderId": "myOrder1",
        //            "cumQty": "0",
        //            "cumQuote": "0",
        //            "executedQty": "0",
        //            "orderId": 283194212,
        //            "origQty": "11",
        //            "origType": "TRAILING_STOP_MARKET",
        //            "price": "0",
        //            "reduceOnly": false,
        //            "side": "BUY",
        //            "positionSide": "SHORT",
        //            "status": "CANCELED",
        //            "stopPrice": "9300",                  // please ignore when order type is TRAILING_STOP_MARKET
        //            "closePosition": false,               // if Close-All
        //            "symbol": "BTCUSDT",
        //            "timeInForce": "GTC",
        //            "type": "TRAILING_STOP_MARKET",
        //            "activatePrice": "9020",              // activation price, only return with TRAILING_STOP_MARKET order
        //            "priceRate": "0.3",                   // callback rate, only return with TRAILING_STOP_MARKET order
        //            "updateTime": 1571110484038,
        //            "workingType": "CONTRACT_PRICE",
        //            "priceProtect": false,                // if conditional order trigger is protected
        //        },
        //        {
        //            "code": -2011,
        //            "msg": "Unknown order sent."
        //        }
        //    ]
        //
        return this.parseOrders(response, market);
    }

    /**
     * @method
     * @name aster#setLeverage
     * @description set the level of leverage for a market
     * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-futures-api.md#change-initial-leverage-trade
     * @param {float} leverage the rate of leverage
     * @param {string} symbol unified market symbol
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} response from the exchange
     */
    public async override Task<object> setLeverage(object leverage, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " setLeverage() requires a symbol argument")) ;
        }
        if (isTrue(isTrue((isLessThan(leverage, 1))) || isTrue((isGreaterThan(leverage, 125)))))
        {
            throw new BadRequest ((string)add(this.id, " leverage should be between 1 and 125")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
            { "leverage", leverage },
        };
        object response = await this.fapiPrivatePostV1Leverage(this.extend(request, parameters));
        //
        //     {
        //         "leverage": 21,
        //         "maxNotionalValue": "1000000",
        //         "symbol": "BTCUSDT"
        //     }
        //
        return response;
    }

    /**
     * @method
     * @name aster#fetchLeverages
     * @description fetch the set leverage for all markets
     * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-futures-api.md#position-information-v2-user_data
     * @param {string[]} [symbols] a list of unified market symbols
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a list of [leverage structures]{@link https://docs.ccxt.com/#/?id=leverage-structure}
     */
    public async override Task<object> fetchLeverages(object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.fapiPrivateGetV2PositionRisk(parameters);
        //
        //     [
        //         {
        //             "symbol": "INJUSDT",
        //             "positionAmt": "0.0",
        //             "entryPrice": "0.0",
        //             "markPrice": "0.00000000",
        //             "unRealizedProfit": "0.00000000",
        //             "liquidationPrice": "0",
        //             "leverage": "20",
        //             "maxNotionalValue": "25000",
        //             "marginType": "cross",
        //             "isolatedMargin": "0.00000000",
        //             "isAutoAddMargin": "false",
        //             "positionSide": "BOTH",
        //             "notional": "0",
        //             "isolatedWallet": "0",
        //             "updateTime": 0
        //         }
        //     ]
        //
        return this.parseLeverages(response, symbols, "symbol");
    }

    public override object parseLeverage(object leverage, object market = null)
    {
        //
        //     {
        //         "symbol": "INJUSDT",
        //         "positionAmt": "0.0",
        //         "entryPrice": "0.0",
        //         "markPrice": "0.00000000",
        //         "unRealizedProfit": "0.00000000",
        //         "liquidationPrice": "0",
        //         "leverage": "20",
        //         "maxNotionalValue": "25000",
        //         "marginType": "cross",
        //         "isolatedMargin": "0.00000000",
        //         "isAutoAddMargin": "false",
        //         "positionSide": "BOTH",
        //         "notional": "0",
        //         "isolatedWallet": "0",
        //         "updateTime": 0
        //     }
        //
        object marketId = this.safeString(leverage, "symbol");
        object marginMode = this.safeStringLower(leverage, "marginType");
        object side = this.safeStringLower(leverage, "positionSide");
        object longLeverage = null;
        object shortLeverage = null;
        object leverageValue = this.safeInteger(leverage, "leverage");
        if (isTrue(isTrue((isEqual(side, null))) || isTrue((isEqual(side, "both")))))
        {
            longLeverage = leverageValue;
            shortLeverage = leverageValue;
        } else if (isTrue(isEqual(side, "long")))
        {
            longLeverage = leverageValue;
        } else if (isTrue(isEqual(side, "short")))
        {
            shortLeverage = leverageValue;
        }
        return new Dictionary<string, object>() {
            { "info", leverage },
            { "symbol", this.safeSymbol(marketId, market) },
            { "marginMode", marginMode },
            { "longLeverage", longLeverage },
            { "shortLeverage", shortLeverage },
        };
    }

    /**
     * @method
     * @name aster#fetchMarginModes
     * @description fetches margin mode of the user
     * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-futures-api.md#position-information-v2-user_data
     * @param {string[]} symbols unified market symbols
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a list of [margin mode structures]{@link https://docs.ccxt.com/#/?id=margin-mode-structure}
     */
    public async override Task<object> fetchMarginModes(object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.fapiPrivateGetV2PositionRisk(parameters);
        //
        //
        //     [
        //         {
        //             "symbol": "INJUSDT",
        //             "positionAmt": "0.0",
        //             "entryPrice": "0.0",
        //             "markPrice": "0.00000000",
        //             "unRealizedProfit": "0.00000000",
        //             "liquidationPrice": "0",
        //             "leverage": "20",
        //             "maxNotionalValue": "25000",
        //             "marginType": "cross",
        //             "isolatedMargin": "0.00000000",
        //             "isAutoAddMargin": "false",
        //             "positionSide": "BOTH",
        //             "notional": "0",
        //             "isolatedWallet": "0",
        //             "updateTime": 0
        //         }
        //     ]
        //
        //
        return this.parseMarginModes(response, symbols, "symbol", "swap");
    }

    public override object parseMarginMode(object marginMode, object market = null)
    {
        //
        //     {
        //         "symbol": "INJUSDT",
        //         "positionAmt": "0.0",
        //         "entryPrice": "0.0",
        //         "markPrice": "0.00000000",
        //         "unRealizedProfit": "0.00000000",
        //         "liquidationPrice": "0",
        //         "leverage": "20",
        //         "maxNotionalValue": "25000",
        //         "marginType": "cross",
        //         "isolatedMargin": "0.00000000",
        //         "isAutoAddMargin": "false",
        //         "positionSide": "BOTH",
        //         "notional": "0",
        //         "isolatedWallet": "0",
        //         "updateTime": 0
        //     }
        //
        object marketId = this.safeString(marginMode, "symbol");
        market = this.safeMarket(marketId, market);
        return new Dictionary<string, object>() {
            { "info", marginMode },
            { "symbol", getValue(market, "symbol") },
            { "marginMode", this.safeStringLower(marginMode, "marginType") },
        };
    }

    /**
     * @method
     * @name aster#fetchMarginAdjustmentHistory
     * @description fetches the history of margin added or reduced from contract isolated positions
     * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-futures-api.md#get-position-margin-change-history-trade
     * @param {string} symbol unified market symbol
     * @param {string} [type] "add" or "reduce"
     * @param {int} [since] timestamp in ms of the earliest change to fetch
     * @param {int} [limit] the maximum amount of changes to fetch
     * @param {object} params extra parameters specific to the exchange api endpoint
     * @param {int} [params.until] timestamp in ms of the latest change to fetch
     * @returns {object[]} a list of [margin structures]{@link https://docs.ccxt.com/#/?id=margin-loan-structure}
     */
    public async override Task<object> fetchMarginAdjustmentHistory(object symbol = null, object type = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchMarginAdjustmentHistory () requires a symbol argument")) ;
        }
        object market = this.market(symbol);
        object until = this.safeInteger(parameters, "until");
        parameters = this.omit(parameters, "until");
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        if (isTrue(!isEqual(type, null)))
        {
            ((IDictionary<string,object>)request)["type"] = ((bool) isTrue((isEqual(type, "add")))) ? 1 : 2;
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["startTime"] = since;
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        if (isTrue(!isEqual(until, null)))
        {
            ((IDictionary<string,object>)request)["endTime"] = until;
        }
        object response = await this.fapiPrivateGetV1PositionMarginHistory(this.extend(request, parameters));
        //
        //     [
        //         {
        //             "amount": "23.36332311",
        //             "asset": "USDT",
        //             "symbol": "BTCUSDT",
        //             "time": 1578047897183,
        //             "type": 1,
        //             "positionSide": "BOTH"
        //         }
        //     ]
        //
        object modifications = this.parseMarginModifications(response);
        return this.filterBySymbolSinceLimit(modifications, symbol, since, limit);
    }

    public override object parseMarginModification(object data, object market = null)
    {
        //
        //     {
        //         "amount": "100",
        //         "asset": "USDT",
        //         "symbol": "BTCUSDT",
        //         "time": 1578047900425,
        //         "type": 1,
        //         "positionSide": "LONG"
        //     }
        //
        //     {
        //         "amount": 100.0,
        //         "code": 200,
        //         "msg": "Successfully modify position margin.",
        //         "type": 1
        //     }
        //
        object rawType = this.safeInteger(data, "type");
        object errorCode = this.safeString(data, "code");
        object marketId = this.safeString(data, "symbol");
        object timestamp = this.safeInteger(data, "time");
        market = this.safeMarket(marketId, market, null, "swap");
        object noErrorCode = isEqual(errorCode, null);
        object success = isEqual(errorCode, "200");
        return new Dictionary<string, object>() {
            { "info", data },
            { "symbol", getValue(market, "symbol") },
            { "type", ((bool) isTrue((isEqual(rawType, 1)))) ? "add" : "reduce" },
            { "marginMode", "isolated" },
            { "amount", this.safeNumber(data, "amount") },
            { "code", this.safeString(data, "asset") },
            { "total", null },
            { "status", ((bool) isTrue((isTrue(success) || isTrue(noErrorCode)))) ? "ok" : "failed" },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
        };
    }

    public async virtual Task<object> modifyMarginHelper(object symbol, object amount, object addOrReduce, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        amount = this.amountToPrecision(symbol, amount);
        object request = new Dictionary<string, object>() {
            { "type", addOrReduce },
            { "symbol", getValue(market, "id") },
            { "amount", amount },
        };
        object code = getValue(market, "quote");
        object response = await this.fapiPrivatePostV1PositionMargin(this.extend(request, parameters));
        //
        //     {
        //         "amount": 100.0,
        //         "code": 200,
        //         "msg": "Successfully modify position margin.",
        //         "type": 1
        //     }
        //
        return this.extend(this.parseMarginModification(response, market), new Dictionary<string, object>() {
            { "code", code },
        });
    }

    /**
     * @method
     * @name aster#reduceMargin
     * @description remove margin from a position
     * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-futures-api.md#modify-isolated-position-margin-trade
     * @param {string} symbol unified market symbol
     * @param {float} amount the amount of margin to remove
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [margin structure]{@link https://docs.ccxt.com/#/?id=reduce-margin-structure}
     */
    public async override Task<object> reduceMargin(object symbol, object amount, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        return await this.modifyMarginHelper(symbol, amount, 2, parameters);
    }

    /**
     * @method
     * @name aster#addMargin
     * @description add margin
     * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-futures-api.md#modify-isolated-position-margin-trade
     * @param {string} symbol unified market symbol
     * @param {float} amount amount of margin to add
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [margin structure]{@link https://docs.ccxt.com/#/?id=add-margin-structure}
     */
    public async override Task<object> addMargin(object symbol, object amount, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        return await this.modifyMarginHelper(symbol, amount, 1, parameters);
    }

    public override object parseIncome(object income, object market = null)
    {
        //
        //     {
        //       "symbol": "ETHUSDT",
        //       "incomeType": "FUNDING_FEE",
        //       "income": "0.00134317",
        //       "asset": "USDT",
        //       "time": "1621584000000",
        //       "info": "FUNDING_FEE",
        //       "tranId": "4480321991774044580",
        //       "tradeId": ""
        //     }
        //
        object marketId = this.safeString(income, "symbol");
        object currencyId = this.safeString(income, "asset");
        object timestamp = this.safeInteger(income, "time");
        return new Dictionary<string, object>() {
            { "info", income },
            { "symbol", this.safeSymbol(marketId, market, null, "swap") },
            { "code", this.safeCurrencyCode(currencyId) },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "id", this.safeString(income, "tranId") },
            { "amount", this.safeNumber(income, "income") },
        };
    }

    /**
     * @method
     * @name aster#fetchFundingHistory
     * @description fetch the history of funding payments paid and received on this account
     * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-futures-api.md#get-income-historyuser_data
     * @param {string} symbol unified market symbol
     * @param {int} [since] the earliest time in ms to fetch funding history for
     * @param {int} [limit] the maximum number of funding history structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {int} [params.until] timestamp in ms of the latest funding history entry
     * @param {boolean} [params.portfolioMargin] set to true if you would like to fetch the funding history for a portfolio margin account
     * @param {string} [params.subType] "linear" or "inverse"
     * @returns {object} a [funding history structure]{@link https://docs.ccxt.com/#/?id=funding-history-structure}
     */
    public async override Task<object> fetchFundingHistory(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = null;
        object request = new Dictionary<string, object>() {
            { "incomeType", "FUNDING_FEE" },
        };
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
        }
        var requestparametersVariable = this.handleUntilOption("endTime", request, parameters);
        request = ((IList<object>)requestparametersVariable)[0];
        parameters = ((IList<object>)requestparametersVariable)[1];
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["startTime"] = since;
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = mathMin(limit, 1000); // max 1000
        }
        object response = await this.fapiPrivateGetV1Income(this.extend(request, parameters));
        return this.parseIncomes(response, market, since, limit);
    }

    public override object parseLedgerEntry(object item, object currency = null)
    {
        //
        //     {
        //         "symbol": "",
        //         "incomeType": "TRANSFER",
        //         "income": "10.00000000",
        //         "asset": "USDT",
        //         "time": 1677645250000,
        //         "info": "TRANSFER",
        //         "tranId": 131001573082,
        //         "tradeId": ""
        //     }
        //
        object amount = this.safeString(item, "income");
        object direction = null;
        if (isTrue(Precise.stringLe(amount, "0")))
        {
            direction = "out";
            amount = Precise.stringMul("-1", amount);
        } else
        {
            direction = "in";
        }
        object currencyId = this.safeString(item, "asset");
        object code = this.safeCurrencyCode(currencyId, currency);
        currency = this.safeCurrency(currencyId, currency);
        object timestamp = this.safeInteger(item, "time");
        object type = this.safeString(item, "incomeType");
        return this.safeLedgerEntry(new Dictionary<string, object>() {
            { "info", item },
            { "id", this.safeString(item, "tranId") },
            { "direction", direction },
            { "account", null },
            { "referenceAccount", null },
            { "referenceId", this.safeString(item, "tradeId") },
            { "type", this.parseLedgerEntryType(type) },
            { "currency", code },
            { "amount", this.parseNumber(amount) },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "before", null },
            { "after", null },
            { "status", null },
            { "fee", null },
        }, currency);
    }

    public virtual object parseLedgerEntryType(object type)
    {
        object ledgerType = new Dictionary<string, object>() {
            { "TRANSFER", "transfer" },
            { "WELCOME_BONUS", "cashback" },
            { "REALIZED_PNL", "trade" },
            { "FUNDING_FEE", "fee" },
            { "COMMISSION", "commission" },
            { "INSURANCE_CLEAR", "settlement" },
            { "MARKET_MERCHANT_RETURN_REWARD", "cashback" },
        };
        return this.safeString(ledgerType, type, type);
    }

    /**
     * @method
     * @name aster#fetchLedger
     * @description fetch the history of changes, actions done by the user or operations that altered the balance of the user
     * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-futures-api.md#get-income-historyuser_data
     * @param {string} [code] unified currency code
     * @param {int} [since] timestamp in ms of the earliest ledger entry
     * @param {int} [limit] max number of ledger entries to return
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {int} [params.until] timestamp in ms of the latest ledger entry
     * @returns {object} a [ledger structure]{@link https://docs.ccxt.com/#/?id=ledger}
     */
    public async override Task<object> fetchLedger(object code = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = null;
        if (isTrue(!isEqual(code, null)))
        {
            currency = this.currency(code);
        }
        object request = new Dictionary<string, object>() {};
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["startTime"] = since;
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = mathMin(limit, 1000); // max 1000
        }
        object until = this.safeInteger(parameters, "until");
        if (isTrue(!isEqual(until, null)))
        {
            parameters = this.omit(parameters, "until");
            ((IDictionary<string,object>)request)["endTime"] = until;
        }
        object response = await this.fapiPrivateGetV1Income(this.extend(request, parameters));
        //
        //     [
        //         {
        //             "symbol": "",
        //             "incomeType": "TRANSFER",
        //             "income": "10.00000000",
        //             "asset": "USDT",
        //             "time": 1677645250000,
        //             "info": "TRANSFER",
        //             "tranId": 131001573082,
        //             "tradeId": ""
        //         }
        //     ]
        //
        return this.parseLedger(response, currency, since, limit);
    }

    public virtual object parsePositionRisk(object position, object market = null)
    {
        //
        //     {
        //         "entryPrice": "6563.66500",
        //         "marginType": "isolated",
        //         "isAutoAddMargin": "false",
        //         "isolatedMargin": "15517.54150468",
        //         "leverage": "10",
        //         "liquidationPrice": "5930.78",
        //         "markPrice": "6679.50671178",
        //         "maxNotionalValue": "20000000",
        //         "positionSide": "LONG",
        //         "positionAmt": "20.000",
        //         "symbol": "BTCUSDT",
        //         "unRealizedProfit": "2316.83423560",
        //         "updateTime": 1625474304765
        //     }
        //
        object marketId = this.safeString(position, "symbol");
        market = this.safeMarket(marketId, market, null, "contract");
        object symbol = this.safeString(market, "symbol");
        object isolatedMarginString = this.safeString(position, "isolatedMargin");
        object leverageBrackets = this.safeDict(this.options, "leverageBrackets", new Dictionary<string, object>() {});
        object leverageBracket = this.safeList(leverageBrackets, symbol, new List<object>() {});
        object notionalString = this.safeString2(position, "notional", "notionalValue");
        object notionalStringAbs = Precise.stringAbs(notionalString);
        object maintenanceMarginPercentageString = null;
        for (object i = 0; isLessThan(i, getArrayLength(leverageBracket)); postFixIncrement(ref i))
        {
            object bracket = getValue(leverageBracket, i);
            if (isTrue(Precise.stringLt(notionalStringAbs, getValue(bracket, 0))))
            {
                break;
            }
            maintenanceMarginPercentageString = getValue(bracket, 1);
        }
        object notional = this.parseNumber(notionalStringAbs);
        object contractsAbs = Precise.stringAbs(this.safeString(position, "positionAmt"));
        object contracts = this.parseNumber(contractsAbs);
        object unrealizedPnlString = this.safeString(position, "unRealizedProfit");
        object unrealizedPnl = this.parseNumber(unrealizedPnlString);
        object liquidationPriceString = this.omitZero(this.safeString(position, "liquidationPrice"));
        object liquidationPrice = this.parseNumber(liquidationPriceString);
        object collateralString = null;
        object marginMode = this.safeString(position, "marginType");
        if (isTrue(isTrue(isEqual(marginMode, null)) && isTrue(!isEqual(isolatedMarginString, null))))
        {
            marginMode = ((bool) isTrue(Precise.stringEq(isolatedMarginString, "0"))) ? "cross" : "isolated";
        }
        object side = null;
        if (isTrue(Precise.stringGt(notionalString, "0")))
        {
            side = "long";
        } else if (isTrue(Precise.stringLt(notionalString, "0")))
        {
            side = "short";
        }
        object entryPriceString = this.safeString(position, "entryPrice");
        object entryPrice = this.parseNumber(entryPriceString);
        object contractSize = this.safeValue(market, "contractSize");
        object contractSizeString = this.numberToString(contractSize);
        // as oppose to notionalValue
        object linear = (inOp(position, "notional"));
        if (isTrue(isEqual(marginMode, "cross")))
        {
            // calculate collateral
            object precision = this.safeDict(market, "precision", new Dictionary<string, object>() {});
            object basePrecisionValue = this.safeString(precision, "base");
            object quotePrecisionValue = this.safeString2(precision, "quote", "price");
            object precisionIsUndefined = isTrue((isEqual(basePrecisionValue, null))) && isTrue((isEqual(quotePrecisionValue, null)));
            if (!isTrue(precisionIsUndefined))
            {
                if (isTrue(linear))
                {
                    // walletBalance = (liquidationPrice * (1 + mmp)  entryPrice) * contracts
                    object onePlusMaintenanceMarginPercentageString = null;
                    object entryPriceSignString = entryPriceString;
                    if (isTrue(isEqual(side, "short")))
                    {
                        onePlusMaintenanceMarginPercentageString = Precise.stringAdd("1", maintenanceMarginPercentageString);
                        entryPriceSignString = Precise.stringMul("-1", entryPriceSignString);
                    } else
                    {
                        onePlusMaintenanceMarginPercentageString = Precise.stringAdd("-1", maintenanceMarginPercentageString);
                    }
                    object inner = Precise.stringMul(liquidationPriceString, onePlusMaintenanceMarginPercentageString);
                    object leftSide = Precise.stringAdd(inner, entryPriceSignString);
                    object quotePrecision = this.precisionFromString(this.safeString2(precision, "quote", "price"));
                    if (isTrue(!isEqual(quotePrecision, null)))
                    {
                        collateralString = Precise.stringDiv(Precise.stringMul(leftSide, contractsAbs), "1", quotePrecision);
                    }
                } else
                {
                    // walletBalance = (contracts * contractSize) * (1/entryPrice - (1 - mmp) / liquidationPrice)
                    object onePlusMaintenanceMarginPercentageString = null;
                    object entryPriceSignString = entryPriceString;
                    if (isTrue(isEqual(side, "short")))
                    {
                        onePlusMaintenanceMarginPercentageString = Precise.stringSub("1", maintenanceMarginPercentageString);
                    } else
                    {
                        onePlusMaintenanceMarginPercentageString = Precise.stringSub("-1", maintenanceMarginPercentageString);
                        entryPriceSignString = Precise.stringMul("-1", entryPriceSignString);
                    }
                    object leftSide = Precise.stringMul(contractsAbs, contractSizeString);
                    object rightSide = Precise.stringSub(Precise.stringDiv("1", entryPriceSignString), Precise.stringDiv(onePlusMaintenanceMarginPercentageString, liquidationPriceString));
                    object basePrecision = this.precisionFromString(this.safeString(precision, "base"));
                    if (isTrue(!isEqual(basePrecision, null)))
                    {
                        collateralString = Precise.stringDiv(Precise.stringMul(leftSide, rightSide), "1", basePrecision);
                    }
                }
            }
        } else
        {
            collateralString = this.safeString(position, "isolatedMargin");
        }
        collateralString = ((bool) isTrue((isEqual(collateralString, null)))) ? "0" : collateralString;
        object collateral = this.parseNumber(collateralString);
        object markPrice = this.parseNumber(this.omitZero(this.safeString(position, "markPrice")));
        object timestamp = this.safeInteger(position, "updateTime");
        if (isTrue(isEqual(timestamp, 0)))
        {
            timestamp = null;
        }
        object maintenanceMarginPercentage = this.parseNumber(maintenanceMarginPercentageString);
        object maintenanceMarginString = Precise.stringMul(maintenanceMarginPercentageString, notionalStringAbs);
        if (isTrue(isEqual(maintenanceMarginString, null)))
        {
            // for a while, this new value was a backup to the existing calculations, but in future we might prioritize this
            maintenanceMarginString = this.safeString(position, "maintMargin");
        }
        object maintenanceMargin = this.parseNumber(maintenanceMarginString);
        object initialMarginString = null;
        object initialMarginPercentageString = null;
        object leverageString = this.safeString(position, "leverage");
        if (isTrue(!isEqual(leverageString, null)))
        {
            object leverage = parseInt(leverageString);
            object rational = this.isRoundNumber(mod(1000, leverage));
            initialMarginPercentageString = Precise.stringDiv("1", leverageString, 8);
            if (!isTrue(rational))
            {
                initialMarginPercentageString = Precise.stringAdd(initialMarginPercentageString, "1e-8");
            }
            object unrounded = Precise.stringMul(notionalStringAbs, initialMarginPercentageString);
            initialMarginString = Precise.stringDiv(unrounded, "1", 8);
        } else
        {
            initialMarginString = this.safeString(position, "initialMargin");
            object unrounded = Precise.stringMul(initialMarginString, "1");
            initialMarginPercentageString = Precise.stringDiv(unrounded, notionalStringAbs, 8);
        }
        object marginRatio = null;
        object percentage = null;
        if (!isTrue(Precise.stringEquals(collateralString, "0")))
        {
            marginRatio = this.parseNumber(Precise.stringDiv(Precise.stringAdd(Precise.stringDiv(maintenanceMarginString, collateralString), "5e-5"), "1", 4));
            percentage = this.parseNumber(Precise.stringMul(Precise.stringDiv(unrealizedPnlString, initialMarginString, 4), "100"));
        }
        object positionSide = this.safeString(position, "positionSide");
        object hedged = !isEqual(positionSide, "BOTH");
        return this.safePosition(new Dictionary<string, object>() {
            { "info", position },
            { "id", null },
            { "symbol", symbol },
            { "contracts", contracts },
            { "contractSize", contractSize },
            { "unrealizedPnl", unrealizedPnl },
            { "leverage", this.parseNumber(leverageString) },
            { "liquidationPrice", liquidationPrice },
            { "collateral", collateral },
            { "notional", notional },
            { "markPrice", markPrice },
            { "entryPrice", entryPrice },
            { "timestamp", timestamp },
            { "initialMargin", this.parseNumber(initialMarginString) },
            { "initialMarginPercentage", this.parseNumber(initialMarginPercentageString) },
            { "maintenanceMargin", maintenanceMargin },
            { "maintenanceMarginPercentage", maintenanceMarginPercentage },
            { "marginRatio", marginRatio },
            { "datetime", this.iso8601(timestamp) },
            { "marginMode", marginMode },
            { "side", side },
            { "hedged", hedged },
            { "percentage", percentage },
            { "stopLossPrice", null },
            { "takeProfitPrice", null },
        });
    }

    /**
     * @method
     * @name aster#fetchPositionsRisk
     * @description fetch positions risk
     * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-futures-api.md#position-information-v2-user_data
     * @param {string[]|undefined} symbols list of unified market symbols
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} data on the positions risk
     */
    public async override Task<object> fetchPositionsRisk(object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (isTrue(!isEqual(symbols, null)))
        {
            if (!isTrue(((symbols is IList<object>) || (symbols.GetType().IsGenericType && symbols.GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>))))))
            {
                throw new ArgumentsRequired ((string)add(this.id, " fetchPositionsRisk() requires an array argument for symbols")) ;
            }
        }
        await this.loadMarkets();
        await this.loadLeverageBrackets(false, parameters);
        object request = new Dictionary<string, object>() {};
        object response = await this.fapiPrivateGetV2PositionRisk(this.extend(request, parameters));
        //
        //     [
        //         {
        //             "entryPrice": "6563.66500",
        //             "marginType": "isolated",
        //             "isAutoAddMargin": "false",
        //             "isolatedMargin": "15517.54150468",
        //             "leverage": "10",
        //             "liquidationPrice": "5930.78",
        //             "markPrice": "6679.50671178",
        //             "maxNotionalValue": "20000000",
        //             "positionSide": "LONG",
        //             "positionAmt": "20.000", // negative value for 'SHORT'
        //             "symbol": "BTCUSDT",
        //             "unRealizedProfit": "2316.83423560",
        //             "updateTime": 1625474304765
        //         }
        //     ]
        //
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(response)); postFixIncrement(ref i))
        {
            object rawPosition = getValue(response, i);
            object entryPriceString = this.safeString(rawPosition, "entryPrice");
            if (isTrue(Precise.stringGt(entryPriceString, "0")))
            {
                ((IList<object>)result).Add(this.parsePositionRisk(getValue(response, i)));
            }
        }
        symbols = this.marketSymbols(symbols);
        return this.filterByArrayPositions(result, "symbol", symbols, false);
    }

    /**
     * @method
     * @name aster#fetchPositions
     * @description fetch all open positions
     * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-futures-api.md#position-information-v2-user_data
     * @param {string[]} [symbols] list of unified market symbols
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.method] method name to call, "positionRisk", "account" or "option", default is "positionRisk"
     * @returns {object[]} a list of [position structure]{@link https://docs.ccxt.com/#/?id=position-structure}
     */
    public async override Task<object> fetchPositions(object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object defaultMethod = null;
        var defaultMethodparametersVariable = this.handleOptionAndParams(parameters, "fetchPositions", "method");
        defaultMethod = ((IList<object>)defaultMethodparametersVariable)[0];
        parameters = ((IList<object>)defaultMethodparametersVariable)[1];
        if (isTrue(isEqual(defaultMethod, null)))
        {
            object options = this.safeDict(this.options, "fetchPositions");
            if (isTrue(isEqual(options, null)))
            {
                defaultMethod = this.safeString(this.options, "fetchPositions", "positionRisk");
            } else
            {
                defaultMethod = "positionRisk";
            }
        }
        if (isTrue(isEqual(defaultMethod, "positionRisk")))
        {
            return await this.fetchPositionsRisk(symbols, parameters);
        } else if (isTrue(isEqual(defaultMethod, "account")))
        {
            return await this.fetchAccountPositions(symbols, parameters);
        } else
        {
            throw new NotSupported ((string)add(add(add(this.id, ".options[\"fetchPositions\"][\"method\"] or params[\"method\"] = \""), defaultMethod), "\" is invalid, please choose between \"account\" and \"positionRisk\"")) ;
        }
    }

    public virtual object parseAccountPositions(object account, object filterClosed = null)
    {
        filterClosed ??= false;
        object positions = this.safeList(account, "positions");
        object assets = this.safeList(account, "assets", new List<object>() {});
        object balances = new Dictionary<string, object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(assets)); postFixIncrement(ref i))
        {
            object entry = getValue(assets, i);
            object currencyId = this.safeString(entry, "asset");
            object code = this.safeCurrencyCode(currencyId);
            object crossWalletBalance = this.safeString(entry, "crossWalletBalance");
            object crossUnPnl = this.safeString(entry, "crossUnPnl");
            ((IDictionary<string,object>)balances)[(string)code] = new Dictionary<string, object>() {
                { "crossMargin", Precise.stringAdd(crossWalletBalance, crossUnPnl) },
                { "crossWalletBalance", crossWalletBalance },
            };
        }
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(positions)); postFixIncrement(ref i))
        {
            object position = getValue(positions, i);
            object marketId = this.safeString(position, "symbol");
            object market = this.safeMarket(marketId, null, null, "contract");
            object code = ((bool) isTrue(getValue(market, "linear"))) ? getValue(market, "quote") : getValue(market, "base");
            object maintenanceMargin = this.safeString(position, "maintMargin");
            // check for maintenance margin so empty positions are not returned
            object isPositionOpen = isTrue((!isEqual(maintenanceMargin, "0"))) && isTrue((!isEqual(maintenanceMargin, "0.00000000")));
            if (isTrue(!isTrue(filterClosed) || isTrue(isPositionOpen)))
            {
                // sometimes not all the codes are correctly returned...
                if (isTrue(inOp(balances, code)))
                {
                    object parsed = this.parseAccountPosition(this.extend(position, new Dictionary<string, object>() {
                        { "crossMargin", getValue(getValue(balances, code), "crossMargin") },
                        { "crossWalletBalance", getValue(getValue(balances, code), "crossWalletBalance") },
                    }), market);
                    ((IList<object>)result).Add(parsed);
                }
            }
        }
        return result;
    }

    public virtual object parseAccountPosition(object position, object market = null)
    {
        object marketId = this.safeString(position, "symbol");
        market = this.safeMarket(marketId, market, null, "contract");
        object symbol = this.safeString(market, "symbol");
        object leverageString = this.safeString(position, "leverage");
        object leverage = ((bool) isTrue((!isEqual(leverageString, null)))) ? parseInt(leverageString) : null;
        object initialMarginString = this.safeString(position, "initialMargin");
        object initialMargin = this.parseNumber(initialMarginString);
        object initialMarginPercentageString = null;
        if (isTrue(!isEqual(leverageString, null)))
        {
            initialMarginPercentageString = Precise.stringDiv("1", leverageString, 8);
            object rational = this.isRoundNumber(mod(1000, leverage));
            if (!isTrue(rational))
            {
                initialMarginPercentageString = Precise.stringDiv(Precise.stringAdd(initialMarginPercentageString, "1e-8"), "1", 8);
            }
        }
        // as oppose to notionalValue
        object usdm = (inOp(position, "notional"));
        object maintenanceMarginString = this.safeString(position, "maintMargin");
        object maintenanceMargin = this.parseNumber(maintenanceMarginString);
        object entryPriceString = this.safeString(position, "entryPrice");
        object entryPrice = this.parseNumber(entryPriceString);
        object notionalString = this.safeString2(position, "notional", "notionalValue");
        object notionalStringAbs = Precise.stringAbs(notionalString);
        object notional = this.parseNumber(notionalStringAbs);
        object contractsString = this.safeString(position, "positionAmt");
        object contractsStringAbs = Precise.stringAbs(contractsString);
        if (isTrue(isEqual(contractsString, null)))
        {
            object entryNotional = Precise.stringMul(Precise.stringMul(leverageString, initialMarginString), entryPriceString);
            object contractSizeNew = this.safeString(market, "contractSize");
            contractsString = Precise.stringDiv(entryNotional, contractSizeNew);
            contractsStringAbs = Precise.stringDiv(Precise.stringAdd(contractsString, "0.5"), "1", 0);
        }
        object contracts = this.parseNumber(contractsStringAbs);
        object leverageBrackets = this.safeDict(this.options, "leverageBrackets", new Dictionary<string, object>() {});
        object leverageBracket = this.safeList(leverageBrackets, symbol, new List<object>() {});
        object maintenanceMarginPercentageString = null;
        for (object i = 0; isLessThan(i, getArrayLength(leverageBracket)); postFixIncrement(ref i))
        {
            object bracket = getValue(leverageBracket, i);
            if (isTrue(Precise.stringLt(notionalStringAbs, getValue(bracket, 0))))
            {
                break;
            }
            maintenanceMarginPercentageString = getValue(bracket, 1);
        }
        object maintenanceMarginPercentage = this.parseNumber(maintenanceMarginPercentageString);
        object unrealizedPnlString = this.safeString(position, "unrealizedProfit");
        object unrealizedPnl = this.parseNumber(unrealizedPnlString);
        object timestamp = this.safeInteger(position, "updateTime");
        if (isTrue(isEqual(timestamp, 0)))
        {
            timestamp = null;
        }
        object isolated = this.safeBool(position, "isolated");
        if (isTrue(isEqual(isolated, null)))
        {
            object isolatedMarginRaw = this.safeString(position, "isolatedMargin");
            isolated = !isTrue(Precise.stringEq(isolatedMarginRaw, "0"));
        }
        object marginMode = null;
        object collateralString = null;
        object walletBalance = null;
        if (isTrue(isolated))
        {
            marginMode = "isolated";
            walletBalance = this.safeString(position, "isolatedWallet");
            collateralString = Precise.stringAdd(walletBalance, unrealizedPnlString);
        } else
        {
            marginMode = "cross";
            walletBalance = this.safeString(position, "crossWalletBalance");
            collateralString = this.safeString(position, "crossMargin");
        }
        object collateral = this.parseNumber(collateralString);
        object marginRatio = null;
        object side = null;
        object percentage = null;
        object liquidationPriceStringRaw = null;
        object liquidationPrice = null;
        object contractSize = this.safeValue(market, "contractSize");
        object contractSizeString = this.numberToString(contractSize);
        if (isTrue(Precise.stringEquals(notionalString, "0")))
        {
            entryPrice = null;
        } else
        {
            side = ((bool) isTrue(Precise.stringLt(notionalString, "0"))) ? "short" : "long";
            marginRatio = this.parseNumber(Precise.stringDiv(Precise.stringAdd(Precise.stringDiv(maintenanceMarginString, collateralString), "5e-5"), "1", 4));
            percentage = this.parseNumber(Precise.stringMul(Precise.stringDiv(unrealizedPnlString, initialMarginString, 4), "100"));
            if (isTrue(usdm))
            {
                // calculate liquidation price
                //
                // liquidationPrice = (walletBalance / (contracts * (1 + mmp))) + (entryPrice / (1 + mmp))
                //
                // mmp = maintenanceMarginPercentage
                // where  is negative for long and positive for short
                // TODO: calculate liquidation price for coinm contracts
                object onePlusMaintenanceMarginPercentageString = null;
                object entryPriceSignString = entryPriceString;
                if (isTrue(isEqual(side, "short")))
                {
                    onePlusMaintenanceMarginPercentageString = Precise.stringAdd("1", maintenanceMarginPercentageString);
                } else
                {
                    onePlusMaintenanceMarginPercentageString = Precise.stringAdd("-1", maintenanceMarginPercentageString);
                    entryPriceSignString = Precise.stringMul("-1", entryPriceSignString);
                }
                object leftSide = Precise.stringDiv(walletBalance, Precise.stringMul(contractsStringAbs, onePlusMaintenanceMarginPercentageString));
                object rightSide = Precise.stringDiv(entryPriceSignString, onePlusMaintenanceMarginPercentageString);
                liquidationPriceStringRaw = Precise.stringAdd(leftSide, rightSide);
            } else
            {
                // calculate liquidation price
                //
                // liquidationPrice = (contracts * contractSize(1 - mmp)) / (1/entryPrice * contracts * contractSize - walletBalance)
                //
                object onePlusMaintenanceMarginPercentageString = null;
                object entryPriceSignString = entryPriceString;
                if (isTrue(isEqual(side, "short")))
                {
                    onePlusMaintenanceMarginPercentageString = Precise.stringSub("1", maintenanceMarginPercentageString);
                } else
                {
                    onePlusMaintenanceMarginPercentageString = Precise.stringSub("-1", maintenanceMarginPercentageString);
                    entryPriceSignString = Precise.stringMul("-1", entryPriceSignString);
                }
                object size = Precise.stringMul(contractsStringAbs, contractSizeString);
                object leftSide = Precise.stringMul(size, onePlusMaintenanceMarginPercentageString);
                object rightSide = Precise.stringSub(Precise.stringMul(Precise.stringDiv("1", entryPriceSignString), size), walletBalance);
                liquidationPriceStringRaw = Precise.stringDiv(leftSide, rightSide);
            }
            object pricePrecision = this.precisionFromString(this.safeString(getValue(market, "precision"), "price"));
            object pricePrecisionPlusOne = add(pricePrecision, 1);
            object pricePrecisionPlusOneString = ((object)pricePrecisionPlusOne).ToString();
            // round half up
            var rounder = new Precise(add("5e-", pricePrecisionPlusOneString));
            object rounderString = ((object)rounder).ToString();
            object liquidationPriceRoundedString = Precise.stringAdd(rounderString, liquidationPriceStringRaw);
            object truncatedLiquidationPrice = Precise.stringDiv(liquidationPriceRoundedString, "1", pricePrecision);
            if (isTrue(isEqual(getValue(truncatedLiquidationPrice, 0), "-")))
            {
                // user cannot be liquidated
                // since he has more collateral than the size of the position
                truncatedLiquidationPrice = null;
            }
            liquidationPrice = this.parseNumber(truncatedLiquidationPrice);
        }
        object positionSide = this.safeString(position, "positionSide");
        object hedged = !isEqual(positionSide, "BOTH");
        return new Dictionary<string, object>() {
            { "info", position },
            { "id", null },
            { "symbol", symbol },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "initialMargin", initialMargin },
            { "initialMarginPercentage", this.parseNumber(initialMarginPercentageString) },
            { "maintenanceMargin", maintenanceMargin },
            { "maintenanceMarginPercentage", maintenanceMarginPercentage },
            { "entryPrice", entryPrice },
            { "notional", notional },
            { "leverage", this.parseNumber(leverageString) },
            { "unrealizedPnl", unrealizedPnl },
            { "contracts", contracts },
            { "contractSize", contractSize },
            { "marginRatio", marginRatio },
            { "liquidationPrice", liquidationPrice },
            { "markPrice", null },
            { "collateral", collateral },
            { "marginMode", marginMode },
            { "side", side },
            { "hedged", hedged },
            { "percentage", percentage },
        };
    }

    /**
     * @method
     * @name aster#fetchAccountPositions
     * @ignore
     * @description fetch account positions
     * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-futures-api.md#position-information-v2-user_data
     * @param {string[]} [symbols] list of unified market symbols
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} data on account positions
     */
    public async virtual Task<object> fetchAccountPositions(object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (isTrue(!isEqual(symbols, null)))
        {
            if (!isTrue(((symbols is IList<object>) || (symbols.GetType().IsGenericType && symbols.GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>))))))
            {
                throw new ArgumentsRequired ((string)add(this.id, " fetchPositions() requires an array argument for symbols")) ;
            }
        }
        await this.loadMarkets();
        await this.loadLeverageBrackets(false, parameters);
        object response = await this.fapiPrivateGetV4Account(parameters);
        object filterClosed = null;
        var filterClosedparametersVariable = this.handleOptionAndParams(parameters, "fetchAccountPositions", "filterClosed", false);
        filterClosed = ((IList<object>)filterClosedparametersVariable)[0];
        parameters = ((IList<object>)filterClosedparametersVariable)[1];
        object result = this.parseAccountPositions(response, filterClosed);
        symbols = this.marketSymbols(symbols);
        return this.filterByArrayPositions(result, "symbol", symbols, false);
    }

    public async virtual Task<object> loadLeverageBrackets(object reload = null, object parameters = null)
    {
        reload ??= false;
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        // by default cache the leverage bracket
        // it contains useful stuff like the maintenance margin and initial margin for positions
        object leverageBrackets = this.safeDict(this.options, "leverageBrackets");
        if (isTrue(isTrue((isEqual(leverageBrackets, null))) || isTrue((reload))))
        {
            object response = await this.fapiPrivateGetV1LeverageBracket(parameters);
            ((IDictionary<string,object>)this.options)["leverageBrackets"] = this.createSafeDictionary();
            for (object i = 0; isLessThan(i, getArrayLength(response)); postFixIncrement(ref i))
            {
                object entry = getValue(response, i);
                object marketId = this.safeString(entry, "symbol");
                object symbol = this.safeSymbol(marketId, null, null, "contract");
                object brackets = this.safeList(entry, "brackets", new List<object>() {});
                object result = new List<object>() {};
                for (object j = 0; isLessThan(j, getArrayLength(brackets)); postFixIncrement(ref j))
                {
                    object bracket = getValue(brackets, j);
                    object floorValue = this.safeString(bracket, "notionalFloor");
                    object maintenanceMarginPercentage = this.safeString(bracket, "maintMarginRatio");
                    ((IList<object>)result).Add(new List<object>() {floorValue, maintenanceMarginPercentage});
                }
                ((IDictionary<string,object>)getValue(this.options, "leverageBrackets"))[(string)symbol] = result;
            }
        }
        return getValue(this.options, "leverageBrackets");
    }

    public virtual object keccakMessage(object message)
    {
        return add("0x", this.hash(message, keccak, "hex"));
    }

    public virtual object signMessage(object message, object privateKey)
    {
        return this.signHash(this.keccakMessage(message), slice(privateKey, -64, null));
    }

    public virtual object signWithdrawPayload(object withdrawPayload, object network)
    {
        object zeroAddress = this.safeString(this.options, "zeroAddress");
        object chainId = this.safeInteger(withdrawPayload, "chainId");
        object domain = new Dictionary<string, object>() {
            { "chainId", chainId },
            { "name", "Aster" },
            { "verifyingContract", zeroAddress },
            { "version", "1" },
        };
        object messageTypes = new Dictionary<string, object>() {
            { "Action", new List<object>() {new Dictionary<string, object>() {
    { "name", "type" },
    { "type", "string" },
}, new Dictionary<string, object>() {
    { "name", "destination" },
    { "type", "address" },
}, new Dictionary<string, object>() {
    { "name", "destination Chain" },
    { "type", "string" },
}, new Dictionary<string, object>() {
    { "name", "token" },
    { "type", "string" },
}, new Dictionary<string, object>() {
    { "name", "amount" },
    { "type", "string" },
}, new Dictionary<string, object>() {
    { "name", "fee" },
    { "type", "string" },
}, new Dictionary<string, object>() {
    { "name", "nonce" },
    { "type", "uint256" },
}, new Dictionary<string, object>() {
    { "name", "aster chain" },
    { "type", "string" },
}} },
        };
        object withdraw = new Dictionary<string, object>() {
            { "type", "Withdraw" },
            { "destination", this.safeString(withdrawPayload, "receiver") },
            { "destination Chain", network },
            { "token", this.safeString(withdrawPayload, "asset") },
            { "amount", this.safeString(withdrawPayload, "amount") },
            { "fee", this.safeString(withdrawPayload, "fee") },
            { "nonce", this.safeInteger(withdrawPayload, "nonce") },
            { "aster chain", "Mainnet" },
        };
        object msg = this.ethEncodeStructuredData(domain, messageTypes, withdraw);
        object signature = this.signMessage(msg, this.privateKey);
        return signature;
    }

    /**
     * @method
     * @name aster#withdraw
     * @description make a withdrawal
     * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-spot-api.md#withdraw-user_data
     * @param {string} code unified currency code
     * @param {float} amount the amount to withdraw
     * @param {string} address the address to withdraw to
     * @param {string} tag
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
     */
    public async override Task<object> withdraw(object code, object amount, object address, object tag = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        var tagparametersVariable = this.handleWithdrawTagAndParams(tag, parameters);
        tag = ((IList<object>)tagparametersVariable)[0];
        parameters = ((IList<object>)tagparametersVariable)[1];
        this.checkAddress(address);
        await this.loadMarkets();
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "asset", getValue(currency, "id") },
            { "receiver", address },
            { "nonce", multiply(this.milliseconds(), 1000) },
        };
        object chainId = this.safeInteger(parameters, "chainId");
        // TODO: check how ARBI signature would work
        object networks = this.safeDict(this.options, "networks", new Dictionary<string, object>() {});
        object network = this.safeStringUpper(parameters, "network");
        network = this.safeString(networks, network, network);
        if (isTrue(isTrue((isEqual(chainId, null))) && isTrue((!isEqual(network, null)))))
        {
            object chainIds = this.safeDict(this.options, "networksToChainId", new Dictionary<string, object>() {});
            chainId = this.safeInteger(chainIds, network);
        }
        if (isTrue(isEqual(chainId, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " withdraw require chainId or network parameter")) ;
        }
        ((IDictionary<string,object>)request)["chainId"] = chainId;
        object fee = this.safeString(parameters, "fee");
        if (isTrue(isEqual(fee, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " withdraw require fee parameter")) ;
        }
        ((IDictionary<string,object>)request)["fee"] = fee;
        parameters = this.omit(parameters, new List<object>() {"chainId", "network", "fee"});
        ((IDictionary<string,object>)request)["amount"] = this.currencyToPrecision(code, amount, network);
        ((IDictionary<string,object>)request)["userSignature"] = this.signWithdrawPayload(request, network);
        object response = await this.sapiPrivatePostV1AsterUserWithdraw(this.extend(request, parameters));
        return new Dictionary<string, object>() {
            { "info", response },
            { "id", this.safeString(response, "withdrawId") },
            { "txid", this.safeString(response, "hash") },
            { "timestamp", null },
            { "datetime", null },
            { "network", network },
            { "address", address },
            { "addressTo", address },
            { "addressFrom", null },
            { "tag", tag },
            { "tagTo", tag },
            { "tagFrom", null },
            { "type", "withdrawal" },
            { "amount", amount },
            { "currency", code },
            { "status", null },
            { "updated", null },
            { "internal", null },
            { "comment", null },
            { "fee", null },
        };
    }

    /**
     * @method
     * @name aster#transfer
     * @description transfer currency internally between wallets on the same account
     * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-spot-api.md#transfer-asset-to-other-address-trade
     * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-futures-api.md#transfer-between-futures-and-spot-user_data
     * @param {string} code unified currency code
     * @param {float} amount amount to transfer
     * @param {string} fromAccount account to transfer from
     * @param {string} toAccount account to transfer to
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [transfer structure]{@link https://docs.ccxt.com/#/?id=transfer-structure}
     */
    public async override Task<object> transfer(object code, object amount, object fromAccount, object toAccount, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "asset", getValue(currency, "id") },
            { "amount", this.currencyToPrecision(code, amount) },
        };
        object type = null;
        object fromId = null;
        if (isTrue(!isEqual(fromAccount, null)))
        {
            fromId = ((string)this.convertTypeToAccount(fromAccount)).ToUpper();
        }
        object toId = null;
        if (isTrue(!isEqual(toAccount, null)))
        {
            toId = ((string)this.convertTypeToAccount(toAccount)).ToUpper();
        }
        if (isTrue(isTrue(isEqual(fromId, "SPOT")) && isTrue(isEqual(toId, "FUTURE"))))
        {
            type = "SPOT_FUTURE";
        } else if (isTrue(isTrue(isEqual(fromId, "FUTURE")) && isTrue(isEqual(toId, "SPOT"))))
        {
            type = "FUTURE_SPOT";
        }
        object response = null;
        if (isTrue(!isEqual(type, null)))
        {
            object defaultClientTranId = this.numberToString(this.milliseconds());
            object clientTranId = this.safeString(parameters, "clientTranId", defaultClientTranId);
            ((IDictionary<string,object>)request)["kindType"] = type;
            ((IDictionary<string,object>)request)["clientTranId"] = clientTranId;
            response = await this.fapiPrivatePostV1AssetWalletTransfer(this.extend(request, parameters));
        } else
        {
            // transfer asset to other address
            ((IDictionary<string,object>)request)["toAddress"] = toAccount;
            response = await this.sapiPrivatePostV1AssetSendToAddress(this.extend(request, parameters));
        }
        //
        //     {
        //         "tranId":13526853623,
        //         "status": "SUCCESS"
        //     }
        //
        return new Dictionary<string, object>() {
            { "info", response },
            { "id", this.safeString(response, "tranId") },
            { "txid", null },
            { "timestamp", null },
            { "datetime", null },
            { "network", null },
            { "address", null },
            { "addressTo", fromAccount },
            { "addressFrom", toAccount },
            { "tag", null },
            { "tagTo", null },
            { "tagFrom", null },
            { "type", "transfer" },
            { "amount", amount },
            { "currency", code },
            { "status", null },
            { "updated", null },
            { "internal", null },
            { "comment", null },
            { "fee", null },
        };
    }

    public virtual object hashMessage(object binaryMessage)
    {
        // const binaryMessage = this.encode (message);
        object binaryMessageLength = this.binaryLength(binaryMessage);
        object x19 = this.base16ToBinary("19");
        object newline = this.base16ToBinary("0a");
        object prefix = this.binaryConcat(x19, this.encode("Ethereum Signed Message:"), newline, this.encode(this.numberToString(binaryMessageLength)));
        return add("0x", this.hash(this.binaryConcat(prefix, binaryMessage), keccak, "hex"));
    }

    public virtual object signHash(object hash, object privateKey)
    {
        this.checkRequiredCredentials();
        object signature = ecdsa(slice(hash, -64, null), slice(privateKey, -64, null), secp256k1, null);
        object r = getValue(signature, "r");
        object s = getValue(signature, "s");
        object v = this.intToBase16(this.sum(27, getValue(signature, "v")));
        return add(add(add("0x", (r as String).PadLeft(Convert.ToInt32(64), Convert.ToChar("0"))), (s as String).PadLeft(Convert.ToInt32(64), Convert.ToChar("0"))), v);
    }

    public override object sign(object path, object api = null, object method = null, object parameters = null, object headers = null, object body = null)
    {
        api ??= "public";
        method ??= "GET";
        parameters ??= new Dictionary<string, object>();
        object url = add(add(this.implodeHostname(getValue(getValue(this.urls, "api"), api)), "/"), path);
        if (isTrue(isTrue(isEqual(api, "fapiPublic")) || isTrue(isEqual(api, "sapiPublic"))))
        {
            if (isTrue(getArrayLength(new List<object>(((IDictionary<string,object>)parameters).Keys))))
            {
                url = add(url, add("?", this.rawencode(parameters)));
            }
        } else if (isTrue(isTrue(isEqual(api, "fapiPrivate")) || isTrue(isEqual(api, "sapiPrivate"))))
        {
            this.checkRequiredCredentials();
            headers = new Dictionary<string, object>() {
                { "X-MBX-APIKEY", this.apiKey },
            };
            object timestamp = this.milliseconds();
            // Nonce is in microseconds
            object nonce = this.microseconds();
            object defaultRecvWindow = this.safeInteger(this.options, "recvWindow");
            object extendedParams = this.extend(new Dictionary<string, object>() {
                { "timestamp", timestamp },
            }, parameters);
            if (isTrue(!isEqual(defaultRecvWindow, null)))
            {
                ((IDictionary<string,object>)extendedParams)["recvWindow"] = defaultRecvWindow;
            }
            object recvWindow = this.safeInteger(parameters, "recvWindow");
            if (isTrue(!isEqual(recvWindow, null)))
            {
                ((IDictionary<string,object>)extendedParams)["recvWindow"] = recvWindow;
            }
            object query = null;
            if (isTrue(isTrue((isEqual(method, "DELETE"))) && isTrue((isEqual(path, "v1/batchOrders")))))
            {
                object orderidlist = this.safeList(extendedParams, "orderIdList", new List<object>() {});
                object origclientorderidlist = this.safeList(extendedParams, "origClientOrderIdList", new List<object>() {});
                extendedParams = this.omit(extendedParams, new List<object>() {"orderIdList", "origClientOrderIdList"});
                query = this.rawencode(extendedParams);
                object orderidlistLength = getArrayLength(orderidlist);
                object origclientorderidlistLength = getArrayLength(origclientorderidlist);
                if (isTrue(isGreaterThan(orderidlistLength, 0)))
                {
                    query = add(add(add(add(query, "&"), "orderidlist=%5B"), String.Join("%2C", ((IList<object>)orderidlist).ToArray())), "%5D");
                }
                if (isTrue(isGreaterThan(origclientorderidlistLength, 0)))
                {
                    query = add(add(add(add(query, "&"), "origclientorderidlist=%5B"), String.Join("%2C", ((IList<object>)origclientorderidlist).ToArray())), "%5D");
                }
            } else
            {
                query = this.rawencode(extendedParams);
            }
            object signature = "";
            if (isTrue(isGreaterThanOrEqual(getIndexOf(path, "v3"), 0)))
            {
                object signerAddress = getValue(this.options, "signerAddress");
                if (isTrue(isEqual(signerAddress, null)))
                {
                    throw new ArgumentsRequired ((string)add(this.id, " requires signerAddress in options when use v3 api")) ;
                }
                // the keys order matter
                object keys = new List<object>(((IDictionary<string,object>)extendedParams).Keys);
                object sortedKeys = this.sort(keys);
                object signingPayload = new Dictionary<string, object>() {};
                for (object i = 0; isLessThan(i, getArrayLength(sortedKeys)); postFixIncrement(ref i))
                {
                    object key = getValue(sortedKeys, i);
                    ((IDictionary<string,object>)signingPayload)[(string)key] = ((object)getValue(extendedParams, key)).ToString();
                }
                object signingHash = this.hashMessage(this.hash(this.ethAbiEncode(new List<object>() {"string", "address", "address", "uint256"}, new List<object> {this.json(signingPayload), this.walletAddress, signerAddress, nonce}), keccak, "binary"));
                signature = this.signHash(signingHash, this.privateKey);
                ((IDictionary<string,object>)extendedParams)["user"] = this.walletAddress;
                ((IDictionary<string,object>)extendedParams)["signer"] = signerAddress;
                ((IDictionary<string,object>)extendedParams)["nonce"] = nonce;
                query = this.rawencode(extendedParams);
            } else
            {
                signature = this.hmac(this.encode(query), this.encode(this.secret), sha256);
            }
            query = add(query, add(add("&", "signature="), signature));
            if (isTrue(isEqual(method, "GET")))
            {
                url = add(url, add("?", query));
            } else
            {
                body = query;
                ((IDictionary<string,object>)headers)["Content-Type"] = "application/x-www-form-urlencoded";
            }
        }
        return new Dictionary<string, object>() {
            { "url", url },
            { "method", method },
            { "body", body },
            { "headers", headers },
        };
    }

    public override object handleErrors(object httpCode, object reason, object url, object method, object headers, object body, object response, object requestHeaders, object requestBody)
    {
        if (isTrue(isEqual(response, null)))
        {
            return null;  // fallback to default error handler
        }
        //
        //    {
        //        "code": -1121,
        //        "msg": "Invalid symbol.",
        //    }
        //
        object code = this.safeString(response, "code");
        object message = this.safeString(response, "msg");
        if (isTrue(isTrue(!isEqual(code, null)) && isTrue(!isEqual(code, "200"))))
        {
            object feedback = add(add(this.id, " "), body);
            this.throwExactlyMatchedException(getValue(this.exceptions, "exact"), message, feedback);
            this.throwExactlyMatchedException(getValue(this.exceptions, "exact"), code, feedback);
            this.throwBroadlyMatchedException(getValue(this.exceptions, "broad"), message, feedback);
            throw new ExchangeError ((string)feedback) ;
        }
        return null;
    }
}
