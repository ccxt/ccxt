namespace ccxt;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

public partial class zonda : Exchange
{
    public override object describe()
    {
        return this.deepExtend(base.describe(), new Dictionary<string, object>() {
            { "id", "zonda" },
            { "name", "Zonda" },
            { "countries", new List<object>() {"EE"} },
            { "rateLimit", 1000 },
            { "has", new Dictionary<string, object>() {
                { "CORS", true },
                { "spot", true },
                { "margin", false },
                { "swap", false },
                { "future", false },
                { "option", false },
                { "addMargin", false },
                { "cancelAllOrders", false },
                { "cancelOrder", true },
                { "cancelOrders", false },
                { "closeAllPositions", false },
                { "closePosition", false },
                { "createDepositAddress", false },
                { "createOrder", true },
                { "createReduceOnlyOrder", false },
                { "fetchBalance", true },
                { "fetchBorrowRateHistories", false },
                { "fetchBorrowRateHistory", false },
                { "fetchCrossBorrowRate", false },
                { "fetchCrossBorrowRates", false },
                { "fetchDeposit", false },
                { "fetchDepositAddress", true },
                { "fetchDepositAddresses", true },
                { "fetchDeposits", null },
                { "fetchFundingHistory", false },
                { "fetchFundingRate", false },
                { "fetchFundingRateHistory", false },
                { "fetchFundingRates", false },
                { "fetchIndexOHLCV", false },
                { "fetchIsolatedBorrowRate", false },
                { "fetchIsolatedBorrowRates", false },
                { "fetchLedger", true },
                { "fetchLeverage", false },
                { "fetchLeverageTiers", false },
                { "fetchMarginMode", false },
                { "fetchMarkets", true },
                { "fetchMarkOHLCV", false },
                { "fetchMyTrades", true },
                { "fetchOHLCV", true },
                { "fetchOpenInterestHistory", false },
                { "fetchOpenOrder", false },
                { "fetchOpenOrders", true },
                { "fetchOrderBook", true },
                { "fetchOrderBooks", false },
                { "fetchPosition", false },
                { "fetchPositionMode", false },
                { "fetchPositions", false },
                { "fetchPositionsRisk", false },
                { "fetchPremiumIndexOHLCV", false },
                { "fetchTicker", true },
                { "fetchTickers", true },
                { "fetchTime", false },
                { "fetchTrades", true },
                { "fetchTradingFee", false },
                { "fetchTradingFees", false },
                { "fetchTransactionFee", false },
                { "fetchTransactionFees", false },
                { "fetchTransactions", null },
                { "fetchTransfer", false },
                { "fetchWithdrawal", false },
                { "fetchWithdrawals", null },
                { "reduceMargin", false },
                { "setLeverage", false },
                { "setMargin", false },
                { "setMarginMode", false },
                { "setPositionMode", false },
                { "transfer", true },
                { "withdraw", true },
            } },
            { "timeframes", new Dictionary<string, object>() {
                { "1m", "60" },
                { "3m", "180" },
                { "5m", "300" },
                { "15m", "900" },
                { "30m", "1800" },
                { "1h", "3600" },
                { "2h", "7200" },
                { "4h", "14400" },
                { "6h", "21600" },
                { "12h", "43200" },
                { "1d", "86400" },
                { "3d", "259200" },
                { "1w", "604800" },
            } },
            { "hostname", "zondacrypto.exchange" },
            { "urls", new Dictionary<string, object>() {
                { "referral", "https://auth.zondaglobal.com/ref/jHlbB4mIkdS1" },
                { "logo", "https://user-images.githubusercontent.com/1294454/159202310-a0e38007-5e7c-4ba9-a32f-c8263a0291fe.jpg" },
                { "www", "https://zondaglobal.com" },
                { "api", new Dictionary<string, object>() {
                    { "public", "https://{hostname}/API/Public" },
                    { "private", "https://{hostname}/API/Trading/tradingApi.php" },
                    { "v1_01Public", "https://api.{hostname}/rest" },
                    { "v1_01Private", "https://api.{hostname}/rest" },
                } },
                { "doc", new List<object>() {"https://docs.zondacrypto.exchange/", "https://github.com/BitBayNet/API"} },
                { "support", "https://zondaglobal.com/en/helpdesk/zonda-exchange" },
                { "fees", "https://zondaglobal.com/legal/zonda-exchange/fees" },
            } },
            { "api", new Dictionary<string, object>() {
                { "public", new Dictionary<string, object>() {
                    { "get", new List<object>() {"{id}/all", "{id}/market", "{id}/orderbook", "{id}/ticker", "{id}/trades"} },
                } },
                { "private", new Dictionary<string, object>() {
                    { "post", new List<object>() {"info", "trade", "cancel", "orderbook", "orders", "transfer", "withdraw", "history", "transactions"} },
                } },
                { "v1_01Public", new Dictionary<string, object>() {
                    { "get", new List<object>() {"trading/ticker", "trading/ticker/{symbol}", "trading/stats", "trading/stats/{symbol}", "trading/orderbook/{symbol}", "trading/transactions/{symbol}", "trading/candle/history/{symbol}/{resolution}"} },
                } },
                { "v1_01Private", new Dictionary<string, object>() {
                    { "get", new List<object>() {"api_payments/deposits/crypto/addresses", "payments/withdrawal/{detailId}", "payments/deposit/{detailId}", "trading/offer", "trading/stop/offer", "trading/config/{symbol}", "trading/history/transactions", "balances/BITBAY/history", "balances/BITBAY/balance", "fiat_cantor/rate/{baseId}/{quoteId}", "fiat_cantor/history", "client_payments/v2/customer/crypto/{currency}/channels/deposit", "client_payments/v2/customer/crypto/{currency}/channels/withdrawal", "client_payments/v2/customer/crypto/deposit/fee", "client_payments/v2/customer/crypto/withdrawal/fee"} },
                    { "post", new List<object>() {"trading/offer/{symbol}", "trading/stop/offer/{symbol}", "trading/config/{symbol}", "balances/BITBAY/balance", "balances/BITBAY/balance/transfer/{source}/{destination}", "fiat_cantor/exchange", "api_payments/withdrawals/crypto", "api_payments/withdrawals/fiat", "client_payments/v2/customer/crypto/deposit", "client_payments/v2/customer/crypto/withdrawal"} },
                    { "delete", new List<object>() {"trading/offer/{symbol}/{id}/{side}/{price}", "trading/stop/offer/{symbol}/{id}/{side}/{price}"} },
                    { "put", new List<object>() {"balances/BITBAY/balance/{id}"} },
                } },
            } },
            { "fees", new Dictionary<string, object>() {
                { "trading", new Dictionary<string, object>() {
                    { "maker", this.parseNumber("0.0") },
                    { "taker", this.parseNumber("0.001") },
                    { "percentage", true },
                    { "tierBased", false },
                } },
                { "fiat", new Dictionary<string, object>() {
                    { "maker", this.parseNumber("0.0030") },
                    { "taker", this.parseNumber("0.0043") },
                    { "percentage", true },
                    { "tierBased", true },
                    { "tiers", new Dictionary<string, object>() {
                        { "taker", new List<object>() {new List<object> {this.parseNumber("0.0043"), this.parseNumber("0")}, new List<object> {this.parseNumber("0.0042"), this.parseNumber("1250")}, new List<object> {this.parseNumber("0.0041"), this.parseNumber("3750")}, new List<object> {this.parseNumber("0.0040"), this.parseNumber("7500")}, new List<object> {this.parseNumber("0.0039"), this.parseNumber("10000")}, new List<object> {this.parseNumber("0.0038"), this.parseNumber("15000")}, new List<object> {this.parseNumber("0.0037"), this.parseNumber("20000")}, new List<object> {this.parseNumber("0.0036"), this.parseNumber("25000")}, new List<object> {this.parseNumber("0.0035"), this.parseNumber("37500")}, new List<object> {this.parseNumber("0.0034"), this.parseNumber("50000")}, new List<object> {this.parseNumber("0.0033"), this.parseNumber("75000")}, new List<object> {this.parseNumber("0.0032"), this.parseNumber("100000")}, new List<object> {this.parseNumber("0.0031"), this.parseNumber("150000")}, new List<object> {this.parseNumber("0.0030"), this.parseNumber("200000")}, new List<object> {this.parseNumber("0.0029"), this.parseNumber("250000")}, new List<object> {this.parseNumber("0.0028"), this.parseNumber("375000")}, new List<object> {this.parseNumber("0.0027"), this.parseNumber("500000")}, new List<object> {this.parseNumber("0.0026"), this.parseNumber("625000")}, new List<object> {this.parseNumber("0.0025"), this.parseNumber("875000")}} },
                        { "maker", new List<object>() {new List<object> {this.parseNumber("0.0030"), this.parseNumber("0")}, new List<object> {this.parseNumber("0.0029"), this.parseNumber("1250")}, new List<object> {this.parseNumber("0.0028"), this.parseNumber("3750")}, new List<object> {this.parseNumber("0.0028"), this.parseNumber("7500")}, new List<object> {this.parseNumber("0.0027"), this.parseNumber("10000")}, new List<object> {this.parseNumber("0.0026"), this.parseNumber("15000")}, new List<object> {this.parseNumber("0.0025"), this.parseNumber("20000")}, new List<object> {this.parseNumber("0.0025"), this.parseNumber("25000")}, new List<object> {this.parseNumber("0.0024"), this.parseNumber("37500")}, new List<object> {this.parseNumber("0.0023"), this.parseNumber("50000")}, new List<object> {this.parseNumber("0.0023"), this.parseNumber("75000")}, new List<object> {this.parseNumber("0.0022"), this.parseNumber("100000")}, new List<object> {this.parseNumber("0.0021"), this.parseNumber("150000")}, new List<object> {this.parseNumber("0.0021"), this.parseNumber("200000")}, new List<object> {this.parseNumber("0.0020"), this.parseNumber("250000")}, new List<object> {this.parseNumber("0.0019"), this.parseNumber("375000")}, new List<object> {this.parseNumber("0.0018"), this.parseNumber("500000")}, new List<object> {this.parseNumber("0.0018"), this.parseNumber("625000")}, new List<object> {this.parseNumber("0.0017"), this.parseNumber("875000")}} },
                    } },
                } },
                { "funding", new Dictionary<string, object>() {
                    { "withdraw", new Dictionary<string, object>() {} },
                } },
            } },
            { "options", new Dictionary<string, object>() {
                { "fetchTickerMethod", "v1_01PublicGetTradingTickerSymbol" },
                { "fetchTickersMethod", "v1_01PublicGetTradingTicker" },
                { "fiatCurrencies", new List<object>() {"EUR", "USD", "GBP", "PLN"} },
                { "transfer", new Dictionary<string, object>() {
                    { "fillResponseFromRequest", true },
                } },
            } },
            { "precisionMode", TICK_SIZE },
            { "exceptions", new Dictionary<string, object>() {
                { "400", typeof(ExchangeError) },
                { "401", typeof(InvalidOrder) },
                { "402", typeof(InvalidOrder) },
                { "403", typeof(InvalidOrder) },
                { "404", typeof(InvalidOrder) },
                { "405", typeof(InvalidOrder) },
                { "406", typeof(InsufficientFunds) },
                { "408", typeof(InvalidOrder) },
                { "501", typeof(AuthenticationError) },
                { "502", typeof(AuthenticationError) },
                { "503", typeof(InvalidNonce) },
                { "504", typeof(ExchangeError) },
                { "505", typeof(AuthenticationError) },
                { "506", typeof(AccountSuspended) },
                { "509", typeof(ExchangeError) },
                { "510", typeof(BadSymbol) },
                { "FUNDS_NOT_SUFFICIENT", typeof(InsufficientFunds) },
                { "OFFER_FUNDS_NOT_EXCEEDING_MINIMUMS", typeof(InvalidOrder) },
                { "OFFER_NOT_FOUND", typeof(OrderNotFound) },
                { "OFFER_WOULD_HAVE_BEEN_PARTIALLY_FILLED", typeof(OrderImmediatelyFillable) },
                { "ACTION_LIMIT_EXCEEDED", typeof(RateLimitExceeded) },
                { "UNDER_MAINTENANCE", typeof(OnMaintenance) },
                { "REQUEST_TIMESTAMP_TOO_OLD", typeof(InvalidNonce) },
                { "PERMISSIONS_NOT_SUFFICIENT", typeof(PermissionDenied) },
                { "INVALID_STOP_RATE", typeof(InvalidOrder) },
                { "TIMEOUT", typeof(ExchangeError) },
                { "RESPONSE_TIMEOUT", typeof(ExchangeError) },
                { "ACTION_BLOCKED", typeof(PermissionDenied) },
                { "INVALID_HASH_SIGNATURE", typeof(AuthenticationError) },
            } },
            { "commonCurrencies", new Dictionary<string, object>() {
                { "GGC", "Global Game Coin" },
            } },
        });
    }

    public async override Task<object> fetchMarkets(object parameters = null)
    {
        /**
        * @method
        * @name zonda#fetchMarkets
        * @see https://docs.zondacrypto.exchange/reference/ticker-1
        * @description retrieves data on all markets for zonda
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} an array of objects representing market data
        */
        parameters ??= new Dictionary<string, object>();
        object response = await this.v1_01PublicGetTradingTicker(parameters);
        //
        //     {
        //         "status": "Ok",
        //         "items": {
        //             "BSV-USD": {
        //                 "market": {
        //                     "code": "BSV-USD",
        //                     "first": { currency: "BSV", minOffer: "0.00035", scale: 8 },
        //                     "second": { currency: "USD", minOffer: "5", scale: 2 }
        //                 },
        //                 "time": "1557569762154",
        //                 "highestBid": "52.31",
        //                 "lowestAsk": "62.99",
        //                 "rate": "63",
        //                 "previousRate": "51.21",
        //             },
        //         },
        //     }
        //
        object items = this.safeValue(response, "items", new Dictionary<string, object>() {});
        object markets = new List<object>(((IDictionary<string,object>)items).Values);
        return this.parseMarkets(markets);
    }

    public override object parseMarket(object item)
    {
        object market = this.safeValue(item, "market", new Dictionary<string, object>() {});
        object id = this.safeString(market, "code");
        object first = this.safeValue(market, "first", new Dictionary<string, object>() {});
        object second = this.safeValue(market, "second", new Dictionary<string, object>() {});
        object baseId = this.safeString(first, "currency");
        object quoteId = this.safeString(second, "currency");
        object bs = this.safeCurrencyCode(baseId);
        object quote = this.safeCurrencyCode(quoteId);
        object fees = this.safeValue(this.fees, "trading", new Dictionary<string, object>() {});
        object fiatCurrencies = this.safeValue(this.options, "fiatCurrencies", new List<object>() {});
        if (isTrue(isTrue(this.inArray(bs, fiatCurrencies)) || isTrue(this.inArray(quote, fiatCurrencies))))
        {
            fees = this.safeValue(this.fees, "fiat", new Dictionary<string, object>() {});
        }
        // todo: check that the limits have ben interpreted correctly
        return new Dictionary<string, object>() {
            { "id", id },
            { "symbol", add(add(bs, "/"), quote) },
            { "base", bs },
            { "quote", quote },
            { "settle", null },
            { "baseId", baseId },
            { "quoteId", quoteId },
            { "settleId", null },
            { "type", "spot" },
            { "spot", true },
            { "margin", false },
            { "swap", false },
            { "future", false },
            { "option", false },
            { "active", null },
            { "contract", false },
            { "linear", null },
            { "inverse", null },
            { "taker", this.safeNumber(fees, "taker") },
            { "maker", this.safeNumber(fees, "maker") },
            { "contractSize", null },
            { "expiry", null },
            { "expiryDatetime", null },
            { "optionType", null },
            { "strike", null },
            { "precision", new Dictionary<string, object>() {
                { "amount", this.parseNumber(this.parsePrecision(this.safeString(first, "scale"))) },
                { "price", this.parseNumber(this.parsePrecision(this.safeString(second, "scale"))) },
            } },
            { "limits", new Dictionary<string, object>() {
                { "leverage", new Dictionary<string, object>() {
                    { "min", null },
                    { "max", null },
                } },
                { "amount", new Dictionary<string, object>() {
                    { "min", this.safeNumber(first, "minOffer") },
                    { "max", null },
                } },
                { "price", new Dictionary<string, object>() {
                    { "min", null },
                    { "max", null },
                } },
                { "cost", new Dictionary<string, object>() {
                    { "min", null },
                    { "max", null },
                } },
            } },
            { "created", null },
            { "info", item },
        };
    }

    public async override Task<object> fetchOpenOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name zonda#fetchOpenOrders
        * @see https://docs.zondacrypto.exchange/reference/active-orders
        * @description fetch all unfilled currently open orders
        * @param {string} symbol not used by zonda fetchOpenOrders
        * @param {int} [since] the earliest time in ms to fetch open orders for
        * @param {int} [limit] the maximum number of  open orders structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object response = await this.v1_01PrivateGetTradingOffer(this.extend(request, parameters));
        object items = this.safeList(response, "items", new List<object>() {});
        return this.parseOrders(items, null, since, limit, new Dictionary<string, object>() {
            { "status", "open" },
        });
    }

    public override object parseOrder(object order, object market = null)
    {
        //
        //     {
        //         "market": "ETH-EUR",
        //         "offerType": "Sell",
        //         "id": "93d3657b-d616-11e9-9248-0242ac110005",
        //         "currentAmount": "0.04",
        //         "lockedAmount": "0.04",
        //         "rate": "280",
        //         "startAmount": "0.04",
        //         "time": "1568372806924",
        //         "postOnly": false,
        //         "hidden": false,
        //         "mode": "limit",
        //         "receivedAmount": "0.0",
        //         "firstBalanceId": "5b816c3e-437c-4e43-9bef-47814ae7ebfc",
        //         "secondBalanceId": "ab43023b-4079-414c-b340-056e3430a3af"
        //     }
        //
        // cancelOrder
        //
        //    {
        //        status: "Ok",
        //        errors: []
        //    }
        //
        object marketId = this.safeString(order, "market");
        object symbol = this.safeSymbol(marketId, market, "-");
        object timestamp = this.safeInteger(order, "time");
        object amount = this.safeString(order, "startAmount");
        object remaining = this.safeString(order, "currentAmount");
        object postOnly = this.safeValue(order, "postOnly");
        return this.safeOrder(new Dictionary<string, object>() {
            { "id", this.safeString(order, "id") },
            { "clientOrderId", null },
            { "info", order },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "lastTradeTimestamp", null },
            { "status", null },
            { "symbol", symbol },
            { "type", this.safeString(order, "mode") },
            { "timeInForce", null },
            { "postOnly", postOnly },
            { "side", this.safeStringLower(order, "offerType") },
            { "price", this.safeString(order, "rate") },
            { "stopPrice", null },
            { "triggerPrice", null },
            { "amount", amount },
            { "cost", null },
            { "filled", null },
            { "remaining", remaining },
            { "average", null },
            { "fee", null },
            { "trades", null },
        }, market);
    }

    public async override Task<object> fetchMyTrades(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name zonda#fetchMyTrades
        * @see https://docs.zondacrypto.exchange/reference/transactions-history
        * @description fetch all trades made by the user
        * @param {string} symbol unified market symbol
        * @param {int} [since] the earliest time in ms to fetch trades for
        * @param {int} [limit] the maximum number of trades structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        if (isTrue(symbol))
        {
            object markets = new List<object> {this.marketId(symbol)};
            symbol = this.symbol(symbol);
            ((IDictionary<string,object>)request)["markets"] = markets;
        }
        object query = new Dictionary<string, object>() {
            { "query", this.json(this.extend(request, parameters)) },
        };
        object response = await this.v1_01PrivateGetTradingHistoryTransactions(query);
        //
        //     {
        //         "status": "Ok",
        //         "totalRows": "67",
        //         "items": [
        //             {
        //                 "id": "b54659a0-51b5-42a0-80eb-2ac5357ccee2",
        //                 "market": "BTC-EUR",
        //                 "time": "1541697096247",
        //                 "amount": "0.00003",
        //                 "rate": "4341.44",
        //                 "initializedBy": "Sell",
        //                 "wasTaker": false,
        //                 "userAction": "Buy",
        //                 "offerId": "bd19804a-6f89-4a69-adb8-eb078900d006",
        //                 "commissionValue": null
        //             },
        //         ]
        //     }
        //
        object items = this.safeValue(response, "items");
        object result = this.parseTrades(items, null, since, limit);
        if (isTrue(isEqual(symbol, null)))
        {
            return result;
        }
        return this.filterBySymbol(result, symbol);
    }

    public override object parseBalance(object response)
    {
        object balances = this.safeValue(response, "balances");
        if (isTrue(isEqual(balances, null)))
        {
            throw new ExchangeError ((string)add(add(this.id, " empty balance response "), this.json(response))) ;
        }
        object result = new Dictionary<string, object>() {
            { "info", response },
        };
        for (object i = 0; isLessThan(i, getArrayLength(balances)); postFixIncrement(ref i))
        {
            object balance = getValue(balances, i);
            object currencyId = this.safeString(balance, "currency");
            object code = this.safeCurrencyCode(currencyId);
            object account = this.account();
            ((IDictionary<string,object>)account)["used"] = this.safeString(balance, "lockedFunds");
            ((IDictionary<string,object>)account)["free"] = this.safeString(balance, "availableFunds");
            ((IDictionary<string,object>)result)[(string)code] = account;
        }
        return this.safeBalance(result);
    }

    public async override Task<object> fetchBalance(object parameters = null)
    {
        /**
        * @method
        * @name zonda#fetchBalance
        * @see https://docs.zondacrypto.exchange/reference/list-of-wallets
        * @description query for balance and get the amount of funds available for trading or funds locked in orders
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.v1_01PrivateGetBalancesBITBAYBalance(parameters);
        return this.parseBalance(response);
    }

    public async override Task<object> fetchOrderBook(object symbol, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name zonda#fetchOrderBook
        * @see https://docs.zondacrypto.exchange/reference/orderbook-2
        * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
        * @param {string} symbol unified symbol of the market to fetch the order book for
        * @param {int} [limit] the maximum amount of order book entries to return
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object response = await this.v1_01PublicGetTradingOrderbookSymbol(this.extend(request, parameters));
        //
        //     {
        //         "status":"Ok",
        //         "sell":[
        //             {"ra":"43988.93","ca":"0.00100525","sa":"0.00100525","pa":"0.00100525","co":1},
        //             {"ra":"43988.94","ca":"0.00114136","sa":"0.00114136","pa":"0.00114136","co":1},
        //             {"ra":"43989","ca":"0.010578","sa":"0.010578","pa":"0.010578","co":1},
        //         ],
        //         "buy":[
        //             {"ra":"42157.33","ca":"2.83147881","sa":"2.83147881","pa":"2.83147881","co":2},
        //             {"ra":"42096.0","ca":"0.00011878","sa":"0.00011878","pa":"0.00011878","co":1},
        //             {"ra":"42022.0","ca":"0.00011899","sa":"0.00011899","pa":"0.00011899","co":1},
        //         ],
        //         "timestamp":"1642299886122",
        //         "seqNo":"27641254"
        //     }
        //
        object rawBids = this.safeValue(response, "buy", new List<object>() {});
        object rawAsks = this.safeValue(response, "sell", new List<object>() {});
        object timestamp = this.safeInteger(response, "timestamp");
        return new Dictionary<string, object>() {
            { "symbol", getValue(market, "symbol") },
            { "bids", this.parseBidsAsks(rawBids, "ra", "ca") },
            { "asks", this.parseBidsAsks(rawAsks, "ra", "ca") },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "nonce", this.safeInteger(response, "seqNo") },
        };
    }

    public override object parseTicker(object ticker, object market = null)
    {
        //
        // version 1
        //
        //    {
        //        "m": "ETH-PLN",
        //        "h": "13485.13",
        //        "l": "13100.01",
        //        "v": "126.10710939",
        //        "r24h": "13332.72"
        //    }
        //
        // version 2
        //
        //    {
        //        "market": {
        //            "code": "ADA-USDT",
        //            "first": {
        //                "currency": "ADA",
        //                "minOffer": "0.2",
        //                "scale": "6"
        //            },
        //            "second": {
        //                "currency": "USDT",
        //                "minOffer": "0.099",
        //                "scale": "6"
        //            },
        //            "amountPrecision": "6",
        //            "pricePrecision": "6",
        //            "ratePrecision": "6"
        //        },
        //        "time": "1655812661202",
        //        "highestBid": "0.492",
        //        "lowestAsk": "0.499389",
        //        "rate": "0.50588",
        //        "previousRate": "0.504981"
        //    }
        //
        object tickerMarket = this.safeValue(ticker, "market");
        object marketId = this.safeString2(tickerMarket, "code", "m");
        market = this.safeMarket(marketId, market);
        object timestamp = this.safeInteger(ticker, "time");
        object rate = this.safeValue(ticker, "rate");
        return this.safeTicker(new Dictionary<string, object>() {
            { "symbol", this.safeSymbol(marketId, market) },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "high", this.safeString(ticker, "h") },
            { "low", this.safeString(ticker, "l") },
            { "bid", this.safeNumber(ticker, "highestBid") },
            { "bidVolume", null },
            { "ask", this.safeNumber(ticker, "lowestAsk") },
            { "askVolume", null },
            { "vwap", null },
            { "open", this.safeString(ticker, "r24h") },
            { "close", rate },
            { "last", rate },
            { "previousClose", this.safeValue(ticker, "previousRate") },
            { "change", null },
            { "percentage", null },
            { "average", null },
            { "baseVolume", this.safeString(ticker, "v") },
            { "quoteVolume", null },
            { "info", ticker },
        }, market);
    }

    public async override Task<object> fetchTicker(object symbol, object parameters = null)
    {
        /**
        * @method
        * @name zonda#fetchTicker
        * @description v1_01PublicGetTradingTickerSymbol retrieves timestamp, datetime, bid, ask, close, last, previousClose, v1_01PublicGetTradingStatsSymbol retrieves high, low, volume and opening price of an asset
        * @see https://docs.zondacrypto.exchange/reference/market-statistics
        * @param {string} symbol unified symbol of the market to fetch the ticker for
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {string} [params.method] v1_01PublicGetTradingTickerSymbol (default) or v1_01PublicGetTradingStatsSymbol
        * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object method = "v1_01PublicGetTradingTickerSymbol";
        object defaultMethod = this.safeString(this.options, "fetchTickerMethod", method);
        object fetchTickerMethod = this.safeString2(parameters, "method", "fetchTickerMethod", defaultMethod);
        object response = null;
        if (isTrue(isEqual(fetchTickerMethod, method)))
        {
            response = await this.v1_01PublicGetTradingTickerSymbol(this.extend(request, parameters));
        } else if (isTrue(isEqual(fetchTickerMethod, "v1_01PublicGetTradingStatsSymbol")))
        {
            response = await this.v1_01PublicGetTradingStatsSymbol(this.extend(request, parameters));
        } else
        {
            throw new BadRequest ((string)add(this.id, " fetchTicker params[\"method\"] must be \"v1_01PublicGetTradingTickerSymbol\" or \"v1_01PublicGetTradingStatsSymbol\"")) ;
        }
        object stats = this.safeValue2(response, "ticker", "stats");
        return this.parseTicker(stats, market);
    }

    public async override Task<object> fetchTickers(object symbols = null, object parameters = null)
    {
        /**
        * @ignore
        * @method
        * @name zonda#fetchTickersV2
        * @description v1_01PublicGetTradingTicker retrieves timestamp, datetime, bid, ask, close, last, previousClose for each market, v1_01PublicGetTradingStats retrieves high, low, volume and opening price of each market
        * @see https://docs.zondacrypto.exchange/reference/market-statistics
        * @param {string[]|undefined} symbols unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {string} [params.method] v1_01PublicGetTradingTicker (default) or v1_01PublicGetTradingStats
        * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/#/?id=ticker-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object method = "v1_01PublicGetTradingTicker";
        object defaultMethod = this.safeString(this.options, "fetchTickersMethod", method);
        object fetchTickersMethod = this.safeString2(parameters, "method", "fetchTickersMethod", defaultMethod);
        object response = null;
        if (isTrue(isEqual(fetchTickersMethod, method)))
        {
            response = await this.v1_01PublicGetTradingTicker(parameters);
        } else if (isTrue(isEqual(fetchTickersMethod, "v1_01PublicGetTradingStats")))
        {
            response = await this.v1_01PublicGetTradingStats(parameters);
        } else
        {
            throw new BadRequest ((string)add(this.id, " fetchTickers params[\"method\"] must be \"v1_01PublicGetTradingTicker\" or \"v1_01PublicGetTradingStats\"")) ;
        }
        object items = this.safeDict(response, "items");
        return this.parseTickers(items, symbols);
    }

    public async override Task<object> fetchLedger(object code = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name zonda#fetchLedger
        * @description fetch the history of changes, actions done by the user or operations that altered the balance of the user
        * @see https://docs.zondacrypto.exchange/reference/operations-history
        * @param {string} [code] unified currency code, default is undefined
        * @param {int} [since] timestamp in ms of the earliest ledger entry, default is undefined
        * @param {int} [limit] max number of ledger entries to return, default is undefined
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [ledger structure]{@link https://docs.ccxt.com/#/?id=ledger-structure}
        */
        parameters ??= new Dictionary<string, object>();
        object balanceCurrencies = new List<object>() {};
        if (isTrue(!isEqual(code, null)))
        {
            object currency = this.currency(code);
            ((IList<object>)balanceCurrencies).Add(getValue(currency, "id"));
        }
        object request = new Dictionary<string, object>() {
            { "balanceCurrencies", balanceCurrencies },
        };
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["fromTime"] = since;
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        request = this.extend(request, parameters);
        object response = await this.v1_01PrivateGetBalancesBITBAYHistory(new Dictionary<string, object>() {
            { "query", this.json(request) },
        });
        object items = getValue(response, "items");
        return this.parseLedger(items, null, since, limit);
    }

    public override object parseLedgerEntry(object item, object currency = null)
    {
        //
        //    FUNDS_MIGRATION
        //    {
        //      "historyId": "84ea7a29-7da5-4de5-b0c0-871e83cad765",
        //      "balance": {
        //        "id": "821ec166-cb88-4521-916c-f4eb44db98df",
        //        "currency": "LTC",
        //        "type": "CRYPTO",
        //        "userId": "a34d361d-7bad-49c1-888e-62473b75d877",
        //        "name": "LTC"
        //      },
        //      "detailId": null,
        //      "time": 1506128252968,
        //      "type": "FUNDS_MIGRATION",
        //      "value": 0.0009957,
        //      "fundsBefore": { "total": 0, "available": 0, "locked": 0 },
        //      "fundsAfter": { "total": 0.0009957, "available": 0.0009957, "locked": 0 },
        //      "change": { "total": 0.0009957, "available": 0.0009957, "locked": 0 }
        //    }
        //
        //    CREATE_BALANCE
        //    {
        //      "historyId": "d0fabd8d-9107-4b5e-b9a6-3cab8af70d49",
        //      "balance": {
        //        "id": "653ffcf2-3037-4ebe-8e13-d5ea1a01d60d",
        //        "currency": "BTG",
        //        "type": "CRYPTO",
        //        "userId": "a34d361d-7bad-49c1-888e-62473b75d877",
        //        "name": "BTG"
        //      },
        //      "detailId": null,
        //      "time": 1508895244751,
        //      "type": "CREATE_BALANCE",
        //      "value": 0,
        //      "fundsBefore": { "total": null, "available": null, "locked": null },
        //      "fundsAfter": { "total": 0, "available": 0, "locked": 0 },
        //      "change": { "total": 0, "available": 0, "locked": 0 }
        //    }
        //
        //    BITCOIN_GOLD_FORK
        //    {
        //      "historyId": "2b4d52d3-611c-473d-b92c-8a8d87a24e41",
        //      "balance": {
        //        "id": "653ffcf2-3037-4ebe-8e13-d5ea1a01d60d",
        //        "currency": "BTG",
        //        "type": "CRYPTO",
        //        "userId": "a34d361d-7bad-49c1-888e-62473b75d877",
        //        "name": "BTG"
        //      },
        //      "detailId": null,
        //      "time": 1508895244778,
        //      "type": "BITCOIN_GOLD_FORK",
        //      "value": 0.00453512,
        //      "fundsBefore": { "total": 0, "available": 0, "locked": 0 },
        //      "fundsAfter": { "total": 0.00453512, "available": 0.00453512, "locked": 0 },
        //      "change": { "total": 0.00453512, "available": 0.00453512, "locked": 0 }
        //    }
        //
        //    ADD_FUNDS
        //    {
        //      "historyId": "3158236d-dae5-4a5d-81af-c1fa4af340fb",
        //      "balance": {
        //        "id": "3a7e7a1e-0324-49d5-8f59-298505ebd6c7",
        //        "currency": "BTC",
        //        "type": "CRYPTO",
        //        "userId": "a34d361d-7bad-49c1-888e-62473b75d877",
        //        "name": "BTC"
        //      },
        //      "detailId": "8e83a960-e737-4380-b8bb-259d6e236faa",
        //      "time": 1520631178816,
        //      "type": "ADD_FUNDS",
        //      "value": 0.628405,
        //      "fundsBefore": { "total": 0.00453512, "available": 0.00453512, "locked": 0 },
        //      "fundsAfter": { "total": 0.63294012, "available": 0.63294012, "locked": 0 },
        //      "change": { "total": 0.628405, "available": 0.628405, "locked": 0 }
        //    }
        //
        //    TRANSACTION_PRE_LOCKING
        //    {
        //      "historyId": "e7d19e0f-03b3-46a8-bc72-dde72cc24ead",
        //      "balance": {
        //        "id": "3a7e7a1e-0324-49d5-8f59-298505ebd6c7",
        //        "currency": "BTC",
        //        "type": "CRYPTO",
        //        "userId": "a34d361d-7bad-49c1-888e-62473b75d877",
        //        "name": "BTC"
        //      },
        //      "detailId": null,
        //      "time": 1520706403868,
        //      "type": "TRANSACTION_PRE_LOCKING",
        //      "value": -0.1,
        //      "fundsBefore": { "total": 0.63294012, "available": 0.63294012, "locked": 0 },
        //      "fundsAfter": { "total": 0.63294012, "available": 0.53294012, "locked": 0.1 },
        //      "change": { "total": 0, "available": -0.1, "locked": 0.1 }
        //    }
        //
        //    TRANSACTION_POST_OUTCOME
        //    {
        //      "historyId": "c4010825-231d-4a9c-8e46-37cde1f7b63c",
        //      "balance": {
        //        "id": "3a7e7a1e-0324-49d5-8f59-298505ebd6c7",
        //        "currency": "BTC",
        //        "type": "CRYPTO",
        //        "userId": "a34d361d-7bad-49c1-888e-62473b75d877",
        //        "name": "BTC"
        //      },
        //      "detailId": "bf2876bc-b545-4503-96c8-ef4de8233876",
        //      "time": 1520706404032,
        //      "type": "TRANSACTION_POST_OUTCOME",
        //      "value": -0.01771415,
        //      "fundsBefore": { "total": 0.63294012, "available": 0.53294012, "locked": 0.1 },
        //      "fundsAfter": { "total": 0.61522597, "available": 0.53294012, "locked": 0.08228585 },
        //      "change": { "total": -0.01771415, "available": 0, "locked": -0.01771415 }
        //    }
        //
        //    TRANSACTION_POST_INCOME
        //    {
        //      "historyId": "7f18b7af-b676-4125-84fd-042e683046f6",
        //      "balance": {
        //        "id": "ab43023b-4079-414c-b340-056e3430a3af",
        //        "currency": "EUR",
        //        "type": "FIAT",
        //        "userId": "a34d361d-7bad-49c1-888e-62473b75d877",
        //        "name": "EUR"
        //      },
        //      "detailId": "f5fcb274-0cc7-4385-b2d3-bae2756e701f",
        //      "time": 1520706404035,
        //      "type": "TRANSACTION_POST_INCOME",
        //      "value": 628.78,
        //      "fundsBefore": { "total": 0, "available": 0, "locked": 0 },
        //      "fundsAfter": { "total": 628.78, "available": 628.78, "locked": 0 },
        //      "change": { "total": 628.78, "available": 628.78, "locked": 0 }
        //    }
        //
        //    TRANSACTION_COMMISSION_OUTCOME
        //    {
        //      "historyId": "843177fa-61bc-4cbf-8be5-b029d856c93b",
        //      "balance": {
        //        "id": "ab43023b-4079-414c-b340-056e3430a3af",
        //        "currency": "EUR",
        //        "type": "FIAT",
        //        "userId": "a34d361d-7bad-49c1-888e-62473b75d877",
        //        "name": "EUR"
        //      },
        //      "detailId": "f5fcb274-0cc7-4385-b2d3-bae2756e701f",
        //      "time": 1520706404050,
        //      "type": "TRANSACTION_COMMISSION_OUTCOME",
        //      "value": -2.71,
        //      "fundsBefore": { "total": 766.06, "available": 766.06, "locked": 0 },
        //      "fundsAfter": { "total": 763.35,"available": 763.35, "locked": 0 },
        //      "change": { "total": -2.71, "available": -2.71, "locked": 0 }
        //    }
        //
        //    TRANSACTION_OFFER_COMPLETED_RETURN
        //    {
        //      "historyId": "cac69b04-c518-4dc5-9d86-e76e91f2e1d2",
        //      "balance": {
        //        "id": "3a7e7a1e-0324-49d5-8f59-298505ebd6c7",
        //        "currency": "BTC",
        //        "type": "CRYPTO",
        //        "userId": "a34d361d-7bad-49c1-888e-62473b75d877",
        //        "name": "BTC"
        //      },
        //      "detailId": null,
        //      "time": 1520714886425,
        //      "type": "TRANSACTION_OFFER_COMPLETED_RETURN",
        //      "value": 0.00000196,
        //      "fundsBefore": { "total": 0.00941208, "available": 0.00941012, "locked": 0.00000196 },
        //      "fundsAfter": { "total": 0.00941208, "available": 0.00941208, "locked": 0 },
        //      "change": { "total": 0, "available": 0.00000196, "locked": -0.00000196 }
        //    }
        //
        //    WITHDRAWAL_LOCK_FUNDS
        //    {
        //      "historyId": "03de2271-66ab-4960-a786-87ab9551fc14",
        //      "balance": {
        //        "id": "3a7e7a1e-0324-49d5-8f59-298505ebd6c7",
        //        "currency": "BTC",
        //        "type": "CRYPTO",
        //        "userId": "a34d361d-7bad-49c1-888e-62473b75d877",
        //        "name": "BTC"
        //      },
        //      "detailId": "6ad3dc72-1d6d-4ec2-8436-ca43f85a38a6",
        //      "time": 1522245654481,
        //      "type": "WITHDRAWAL_LOCK_FUNDS",
        //      "value": -0.8,
        //      "fundsBefore": { "total": 0.8, "available": 0.8, "locked": 0 },
        //      "fundsAfter": { "total": 0.8, "available": 0, "locked": 0.8 },
        //      "change": { "total": 0, "available": -0.8, "locked": 0.8 }
        //    }
        //
        //    WITHDRAWAL_SUBTRACT_FUNDS
        //    {
        //      "historyId": "b0308c89-5288-438d-a306-c6448b1a266d",
        //      "balance": {
        //        "id": "3a7e7a1e-0324-49d5-8f59-298505ebd6c7",
        //        "currency": "BTC",
        //        "type": "CRYPTO",
        //        "userId": "a34d361d-7bad-49c1-888e-62473b75d877",
        //        "name": "BTC"
        //      },
        //      "detailId": "6ad3dc72-1d6d-4ec2-8436-ca43f85a38a6",
        //      "time": 1522246526186,
        //      "type": "WITHDRAWAL_SUBTRACT_FUNDS",
        //      "value": -0.8,
        //      "fundsBefore": { "total": 0.8, "available": 0, "locked": 0.8 },
        //      "fundsAfter": { "total": 0, "available": 0, "locked": 0 },
        //      "change": { "total": -0.8, "available": 0, "locked": -0.8 }
        //    }
        //
        //    TRANSACTION_OFFER_ABORTED_RETURN
        //    {
        //      "historyId": "b1a3c075-d403-4e05-8f32-40512cdd88c0",
        //      "balance": {
        //        "id": "3a7e7a1e-0324-49d5-8f59-298505ebd6c7",
        //        "currency": "BTC",
        //        "type": "CRYPTO",
        //        "userId": "a34d361d-7bad-49c1-888e-62473b75d877",
        //        "name": "BTC"
        //      },
        //      "detailId": null,
        //      "time": 1522512298662,
        //      "type": "TRANSACTION_OFFER_ABORTED_RETURN",
        //      "value": 0.0564931,
        //      "fundsBefore": { "total": 0.44951311, "available": 0.39302001, "locked": 0.0564931 },
        //      "fundsAfter": { "total": 0.44951311, "available": 0.44951311, "locked": 0 },
        //      "change": { "total": 0, "available": 0.0564931, "locked": -0.0564931 }
        //    }
        //
        //    WITHDRAWAL_UNLOCK_FUNDS
        //    {
        //      "historyId": "0ed569a2-c330-482e-bb89-4cb553fb5b11",
        //      "balance": {
        //        "id": "3a7e7a1e-0324-49d5-8f59-298505ebd6c7",
        //        "currency": "BTC",
        //        "type": "CRYPTO",
        //        "userId": "a34d361d-7bad-49c1-888e-62473b75d877",
        //        "name": "BTC"
        //      },
        //      "detailId": "0c7be256-c336-4111-bee7-4eb22e339700",
        //      "time": 1527866360785,
        //      "type": "WITHDRAWAL_UNLOCK_FUNDS",
        //      "value": 0.05045,
        //      "fundsBefore": { "total": 0.86001578, "available": 0.80956578, "locked": 0.05045 },
        //      "fundsAfter": { "total": 0.86001578, "available": 0.86001578, "locked": 0 },
        //      "change": { "total": 0, "available": 0.05045, "locked": -0.05045 }
        //    }
        //
        //    TRANSACTION_COMMISSION_RETURN
        //    {
        //      "historyId": "07c89c27-46f1-4d7a-8518-b73798bf168a",
        //      "balance": {
        //        "id": "ab43023b-4079-414c-b340-056e3430a3af",
        //        "currency": "EUR",
        //        "type": "FIAT",
        //        "userId": "a34d361d-7bad-49c1-888e-62473b75d877",
        //        "name": "EUR"
        //      },
        //      "detailId": null,
        //      "time": 1528304043063,
        //      "type": "TRANSACTION_COMMISSION_RETURN",
        //      "value": 0.6,
        //      "fundsBefore": { "total": 0, "available": 0, "locked": 0 },
        //      "fundsAfter": { "total": 0.6, "available": 0.6, "locked": 0 },
        //      "change": { "total": 0.6, "available": 0.6, "locked": 0 }
        //    }
        //
        object timestamp = this.safeInteger(item, "time");
        object balance = this.safeValue(item, "balance", new Dictionary<string, object>() {});
        object currencyId = this.safeString(balance, "currency");
        currency = this.safeCurrency(currencyId, currency);
        object change = this.safeValue(item, "change", new Dictionary<string, object>() {});
        object amount = this.safeString(change, "total");
        object direction = "in";
        if (isTrue(Precise.stringLt(amount, "0")))
        {
            direction = "out";
            amount = Precise.stringNeg(amount);
        }
        // there are 2 undocumented api calls: (v1_01PrivateGetPaymentsDepositDetailId and v1_01PrivateGetPaymentsWithdrawalDetailId)
        // that can be used to enrich the transfers with txid, address etc (you need to use info.detailId as a parameter)
        object fundsBefore = this.safeValue(item, "fundsBefore", new Dictionary<string, object>() {});
        object fundsAfter = this.safeValue(item, "fundsAfter", new Dictionary<string, object>() {});
        return this.safeLedgerEntry(new Dictionary<string, object>() {
            { "info", item },
            { "id", this.safeString(item, "historyId") },
            { "direction", direction },
            { "account", null },
            { "referenceId", this.safeString(item, "detailId") },
            { "referenceAccount", null },
            { "type", this.parseLedgerEntryType(this.safeString(item, "type")) },
            { "currency", this.safeCurrencyCode(currencyId) },
            { "amount", this.parseNumber(amount) },
            { "before", this.safeNumber(fundsBefore, "total") },
            { "after", this.safeNumber(fundsAfter, "total") },
            { "status", "ok" },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "fee", null },
        }, currency);
    }

    public virtual object parseLedgerEntryType(object type)
    {
        object types = new Dictionary<string, object>() {
            { "ADD_FUNDS", "transaction" },
            { "BITCOIN_GOLD_FORK", "transaction" },
            { "CREATE_BALANCE", "transaction" },
            { "FUNDS_MIGRATION", "transaction" },
            { "WITHDRAWAL_LOCK_FUNDS", "transaction" },
            { "WITHDRAWAL_SUBTRACT_FUNDS", "transaction" },
            { "WITHDRAWAL_UNLOCK_FUNDS", "transaction" },
            { "TRANSACTION_COMMISSION_OUTCOME", "fee" },
            { "TRANSACTION_COMMISSION_RETURN", "fee" },
            { "TRANSACTION_OFFER_ABORTED_RETURN", "trade" },
            { "TRANSACTION_OFFER_COMPLETED_RETURN", "trade" },
            { "TRANSACTION_POST_INCOME", "trade" },
            { "TRANSACTION_POST_OUTCOME", "trade" },
            { "TRANSACTION_PRE_LOCKING", "trade" },
        };
        return this.safeString(types, type, type);
    }

    public override object parseOHLCV(object ohlcv, object market = null)
    {
        //
        //     [
        //         "1582399800000",
        //         {
        //             "o": "0.0001428",
        //             "c": "0.0001428",
        //             "h": "0.0001428",
        //             "l": "0.0001428",
        //             "v": "4",
        //             "co": "1"
        //         }
        //     ]
        //
        object first = this.safeValue(ohlcv, 1, new Dictionary<string, object>() {});
        return new List<object> {this.safeInteger(ohlcv, 0), this.safeNumber(first, "o"), this.safeNumber(first, "h"), this.safeNumber(first, "l"), this.safeNumber(first, "c"), this.safeNumber(first, "v")};
    }

    public async override Task<object> fetchOHLCV(object symbol, object timeframe = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name zonda#fetchOHLCV
        * @see https://docs.zondacrypto.exchange/reference/candles-chart
        * @description fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
        * @param {string} symbol unified symbol of the market to fetch OHLCV data for
        * @param {string} timeframe the length of time each candle represents
        * @param {int} [since] timestamp in ms of the earliest candle to fetch
        * @param {int} [limit] the maximum amount of candles to fetch
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
        */
        timeframe ??= "1m";
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object tradingSymbol = add(add(getValue(market, "baseId"), "-"), getValue(market, "quoteId"));
        object request = new Dictionary<string, object>() {
            { "symbol", tradingSymbol },
            { "resolution", this.safeString(this.timeframes, timeframe, timeframe) },
        };
        if (isTrue(isEqual(limit, null)))
        {
            limit = 100;
        } else
        {
            limit = mathMin(limit, 11000); // supports up to 11k candles diapason
        }
        object duration = this.parseTimeframe(timeframe);
        object timerange = multiply(multiply(limit, duration), 1000);
        if (isTrue(isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["to"] = this.milliseconds();
            ((IDictionary<string,object>)request)["from"] = subtract(getValue(request, "to"), timerange);
        } else
        {
            ((IDictionary<string,object>)request)["from"] = since;
            ((IDictionary<string,object>)request)["to"] = this.sum(getValue(request, "from"), timerange);
        }
        object response = await this.v1_01PublicGetTradingCandleHistorySymbolResolution(this.extend(request, parameters));
        //
        //     {
        //         "status":"Ok",
        //         "items":[
        //             ["1591503060000",{"o":"0.02509572","c":"0.02509438","h":"0.02509664","l":"0.02509438","v":"0.02082165","co":"17"}],
        //             ["1591503120000",{"o":"0.02509606","c":"0.02509515","h":"0.02509606","l":"0.02509487","v":"0.04971703","co":"13"}],
        //             ["1591503180000",{"o":"0.02509532","c":"0.02509589","h":"0.02509589","l":"0.02509454","v":"0.01332236","co":"7"}],
        //         ]
        //     }
        //
        object items = this.safeList(response, "items", new List<object>() {});
        return this.parseOHLCVs(items, market, timeframe, since, limit);
    }

    public override object parseTrade(object trade, object market = null)
    {
        //
        // createOrder trades
        //
        //     {
        //         "rate": "0.02195928",
        //         "amount": "0.00167952"
        //     }
        //
        // fetchMyTrades (private)
        //
        //     {
        //         "amount": "0.29285199",
        //         "commissionValue": "0.00125927",
        //         "id": "11c8203a-a267-11e9-b698-0242ac110007",
        //         "initializedBy": "Buy",
        //         "market": "ETH-EUR",
        //         "offerId": "11c82038-a267-11e9-b698-0242ac110007",
        //         "rate": "277",
        //         "time": "1562689917517",
        //         "userAction": "Buy",
        //         "wasTaker": true,
        //     }
        //
        // fetchTrades (public)
        //
        //     {
        //          "id": "df00b0da-e5e0-11e9-8c19-0242ac11000a",
        //          "t": "1570108958831",
        //          "a": "0.04776653",
        //          "r": "0.02145854",
        //          "ty": "Sell"
        //     }
        //
        object timestamp = this.safeInteger2(trade, "time", "t");
        object side = this.safeStringLower2(trade, "userAction", "ty");
        object wasTaker = this.safeValue(trade, "wasTaker");
        object takerOrMaker = null;
        if (isTrue(!isEqual(wasTaker, null)))
        {
            takerOrMaker = ((bool) isTrue(wasTaker)) ? "taker" : "maker";
        }
        object priceString = this.safeString2(trade, "rate", "r");
        object amountString = this.safeString2(trade, "amount", "a");
        object feeCostString = this.safeString(trade, "commissionValue");
        object marketId = this.safeString(trade, "market");
        market = this.safeMarket(marketId, market, "-");
        object symbol = getValue(market, "symbol");
        object fee = null;
        if (isTrue(!isEqual(feeCostString, null)))
        {
            object feeCurrency = ((bool) isTrue((isEqual(side, "buy")))) ? getValue(market, "base") : getValue(market, "quote");
            fee = new Dictionary<string, object>() {
                { "currency", feeCurrency },
                { "cost", feeCostString },
            };
        }
        object order = this.safeString(trade, "offerId");
        // todo: check this logic
        object type = null;
        if (isTrue(!isEqual(order, null)))
        {
            type = ((bool) isTrue(order)) ? "limit" : "market";
        }
        return this.safeTrade(new Dictionary<string, object>() {
            { "id", this.safeString(trade, "id") },
            { "order", order },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "symbol", symbol },
            { "type", type },
            { "side", side },
            { "price", priceString },
            { "amount", amountString },
            { "cost", null },
            { "takerOrMaker", takerOrMaker },
            { "fee", fee },
            { "info", trade },
        }, market);
    }

    public async override Task<object> fetchTrades(object symbol, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name zonda#fetchTrades
        * @see https://docs.zondacrypto.exchange/reference/last-transactions
        * @description get the list of most recent trades for a particular symbol
        * @param {string} symbol unified symbol of the market to fetch trades for
        * @param {int} [since] timestamp in ms of the earliest trade to fetch
        * @param {int} [limit] the maximum amount of trades to fetch
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object tradingSymbol = add(add(getValue(market, "baseId"), "-"), getValue(market, "quoteId"));
        object request = new Dictionary<string, object>() {
            { "symbol", tradingSymbol },
        };
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["fromTime"] = subtract(since, 1); // result does not include exactly `since` time therefore decrease by 1
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit; // default - 10, max - 300
        }
        object response = await this.v1_01PublicGetTradingTransactionsSymbol(this.extend(request, parameters));
        object items = this.safeList(response, "items");
        return this.parseTrades(items, market, since, limit);
    }

    public async override Task<object> createOrder(object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        /**
        * @method
        * @name zonda#createOrder
        * @description create a trade order
        * @param {string} symbol unified symbol of the market to create an order in
        * @param {string} type 'market' or 'limit'
        * @param {string} side 'buy' or 'sell'
        * @param {float} amount how much of currency you want to trade in units of base currency
        * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object tradingSymbol = add(add(getValue(market, "baseId"), "-"), getValue(market, "quoteId"));
        amount = parseFloat(this.amountToPrecision(symbol, amount));
        object request = new Dictionary<string, object>() {
            { "symbol", tradingSymbol },
            { "offerType", ((string)side).ToUpper() },
            { "amount", amount },
        };
        object stopLossPrice = this.safeValue2(parameters, "stopPrice", "stopLossPrice");
        object isStopLossPrice = !isEqual(stopLossPrice, null);
        object isLimitOrder = isEqual(type, "limit");
        object isMarketOrder = isEqual(type, "market");
        object isStopLimit = isTrue((isEqual(type, "stop-limit"))) || isTrue((isTrue(isLimitOrder) && isTrue(isStopLossPrice)));
        object isStopMarket = isTrue(isEqual(type, "stop-market")) || isTrue((isTrue(isMarketOrder) && isTrue(isStopLossPrice)));
        object isStopOrder = isTrue(isStopLimit) || isTrue(isStopMarket);
        if (isTrue(isTrue(isLimitOrder) || isTrue(isStopLimit)))
        {
            ((IDictionary<string,object>)request)["rate"] = this.priceToPrecision(symbol, price);
            ((IDictionary<string,object>)request)["mode"] = ((bool) isTrue(isStopLimit)) ? "stop-limit" : "limit";
        } else if (isTrue(isTrue(isMarketOrder) || isTrue(isStopMarket)))
        {
            ((IDictionary<string,object>)request)["mode"] = ((bool) isTrue(isStopMarket)) ? "stop-market" : "market";
        } else
        {
            throw new ExchangeError ((string)add(this.id, " createOrder() invalid type")) ;
        }
        parameters = this.omit(parameters, new List<object>() {"stopPrice", "stopLossPrice"});
        object response = null;
        if (isTrue(isStopOrder))
        {
            if (!isTrue(isStopLossPrice))
            {
                throw new ExchangeError ((string)add(this.id, " createOrder() zonda requires `triggerPrice` or `stopPrice` parameter for stop-limit or stop-market orders")) ;
            }
            ((IDictionary<string,object>)request)["stopRate"] = this.priceToPrecision(symbol, stopLossPrice);
            response = await this.v1_01PrivatePostTradingStopOfferSymbol(this.extend(request, parameters));
        } else
        {
            response = await this.v1_01PrivatePostTradingOfferSymbol(this.extend(request, parameters));
        }
        //
        // unfilled (open order)
        //
        //     {
        //         "status": "Ok",
        //         "completed": false, // can deduce status from here
        //         "offerId": "ce9cc72e-d61c-11e9-9248-0242ac110005",
        //         "transactions": [], // can deduce order info from here
        //     }
        //
        // filled (closed order)
        //
        //     {
        //         "status": "Ok",
        //         "offerId": "942a4a3e-e922-11e9-8c19-0242ac11000a",
        //         "completed": true,
        //         "transactions": [
        //           {
        //             "rate": "0.02195928",
        //             "amount": "0.00167952"
        //           },
        //           {
        //             "rate": "0.02195928",
        //             "amount": "0.00167952"
        //           },
        //           {
        //             "rate": "0.02196207",
        //             "amount": "0.27704177"
        //           }
        //         ]
        //     }
        //
        // partially-filled (open order)
        //
        //     {
        //         "status": "Ok",
        //         "offerId": "d0ebefab-f4d7-11e9-8c19-0242ac11000a",
        //         "completed": false,
        //         "transactions": [
        //           {
        //             "rate": "0.02106404",
        //             "amount": "0.0019625"
        //           },
        //           {
        //             "rate": "0.02106404",
        //             "amount": "0.0019625"
        //           },
        //           {
        //             "rate": "0.02105901",
        //             "amount": "0.00975256"
        //           }
        //         ]
        //     }
        //
        object id = this.safeString2(response, "offerId", "stopOfferId");
        object completed = this.safeBool(response, "completed", false);
        object status = ((bool) isTrue(completed)) ? "closed" : "open";
        object transactions = this.safeValue(response, "transactions");
        return this.safeOrder(new Dictionary<string, object>() {
            { "id", id },
            { "info", response },
            { "timestamp", null },
            { "datetime", null },
            { "lastTradeTimestamp", null },
            { "status", status },
            { "symbol", symbol },
            { "type", type },
            { "side", side },
            { "price", price },
            { "amount", amount },
            { "cost", null },
            { "filled", null },
            { "remaining", null },
            { "average", null },
            { "fee", null },
            { "trades", transactions },
            { "clientOrderId", null },
        });
    }

    public async override Task<object> cancelOrder(object id, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name zonda#cancelOrder
        * @see https://docs.zondacrypto.exchange/reference/cancel-order
        * @description cancels an open order
        * @param {string} id order id
        * @param {string} symbol unified symbol of the market the order was made in
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        object side = this.safeString(parameters, "side");
        if (isTrue(isEqual(side, null)))
        {
            throw new ExchangeError ((string)add(this.id, " cancelOrder() requires a `side` parameter (\"buy\" or \"sell\")")) ;
        }
        object price = this.safeValue(parameters, "price");
        if (isTrue(isEqual(price, null)))
        {
            throw new ExchangeError ((string)add(this.id, " cancelOrder() requires a `price` parameter (float or string)")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object tradingSymbol = add(add(getValue(market, "baseId"), "-"), getValue(market, "quoteId"));
        object request = new Dictionary<string, object>() {
            { "symbol", tradingSymbol },
            { "id", id },
            { "side", side },
            { "price", price },
        };
        object response = await this.v1_01PrivateDeleteTradingOfferSymbolIdSidePrice(this.extend(request, parameters));
        // { status: "Fail", errors: [ "NOT_RECOGNIZED_OFFER_TYPE" ] }  -- if required params are missing
        // { status: "Ok", errors: [] }
        return this.parseOrder(response);
    }

    public virtual object isFiat(object currency)
    {
        object fiatCurrencies = new Dictionary<string, object>() {
            { "USD", true },
            { "EUR", true },
            { "PLN", true },
        };
        return this.safeBool(fiatCurrencies, currency, false);
    }

    public override object parseDepositAddress(object depositAddress, object currency = null)
    {
        //
        //     {
        //         "address": "33u5YAEhQbYfjHHPsfMfCoSdEjfwYjVcBE",
        //         "currency": "BTC",
        //         "balanceId": "5d5d19e7-2265-49c7-af9a-047bcf384f21",
        //         "balanceEngine": "BITBAY",
        //         "tag": null
        //     }
        //
        object currencyId = this.safeString(depositAddress, "currency");
        object address = this.safeString(depositAddress, "address");
        this.checkAddress(address);
        return new Dictionary<string, object>() {
            { "currency", this.safeCurrencyCode(currencyId, currency) },
            { "address", address },
            { "tag", this.safeString(depositAddress, "tag") },
            { "network", null },
            { "info", depositAddress },
        };
    }

    public async override Task<object> fetchDepositAddress(object code, object parameters = null)
    {
        /**
        * @method
        * @name zonda#fetchDepositAddress
        * @see https://docs.zondacrypto.exchange/reference/deposit-addresses-for-crypto
        * @description fetch the deposit address for a currency associated with this account
        * @param {string} code unified currency code
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {string} [params.walletId] Wallet id to filter deposit adresses.
        * @returns {object} an [address structure]{@link https://docs.ccxt.com/#/?id=address-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "currency", getValue(currency, "id") },
        };
        object response = await this.v1_01PrivateGetApiPaymentsDepositsCryptoAddresses(this.extend(request, parameters));
        //
        //     {
        //         "status": "Ok",
        //         "data": [{
        //                 "address": "33u5YAEhQbYfjHHPsfMfCoSdEjfwYjVcBE",
        //                 "currency": "BTC",
        //                 "balanceId": "5d5d19e7-2265-49c7-af9a-047bcf384f21",
        //                 "balanceEngine": "BITBAY",
        //                 "tag": null
        //             }
        //         ]
        //     }
        //
        object data = this.safeValue(response, "data");
        object first = this.safeDict(data, 0);
        return this.parseDepositAddress(first, currency);
    }

    public async override Task<object> fetchDepositAddresses(object codes = null, object parameters = null)
    {
        /**
        * @method
        * @name zonda#fetchDepositAddresses
        * @see https://docs.zondacrypto.exchange/reference/deposit-addresses-for-crypto
        * @description fetch deposit addresses for multiple currencies and chain types
        * @param {string[]|undefined} codes zonda does not support filtering filtering by multiple codes and will ignore this parameter.
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a list of [address structures]{@link https://docs.ccxt.com/#/?id=address-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.v1_01PrivateGetApiPaymentsDepositsCryptoAddresses(parameters);
        //
        //     {
        //         "status": "Ok",
        //         "data": [{
        //                 "address": "33u5YAEhQbYfjHHPsfMfCoSdEjfwYjVcBE",
        //                 "currency": "BTC",
        //                 "balanceId": "5d5d19e7-2265-49c7-af9a-047bcf384f21",
        //                 "balanceEngine": "BITBAY",
        //                 "tag": null
        //             }
        //         ]
        //     }
        //
        object data = this.safeList(response, "data");
        return this.parseDepositAddresses(data, codes);
    }

    public async override Task<object> transfer(object code, object amount, object fromAccount, object toAccount, object parameters = null)
    {
        /**
        * @method
        * @name zonda#transfer
        * @see https://docs.zondacrypto.exchange/reference/internal-transfer
        * @description transfer currency internally between wallets on the same account
        * @param {string} code unified currency code
        * @param {float} amount amount to transfer
        * @param {string} fromAccount account to transfer from
        * @param {string} toAccount account to transfer to
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [transfer structure]{@link https://docs.ccxt.com/#/?id=transfer-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "source", fromAccount },
            { "destination", toAccount },
            { "currency", code },
            { "funds", this.currencyToPrecision(code, amount) },
        };
        object response = await this.v1_01PrivatePostBalancesBITBAYBalanceTransferSourceDestination(this.extend(request, parameters));
        //
        //     {
        //         "status": "Ok",
        //         "from": {
        //             "id": "ad9397c5-3bd9-4372-82ba-22da6a90cb56",
        //             "userId": "4bc43956-423f-47fd-9faa-acd37c58ed9f",
        //             "availableFunds": 0.01803472,
        //             "totalFunds": 0.01804161,
        //             "lockedFunds": 0.00000689,
        //             "currency": "BTC",
        //             "type": "CRYPTO",
        //             "name": "BTC",
        //             "balanceEngine": "BITBAY"
        //         },
        //         "to": {
        //             "id": "01931d52-536b-4ca5-a9f4-be28c86d0cc3",
        //             "userId": "4bc43956-423f-47fd-9faa-acd37c58ed9f",
        //             "availableFunds": 0.0001,
        //             "totalFunds": 0.0001,
        //             "lockedFunds": 0,
        //             "currency": "BTC",
        //             "type": "CRYPTO",
        //             "name": "Prowizja",
        //             "balanceEngine": "BITBAY"
        //         },
        //         "errors": null
        //     }
        //
        object transfer = this.parseTransfer(response, currency);
        object transferOptions = this.safeValue(this.options, "transfer", new Dictionary<string, object>() {});
        object fillResponseFromRequest = this.safeBool(transferOptions, "fillResponseFromRequest", true);
        if (isTrue(fillResponseFromRequest))
        {
            ((IDictionary<string,object>)transfer)["amount"] = amount;
        }
        return transfer;
    }

    public override object parseTransfer(object transfer, object currency = null)
    {
        //
        //     {
        //         "status": "Ok",
        //         "from": {
        //             "id": "ad9397c5-3bd9-4372-82ba-22da6a90cb56",
        //             "userId": "4bc43956-423f-47fd-9faa-acd37c58ed9f",
        //             "availableFunds": 0.01803472,
        //             "totalFunds": 0.01804161,
        //             "lockedFunds": 0.00000689,
        //             "currency": "BTC",
        //             "type": "CRYPTO",
        //             "name": "BTC",
        //             "balanceEngine": "BITBAY"
        //         },
        //         "to": {
        //             "id": "01931d52-536b-4ca5-a9f4-be28c86d0cc3",
        //             "userId": "4bc43956-423f-47fd-9faa-acd37c58ed9f",
        //             "availableFunds": 0.0001,
        //             "totalFunds": 0.0001,
        //             "lockedFunds": 0,
        //             "currency": "BTC",
        //             "type": "CRYPTO",
        //             "name": "Prowizja",
        //             "balanceEngine": "BITBAY"
        //         },
        //         "errors": null
        //     }
        //
        object status = this.safeString(transfer, "status");
        object fromAccount = this.safeValue(transfer, "from", new Dictionary<string, object>() {});
        object fromId = this.safeString(fromAccount, "id");
        object to = this.safeValue(transfer, "to", new Dictionary<string, object>() {});
        object toId = this.safeString(to, "id");
        object currencyId = this.safeString(fromAccount, "currency");
        return new Dictionary<string, object>() {
            { "info", transfer },
            { "id", null },
            { "timestamp", null },
            { "datetime", null },
            { "currency", this.safeCurrencyCode(currencyId, currency) },
            { "amount", null },
            { "fromAccount", fromId },
            { "toAccount", toId },
            { "status", this.parseTransferStatus(status) },
        };
    }

    public virtual object parseTransferStatus(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "Ok", "ok" },
            { "Fail", "failed" },
        };
        return this.safeString(statuses, status, status);
    }

    public async override Task<object> withdraw(object code, object amount, object address, object tag = null, object parameters = null)
    {
        /**
        * @method
        * @name zonda#withdraw
        * @see https://docs.zondacrypto.exchange/reference/crypto-withdrawal-1
        * @description make a withdrawal
        * @param {string} code unified currency code
        * @param {float} amount the amount to withdraw
        * @param {string} address the address to withdraw to
        * @param {string} tag
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
        */
        parameters ??= new Dictionary<string, object>();
        var tagparametersVariable = this.handleWithdrawTagAndParams(tag, parameters);
        tag = ((IList<object>)tagparametersVariable)[0];
        parameters = ((IList<object>)tagparametersVariable)[1];
        this.checkAddress(address);
        await this.loadMarkets();
        object response = null;
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "currency", getValue(currency, "id") },
            { "amount", amount },
            { "address", address },
        };
        if (isTrue(this.isFiat(code)))
        {
            // request['swift'] = params['swift']; // Bank identifier, if required.
            response = await this.v1_01PrivatePostApiPaymentsWithdrawalsFiat(this.extend(request, parameters));
        } else
        {
            if (isTrue(!isEqual(tag, null)))
            {
                ((IDictionary<string,object>)request)["tag"] = tag;
            }
            response = await this.v1_01PrivatePostApiPaymentsWithdrawalsCrypto(this.extend(request, parameters));
        }
        //
        //     {
        //         "status": "Ok",
        //         "data": {
        //           "id": "65e01087-afb0-4ab2-afdb-cc925e360296"
        //         }
        //     }
        //
        object data = this.safeDict(response, "data");
        return this.parseTransaction(data, currency);
    }

    public override object parseTransaction(object transaction, object currency = null)
    {
        //
        // withdraw
        //
        //     {
        //         "id": "65e01087-afb0-4ab2-afdb-cc925e360296"
        //     }
        //
        currency = this.safeCurrency(null, currency);
        return new Dictionary<string, object>() {
            { "id", this.safeString(transaction, "id") },
            { "txid", null },
            { "timestamp", null },
            { "datetime", null },
            { "network", null },
            { "addressFrom", null },
            { "address", null },
            { "addressTo", null },
            { "amount", null },
            { "type", null },
            { "currency", getValue(currency, "code") },
            { "status", null },
            { "updated", null },
            { "tagFrom", null },
            { "tag", null },
            { "tagTo", null },
            { "comment", null },
            { "internal", null },
            { "fee", null },
            { "info", transaction },
        };
    }

    public override object sign(object path, object api = null, object method = null, object parameters = null, object headers = null, object body = null)
    {
        api ??= "public";
        method ??= "GET";
        parameters ??= new Dictionary<string, object>();
        object url = this.implodeHostname(getValue(getValue(this.urls, "api"), api));
        if (isTrue(isEqual(api, "public")))
        {
            object query = this.omit(parameters, this.extractParams(path));
            url = add(url, add(add("/", this.implodeParams(path, parameters)), ".json"));
            if (isTrue(getArrayLength(new List<object>(((IDictionary<string,object>)query).Keys))))
            {
                url = add(url, add("?", this.urlencode(query)));
            }
        } else if (isTrue(isEqual(api, "v1_01Public")))
        {
            object query = this.omit(parameters, this.extractParams(path));
            url = add(url, add("/", this.implodeParams(path, parameters)));
            if (isTrue(getArrayLength(new List<object>(((IDictionary<string,object>)query).Keys))))
            {
                url = add(url, add("?", this.urlencode(query)));
            }
        } else if (isTrue(isEqual(api, "v1_01Private")))
        {
            this.checkRequiredCredentials();
            object query = this.omit(parameters, this.extractParams(path));
            url = add(url, add("/", this.implodeParams(path, parameters)));
            object nonce = ((object)this.milliseconds()).ToString();
            object payload = null;
            if (isTrue(!isEqual(method, "POST")))
            {
                if (isTrue(getArrayLength(new List<object>(((IDictionary<string,object>)query).Keys))))
                {
                    url = add(url, add("?", this.urlencode(query)));
                }
                payload = add(this.apiKey, nonce);
            } else if (isTrue(isEqual(body, null)))
            {
                body = this.json(query);
                payload = add(add(this.apiKey, nonce), body);
            }
            headers = new Dictionary<string, object>() {
                { "Request-Timestamp", nonce },
                { "Operation-Id", this.uuid() },
                { "API-Key", this.apiKey },
                { "API-Hash", this.hmac(this.encode(payload), this.encode(this.secret), sha512) },
                { "Content-Type", "application/json" },
            };
        } else
        {
            this.checkRequiredCredentials();
            body = this.urlencode(this.extend(new Dictionary<string, object>() {
                { "method", path },
                { "moment", this.nonce() },
            }, parameters));
            headers = new Dictionary<string, object>() {
                { "Content-Type", "application/x-www-form-urlencoded" },
                { "API-Key", this.apiKey },
                { "API-Hash", this.hmac(this.encode(body), this.encode(this.secret), sha512) },
            };
        }
        return new Dictionary<string, object>() {
            { "url", url },
            { "method", method },
            { "body", body },
            { "headers", headers },
        };
    }

    public override object handleErrors(object httpCode, object reason, object url, object method, object headers, object body, object response, object requestHeaders, object requestBody)
    {
        if (isTrue(isEqual(response, null)))
        {
            return null;  // fallback to default error handler
        }
        if (isTrue(inOp(response, "code")))
        {
            //
            // bitbay returns the integer "success": 1 key from their private API
            // or an integer "code" value from 0 to 510 and an error message
            //
            //      { "success": 1, ... }
            //      { 'code': 502, "message": "Invalid sign" }
            //      { 'code': 0, "message": "offer funds not exceeding minimums" }
            //
            //      400 At least one parameter wasn't set
            //      401 Invalid order type
            //      402 No orders with specified currencies
            //      403 Invalid payment currency name
            //      404 Error. Wrong transaction type
            //      405 Order with this id doesn't exist
            //      406 No enough money or crypto
            //      408 Invalid currency name
            //      501 Invalid public key
            //      502 Invalid sign
            //      503 Invalid moment parameter. Request time doesn't match current server time
            //      504 Invalid method
            //      505 Key has no permission for this action
            //      506 Account locked. Please contact with customer service
            //      509 The BIC/SWIFT is required for this currency
            //      510 Invalid market name
            //
            object code = this.safeString(response, "code"); // always an integer
            object feedback = add(add(this.id, " "), body);
            this.throwExactlyMatchedException(this.exceptions, code, feedback);
            throw new ExchangeError ((string)feedback) ;
        } else if (isTrue(inOp(response, "status")))
        {
            //
            //      {"status":"Fail","errors":["OFFER_FUNDS_NOT_EXCEEDING_MINIMUMS"]}
            //
            object status = this.safeString(response, "status");
            if (isTrue(isEqual(status, "Fail")))
            {
                object errors = this.safeValue(response, "errors");
                object feedback = add(add(this.id, " "), body);
                for (object i = 0; isLessThan(i, getArrayLength(errors)); postFixIncrement(ref i))
                {
                    object error = getValue(errors, i);
                    this.throwExactlyMatchedException(this.exceptions, error, feedback);
                }
                throw new ExchangeError ((string)feedback) ;
            }
        }
        return null;
    }
}
