namespace ccxt;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

public partial class blofin : Exchange
{
    public override object describe()
    {
        return this.deepExtend(base.describe(), new Dictionary<string, object>() {
            { "id", "blofin" },
            { "name", "BloFin" },
            { "countries", new List<object>() {"US"} },
            { "version", "v1" },
            { "rateLimit", 100 },
            { "pro", true },
            { "has", new Dictionary<string, object>() {
                { "CORS", null },
                { "spot", false },
                { "margin", false },
                { "swap", true },
                { "future", false },
                { "option", false },
                { "addMargin", false },
                { "borrowMargin", false },
                { "cancelAllOrders", false },
                { "cancelOrder", true },
                { "cancelOrders", true },
                { "closeAllPositions", false },
                { "closePosition", true },
                { "createDepositAddress", false },
                { "createMarketBuyOrderWithCost", false },
                { "createMarketSellOrderWithCost", false },
                { "createOrder", true },
                { "createOrders", true },
                { "createOrderWithTakeProfitAndStopLoss", true },
                { "createPostOnlyOrder", false },
                { "createReduceOnlyOrder", false },
                { "createStopLimitOrder", false },
                { "createStopLossOrder", true },
                { "createStopMarketOrder", false },
                { "createStopOrder", false },
                { "createTakeProfitOrder", true },
                { "editOrder", false },
                { "fetchAccounts", false },
                { "fetchBalance", true },
                { "fetchBidsAsks", null },
                { "fetchBorrowInterest", false },
                { "fetchBorrowRateHistories", false },
                { "fetchBorrowRateHistory", false },
                { "fetchCanceledOrders", false },
                { "fetchClosedOrder", false },
                { "fetchClosedOrders", false },
                { "fetchCrossBorrowRate", false },
                { "fetchCrossBorrowRates", false },
                { "fetchCurrencies", false },
                { "fetchDeposit", false },
                { "fetchDepositAddress", false },
                { "fetchDepositAddresses", false },
                { "fetchDepositAddressesByNetwork", false },
                { "fetchDeposits", true },
                { "fetchDepositsWithdrawals", false },
                { "fetchDepositWithdrawFee", "emulated" },
                { "fetchDepositWithdrawFees", false },
                { "fetchFundingHistory", true },
                { "fetchFundingRate", true },
                { "fetchFundingRateHistory", true },
                { "fetchFundingRates", false },
                { "fetchGreeks", false },
                { "fetchIndexOHLCV", false },
                { "fetchIsolatedBorrowRate", false },
                { "fetchIsolatedBorrowRates", false },
                { "fetchL3OrderBook", false },
                { "fetchLedger", true },
                { "fetchLedgerEntry", null },
                { "fetchLeverage", true },
                { "fetchLeverages", true },
                { "fetchLeverageTiers", false },
                { "fetchMarginMode", true },
                { "fetchMarginModes", false },
                { "fetchMarketLeverageTiers", false },
                { "fetchMarkets", true },
                { "fetchMarkOHLCV", false },
                { "fetchMySettlementHistory", false },
                { "fetchMyTrades", true },
                { "fetchOHLCV", true },
                { "fetchOpenInterest", false },
                { "fetchOpenInterestHistory", false },
                { "fetchOpenOrder", null },
                { "fetchOpenOrders", true },
                { "fetchOrder", null },
                { "fetchOrderBook", true },
                { "fetchOrderBooks", false },
                { "fetchOrders", false },
                { "fetchOrderTrades", true },
                { "fetchPosition", true },
                { "fetchPositions", true },
                { "fetchPositionsForSymbol", false },
                { "fetchPositionsRisk", false },
                { "fetchPremiumIndexOHLCV", false },
                { "fetchSettlementHistory", false },
                { "fetchStatus", false },
                { "fetchTicker", true },
                { "fetchTickers", true },
                { "fetchTime", false },
                { "fetchTrades", true },
                { "fetchTradingFee", false },
                { "fetchTradingFees", false },
                { "fetchTradingLimits", false },
                { "fetchTransactionFee", false },
                { "fetchTransactionFees", false },
                { "fetchTransactions", false },
                { "fetchTransfer", false },
                { "fetchTransfers", false },
                { "fetchUnderlyingAssets", false },
                { "fetchVolatilityHistory", false },
                { "fetchWithdrawal", false },
                { "fetchWithdrawals", true },
                { "fetchWithdrawalWhitelist", false },
                { "reduceMargin", false },
                { "repayCrossMargin", false },
                { "setLeverage", true },
                { "setMargin", false },
                { "setMarginMode", false },
                { "setPositionMode", false },
                { "signIn", false },
                { "transfer", true },
                { "withdraw", false },
            } },
            { "timeframes", new Dictionary<string, object>() {
                { "1m", "1m" },
                { "3m", "3m" },
                { "5m", "5m" },
                { "15m", "15m" },
                { "30m", "30m" },
                { "1h", "1H" },
                { "2h", "2H" },
                { "4h", "4H" },
                { "6h", "6H" },
                { "8h", "8H" },
                { "12h", "12H" },
                { "1d", "1D" },
                { "3d", "3D" },
                { "1w", "1W" },
                { "1M", "1M" },
            } },
            { "hostname", "www.blofin.com" },
            { "urls", new Dictionary<string, object>() {
                { "logo", "https://github.com/user-attachments/assets/518cdf80-f05d-4821-a3e3-d48ceb41d73b" },
                { "api", new Dictionary<string, object>() {
                    { "rest", "https://openapi.blofin.com" },
                } },
                { "referral", new Dictionary<string, object>() {
                    { "url", "https://blofin.com/register?referral_code=jBd8U1" },
                    { "discount", 0.05 },
                } },
                { "www", "https://www.blofin.com" },
                { "doc", "https://blofin.com/docs" },
            } },
            { "api", new Dictionary<string, object>() {
                { "public", new Dictionary<string, object>() {
                    { "get", new Dictionary<string, object>() {
                        { "market/instruments", 1 },
                        { "market/tickers", 1 },
                        { "market/books", 1 },
                        { "market/trades", 1 },
                        { "market/candles", 1 },
                        { "market/mark-price", 1 },
                        { "market/funding-rate", 1 },
                        { "market/funding-rate-history", 1 },
                    } },
                } },
                { "private", new Dictionary<string, object>() {
                    { "get", new Dictionary<string, object>() {
                        { "asset/balances", 1 },
                        { "trade/orders-pending", 1 },
                        { "trade/fills-history", 1 },
                        { "asset/deposit-history", 1 },
                        { "asset/withdrawal-history", 1 },
                        { "asset/bills", 1 },
                        { "account/balance", 1 },
                        { "account/positions", 1 },
                        { "account/leverage-info", 1 },
                        { "account/margin-mode", 1 },
                        { "account/batch-leverage-info", 1 },
                        { "trade/orders-tpsl-pending", 1 },
                        { "trade/orders-history", 1 },
                        { "trade/orders-tpsl-history", 1 },
                        { "user/query-apikey", 1 },
                        { "affiliate/basic", 1 },
                    } },
                    { "post", new Dictionary<string, object>() {
                        { "trade/order", 1 },
                        { "trade/cancel-order", 1 },
                        { "account/set-leverage", 1 },
                        { "trade/batch-orders", 1 },
                        { "trade/order-tpsl", 1 },
                        { "trade/cancel-batch-orders", 1 },
                        { "trade/cancel-tpsl", 1 },
                        { "trade/close-position", 1 },
                        { "asset/transfer", 1 },
                    } },
                } },
            } },
            { "fees", new Dictionary<string, object>() {
                { "swap", new Dictionary<string, object>() {
                    { "taker", this.parseNumber("0.00060") },
                    { "maker", this.parseNumber("0.00020") },
                } },
            } },
            { "requiredCredentials", new Dictionary<string, object>() {
                { "apiKey", true },
                { "secret", true },
                { "password", true },
            } },
            { "exceptions", new Dictionary<string, object>() {
                { "exact", new Dictionary<string, object>() {
                    { "400", typeof(BadRequest) },
                    { "401", typeof(AuthenticationError) },
                    { "500", typeof(ExchangeError) },
                    { "404", typeof(BadRequest) },
                    { "405", typeof(BadRequest) },
                    { "406", typeof(BadRequest) },
                    { "429", typeof(RateLimitExceeded) },
                    { "152001", typeof(BadRequest) },
                    { "152002", typeof(BadRequest) },
                    { "152003", typeof(BadRequest) },
                    { "152004", typeof(BadRequest) },
                    { "152005", typeof(BadRequest) },
                    { "152006", typeof(InvalidOrder) },
                    { "152007", typeof(InvalidOrder) },
                    { "152008", typeof(InvalidOrder) },
                    { "152009", typeof(InvalidOrder) },
                    { "150003", typeof(InvalidOrder) },
                    { "150004", typeof(InvalidOrder) },
                    { "542", typeof(InvalidOrder) },
                    { "102002", typeof(InvalidOrder) },
                    { "102005", typeof(InvalidOrder) },
                    { "102014", typeof(InvalidOrder) },
                    { "102015", typeof(InvalidOrder) },
                    { "102022", typeof(InvalidOrder) },
                    { "102037", typeof(InvalidOrder) },
                    { "102038", typeof(InvalidOrder) },
                    { "102039", typeof(InvalidOrder) },
                    { "102040", typeof(InvalidOrder) },
                    { "102047", typeof(InvalidOrder) },
                    { "102048", typeof(InvalidOrder) },
                    { "102049", typeof(InvalidOrder) },
                    { "102050", typeof(InvalidOrder) },
                    { "102051", typeof(InvalidOrder) },
                    { "102052", typeof(InvalidOrder) },
                    { "102053", typeof(InvalidOrder) },
                    { "102054", typeof(InvalidOrder) },
                    { "102055", typeof(InvalidOrder) },
                    { "102064", typeof(BadRequest) },
                    { "102065", typeof(BadRequest) },
                    { "102068", typeof(BadRequest) },
                    { "103013", typeof(ExchangeError) },
                    { "Order failed. Insufficient USDT margin in account", typeof(InsufficientFunds) },
                } },
                { "broad", new Dictionary<string, object>() {
                    { "Internal Server Error", typeof(ExchangeNotAvailable) },
                    { "server error", typeof(ExchangeNotAvailable) },
                } },
            } },
            { "httpExceptions", new Dictionary<string, object>() {
                { "429", typeof(ExchangeNotAvailable) },
            } },
            { "precisionMode", TICK_SIZE },
            { "options", new Dictionary<string, object>() {
                { "brokerId", "ec6dd3a7dd982d0b" },
                { "accountsByType", new Dictionary<string, object>() {
                    { "swap", "futures" },
                    { "future", "futures" },
                } },
                { "accountsById", new Dictionary<string, object>() {
                    { "futures", "swap" },
                } },
                { "sandboxMode", false },
                { "defaultNetwork", "ERC20" },
                { "defaultNetworks", new Dictionary<string, object>() {
                    { "ETH", "ERC20" },
                    { "BTC", "BTC" },
                    { "USDT", "TRC20" },
                } },
                { "networks", new Dictionary<string, object>() {
                    { "BTC", "Bitcoin" },
                    { "BEP20", "BSC" },
                    { "ERC20", "ERC20" },
                    { "TRC20", "TRC20" },
                } },
                { "fetchOpenInterestHistory", new Dictionary<string, object>() {
                    { "timeframes", new Dictionary<string, object>() {
                        { "5m", "5m" },
                        { "1h", "1H" },
                        { "8h", "8H" },
                        { "1d", "1D" },
                        { "5M", "5m" },
                        { "1H", "1H" },
                        { "8H", "8H" },
                        { "1D", "1D" },
                    } },
                } },
                { "fetchOHLCV", new Dictionary<string, object>() {
                    { "timezone", "UTC" },
                } },
                { "fetchPositions", new Dictionary<string, object>() {
                    { "method", "privateGetAccountPositions" },
                } },
                { "createOrder", "privatePostTradeOrder" },
                { "createMarketBuyOrderRequiresPrice", false },
                { "fetchMarkets", new List<object>() {"swap"} },
                { "defaultType", "swap" },
                { "fetchLedger", new Dictionary<string, object>() {
                    { "method", "privateGetAssetBills" },
                } },
                { "fetchOpenOrders", new Dictionary<string, object>() {
                    { "method", "privateGetTradeOrdersPending" },
                } },
                { "cancelOrders", new Dictionary<string, object>() {
                    { "method", "privatePostTradeCancelBatchOrders" },
                } },
                { "fetchCanceledOrders", new Dictionary<string, object>() {
                    { "method", "privateGetTradeOrdersHistory" },
                } },
                { "fetchClosedOrders", new Dictionary<string, object>() {
                    { "method", "privateGetTradeOrdersHistory" },
                } },
                { "withdraw", new Dictionary<string, object>() {
                    { "password", null },
                    { "pwd", null },
                } },
                { "exchangeType", new Dictionary<string, object>() {
                    { "spot", "SPOT" },
                    { "swap", "SWAP" },
                    { "SPOT", "SPOT" },
                    { "SWAP", "SWAP" },
                } },
            } },
        });
    }

    /**
     * @method
     * @name blofin#fetchMarkets
     * @description retrieves data on all markets for blofin
     * @see https://blofin.com/docs#get-instruments
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} an array of objects representing market data
     */
    public async override Task<object> fetchMarkets(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object response = await this.publicGetMarketInstruments(parameters);
        object data = this.safeList(response, "data", new List<object>() {});
        return this.parseMarkets(data);
    }

    public override object parseMarket(object market)
    {
        object id = this.safeString(market, "instId");
        object type = this.safeStringLower(market, "instType");
        object spot = (isEqual(type, "spot"));
        object future = (isEqual(type, "future"));
        object swap = (isEqual(type, "swap"));
        object option = (isEqual(type, "option"));
        object contract = isTrue(swap) || isTrue(future);
        object baseId = this.safeString(market, "baseCurrency");
        object quoteId = this.safeString(market, "quoteCurrency");
        object settleId = this.safeString(market, "quoteCurrency");
        object settle = this.safeCurrencyCode(settleId);
        object bs = this.safeCurrencyCode(baseId);
        object quote = this.safeCurrencyCode(quoteId);
        object symbol = add(add(bs, "/"), quote);
        if (isTrue(swap))
        {
            symbol = add(add(symbol, ":"), settle);
        }
        object expiry = null;
        object strikePrice = null;
        object optionType = null;
        object tickSize = this.safeString(market, "tickSize");
        object fees = this.safeDict2(this.fees, type, "trading", new Dictionary<string, object>() {});
        object taker = this.safeNumber(fees, "taker");
        object maker = this.safeNumber(fees, "maker");
        object maxLeverage = this.safeString(market, "maxLeverage", "100");
        maxLeverage = Precise.stringMax(maxLeverage, "1");
        object isActive = (isEqual(this.safeString(market, "state"), "live"));
        return this.safeMarketStructure(new Dictionary<string, object>() {
            { "id", id },
            { "symbol", symbol },
            { "base", bs },
            { "quote", quote },
            { "baseId", baseId },
            { "quoteId", quoteId },
            { "settle", settle },
            { "settleId", settleId },
            { "type", type },
            { "spot", spot },
            { "option", option },
            { "margin", isTrue(spot) && isTrue((Precise.stringGt(maxLeverage, "1"))) },
            { "swap", swap },
            { "future", future },
            { "active", isActive },
            { "taker", taker },
            { "maker", maker },
            { "contract", contract },
            { "linear", ((bool) isTrue(contract)) ? (isEqual(quoteId, settleId)) : null },
            { "inverse", ((bool) isTrue(contract)) ? (isEqual(baseId, settleId)) : null },
            { "contractSize", ((bool) isTrue(contract)) ? this.safeNumber(market, "contractValue") : null },
            { "expiry", expiry },
            { "expiryDatetime", expiry },
            { "strike", strikePrice },
            { "optionType", optionType },
            { "created", this.safeInteger(market, "listTime") },
            { "precision", new Dictionary<string, object>() {
                { "amount", this.safeNumber(market, "lotSize") },
                { "price", this.parseNumber(tickSize) },
            } },
            { "limits", new Dictionary<string, object>() {
                { "leverage", new Dictionary<string, object>() {
                    { "min", this.parseNumber("1") },
                    { "max", this.parseNumber(maxLeverage) },
                } },
                { "amount", new Dictionary<string, object>() {
                    { "min", this.safeNumber(market, "minSize") },
                    { "max", null },
                } },
                { "price", new Dictionary<string, object>() {
                    { "min", null },
                    { "max", null },
                } },
                { "cost", new Dictionary<string, object>() {
                    { "min", null },
                    { "max", null },
                } },
            } },
            { "info", market },
        });
    }

    /**
     * @method
     * @name blofin#fetchOrderBook
     * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
     * @see https://blofin.com/docs#get-order-book
     * @param {string} symbol unified symbol of the market to fetch the order book for
     * @param {int} [limit] the maximum amount of order book entries to return
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
     */
    public async override Task<object> fetchOrderBook(object symbol, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "instId", getValue(market, "id") },
        };
        limit = ((bool) isTrue((isEqual(limit, null)))) ? 50 : limit;
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["size"] = limit; // max 100
        }
        object response = await this.publicGetMarketBooks(this.extend(request, parameters));
        //
        //     {
        //         "code": "0",
        //         "msg": "",
        //         "data": [
        //             {
        //                 "asks": [
        //                     ["0.07228","4.211619","0","2"], // price, amount, liquidated orders, total open orders
        //                     ["0.0723","299.880364","0","2"],
        //                     ["0.07231","3.72832","0","1"],
        //                 ],
        //                 "bids": [
        //                     ["0.07221","18.5","0","1"],
        //                     ["0.0722","18.5","0","1"],
        //                     ["0.07219","0.505407","0","1"],
        //                 ],
        //                 "ts": "1621438475342"
        //             }
        //         ]
        //     }
        //
        object data = this.safeList(response, "data", new List<object>() {});
        object first = this.safeDict(data, 0, new Dictionary<string, object>() {});
        object timestamp = this.safeInteger(first, "ts");
        return this.parseOrderBook(first, symbol, timestamp);
    }

    public override object parseTicker(object ticker, object market = null)
    {
        //
        // response similar for REST & WS
        //
        //     {
        //         instId: "ADA-USDT",
        //         ts: "1707736811486",
        //         last: "0.5315",
        //         lastSize: "4",
        //         askPrice: "0.5318",
        //         askSize: "248",
        //         bidPrice: "0.5315",
        //         bidSize: "63",
        //         open24h: "0.5555",
        //         high24h: "0.5563",
        //         low24h: "0.5315",
        //         volCurrency24h: "198560100",
        //         vol24h: "1985601",
        //     }
        //
        object timestamp = this.safeInteger(ticker, "ts");
        object marketId = this.safeString(ticker, "instId");
        market = this.safeMarket(marketId, market, "-");
        object symbol = getValue(market, "symbol");
        object last = this.safeString(ticker, "last");
        object open = this.safeString(ticker, "open24h");
        object spot = this.safeBool(market, "spot", false);
        object quoteVolume = ((bool) isTrue(spot)) ? this.safeString(ticker, "volCurrency24h") : null;
        object baseVolume = this.safeString(ticker, "vol24h");
        object high = this.safeString(ticker, "high24h");
        object low = this.safeString(ticker, "low24h");
        return this.safeTicker(new Dictionary<string, object>() {
            { "symbol", symbol },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "high", high },
            { "low", low },
            { "bid", this.safeString(ticker, "bidPrice") },
            { "bidVolume", this.safeString(ticker, "bidSize") },
            { "ask", this.safeString(ticker, "askPrice") },
            { "askVolume", this.safeString(ticker, "askSize") },
            { "vwap", null },
            { "open", open },
            { "close", last },
            { "last", last },
            { "previousClose", null },
            { "change", null },
            { "percentage", null },
            { "average", null },
            { "baseVolume", baseVolume },
            { "quoteVolume", quoteVolume },
            { "indexPrice", this.safeString(ticker, "indexPrice") },
            { "markPrice", this.safeString(ticker, "markPrice") },
            { "info", ticker },
        }, market);
    }

    /**
     * @method
     * @name blofin#fetchTicker
     * @description fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
     * @see https://blofin.com/docs#get-tickers
     * @param {string} symbol unified symbol of the market to fetch the ticker for
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
     */
    public async override Task<object> fetchTicker(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "instId", getValue(market, "id") },
        };
        object response = await this.publicGetMarketTickers(this.extend(request, parameters));
        object data = this.safeList(response, "data", new List<object>() {});
        object first = this.safeDict(data, 0, new Dictionary<string, object>() {});
        return this.parseTicker(first, market);
    }

    /**
     * @method
     * @name blofin#fetchMarkPrice
     * @description fetches mark price for the market
     * @see https://docs.blofin.com/index.html#get-mark-price
     * @param {string} symbol unified market symbol
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.subType] "linear" or "inverse"
     * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/#/?id=ticker-structure}
     */
    public async override Task<object> fetchMarkPrice(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object response = await this.publicGetMarketMarkPrice(this.extend(request, parameters));
        object data = this.safeList(response, "data", new List<object>() {});
        object first = this.safeDict(data, 0, new Dictionary<string, object>() {});
        return this.parseTicker(first, market);
    }

    /**
     * @method
     * @name blofin#fetchTickers
     * @description fetches price tickers for multiple markets, statistical information calculated over the past 24 hours for each market
     * @see https://blofin.com/docs#get-tickers
     * @param {string[]} [symbols] unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/#/?id=ticker-structure}
     */
    public async override Task<object> fetchTickers(object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        symbols = this.marketSymbols(symbols);
        object response = await this.publicGetMarketTickers(parameters);
        object tickers = this.safeList(response, "data", new List<object>() {});
        return this.parseTickers(tickers, symbols);
    }

    public override object parseTrade(object trade, object market = null)
    {
        //
        // fetch trades (response similar for REST & WS)
        //
        //   {
        //       "tradeId": "3263934920",
        //       "instId": "LTC-USDT",
        //       "price": "67.87",
        //       "size": "1",
        //       "side": "buy",
        //       "ts": "1707232020854"
        //   }
        //
        // my trades
        //   {
        //       "instId": "LTC-USDT",
        //       "tradeId": "1440847",
        //       "orderId": "2075705202",
        //       "fillPrice": "67.850000000000000000",
        //       "fillSize": "1.000000000000000000",
        //       "fillPnl": "0.000000000000000000",
        //       "side": "buy",
        //       "positionSide": "net",
        //       "fee": "0.040710000000000000",
        //       "ts": "1707224678878",
        //       "brokerId": ""
        //   }
        //
        object id = this.safeString(trade, "tradeId");
        object marketId = this.safeString(trade, "instId");
        market = this.safeMarket(marketId, market, "-");
        object symbol = getValue(market, "symbol");
        object timestamp = this.safeInteger(trade, "ts");
        object price = this.safeString2(trade, "price", "fillPrice");
        object amount = this.safeString2(trade, "size", "fillSize");
        object side = this.safeString(trade, "side");
        object orderId = this.safeString(trade, "orderId");
        object feeCost = this.safeString(trade, "fee");
        object fee = null;
        if (isTrue(!isEqual(feeCost, null)))
        {
            fee = new Dictionary<string, object>() {
                { "cost", feeCost },
                { "currency", getValue(market, "settle") },
            };
        }
        return this.safeTrade(new Dictionary<string, object>() {
            { "info", trade },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "symbol", symbol },
            { "id", id },
            { "order", orderId },
            { "type", null },
            { "takerOrMaker", null },
            { "side", side },
            { "price", price },
            { "amount", amount },
            { "cost", null },
            { "fee", fee },
        }, market);
    }

    /**
     * @method
     * @name blofin#fetchTrades
     * @description get the list of most recent trades for a particular symbol
     * @see https://blofin.com/docs#get-trades
     * @param {string} symbol unified symbol of the market to fetch trades for
     * @param {int} [since] timestamp in ms of the earliest trade to fetch
     * @param {int} [limit] the maximum amount of trades to fetch
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {boolean} [params.paginate] *only applies to publicGetMarketHistoryTrades* default false, when true will automatically paginate by calling this endpoint multiple times
     * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
     */
    public async override Task<object> fetchTrades(object symbol, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object paginate = false;
        var paginateparametersVariable = this.handleOptionAndParams(parameters, "fetchTrades", "paginate");
        paginate = ((IList<object>)paginateparametersVariable)[0];
        parameters = ((IList<object>)paginateparametersVariable)[1];
        if (isTrue(paginate))
        {
            return await this.fetchPaginatedCallCursor("fetchTrades", symbol, since, limit, parameters, "tradeId", "after", null, 100);
        }
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "instId", getValue(market, "id") },
        };
        object response = null;
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit; // default 100
        }
        object method = null;
        var methodparametersVariable = this.handleOptionAndParams(parameters, "fetchTrades", "method", "publicGetMarketTrades");
        method = ((IList<object>)methodparametersVariable)[0];
        parameters = ((IList<object>)methodparametersVariable)[1];
        if (isTrue(isEqual(method, "publicGetMarketTrades")))
        {
            response = await this.publicGetMarketTrades(this.extend(request, parameters));
        }
        object data = this.safeList(response, "data", new List<object>() {});
        return this.parseTrades(data, market, since, limit);
    }

    public override object parseOHLCV(object ohlcv, object market = null)
    {
        //
        //     [
        //         "1678928760000", // timestamp
        //         "24341.4", // open
        //         "24344", // high
        //         "24313.2", // low
        //         "24323", // close
        //         "628", // contract volume
        //         "2.5819", // base volume
        //         "62800", // quote volume
        //         "0" // candlestick state
        //     ]
        //
        return new List<object> {this.safeInteger(ohlcv, 0), this.safeNumber(ohlcv, 1), this.safeNumber(ohlcv, 2), this.safeNumber(ohlcv, 3), this.safeNumber(ohlcv, 4), this.safeNumber(ohlcv, 6)};
    }

    /**
     * @method
     * @name blofin#fetchOHLCV
     * @description fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
     * @see https://blofin.com/docs#get-candlesticks
     * @param {string} symbol unified symbol of the market to fetch OHLCV data for
     * @param {string} timeframe the length of time each candle represents
     * @param {int} [since] timestamp in ms of the earliest candle to fetch
     * @param {int} [limit] the maximum amount of candles to fetch
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {int} [params.until] timestamp in ms of the latest candle to fetch
     * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [availble parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
     * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
     */
    public async override Task<object> fetchOHLCV(object symbol, object timeframe = null, object since = null, object limit = null, object parameters = null)
    {
        timeframe ??= "1m";
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object paginate = false;
        var paginateparametersVariable = this.handleOptionAndParams(parameters, "fetchOHLCV", "paginate");
        paginate = ((IList<object>)paginateparametersVariable)[0];
        parameters = ((IList<object>)paginateparametersVariable)[1];
        if (isTrue(paginate))
        {
            return await this.fetchPaginatedCallDeterministic("fetchOHLCV", symbol, since, limit, timeframe, parameters, 100);
        }
        if (isTrue(isEqual(limit, null)))
        {
            limit = 100; // default 100, max 100
        }
        object request = new Dictionary<string, object>() {
            { "instId", getValue(market, "id") },
            { "bar", this.safeString(this.timeframes, timeframe, timeframe) },
            { "limit", limit },
        };
        object until = this.safeInteger(parameters, "until");
        if (isTrue(!isEqual(until, null)))
        {
            ((IDictionary<string,object>)request)["after"] = until;
            parameters = this.omit(parameters, "until");
        }
        object response = null;
        response = await this.publicGetMarketCandles(this.extend(request, parameters));
        object data = this.safeList(response, "data", new List<object>() {});
        return this.parseOHLCVs(data, market, timeframe, since, limit);
    }

    /**
     * @method
     * @name blofin#fetchFundingRateHistory
     * @description fetches historical funding rate prices
     * @see https://blofin.com/docs#get-funding-rate-history
     * @param {string} symbol unified symbol of the market to fetch the funding rate history for
     * @param {int} [since] timestamp in ms of the earliest funding rate to fetch
     * @param {int} [limit] the maximum amount of [funding rate structures]{@link https://docs.ccxt.com/#/?id=funding-rate-history-structure} to fetch
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [availble parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
     * @returns {object[]} a list of [funding rate structures]{@link https://docs.ccxt.com/#/?id=funding-rate-history-structure}
     */
    public async override Task<object> fetchFundingRateHistory(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchFundingRateHistory() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object paginate = false;
        var paginateparametersVariable = this.handleOptionAndParams(parameters, "fetchFundingRateHistory", "paginate");
        paginate = ((IList<object>)paginateparametersVariable)[0];
        parameters = ((IList<object>)paginateparametersVariable)[1];
        if (isTrue(paginate))
        {
            return await this.fetchPaginatedCallDeterministic("fetchFundingRateHistory", symbol, since, limit, "8h", parameters);
        }
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "instId", getValue(market, "id") },
        };
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["before"] = mathMax(subtract(since, 1), 0);
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        object response = await this.publicGetMarketFundingRateHistory(this.extend(request, parameters));
        object rates = new List<object>() {};
        object data = this.safeList(response, "data", new List<object>() {});
        for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
        {
            object rate = getValue(data, i);
            object timestamp = this.safeInteger(rate, "fundingTime");
            ((IList<object>)rates).Add(new Dictionary<string, object>() {
                { "info", rate },
                { "symbol", getValue(market, "symbol") },
                { "fundingRate", this.safeNumber(rate, "fundingRate") },
                { "timestamp", timestamp },
                { "datetime", this.iso8601(timestamp) },
            });
        }
        object sorted = this.sortBy(rates, "timestamp");
        return this.filterBySymbolSinceLimit(sorted, getValue(market, "symbol"), since, limit);
    }

    public override object parseFundingRate(object contract, object market = null)
    {
        //
        //    {
        //        "fundingRate": "0.00027815",
        //        "fundingTime": "1634256000000",
        //        "instId": "BTC-USD-SWAP",
        //    }
        //
        object marketId = this.safeString(contract, "instId");
        object symbol = this.safeSymbol(marketId, market);
        object fundingTime = this.safeInteger(contract, "fundingTime");
        // > The current interest is 0.
        return new Dictionary<string, object>() {
            { "info", contract },
            { "symbol", symbol },
            { "markPrice", null },
            { "indexPrice", null },
            { "interestRate", this.parseNumber("0") },
            { "estimatedSettlePrice", null },
            { "timestamp", null },
            { "datetime", null },
            { "fundingRate", this.safeNumber(contract, "fundingRate") },
            { "fundingTimestamp", fundingTime },
            { "fundingDatetime", this.iso8601(fundingTime) },
            { "nextFundingRate", null },
            { "nextFundingTimestamp", null },
            { "nextFundingDatetime", null },
            { "previousFundingRate", null },
            { "previousFundingTimestamp", null },
            { "previousFundingDatetime", null },
            { "interval", null },
        };
    }

    /**
     * @method
     * @name blofin#fetchFundingRate
     * @description fetch the current funding rate
     * @see https://blofin.com/docs#get-funding-rate
     * @param {string} symbol unified market symbol
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [funding rate structure]{@link https://docs.ccxt.com/#/?id=funding-rate-structure}
     */
    public async override Task<object> fetchFundingRate(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        if (!isTrue(getValue(market, "swap")))
        {
            throw new ExchangeError ((string)add(this.id, " fetchFundingRate() is only valid for swap markets")) ;
        }
        object request = new Dictionary<string, object>() {
            { "instId", getValue(market, "id") },
        };
        object response = await this.publicGetMarketFundingRate(this.extend(request, parameters));
        //
        //    {
        //        "code": "0",
        //        "data": [
        //            {
        //                "fundingRate": "0.00027815",
        //                "fundingTime": "1634256000000",
        //                "instId": "BTC-USD-SWAP",
        //            }
        //        ],
        //        "msg": ""
        //    }
        //
        object data = this.safeList(response, "data", new List<object>() {});
        object entry = this.safeDict(data, 0, new Dictionary<string, object>() {});
        return this.parseFundingRate(entry, market);
    }

    public virtual object parseBalanceByType(object type, object response)
    {
        if (isTrue(type))
        {
            return this.parseFundingBalance(response);
        } else
        {
            return this.parseBalance(response);
        }
    }

    public override object parseBalance(object response)
    {
        //
        // "data" similar for REST & WS
        //
        // {
        //     "code": "0",
        //     "msg": "success",
        //     "data": {
        //         "ts": "1697021343571",
        //         "totalEquity": "10011254.077985990315787910",
        //         "isolatedEquity": "861.763132108800000000",
        //         "details": [
        //             {
        //                 "currency": "USDT",
        //                 "equity": "10014042.988958415234430699548",
        //                 "balance": "10013119.885958415234430699",
        //                 "ts": "1697021343571",
        //                 "isolatedEquity": "862.003200000000000000048",
        //                 "available": "9996399.4708691159703362725",
        //                 "availableEquity": "9996399.4708691159703362725",
        //                 "frozen": "15805.149672632597427761",
        //                 "orderFrozen": "14920.994472632597427761",
        //                 "equityUsd": "10011254.077985990315787910",
        //                 "isolatedUnrealizedPnl": "-22.151999999999999999952",
        //                 "bonus": "0" // present only in REST
        //                 "unrealizedPnl": "0" // present only in WS
        //             }
        //         ]
        //     }
        // }
        //
        object result = new Dictionary<string, object>() {
            { "info", response },
        };
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        object timestamp = this.safeInteger(data, "ts");
        object details = this.safeList(data, "details", new List<object>() {});
        for (object i = 0; isLessThan(i, getArrayLength(details)); postFixIncrement(ref i))
        {
            object balance = getValue(details, i);
            object currencyId = this.safeString(balance, "currency");
            object code = this.safeCurrencyCode(currencyId);
            object account = this.account();
            // it may be incorrect to use total, free and used for swap accounts
            object eq = this.safeString(balance, "equity");
            object availEq = this.safeString(balance, "available");
            if (isTrue(isTrue((isEqual(eq, null))) || isTrue((isEqual(availEq, null)))))
            {
                ((IDictionary<string,object>)account)["free"] = this.safeString(balance, "availableEquity");
                ((IDictionary<string,object>)account)["used"] = this.safeString(balance, "frozen");
            } else
            {
                ((IDictionary<string,object>)account)["total"] = eq;
                ((IDictionary<string,object>)account)["free"] = availEq;
            }
            ((IDictionary<string,object>)result)[(string)code] = account;
        }
        ((IDictionary<string,object>)result)["timestamp"] = timestamp;
        ((IDictionary<string,object>)result)["datetime"] = this.iso8601(timestamp);
        return this.safeBalance(result);
    }

    public virtual object parseFundingBalance(object response)
    {
        //
        //  {
        //      "code": "0",
        //      "msg": "success",
        //      "data": [
        //          {
        //              "currency": "USDT",
        //              "balance": "10012514.919418081548717298",
        //              "available": "9872132.414278782284622898",
        //              "frozen": "138556.471805965930761067",
        //              "bonus": "0"
        //          }
        //      ]
        //  }
        //
        object result = new Dictionary<string, object>() {
            { "info", response },
        };
        object data = this.safeList(response, "data", new List<object>() {});
        for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
        {
            object balance = getValue(data, i);
            object currencyId = this.safeString(balance, "currency");
            object code = this.safeCurrencyCode(currencyId);
            object account = this.account();
            // it may be incorrect to use total, free and used for swap accounts
            ((IDictionary<string,object>)account)["total"] = this.safeString(balance, "balance");
            ((IDictionary<string,object>)account)["free"] = this.safeString(balance, "available");
            ((IDictionary<string,object>)account)["used"] = this.safeString(balance, "frozen");
            ((IDictionary<string,object>)result)[(string)code] = account;
        }
        return this.safeBalance(result);
    }

    public virtual object parseTradingFee(object fee, object market = null)
    {
        return new Dictionary<string, object>() {
            { "info", fee },
            { "symbol", this.safeSymbol(null, market) },
            { "maker", this.parseNumber(Precise.stringNeg(this.safeString2(fee, "maker", "makerU"))) },
            { "taker", this.parseNumber(Precise.stringNeg(this.safeString2(fee, "taker", "takerU"))) },
            { "percentage", null },
            { "tierBased", null },
        };
    }

    /**
     * @method
     * @name blofin#fetchBalance
     * @description query for balance and get the amount of funds available for trading or funds locked in orders
     * @see https://blofin.com/docs#get-balance
     * @see https://blofin.com/docs#get-futures-account-balance
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.accountType] the type of account to fetch the balance for, either 'funding' or 'futures'  or 'copy_trading' or 'earn'
     * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
     */
    public async override Task<object> fetchBalance(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object accountType = this.safeString2(parameters, "accountType", "type");
        parameters = this.omit(parameters, new List<object>() {"accountType", "type"});
        object request = new Dictionary<string, object>() {};
        object response = null;
        if (isTrue(!isEqual(accountType, null)))
        {
            object options = this.safeDict(this.options, "accountsByType", new Dictionary<string, object>() {});
            object parsedAccountType = this.safeString(options, accountType, accountType);
            ((IDictionary<string,object>)request)["accountType"] = parsedAccountType;
            response = await this.privateGetAssetBalances(this.extend(request, parameters));
        } else
        {
            response = await this.privateGetAccountBalance(this.extend(request, parameters));
        }
        return this.parseBalanceByType(accountType, response);
    }

    public virtual object createOrderRequest(object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "instId", getValue(market, "id") },
            { "side", side },
            { "orderType", type },
            { "size", this.amountToPrecision(symbol, amount) },
            { "brokerId", this.safeString(this.options, "brokerId", "ec6dd3a7dd982d0b") },
        };
        object marginMode = null;
        var marginModeparametersVariable = this.handleMarginModeAndParams("createOrder", parameters, "cross");
        marginMode = ((IList<object>)marginModeparametersVariable)[0];
        parameters = ((IList<object>)marginModeparametersVariable)[1];
        ((IDictionary<string,object>)request)["marginMode"] = marginMode;
        object timeInForce = this.safeString(parameters, "timeInForce", "GTC");
        object isMarketOrder = isEqual(type, "market");
        parameters = this.omit(parameters, new List<object>() {"timeInForce"});
        object ioc = isTrue((isEqual(timeInForce, "IOC"))) || isTrue((isEqual(type, "ioc")));
        object marketIOC = (isTrue(isMarketOrder) && isTrue(ioc));
        if (isTrue(isTrue(isMarketOrder) || isTrue(marketIOC)))
        {
            ((IDictionary<string,object>)request)["orderType"] = "market";
        } else
        {
            ((IDictionary<string,object>)request)["price"] = this.priceToPrecision(symbol, price);
        }
        object postOnly = false;
        var postOnlyparametersVariable = this.handlePostOnly(isMarketOrder, isEqual(type, "post_only"), parameters);
        postOnly = ((IList<object>)postOnlyparametersVariable)[0];
        parameters = ((IList<object>)postOnlyparametersVariable)[1];
        if (isTrue(postOnly))
        {
            ((IDictionary<string,object>)request)["type"] = "post_only";
        }
        object stopLoss = this.safeDict(parameters, "stopLoss");
        object takeProfit = this.safeDict(parameters, "takeProfit");
        parameters = this.omit(parameters, new List<object>() {"stopLoss", "takeProfit"});
        object isStopLoss = !isEqual(stopLoss, null);
        object isTakeProfit = !isEqual(takeProfit, null);
        if (isTrue(isTrue(isStopLoss) || isTrue(isTakeProfit)))
        {
            if (isTrue(isStopLoss))
            {
                object slTriggerPrice = this.safeString2(stopLoss, "triggerPrice", "stopPrice");
                ((IDictionary<string,object>)request)["slTriggerPrice"] = this.priceToPrecision(symbol, slTriggerPrice);
                object slOrderPrice = this.safeString(stopLoss, "price", "-1");
                ((IDictionary<string,object>)request)["slOrderPrice"] = this.priceToPrecision(symbol, slOrderPrice);
            }
            if (isTrue(isTakeProfit))
            {
                object tpTriggerPrice = this.safeString2(takeProfit, "triggerPrice", "stopPrice");
                ((IDictionary<string,object>)request)["tpTriggerPrice"] = this.priceToPrecision(symbol, tpTriggerPrice);
                object tpPrice = this.safeString(takeProfit, "price", "-1");
                ((IDictionary<string,object>)request)["tpOrderPrice"] = this.priceToPrecision(symbol, tpPrice);
            }
        }
        return this.extend(request, parameters);
    }

    public virtual object parseOrderStatus(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "canceled", "canceled" },
            { "order_failed", "canceled" },
            { "live", "open" },
            { "partially_filled", "open" },
            { "filled", "closed" },
            { "effective", "closed" },
        };
        return this.safeString(statuses, status, status);
    }

    public override object parseOrder(object order, object market = null)
    {
        //
        // response similar for REST & WS
        //
        // {
        //     "orderId": "2075628533",
        //     "clientOrderId": "",
        //     "instId": "LTC-USDT",
        //     "marginMode": "cross",
        //     "positionSide": "net",
        //     "side": "buy",
        //     "orderType": "market",
        //     "price": "0.000000000000000000",
        //     "size": "1.000000000000000000",
        //     "reduceOnly": "true",
        //     "leverage": "3",
        //     "state": "filled",
        //     "filledSize": "1.000000000000000000",
        //     "pnl": "-0.050000000000000000",
        //     "averagePrice": "68.110000000000000000",
        //     "fee": "0.040866000000000000",
        //     "createTime": "1706891359010",
        //     "updateTime": "1706891359098",
        //     "orderCategory": "normal",
        //     "tpTriggerPrice": null,
        //     "tpOrderPrice": null,
        //     "slTriggerPrice": null,
        //     "slOrderPrice": null,
        //     "cancelSource": "not_canceled",
        //     "cancelSourceReason": null,
        //     "brokerId": "ec6dd3a7dd982d0b"
        //     "filled_amount": "1.000000000000000000", // filledAmount in "ws" watchOrders
        //     "cancelSource": "", // only in WS
        //     "instType": "SWAP", // only in WS
        // }
        //
        object id = this.safeString2(order, "tpslId", "orderId");
        object timestamp = this.safeInteger(order, "createTime");
        object lastUpdateTimestamp = this.safeInteger(order, "updateTime");
        object lastTradeTimestamp = this.safeInteger(order, "fillTime");
        object side = this.safeString(order, "side");
        object type = this.safeString(order, "orderType");
        object postOnly = null;
        object timeInForce = null;
        if (isTrue(isEqual(type, "post_only")))
        {
            postOnly = true;
            type = "limit";
        } else if (isTrue(isEqual(type, "fok")))
        {
            timeInForce = "FOK";
            type = "limit";
        } else if (isTrue(isEqual(type, "ioc")))
        {
            timeInForce = "IOC";
            type = "limit";
        }
        object marketId = this.safeString(order, "instId");
        market = this.safeMarket(marketId, market);
        object symbol = this.safeSymbol(marketId, market, "-");
        object filled = this.safeString(order, "filledSize");
        object price = this.safeString2(order, "px", "price");
        object average = this.safeString(order, "averagePrice");
        object status = this.parseOrderStatus(this.safeString(order, "state"));
        object feeCostString = this.safeString(order, "fee");
        object amount = this.safeString(order, "size");
        object leverage = this.safeString(order, "leverage", "1");
        object contractSize = this.safeString(market, "contractSize");
        object baseAmount = Precise.stringMul(contractSize, filled);
        object cost = null;
        if (isTrue(!isEqual(average, null)))
        {
            cost = Precise.stringMul(average, baseAmount);
            cost = Precise.stringDiv(cost, leverage);
        }
        // spot market buy: "sz" can refer either to base currency units or to quote currency units
        object fee = null;
        if (isTrue(!isEqual(feeCostString, null)))
        {
            object feeCostSigned = Precise.stringAbs(feeCostString);
            object feeCurrencyId = this.safeString(order, "feeCcy", "USDT");
            object feeCurrencyCode = this.safeCurrencyCode(feeCurrencyId);
            fee = new Dictionary<string, object>() {
                { "cost", this.parseNumber(feeCostSigned) },
                { "currency", feeCurrencyCode },
            };
        }
        object clientOrderId = this.safeString(order, "clientOrderId");
        if (isTrue(isTrue((!isEqual(clientOrderId, null))) && isTrue((isLessThan(((string)clientOrderId).Length, 1)))))
        {
            clientOrderId = null; // fix empty clientOrderId string
        }
        object stopLossTriggerPrice = this.safeNumber(order, "slTriggerPrice");
        object stopLossPrice = this.safeNumber(order, "slOrderPrice");
        object takeProfitTriggerPrice = this.safeNumber(order, "tpTriggerPrice");
        object takeProfitPrice = this.safeNumber(order, "tpOrderPrice");
        object reduceOnlyRaw = this.safeString(order, "reduceOnly");
        object reduceOnly = (isEqual(reduceOnlyRaw, "true"));
        return this.safeOrder(new Dictionary<string, object>() {
            { "info", order },
            { "id", id },
            { "clientOrderId", clientOrderId },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "lastTradeTimestamp", lastTradeTimestamp },
            { "lastUpdateTimestamp", lastUpdateTimestamp },
            { "symbol", symbol },
            { "type", type },
            { "timeInForce", timeInForce },
            { "postOnly", postOnly },
            { "side", side },
            { "price", price },
            { "stopLossTriggerPrice", stopLossTriggerPrice },
            { "takeProfitTriggerPrice", takeProfitTriggerPrice },
            { "stopLossPrice", stopLossPrice },
            { "takeProfitPrice", takeProfitPrice },
            { "average", average },
            { "cost", cost },
            { "amount", amount },
            { "filled", filled },
            { "remaining", null },
            { "status", status },
            { "fee", fee },
            { "trades", null },
            { "reduceOnly", reduceOnly },
        }, market);
    }

    /**
     * @method
     * @name blofin#createOrder
     * @description create a trade order
     * @see https://blofin.com/docs#place-order
     * @see https://blofin.com/docs#place-tpsl-order
     * @param {string} symbol unified symbol of the market to create an order in
     * @param {string} type 'market' or 'limit' or 'post_only' or 'ioc' or 'fok'
     * @param {string} side 'buy' or 'sell'
     * @param {float} amount how much of currency you want to trade in units of base currency
     * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {bool} [params.reduceOnly] a mark to reduce the position size for margin, swap and future orders
     * @param {bool} [params.postOnly] true to place a post only order
     * @param {string} [params.marginMode] 'cross' or 'isolated', default is 'cross'
     * @param {float} [params.stopLossPrice] stop loss trigger price (will use privatePostTradeOrderTpsl)
     * @param {float} [params.takeProfitPrice] take profit trigger price (will use privatePostTradeOrderTpsl)
     * @param {string} [params.positionSide] *stopLossPrice/takeProfitPrice orders only* 'long' or 'short' or 'net' default is 'net'
     * @param {string} [params.clientOrderId] a unique id for the order
     * @param {object} [params.takeProfit] *takeProfit object in params* containing the triggerPrice at which the attached take profit order will be triggered
     * @param {float} [params.takeProfit.triggerPrice] take profit trigger price
     * @param {float} [params.takeProfit.price] take profit order price (if not provided the order will be a market order)
     * @param {object} [params.stopLoss] *stopLoss object in params* containing the triggerPrice at which the attached stop loss order will be triggered
     * @param {float} [params.stopLoss.triggerPrice] stop loss trigger price
     * @param {float} [params.stopLoss.price] stop loss order price (if not provided the order will be a market order)
     * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> createOrder(object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object tpsl = this.safeBool(parameters, "tpsl", false);
        parameters = this.omit(parameters, "tpsl");
        object method = null;
        var methodparametersVariable = this.handleOptionAndParams(parameters, "createOrder", "method", "privatePostTradeOrder");
        method = ((IList<object>)methodparametersVariable)[0];
        parameters = ((IList<object>)methodparametersVariable)[1];
        object isStopLossPriceDefined = !isEqual(this.safeString(parameters, "stopLossPrice"), null);
        object isTakeProfitPriceDefined = !isEqual(this.safeString(parameters, "takeProfitPrice"), null);
        object isType2Order = (isTrue(isStopLossPriceDefined) || isTrue(isTakeProfitPriceDefined));
        object response = null;
        if (isTrue(isTrue(isTrue(tpsl) || isTrue((isEqual(method, "privatePostTradeOrderTpsl")))) || isTrue(isType2Order)))
        {
            object tpslRequest = this.createTpslOrderRequest(symbol, type, side, amount, price, parameters);
            response = await this.privatePostTradeOrderTpsl(tpslRequest);
        } else
        {
            object request = this.createOrderRequest(symbol, type, side, amount, price, parameters);
            response = await this.privatePostTradeOrder(request);
        }
        object data = this.safeList(response, "data", new List<object>() {});
        object first = this.safeDict(data, 0);
        object order = this.parseOrder(first, market);
        ((IDictionary<string,object>)order)["type"] = type;
        ((IDictionary<string,object>)order)["side"] = side;
        return order;
    }

    public virtual object createTpslOrderRequest(object symbol, object type, object side, object amount = null, object price = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object market = this.market(symbol);
        object positionSide = this.safeString(parameters, "positionSide", "net");
        object request = new Dictionary<string, object>() {
            { "instId", getValue(market, "id") },
            { "side", side },
            { "positionSide", positionSide },
            { "brokerId", this.safeString(this.options, "brokerId", "ec6dd3a7dd982d0b") },
        };
        if (isTrue(!isEqual(amount, null)))
        {
            ((IDictionary<string,object>)request)["size"] = this.amountToPrecision(symbol, amount);
        }
        object marginMode = this.safeString(parameters, "marginMode", "cross"); // cross or isolated
        if (isTrue(isTrue(!isEqual(marginMode, "cross")) && isTrue(!isEqual(marginMode, "isolated"))))
        {
            throw new BadRequest ((string)add(this.id, " createTpslOrder() requires a marginMode parameter that must be either cross or isolated")) ;
        }
        object stopLossPrice = this.safeString(parameters, "stopLossPrice");
        object takeProfitPrice = this.safeString(parameters, "takeProfitPrice");
        if (isTrue(!isEqual(stopLossPrice, null)))
        {
            ((IDictionary<string,object>)request)["slTriggerPrice"] = this.priceToPrecision(symbol, stopLossPrice);
            if (isTrue(isEqual(type, "market")))
            {
                ((IDictionary<string,object>)request)["slOrderPrice"] = "-1";
            } else
            {
                ((IDictionary<string,object>)request)["slOrderPrice"] = this.priceToPrecision(symbol, price);
            }
        } else if (isTrue(!isEqual(takeProfitPrice, null)))
        {
            ((IDictionary<string,object>)request)["tpTriggerPrice"] = this.priceToPrecision(symbol, takeProfitPrice);
            if (isTrue(isEqual(type, "market")))
            {
                ((IDictionary<string,object>)request)["tpOrderPrice"] = "-1";
            } else
            {
                ((IDictionary<string,object>)request)["tpOrderPrice"] = this.priceToPrecision(symbol, price);
            }
        }
        ((IDictionary<string,object>)request)["marginMode"] = marginMode;
        parameters = this.omit(parameters, new List<object>() {"stopLossPrice", "takeProfitPrice"});
        return this.extend(request, parameters);
    }

    /**
     * @method
     * @name blofin#cancelOrder
     * @description cancels an open order
     * @see https://blofin.com/docs#cancel-order
     * @see https://blofin.com/docs#cancel-tpsl-order
     * @param {string} id order id
     * @param {string} symbol unified symbol of the market the order was made in
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {boolean} [params.trigger] True if cancelling a trigger/conditional order/tp sl orders
     * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> cancelOrder(object id, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " cancelOrder() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "instId", getValue(market, "id") },
        };
        object isTrigger = this.safeBoolN(parameters, new List<object>() {"stop", "trigger", "tpsl"}, false);
        object clientOrderId = this.safeString(parameters, "clientOrderId");
        if (isTrue(!isEqual(clientOrderId, null)))
        {
            ((IDictionary<string,object>)request)["clientOrderId"] = clientOrderId;
        } else
        {
            if (!isTrue(isTrigger))
            {
                ((IDictionary<string,object>)request)["orderId"] = ((object)id).ToString();
            } else
            {
                ((IDictionary<string,object>)request)["tpslId"] = ((object)id).ToString();
            }
        }
        object query = this.omit(parameters, new List<object>() {"orderId", "clientOrderId", "stop", "trigger", "tpsl"});
        if (isTrue(isTrigger))
        {
            object tpslResponse = await this.cancelOrders(new List<object>() {id}, symbol, parameters);
            object first = this.safeDict(tpslResponse, 0);
            return first;
        }
        object response = await this.privatePostTradeCancelOrder(this.extend(request, query));
        object data = this.safeList(response, "data", new List<object>() {});
        object order = this.safeDict(data, 0);
        return this.parseOrder(order, market);
    }

    /**
     * @method
     * @name blofin#createOrders
     * @description create a list of trade orders
     * @see https://blofin.com/docs#place-multiple-orders
     * @param {Array} orders list of orders to create, each object should contain the parameters required by createOrder, namely symbol, type, side, amount, price and params
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> createOrders(object orders, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object ordersRequests = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(orders)); postFixIncrement(ref i))
        {
            object rawOrder = getValue(orders, i);
            object marketId = this.safeString(rawOrder, "symbol");
            object type = this.safeString(rawOrder, "type");
            object side = this.safeString(rawOrder, "side");
            object amount = this.safeValue(rawOrder, "amount");
            object price = this.safeValue(rawOrder, "price");
            object orderParams = this.safeDict(rawOrder, "params", new Dictionary<string, object>() {});
            object extendedParams = this.extend(orderParams, parameters); // the request does not accept extra params since it's a list, so we're extending each order with the common params
            object orderRequest = this.createOrderRequest(marketId, type, side, amount, price, extendedParams);
            ((IList<object>)ordersRequests).Add(orderRequest);
        }
        object response = await this.privatePostTradeBatchOrders(ordersRequests);
        object data = this.safeList(response, "data", new List<object>() {});
        return this.parseOrders(data);
    }

    /**
     * @method
     * @name blofin#fetchOpenOrders
     * @description Fetch orders that are still open
     * @see https://blofin.com/docs#get-active-orders
     * @see https://blofin.com/docs#get-active-tpsl-orders
     * @param {string} symbol unified market symbol
     * @param {int} [since] the earliest time in ms to fetch open orders for
     * @param {int} [limit] the maximum number of  open orders structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {bool} [params.trigger] True if fetching trigger or conditional orders
     * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [availble parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
     * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> fetchOpenOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object paginate = false;
        var paginateparametersVariable = this.handleOptionAndParams(parameters, "fetchOpenOrders", "paginate");
        paginate = ((IList<object>)paginateparametersVariable)[0];
        parameters = ((IList<object>)paginateparametersVariable)[1];
        if (isTrue(paginate))
        {
            return await this.fetchPaginatedCallDynamic("fetchOpenOrders", symbol, since, limit, parameters);
        }
        object request = new Dictionary<string, object>() {};
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            ((IDictionary<string,object>)request)["instId"] = getValue(market, "id");
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit; // default 100, max 100
        }
        object isTrigger = this.safeBoolN(parameters, new List<object>() {"stop", "trigger", "tpsl", "TPSL"}, false);
        object method = null;
        var methodparametersVariable = this.handleOptionAndParams(parameters, "fetchOpenOrders", "method", "privateGetTradeOrdersPending");
        method = ((IList<object>)methodparametersVariable)[0];
        parameters = ((IList<object>)methodparametersVariable)[1];
        object query = this.omit(parameters, new List<object>() {"method", "stop", "trigger", "tpsl", "TPSL"});
        object response = null;
        if (isTrue(isTrue(isTrigger) || isTrue((isEqual(method, "privateGetTradeOrdersTpslPending")))))
        {
            response = await this.privateGetTradeOrdersTpslPending(this.extend(request, query));
        } else
        {
            response = await this.privateGetTradeOrdersPending(this.extend(request, query));
        }
        object data = this.safeList(response, "data", new List<object>() {});
        return this.parseOrders(data, market, since, limit);
    }

    /**
     * @method
     * @name blofin#fetchMyTrades
     * @description fetch all trades made by the user
     * @see https://blofin.com/docs#get-trade-history
     * @param {string} symbol unified market symbol
     * @param {int} [since] the earliest time in ms to fetch trades for
     * @param {int} [limit] the maximum number of trades structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {int} [params.until] Timestamp in ms of the latest time to retrieve trades for
     * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [availble parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
     * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
     */
    public async override Task<object> fetchMyTrades(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object paginate = false;
        var paginateparametersVariable = this.handleOptionAndParams(parameters, "fetchMyTrades", "paginate");
        paginate = ((IList<object>)paginateparametersVariable)[0];
        parameters = ((IList<object>)paginateparametersVariable)[1];
        if (isTrue(paginate))
        {
            return await this.fetchPaginatedCallDynamic("fetchMyTrades", symbol, since, limit, parameters);
        }
        object request = new Dictionary<string, object>() {};
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            ((IDictionary<string,object>)request)["instId"] = getValue(market, "id");
        }
        var requestparametersVariable = this.handleUntilOption("end", request, parameters);
        request = ((IList<object>)requestparametersVariable)[0];
        parameters = ((IList<object>)requestparametersVariable)[1];
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit; // default 100, max 100
        }
        object response = await this.privateGetTradeFillsHistory(this.extend(request, parameters));
        object data = this.safeList(response, "data", new List<object>() {});
        return this.parseTrades(data, market, since, limit);
    }

    /**
     * @method
     * @name blofin#fetchDeposits
     * @description fetch all deposits made to an account
     * @see https://blofin.com/docs#get-deposite-history
     * @param {string} code unified currency code
     * @param {int} [since] the earliest time in ms to fetch deposits for
     * @param {int} [limit] the maximum number of deposits structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {int} [params.until] the latest time in ms to fetch entries for
     * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [availble parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
     * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
     */
    public async override Task<object> fetchDeposits(object code = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object paginate = false;
        var paginateparametersVariable = this.handleOptionAndParams(parameters, "fetchDeposits", "paginate");
        paginate = ((IList<object>)paginateparametersVariable)[0];
        parameters = ((IList<object>)paginateparametersVariable)[1];
        if (isTrue(paginate))
        {
            return await this.fetchPaginatedCallDynamic("fetchDeposits", code, since, limit, parameters);
        }
        object request = new Dictionary<string, object>() {};
        object currency = null;
        if (isTrue(!isEqual(code, null)))
        {
            currency = this.currency(code);
            ((IDictionary<string,object>)request)["currency"] = getValue(currency, "id");
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["before"] = mathMax(subtract(since, 1), 0);
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit; // default 100, max 100
        }
        var requestparametersVariable = this.handleUntilOption("after", request, parameters);
        request = ((IList<object>)requestparametersVariable)[0];
        parameters = ((IList<object>)requestparametersVariable)[1];
        object response = await this.privateGetAssetDepositHistory(this.extend(request, parameters));
        object data = this.safeList(response, "data", new List<object>() {});
        return this.parseTransactions(data, currency, since, limit, parameters);
    }

    /**
     * @method
     * @name blofin#fetchWithdrawals
     * @description fetch all withdrawals made from an account
     * @see https://blofin.com/docs#get-withdraw-history
     * @param {string} code unified currency code
     * @param {int} [since] the earliest time in ms to fetch withdrawals for
     * @param {int} [limit] the maximum number of withdrawals structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {int} [params.until] the latest time in ms to fetch entries for
     * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [availble parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
     * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
     */
    public async override Task<object> fetchWithdrawals(object code = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object paginate = false;
        var paginateparametersVariable = this.handleOptionAndParams(parameters, "fetchWithdrawals", "paginate");
        paginate = ((IList<object>)paginateparametersVariable)[0];
        parameters = ((IList<object>)paginateparametersVariable)[1];
        if (isTrue(paginate))
        {
            return await this.fetchPaginatedCallDynamic("fetchWithdrawals", code, since, limit, parameters);
        }
        object request = new Dictionary<string, object>() {};
        object currency = null;
        if (isTrue(!isEqual(code, null)))
        {
            currency = this.currency(code);
            ((IDictionary<string,object>)request)["currency"] = getValue(currency, "id");
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["before"] = mathMax(subtract(since, 1), 0);
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit; // default 100, max 100
        }
        var requestparametersVariable = this.handleUntilOption("after", request, parameters);
        request = ((IList<object>)requestparametersVariable)[0];
        parameters = ((IList<object>)requestparametersVariable)[1];
        object response = await this.privateGetAssetWithdrawalHistory(this.extend(request, parameters));
        object data = this.safeList(response, "data", new List<object>() {});
        return this.parseTransactions(data, currency, since, limit, parameters);
    }

    /**
     * @method
     * @name blofin#fetchLedger
     * @description fetch the history of changes, actions done by the user or operations that altered the balance of the user
     * @see https://blofin.com/docs#get-funds-transfer-history
     * @param {string} [code] unified currency code, default is undefined
     * @param {int} [since] timestamp in ms of the earliest ledger entry, default is undefined
     * @param {int} [limit] max number of ledger entries to return, default is undefined
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.marginMode] 'cross' or 'isolated'
     * @param {int} [params.until] the latest time in ms to fetch entries for
     * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [available parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
     * @returns {object} a [ledger structure]{@link https://docs.ccxt.com/#/?id=ledger}
     */
    public async override Task<object> fetchLedger(object code = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object paginate = false;
        var paginateparametersVariable = this.handleOptionAndParams(parameters, "fetchLedger", "paginate");
        paginate = ((IList<object>)paginateparametersVariable)[0];
        parameters = ((IList<object>)paginateparametersVariable)[1];
        if (isTrue(paginate))
        {
            return await this.fetchPaginatedCallDynamic("fetchLedger", code, since, limit, parameters);
        }
        object request = new Dictionary<string, object>() {};
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        object currency = null;
        if (isTrue(!isEqual(code, null)))
        {
            currency = this.currency(code);
            ((IDictionary<string,object>)request)["currency"] = getValue(currency, "id");
        }
        var requestparametersVariable = this.handleUntilOption("end", request, parameters);
        request = ((IList<object>)requestparametersVariable)[0];
        parameters = ((IList<object>)requestparametersVariable)[1];
        object response = null;
        response = await this.privateGetAssetBills(this.extend(request, parameters));
        object data = this.safeList(response, "data", new List<object>() {});
        return this.parseLedger(data, currency, since, limit);
    }

    public override object parseTransaction(object transaction, object currency = null)
    {
        //
        //
        // fetchDeposits
        //
        //     {
        //         "currency": "USDT",
        //         "chain": "TRC20",
        //         "address": "TGfJLtnsh3B9EqekFEBZ1nR14QanBUf5Bi",
        //         "txId": "892f4e0c32268b29b2e541ef30d32a30bbf10f902adcc4b1428319ed7c3758fd",
        //         "type": "0",
        //         "amount": "86.975843",
        //         "state": "1",
        //         "ts": "1703163304153",
        //         "tag": null,
        //         "confirm": "16",
        //         "depositId": "36c8e2a7ea184a219de72215a696acaf"
        //     }
        // fetchWithdrawals
        //    {
        //       "currency": "USDT",
        //        "chain": "TRC20",
        //        "address": "TYgB3sVXHPEDQUu288EG1uMFh9Pk2swLgW",
        //        "txId": "1fd5ac52df414d7ea66194cadd9a5b4d2422c2b9720037f66d98207f9858fd96",
        //        "type": "0",
        //        "amount": "9",
        //        "fee": "1",
        //        "feeCurrency": "USDT",
        //        "state": "3",
        //        "clientId": null,
        //        "ts": "1707217439351",
        //        "tag": null,
        //        "memo": null,
        //        "withdrawId": "e0768698cfdf4aee8e54654c3775914b"
        //    }
        //
        object type = null;
        object id = null;
        object withdrawalId = this.safeString(transaction, "withdrawId");
        object depositId = this.safeString(transaction, "depositId");
        object addressTo = this.safeString(transaction, "address");
        object address = addressTo;
        object tagTo = this.safeString(transaction, "tag");
        if (isTrue(!isEqual(withdrawalId, null)))
        {
            type = "withdrawal";
            id = withdrawalId;
        } else
        {
            id = depositId;
            type = "deposit";
        }
        object currencyId = this.safeString(transaction, "currency");
        object code = this.safeCurrencyCode(currencyId);
        object amount = this.safeNumber(transaction, "amount");
        object status = this.parseTransactionStatus(this.safeString(transaction, "state"));
        object txid = this.safeString(transaction, "txId");
        object timestamp = this.safeInteger(transaction, "ts");
        object feeCurrencyId = this.safeString(transaction, "feeCurrency");
        object feeCode = this.safeCurrencyCode(feeCurrencyId);
        object feeCost = this.safeNumber(transaction, "fee");
        return new Dictionary<string, object>() {
            { "info", transaction },
            { "id", id },
            { "currency", code },
            { "amount", amount },
            { "network", null },
            { "addressFrom", null },
            { "addressTo", addressTo },
            { "address", address },
            { "tagFrom", null },
            { "tagTo", tagTo },
            { "tag", tagTo },
            { "status", status },
            { "type", type },
            { "updated", null },
            { "txid", txid },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "internal", null },
            { "comment", null },
            { "fee", new Dictionary<string, object>() {
                { "currency", feeCode },
                { "cost", feeCost },
            } },
        };
    }

    public virtual object parseTransactionStatus(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "0", "pending" },
            { "1", "ok" },
            { "2", "failed" },
            { "3", "pending" },
        };
        return this.safeString(statuses, status, status);
    }

    public virtual object parseLedgerEntryType(object type)
    {
        object types = new Dictionary<string, object>() {
            { "1", "transfer" },
            { "2", "trade" },
            { "3", "trade" },
            { "4", "rebate" },
            { "5", "trade" },
            { "6", "transfer" },
            { "7", "trade" },
            { "8", "fee" },
            { "9", "trade" },
            { "10", "trade" },
            { "11", "trade" },
        };
        return this.safeString(types, type, type);
    }

    public override object parseLedgerEntry(object item, object currency = null)
    {
        object currencyId = this.safeString(item, "currency");
        object code = this.safeCurrencyCode(currencyId, currency);
        currency = this.safeCurrency(currencyId, currency);
        object timestamp = this.safeInteger(item, "ts");
        return this.safeLedgerEntry(new Dictionary<string, object>() {
            { "info", item },
            { "id", this.safeString(item, "transferId") },
            { "direction", null },
            { "account", null },
            { "referenceId", this.safeString(item, "clientId") },
            { "referenceAccount", null },
            { "type", this.parseLedgerEntryType(this.safeString(item, "type")) },
            { "currency", code },
            { "amount", this.safeNumber(item, "amount") },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "before", null },
            { "after", null },
            { "status", "ok" },
            { "fee", null },
        }, currency);
    }

    public virtual object parseIds(object ids)
    {
        /**
         * @ignore
         * @method
         * @name blofin#parseIds
         * @param {string[]|string} ids order ids
         * @returns {string[]} list of order ids
         */
        if (isTrue((ids is string)))
        {
            return ((string)ids).Split(new [] {((string)",")}, StringSplitOptions.None).ToList<object>();
        } else
        {
            return ids;
        }
    }

    /**
     * @method
     * @name blofin#cancelOrders
     * @description cancel multiple orders
     * @see https://blofin.com/docs#cancel-multiple-orders
     * @param {string[]} ids order ids
     * @param {string} symbol unified market symbol
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {boolean} [params.trigger] whether the order is a stop/trigger order
     * @returns {object} an list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async virtual Task<object> cancelOrders(object ids, object symbol = null, object parameters = null)
    {
        // TODO : the original endpoint signature differs, according to that you can skip individual symbol and assign ids in batch. At this moment, `params` is not being used too.
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " cancelOrders() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new List<object>() {};
        object options = this.safeDict(this.options, "cancelOrders", new Dictionary<string, object>() {});
        object defaultMethod = this.safeString(options, "method", "privatePostTradeCancelBatchOrders");
        object method = this.safeString(parameters, "method", defaultMethod);
        object clientOrderIds = this.parseIds(this.safeValue(parameters, "clientOrderId"));
        object tpslIds = this.parseIds(this.safeValue(parameters, "tpslId"));
        object trigger = this.safeBoolN(parameters, new List<object>() {"stop", "trigger", "tpsl"});
        if (isTrue(trigger))
        {
            method = "privatePostTradeCancelTpsl";
        }
        if (isTrue(isEqual(clientOrderIds, null)))
        {
            ids = this.parseIds(ids);
            if (isTrue(!isEqual(tpslIds, null)))
            {
                for (object i = 0; isLessThan(i, getArrayLength(tpslIds)); postFixIncrement(ref i))
                {
                    ((IList<object>)request).Add(new Dictionary<string, object>() {
                        { "tpslId", getValue(tpslIds, i) },
                        { "instId", getValue(market, "id") },
                    });
                }
            }
            for (object i = 0; isLessThan(i, getArrayLength(ids)); postFixIncrement(ref i))
            {
                if (isTrue(trigger))
                {
                    ((IList<object>)request).Add(new Dictionary<string, object>() {
                        { "tpslId", getValue(ids, i) },
                        { "instId", getValue(market, "id") },
                    });
                } else
                {
                    ((IList<object>)request).Add(new Dictionary<string, object>() {
                        { "orderId", getValue(ids, i) },
                        { "instId", getValue(market, "id") },
                    });
                }
            }
        } else
        {
            for (object i = 0; isLessThan(i, getArrayLength(clientOrderIds)); postFixIncrement(ref i))
            {
                ((IList<object>)request).Add(new Dictionary<string, object>() {
                    { "instId", getValue(market, "id") },
                    { "clientOrderId", getValue(clientOrderIds, i) },
                });
            }
        }
        object response = null;
        if (isTrue(isEqual(method, "privatePostTradeCancelTpsl")))
        {
            response = await this.privatePostTradeCancelTpsl(request); // * dont extend with params, otherwise ARRAY will be turned into OBJECT
        } else
        {
            response = await this.privatePostTradeCancelBatchOrders(request); // * dont extend with params, otherwise ARRAY will be turned into OBJECT
        }
        object ordersData = this.safeList(response, "data", new List<object>() {});
        return this.parseOrders(ordersData, market, null, null, parameters);
    }

    /**
     * @method
     * @name blofin#transfer
     * @description transfer currency internally between wallets on the same account
     * @see https://blofin.com/docs#funds-transfer
     * @param {string} code unified currency code
     * @param {float} amount amount to transfer
     * @param {string} fromAccount account to transfer from (funding, swap, copy_trading, earn)
     * @param {string} toAccount account to transfer to (funding, swap, copy_trading, earn)
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [transfer structure]{@link https://docs.ccxt.com/#/?id=transfer-structure}
     */
    public async override Task<object> transfer(object code, object amount, object fromAccount, object toAccount, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        object accountsByType = this.safeDict(this.options, "accountsByType", new Dictionary<string, object>() {});
        object fromId = this.safeString(accountsByType, fromAccount, fromAccount);
        object toId = this.safeString(accountsByType, toAccount, toAccount);
        object request = new Dictionary<string, object>() {
            { "currency", getValue(currency, "id") },
            { "amount", this.currencyToPrecision(code, amount) },
            { "fromAccount", fromId },
            { "toAccount", toId },
        };
        object response = await this.privatePostAssetTransfer(this.extend(request, parameters));
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        return this.parseTransfer(data, currency);
    }

    public override object parseTransfer(object transfer, object currency = null)
    {
        object id = this.safeString(transfer, "transferId");
        return new Dictionary<string, object>() {
            { "info", transfer },
            { "id", id },
            { "timestamp", null },
            { "datetime", null },
            { "currency", null },
            { "amount", null },
            { "fromAccount", null },
            { "toAccount", null },
            { "status", null },
        };
    }

    /**
     * @method
     * @name blofin#fetchPosition
     * @description fetch data on a single open contract trade position
     * @see https://blofin.com/docs#get-positions
     * @param {string} symbol unified market symbol of the market the position is held in, default is undefined
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.instType] MARGIN, SWAP, FUTURES, OPTION
     * @returns {object} a [position structure]{@link https://docs.ccxt.com/#/?id=position-structure}
     */
    public async override Task<object> fetchPosition(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "instId", getValue(market, "id") },
        };
        object response = await this.privateGetAccountPositions(this.extend(request, parameters));
        object data = this.safeList(response, "data", new List<object>() {});
        object position = this.safeDict(data, 0);
        if (isTrue(isEqual(position, null)))
        {
            return null;
        }
        return this.parsePosition(position, market);
    }

    /**
     * @method
     * @name blofin#fetchPosition
     * @description fetch data on a single open contract trade position
     * @see https://blofin.com/docs#get-positions
     * @param {string[]} [symbols] list of unified market symbols
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.instType] MARGIN, SWAP, FUTURES, OPTION
     * @returns {object} a [position structure]{@link https://docs.ccxt.com/#/?id=position-structure}
     */
    public async override Task<object> fetchPositions(object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        symbols = this.marketSymbols(symbols);
        object response = await this.privateGetAccountPositions(parameters);
        object data = this.safeList(response, "data", new List<object>() {});
        object result = this.parsePositions(data);
        return this.filterByArrayPositions(result, "symbol", symbols, false);
    }

    public override object parsePosition(object position, object market = null)
    {
        //
        // response similar for REST & WS
        //
        //     {
        //         instType: 'SWAP',
        //         instId: 'LTC-USDT',
        //         marginMode: 'cross',
        //         positionId: '644159',
        //         positionSide: 'net',
        //         positions: '1',
        //         availablePositions: '1',
        //         averagePrice: '68.16',
        //         unrealizedPnl: '0.80631223',
        //         unrealizedPnlRatio: '0.03548909463028169',
        //         leverage: '3',
        //         liquidationPrice: '10.116655172370356435',
        //         markPrice: '68.96',
        //         initialMargin: '22.988770743333333333',
        //         margin: '', // this field might not exist in rest response
        //         marginRatio: '152.523509620342499273',
        //         maintenanceMargin: '0.34483156115',
        //         adl: '4',
        //         createTime: '1707235776528',
        //         updateTime: '1707235776528'
        //     }
        //
        object marketId = this.safeString(position, "instId");
        market = this.safeMarket(marketId, market);
        object symbol = getValue(market, "symbol");
        object pos = this.safeString(position, "positions");
        object contractsAbs = Precise.stringAbs(pos);
        object side = this.safeString(position, "positionSide");
        object hedged = !isEqual(side, "net");
        object contracts = this.parseNumber(contractsAbs);
        if (isTrue(!isEqual(pos, null)))
        {
            if (isTrue(isEqual(side, "net")))
            {
                if (isTrue(Precise.stringGt(pos, "0")))
                {
                    side = "long";
                } else if (isTrue(Precise.stringLt(pos, "0")))
                {
                    side = "short";
                } else
                {
                    side = null;
                }
            }
        }
        object contractSize = this.safeNumber(market, "contractSize");
        object contractSizeString = this.numberToString(contractSize);
        object markPriceString = this.safeString(position, "markPrice");
        object notionalString = this.safeString(position, "notionalUsd");
        if (isTrue(getValue(market, "inverse")))
        {
            notionalString = Precise.stringDiv(Precise.stringMul(contractsAbs, contractSizeString), markPriceString);
        }
        object notional = this.parseNumber(notionalString);
        object marginMode = this.safeString(position, "marginMode");
        object initialMarginString = null;
        object entryPriceString = this.safeString(position, "averagePrice");
        object unrealizedPnlString = this.safeString(position, "unrealizedPnl");
        object leverageString = this.safeString(position, "leverage");
        object initialMarginPercentage = null;
        object collateralString = null;
        if (isTrue(isEqual(marginMode, "cross")))
        {
            initialMarginString = this.safeString(position, "initialMargin");
            collateralString = Precise.stringAdd(initialMarginString, unrealizedPnlString);
        } else if (isTrue(isEqual(marginMode, "isolated")))
        {
            initialMarginPercentage = Precise.stringDiv("1", leverageString);
            collateralString = this.safeString(position, "margin");
        }
        object maintenanceMarginString = this.safeString(position, "maintenanceMargin");
        object maintenanceMargin = this.parseNumber(maintenanceMarginString);
        object maintenanceMarginPercentageString = Precise.stringDiv(maintenanceMarginString, notionalString);
        if (isTrue(isEqual(initialMarginPercentage, null)))
        {
            initialMarginPercentage = this.parseNumber(Precise.stringDiv(initialMarginString, notionalString, 4));
        } else if (isTrue(isEqual(initialMarginString, null)))
        {
            initialMarginString = Precise.stringMul(initialMarginPercentage, notionalString);
        }
        object rounder = "0.00005"; // round to closest 0.01%
        object maintenanceMarginPercentage = this.parseNumber(Precise.stringDiv(Precise.stringAdd(maintenanceMarginPercentageString, rounder), "1", 4));
        object liquidationPrice = this.safeNumber(position, "liquidationPrice");
        object percentageString = this.safeString(position, "unrealizedPnlRatio");
        object percentage = this.parseNumber(Precise.stringMul(percentageString, "100"));
        object timestamp = this.safeInteger(position, "updateTime");
        object marginRatio = this.parseNumber(Precise.stringDiv(maintenanceMarginString, collateralString, 4));
        return this.safePosition(new Dictionary<string, object>() {
            { "info", position },
            { "id", null },
            { "symbol", symbol },
            { "notional", notional },
            { "marginMode", marginMode },
            { "liquidationPrice", liquidationPrice },
            { "entryPrice", this.parseNumber(entryPriceString) },
            { "unrealizedPnl", this.parseNumber(unrealizedPnlString) },
            { "percentage", percentage },
            { "contracts", contracts },
            { "contractSize", contractSize },
            { "markPrice", this.parseNumber(markPriceString) },
            { "lastPrice", null },
            { "side", side },
            { "hedged", hedged },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "lastUpdateTimestamp", null },
            { "maintenanceMargin", maintenanceMargin },
            { "maintenanceMarginPercentage", maintenanceMarginPercentage },
            { "collateral", this.parseNumber(collateralString) },
            { "initialMargin", this.parseNumber(initialMarginString) },
            { "initialMarginPercentage", this.parseNumber(initialMarginPercentage) },
            { "leverage", this.parseNumber(leverageString) },
            { "marginRatio", marginRatio },
            { "stopLossPrice", null },
            { "takeProfitPrice", null },
        });
    }

    /**
     * @method
     * @name blofin#fetchLeverages
     * @description fetch the set leverage for all contract markets
     * @see https://docs.blofin.com/index.html#get-multiple-leverage
     * @param {string[]} symbols a list of unified market symbols, required on blofin
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.marginMode] 'cross' or 'isolated'
     * @returns {object} a list of [leverage structures]{@link https://docs.ccxt.com/#/?id=leverage-structure}
     */
    public async override Task<object> fetchLeverages(object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        if (isTrue(isEqual(symbols, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchLeverages() requires a symbols argument")) ;
        }
        object marginMode = null;
        var marginModeparametersVariable = this.handleMarginModeAndParams("fetchLeverages", parameters);
        marginMode = ((IList<object>)marginModeparametersVariable)[0];
        parameters = ((IList<object>)marginModeparametersVariable)[1];
        if (isTrue(isEqual(marginMode, null)))
        {
            marginMode = this.safeString(parameters, "marginMode", "cross"); // cross as default marginMode
        }
        if (isTrue(isTrue((!isEqual(marginMode, "cross"))) && isTrue((!isEqual(marginMode, "isolated")))))
        {
            throw new BadRequest ((string)add(this.id, " fetchLeverages() requires a marginMode parameter that must be either cross or isolated")) ;
        }
        symbols = this.marketSymbols(symbols);
        object instIds = "";
        for (object i = 0; isLessThan(i, getArrayLength(symbols)); postFixIncrement(ref i))
        {
            object entry = getValue(symbols, i);
            object entryMarket = this.market(entry);
            if (isTrue(isGreaterThan(i, 0)))
            {
                instIds = add(add(instIds, ","), getValue(entryMarket, "id"));
            } else
            {
                instIds = add(instIds, getValue(entryMarket, "id"));
            }
        }
        object request = new Dictionary<string, object>() {
            { "instId", instIds },
            { "marginMode", marginMode },
        };
        object response = await this.privateGetAccountBatchLeverageInfo(this.extend(request, parameters));
        //
        //     {
        //         "code": "0",
        //         "msg": "success",
        //         "data": [
        //             {
        //                 "leverage": "3",
        //                 "marginMode": "cross",
        //                 "instId": "BTC-USDT"
        //             },
        //         ]
        //     }
        //
        object leverages = this.safeList(response, "data", new List<object>() {});
        return this.parseLeverages(leverages, symbols, "instId");
    }

    /**
     * @method
     * @name blofin#fetchLeverage
     * @description fetch the set leverage for a market
     * @see https://docs.blofin.com/index.html#get-leverage
     * @param {string} symbol unified market symbol
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.marginMode] 'cross' or 'isolated'
     * @returns {object} a [leverage structure]{@link https://docs.ccxt.com/#/?id=leverage-structure}
     */
    public async override Task<object> fetchLeverage(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object marginMode = null;
        var marginModeparametersVariable = this.handleMarginModeAndParams("fetchLeverage", parameters);
        marginMode = ((IList<object>)marginModeparametersVariable)[0];
        parameters = ((IList<object>)marginModeparametersVariable)[1];
        if (isTrue(isEqual(marginMode, null)))
        {
            marginMode = this.safeString(parameters, "marginMode", "cross"); // cross as default marginMode
        }
        if (isTrue(isTrue((!isEqual(marginMode, "cross"))) && isTrue((!isEqual(marginMode, "isolated")))))
        {
            throw new BadRequest ((string)add(this.id, " fetchLeverage() requires a marginMode parameter that must be either cross or isolated")) ;
        }
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "instId", getValue(market, "id") },
            { "marginMode", marginMode },
        };
        object response = await this.privateGetAccountLeverageInfo(this.extend(request, parameters));
        //
        //     {
        //         "code": "0",
        //         "msg": "success",
        //         "data": {
        //             "leverage": "3",
        //             "marginMode": "cross",
        //             "instId": "BTC-USDT"
        //         }
        //     }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        return this.parseLeverage(data, market);
    }

    public override object parseLeverage(object leverage, object market = null)
    {
        object marketId = this.safeString(leverage, "instId");
        object leverageValue = this.safeInteger(leverage, "leverage");
        return new Dictionary<string, object>() {
            { "info", leverage },
            { "symbol", this.safeSymbol(marketId, market) },
            { "marginMode", this.safeStringLower(leverage, "marginMode") },
            { "longLeverage", leverageValue },
            { "shortLeverage", leverageValue },
        };
    }

    /**
     * @method
     * @name blofin#setLeverage
     * @description set the level of leverage for a market
     * @see https://blofin.com/docs#set-leverage
     * @param {int} leverage the rate of leverage
     * @param {string} symbol unified market symbol
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.marginMode] 'cross' or 'isolated'
     * @returns {object} response from the exchange
     */
    public async override Task<object> setLeverage(object leverage, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " setLeverage() requires a symbol argument")) ;
        }
        // WARNING: THIS WILL INCREASE LIQUIDATION PRICE FOR OPEN ISOLATED LONG POSITIONS
        // AND DECREASE LIQUIDATION PRICE FOR OPEN ISOLATED SHORT POSITIONS
        if (isTrue(isTrue((isLessThan(leverage, 1))) || isTrue((isGreaterThan(leverage, 125)))))
        {
            throw new BadRequest ((string)add(this.id, " setLeverage() leverage should be between 1 and 125")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object marginMode = null;
        var marginModeparametersVariable = this.handleMarginModeAndParams("setLeverage", parameters, "cross");
        marginMode = ((IList<object>)marginModeparametersVariable)[0];
        parameters = ((IList<object>)marginModeparametersVariable)[1];
        if (isTrue(isTrue((!isEqual(marginMode, "cross"))) && isTrue((!isEqual(marginMode, "isolated")))))
        {
            throw new BadRequest ((string)add(this.id, " setLeverage() requires a marginMode parameter that must be either cross or isolated")) ;
        }
        object request = new Dictionary<string, object>() {
            { "leverage", leverage },
            { "marginMode", marginMode },
            { "instId", getValue(market, "id") },
        };
        object response = await this.privatePostAccountSetLeverage(this.extend(request, parameters));
        return response;
    }

    /**
     * @method
     * @name blofin#closePosition
     * @description closes open positions for a market
     * @see https://blofin.com/docs#close-positions
     * @param {string} symbol Unified CCXT market symbol
     * @param {string} [side] 'buy' or 'sell', leave as undefined in net mode
     * @param {object} [params] extra parameters specific to the blofin api endpoint
     * @param {string} [params.clientOrderId] a unique identifier for the order
     * @param {string} [params.marginMode] 'cross' or 'isolated', default is 'cross;
     * @param {string} [params.code] *required in the case of closing cross MARGIN position for Single-currency margin* margin currency
     *
     * EXCHANGE SPECIFIC PARAMETERS
     * @param {boolean} [params.autoCxl] whether any pending orders for closing out needs to be automatically canceled when close position via a market order. false or true, the default is false
     * @param {string} [params.tag] order tag a combination of case-sensitive alphanumerics, all numbers, or all letters of up to 16 characters
     * @returns {object[]} [A list of position structures]{@link https://docs.ccxt.com/#/?id=position-structure}
     */
    public async override Task<object> closePosition(object symbol, object side = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object clientOrderId = this.safeString(parameters, "clientOrderId");
        object marginMode = null;
        var marginModeparametersVariable = this.handleMarginModeAndParams("closePosition", parameters, "cross");
        marginMode = ((IList<object>)marginModeparametersVariable)[0];
        parameters = ((IList<object>)marginModeparametersVariable)[1];
        object request = new Dictionary<string, object>() {
            { "instId", getValue(market, "id") },
            { "marginMode", marginMode },
        };
        if (isTrue(!isEqual(clientOrderId, null)))
        {
            ((IDictionary<string,object>)request)["clientOrderId"] = clientOrderId;
        }
        object response = await this.privatePostTradeClosePosition(this.extend(request, parameters));
        return this.safeDict(response, "data");
    }

    /**
     * @method
     * @name blofin#fetchClosedOrders
     * @description fetches information on multiple closed orders made by the user
     * @see https://blofin.com/docs#get-order-history
     * @see https://blofin.com/docs#get-tpsl-order-history
     * @param {string} symbol unified market symbol of the market orders were made in
     * @param {int} [since] the earliest time in ms to fetch orders for
     * @param {int} [limit] the maximum number of  orde structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {bool} [params.trigger] True if fetching trigger or conditional orders
     * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [availble parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
     * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> fetchClosedOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object paginate = false;
        var paginateparametersVariable = this.handleOptionAndParams(parameters, "fetchClosedOrders", "paginate");
        paginate = ((IList<object>)paginateparametersVariable)[0];
        parameters = ((IList<object>)paginateparametersVariable)[1];
        if (isTrue(paginate))
        {
            return await this.fetchPaginatedCallDynamic("fetchClosedOrders", symbol, since, limit, parameters);
        }
        object request = new Dictionary<string, object>() {};
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            ((IDictionary<string,object>)request)["instId"] = getValue(market, "id");
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit; // default 100, max 100
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["begin"] = since;
        }
        object isTrigger = this.safeBoolN(parameters, new List<object>() {"stop", "trigger", "tpsl", "TPSL"}, false);
        object method = null;
        var methodparametersVariable = this.handleOptionAndParams(parameters, "fetchOpenOrders", "method", "privateGetTradeOrdersHistory");
        method = ((IList<object>)methodparametersVariable)[0];
        parameters = ((IList<object>)methodparametersVariable)[1];
        object query = this.omit(parameters, new List<object>() {"method", "stop", "trigger", "tpsl", "TPSL"});
        object response = null;
        if (isTrue(isTrue((isTrigger)) || isTrue((isEqual(method, "privateGetTradeOrdersTpslHistory")))))
        {
            response = await this.privateGetTradeOrdersTpslHistory(this.extend(request, query));
        } else
        {
            response = await this.privateGetTradeOrdersHistory(this.extend(request, query));
        }
        object data = this.safeList(response, "data", new List<object>() {});
        return this.parseOrders(data, market, since, limit);
    }

    /**
     * @method
     * @name blofin#fetchMarginMode
     * @description fetches the margin mode of a trading pair
     * @see https://docs.blofin.com/index.html#get-margin-mode
     * @param {string} symbol unified symbol of the market to fetch the margin mode for
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [margin mode structure]{@link https://docs.ccxt.com/#/?id=margin-mode-structure}
     */
    public async override Task<object> fetchMarginMode(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object response = await this.privateGetAccountMarginMode(parameters);
        //
        //     {
        //         "code": "0",
        //         "msg": "success",
        //         "data": {
        //             "marginMode": "cross"
        //         }
        //     }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        return this.parseMarginMode(data, market);
    }

    public override object parseMarginMode(object marginMode, object market = null)
    {
        return new Dictionary<string, object>() {
            { "info", marginMode },
            { "symbol", getValue(market, "symbol") },
            { "marginMode", this.safeString(marginMode, "marginMode") },
        };
    }

    public override object handleErrors(object httpCode, object reason, object url, object method, object headers, object body, object response, object requestHeaders, object requestBody)
    {
        if (isTrue(isEqual(response, null)))
        {
            return null;  // fallback to default error handler
        }
        //
        // {"code":"152002","msg":"Parameter bar error."}
        //
        object code = this.safeString(response, "code");
        object message = this.safeString(response, "msg");
        object feedback = add(add(this.id, " "), body);
        if (isTrue(isTrue(!isEqual(code, null)) && isTrue(!isEqual(code, "0"))))
        {
            this.throwExactlyMatchedException(getValue(this.exceptions, "exact"), message, feedback);
            this.throwExactlyMatchedException(getValue(this.exceptions, "exact"), code, feedback);
            this.throwBroadlyMatchedException(getValue(this.exceptions, "broad"), message, feedback);
            throw new ExchangeError ((string)feedback) ;
        }
        //
        //  {
        //      orderId: null,
        //      clientOrderId: '',
        //      msg: 'Order failed. Insufficient USDT margin in account',
        //      code: '103003'
        //  }
        //
        object data = this.safeList(response, "data");
        object first = this.safeDict(data, 0);
        object insideMsg = this.safeString(first, "msg");
        object insideCode = this.safeString(first, "code");
        if (isTrue(isTrue(!isEqual(insideCode, null)) && isTrue(!isEqual(insideCode, "0"))))
        {
            this.throwExactlyMatchedException(getValue(this.exceptions, "exact"), insideCode, feedback);
            this.throwExactlyMatchedException(getValue(this.exceptions, "exact"), insideMsg, feedback);
            this.throwBroadlyMatchedException(getValue(this.exceptions, "broad"), insideMsg, feedback);
        }
        return null;
    }

    public override object sign(object path, object api = null, object method = null, object parameters = null, object headers = null, object body = null)
    {
        api ??= "public";
        method ??= "GET";
        parameters ??= new Dictionary<string, object>();
        object request = add(add(add("/api/", this.version), "/"), this.implodeParams(path, parameters));
        object query = this.omit(parameters, this.extractParams(path));
        object url = add(this.implodeHostname(getValue(getValue(this.urls, "api"), "rest")), request);
        // const type = this.getPathAuthenticationType (path);
        if (isTrue(isEqual(api, "public")))
        {
            if (!isTrue(this.isEmpty(query)))
            {
                url = add(url, add("?", this.urlencode(query)));
            }
        } else if (isTrue(isEqual(api, "private")))
        {
            this.checkRequiredCredentials();
            object timestamp = ((object)this.milliseconds()).ToString();
            headers = new Dictionary<string, object>() {
                { "ACCESS-KEY", this.apiKey },
                { "ACCESS-PASSPHRASE", this.password },
                { "ACCESS-TIMESTAMP", timestamp },
                { "ACCESS-NONCE", timestamp },
            };
            object sign_body = "";
            if (isTrue(isEqual(method, "GET")))
            {
                if (!isTrue(this.isEmpty(query)))
                {
                    object urlencodedQuery = add("?", this.urlencode(query));
                    url = add(url, urlencodedQuery);
                    request = add(request, urlencodedQuery);
                }
            } else
            {
                if (!isTrue(this.isEmpty(query)))
                {
                    body = this.json(query);
                    sign_body = body;
                }
                ((IDictionary<string,object>)headers)["Content-Type"] = "application/json";
            }
            object auth = add(add(add(add(request, method), timestamp), timestamp), sign_body);
            object signature = this.stringToBase64(this.hmac(this.encode(auth), this.encode(this.secret), sha256));
            ((IDictionary<string,object>)headers)["ACCESS-SIGN"] = signature;
        }
        return new Dictionary<string, object>() {
            { "url", url },
            { "method", method },
            { "body", body },
            { "headers", headers },
        };
    }
}
