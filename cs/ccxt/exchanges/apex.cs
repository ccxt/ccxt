namespace ccxt;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

public partial class apex : Exchange
{
    public override object describe()
    {
        return this.deepExtend(base.describe(), new Dictionary<string, object>() {
            { "id", "apex" },
            { "name", "Apex" },
            { "countries", new List<object>() {} },
            { "version", "v3" },
            { "rateLimit", 20 },
            { "certified", false },
            { "pro", true },
            { "dex", true },
            { "has", new Dictionary<string, object>() {
                { "CORS", null },
                { "spot", false },
                { "margin", false },
                { "swap", true },
                { "future", false },
                { "option", false },
                { "addMargin", false },
                { "borrowCrossMargin", false },
                { "borrowIsolatedMargin", false },
                { "cancelAllOrders", true },
                { "cancelAllOrdersAfter", false },
                { "cancelOrder", true },
                { "cancelOrders", false },
                { "cancelOrdersForSymbols", false },
                { "closeAllPositions", false },
                { "closePosition", false },
                { "createMarketBuyOrderWithCost", false },
                { "createMarketOrderWithCost", false },
                { "createMarketSellOrderWithCost", false },
                { "createOrder", true },
                { "createOrders", false },
                { "createPostOnlyOrder", true },
                { "createReduceOnlyOrder", true },
                { "createStopOrder", true },
                { "createTriggerOrder", true },
                { "editOrder", false },
                { "fetchAccounts", true },
                { "fetchBalance", true },
                { "fetchBorrowInterest", false },
                { "fetchBorrowRateHistories", false },
                { "fetchBorrowRateHistory", false },
                { "fetchCanceledAndClosedOrders", false },
                { "fetchCanceledOrders", false },
                { "fetchClosedOrders", false },
                { "fetchCrossBorrowRate", false },
                { "fetchCrossBorrowRates", false },
                { "fetchCurrencies", true },
                { "fetchDepositAddress", false },
                { "fetchDepositAddresses", false },
                { "fetchDeposits", false },
                { "fetchDepositWithdrawFee", false },
                { "fetchDepositWithdrawFees", false },
                { "fetchFundingHistory", true },
                { "fetchFundingRate", false },
                { "fetchFundingRateHistory", true },
                { "fetchFundingRates", false },
                { "fetchIndexOHLCV", false },
                { "fetchIsolatedBorrowRate", false },
                { "fetchIsolatedBorrowRates", false },
                { "fetchLedger", false },
                { "fetchLeverage", false },
                { "fetchLeverageTiers", false },
                { "fetchLiquidations", false },
                { "fetchMarginMode", false },
                { "fetchMarketLeverageTiers", false },
                { "fetchMarkets", true },
                { "fetchMarkOHLCV", false },
                { "fetchMyLiquidations", false },
                { "fetchMyTrades", true },
                { "fetchOHLCV", true },
                { "fetchOpenInterest", true },
                { "fetchOpenInterestHistory", false },
                { "fetchOpenInterests", false },
                { "fetchOpenOrders", true },
                { "fetchOrder", true },
                { "fetchOrderBook", true },
                { "fetchOrders", true },
                { "fetchOrderTrades", true },
                { "fetchPosition", false },
                { "fetchPositionMode", false },
                { "fetchPositions", true },
                { "fetchPositionsRisk", false },
                { "fetchPremiumIndexOHLCV", false },
                { "fetchTicker", true },
                { "fetchTickers", true },
                { "fetchTime", true },
                { "fetchTrades", true },
                { "fetchTradingFee", false },
                { "fetchTradingFees", false },
                { "fetchTransfer", true },
                { "fetchTransfers", true },
                { "fetchWithdrawal", false },
                { "fetchWithdrawals", false },
                { "reduceMargin", false },
                { "repayCrossMargin", false },
                { "repayIsolatedMargin", false },
                { "sandbox", true },
                { "setLeverage", true },
                { "setMarginMode", false },
                { "setPositionMode", false },
                { "transfer", false },
                { "withdraw", false },
            } },
            { "timeframes", new Dictionary<string, object>() {
                { "1m", "1" },
                { "5m", "5" },
                { "15m", "15" },
                { "30m", "30" },
                { "1h", "60" },
                { "2h", "120" },
                { "4h", "240" },
                { "6h", "360" },
                { "12h", "720" },
                { "1d", "D" },
                { "1w", "W" },
                { "1M", "M" },
            } },
            { "hostname", "omni.apex.exchange" },
            { "urls", new Dictionary<string, object>() {
                { "logo", "https://github.com/user-attachments/assets/fef8f2f7-4265-46aa-965e-33a91881cb00" },
                { "api", new Dictionary<string, object>() {
                    { "public", "https://{hostname}/api" },
                    { "private", "https://{hostname}/api" },
                } },
                { "test", new Dictionary<string, object>() {
                    { "public", "https://testnet.omni.apex.exchange/api" },
                    { "private", "https://testnet.omni.apex.exchange/api" },
                } },
                { "www", "https://apex.exchange/" },
                { "doc", "https://api-docs.pro.apex.exchange" },
                { "fees", "https://apex-pro.gitbook.io/apex-pro/apex-omni-live-now/trading-perpetual-contracts/trading-fees" },
                { "referral", "https://omni.apex.exchange/trade" },
            } },
            { "api", new Dictionary<string, object>() {
                { "public", new Dictionary<string, object>() {
                    { "get", new Dictionary<string, object>() {
                        { "v3/symbols", 1 },
                        { "v3/history-funding", 1 },
                        { "v3/ticker", 1 },
                        { "v3/klines", 1 },
                        { "v3/trades", 1 },
                        { "v3/depth", 1 },
                        { "v3/time", 1 },
                        { "v3/data/all-ticker-info", 1 },
                    } },
                } },
                { "private", new Dictionary<string, object>() {
                    { "get", new Dictionary<string, object>() {
                        { "v3/account", 1 },
                        { "v3/account-balance", 1 },
                        { "v3/fills", 1 },
                        { "v3/order-fills", 1 },
                        { "v3/order", 1 },
                        { "v3/history-orders", 1 },
                        { "v3/order-by-client-order-id", 1 },
                        { "v3/funding", 1 },
                        { "v3/historical-pnl", 1 },
                        { "v3/open-orders", 1 },
                        { "v3/transfers", 1 },
                        { "v3/transfer", 1 },
                    } },
                    { "post", new Dictionary<string, object>() {
                        { "v3/delete-open-orders", 1 },
                        { "v3/delete-client-order-id", 1 },
                        { "v3/delete-order", 1 },
                        { "v3/order", 1 },
                        { "v3/set-initial-margin-rate", 1 },
                        { "v3/transfer-out", 1 },
                        { "v3/contract-transfer-out", 1 },
                    } },
                } },
            } },
            { "httpExceptions", new Dictionary<string, object>() {
                { "403", typeof(RateLimitExceeded) },
            } },
            { "exceptions", new Dictionary<string, object>() {
                { "exact", new Dictionary<string, object>() {
                    { "20006", "apikey sign error" },
                    { "20016", "request para error" },
                    { "10001", typeof(BadRequest) },
                } },
                { "broad", new Dictionary<string, object>() {
                    { "ORDER_PRICE_MUST_GREETER_ZERO", typeof(InvalidOrder) },
                    { "ORDER_POSSIBLE_LEAD_TO_ACCOUNT_LIQUIDATED", typeof(InvalidOrder) },
                    { "ORDER_WITH_THIS_PRICE_CANNOT_REDUCE_POSITION_ONLY", typeof(InvalidOrder) },
                } },
            } },
            { "fees", new Dictionary<string, object>() {
                { "swap", new Dictionary<string, object>() {
                    { "taker", this.parseNumber("0.0005") },
                    { "maker", this.parseNumber("0.0002") },
                } },
            } },
            { "requiredCredentials", new Dictionary<string, object>() {
                { "apiKey", true },
                { "secret", true },
                { "walletAddress", false },
                { "privateKey", false },
                { "password", true },
            } },
            { "precisionMode", TICK_SIZE },
            { "commonCurrencies", new Dictionary<string, object>() {} },
            { "options", new Dictionary<string, object>() {
                { "defaultType", "swap" },
                { "defaultSlippage", 0.05 },
                { "brokerId", "6956" },
            } },
            { "features", new Dictionary<string, object>() {
                { "default", new Dictionary<string, object>() {
                    { "sandbox", true },
                    { "createOrder", new Dictionary<string, object>() {
                        { "marginMode", false },
                        { "triggerPrice", true },
                        { "triggerPriceType", null },
                        { "triggerDirection", false },
                        { "stopLossPrice", false },
                        { "takeProfitPrice", false },
                        { "attachedStopLossTakeProfit", null },
                        { "timeInForce", new Dictionary<string, object>() {
                            { "IOC", true },
                            { "FOK", true },
                            { "PO", true },
                            { "GTD", true },
                        } },
                        { "hedged", false },
                        { "selfTradePrevention", false },
                        { "trailing", true },
                        { "leverage", false },
                        { "marketBuyByCost", false },
                        { "marketBuyRequiresPrice", false },
                        { "iceberg", false },
                    } },
                    { "createOrders", null },
                    { "fetchMyTrades", new Dictionary<string, object>() {
                        { "marginMode", false },
                        { "limit", 500 },
                        { "daysBack", 100000 },
                        { "untilDays", 100000 },
                        { "symbolRequired", false },
                    } },
                    { "fetchOrder", new Dictionary<string, object>() {
                        { "marginMode", false },
                        { "trigger", false },
                        { "trailing", false },
                        { "symbolRequired", false },
                    } },
                    { "fetchOpenOrders", new Dictionary<string, object>() {
                        { "marginMode", false },
                        { "limit", null },
                        { "trigger", false },
                        { "trailing", false },
                        { "symbolRequired", false },
                    } },
                    { "fetchOrders", new Dictionary<string, object>() {
                        { "marginMode", false },
                        { "limit", 100 },
                        { "daysBack", 100000 },
                        { "untilDays", 100000 },
                        { "trigger", false },
                        { "trailing", false },
                        { "symbolRequired", false },
                    } },
                    { "fetchClosedOrders", null },
                    { "fetchOHLCV", new Dictionary<string, object>() {
                        { "limit", 200 },
                    } },
                } },
                { "swap", new Dictionary<string, object>() {
                    { "linear", new Dictionary<string, object>() {
                        { "extends", "default" },
                    } },
                    { "inverse", null },
                } },
            } },
        });
    }

    /**
     * @method
     * @name apex#fetchTime
     * @description fetches the current integer timestamp in milliseconds from the exchange server
     * @see https://api-docs.pro.apex.exchange/#publicapi-v3-for-omni-get-system-time-v3
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {int} the current integer timestamp in milliseconds from the exchange server
     */
    public async override Task<object> fetchTime(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object response = await this.publicGetV3Time(parameters);
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        //
        // {
        //    "data": {
        //    "time": 1738837534454
        //     }
        // }
        return this.safeInteger(data, "time");
    }

    public override object parseBalance(object response)
    {
        //
        // {
        //     "totalEquityValue": "100.000000",
        //     "availableBalance": "100.000000",
        //     "initialMargin": "100.000000",
        //     "maintenanceMargin": "100.000000",
        //     "symbolToOraclePrice": {
        //     "BTC-USDC": {
        //         "oraclePrice": "20000",
        //             "createdTime": 124566
        //     }
        // }
        // }
        //
        object timestamp = this.milliseconds();
        object result = new Dictionary<string, object>() {
            { "info", response },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
        };
        object code = "USDT";
        object account = this.account();
        ((IDictionary<string,object>)account)["free"] = this.safeString(response, "availableBalance");
        ((IDictionary<string,object>)account)["total"] = this.safeString(response, "totalEquityValue");
        ((IDictionary<string,object>)result)[(string)code] = account;
        return this.safeBalance(result);
    }

    /**
     * @method
     * @name apex#fetchBalance
     * @description query for account info
     * @see https://api-docs.pro.apex.exchange/#privateapi-v3-for-omni-get-retrieve-user-account-balance
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
     */
    public async override Task<object> fetchBalance(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.privateGetV3AccountBalance(parameters);
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        return this.parseBalance(data);
    }

    public override object parseAccount(object account)
    {
        object accountId = this.safeString(account, "id", "0");
        return new Dictionary<string, object>() {
            { "id", accountId },
            { "type", null },
            { "code", null },
            { "info", account },
        };
    }

    /**
     * @method
     * @name apex#fetchAccount
     * @description query for balance and get the amount of funds available for trading or funds locked in orders
     * @see https://api-docs.pro.apex.exchange/#privateapi-v3-for-omni-get-retrieve-user-account-data
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
     */
    public async virtual Task<object> fetchAccount(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.privateGetV3Account(parameters);
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        return this.parseAccount(data);
    }

    /**
     * @method
     * @name apex#fetchCurrencies
     * @description fetches all available currencies on an exchange
     * @see https://api-docs.pro.apex.exchange/#publicapi-v3-for-omni-get-all-config-data-v3
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} an associative dictionary of currencies
     */
    public async override Task<object> fetchCurrencies(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object response = await this.publicGetV3Symbols(parameters);
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        object spotConfig = this.safeDict(data, "spotConfig", new Dictionary<string, object>() {});
        object multiChain = this.safeDict(spotConfig, "multiChain", new Dictionary<string, object>() {});
        // "spotConfig": {
        //     "assets": [
        //         {
        //             "tokenId": "141",
        //             "token": "USDT",
        //             "displayName": "Tether USD Coin",
        //             "decimals": 18,
        //             "showStep": "0.01",
        //             "iconUrl": "https://static-pro.apex.exchange/chains/chain_tokens/Ethereum/Ethereum_USDT.svg",
        //             "l2WithdrawFee": "0",
        //             "enableCollateral": true,
        //             "enableCrossCollateral": false,
        //             "crossCollateralDiscountRate": null,
        //             "isGray": false
        //         }
        //     ],
        // "multiChain": {
        //  "chains": [
        //      {
        //          "chain": "Arbitrum One",
        //          "chainId": "9",
        //          "chainType": "0",
        //          "l1ChainId": "42161",
        //          "chainIconUrl": "https://static-pro.apex.exchange/chains/chain_logos/Arbitrum.svg",
        //          "contractAddress": "0x3169844a120c0f517b4eb4a750c08d8518c8466a",
        //          "swapContractAddress": "0x9e07b6Aef1bbD9E513fc2Eb8873e311E80B4f855",
        //          "stopDeposit": false,
        //          "feeLess": false,
        //          "gasLess": false,
        //          "gasToken": "ETH",
        //          "dynamicFee": true,
        //          "gasTokenDecimals": 18,
        //          "feeGasLimit": 300000,
        //          "blockTimeSeconds": 2,
        //          "rpcUrl": "https://arb.pro.apex.exchange",
        //          "minSwapUsdtAmount": "",
        //          "maxSwapUsdtAmount": "",
        //          "webRpcUrl": "https://arb.pro.apex.exchange",
        //          "webTxUrl": "https://arbiscan.io/tx/",
        //          "backupRpcUrl": "https://arb-mainnet.g.alchemy.com/v2/rGlYUbRHtUav5mfeThCPtsV9GLPt2Xq5",
        //          "txConfirm": 20,
        //          "withdrawGasFeeLess": false,
        //          "tokens": [
        //              {
        //                  "decimals": 6,
        //                  "iconUrl": "https://static-pro.apex.exchange/chains/chain_tokens/Arbitrum/Arbitrum_USDT.svg",
        //                  "token": "USDT",
        //                  "tokenAddress": "0xFd086bC7CD5C481DCC9C85ebE478A1C0b69FCbb9",
        //                  "pullOff": false,
        //                  "withdrawEnable": true,
        //                  "slippage": "",
        //                  "isDefaultToken": false,
        //                  "displayToken": "USDT",
        //                  "needResetApproval": true,
        //                  "minFee": "2",
        //                  "maxFee": "40",
        //                  "feeRate": "0.0001",
        //                  "maxWithdraw": "",
        //                  "minDeposit": "",
        //                  "minWithdraw": "",
        //                  "maxFastWithdrawAmount": "40000",
        //                  "minFastWithdrawAmount": "1",
        //                  "isGray": false
        //              },
        //              {
        //                  "decimals": 6,
        //                  "iconUrl": "https://static-pro.apex.exchange/chains/chain_tokens/Arbitrum/Arbitrum_USDC.svg",
        //                  "token": "USDC",
        //                  "tokenAddress": "0xaf88d065e77c8cc2239327c5edb3a432268e5831",
        //                  "pullOff": false,
        //                  "withdrawEnable": true,
        //                  "slippage": "",
        //                  "isDefaultToken": false,
        //                  "displayToken": "USDC",
        //                  "needResetApproval": true,
        //                  "minFee": "2",
        //                  "maxFee": "20",
        //                  "feeRate": "0.0001",
        //                  "maxWithdraw": "",
        //                  "minDeposit": "",
        //                  "minWithdraw": "",
        //                  "maxFastWithdrawAmount": "1",
        //                  "minFastWithdrawAmount": "1",
        //                  "isGray": false
        //              }
        //          ]
        //        }
        //     ]
        // }
        object rows = this.safeList(spotConfig, "assets", new List<object>() {});
        object chains = this.safeList(multiChain, "chains", new List<object>() {});
        object result = new Dictionary<string, object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(rows)); postFixIncrement(ref i))
        {
            object currency = getValue(rows, i);
            object currencyId = this.safeString(currency, "token");
            object code = this.safeCurrencyCode(currencyId);
            object name = this.safeString(currency, "displayName");
            object networks = new Dictionary<string, object>() {};
            object minPrecision = null;
            object minWithdrawFeeString = null;
            object minWithdrawString = null;
            object deposit = false;
            object withdraw = false;
            for (object j = 0; isLessThan(j, getArrayLength(chains)); postFixIncrement(ref j))
            {
                object chain = getValue(chains, j);
                object tokens = this.safeList(chain, "tokens", new List<object>() {});
                for (object f = 0; isLessThan(f, getArrayLength(tokens)); postFixIncrement(ref f))
                {
                    object token = getValue(tokens, f);
                    object tokenName = this.safeString(token, "token");
                    if (isTrue(isEqual(tokenName, currencyId)))
                    {
                        object networkId = this.safeString(chain, "chainId");
                        object networkCode = this.networkIdToCode(networkId);
                        object precision = this.parseNumber(this.parsePrecision(this.safeString(currency, "decimals")));
                        minPrecision = ((bool) isTrue((isEqual(minPrecision, null)))) ? precision : mathMin(minPrecision, precision);
                        object depositAllowed = !isTrue(this.safeBool(chain, "stopDeposit"));
                        deposit = ((bool) isTrue((depositAllowed))) ? depositAllowed : deposit;
                        object withdrawAllowed = this.safeBool(token, "withdrawEnable");
                        withdraw = ((bool) isTrue((withdrawAllowed))) ? withdrawAllowed : withdraw;
                        minWithdrawFeeString = this.safeString(token, "minFee");
                        minWithdrawString = this.safeString(token, "minWithdraw");
                        object minNetworkDepositString = this.safeString(chain, "depositMin");
                        ((IDictionary<string,object>)networks)[(string)networkCode] = new Dictionary<string, object>() {
                            { "info", chain },
                            { "id", networkId },
                            { "network", networkCode },
                            { "active", isTrue(depositAllowed) && isTrue(withdrawAllowed) },
                            { "deposit", depositAllowed },
                            { "withdraw", withdrawAllowed },
                            { "fee", this.parseNumber(minWithdrawFeeString) },
                            { "precision", precision },
                            { "limits", new Dictionary<string, object>() {
                                { "withdraw", new Dictionary<string, object>() {
                                    { "min", this.parseNumber(minWithdrawString) },
                                    { "max", null },
                                } },
                                { "deposit", new Dictionary<string, object>() {
                                    { "min", this.parseNumber(minNetworkDepositString) },
                                    { "max", null },
                                } },
                            } },
                        };
                    }
                }
            }
            ((IDictionary<string,object>)result)[(string)code] = new Dictionary<string, object>() {
                { "info", currency },
                { "code", code },
                { "id", currencyId },
                { "type", "crypto" },
                { "name", name },
                { "active", isTrue(deposit) && isTrue(withdraw) },
                { "deposit", deposit },
                { "withdraw", withdraw },
                { "fee", this.parseNumber(minWithdrawFeeString) },
                { "precision", minPrecision },
                { "limits", new Dictionary<string, object>() {
                    { "amount", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                    { "withdraw", new Dictionary<string, object>() {
                        { "min", this.parseNumber(minWithdrawString) },
                        { "max", null },
                    } },
                    { "deposit", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                } },
                { "networks", networks },
            };
        }
        return result;
    }

    /**
     * @method
     * @name apex#fetchMarkets
     * @description retrieves data on all markets for apex
     * @see https://api-docs.pro.apex.exchange/#publicapi-v3-for-omni-get-all-config-data-v3
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} an array of objects representing market data
     */
    public async override Task<object> fetchMarkets(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object response = await this.publicGetV3Symbols(parameters);
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        object contractConfig = this.safeDict(data, "contractConfig", new Dictionary<string, object>() {});
        object perpetualContract = this.safeList(contractConfig, "perpetualContract", new List<object>() {});
        // {
        //     "perpetualContract":[
        //         {
        //             "baselinePositionValue": "50000.0000",
        //             "crossId": 30002,
        //             "crossSymbolId": 10,
        //             "crossSymbolName": "BTCUSDT",
        //             "digitMerge": "0.1,0.2,0.4,1,2",
        //             "displayMaxLeverage": "100",
        //             "displayMinLeverage": "1",
        //             "enableDisplay": true,
        //             "enableOpenPosition": true,
        //             "enableTrade": true,
        //             "fundingImpactMarginNotional": "6",
        //             "fundingInterestRate": "0.0003",
        //             "incrementalInitialMarginRate": "0.00250",
        //             "incrementalMaintenanceMarginRate": "0.00100",
        //             "incrementalPositionValue": "50000.0000",
        //             "initialMarginRate": "0.01",
        //             "maintenanceMarginRate": "0.005",
        //             "maxOrderSize": "50",
        //             "maxPositionSize": "100",
        //             "minOrderSize": "0.0010",
        //             "maxMarketPriceRange": "0.025",
        //             "settleAssetId": "USDT",
        //             "baseTokenId": "BTC",
        //             "stepSize": "0.001",
        //             "symbol": "BTC-USDT",
        //             "symbolDisplayName": "BTCUSDT",
        //             "tickSize": "0.1",
        //             "maxMaintenanceMarginRate": "0.5000",
        //             "maxPositionValue": "5000000.0000",
        //             "tagIconUrl": "https://static-pro.apex.exchange/icon/LABLE_HOT.svg",
        //             "tag": "HOT",
        //             "riskTip": false,
        //             "defaultInitialMarginRate": "0.05",
        //             "klineStartTime": 0,
        //             "maxMarketSizeBuffer": "0.98",
        //             "enableFundingSettlement": true,
        //             "indexPriceDecimals": 2,
        //             "indexPriceVarRate": "0.001",
        //             "openPositionOiLimitRate": "0.05",
        //             "fundingMaxRate": "0.000234",
        //             "fundingMinRate": "-0.000234",
        //             "fundingMaxValue": "",
        //             "enableFundingMxValue": true,
        //             "l2PairId": "50001",
        //             "settleTimeStamp": 0,
        //             "isPrelaunch": false,
        //             "riskLimitConfig": {},
        //             "category": "L1"
        //         }
        //     ]
        // }
        return this.parseMarkets(perpetualContract);
    }

    public override object parseMarket(object market)
    {
        object id = this.safeString(market, "symbol");
        object id2 = this.safeString(market, "crossSymbolName");
        object quoteId = this.safeString(market, "l2PairId");
        object baseId = this.safeString(market, "baseTokenId");
        object quote = this.safeString(market, "settleAssetId");
        object bs = this.safeCurrencyCode(baseId);
        object settleId = this.safeString(market, "settleAssetId");
        object settle = this.safeCurrencyCode(settleId);
        object symbol = add(add(add(add(baseId, "/"), quote), ":"), settle);
        object expiry = 0;
        object takerFee = this.parseNumber("0.0002");
        object makerFee = this.parseNumber("0.0005");
        return this.safeMarketStructure(new Dictionary<string, object>() {
            { "id", id },
            { "id2", id2 },
            { "symbol", symbol },
            { "base", bs },
            { "quote", quote },
            { "settle", settle },
            { "baseId", baseId },
            { "quoteId", quoteId },
            { "settleId", settleId },
            { "type", "swap" },
            { "spot", false },
            { "margin", null },
            { "swap", true },
            { "future", false },
            { "option", false },
            { "active", this.safeBool(market, "enableTrade") },
            { "contract", true },
            { "linear", true },
            { "inverse", false },
            { "taker", takerFee },
            { "maker", makerFee },
            { "contractSize", this.safeNumber(market, "minOrderSize") },
            { "expiry", ((bool) isTrue((isEqual(expiry, 0)))) ? null : expiry },
            { "expiryDatetime", ((bool) isTrue((isEqual(expiry, 0)))) ? null : this.iso8601(expiry) },
            { "strike", null },
            { "optionType", null },
            { "precision", new Dictionary<string, object>() {
                { "amount", this.safeNumber(market, "stepSize") },
                { "price", this.safeNumber(market, "tickSize") },
            } },
            { "limits", new Dictionary<string, object>() {
                { "leverage", new Dictionary<string, object>() {
                    { "min", this.safeNumber(market, "displayMinLeverage") },
                    { "max", this.safeNumber(market, "displayMaxLeverage") },
                } },
                { "amount", new Dictionary<string, object>() {
                    { "min", this.safeNumber(market, "minOrderSize") },
                    { "max", this.safeNumber(market, "maxOrderSize") },
                } },
                { "price", new Dictionary<string, object>() {
                    { "min", null },
                    { "max", null },
                } },
                { "cost", new Dictionary<string, object>() {
                    { "min", null },
                    { "max", null },
                } },
            } },
            { "created", null },
            { "info", market },
        });
    }

    public override object parseTicker(object ticker, object market = null)
    {
        //
        // {
        //     "symbol": "BTCUSDT",
        //     "price24hPcnt": "0.450141",
        //     "lastPrice": "43511.50",
        //     "highPrice24h": "43513.50",
        //     "lowPrice24h": "29996.00",
        //     "markPrice": "43513.50",
        //     "indexPrice": "40828.94",
        //     "openInterest": "2036854775808",
        //     "turnover24h": "5626085.23749999",
        //     "volume24h": "169.317",
        //     "fundingRate": "0",
        //     "predictedFundingRate": "0",
        //     "nextFundingTime": "10:00:00",
        //     "tradeCount": 100
        // }
        //
        object timestamp = this.milliseconds();
        object marketId = this.safeString(ticker, "symbol");
        market = this.safeMarket(marketId, market);
        object symbol = this.safeSymbol(marketId, market);
        object last = this.safeString(ticker, "lastPrice");
        object percentage = this.safeString(ticker, "price24hPcnt");
        object quoteVolume = this.safeString(ticker, "turnover24h");
        object baseVolume = this.safeString(ticker, "volume24h");
        object high = this.safeString(ticker, "highPrice24h");
        object low = this.safeString(ticker, "lowPrice24h");
        return this.safeTicker(new Dictionary<string, object>() {
            { "symbol", symbol },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "high", high },
            { "low", low },
            { "bid", null },
            { "bidVolume", null },
            { "ask", null },
            { "askVolume", null },
            { "vwap", null },
            { "open", null },
            { "close", last },
            { "last", last },
            { "previousClose", null },
            { "change", null },
            { "percentage", percentage },
            { "average", null },
            { "baseVolume", baseVolume },
            { "quoteVolume", quoteVolume },
            { "markPrice", this.safeString(ticker, "markPrice") },
            { "indexPrice", this.safeString(ticker, "indexPrice") },
            { "info", ticker },
        }, market);
    }

    /**
     * @method
     * @name apex#fetchTicker
     * @description fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
     * @see https://api-docs.pro.apex.exchange/#publicapi-v3-for-omni-get-ticker-data-v3
     * @param {string} symbol unified symbol of the market to fetch the ticker for
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
     */
    public async override Task<object> fetchTicker(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id2") },
        };
        object response = await this.publicGetV3Ticker(this.extend(request, parameters));
        object tickers = this.safeList(response, "data", new List<object>() {});
        object rawTicker = this.safeDict(tickers, 0, new Dictionary<string, object>() {});
        return this.parseTicker(rawTicker, market);
    }

    /**
     * @method
     * @name apex#fetchTickers
     * @description fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
     * @see https://api-docs.pro.apex.exchange/#publicapi-v3-for-omni-get-ticker-data-v3
     * @param {string} symbols unified symbol of the market to fetch the ticker for
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
     */
    public async override Task<object> fetchTickers(object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.publicGetV3DataAllTickerInfo(parameters);
        object tickers = this.safeList(response, "data", new List<object>() {});
        return this.parseTickers(tickers, symbols);
    }

    /**
     * @method
     * @name apex#fetchOHLCV
     * @description fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
     * @see https://api-docs.pro.apex.exchange/#publicapi-v3-for-omni-get-candlestick-chart-data-v3
     * @param {string} symbol unified symbol of the market to fetch OHLCV data for
     * @param {string} timeframe the length of time each candle represents
     * @param {int} [since] timestamp in ms of the earliest candle to fetch
     * @param {int} [limit] the maximum amount of candles to fetch
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {int} [params.until] timestamp in ms of the latest candle to fetch
     * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
     */
    public async override Task<object> fetchOHLCV(object symbol, object timeframe = null, object since = null, object limit = null, object parameters = null)
    {
        timeframe ??= "1m";
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "interval", this.safeString(this.timeframes, timeframe, timeframe) },
            { "symbol", getValue(market, "id2") },
        };
        if (isTrue(isEqual(limit, null)))
        {
            limit = 200; // default is 200 when requested with `since`
        }
        ((IDictionary<string,object>)request)["limit"] = limit; // max 200, default 200
        var requestparametersVariable = this.handleUntilOption("end", request, parameters);
        request = ((IList<object>)requestparametersVariable)[0];
        parameters = ((IList<object>)requestparametersVariable)[1];
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["start"] = since;
        }
        object response = await this.publicGetV3Klines(this.extend(request, parameters));
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        object OHLCVs = this.safeList(data, getValue(market, "id2"), new List<object>() {});
        return this.parseOHLCVs(OHLCVs, market, timeframe, since, limit);
    }

    public override object parseOHLCV(object ohlcv, object market = null)
    {
        //
        // {
        //     "start": 1647511440000,
        //     "symbol": "BTC-USD",
        //     "interval": "1",
        //     "low": "40000",
        //     "high": "45000",
        //     "open": "45000",
        //     "close": "40000",
        //     "volume": "1.002",
        //     "turnover": "3"
        // } {"s":"BTCUSDT","i":"1","t":1741265880000,"c":"90235","h":"90235","l":"90156","o":"90156","v":"0.052","tr":"4690.4466"}
        //
        return new List<object> {this.safeIntegerN(ohlcv, new List<object>() {"start", "t"}), this.safeNumberN(ohlcv, new List<object>() {"open", "o"}), this.safeNumberN(ohlcv, new List<object>() {"high", "h"}), this.safeNumberN(ohlcv, new List<object>() {"low", "l"}), this.safeNumberN(ohlcv, new List<object>() {"close", "c"}), this.safeNumberN(ohlcv, new List<object>() {"volume", "v"})};
    }

    /**
     * @method
     * @name apex#fetchOrderBook
     * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
     * @see https://api-docs.pro.apex.exchange/#publicapi-v3-for-omni-get-market-depth-v3
     * @param {string} symbol unified symbol of the market to fetch the order book for
     * @param {int} [limit] the maximum amount of order book entries to return
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
     */
    public async override Task<object> fetchOrderBook(object symbol, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id2") },
        };
        if (isTrue(isEqual(limit, null)))
        {
            limit = 100; // default is 200 when requested with `since`
        }
        ((IDictionary<string,object>)request)["limit"] = limit; // max 100, default 100
        object response = await this.publicGetV3Depth(this.extend(request, parameters));
        //
        // {
        //     "a": [
        //     [
        //         "96576.3",
        //         "0.399"
        //     ],
        //     [
        //         "96577.6",
        //         "0.106"
        //     ]
        // ],
        //     "b": [
        //     [
        //         "96565.2",
        //         "0.131"
        //     ],
        //     [
        //         "96565.1",
        //         "0.038"
        //     ]
        // ],
        //     "s": "BTCUSDT",
        //     "u": 18665465
        // }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        object timestamp = this.milliseconds();
        object orderbook = this.parseOrderBook(data, getValue(market, "symbol"), timestamp, "b", "a");
        ((IDictionary<string,object>)orderbook)["nonce"] = this.safeInteger(data, "u");
        return orderbook;
    }

    /**
     * @method
     * @name apex#fetchTrades
     * @description get the list of most recent trades for a particular symbol
     * @see https://api-docs.pro.apex.exchange/#publicapi-v3-for-omni-get-newest-trading-data-v3
     * @param {string} symbol unified symbol of the market to fetch trades for
     * @param {int} [since] timestamp in ms of the earliest trade to fetch
     * @param {int} [limit] the maximum amount of trades to fetch
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {int} [params.until] the latest time in ms to fetch trades for
     * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times
     * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
     */
    public async override Task<object> fetchTrades(object symbol, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id2") },
        };
        if (isTrue(isEqual(limit, null)))
        {
            limit = 500; // default is 50
        }
        ((IDictionary<string,object>)request)["limit"] = limit;
        object response = await this.publicGetV3Trades(this.extend(request, parameters));
        //
        // [
        //  {
        //      "i": "993f7f85-9215-5723-9078-2186ae140847",
        //      "p": "96534.3",
        //      "S": "Sell",
        //      "v": "0.261",
        //      "s": "BTCUSDT",
        //      "T": 1739118072710
        //  },
        //  {
        //      "i": "c947c9cf-8c18-5784-89c3-91bdf86ddde8",
        //      "p": "96513.5",
        //      "S": "Sell",
        //      "v": "0.042",
        //      "s": "BTCUSDT",
        //      "T": 1739118075944
        //  }
        //  ]
        //
        object trades = this.safeList(response, "data", new List<object>() {});
        return this.parseTrades(trades, market, since, limit);
    }

    public override object parseTrade(object trade, object market = null)
    {
        //
        // [
        //  {
        //      "i": "993f7f85-9215-5723-9078-2186ae140847",
        //      "p": "96534.3",
        //      "S": "Sell",
        //      "v": "0.261",
        //      "s": "BTCUSDT",
        //      "T": 1739118072710
        //  }
        //  ]
        //
        object marketId = this.safeStringN(trade, new List<object>() {"s", "symbol"});
        market = this.safeMarket(marketId, market);
        object id = this.safeStringN(trade, new List<object>() {"i", "id"});
        object timestamp = this.safeIntegerN(trade, new List<object>() {"t", "T", "createdAt"});
        object priceString = this.safeStringN(trade, new List<object>() {"p", "price"});
        object amountString = this.safeStringN(trade, new List<object>() {"v", "size"});
        object side = this.safeStringLowerN(trade, new List<object>() {"S", "side"});
        object type = this.safeStringN(trade, new List<object>() {"type"});
        object fee = this.safeStringN(trade, new List<object>() {"fee"});
        return this.safeTrade(new Dictionary<string, object>() {
            { "info", trade },
            { "id", id },
            { "order", null },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "symbol", getValue(market, "symbol") },
            { "type", type },
            { "takerOrMaker", null },
            { "side", side },
            { "price", priceString },
            { "amount", amountString },
            { "cost", null },
            { "fee", fee },
        }, market);
    }

    /**
     * @method
     * @name apex#fetchOpenInterest
     * @description retrieves the open interest of a contract trading pair
     * @see https://api-docs.pro.apex.exchange/#publicapi-v3-for-omni-get-ticker-data-v3
     * @param {string} symbol unified CCXT market symbol
     * @param {object} [params] exchange specific parameters
     * @returns {object} an open interest structure{@link https://docs.ccxt.com/#/?id=open-interest-structure}
     */
    public async override Task<object> fetchOpenInterest(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id2") },
        };
        object response = await this.publicGetV3Ticker(this.extend(request, parameters));
        object tickers = this.safeList(response, "data", new List<object>() {});
        object rawTicker = this.safeDict(tickers, 0, new Dictionary<string, object>() {});
        return this.parseOpenInterest(rawTicker, market);
    }

    public override object parseOpenInterest(object interest, object market = null)
    {
        //
        // {
        //     "symbol": "BTCUSDT",
        //     "price24hPcnt": "0.450141",
        //     "lastPrice": "43511.50",
        //     "highPrice24h": "43513.50",
        //     "lowPrice24h": "29996.00",
        //     "markPrice": "43513.50",
        //     "indexPrice": "40828.94",
        //     "openInterest": "2036854775808",
        //     "turnover24h": "5626085.23749999",
        //     "volume24h": "169.317",
        //     "fundingRate": "0",
        //     "predictedFundingRate": "0",
        //     "nextFundingTime": "10:00:00",
        //     "tradeCount": 100
        // }
        //
        object timestamp = this.milliseconds();
        object marketId = this.safeString(interest, "symbol");
        market = this.safeMarket(marketId, market);
        object symbol = this.safeSymbol(marketId, market);
        return this.safeOpenInterest(new Dictionary<string, object>() {
            { "symbol", symbol },
            { "openInterestAmount", this.safeString(interest, "openInterest") },
            { "openInterestValue", null },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "info", interest },
        }, market);
    }

    /**
     * @method
     * @name apex#fetchFundingRateHistory
     * @description fetches historical funding rate prices
     * @see https://api-docs.pro.apex.exchange/#publicapi-v3-for-omni-get-funding-rate-history-v3
     * @param {string} symbol unified symbol of the market to fetch the funding rate history for
     * @param {int} [since] timestamp in ms of the earliest funding rate to fetch
     * @param {int} [limit] the maximum amount of [funding rate structures]{@link https://docs.ccxt.com/#/?id=funding-rate-history-structure} to fetch
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {int} [params.until] timestamp in ms of the latest funding rate
     * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [availble parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
     * @returns {object[]} a list of [funding rate structures]{@link https://docs.ccxt.com/#/?id=funding-rate-history-structure}
     */
    public async override Task<object> fetchFundingRateHistory(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchFundingRateHistory() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object market = this.market(symbol);
        ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["beginTimeInclusive"] = since;
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        object page = this.safeInteger(parameters, "page");
        if (isTrue(!isEqual(page, null)))
        {
            ((IDictionary<string,object>)request)["page"] = page;
        }
        object endTimeExclusive = this.safeIntegerN(parameters, new List<object>() {"endTime", "endTimeExclusive", "until"});
        if (isTrue(!isEqual(endTimeExclusive, null)))
        {
            ((IDictionary<string,object>)request)["endTimeExclusive"] = endTimeExclusive;
        }
        object response = await this.publicGetV3HistoryFunding(this.extend(request, parameters));
        //
        // {
        //     "historyFunds": [
        //     {
        //         "symbol": "BTC-USD",
        //         "rate": "0.0000125000",
        //         "price": "31297.5000008009374142",
        //         "fundingTime": 12315555,
        //         "fundingTimestamp": 12315555
        //     }
        // ],
        //     "totalSize": 11
        // }
        //
        object rates = new List<object>() {};
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        object resultList = this.safeList(data, "historyFunds", new List<object>() {});
        for (object i = 0; isLessThan(i, getArrayLength(resultList)); postFixIncrement(ref i))
        {
            object entry = getValue(resultList, i);
            object timestamp = this.safeInteger(entry, "fundingTimestamp");
            ((IList<object>)rates).Add(new Dictionary<string, object>() {
                { "info", entry },
                { "symbol", this.safeString(entry, "symbol") },
                { "fundingRate", this.safeNumber(entry, "rate") },
                { "timestamp", timestamp },
                { "datetime", this.iso8601(timestamp) },
            });
        }
        object sorted = this.sortBy(rates, "timestamp");
        return this.filterBySymbolSinceLimit(sorted, symbol, since, limit);
    }

    public override object parseOrder(object order, object market = null)
    {
        //
        // {
        //     "id": "1234",
        //     "clientId": "1234",
        //     "accountId": "12345",
        //     "symbol": "BTC-USD",
        //     "side": "SELL",
        //     "price": "18000",
        //     "limitFee": "100",
        //     "fee": "100",
        //     "triggerPrice": "1.2",
        //     "trailingPercent": "0.12",
        //     "size": "100",
        //     "remainingSize": "100",
        //     "type": "LIMIT",
        //     "createdAt": 1647502440973,
        //     "updatedTime": 1647502440973,
        //     "expiresAt": 1647502440973,
        //     "status": "PENDING",
        //     "timeInForce": "GOOD_TIL_CANCEL",
        //     "postOnly": false,
        //     "reduceOnly": false,
        //     "stopPnl": false,
        //     "latestMatchFillPrice": "reason",
        //     "cumMatchFillSize": "0.1",
        //     "cumMatchFillValue": "1000",
        //     "cumMatchFillFee": "1",
        //     "cumSuccessFillSize": "0.1",
        //     "cumSuccessFillValue": "1000",
        //     "cumSuccessFillFee": "1",
        //     "triggerPriceType": "INDEX",
        //     "isOpenTpslOrder": true,
        //     "isSetOpenTp": true,
        //     "isSetOpenSl": false,
        //     "openTpParam": {
        //     "side": "SELL",
        //         "price": "18000",
        //         "limitFee": "100",
        //         "clientOrderId": "111100",
        //         "triggerPrice": "1.2",
        //         "trailingPercent": "0.12",
        //         "size": "100"
        // },
        //     "openSlParam": {
        //     "side": "SELL",
        //         "price": "18000",
        //         "limitFee": "100",
        //         "clientOrderId": "111100",
        //         "triggerPrice": "1.2",
        //         "trailingPercent": "0.12",
        //         "size": "100"
        // }
        // }
        //
        object timestamp = this.safeInteger(order, "createdAt");
        object orderId = this.safeString(order, "id");
        object clientOrderId = this.safeString(order, "clientId");
        object marketId = this.safeString(order, "symbol");
        market = this.safeMarket(marketId, market);
        object symbol = getValue(market, "symbol");
        object price = this.safeString(order, "price");
        object amount = this.safeString(order, "size");
        object orderType = this.safeString(order, "type");
        object status = this.safeString(order, "status");
        object side = this.safeStringLower(order, "side");
        // const average = this.omitZero (this.safeString (order, 'avg_fill_price'));
        object remaining = this.omitZero(this.safeString(order, "remainingSize"));
        object lastUpdateTimestamp = this.safeInteger(order, "updatedTime");
        return this.safeOrder(new Dictionary<string, object>() {
            { "id", orderId },
            { "clientOrderId", clientOrderId },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "lastTradeTimestamp", null },
            { "lastUpdateTimestamp", lastUpdateTimestamp },
            { "status", this.parseOrderStatus(status) },
            { "symbol", symbol },
            { "type", this.parseOrderType(orderType) },
            { "timeInForce", this.parseTimeInForce(this.safeString(order, "timeInForce")) },
            { "postOnly", this.safeBool(order, "postOnly") },
            { "reduceOnly", this.safeBool(order, "reduceOnly") },
            { "side", side },
            { "price", price },
            { "triggerPrice", this.safeString(order, "triggerPrice") },
            { "takeProfitPrice", null },
            { "stopLossPrice", null },
            { "average", null },
            { "amount", amount },
            { "filled", null },
            { "remaining", remaining },
            { "cost", null },
            { "trades", null },
            { "fee", new Dictionary<string, object>() {
                { "cost", this.safeString(order, "fee") },
                { "currency", getValue(market, "settleId") },
            } },
            { "info", order },
        }, market);
    }

    public virtual object parseTimeInForce(object timeInForce)
    {
        object timeInForces = new Dictionary<string, object>() {
            { "GOOD_TIL_CANCEL", "GOOD_TIL_CANCEL" },
            { "FILL_OR_KILL", "FILL_OR_KILL" },
            { "IMMEDIATE_OR_CANCEL", "IMMEDIATE_OR_CANCEL" },
            { "POST_ONLY", "POST_ONLY" },
        };
        return this.safeString(timeInForces, timeInForce, null);
    }

    public virtual object parseOrderStatus(object status)
    {
        if (isTrue(!isEqual(status, null)))
        {
            object statuses = new Dictionary<string, object>() {
                { "PENDING", "open" },
                { "OPEN", "open" },
                { "FILLED", "filled" },
                { "CANCELING", "canceled" },
                { "CANCELED", "canceled" },
                { "UNTRIGGERED", "open" },
            };
            return this.safeString(statuses, status, status);
        }
        return status;
    }

    public virtual object parseOrderType(object type)
    {
        object types = new Dictionary<string, object>() {
            { "LIMIT", "LIMIT" },
            { "MARKET", "MARKET" },
            { "STOP_LIMIT", "STOP_LIMIT" },
            { "STOP_MARKET", "STOP_MARKET" },
            { "TAKE_PROFIT_LIMIT", "TAKE_PROFIT_LIMIT" },
            { "TAKE_PROFIT_MARKET", "TAKE_PROFIT_MARKET" },
        };
        return this.safeStringUpper(types, type, type);
    }

    public override object safeMarket(object marketId = null, object market = null, object delimiter = null, object marketType = null)
    {
        if (isTrue(isTrue(isEqual(market, null)) && isTrue(!isEqual(marketId, null))))
        {
            if (isTrue(inOp(this.markets, marketId)))
            {
                market = getValue(this.markets, marketId);
            } else if (isTrue(inOp(this.markets_by_id, marketId)))
            {
                market = getValue(this.markets_by_id, marketId);
            } else
            {
                object newMarketId = this.addHyphenBeforeUsdt(marketId);
                if (isTrue(inOp(this.markets_by_id, newMarketId)))
                {
                    object markets = getValue(this.markets_by_id, newMarketId);
                    object numMarkets = getArrayLength(markets);
                    if (isTrue(isGreaterThan(numMarkets, 0)))
                    {
                        if (isTrue(isEqual(getValue(getValue(getValue(this.markets_by_id, newMarketId), 0), "id2"), marketId)))
                        {
                            market = getValue(getValue(this.markets_by_id, newMarketId), 0);
                        }
                    }
                }
            }
        }
        return base.safeMarket(marketId, market, delimiter, marketType);
    }

    public virtual object generateRandomClientIdOmni(object _accountId)
    {
        object accountId = isTrue(_accountId) || isTrue(((object)this.randNumber(12)).ToString());
        return add(add(add(add(add("apexomni-", accountId), "-"), ((object)this.milliseconds()).ToString()), "-"), ((object)this.randNumber(6)).ToString());
    }

    public virtual object addHyphenBeforeUsdt(object symbol)
    {
        object uppercaseSymbol = ((string)symbol).ToUpper();
        object index = getIndexOf(uppercaseSymbol, "USDT");
        object symbolChar = this.safeString(symbol, subtract(index, 1));
        if (isTrue(isTrue(isGreaterThan(index, 0)) && isTrue(!isEqual(symbolChar, "-"))))
        {
            return add(add(slice(symbol, 0, index), "-"), slice(symbol, index, null));
        }
        return symbol;
    }

    public virtual object getSeeds()
    {
        object seeds = this.safeString(this.options, "seeds");
        if (isTrue(isEqual(seeds, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " the \"seeds\" key is required in the options to access private endpoints. You can find it in API Management > Omni Key, and then set it as exchange.options[\"seeds\"] = XXXX")) ;
        }
        return seeds;
    }

    public async virtual Task<object> getAccountId()
    {
        object accountId = this.safeString(this.options, "accountId", "0");
        if (isTrue(isEqual(accountId, "0")))
        {
            object accountData = await this.fetchAccount();
            ((IDictionary<string,object>)this.options)["accountId"] = this.safeString(accountData, "id", "0");
        }
        return getValue(this.options, "accountId");
    }

    /**
     * @method
     * @name apex#createOrder
     * @description create a trade order
     * @see https://api-docs.pro.apex.exchange/#privateapi-v3-for-omni-post-creating-orders
     * @param {string} symbol unified symbol of the market to create an order in
     * @param {string} type 'market' or 'limit'
     * @param {string} side 'buy' or 'sell'
     * @param {float} amount how much of currency you want to trade in units of base currency
     * @param {float} [price] the price at which the order is to be fullfilled, in units of the quote currency, ignored in market orders
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {float} [params.triggerPrice] The price a trigger order is triggered at
     * @param {string} [params.timeInForce] "GTC", "IOC", or "POST_ONLY"
     * @param {bool} [params.postOnly] true or false
     * @param {bool} [params.reduceOnly] Ensures that the executed order does not flip the opened position.
     * @param {string} [params.clientOrderId] a unique id for the order
     * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> createOrder(object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object orderType = ((string)type).ToUpper();
        object orderSide = ((string)side).ToUpper();
        object orderSize = this.amountToPrecision(symbol, amount);
        object orderPrice = "0";
        if (isTrue(!isEqual(price, null)))
        {
            orderPrice = this.priceToPrecision(symbol, price);
        }
        object fees = this.safeDict(this.fees, "swap", new Dictionary<string, object>() {});
        object taker = this.safeNumber(fees, "taker", 0.0005);
        object maker = this.safeNumber(fees, "maker", 0.0002);
        object limitFee = this.decimalToPrecision(Precise.stringAdd(Precise.stringMul(Precise.stringMul(orderPrice, orderSize), ((object)taker).ToString()), ((object)getValue(getValue(market, "precision"), "price")).ToString()), TRUNCATE, getValue(getValue(market, "precision"), "price"), this.precisionMode, this.paddingMode);
        object timeNow = this.milliseconds();
        // const triggerPrice = this.safeString2 (params, 'triggerPrice', 'stopPrice');
        object isMarket = isEqual(orderType, "MARKET");
        if (isTrue(isTrue(isMarket) && isTrue((isEqual(price, null)))))
        {
            throw new ArgumentsRequired ((string)add(this.id, " createOrder() requires a price argument for market orders")) ;
        }
        object timeInForce = this.safeStringUpper(parameters, "timeInForce");
        object postOnly = this.isPostOnly(isMarket, null, parameters);
        if (isTrue(isEqual(timeInForce, null)))
        {
            timeInForce = "GOOD_TIL_CANCEL";
        }
        if (!isTrue(isMarket))
        {
            if (isTrue(postOnly))
            {
                timeInForce = "POST_ONLY";
            } else if (isTrue(isEqual(timeInForce, "ioc")))
            {
                timeInForce = "IMMEDIATE_OR_CANCEL";
            }
        }
        parameters = this.omit(parameters, "timeInForce");
        parameters = this.omit(parameters, "postOnly");
        object clientOrderId = this.safeStringN(parameters, new List<object>() {"clientId", "clientOrderId", "client_order_id"});
        object accountId = await this.getAccountId();
        if (isTrue(isEqual(clientOrderId, null)))
        {
            clientOrderId = this.generateRandomClientIdOmni(accountId);
        }
        parameters = this.omit(parameters, new List<object>() {"clientId", "clientOrderId", "client_order_id"});
        object orderToSign = new Dictionary<string, object>() {
            { "accountId", accountId },
            { "slotId", clientOrderId },
            { "nonce", clientOrderId },
            { "pairId", getValue(market, "quoteId") },
            { "size", orderSize },
            { "price", orderPrice },
            { "direction", orderSide },
            { "makerFeeRate", ((object)maker).ToString() },
            { "takerFeeRate", ((object)taker).ToString() },
        };
        object signature = await this.getZKContractSignatureObj(this.remove0xPrefix(this.getSeeds()), orderToSign);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
            { "side", orderSide },
            { "type", orderType },
            { "size", orderSize },
            { "price", orderPrice },
            { "limitFee", limitFee },
            { "expiration", (Math.Floor(Double.Parse((add(divide(timeNow, 1000), multiply(multiply(multiply(30, 24), 60), 60))).ToString()))) },
            { "timeInForce", timeInForce },
            { "clientId", clientOrderId },
            { "brokerId", this.safeString(this.options, "brokerId", "6956") },
        };
        ((IDictionary<string,object>)request)["signature"] = signature;
        object response = await this.privatePostV3Order(this.extend(request, parameters));
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        return this.parseOrder(data, market);
    }

    /**
     * @method
     * @name apex#transfer
     * @description transfer currency internally between wallets on the same account
     * @param {string} code unified currency code
     * @param {float} amount amount to transfer
     * @param {string} fromAccount account to transfer from
     * @param {string} toAccount account to transfer to
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.transferId] UUID, which is unique across the platform
     * @returns {object} a [transfer structure]{@link https://docs.ccxt.com/#/?id=transfer-structure}
     */
    public async override Task<object> transfer(object code, object amount, object fromAccount, object toAccount, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object configResponse = await this.publicGetV3Symbols(parameters);
        object configData = this.safeDict(configResponse, "data", new Dictionary<string, object>() {});
        object contractConfig = this.safeDict(configData, "contractConfig", new Dictionary<string, object>() {});
        object contractAssets = this.safeList(contractConfig, "assets", new List<object>() {});
        object spotConfig = this.safeDict(configData, "spotConfig", new Dictionary<string, object>() {});
        object spotAssets = this.safeList(spotConfig, "assets", new List<object>() {});
        object globalConfig = this.safeDict(spotConfig, "global", new Dictionary<string, object>() {});
        object receiverAddress = this.safeString(globalConfig, "contractAssetPoolEthAddress", "");
        object receiverZkAccountId = this.safeString(globalConfig, "contractAssetPoolZkAccountId", "");
        object receiverSubAccountId = this.safeString(globalConfig, "contractAssetPoolSubAccount", "");
        object receiverAccountId = this.safeString(globalConfig, "contractAssetPoolAccountId", "");
        object accountResponse = await this.privateGetV3Account(parameters);
        object accountData = this.safeDict(accountResponse, "data", new Dictionary<string, object>() {});
        object spotAccount = this.safeDict(accountData, "spotAccount", new Dictionary<string, object>() {});
        object zkAccountId = this.safeString(spotAccount, "zkAccountId", "");
        object subAccountId = this.safeString(spotAccount, "defaultSubAccountId", "0");
        object subAccounts = this.safeList(spotAccount, "subAccounts", new List<object>() {});
        object nonce = "0";
        if (isTrue(isGreaterThan(getArrayLength(subAccounts), 0)))
        {
            nonce = this.safeString(getValue(subAccounts, 0), "nonce", "0");
        }
        object ethAddress = this.safeString(accountData, "ethereumAddress", "");
        object accountId = this.safeString(accountData, "id", "");
        object currency = new Dictionary<string, object>() {};
        object assets = new List<object>() {};
        if (isTrue(isTrue(!isEqual(fromAccount, null)) && isTrue(isEqual(((string)fromAccount).ToLower(), "contract"))))
        {
            assets = contractAssets;
        } else
        {
            assets = spotAssets;
        }
        for (object i = 0; isLessThan(i, getArrayLength(assets)); postFixIncrement(ref i))
        {
            if (isTrue(isEqual(this.safeString(getValue(assets, i), "token", ""), code)))
            {
                currency = getValue(assets, i);
            }
        }
        object tokenId = this.safeString(currency, "tokenId", "");
        object amountNumber = this.parseToInt(multiply(amount, (Math.Pow(Convert.ToDouble(10), Convert.ToDouble(this.safeNumber(currency, "decimals", 0))))));
        object timestampSeconds = this.parseToInt(divide(this.milliseconds(), 1000));
        object clientOrderId = this.safeStringN(parameters, new List<object>() {"clientId", "clientOrderId", "client_order_id"});
        if (isTrue(isEqual(clientOrderId, null)))
        {
            clientOrderId = this.generateRandomClientIdOmni(this.safeString(this.options, "accountId"));
        }
        parameters = this.omit(parameters, new List<object>() {"clientId", "clientOrderId", "client_order_id"});
        if (isTrue(isTrue(!isEqual(fromAccount, null)) && isTrue(isEqual(((string)fromAccount).ToLower(), "contract"))))
        {
            object formattedUint32 = "4294967295";
            object zkSignAccountId = Precise.stringMod(accountId, formattedUint32);
            object expireTime = add(timestampSeconds, multiply(multiply(3600, 24), 28));
            object orderToSign = new Dictionary<string, object>() {
                { "zkAccountId", zkSignAccountId },
                { "receiverAddress", ethAddress },
                { "subAccountId", subAccountId },
                { "receiverSubAccountId", subAccountId },
                { "tokenId", tokenId },
                { "amount", ((object)amountNumber).ToString() },
                { "fee", "0" },
                { "nonce", clientOrderId },
                { "timestampSeconds", expireTime },
                { "isContract", true },
            };
            object signature = await this.getZKTransferSignatureObj(this.remove0xPrefix(this.getSeeds()), orderToSign);
            object request = new Dictionary<string, object>() {
                { "amount", amount },
                { "expireTime", expireTime },
                { "clientWithdrawId", clientOrderId },
                { "signature", signature },
                { "token", code },
                { "ethAddress", ethAddress },
            };
            object response = await this.privatePostV3ContractTransferOut(this.extend(request, parameters));
            object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
            object currentTime = this.milliseconds();
            return this.extend(this.parseTransfer(data, this.currency(code)), new Dictionary<string, object>() {
                { "timestamp", currentTime },
                { "datetime", this.iso8601(currentTime) },
                { "amount", this.parseNumber(amount) },
                { "fromAccount", "contract" },
                { "toAccount", "spot" },
            });
        } else
        {
            object orderToSign = new Dictionary<string, object>() {
                { "zkAccountId", zkAccountId },
                { "receiverAddress", receiverAddress },
                { "subAccountId", subAccountId },
                { "receiverSubAccountId", receiverSubAccountId },
                { "tokenId", tokenId },
                { "amount", ((object)amountNumber).ToString() },
                { "fee", "0" },
                { "nonce", nonce },
                { "timestampSeconds", timestampSeconds },
            };
            object signature = await this.getZKTransferSignatureObj(this.remove0xPrefix(this.getSeeds()), orderToSign);
            object request = new Dictionary<string, object>() {
                { "amount", ((object)amount).ToString() },
                { "timestamp", timestampSeconds },
                { "clientTransferId", clientOrderId },
                { "signature", signature },
                { "zkAccountId", zkAccountId },
                { "subAccountId", subAccountId },
                { "fee", "0" },
                { "token", code },
                { "tokenId", tokenId },
                { "receiverAccountId", receiverAccountId },
                { "receiverZkAccountId", receiverZkAccountId },
                { "receiverSubAccountId", receiverSubAccountId },
                { "receiverAddress", receiverAddress },
                { "nonce", nonce },
            };
            object response = await this.privatePostV3TransferOut(this.extend(request, parameters));
            object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
            object currentTime = this.milliseconds();
            return this.extend(this.parseTransfer(data, this.currency(code)), new Dictionary<string, object>() {
                { "timestamp", currentTime },
                { "datetime", this.iso8601(currentTime) },
                { "amount", this.parseNumber(amount) },
                { "fromAccount", "spot" },
                { "toAccount", "contract" },
            });
        }
    }

    public override object parseTransfer(object transfer, object currency = null)
    {
        object currencyId = this.safeString(transfer, "coin");
        object timestamp = this.safeInteger(transfer, "timestamp");
        object fromAccount = this.safeString(transfer, "fromAccount");
        object toAccount = this.safeString(transfer, "toAccount");
        return new Dictionary<string, object>() {
            { "info", transfer },
            { "id", this.safeStringN(transfer, new List<object>() {"transferId", "id"}) },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "currency", this.safeCurrencyCode(currencyId, currency) },
            { "amount", this.safeNumber(transfer, "amount") },
            { "fromAccount", fromAccount },
            { "toAccount", toAccount },
            { "status", this.safeString(transfer, "status") },
        };
    }

    /**
     * @method
     * @name apex#cancelAllOrders
     * @description cancel all open orders in a market
     * @see https://api-docs.pro.apex.exchange/#privateapi-v3-for-omni-post-cancel-all-open-orders
     * @param {string} symbol unified market symbol of the market to cancel orders in
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> cancelAllOrders(object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = null;
        object request = new Dictionary<string, object>() {};
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
        }
        object response = await this.privatePostV3DeleteOpenOrders(this.extend(request, parameters));
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        return data;
    }

    /**
     * @method
     * @name apex#cancelOrder
     * @description cancels an open order
     * @see https://api-docs.pro.apex.exchange/#privateapi-v3-for-omni-post-cancel-order
     * @param {string} id order id
     * @param symbol
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> cancelOrder(object id, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object request = new Dictionary<string, object>() {};
        object clientOrderId = this.safeStringN(parameters, new List<object>() {"clientId", "clientOrderId", "client_order_id"});
        object response = null;
        if (isTrue(!isEqual(clientOrderId, null)))
        {
            ((IDictionary<string,object>)request)["id"] = clientOrderId;
            parameters = this.omit(parameters, new List<object>() {"clientId", "clientOrderId", "client_order_id"});
            response = await this.privatePostV3DeleteClientOrderId(this.extend(request, parameters));
        } else
        {
            ((IDictionary<string,object>)request)["id"] = id;
            response = await this.privatePostV3DeleteOrder(this.extend(request, parameters));
        }
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        return data;
    }

    /**
     * @method
     * @name apex#fetchOrder
     * @description fetches information on an order made by the user
     * @see https://api-docs.pro.apex.exchange/#privateapi-v3-for-omni-get-order-id
     * @see https://api-docs.pro.apex.exchange/#privateapi-v3-for-omni-get-order-by-clientorderid
     * @param {string} id the order id
     * @param {string} symbol unified symbol of the market the order was made in
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.clientOrderId] a unique id for the order
     * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> fetchOrder(object id, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object clientOrderId = this.safeStringN(parameters, new List<object>() {"clientId", "clientOrderId", "client_order_id"});
        object response = null;
        if (isTrue(!isEqual(clientOrderId, null)))
        {
            ((IDictionary<string,object>)request)["id"] = clientOrderId;
            parameters = this.omit(parameters, new List<object>() {"clientId", "clientOrderId", "client_order_id"});
            response = await this.privateGetV3OrderByClientOrderId(this.extend(request, parameters));
        } else
        {
            ((IDictionary<string,object>)request)["id"] = id;
            response = await this.privateGetV3Order(this.extend(request, parameters));
        }
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        return this.parseOrder(data);
    }

    /**
     * @method
     * @name apex#fetchOpenOrders
     * @description fetches information on multiple orders made by the user
     * @see https://api-docs.pro.apex.exchange/#privateapi-v3-for-omni-get-open-orders
     * @param {string} symbol unified market symbol of the market orders were made in
     * @param {int} [since] the earliest time in ms to fetch orders for
     * @param {int} [limit] the maximum number of order structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> fetchOpenOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.privateGetV3OpenOrders(parameters);
        object orders = this.safeList(response, "data", new List<object>() {});
        return this.parseOrders(orders, null, since, limit);
    }

    /**
     * @method
     * @name apex#fetchOrders
     * @description fetches information on multiple orders made by the user *classic accounts only*
     * @see https://api-docs.pro.apex.exchange/#privateapi-v3-for-omni-get-all-order-history
     * @param {string} symbol unified market symbol of the market orders were made in
     * @param {int} [since] the earliest time in ms to fetch orders for
     * @param {int} [limit] the maximum number of order structures to retrieve, default 100
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {object} [params.until] end time, ms
     * @param {boolean} [params.status] "PENDING", "OPEN", "FILLED", "CANCELED", "EXPIRED", "UNTRIGGERED"
     * @param {boolean} [params.side] BUY or SELL
     * @param {string} [params.type] "LIMIT", "MARKET","STOP_LIMIT", "STOP_MARKET", "TAKE_PROFIT_LIMIT","TAKE_PROFIT_MARKET"
     * @param {string} [params.orderType] "ACTIVE","CONDITION","HISTORY"
     * @param {boolean} [params.page] Page numbers start from 0
     * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> fetchOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["beginTimeInclusive"] = since;
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        object endTimeExclusive = this.safeIntegerN(parameters, new List<object>() {"endTime", "endTimeExclusive", "until"});
        if (isTrue(!isEqual(endTimeExclusive, null)))
        {
            ((IDictionary<string,object>)request)["endTimeExclusive"] = endTimeExclusive;
            parameters = this.omit(parameters, new List<object>() {"endTime", "endTimeExclusive", "until"});
        }
        object response = await this.privateGetV3HistoryOrders(this.extend(request, parameters));
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        object orders = this.safeList(data, "orders", new List<object>() {});
        return this.parseOrders(orders, market, since, limit);
    }

    /**
     * @method
     * @name apex#fetchOrderTrades
     * @description fetch all the trades made from a single order
     * @see https://api-docs.pro.apex.exchange/#privateapi-v3-for-omni-get-trade-history
     * @param {string} id order id
     * @param {string} symbol unified market symbol
     * @param {int} [since] the earliest time in ms to fetch trades for
     * @param {int} [limit] the maximum number of trades to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
     */
    public async override Task<object> fetchOrderTrades(object id, object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object clientOrderId = this.safeString2(parameters, "clientOrderId", "clientId");
        if (isTrue(!isEqual(clientOrderId, null)))
        {
            ((IDictionary<string,object>)request)["clientOrderId"] = clientOrderId;
        } else
        {
            ((IDictionary<string,object>)request)["orderId"] = id;
        }
        parameters = this.omit(parameters, new List<object>() {"clientOrderId", "clientId"});
        object response = await this.privateGetV3OrderFills(this.extend(request, parameters));
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        object orders = this.safeList(data, "orders", new List<object>() {});
        return this.parseTrades(orders, null, since, limit);
    }

    /**
     * @method
     * @name apex#fetchMyTrades
     * @description fetches information on multiple orders made by the user *classic accounts only*
     * @see https://api-docs.pro.apex.exchange/#privateapi-v3-for-omni-get-trade-history
     * @param {string} symbol unified market symbol of the market orders were made in
     * @param {int} [since] the earliest time in ms to fetch orders for
     * @param {int} [limit] the maximum number of order structures to retrieve, default 100
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {object} [params.until] end time
     * @param {boolean} [params.side] BUY or SELL
     * @param {string} [params.orderType] "LIMIT", "MARKET","STOP_LIMIT", "STOP_MARKET", "TAKE_PROFIT_LIMIT","TAKE_PROFIT_MARKET"
     * @param {boolean} [params.page] Page numbers start from 0
     * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
     */
    public async override Task<object> fetchMyTrades(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["beginTimeInclusive"] = since;
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        object endTimeExclusive = this.safeIntegerN(parameters, new List<object>() {"endTime", "endTimeExclusive", "until"});
        if (isTrue(!isEqual(endTimeExclusive, null)))
        {
            ((IDictionary<string,object>)request)["endTimeExclusive"] = endTimeExclusive;
            parameters = this.omit(parameters, new List<object>() {"endTime", "endTimeExclusive", "until"});
        }
        object response = await this.privateGetV3Fills(this.extend(request, parameters));
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        object orders = this.safeList(data, "orders", new List<object>() {});
        return this.parseTrades(orders, market, since, limit);
    }

    /**
     * @method
     * @name apex#fetchFundingHistory
     * @description fetches information on multiple orders made by the user *classic accounts only*
     * @see https://api-docs.pro.apex.exchange/#privateapi-v3-for-omni-get-funding-rate
     * @param {string} symbol unified market symbol of the market orders were made in
     * @param {int} [since] the earliest time in ms to fetch orders for
     * @param {int} [limit] the maximum number of order structures to retrieve, default 100
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {object} [params.until] end time, ms
     * @param {boolean} [params.side] BUY or SELL
     * @param {boolean} [params.page] Page numbers start from 0
     * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=funding-history-structure}
     */
    public async override Task<object> fetchFundingHistory(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["beginTimeInclusive"] = since;
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        object endTimeExclusive = this.safeIntegerN(parameters, new List<object>() {"endTime", "endTimeExclusive", "until"});
        if (isTrue(!isEqual(endTimeExclusive, null)))
        {
            parameters = this.omit(parameters, new List<object>() {"endTime", "endTimeExclusive", "until"});
            ((IDictionary<string,object>)request)["endTimeExclusive"] = endTimeExclusive;
        }
        object response = await this.privateGetV3Funding(this.extend(request, parameters));
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        object fundingValues = this.safeList(data, "fundingValues", new List<object>() {});
        return this.parseIncomes(fundingValues, market, since, limit);
    }

    public override object parseIncome(object income, object market = null)
    {
        //
        // {
        //     "id": "1234",
        //     "symbol": "BTC-USDT",
        //     "fundingValue": "10000",
        //     "rate": "0.0000125000",
        //     "positionSize": "500",
        //     "price": "90",
        //     "side": "LONG",
        //     "status": "SUCCESS",
        //     "fundingTime": 1647502440973,
        //     "transactionId": "1234556"
        // }
        //
        object marketId = this.safeString(income, "symbol");
        market = this.safeMarket(marketId, market, null, "contract");
        object code = "USDT";
        object timestamp = this.safeInteger(income, "fundingTime");
        return new Dictionary<string, object>() {
            { "info", income },
            { "symbol", this.safeSymbol(marketId, market) },
            { "code", code },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "id", this.safeString(income, "id") },
            { "amount", this.safeNumber(income, "fundingValue") },
            { "rate", this.safeNumber(income, "rate") },
        };
    }

    /**
     * @method
     * @name apex#setLeverage
     * @description set the level of leverage for a market
     * @see https://api-docs.pro.apex.exchange/#privateapi-v3-for-omni-post-sets-the-initial-margin-rate-of-a-contract
     * @param {float} leverage the rate of leverage
     * @param {string} symbol unified market symbol
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} response from the exchange
     */
    public async override Task<object> setLeverage(object leverage, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " setLeverage() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object leverageString = this.numberToString(leverage);
        object initialMarginRate = Precise.stringDiv("1", leverageString, 4);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
            { "initialMarginRate", initialMarginRate },
        };
        object response = await this.privatePostV3SetInitialMarginRate(this.extend(request, parameters));
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        return data;
    }

    /**
     * @method
     * @name apex#fetchPositions
     * @description fetch all open positions
     * @see https://api-docs.pro.apex.exchange/#privateapi-v3-for-omni-get-retrieve-user-account-data
     * @param {string[]} [symbols] list of unified market symbols
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} a list of [position structure]{@link https://docs.ccxt.com/#/?id=position-structure}
     */
    public async override Task<object> fetchPositions(object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.privateGetV3Account(parameters);
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        object positions = this.safeList(data, "positions", new List<object>() {});
        return this.parsePositions(positions, symbols);
    }

    public override object parsePosition(object position, object market = null)
    {
        //
        // {
        //     "symbol": "BTC-USDT",
        //     "status": "",
        //     "side": "LONG",
        //     "size": "0.000",
        //     "entryPrice": "0.00",
        //     "exitPrice": "",
        //     "createdAt": 1690366452416,
        //     "updatedTime": 1690366452416,
        //     "fee": "0.000000",
        //     "fundingFee": "0.000000",
        //     "lightNumbers": "",
        //     "customInitialMarginRate": "0"
        // }
        object marketId = this.safeString(position, "symbol");
        market = this.safeMarket(marketId, market);
        object symbol = getValue(market, "symbol");
        object side = this.safeStringLower(position, "side");
        object quantity = this.safeString(position, "size");
        object timestamp = this.safeInteger(position, "updatedTime");
        object leverage = 20;
        object customInitialMarginRate = this.safeStringN(position, new List<object>() {"customInitialMarginRate", "customImr"}, "0");
        if (isTrue(!isEqual(this.precisionFromString(customInitialMarginRate), 0)))
        {
            leverage = this.parseToInt(Precise.stringDiv("1", customInitialMarginRate, 4));
        }
        return this.safePosition(new Dictionary<string, object>() {
            { "info", position },
            { "id", this.safeString(position, "id") },
            { "symbol", symbol },
            { "entryPrice", this.safeString(position, "entryPrice") },
            { "markPrice", null },
            { "notional", null },
            { "collateral", null },
            { "unrealizedPnl", null },
            { "side", side },
            { "contracts", this.parseNumber(quantity) },
            { "contractSize", null },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "hedged", null },
            { "maintenanceMargin", null },
            { "maintenanceMarginPercentage", null },
            { "initialMargin", null },
            { "initialMarginPercentage", null },
            { "leverage", leverage },
            { "liquidationPrice", null },
            { "marginRatio", null },
            { "marginMode", null },
            { "percentage", null },
        });
    }

    public override object sign(object path, object api = null, object method = null, object parameters = null, object headers = null, object body = null)
    {
        api ??= "public";
        method ??= "GET";
        parameters ??= new Dictionary<string, object>();
        object url = add(add(this.implodeHostname(getValue(getValue(this.urls, "api"), api)), "/"), path);
        headers = new Dictionary<string, object>() {
            { "User-Agent", "apex-CCXT" },
            { "Accept", "application/json" },
            { "Content-Type", "application/x-www-form-urlencoded" },
        };
        object signPath = add("/api/", path);
        object signBody = body;
        if (isTrue(!isEqual(((string)method).ToUpper(), "POST")))
        {
            if (isTrue(getArrayLength(new List<object>(((IDictionary<string,object>)parameters).Keys))))
            {
                signPath = add(signPath, add("?", this.rawencode(parameters)));
                url = add(url, add("?", this.rawencode(parameters)));
            }
        } else
        {
            object sortedQuery = this.keysort(parameters);
            signBody = this.rawencode(sortedQuery);
        }
        if (isTrue(isEqual(api, "private")))
        {
            this.checkRequiredCredentials();
            object timestamp = ((object)this.milliseconds()).ToString();
            object messageString = add(add(timestamp, ((string)method).ToUpper()), signPath);
            if (isTrue(!isEqual(signBody, null)))
            {
                messageString = add(messageString, signBody);
            }
            object signature = this.hmac(this.encode(messageString), this.encode(this.stringToBase64(this.secret)), sha256, "base64");
            ((IDictionary<string,object>)headers)["APEX-SIGNATURE"] = signature;
            ((IDictionary<string,object>)headers)["APEX-API-KEY"] = this.apiKey;
            ((IDictionary<string,object>)headers)["APEX-TIMESTAMP"] = timestamp;
            ((IDictionary<string,object>)headers)["APEX-PASSPHRASE"] = this.password;
        }
        return new Dictionary<string, object>() {
            { "url", url },
            { "method", method },
            { "body", signBody },
            { "headers", headers },
        };
    }

    public override object handleErrors(object code, object reason, object url, object method, object headers, object body, object response, object requestHeaders, object requestBody)
    {
        //
        // {"code":3,"msg":"Order price must be greater than 0. Order price is 0.","key":"ORDER_PRICE_MUST_GREETER_ZERO","detail":{"price":"0"}}
        // {"code":400,"msg":"strconv.ParseInt: parsing \"dsfdfsd\": invalid syntax","timeCost":5320995}
        //
        if (isTrue(isEqual(response, null)))
        {
            return null;
        }
        object errorCode = this.safeInteger(response, "code");
        if (isTrue(isTrue(!isEqual(errorCode, null)) && isTrue(!isEqual(errorCode, 0))))
        {
            object feedback = add(add(this.id, " "), body);
            object message = this.safeString2(response, "key", "msg");
            this.throwBroadlyMatchedException(getValue(this.exceptions, "broad"), message, feedback);
            object status = ((object)code).ToString();
            this.throwExactlyMatchedException(getValue(this.exceptions, "exact"), status, feedback);
            throw new ExchangeError ((string)feedback) ;
        }
        return null;
    }
}
