namespace ccxt;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

public partial class coinbase : Exchange
{
    public override object describe()
    {
        return this.deepExtend(base.describe(), new Dictionary<string, object>() {
            { "id", "coinbase" },
            { "name", "Coinbase Advanced" },
            { "countries", new List<object>() {"US"} },
            { "pro", true },
            { "certified", true },
            { "rateLimit", 34 },
            { "version", "v2" },
            { "userAgent", getValue(this.userAgents, "chrome") },
            { "headers", new Dictionary<string, object>() {
                { "CB-VERSION", "2018-05-30" },
            } },
            { "has", new Dictionary<string, object>() {
                { "CORS", true },
                { "spot", true },
                { "margin", false },
                { "swap", false },
                { "future", false },
                { "option", false },
                { "addMargin", false },
                { "cancelOrder", true },
                { "cancelOrders", true },
                { "closeAllPositions", false },
                { "closePosition", true },
                { "createConvertTrade", true },
                { "createDepositAddress", true },
                { "createLimitBuyOrder", true },
                { "createLimitSellOrder", true },
                { "createMarketBuyOrder", true },
                { "createMarketBuyOrderWithCost", true },
                { "createMarketOrderWithCost", false },
                { "createMarketSellOrder", true },
                { "createMarketSellOrderWithCost", false },
                { "createOrder", true },
                { "createPostOnlyOrder", true },
                { "createReduceOnlyOrder", false },
                { "createStopLimitOrder", true },
                { "createStopMarketOrder", false },
                { "createStopOrder", true },
                { "deposit", true },
                { "editOrder", true },
                { "fetchAccounts", true },
                { "fetchBalance", true },
                { "fetchBidsAsks", true },
                { "fetchBorrowRateHistories", false },
                { "fetchBorrowRateHistory", false },
                { "fetchCanceledOrders", true },
                { "fetchClosedOrders", true },
                { "fetchConvertQuote", true },
                { "fetchConvertTrade", true },
                { "fetchConvertTradeHistory", false },
                { "fetchCrossBorrowRate", false },
                { "fetchCrossBorrowRates", false },
                { "fetchCurrencies", true },
                { "fetchDeposit", true },
                { "fetchDepositAddress", "emulated" },
                { "fetchDepositAddresses", false },
                { "fetchDepositAddressesByNetwork", true },
                { "fetchDeposits", true },
                { "fetchFundingHistory", false },
                { "fetchFundingRate", false },
                { "fetchFundingRateHistory", false },
                { "fetchFundingRates", false },
                { "fetchIndexOHLCV", false },
                { "fetchIsolatedBorrowRate", false },
                { "fetchIsolatedBorrowRates", false },
                { "fetchL2OrderBook", false },
                { "fetchLedger", true },
                { "fetchLeverage", false },
                { "fetchLeverageTiers", false },
                { "fetchMarginMode", false },
                { "fetchMarkets", true },
                { "fetchMarkOHLCV", false },
                { "fetchMyBuys", true },
                { "fetchMySells", true },
                { "fetchMyTrades", true },
                { "fetchOHLCV", true },
                { "fetchOpenInterestHistory", false },
                { "fetchOpenOrders", true },
                { "fetchOrder", true },
                { "fetchOrderBook", true },
                { "fetchOrders", true },
                { "fetchPosition", true },
                { "fetchPositionMode", false },
                { "fetchPositions", true },
                { "fetchPositionsRisk", false },
                { "fetchPremiumIndexOHLCV", false },
                { "fetchTicker", true },
                { "fetchTickers", true },
                { "fetchTime", true },
                { "fetchTrades", true },
                { "fetchTradingFee", false },
                { "fetchTradingFees", false },
                { "fetchWithdrawals", true },
                { "reduceMargin", false },
                { "setLeverage", false },
                { "setMarginMode", false },
                { "setPositionMode", false },
                { "withdraw", true },
            } },
            { "urls", new Dictionary<string, object>() {
                { "logo", "https://user-images.githubusercontent.com/1294454/40811661-b6eceae2-653a-11e8-829e-10bfadb078cf.jpg" },
                { "api", new Dictionary<string, object>() {
                    { "rest", "https://api.coinbase.com" },
                } },
                { "www", "https://www.coinbase.com" },
                { "doc", new List<object>() {"https://developers.coinbase.com/api/v2", "https://docs.cloud.coinbase.com/advanced-trade-api/docs/welcome"} },
                { "fees", new List<object>() {"https://support.coinbase.com/customer/portal/articles/2109597-buy-sell-bank-transfer-fees", "https://www.coinbase.com/advanced-fees"} },
                { "referral", "https://www.coinbase.com/join/58cbe25a355148797479dbd2" },
            } },
            { "requiredCredentials", new Dictionary<string, object>() {
                { "apiKey", true },
                { "secret", true },
            } },
            { "api", new Dictionary<string, object>() {
                { "v2", new Dictionary<string, object>() {
                    { "public", new Dictionary<string, object>() {
                        { "get", new Dictionary<string, object>() {
                            { "currencies", 10.6 },
                            { "currencies/crypto", 10.6 },
                            { "time", 10.6 },
                            { "exchange-rates", 10.6 },
                            { "users/{user_id}", 10.6 },
                            { "prices/{symbol}/buy", 10.6 },
                            { "prices/{symbol}/sell", 10.6 },
                            { "prices/{symbol}/spot", 10.6 },
                        } },
                    } },
                    { "private", new Dictionary<string, object>() {
                        { "get", new Dictionary<string, object>() {
                            { "accounts", 10.6 },
                            { "accounts/{account_id}", 10.6 },
                            { "accounts/{account_id}/addresses", 10.6 },
                            { "accounts/{account_id}/addresses/{address_id}", 10.6 },
                            { "accounts/{account_id}/addresses/{address_id}/transactions", 10.6 },
                            { "accounts/{account_id}/transactions", 10.6 },
                            { "accounts/{account_id}/transactions/{transaction_id}", 10.6 },
                            { "accounts/{account_id}/buys", 10.6 },
                            { "accounts/{account_id}/buys/{buy_id}", 10.6 },
                            { "accounts/{account_id}/sells", 10.6 },
                            { "accounts/{account_id}/sells/{sell_id}", 10.6 },
                            { "accounts/{account_id}/deposits", 10.6 },
                            { "accounts/{account_id}/deposits/{deposit_id}", 10.6 },
                            { "accounts/{account_id}/withdrawals", 10.6 },
                            { "accounts/{account_id}/withdrawals/{withdrawal_id}", 10.6 },
                            { "payment-methods", 10.6 },
                            { "payment-methods/{payment_method_id}", 10.6 },
                            { "user", 10.6 },
                            { "user/auth", 10.6 },
                        } },
                        { "post", new Dictionary<string, object>() {
                            { "accounts", 10.6 },
                            { "accounts/{account_id}/primary", 10.6 },
                            { "accounts/{account_id}/addresses", 10.6 },
                            { "accounts/{account_id}/transactions", 10.6 },
                            { "accounts/{account_id}/transactions/{transaction_id}/complete", 10.6 },
                            { "accounts/{account_id}/transactions/{transaction_id}/resend", 10.6 },
                            { "accounts/{account_id}/buys", 10.6 },
                            { "accounts/{account_id}/buys/{buy_id}/commit", 10.6 },
                            { "accounts/{account_id}/sells", 10.6 },
                            { "accounts/{account_id}/sells/{sell_id}/commit", 10.6 },
                            { "accounts/{account_id}/deposits", 10.6 },
                            { "accounts/{account_id}/deposits/{deposit_id}/commit", 10.6 },
                            { "accounts/{account_id}/withdrawals", 10.6 },
                            { "accounts/{account_id}/withdrawals/{withdrawal_id}/commit", 10.6 },
                        } },
                        { "put", new Dictionary<string, object>() {
                            { "accounts/{account_id}", 10.6 },
                            { "user", 10.6 },
                        } },
                        { "delete", new Dictionary<string, object>() {
                            { "accounts/{id}", 10.6 },
                            { "accounts/{account_id}/transactions/{transaction_id}", 10.6 },
                        } },
                    } },
                } },
                { "v3", new Dictionary<string, object>() {
                    { "public", new Dictionary<string, object>() {
                        { "get", new Dictionary<string, object>() {
                            { "brokerage/time", 3 },
                            { "brokerage/market/product_book", 3 },
                            { "brokerage/market/products", 3 },
                            { "brokerage/market/products/{product_id}", 3 },
                            { "brokerage/market/products/{product_id}/candles", 3 },
                            { "brokerage/market/products/{product_id}/ticker", 3 },
                        } },
                    } },
                    { "private", new Dictionary<string, object>() {
                        { "get", new Dictionary<string, object>() {
                            { "brokerage/accounts", 1 },
                            { "brokerage/accounts/{account_uuid}", 1 },
                            { "brokerage/orders/historical/batch", 1 },
                            { "brokerage/orders/historical/fills", 1 },
                            { "brokerage/orders/historical/{order_id}", 1 },
                            { "brokerage/products", 3 },
                            { "brokerage/products/{product_id}", 3 },
                            { "brokerage/products/{product_id}/candles", 3 },
                            { "brokerage/products/{product_id}/ticker", 3 },
                            { "brokerage/best_bid_ask", 3 },
                            { "brokerage/product_book", 3 },
                            { "brokerage/transaction_summary", 3 },
                            { "brokerage/portfolios", 1 },
                            { "brokerage/portfolios/{portfolio_uuid}", 1 },
                            { "brokerage/convert/trade/{trade_id}", 1 },
                            { "brokerage/cfm/balance_summary", 1 },
                            { "brokerage/cfm/positions", 1 },
                            { "brokerage/cfm/positions/{product_id}", 1 },
                            { "brokerage/cfm/sweeps", 1 },
                            { "brokerage/intx/portfolio/{portfolio_uuid}", 1 },
                            { "brokerage/intx/positions/{portfolio_uuid}", 1 },
                            { "brokerage/intx/positions/{portfolio_uuid}/{symbol}", 1 },
                            { "brokerage/payment_methods", 1 },
                            { "brokerage/payment_methods/{payment_method_id}", 1 },
                        } },
                        { "post", new Dictionary<string, object>() {
                            { "brokerage/orders", 1 },
                            { "brokerage/orders/batch_cancel", 1 },
                            { "brokerage/orders/edit", 1 },
                            { "brokerage/orders/edit_preview", 1 },
                            { "brokerage/orders/preview", 1 },
                            { "brokerage/portfolios", 1 },
                            { "brokerage/portfolios/move_funds", 1 },
                            { "brokerage/convert/quote", 1 },
                            { "brokerage/convert/trade/{trade_id}", 1 },
                            { "brokerage/cfm/sweeps/schedule", 1 },
                            { "brokerage/intx/allocate", 1 },
                            { "brokerage/orders/close_position", 1 },
                        } },
                        { "put", new Dictionary<string, object>() {
                            { "brokerage/portfolios/{portfolio_uuid}", 1 },
                        } },
                        { "delete", new Dictionary<string, object>() {
                            { "brokerage/portfolios/{portfolio_uuid}", 1 },
                            { "brokerage/cfm/sweeps", 1 },
                        } },
                    } },
                } },
            } },
            { "fees", new Dictionary<string, object>() {
                { "trading", new Dictionary<string, object>() {
                    { "taker", this.parseNumber("0.006") },
                    { "maker", this.parseNumber("0.004") },
                    { "tierBased", true },
                    { "percentage", true },
                    { "tiers", new Dictionary<string, object>() {
                        { "taker", new List<object>() {new List<object> {this.parseNumber("0"), this.parseNumber("0.006")}, new List<object> {this.parseNumber("10000"), this.parseNumber("0.004")}, new List<object> {this.parseNumber("50000"), this.parseNumber("0.0025")}, new List<object> {this.parseNumber("100000"), this.parseNumber("0.002")}, new List<object> {this.parseNumber("1000000"), this.parseNumber("0.0018")}, new List<object> {this.parseNumber("15000000"), this.parseNumber("0.0016")}, new List<object> {this.parseNumber("75000000"), this.parseNumber("0.0012")}, new List<object> {this.parseNumber("250000000"), this.parseNumber("0.0008")}, new List<object> {this.parseNumber("400000000"), this.parseNumber("0.0005")}} },
                        { "maker", new List<object>() {new List<object> {this.parseNumber("0"), this.parseNumber("0.004")}, new List<object> {this.parseNumber("10000"), this.parseNumber("0.0025")}, new List<object> {this.parseNumber("50000"), this.parseNumber("0.0015")}, new List<object> {this.parseNumber("100000"), this.parseNumber("0.001")}, new List<object> {this.parseNumber("1000000"), this.parseNumber("0.0008")}, new List<object> {this.parseNumber("15000000"), this.parseNumber("0.0006")}, new List<object> {this.parseNumber("75000000"), this.parseNumber("0.0003")}, new List<object> {this.parseNumber("250000000"), this.parseNumber("0.0")}, new List<object> {this.parseNumber("400000000"), this.parseNumber("0.0")}} },
                    } },
                } },
            } },
            { "precisionMode", TICK_SIZE },
            { "exceptions", new Dictionary<string, object>() {
                { "exact", new Dictionary<string, object>() {
                    { "two_factor_required", typeof(AuthenticationError) },
                    { "param_required", typeof(ExchangeError) },
                    { "validation_error", typeof(ExchangeError) },
                    { "invalid_request", typeof(ExchangeError) },
                    { "personal_details_required", typeof(AuthenticationError) },
                    { "identity_verification_required", typeof(AuthenticationError) },
                    { "jumio_verification_required", typeof(AuthenticationError) },
                    { "jumio_face_match_verification_required", typeof(AuthenticationError) },
                    { "unverified_email", typeof(AuthenticationError) },
                    { "authentication_error", typeof(AuthenticationError) },
                    { "invalid_authentication_method", typeof(AuthenticationError) },
                    { "invalid_token", typeof(AuthenticationError) },
                    { "revoked_token", typeof(AuthenticationError) },
                    { "expired_token", typeof(AuthenticationError) },
                    { "invalid_scope", typeof(AuthenticationError) },
                    { "not_found", typeof(ExchangeError) },
                    { "rate_limit_exceeded", typeof(RateLimitExceeded) },
                    { "internal_server_error", typeof(ExchangeError) },
                    { "UNSUPPORTED_ORDER_CONFIGURATION", typeof(BadRequest) },
                    { "INSUFFICIENT_FUND", typeof(BadRequest) },
                    { "PERMISSION_DENIED", typeof(PermissionDenied) },
                    { "INVALID_ARGUMENT", typeof(BadRequest) },
                } },
                { "broad", new Dictionary<string, object>() {
                    { "request timestamp expired", typeof(InvalidNonce) },
                    { "order with this orderID was not found", typeof(OrderNotFound) },
                } },
            } },
            { "timeframes", new Dictionary<string, object>() {
                { "1m", "ONE_MINUTE" },
                { "5m", "FIVE_MINUTE" },
                { "15m", "FIFTEEN_MINUTE" },
                { "30m", "THIRTY_MINUTE" },
                { "1h", "ONE_HOUR" },
                { "2h", "TWO_HOUR" },
                { "6h", "SIX_HOUR" },
                { "1d", "ONE_DAY" },
            } },
            { "commonCurrencies", new Dictionary<string, object>() {
                { "CGLD", "CELO" },
            } },
            { "options", new Dictionary<string, object>() {
                { "brokerId", "ccxt" },
                { "stablePairs", new List<object>() {"BUSD-USD", "CBETH-ETH", "DAI-USD", "GUSD-USD", "GYEN-USD", "PAX-USD", "PAX-USDT", "USDC-EUR", "USDC-GBP", "USDT-EUR", "USDT-GBP", "USDT-USD", "USDT-USDC", "WBTC-BTC"} },
                { "fetchCurrencies", new Dictionary<string, object>() {
                    { "expires", 5000 },
                } },
                { "accounts", new List<object>() {"wallet", "fiat"} },
                { "v3Accounts", new List<object>() {"ACCOUNT_TYPE_CRYPTO", "ACCOUNT_TYPE_FIAT"} },
                { "networks", new Dictionary<string, object>() {
                    { "ERC20", "ethereum" },
                    { "XLM", "stellar" },
                } },
                { "createMarketBuyOrderRequiresPrice", true },
                { "advanced", true },
                { "fetchMarkets", "fetchMarketsV3" },
                { "fetchTicker", "fetchTickerV3" },
                { "fetchTickers", "fetchTickersV3" },
                { "fetchAccounts", "fetchAccountsV3" },
                { "fetchBalance", "v2PrivateGetAccounts" },
                { "fetchTime", "v2PublicGetTime" },
                { "user_native_currency", "USD" },
            } },
        });
    }

    public async override Task<object> fetchTime(object parameters = null)
    {
        /**
        * @method
        * @name coinbase#fetchTime
        * @description fetches the current integer timestamp in milliseconds from the exchange server
        * @see https://docs.cloud.coinbase.com/sign-in-with-coinbase/docs/api-time#http-request
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {string} [params.method] 'v2PublicGetTime' or 'v3PublicGetBrokerageTime' default is 'v2PublicGetTime'
        * @returns {int} the current integer timestamp in milliseconds from the exchange server
        */
        parameters ??= new Dictionary<string, object>();
        object defaultMethod = this.safeString(this.options, "fetchTime", "v2PublicGetTime");
        object method = this.safeString(parameters, "method", defaultMethod);
        parameters = this.omit(parameters, "method");
        object response = null;
        if (isTrue(isEqual(method, "v2PublicGetTime")))
        {
            response = await this.v2PublicGetTime(parameters);
            //
            //     {
            //         "data": {
            //             "epoch": 1589295679,
            //             "iso": "2020-05-12T15:01:19Z"
            //         }
            //     }
            //
            response = this.safeDict(response, "data", new Dictionary<string, object>() {});
        } else
        {
            response = await this.v3PublicGetBrokerageTime(parameters);
        }
        return this.safeTimestamp2(response, "epoch", "epochSeconds");
    }

    public async override Task<object> fetchAccounts(object parameters = null)
    {
        /**
        * @method
        * @name coinbase#fetchAccounts
        * @description fetch all the accounts associated with a profile
        * @see https://docs.cloud.coinbase.com/advanced-trade-api/reference/retailbrokerageapi_getaccounts
        * @see https://docs.cloud.coinbase.com/sign-in-with-coinbase/docs/api-accounts#list-accounts
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [availble parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
        * @returns {object} a dictionary of [account structures]{@link https://docs.ccxt.com/#/?id=account-structure} indexed by the account type
        */
        parameters ??= new Dictionary<string, object>();
        object method = this.safeString(this.options, "fetchAccounts", "fetchAccountsV3");
        if (isTrue(isEqual(method, "fetchAccountsV3")))
        {
            return await this.fetchAccountsV3(parameters);
        }
        return await this.fetchAccountsV2(parameters);
    }

    public async virtual Task<object> fetchAccountsV2(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object paginate = false;
        var paginateparametersVariable = this.handleOptionAndParams(parameters, "fetchAccounts", "paginate");
        paginate = ((IList<object>)paginateparametersVariable)[0];
        parameters = ((IList<object>)paginateparametersVariable)[1];
        if (isTrue(paginate))
        {
            return await this.fetchPaginatedCallCursor("fetchAccounts", null, null, null, parameters, "next_starting_after", "starting_after", null, 100);
        }
        object request = new Dictionary<string, object>() {
            { "limit", 100 },
        };
        object response = await this.v2PrivateGetAccounts(this.extend(request, parameters));
        //
        //     {
        //         "pagination": {
        //             "ending_before": null,
        //             "starting_after": null,
        //             "previous_ending_before": null,
        //             "next_starting_after": null,
        //             "limit": 244,
        //             "order": "desc",
        //             "previous_uri": null,
        //             "next_uri": null
        //         },
        //         "data": [
        //             {
        //                 "id": "XLM",
        //                 "name": "XLM Wallet",
        //                 "primary": false,
        //                 "type": "wallet",
        //                 "currency": {
        //                     "code": "XLM",
        //                     "name": "Stellar Lumens",
        //                     "color": "#000000",
        //                     "sort_index": 127,
        //                     "exponent": 7,
        //                     "type": "crypto",
        //                     "address_regex": "^G[A-Z2-7]{55}$",
        //                     "asset_id": "13b83335-5ede-595b-821e-5bcdfa80560f",
        //                     "destination_tag_name": "XLM Memo ID",
        //                     "destination_tag_regex": "^[ -~]{1,28}$"
        //                 },
        //                 "balance": {
        //                     "amount": "0.0000000",
        //                     "currency": "XLM"
        //                 },
        //                 "created_at": null,
        //                 "updated_at": null,
        //                 "resource": "account",
        //                 "resource_path": "/v2/accounts/XLM",
        //                 "allow_deposits": true,
        //                 "allow_withdrawals": true
        //             },
        //         ]
        //     }
        //
        object data = this.safeList(response, "data", new List<object>() {});
        object pagination = this.safeDict(response, "pagination", new Dictionary<string, object>() {});
        object cursor = this.safeString(pagination, "next_starting_after");
        object accounts = this.safeList(response, "data", new List<object>() {});
        object length = getArrayLength(accounts);
        object lastIndex = subtract(length, 1);
        object last = this.safeDict(accounts, lastIndex);
        if (isTrue(isTrue((!isEqual(cursor, null))) && isTrue((!isEqual(cursor, "")))))
        {
            ((IDictionary<string,object>)last)["next_starting_after"] = cursor;
            ((List<object>)accounts)[Convert.ToInt32(lastIndex)] = last;
        }
        return this.parseAccounts(data, parameters);
    }

    public async virtual Task<object> fetchAccountsV3(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object paginate = false;
        var paginateparametersVariable = this.handleOptionAndParams(parameters, "fetchAccounts", "paginate");
        paginate = ((IList<object>)paginateparametersVariable)[0];
        parameters = ((IList<object>)paginateparametersVariable)[1];
        if (isTrue(paginate))
        {
            return await this.fetchPaginatedCallCursor("fetchAccounts", null, null, null, parameters, "cursor", "cursor", null, 100);
        }
        object request = new Dictionary<string, object>() {
            { "limit", 100 },
        };
        object response = await this.v3PrivateGetBrokerageAccounts(this.extend(request, parameters));
        //
        //     {
        //         "accounts": [
        //             {
        //                 "uuid": "11111111-1111-1111-1111-111111111111",
        //                 "name": "USDC Wallet",
        //                 "currency": "USDC",
        //                 "available_balance": {
        //                     "value": "0.0000000000000000",
        //                     "currency": "USDC"
        //                 },
        //                 "default": true,
        //                 "active": true,
        //                 "created_at": "2023-01-04T06:20:06.456Z",
        //                 "updated_at": "2023-01-04T06:20:07.181Z",
        //                 "deleted_at": null,
        //                 "type": "ACCOUNT_TYPE_CRYPTO",
        //                 "ready": false,
        //                 "hold": {
        //                     "value": "0.0000000000000000",
        //                     "currency": "USDC"
        //                 }
        //             },
        //             ...
        //         ],
        //         "has_next": false,
        //         "cursor": "",
        //         "size": 9
        //     }
        //
        object accounts = this.safeList(response, "accounts", new List<object>() {});
        object length = getArrayLength(accounts);
        object lastIndex = subtract(length, 1);
        object last = this.safeDict(accounts, lastIndex);
        object cursor = this.safeString(response, "cursor");
        if (isTrue(isTrue((!isEqual(cursor, null))) && isTrue((!isEqual(cursor, "")))))
        {
            ((IDictionary<string,object>)last)["cursor"] = cursor;
            ((List<object>)accounts)[Convert.ToInt32(lastIndex)] = last;
        }
        return this.parseAccounts(accounts, parameters);
    }

    public async virtual Task<object> fetchPortfolios(object parameters = null)
    {
        /**
        * @method
        * @name coinbase#fetchPortfolios
        * @description fetch all the portfolios
        * @see https://docs.cloud.coinbase.com/advanced-trade-api/reference/retailbrokerageapi_getportfolios
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a dictionary of [account structures]{@link https://docs.ccxt.com/#/?id=account-structure} indexed by the account type
        */
        parameters ??= new Dictionary<string, object>();
        object response = await this.v3PrivateGetBrokeragePortfolios(parameters);
        object portfolios = this.safeList(response, "portfolios", new List<object>() {});
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(portfolios)); postFixIncrement(ref i))
        {
            object portfolio = getValue(portfolios, i);
            ((IList<object>)result).Add(new Dictionary<string, object>() {
                { "id", this.safeString(portfolio, "uuid") },
                { "type", this.safeString(portfolio, "type") },
                { "code", null },
                { "info", portfolio },
            });
        }
        return result;
    }

    public override object parseAccount(object account)
    {
        //
        // fetchAccountsV2
        //
        //     {
        //         "id": "XLM",
        //         "name": "XLM Wallet",
        //         "primary": false,
        //         "type": "wallet",
        //         "currency": {
        //             "code": "XLM",
        //             "name": "Stellar Lumens",
        //             "color": "#000000",
        //             "sort_index": 127,
        //             "exponent": 7,
        //             "type": "crypto",
        //             "address_regex": "^G[A-Z2-7]{55}$",
        //             "asset_id": "13b83335-5ede-595b-821e-5bcdfa80560f",
        //             "destination_tag_name": "XLM Memo ID",
        //             "destination_tag_regex": "^[ -~]{1,28}$"
        //         },
        //         "balance": {
        //             "amount": "0.0000000",
        //             "currency": "XLM"
        //         },
        //         "created_at": null,
        //         "updated_at": null,
        //         "resource": "account",
        //         "resource_path": "/v2/accounts/XLM",
        //         "allow_deposits": true,
        //         "allow_withdrawals": true
        //     }
        //
        // fetchAccountsV3
        //
        //     {
        //         "uuid": "11111111-1111-1111-1111-111111111111",
        //         "name": "USDC Wallet",
        //         "currency": "USDC",
        //         "available_balance": {
        //             "value": "0.0000000000000000",
        //             "currency": "USDC"
        //         },
        //         "default": true,
        //         "active": true,
        //         "created_at": "2023-01-04T06:20:06.456Z",
        //         "updated_at": "2023-01-04T06:20:07.181Z",
        //         "deleted_at": null,
        //         "type": "ACCOUNT_TYPE_CRYPTO",
        //         "ready": false,
        //         "hold": {
        //             "value": "0.0000000000000000",
        //             "currency": "USDC"
        //         }
        //     }
        //
        object active = this.safeBool(account, "active");
        object currencyIdV3 = this.safeString(account, "currency");
        object currency = this.safeDict(account, "currency", new Dictionary<string, object>() {});
        object currencyId = this.safeString(currency, "code", currencyIdV3);
        object typeV3 = this.safeString(account, "name");
        object typeV2 = this.safeString(account, "type");
        object parts = ((string)typeV3).Split(new [] {((string)" ")}, StringSplitOptions.None).ToList<object>();
        return new Dictionary<string, object>() {
            { "id", this.safeString2(account, "id", "uuid") },
            { "type", ((bool) isTrue((!isEqual(active, null)))) ? this.safeStringLower(parts, 1) : typeV2 },
            { "code", this.safeCurrencyCode(currencyId) },
            { "info", account },
        };
    }

    public async override Task<object> createDepositAddress(object code, object parameters = null)
    {
        /**
        * @method
        * @name coinbase#createDepositAddress
        * @description create a currency deposit address
        * @see https://docs.cloud.coinbase.com/sign-in-with-coinbase/docs/api-addresses#create-address
        * @param {string} code unified currency code of the currency for the deposit address
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} an [address structure]{@link https://docs.ccxt.com/#/?id=address-structure}
        */
        parameters ??= new Dictionary<string, object>();
        object accountId = this.safeString(parameters, "account_id");
        parameters = this.omit(parameters, "account_id");
        if (isTrue(isEqual(accountId, null)))
        {
            await this.loadAccounts();
            for (object i = 0; isLessThan(i, getArrayLength(this.accounts)); postFixIncrement(ref i))
            {
                object account = getValue(this.accounts, i);
                if (isTrue(isTrue(isEqual(getValue(account, "code"), code)) && isTrue(isEqual(getValue(account, "type"), "wallet"))))
                {
                    accountId = getValue(account, "id");
                    break;
                }
            }
        }
        if (isTrue(isEqual(accountId, null)))
        {
            throw new ExchangeError ((string)add(this.id, " createDepositAddress() could not find the account with matching currency code, specify an `account_id` extra param")) ;
        }
        object request = new Dictionary<string, object>() {
            { "account_id", accountId },
        };
        object response = await this.v2PrivatePostAccountsAccountIdAddresses(this.extend(request, parameters));
        //
        //     {
        //         "data": {
        //             "id": "05b1ebbf-9438-5dd4-b297-2ddedc98d0e4",
        //             "address": "coinbasebase",
        //             "address_info": {
        //                 "address": "coinbasebase",
        //                 "destination_tag": "287594668"
        //             },
        //             "name": null,
        //             "created_at": "2019-07-01T14:39:29Z",
        //             "updated_at": "2019-07-01T14:39:29Z",
        //             "network": "eosio",
        //             "uri_scheme": "eosio",
        //             "resource": "address",
        //             "resource_path": "/v2/accounts/14cfc769-e852-52f3-b831-711c104d194c/addresses/05b1ebbf-9438-5dd4-b297-2ddedc98d0e4",
        //             "warnings": [
        //                 {
        //                     "title": "Only send EOS (EOS) to this address",
        //                     "details": "Sending any other cryptocurrency will result in permanent loss.",
        //                     "image_url": "https://dynamic-assets.coinbase.com/deaca3d47b10ed4a91a872e9618706eec34081127762d88f2476ac8e99ada4b48525a9565cf2206d18c04053f278f693434af4d4629ca084a9d01b7a286a7e26/asset_icons/1f8489bb280fb0a0fd643c1161312ba49655040e9aaaced5f9ad3eeaf868eadc.png"
        //                 },
        //                 {
        //                     "title": "Both an address and EOS memo are required to receive EOS",
        //                     "details": "If you send funds without an EOS memo or with an incorrect EOS memo, your funds cannot be credited to your account.",
        //                     "image_url": "https://www.coinbase.com/assets/receive-warning-2f3269d83547a7748fb39d6e0c1c393aee26669bfea6b9f12718094a1abff155.png"
        //                 }
        //             ],
        //             "warning_title": "Only send EOS (EOS) to this address",
        //             "warning_details": "Sending any other cryptocurrency will result in permanent loss.",
        //             "destination_tag": "287594668",
        //             "deposit_uri": "eosio:coinbasebase?dt=287594668",
        //             "callback_url": null
        //         }
        //     }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        object tag = this.safeString(data, "destination_tag");
        object address = this.safeString(data, "address");
        return new Dictionary<string, object>() {
            { "currency", code },
            { "tag", tag },
            { "address", address },
            { "info", response },
        };
    }

    public async virtual Task<object> fetchMySells(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name coinbase#fetchMySells
        * @ignore
        * @description fetch sells
        * @see https://docs.cloud.coinbase.com/sign-in-with-coinbase/docs/api-sells#list-sells
        * @param {string} symbol not used by coinbase fetchMySells ()
        * @param {int} [since] timestamp in ms of the earliest sell, default is undefined
        * @param {int} [limit] max number of sells to return, default is undefined
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [list of order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        // v2 did't have an endpoint for all historical trades
        parameters ??= new Dictionary<string, object>();
        object request = this.prepareAccountRequest(limit, parameters);
        await this.loadMarkets();
        object query = this.omit(parameters, new List<object>() {"account_id", "accountId"});
        object sells = await this.v2PrivateGetAccountsAccountIdSells(this.extend(request, query));
        return this.parseTrades(getValue(sells, "data"), null, since, limit);
    }

    public async virtual Task<object> fetchMyBuys(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name coinbase#fetchMyBuys
        * @ignore
        * @description fetch buys
        * @see https://docs.cloud.coinbase.com/sign-in-with-coinbase/docs/api-buys#list-buys
        * @param {string} symbol not used by coinbase fetchMyBuys ()
        * @param {int} [since] timestamp in ms of the earliest buy, default is undefined
        * @param {int} [limit] max number of buys to return, default is undefined
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a list of  [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        // v2 did't have an endpoint for all historical trades
        parameters ??= new Dictionary<string, object>();
        object request = this.prepareAccountRequest(limit, parameters);
        await this.loadMarkets();
        object query = this.omit(parameters, new List<object>() {"account_id", "accountId"});
        object buys = await this.v2PrivateGetAccountsAccountIdBuys(this.extend(request, query));
        return this.parseTrades(getValue(buys, "data"), null, since, limit);
    }

    public async virtual Task<object> fetchTransactionsWithMethod(object method, object code = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object request = null;
        var requestparametersVariable = await this.prepareAccountRequestWithCurrencyCode(code, limit, parameters);
        request = ((IList<object>)requestparametersVariable)[0];
        parameters = ((IList<object>)requestparametersVariable)[1];
        await this.loadMarkets();
        object response = await ((Task<object>)callDynamically(this, method, new object[] { this.extend(request, parameters) }));
        return this.parseTransactions(getValue(response, "data"), null, since, limit);
    }

    public async override Task<object> fetchWithdrawals(object code = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name coinbase#fetchWithdrawals
        * @description fetch all withdrawals made from an account
        * @see https://docs.cloud.coinbase.com/sign-in-with-coinbase/docs/api-withdrawals#list-withdrawals
        * @param {string} code unified currency code
        * @param {int} [since] the earliest time in ms to fetch withdrawals for
        * @param {int} [limit] the maximum number of withdrawals structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
        */
        // fiat only, for crypto transactions use fetchLedger
        parameters ??= new Dictionary<string, object>();
        return await this.fetchTransactionsWithMethod("v2PrivateGetAccountsAccountIdWithdrawals", code, since, limit, parameters);
    }

    public async override Task<object> fetchDeposits(object code = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name coinbase#fetchDeposits
        * @description fetch all deposits made to an account
        * @see https://docs.cloud.coinbase.com/sign-in-with-coinbase/docs/api-deposits#list-deposits
        * @param {string} code unified currency code
        * @param {int} [since] the earliest time in ms to fetch deposits for
        * @param {int} [limit] the maximum number of deposits structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
        */
        // fiat only, for crypto transactions use fetchLedger
        parameters ??= new Dictionary<string, object>();
        return await this.fetchTransactionsWithMethod("v2PrivateGetAccountsAccountIdDeposits", code, since, limit, parameters);
    }

    public virtual object parseTransactionStatus(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "created", "pending" },
            { "completed", "ok" },
            { "canceled", "canceled" },
        };
        return this.safeString(statuses, status, status);
    }

    public override object parseTransaction(object transaction, object currency = null)
    {
        //
        // fiat deposit
        //
        //     {
        //         "id": "f34c19f3-b730-5e3d-9f72",
        //         "status": "completed",
        //         "payment_method": {
        //             "id": "a022b31d-f9c7-5043-98f2",
        //             "resource": "payment_method",
        //             "resource_path": "/v2/payment-methods/a022b31d-f9c7-5043-98f2"
        //         },
        //         "transaction": {
        //             "id": "04ed4113-3732-5b0c-af86-b1d2146977d0",
        //             "resource": "transaction",
        //             "resource_path": "/v2/accounts/91cd2d36-3a91-55b6-a5d4-0124cf105483/transactions/04ed4113-3732-5b0c-af86"
        //         },
        //         "user_reference": "2VTYTH",
        //         "created_at": "2017-02-09T07:01:18Z",
        //         "updated_at": "2017-02-09T07:01:26Z",
        //         "resource": "deposit",
        //         "resource_path": "/v2/accounts/91cd2d36-3a91-55b6-a5d4-0124cf105483/deposits/f34c19f3-b730-5e3d-9f72",
        //         "committed": true,
        //         "payout_at": "2017-02-12T07:01:17Z",
        //         "instant": false,
        //         "fee": { "amount": "0.00", "currency": "EUR" },
        //         "amount": { "amount": "114.02", "currency": "EUR" },
        //         "subtotal": { "amount": "114.02", "currency": "EUR" },
        //         "hold_until": null,
        //         "hold_days": 0,
        //         "hold_business_days": 0,
        //         "next_step": null
        //     }
        //
        // fiat_withdrawal
        //
        //     {
        //         "id": "cfcc3b4a-eeb6-5e8c-8058",
        //         "status": "completed",
        //         "payment_method": {
        //             "id": "8b94cfa4-f7fd-5a12-a76a",
        //             "resource": "payment_method",
        //             "resource_path": "/v2/payment-methods/8b94cfa4-f7fd-5a12-a76a"
        //         },
        //         "transaction": {
        //             "id": "fcc2550b-5104-5f83-a444",
        //             "resource": "transaction",
        //             "resource_path": "/v2/accounts/91cd2d36-3a91-55b6-a5d4-0124cf105483/transactions/fcc2550b-5104-5f83-a444"
        //         },
        //         "user_reference": "MEUGK",
        //         "created_at": "2018-07-26T08:55:12Z",
        //         "updated_at": "2018-07-26T08:58:18Z",
        //         "resource": "withdrawal",
        //         "resource_path": "/v2/accounts/91cd2d36-3a91-55b6-a5d4-0124cf105483/withdrawals/cfcc3b4a-eeb6-5e8c-8058",
        //         "committed": true,
        //         "payout_at": "2018-07-31T08:55:12Z",
        //         "instant": false,
        //         "fee": { "amount": "0.15", "currency": "EUR" },
        //         "amount": { "amount": "13130.69", "currency": "EUR" },
        //         "subtotal": { "amount": "13130.84", "currency": "EUR" },
        //         "idem": "e549dee5-63ed-4e79-8a96",
        //         "next_step": null
        //     }
        //
        // withdraw
        //
        //     {
        //         "id": "a1794ecf-5693-55fa-70cf-ef731748ed82",
        //         "type": "send",
        //         "status": "pending",
        //         "amount": {
        //             "amount": "-14.008308",
        //             "currency": "USDC"
        //         },
        //         "native_amount": {
        //             "amount": "-18.74",
        //             "currency": "CAD"
        //         },
        //         "description": null,
        //         "created_at": "2024-01-12T01:27:31Z",
        //         "updated_at": "2024-01-12T01:27:31Z",
        //         "resource": "transaction",
        //         "resource_path": "/v2/accounts/a34bgfad-ed67-538b-bffc-730c98c10da0/transactions/a1794ecf-5693-55fa-70cf-ef731748ed82",
        //         "instant_exchange": false,
        //         "network": {
        //             "status": "pending",
        //             "status_description": "Pending (est. less than 10 minutes)",
        //             "transaction_fee": {
        //                 "amount": "4.008308",
        //                 "currency": "USDC"
        //             },
        //             "transaction_amount": {
        //                 "amount": "10.000000",
        //                 "currency": "USDC"
        //             },
        //             "confirmations": 0
        //         },
        //         "to": {
        //             "resource": "ethereum_address",
        //             "address": "0x9...",
        //             "currency": "USDC",
        //             "address_info": {
        //                 "address": "0x9..."
        //             }
        //         },
        //         "idem": "748d8591-dg9a-7831-a45b-crd61dg78762",
        //         "details": {
        //             "title": "Sent USDC",
        //             "subtitle": "To USDC address on Ethereum network",
        //             "header": "Sent 14.008308 USDC ($18.74)",
        //             "health": "warning"
        //         },
        //         "hide_native_amount": false
        //     }
        //
        object transactionType = this.safeString(transaction, "type");
        object amountAndCurrencyObject = null;
        object feeObject = null;
        if (isTrue(isEqual(transactionType, "send")))
        {
            object network = this.safeDict(transaction, "network", new Dictionary<string, object>() {});
            amountAndCurrencyObject = this.safeDict(network, "transaction_amount", new Dictionary<string, object>() {});
            feeObject = this.safeDict(network, "transaction_fee", new Dictionary<string, object>() {});
        } else
        {
            amountAndCurrencyObject = this.safeDict(transaction, "subtotal", new Dictionary<string, object>() {});
            feeObject = this.safeDict(transaction, "fee", new Dictionary<string, object>() {});
        }
        object status = this.parseTransactionStatus(this.safeString(transaction, "status"));
        if (isTrue(isEqual(status, null)))
        {
            object committed = this.safeBool(transaction, "committed");
            status = ((bool) isTrue(committed)) ? "ok" : "pending";
        }
        object id = this.safeString(transaction, "id");
        object currencyId = this.safeString(amountAndCurrencyObject, "currency");
        object feeCurrencyId = this.safeString(feeObject, "currency");
        object datetime = this.safeString(transaction, "created_at");
        object toObject = this.safeDict(transaction, "to", new Dictionary<string, object>() {});
        object toAddress = this.safeString(toObject, "address");
        return new Dictionary<string, object>() {
            { "info", transaction },
            { "id", id },
            { "txid", id },
            { "timestamp", this.parse8601(datetime) },
            { "datetime", datetime },
            { "network", null },
            { "address", toAddress },
            { "addressTo", toAddress },
            { "addressFrom", null },
            { "tag", null },
            { "tagTo", null },
            { "tagFrom", null },
            { "type", this.safeString(transaction, "resource") },
            { "amount", this.safeNumber(amountAndCurrencyObject, "amount") },
            { "currency", this.safeCurrencyCode(currencyId, currency) },
            { "status", status },
            { "updated", this.parse8601(this.safeString(transaction, "updated_at")) },
            { "fee", new Dictionary<string, object>() {
                { "cost", this.safeNumber(feeObject, "amount") },
                { "currency", this.safeCurrencyCode(feeCurrencyId) },
            } },
        };
    }

    public override object parseTrade(object trade, object market = null)
    {
        //
        // fetchMyBuys, fetchMySells
        //
        //     {
        //         "id": "67e0eaec-07d7-54c4-a72c-2e92826897df",
        //         "status": "completed",
        //         "payment_method": {
        //             "id": "83562370-3e5c-51db-87da-752af5ab9559",
        //             "resource": "payment_method",
        //             "resource_path": "/v2/payment-methods/83562370-3e5c-51db-87da-752af5ab9559"
        //         },
        //         "transaction": {
        //             "id": "441b9494-b3f0-5b98-b9b0-4d82c21c252a",
        //             "resource": "transaction",
        //             "resource_path": "/v2/accounts/2bbf394c-193b-5b2a-9155-3b4732659ede/transactions/441b9494-b3f0-5b98-b9b0-4d82c21c252a"
        //         },
        //         "amount": { "amount": "1.00000000", "currency": "BTC" },
        //         "total": { "amount": "10.25", "currency": "USD" },
        //         "subtotal": { "amount": "10.10", "currency": "USD" },
        //         "created_at": "2015-01-31T20:49:02Z",
        //         "updated_at": "2015-02-11T16:54:02-08:00",
        //         "resource": "buy",
        //         "resource_path": "/v2/accounts/2bbf394c-193b-5b2a-9155-3b4732659ede/buys/67e0eaec-07d7-54c4-a72c-2e92826897df",
        //         "committed": true,
        //         "instant": false,
        //         "fee": { "amount": "0.15", "currency": "USD" },
        //         "payout_at": "2015-02-18T16:54:00-08:00"
        //     }
        //
        // fetchTrades
        //
        //     {
        //         "trade_id": "10092327",
        //         "product_id": "BTC-USDT",
        //         "price": "17488.12",
        //         "size": "0.0000623",
        //         "time": "2023-01-11T00:52:37.557001Z",
        //         "side": "BUY",
        //         "bid": "",
        //         "ask": ""
        //     }
        //
        // fetchMyTrades
        //
        //     {
        //         "entry_id": "b88b82cc89e326a2778874795102cbafd08dd979a2a7a3c69603fc4c23c2e010",
        //         "trade_id": "cdc39e45-bbd3-44ec-bf02-61742dfb16a1",
        //         "order_id": "813a53c5-3e39-47bb-863d-2faf685d22d8",
        //         "trade_time": "2023-01-18T01:37:38.091377090Z",
        //         "trade_type": "FILL",
        //         "price": "21220.64",
        //         "size": "0.0046830664333996",
        //         "commission": "0.0000280983986004",
        //         "product_id": "BTC-USDT",
        //         "sequence_timestamp": "2023-01-18T01:37:38.092520Z",
        //         "liquidity_indicator": "UNKNOWN_LIQUIDITY_INDICATOR",
        //         "size_in_quote": true,
        //         "user_id": "1111111-1111-1111-1111-111111111111",
        //         "side": "BUY"
        //     }
        //
        object symbol = null;
        object totalObject = this.safeDict(trade, "total", new Dictionary<string, object>() {});
        object amountObject = this.safeDict(trade, "amount", new Dictionary<string, object>() {});
        object subtotalObject = this.safeDict(trade, "subtotal", new Dictionary<string, object>() {});
        object feeObject = this.safeDict(trade, "fee", new Dictionary<string, object>() {});
        object marketId = this.safeString(trade, "product_id");
        market = this.safeMarket(marketId, market, "-");
        if (isTrue(!isEqual(market, null)))
        {
            symbol = getValue(market, "symbol");
        } else
        {
            object baseId = this.safeString(amountObject, "currency");
            object quoteId = this.safeString(totalObject, "currency");
            if (isTrue(isTrue((!isEqual(baseId, null))) && isTrue((!isEqual(quoteId, null)))))
            {
                object bs = this.safeCurrencyCode(baseId);
                object quote = this.safeCurrencyCode(quoteId);
                symbol = add(add(bs, "/"), quote);
            }
        }
        object sizeInQuote = this.safeBool(trade, "size_in_quote");
        object v3Price = this.safeString(trade, "price");
        object v3Cost = null;
        object v3Amount = this.safeString(trade, "size");
        if (isTrue(sizeInQuote))
        {
            // calculate base size
            v3Cost = v3Amount;
            v3Amount = Precise.stringDiv(v3Amount, v3Price);
        }
        object v3FeeCost = this.safeString(trade, "commission");
        object amountString = this.safeString(amountObject, "amount", v3Amount);
        object costString = this.safeString(subtotalObject, "amount", v3Cost);
        object priceString = null;
        object cost = null;
        if (isTrue(isTrue((!isEqual(costString, null))) && isTrue((!isEqual(amountString, null)))))
        {
            priceString = Precise.stringDiv(costString, amountString);
        } else
        {
            priceString = v3Price;
        }
        if (isTrue(isTrue((!isEqual(priceString, null))) && isTrue((!isEqual(amountString, null)))))
        {
            cost = Precise.stringMul(priceString, amountString);
        } else
        {
            cost = costString;
        }
        object feeCurrencyId = this.safeString(feeObject, "currency");
        object feeCost = this.safeNumber(feeObject, "amount", this.parseNumber(v3FeeCost));
        if (isTrue(isTrue(isTrue((isEqual(feeCurrencyId, null))) && isTrue((!isEqual(market, null)))) && isTrue((!isEqual(feeCost, null)))))
        {
            feeCurrencyId = getValue(market, "quote");
        }
        object datetime = this.safeStringN(trade, new List<object>() {"created_at", "trade_time", "time"});
        object side = this.safeStringLower2(trade, "resource", "side");
        object takerOrMaker = this.safeStringLower(trade, "liquidity_indicator");
        return this.safeTrade(new Dictionary<string, object>() {
            { "info", trade },
            { "id", this.safeString2(trade, "id", "trade_id") },
            { "order", this.safeString(trade, "order_id") },
            { "timestamp", this.parse8601(datetime) },
            { "datetime", datetime },
            { "symbol", symbol },
            { "type", null },
            { "side", ((bool) isTrue((isEqual(side, "unknown_order_side")))) ? null : side },
            { "takerOrMaker", ((bool) isTrue((isEqual(takerOrMaker, "unknown_liquidity_indicator")))) ? null : takerOrMaker },
            { "price", priceString },
            { "amount", amountString },
            { "cost", cost },
            { "fee", new Dictionary<string, object>() {
                { "cost", feeCost },
                { "currency", this.safeCurrencyCode(feeCurrencyId) },
            } },
        });
    }

    public async override Task<object> fetchMarkets(object parameters = null)
    {
        /**
        * @method
        * @name coinbase#fetchMarkets
        * @see https://docs.cloud.coinbase.com/advanced-trade-api/reference/retailbrokerageapi_getpublicproducts
        * @see https://docs.cloud.coinbase.com/sign-in-with-coinbase/docs/api-currencies#get-fiat-currencies
        * @see https://docs.cloud.coinbase.com/sign-in-with-coinbase/docs/api-exchange-rates#get-exchange-rates
        * @description retrieves data on all markets for coinbase
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} an array of objects representing market data
        */
        parameters ??= new Dictionary<string, object>();
        object method = this.safeString(this.options, "fetchMarkets", "fetchMarketsV3");
        if (isTrue(isEqual(method, "fetchMarketsV3")))
        {
            return await this.fetchMarketsV3(parameters);
        }
        return await this.fetchMarketsV2(parameters);
    }

    public async virtual Task<object> fetchMarketsV2(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object response = await this.fetchCurrenciesFromCache(parameters);
        object currencies = this.safeDict(response, "currencies", new Dictionary<string, object>() {});
        object exchangeRates = this.safeDict(response, "exchangeRates", new Dictionary<string, object>() {});
        object data = this.safeList(currencies, "data", new List<object>() {});
        object dataById = this.indexBy(data, "id");
        object rates = this.safeDict(this.safeDict(exchangeRates, "data", new Dictionary<string, object>() {}), "rates", new Dictionary<string, object>() {});
        object baseIds = new List<object>(((IDictionary<string,object>)rates).Keys);
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(baseIds)); postFixIncrement(ref i))
        {
            object baseId = getValue(baseIds, i);
            object bs = this.safeCurrencyCode(baseId);
            object type = ((bool) isTrue((inOp(dataById, baseId)))) ? "fiat" : "crypto";
            // https://github.com/ccxt/ccxt/issues/6066
            if (isTrue(isEqual(type, "crypto")))
            {
                for (object j = 0; isLessThan(j, getArrayLength(data)); postFixIncrement(ref j))
                {
                    object quoteCurrency = getValue(data, j);
                    object quoteId = this.safeString(quoteCurrency, "id");
                    object quote = this.safeCurrencyCode(quoteId);
                    ((IList<object>)result).Add(new Dictionary<string, object>() {
                        { "id", add(add(baseId, "-"), quoteId) },
                        { "symbol", add(add(bs, "/"), quote) },
                        { "base", bs },
                        { "quote", quote },
                        { "settle", null },
                        { "baseId", baseId },
                        { "quoteId", quoteId },
                        { "settleId", null },
                        { "type", "spot" },
                        { "spot", true },
                        { "margin", false },
                        { "swap", false },
                        { "future", false },
                        { "option", false },
                        { "active", null },
                        { "contract", false },
                        { "linear", null },
                        { "inverse", null },
                        { "contractSize", null },
                        { "expiry", null },
                        { "expiryDatetime", null },
                        { "strike", null },
                        { "optionType", null },
                        { "precision", new Dictionary<string, object>() {
                            { "amount", null },
                            { "price", null },
                        } },
                        { "limits", new Dictionary<string, object>() {
                            { "leverage", new Dictionary<string, object>() {
                                { "min", null },
                                { "max", null },
                            } },
                            { "amount", new Dictionary<string, object>() {
                                { "min", null },
                                { "max", null },
                            } },
                            { "price", new Dictionary<string, object>() {
                                { "min", null },
                                { "max", null },
                            } },
                            { "cost", new Dictionary<string, object>() {
                                { "min", this.safeNumber(quoteCurrency, "min_size") },
                                { "max", null },
                            } },
                        } },
                        { "info", quoteCurrency },
                    });
                }
            }
        }
        return result;
    }

    public async virtual Task<object> fetchMarketsV3(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object spotUnresolvedPromises = new List<object> {this.v3PublicGetBrokerageMarketProducts(parameters)};
        if (isTrue(this.checkRequiredCredentials(false)))
        {
            ((IList<object>)spotUnresolvedPromises).Add(this.v3PrivateGetBrokerageTransactionSummary(parameters));
        }
        //
        //    {
        //        total_volume: '9.995989116664404',
        //        total_fees: '0.07996791093331522',
        //        fee_tier: {
        //            pricing_tier: 'Advanced 1',
        //            usd_from: '0',
        //            usd_to: '1000',
        //            taker_fee_rate: '0.008',
        //            maker_fee_rate: '0.006',
        //            aop_from: '',
        //            aop_to: ''
        //        },
        //        margin_rate: null,
        //        goods_and_services_tax: null,
        //        advanced_trade_only_volume: '9.995989116664404',
        //        advanced_trade_only_fees: '0.07996791093331522',
        //        coinbase_pro_volume: '0',
        //        coinbase_pro_fees: '0',
        //        total_balance: '',
        //        has_promo_fee: false
        //    }
        //
        object unresolvedContractPromises = new List<object>() {};
        try
        {
            unresolvedContractPromises = new List<object> {this.v3PublicGetBrokerageMarketProducts(this.extend(parameters, new Dictionary<string, object>() {
    { "product_type", "FUTURE" },
})), this.v3PublicGetBrokerageMarketProducts(this.extend(parameters, new Dictionary<string, object>() {
    { "product_type", "FUTURE" },
    { "contract_expiry_type", "PERPETUAL" },
}))};
            if (isTrue(this.checkRequiredCredentials(false)))
            {
                ((IList<object>)unresolvedContractPromises).Add(this.extend(parameters, new Dictionary<string, object>() {
                    { "product_type", "FUTURE" },
                }));
                ((IList<object>)unresolvedContractPromises).Add(this.extend(parameters, new Dictionary<string, object>() {
                    { "product_type", "FUTURE" },
                    { "contract_expiry_type", "PERPETUAL" },
                }));
            }
        } catch(Exception e)
        {
            unresolvedContractPromises = new List<object>() {}; // the sync version of ccxt won't have the promise.all line so the request is made here. Some users can't access perpetual products
        }
        object promises = await promiseAll(spotUnresolvedPromises);
        object contractPromises = null;
        try
        {
            contractPromises = await promiseAll(unresolvedContractPromises); // some users don't have access to contracts
        } catch(Exception e)
        {
            contractPromises = new List<object>() {};
        }
        object spot = this.safeDict(promises, 0, new Dictionary<string, object>() {});
        object fees = this.safeDict(promises, 1, new Dictionary<string, object>() {});
        object expiringFutures = this.safeDict(contractPromises, 0, new Dictionary<string, object>() {});
        object perpetualFutures = this.safeDict(contractPromises, 1, new Dictionary<string, object>() {});
        object expiringFees = this.safeDict(contractPromises, 2, new Dictionary<string, object>() {});
        object perpetualFees = this.safeDict(contractPromises, 3, new Dictionary<string, object>() {});
        //
        //     {
        //         "total_volume": 0,
        //         "total_fees": 0,
        //         "fee_tier": {
        //             "pricing_tier": "",
        //             "usd_from": "0",
        //             "usd_to": "10000",
        //             "taker_fee_rate": "0.006",
        //             "maker_fee_rate": "0.004"
        //         },
        //         "margin_rate": null,
        //         "goods_and_services_tax": null,
        //         "advanced_trade_only_volume": 0,
        //         "advanced_trade_only_fees": 0,
        //         "coinbase_pro_volume": 0,
        //         "coinbase_pro_fees": 0
        //     }
        //
        object feeTier = this.safeDict(fees, "fee_tier", new Dictionary<string, object>() {});
        object expiringFeeTier = this.safeDict(expiringFees, "fee_tier", new Dictionary<string, object>() {}); // fee tier null?
        object perpetualFeeTier = this.safeDict(perpetualFees, "fee_tier", new Dictionary<string, object>() {}); // fee tier null?
        object data = this.safeList(spot, "products", new List<object>() {});
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
        {
            ((IList<object>)result).Add(this.parseSpotMarket(getValue(data, i), feeTier));
        }
        object futureData = this.safeList(expiringFutures, "products", new List<object>() {});
        for (object i = 0; isLessThan(i, getArrayLength(futureData)); postFixIncrement(ref i))
        {
            ((IList<object>)result).Add(this.parseContractMarket(getValue(futureData, i), expiringFeeTier));
        }
        object perpetualData = this.safeList(perpetualFutures, "products", new List<object>() {});
        for (object i = 0; isLessThan(i, getArrayLength(perpetualData)); postFixIncrement(ref i))
        {
            ((IList<object>)result).Add(this.parseContractMarket(getValue(perpetualData, i), perpetualFeeTier));
        }
        return result;
    }

    public virtual object parseSpotMarket(object market, object feeTier)
    {
        //
        //         {
        //             "product_id": "TONE-USD",
        //             "price": "0.01523",
        //             "price_percentage_change_24h": "1.94109772423025",
        //             "volume_24h": "19773129",
        //             "volume_percentage_change_24h": "437.0170530929949",
        //             "base_increment": "1",
        //             "quote_increment": "0.00001",
        //             "quote_min_size": "1",
        //             "quote_max_size": "10000000",
        //             "base_min_size": "26.7187147229469674",
        //             "base_max_size": "267187147.2294696735908216",
        //             "base_name": "TE-FOOD",
        //             "quote_name": "US Dollar",
        //             "watched": false,
        //             "is_disabled": false,
        //             "new": false,
        //             "status": "online",
        //             "cancel_only": false,
        //             "limit_only": false,
        //             "post_only": false,
        //             "trading_disabled": false,
        //             "auction_mode": false,
        //             "product_type": "SPOT",
        //             "quote_currency_id": "USD",
        //             "base_currency_id": "TONE",
        //             "fcm_trading_session_details": null,
        //             "mid_market_price": ""
        //         }
        //
        object id = this.safeString(market, "product_id");
        object baseId = this.safeString(market, "base_currency_id");
        object quoteId = this.safeString(market, "quote_currency_id");
        object bs = this.safeCurrencyCode(baseId);
        object quote = this.safeCurrencyCode(quoteId);
        object marketType = this.safeStringLower(market, "product_type");
        object tradingDisabled = this.safeBool(market, "trading_disabled");
        object stablePairs = this.safeList(this.options, "stablePairs", new List<object>() {});
        return this.safeMarketStructure(new Dictionary<string, object>() {
            { "id", id },
            { "symbol", add(add(bs, "/"), quote) },
            { "base", bs },
            { "quote", quote },
            { "settle", null },
            { "baseId", baseId },
            { "quoteId", quoteId },
            { "settleId", null },
            { "type", marketType },
            { "spot", (isEqual(marketType, "spot")) },
            { "margin", null },
            { "swap", false },
            { "future", false },
            { "option", false },
            { "active", !isTrue(tradingDisabled) },
            { "contract", false },
            { "linear", null },
            { "inverse", null },
            { "taker", ((bool) isTrue(this.inArray(id, stablePairs))) ? 0.00001 : this.safeNumber(feeTier, "taker_fee_rate") },
            { "maker", ((bool) isTrue(this.inArray(id, stablePairs))) ? 0 : this.safeNumber(feeTier, "maker_fee_rate") },
            { "contractSize", null },
            { "expiry", null },
            { "expiryDatetime", null },
            { "strike", null },
            { "optionType", null },
            { "precision", new Dictionary<string, object>() {
                { "amount", this.safeNumber(market, "base_increment") },
                { "price", this.safeNumber2(market, "price_increment", "quote_increment") },
            } },
            { "limits", new Dictionary<string, object>() {
                { "leverage", new Dictionary<string, object>() {
                    { "min", null },
                    { "max", null },
                } },
                { "amount", new Dictionary<string, object>() {
                    { "min", this.safeNumber(market, "base_min_size") },
                    { "max", this.safeNumber(market, "base_max_size") },
                } },
                { "price", new Dictionary<string, object>() {
                    { "min", null },
                    { "max", null },
                } },
                { "cost", new Dictionary<string, object>() {
                    { "min", this.safeNumber(market, "quote_min_size") },
                    { "max", this.safeNumber(market, "quote_max_size") },
                } },
            } },
            { "created", null },
            { "info", market },
        });
    }

    public virtual object parseContractMarket(object market, object feeTier)
    {
        // expiring
        //
        //        {
        //           "product_id":"BIT-26APR24-CDE",
        //           "price":"71145",
        //           "price_percentage_change_24h":"-2.36722931247427",
        //           "volume_24h":"108549",
        //           "volume_percentage_change_24h":"155.78255337197794",
        //           "base_increment":"1",
        //           "quote_increment":"0.01",
        //           "quote_min_size":"0",
        //           "quote_max_size":"100000000",
        //           "base_min_size":"1",
        //           "base_max_size":"100000000",
        //           "base_name":"",
        //           "quote_name":"US Dollar",
        //           "watched":false,
        //           "is_disabled":false,
        //           "new":false,
        //           "status":"",
        //           "cancel_only":false,
        //           "limit_only":false,
        //           "post_only":false,
        //           "trading_disabled":false,
        //           "auction_mode":false,
        //           "product_type":"FUTURE",
        //           "quote_currency_id":"USD",
        //           "base_currency_id":"",
        //           "fcm_trading_session_details":{
        //              "is_session_open":true,
        //              "open_time":"2024-04-08T22:00:00Z",
        //              "close_time":"2024-04-09T21:00:00Z"
        //           },
        //           "mid_market_price":"71105",
        //           "alias":"",
        //           "alias_to":[
        //           ],
        //           "base_display_symbol":"",
        //           "quote_display_symbol":"USD",
        //           "view_only":false,
        //           "price_increment":"5",
        //           "display_name":"BTC 26 APR 24",
        //           "product_venue":"FCM",
        //           "future_product_details":{
        //              "venue":"cde",
        //              "contract_code":"BIT",
        //              "contract_expiry":"2024-04-26T15:00:00Z",
        //              "contract_size":"0.01",
        //              "contract_root_unit":"BTC",
        //              "group_description":"Nano Bitcoin Futures",
        //              "contract_expiry_timezone":"Europe/London",
        //              "group_short_description":"Nano BTC",
        //              "risk_managed_by":"MANAGED_BY_FCM",
        //              "contract_expiry_type":"EXPIRING",
        //              "contract_display_name":"BTC 26 APR 24"
        //           }
        //        }
        //
        // perpetual
        //
        //        {
        //           "product_id":"ETH-PERP-INTX",
        //           "price":"3630.98",
        //           "price_percentage_change_24h":"0.65142426292038",
        //           "volume_24h":"114020.1501",
        //           "volume_percentage_change_24h":"63.33650787154869",
        //           "base_increment":"0.0001",
        //           "quote_increment":"0.01",
        //           "quote_min_size":"10",
        //           "quote_max_size":"50000000",
        //           "base_min_size":"0.0001",
        //           "base_max_size":"50000",
        //           "base_name":"",
        //           "quote_name":"USDC",
        //           "watched":false,
        //           "is_disabled":false,
        //           "new":false,
        //           "status":"",
        //           "cancel_only":false,
        //           "limit_only":false,
        //           "post_only":false,
        //           "trading_disabled":false,
        //           "auction_mode":false,
        //           "product_type":"FUTURE",
        //           "quote_currency_id":"USDC",
        //           "base_currency_id":"",
        //           "fcm_trading_session_details":null,
        //           "mid_market_price":"3630.975",
        //           "alias":"",
        //           "alias_to":[],
        //           "base_display_symbol":"",
        //           "quote_display_symbol":"USDC",
        //           "view_only":false,
        //           "price_increment":"0.01",
        //           "display_name":"ETH PERP",
        //           "product_venue":"INTX",
        //           "future_product_details":{
        //              "venue":"",
        //              "contract_code":"ETH",
        //              "contract_expiry":null,
        //              "contract_size":"1",
        //              "contract_root_unit":"ETH",
        //              "group_description":"",
        //              "contract_expiry_timezone":"",
        //              "group_short_description":"",
        //              "risk_managed_by":"MANAGED_BY_VENUE",
        //              "contract_expiry_type":"PERPETUAL",
        //              "perpetual_details":{
        //                 "open_interest":"0",
        //                 "funding_rate":"0.000016",
        //                 "funding_time":"2024-04-09T09:00:00.000008Z",
        //                 "max_leverage":"10"
        //              },
        //              "contract_display_name":"ETH PERPETUAL"
        //           }
        //        }
        //
        object id = this.safeString(market, "product_id");
        object futureProductDetails = this.safeDict(market, "future_product_details", new Dictionary<string, object>() {});
        object contractExpiryType = this.safeString(futureProductDetails, "contract_expiry_type");
        object contractSize = this.safeNumber(futureProductDetails, "contract_size");
        object contractExpire = this.safeString(futureProductDetails, "contract_expiry");
        object expireTimestamp = this.parse8601(contractExpire);
        object expireDateTime = this.iso8601(expireTimestamp);
        object isSwap = (isEqual(contractExpiryType, "PERPETUAL"));
        object baseId = this.safeString(futureProductDetails, "contract_root_unit");
        object quoteId = this.safeString(market, "quote_currency_id");
        object bs = this.safeCurrencyCode(baseId);
        object quote = this.safeCurrencyCode(quoteId);
        object tradingDisabled = this.safeBool(market, "is_disabled");
        object symbol = add(add(bs, "/"), quote);
        object type = null;
        if (isTrue(isSwap))
        {
            type = "swap";
            symbol = add(add(symbol, ":"), quote);
        } else
        {
            type = "future";
            symbol = add(add(add(add(symbol, ":"), quote), "-"), this.yymmdd(expireTimestamp));
        }
        object takerFeeRate = this.safeNumber(feeTier, "taker_fee_rate");
        object makerFeeRate = this.safeNumber(feeTier, "maker_fee_rate");
        object taker = ((bool) isTrue(takerFeeRate)) ? takerFeeRate : this.parseNumber("0.06");
        object maker = ((bool) isTrue(makerFeeRate)) ? makerFeeRate : this.parseNumber("0.04");
        return this.safeMarketStructure(new Dictionary<string, object>() {
            { "id", id },
            { "symbol", symbol },
            { "base", bs },
            { "quote", quote },
            { "settle", quote },
            { "baseId", baseId },
            { "quoteId", quoteId },
            { "settleId", quoteId },
            { "type", type },
            { "spot", false },
            { "margin", false },
            { "swap", isSwap },
            { "future", !isTrue(isSwap) },
            { "option", false },
            { "active", !isTrue(tradingDisabled) },
            { "contract", true },
            { "linear", true },
            { "inverse", false },
            { "taker", taker },
            { "maker", maker },
            { "contractSize", contractSize },
            { "expiry", expireTimestamp },
            { "expiryDatetime", expireDateTime },
            { "strike", null },
            { "optionType", null },
            { "precision", new Dictionary<string, object>() {
                { "amount", this.safeNumber(market, "base_increment") },
                { "price", this.safeNumber2(market, "price_increment", "quote_increment") },
            } },
            { "limits", new Dictionary<string, object>() {
                { "leverage", new Dictionary<string, object>() {
                    { "min", null },
                    { "max", null },
                } },
                { "amount", new Dictionary<string, object>() {
                    { "min", this.safeNumber(market, "base_min_size") },
                    { "max", this.safeNumber(market, "base_max_size") },
                } },
                { "price", new Dictionary<string, object>() {
                    { "min", null },
                    { "max", null },
                } },
                { "cost", new Dictionary<string, object>() {
                    { "min", this.safeNumber(market, "quote_min_size") },
                    { "max", this.safeNumber(market, "quote_max_size") },
                } },
            } },
            { "created", null },
            { "info", market },
        });
    }

    public async virtual Task<object> fetchCurrenciesFromCache(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object options = this.safeDict(this.options, "fetchCurrencies", new Dictionary<string, object>() {});
        object timestamp = this.safeInteger(options, "timestamp");
        object expires = this.safeInteger(options, "expires", 1000);
        object now = this.milliseconds();
        if (isTrue(isTrue((isEqual(timestamp, null))) || isTrue((isGreaterThan((subtract(now, timestamp)), expires)))))
        {
            object promises = new List<object> {this.v2PublicGetCurrencies(parameters), this.v2PublicGetCurrenciesCrypto(parameters)};
            object promisesResult = await promiseAll(promises);
            object fiatResponse = this.safeDict(promisesResult, 0, new Dictionary<string, object>() {});
            //
            //    [
            //        "data": {
            //            id: 'IMP',
            //            name: 'Isle of Man Pound',
            //            min_size: '0.01'
            //        },
            //        ...
            //    ]
            //
            object cryptoResponse = this.safeDict(promisesResult, 1, new Dictionary<string, object>() {});
            //
            //    {
            //        asset_id: '9476e3be-b731-47fa-82be-347fabc573d9',
            //        code: 'AERO',
            //        name: 'Aerodrome Finance',
            //        color: '#0433FF',
            //        sort_index: '340',
            //        exponent: '8',
            //        type: 'crypto',
            //        address_regex: '^(?:0x)?[0-9a-fA-F]{40}$'
            //    }
            //
            object fiatData = this.safeList(fiatResponse, "data", new List<object>() {});
            object cryptoData = this.safeList(cryptoResponse, "data", new List<object>() {});
            object exchangeRates = await this.v2PublicGetExchangeRates(parameters);
            ((IDictionary<string,object>)this.options)["fetchCurrencies"] = this.extend(options, new Dictionary<string, object>() {
                { "currencies", this.arrayConcat(fiatData, cryptoData) },
                { "exchangeRates", exchangeRates },
                { "timestamp", now },
            });
        }
        return this.safeDict(this.options, "fetchCurrencies", new Dictionary<string, object>() {});
    }

    public async override Task<object> fetchCurrencies(object parameters = null)
    {
        /**
        * @method
        * @name coinbase#fetchCurrencies
        * @description fetches all available currencies on an exchange
        * @see https://docs.cloud.coinbase.com/sign-in-with-coinbase/docs/api-currencies#get-fiat-currencies
        * @see https://docs.cloud.coinbase.com/sign-in-with-coinbase/docs/api-exchange-rates#get-exchange-rates
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} an associative dictionary of currencies
        */
        parameters ??= new Dictionary<string, object>();
        object response = await this.fetchCurrenciesFromCache(parameters);
        object currencies = this.safeList(response, "currencies", new List<object>() {});
        //
        // fiat
        //
        //    {
        //        id: 'IMP',
        //        name: 'Isle of Man Pound',
        //        min_size: '0.01'
        //    },
        //
        // crypto
        //
        //    {
        //        asset_id: '9476e3be-b731-47fa-82be-347fabc573d9',
        //        code: 'AERO',
        //        name: 'Aerodrome Finance',
        //        color: '#0433FF',
        //        sort_index: '340',
        //        exponent: '8',
        //        type: 'crypto',
        //        address_regex: '^(?:0x)?[0-9a-fA-F]{40}$'
        //    }
        //
        //
        //     {
        //         "data":{
        //             "currency":"USD",
        //             "rates":{
        //                 "AED":"3.67",
        //                 "AFN":"78.21",
        //                 "ALL":"110.42",
        //                 "AMD":"474.18",
        //                 "ANG":"1.75",
        //                 ...
        //             },
        //         }
        //     }
        //
        object result = new Dictionary<string, object>() {};
        object networks = new Dictionary<string, object>() {};
        object networksById = new Dictionary<string, object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(currencies)); postFixIncrement(ref i))
        {
            object currency = getValue(currencies, i);
            object assetId = this.safeString(currency, "asset_id");
            object id = this.safeString2(currency, "id", "code");
            object code = this.safeCurrencyCode(id);
            object name = this.safeString(currency, "name");
            ((IDictionary<string,object>)getValue(this.options, "networks"))[(string)code] = ((string)name).ToLower();
            ((IDictionary<string,object>)getValue(this.options, "networksById"))[(string)code] = ((string)name).ToLower();
            ((IDictionary<string,object>)result)[(string)code] = new Dictionary<string, object>() {
                { "info", currency },
                { "id", id },
                { "code", code },
                { "type", ((bool) isTrue((!isEqual(assetId, null)))) ? "crypto" : "fiat" },
                { "name", this.safeString(currency, "name") },
                { "active", true },
                { "deposit", null },
                { "withdraw", null },
                { "fee", null },
                { "precision", null },
                { "limits", new Dictionary<string, object>() {
                    { "amount", new Dictionary<string, object>() {
                        { "min", this.safeNumber(currency, "min_size") },
                        { "max", null },
                    } },
                    { "withdraw", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                } },
            };
            if (isTrue(!isEqual(assetId, null)))
            {
                object lowerCaseName = ((string)name).ToLower();
                ((IDictionary<string,object>)networks)[(string)code] = lowerCaseName;
                ((IDictionary<string,object>)networksById)[(string)lowerCaseName] = code;
            }
        }
        ((IDictionary<string,object>)this.options)["networks"] = this.extend(networks, getValue(this.options, "networks"));
        ((IDictionary<string,object>)this.options)["networksById"] = this.extend(networksById, getValue(this.options, "networksById"));
        return result;
    }

    public async override Task<object> fetchTickers(object symbols = null, object parameters = null)
    {
        /**
        * @method
        * @name coinbase#fetchTickers
        * @description fetches price tickers for multiple markets, statistical information calculated over the past 24 hours for each market
        * @see https://docs.cloud.coinbase.com/advanced-trade-api/reference/retailbrokerageapi_getproducts
        * @see https://docs.cloud.coinbase.com/sign-in-with-coinbase/docs/api-exchange-rates#get-exchange-rates
        * @param {string[]|undefined} symbols unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/#/?id=ticker-structure}
        */
        parameters ??= new Dictionary<string, object>();
        object method = this.safeString(this.options, "fetchTickers", "fetchTickersV3");
        if (isTrue(isEqual(method, "fetchTickersV3")))
        {
            return await this.fetchTickersV3(symbols, parameters);
        }
        return await this.fetchTickersV2(symbols, parameters);
    }

    public async virtual Task<object> fetchTickersV2(object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        symbols = this.marketSymbols(symbols);
        object request = new Dictionary<string, object>() {};
        object response = await this.v2PublicGetExchangeRates(this.extend(request, parameters));
        //
        //     {
        //         "data":{
        //             "currency":"USD",
        //             "rates":{
        //                 "AED":"3.6731",
        //                 "AFN":"103.163942",
        //                 "ALL":"106.973038",
        //             }
        //         }
        //     }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        object rates = this.safeDict(data, "rates", new Dictionary<string, object>() {});
        object quoteId = this.safeString(data, "currency");
        object result = new Dictionary<string, object>() {};
        object baseIds = new List<object>(((IDictionary<string,object>)rates).Keys);
        object delimiter = "-";
        for (object i = 0; isLessThan(i, getArrayLength(baseIds)); postFixIncrement(ref i))
        {
            object baseId = getValue(baseIds, i);
            object marketId = add(add(baseId, delimiter), quoteId);
            object market = this.safeMarket(marketId, null, delimiter);
            object symbol = getValue(market, "symbol");
            ((IDictionary<string,object>)result)[(string)symbol] = this.parseTicker(getValue(rates, baseId), market);
        }
        return this.filterByArrayTickers(result, "symbol", symbols);
    }

    public async virtual Task<object> fetchTickersV3(object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        symbols = this.marketSymbols(symbols);
        object request = new Dictionary<string, object>() {};
        if (isTrue(!isEqual(symbols, null)))
        {
            ((IDictionary<string,object>)request)["product_ids"] = this.marketIds(symbols);
        }
        object response = await this.v3PublicGetBrokerageMarketProducts(this.extend(request, parameters));
        //
        //     {
        //         "products": [
        //             {
        //                 "product_id": "TONE-USD",
        //                 "price": "0.01523",
        //                 "price_percentage_change_24h": "1.94109772423025",
        //                 "volume_24h": "19773129",
        //                 "volume_percentage_change_24h": "437.0170530929949",
        //                 "base_increment": "1",
        //                 "quote_increment": "0.00001",
        //                 "quote_min_size": "1",
        //                 "quote_max_size": "10000000",
        //                 "base_min_size": "26.7187147229469674",
        //                 "base_max_size": "267187147.2294696735908216",
        //                 "base_name": "TE-FOOD",
        //                 "quote_name": "US Dollar",
        //                 "watched": false,
        //                 "is_disabled": false,
        //                 "new": false,
        //                 "status": "online",
        //                 "cancel_only": false,
        //                 "limit_only": false,
        //                 "post_only": false,
        //                 "trading_disabled": false,
        //                 "auction_mode": false,
        //                 "product_type": "SPOT",
        //                 "quote_currency_id": "USD",
        //                 "base_currency_id": "TONE",
        //                 "fcm_trading_session_details": null,
        //                 "mid_market_price": ""
        //             },
        //             ...
        //         ],
        //         "num_products": 549
        //     }
        //
        object data = this.safeList(response, "products", new List<object>() {});
        object result = new Dictionary<string, object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
        {
            object entry = getValue(data, i);
            object marketId = this.safeString(entry, "product_id");
            object market = this.safeMarket(marketId, null, "-");
            object symbol = getValue(market, "symbol");
            ((IDictionary<string,object>)result)[(string)symbol] = this.parseTicker(entry, market);
        }
        return this.filterByArrayTickers(result, "symbol", symbols);
    }

    public async override Task<object> fetchTicker(object symbol, object parameters = null)
    {
        /**
        * @method
        * @name coinbase#fetchTicker
        * @description fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
        * @see https://docs.cloud.coinbase.com/advanced-trade-api/reference/retailbrokerageapi_getmarkettrades
        * @see https://docs.cloud.coinbase.com/sign-in-with-coinbase/docs/api-prices#get-spot-price
        * @see https://docs.cloud.coinbase.com/sign-in-with-coinbase/docs/api-prices#get-buy-price
        * @see https://docs.cloud.coinbase.com/sign-in-with-coinbase/docs/api-prices#get-sell-price
        * @param {string} symbol unified symbol of the market to fetch the ticker for
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
        */
        parameters ??= new Dictionary<string, object>();
        object method = this.safeString(this.options, "fetchTicker", "fetchTickerV3");
        if (isTrue(isEqual(method, "fetchTickerV3")))
        {
            return await this.fetchTickerV3(symbol, parameters);
        }
        return await this.fetchTickerV2(symbol, parameters);
    }

    public async virtual Task<object> fetchTickerV2(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = this.extend(new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        }, parameters);
        object spot = await this.v2PublicGetPricesSymbolSpot(request);
        //
        //     {"data":{"base":"BTC","currency":"USD","amount":"48691.23"}}
        //
        object ask = await this.v2PublicGetPricesSymbolBuy(request);
        //
        //     {"data":{"base":"BTC","currency":"USD","amount":"48691.23"}}
        //
        object bid = await this.v2PublicGetPricesSymbolSell(request);
        //
        //     {"data":{"base":"BTC","currency":"USD","amount":"48691.23"}}
        //
        object spotData = this.safeDict(spot, "data", new Dictionary<string, object>() {});
        object askData = this.safeDict(ask, "data", new Dictionary<string, object>() {});
        object bidData = this.safeDict(bid, "data", new Dictionary<string, object>() {});
        object bidAskLast = new Dictionary<string, object>() {
            { "bid", this.safeNumber(bidData, "amount") },
            { "ask", this.safeNumber(askData, "amount") },
            { "price", this.safeNumber(spotData, "amount") },
        };
        return this.parseTicker(bidAskLast, market);
    }

    public async virtual Task<object> fetchTickerV3(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "product_id", getValue(market, "id") },
            { "limit", 1 },
        };
        object response = await this.v3PublicGetBrokerageMarketProductsProductIdTicker(this.extend(request, parameters));
        //
        //     {
        //         "trades": [
        //             {
        //                 "trade_id": "518078013",
        //                 "product_id": "BTC-USD",
        //                 "price": "28208.1",
        //                 "size": "0.00659179",
        //                 "time": "2023-04-04T23:05:34.492746Z",
        //                 "side": "BUY",
        //                 "bid": "",
        //                 "ask": ""
        //             }
        //         ],
        //         "best_bid": "28208.61",
        //         "best_ask": "28208.62"
        //     }
        //
        object data = this.safeList(response, "trades", new List<object>() {});
        object ticker = this.parseTicker(getValue(data, 0), market);
        ((IDictionary<string,object>)ticker)["bid"] = this.safeNumber(response, "best_bid");
        ((IDictionary<string,object>)ticker)["ask"] = this.safeNumber(response, "best_ask");
        return ticker;
    }

    public override object parseTicker(object ticker, object market = null)
    {
        //
        // fetchTickerV2
        //
        //     {
        //         "bid": 20713.37,
        //         "ask": 20924.65,
        //         "price": 20809.83
        //     }
        //
        // fetchTickerV3
        //
        //     {
        //         "trade_id": "10209805",
        //         "product_id": "BTC-USDT",
        //         "price": "19381.27",
        //         "size": "0.1",
        //         "time": "2023-01-13T20:35:41.865970Z",
        //         "side": "BUY",
        //         "bid": "",
        //         "ask": ""
        //     }
        //
        // fetchTickersV2
        //
        //     "48691.23"
        //
        // fetchTickersV3
        //
        //     [
        //         {
        //             "product_id": "TONE-USD",
        //             "price": "0.01523",
        //             "price_percentage_change_24h": "1.94109772423025",
        //             "volume_24h": "19773129",
        //             "volume_percentage_change_24h": "437.0170530929949",
        //             "base_increment": "1",
        //             "quote_increment": "0.00001",
        //             "quote_min_size": "1",
        //             "quote_max_size": "10000000",
        //             "base_min_size": "26.7187147229469674",
        //             "base_max_size": "267187147.2294696735908216",
        //             "base_name": "TE-FOOD",
        //             "quote_name": "US Dollar",
        //             "watched": false,
        //             "is_disabled": false,
        //             "new": false,
        //             "status": "online",
        //             "cancel_only": false,
        //             "limit_only": false,
        //             "post_only": false,
        //             "trading_disabled": false,
        //             "auction_mode": false,
        //             "product_type": "SPOT",
        //             "quote_currency_id": "USD",
        //             "base_currency_id": "TONE",
        //             "fcm_trading_session_details": null,
        //             "mid_market_price": ""
        //         },
        //         ...
        //     ]
        //
        // fetchBidsAsks
        //
        //     {
        //         "product_id": "TRAC-EUR",
        //         "bids": [
        //             {
        //                 "price": "0.2384",
        //                 "size": "386.1"
        //             }
        //         ],
        //         "asks": [
        //             {
        //                 "price": "0.2406",
        //                 "size": "672"
        //             }
        //         ],
        //         "time": "2023-06-30T07:15:24.656044Z"
        //     }
        //
        object bid = this.safeNumber(ticker, "bid");
        object ask = this.safeNumber(ticker, "ask");
        object bidVolume = null;
        object askVolume = null;
        if (isTrue((inOp(ticker, "bids"))))
        {
            object bids = this.safeList(ticker, "bids", new List<object>() {});
            object asks = this.safeList(ticker, "asks", new List<object>() {});
            bid = this.safeNumber(getValue(bids, 0), "price");
            bidVolume = this.safeNumber(getValue(bids, 0), "size");
            ask = this.safeNumber(getValue(asks, 0), "price");
            askVolume = this.safeNumber(getValue(asks, 0), "size");
        }
        object marketId = this.safeString(ticker, "product_id");
        object last = this.safeNumber(ticker, "price");
        object datetime = this.safeString(ticker, "time");
        return this.safeTicker(new Dictionary<string, object>() {
            { "symbol", this.safeSymbol(marketId, market) },
            { "timestamp", this.parse8601(datetime) },
            { "datetime", datetime },
            { "bid", bid },
            { "ask", ask },
            { "last", last },
            { "high", null },
            { "low", null },
            { "bidVolume", bidVolume },
            { "askVolume", askVolume },
            { "vwap", null },
            { "open", null },
            { "close", last },
            { "previousClose", null },
            { "change", null },
            { "percentage", this.safeNumber(ticker, "price_percentage_change_24h") },
            { "average", null },
            { "baseVolume", null },
            { "quoteVolume", null },
            { "info", ticker },
        }, market);
    }

    public virtual object parseCustomBalance(object response, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object balances = this.safeList2(response, "data", "accounts", new List<object>() {});
        object accounts = this.safeList(parameters, "type", getValue(this.options, "accounts"));
        object v3Accounts = this.safeList(parameters, "type", getValue(this.options, "v3Accounts"));
        object result = new Dictionary<string, object>() {
            { "info", response },
        };
        for (object b = 0; isLessThan(b, getArrayLength(balances)); postFixIncrement(ref b))
        {
            object balance = getValue(balances, b);
            object type = this.safeString(balance, "type");
            if (isTrue(this.inArray(type, accounts)))
            {
                object value = this.safeDict(balance, "balance");
                if (isTrue(!isEqual(value, null)))
                {
                    object currencyId = this.safeString(value, "currency");
                    object code = this.safeCurrencyCode(currencyId);
                    object total = this.safeString(value, "amount");
                    object free = total;
                    object account = this.safeDict(result, code);
                    if (isTrue(isEqual(account, null)))
                    {
                        account = this.account();
                        ((IDictionary<string,object>)account)["free"] = free;
                        ((IDictionary<string,object>)account)["total"] = total;
                    } else
                    {
                        ((IDictionary<string,object>)account)["free"] = Precise.stringAdd(getValue(account, "free"), total);
                        ((IDictionary<string,object>)account)["total"] = Precise.stringAdd(getValue(account, "total"), total);
                    }
                    ((IDictionary<string,object>)result)[(string)code] = account;
                }
            } else if (isTrue(this.inArray(type, v3Accounts)))
            {
                object available = this.safeDict(balance, "available_balance");
                object hold = this.safeDict(balance, "hold");
                if (isTrue(isTrue(!isEqual(available, null)) && isTrue(!isEqual(hold, null))))
                {
                    object currencyId = this.safeString(available, "currency");
                    object code = this.safeCurrencyCode(currencyId);
                    object used = this.safeString(hold, "value");
                    object free = this.safeString(available, "value");
                    object total = Precise.stringAdd(used, free);
                    object account = this.safeDict(result, code);
                    if (isTrue(isEqual(account, null)))
                    {
                        account = this.account();
                        ((IDictionary<string,object>)account)["free"] = free;
                        ((IDictionary<string,object>)account)["used"] = used;
                        ((IDictionary<string,object>)account)["total"] = total;
                    } else
                    {
                        ((IDictionary<string,object>)account)["free"] = Precise.stringAdd(getValue(account, "free"), free);
                        ((IDictionary<string,object>)account)["used"] = Precise.stringAdd(getValue(account, "used"), used);
                        ((IDictionary<string,object>)account)["total"] = Precise.stringAdd(getValue(account, "total"), total);
                    }
                    ((IDictionary<string,object>)result)[(string)code] = account;
                }
            }
        }
        return this.safeBalance(result);
    }

    public async override Task<object> fetchBalance(object parameters = null)
    {
        /**
        * @method
        * @name coinbase#fetchBalance
        * @description query for balance and get the amount of funds available for trading or funds locked in orders
        * @see https://docs.cloud.coinbase.com/advanced-trade-api/reference/retailbrokerageapi_getaccounts
        * @see https://docs.cloud.coinbase.com/sign-in-with-coinbase/docs/api-accounts#list-accounts
        * @see https://docs.cloud.coinbase.com/advanced-trade-api/reference/retailbrokerageapi_getfcmbalancesummary
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {boolean} [params.v3] default false, set true to use v3 api endpoint
        * @param {object} [params.type] "spot" (default) or "swap" or "future"
        * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object response = null;
        object isV3 = this.safeBool(parameters, "v3", false);
        parameters = this.omit(parameters, new List<object>() {"v3"});
        object marketType = null;
        var marketTypeparametersVariable = this.handleMarketTypeAndParams("fetchBalance", null, parameters);
        marketType = ((IList<object>)marketTypeparametersVariable)[0];
        parameters = ((IList<object>)marketTypeparametersVariable)[1];
        object method = this.safeString(this.options, "fetchBalance", "v3PrivateGetBrokerageAccounts");
        if (isTrue(isEqual(marketType, "future")))
        {
            response = await this.v3PrivateGetBrokerageCfmBalanceSummary(this.extend(request, parameters));
        } else if (isTrue(isTrue((isV3)) || isTrue((isEqual(method, "v3PrivateGetBrokerageAccounts")))))
        {
            ((IDictionary<string,object>)request)["limit"] = 250;
            response = await this.v3PrivateGetBrokerageAccounts(this.extend(request, parameters));
        } else
        {
            ((IDictionary<string,object>)request)["limit"] = 100;
            response = await this.v2PrivateGetAccounts(this.extend(request, parameters));
        }
        //
        // v2PrivateGetAccounts
        //     {
        //         "pagination":{
        //             "ending_before":null,
        //             "starting_after":null,
        //             "previous_ending_before":null,
        //             "next_starting_after":"6b17acd6-2e68-5eb0-9f45-72d67cef578b",
        //             "limit":100,
        //             "order":"desc",
        //             "previous_uri":null,
        //             "next_uri":"/v2/accounts?limit=100\u0026starting_after=6b17acd6-2e68-5eb0-9f45-72d67cef578b"
        //         },
        //         "data":[
        //             {
        //                 "id":"94ad58bc-0f15-5309-b35a-a4c86d7bad60",
        //                 "name":"MINA Wallet",
        //                 "primary":false,
        //                 "type":"wallet",
        //                 "currency":{
        //                     "code":"MINA",
        //                     "name":"Mina",
        //                     "color":"#EA6B48",
        //                     "sort_index":397,
        //                     "exponent":9,
        //                     "type":"crypto",
        //                     "address_regex":"^(B62)[A-Za-z0-9]{52}$",
        //                     "asset_id":"a4ffc575-942c-5e26-b70c-cb3befdd4229",
        //                     "slug":"mina"
        //                 },
        //                 "balance":{"amount":"0.000000000","currency":"MINA"},
        //                 "created_at":"2022-03-25T00:36:16Z",
        //                 "updated_at":"2022-03-25T00:36:16Z",
        //                 "resource":"account",
        //                 "resource_path":"/v2/accounts/94ad58bc-0f15-5309-b35a-a4c86d7bad60",
        //                 "allow_deposits":true,
        //                 "allow_withdrawals":true
        //             },
        //         ]
        //     }
        //
        // v3PrivateGetBrokerageAccounts
        //     {
        //         "accounts": [
        //             {
        //                 "uuid": "11111111-1111-1111-1111-111111111111",
        //                 "name": "USDC Wallet",
        //                 "currency": "USDC",
        //                 "available_balance": {
        //                     "value": "0.0000000000000000",
        //                     "currency": "USDC"
        //                 },
        //                 "default": true,
        //                 "active": true,
        //                 "created_at": "2023-01-04T06:20:06.456Z",
        //                 "updated_at": "2023-01-04T06:20:07.181Z",
        //                 "deleted_at": null,
        //                 "type": "ACCOUNT_TYPE_CRYPTO",
        //                 "ready": false,
        //                 "hold": {
        //                     "value": "0.0000000000000000",
        //                     "currency": "USDC"
        //                 }
        //             },
        //             ...
        //         ],
        //         "has_next": false,
        //         "cursor": "",
        //         "size": 9
        //     }
        //
        ((IDictionary<string,object>)parameters)["type"] = marketType;
        return this.parseCustomBalance(response, parameters);
    }

    public async override Task<object> fetchLedger(object code = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name coinbase#fetchLedger
        * @description fetch the history of changes, actions done by the user or operations that altered balance of the user
        * @see https://docs.cloud.coinbase.com/sign-in-with-coinbase/docs/api-transactions#list-transactions
        * @param {string} code unified currency code, default is undefined
        * @param {int} [since] timestamp in ms of the earliest ledger entry, default is undefined
        * @param {int} [limit] max number of ledger entrys to return, default is undefined
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [availble parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
        * @returns {object} a [ledger structure]{@link https://docs.ccxt.com/#/?id=ledger-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object paginate = false;
        var paginateparametersVariable = this.handleOptionAndParams(parameters, "fetchLedger", "paginate");
        paginate = ((IList<object>)paginateparametersVariable)[0];
        parameters = ((IList<object>)paginateparametersVariable)[1];
        if (isTrue(paginate))
        {
            return await this.fetchPaginatedCallCursor("fetchLedger", code, since, limit, parameters, "next_starting_after", "starting_after", null, 100);
        }
        object currency = null;
        if (isTrue(!isEqual(code, null)))
        {
            currency = this.currency(code);
        }
        object request = null;
        var requestparametersVariable = await this.prepareAccountRequestWithCurrencyCode(code, limit, parameters);
        request = ((IList<object>)requestparametersVariable)[0];
        parameters = ((IList<object>)requestparametersVariable)[1];
        // for pagination use parameter 'starting_after'
        // the value for the next page can be obtained from the result of the previous call in the 'pagination' field
        // eg: instance.last_json_response.pagination.next_starting_after
        object response = await this.v2PrivateGetAccountsAccountIdTransactions(this.extend(request, parameters));
        object ledger = this.parseLedger(getValue(response, "data"), currency, since, limit);
        object length = getArrayLength(ledger);
        if (isTrue(isEqual(length, 0)))
        {
            return ledger;
        }
        object lastIndex = subtract(length, 1);
        object last = this.safeDict(ledger, lastIndex);
        object pagination = this.safeDict(response, "pagination", new Dictionary<string, object>() {});
        object cursor = this.safeString(pagination, "next_starting_after");
        if (isTrue(isTrue((!isEqual(cursor, null))) && isTrue((!isEqual(cursor, "")))))
        {
            ((IDictionary<string,object>)last)["next_starting_after"] = cursor;
            ((List<object>)ledger)[Convert.ToInt32(lastIndex)] = last;
        }
        return ledger;
    }

    public virtual object parseLedgerEntryStatus(object status)
    {
        object types = new Dictionary<string, object>() {
            { "completed", "ok" },
        };
        return this.safeString(types, status, status);
    }

    public virtual object parseLedgerEntryType(object type)
    {
        object types = new Dictionary<string, object>() {
            { "buy", "trade" },
            { "sell", "trade" },
            { "fiat_deposit", "transaction" },
            { "fiat_withdrawal", "transaction" },
            { "exchange_deposit", "transaction" },
            { "exchange_withdrawal", "transaction" },
            { "send", "transaction" },
            { "pro_deposit", "transaction" },
            { "pro_withdrawal", "transaction" },
        };
        return this.safeString(types, type, type);
    }

    public override object parseLedgerEntry(object item, object currency = null)
    {
        //
        // crypto deposit transaction
        //
        //     {
        //         "id": "34e4816b-4c8c-5323-a01c-35a9fa26e490",
        //         "type": "send",
        //         "status": "completed",
        //         "amount": { amount: "28.31976528", currency: "BCH" },
        //         "native_amount": { amount: "2799.65", currency: "GBP" },
        //         "description": null,
        //         "created_at": "2019-02-28T12:35:20Z",
        //         "updated_at": "2019-02-28T12:43:24Z",
        //         "resource": "transaction",
        //         "resource_path": "/v2/accounts/c01d7364-edd7-5f3a-bd1d-de53d4cbb25e/transactions/34e4816b-4c8c-5323-a01c-35a9fa26e490",
        //         "instant_exchange": false,
        //         "network": {
        //             "status": "confirmed",
        //             "hash": "56222d865dae83774fccb2efbd9829cf08c75c94ce135bfe4276f3fb46d49701",
        //             "transaction_url": "https://bch.btc.com/56222d865dae83774fccb2efbd9829cf08c75c94ce135bfe4276f3fb46d49701"
        //         },
        //         "from": { resource: "bitcoin_cash_network", currency: "BCH" },
        //         "details": { title: 'Received Bitcoin Cash', subtitle: "From Bitcoin Cash address" }
        //     }
        //
        // crypto withdrawal transaction
        //
        //     {
        //         "id": "459aad99-2c41-5698-ac71-b6b81a05196c",
        //         "type": "send",
        //         "status": "completed",
        //         "amount": { amount: "-0.36775642", currency: "BTC" },
        //         "native_amount": { amount: "-1111.65", currency: "GBP" },
        //         "description": null,
        //         "created_at": "2019-03-20T08:37:07Z",
        //         "updated_at": "2019-03-20T08:49:33Z",
        //         "resource": "transaction",
        //         "resource_path": "/v2/accounts/c6afbd34-4bd0-501e-8616-4862c193cd84/transactions/459aad99-2c41-5698-ac71-b6b81a05196c",
        //         "instant_exchange": false,
        //         "network": {
        //             "status": "confirmed",
        //             "hash": "2732bbcf35c69217c47b36dce64933d103895277fe25738ffb9284092701e05b",
        //             "transaction_url": "https://blockchain.info/tx/2732bbcf35c69217c47b36dce64933d103895277fe25738ffb9284092701e05b",
        //             "transaction_fee": { amount: "0.00000000", currency: "BTC" },
        //             "transaction_amount": { amount: "0.36775642", currency: "BTC" },
        //             "confirmations": 15682
        //         },
        //         "to": {
        //             "resource": "bitcoin_address",
        //             "address": "1AHnhqbvbYx3rnZx8uC7NbFZaTe4tafFHX",
        //             "currency": "BTC",
        //             "address_info": { address: "1AHnhqbvbYx3rnZx8uC7NbFZaTe4tafFHX" }
        //         },
        //         "idem": "da0a2f14-a2af-4c5a-a37e-d4484caf582bsend",
        //         "application": {
        //             "id": "5756ab6e-836b-553b-8950-5e389451225d",
        //             "resource": "application",
        //             "resource_path": "/v2/applications/5756ab6e-836b-553b-8950-5e389451225d"
        //         },
        //         "details": { title: 'Sent Bitcoin', subtitle: "To Bitcoin address" }
        //     }
        //
        // withdrawal transaction from coinbase to coinbasepro
        //
        //     {
        //         "id": "5b1b9fb8-5007-5393-b923-02903b973fdc",
        //         "type": "pro_deposit",
        //         "status": "completed",
        //         "amount": { amount: "-0.00001111", currency: "BCH" },
        //         "native_amount": { amount: "0.00", currency: "GBP" },
        //         "description": null,
        //         "created_at": "2019-02-28T13:31:58Z",
        //         "updated_at": "2019-02-28T13:31:58Z",
        //         "resource": "transaction",
        //         "resource_path": "/v2/accounts/c01d7364-edd7-5f3a-bd1d-de53d4cbb25e/transactions/5b1b9fb8-5007-5393-b923-02903b973fdc",
        //         "instant_exchange": false,
        //         "application": {
        //             "id": "5756ab6e-836b-553b-8950-5e389451225d",
        //             "resource": "application",
        //             "resource_path": "/v2/applications/5756ab6e-836b-553b-8950-5e389451225d"
        //         },
        //         "details": { title: 'Transferred Bitcoin Cash', subtitle: "To Coinbase Pro" }
        //     }
        //
        // withdrawal transaction from coinbase to gdax
        //
        //     {
        //         "id": "badb7313-a9d3-5c07-abd0-00f8b44199b1",
        //         "type": "exchange_deposit",
        //         "status": "completed",
        //         "amount": { amount: "-0.43704149", currency: "BCH" },
        //         "native_amount": { amount: "-51.90", currency: "GBP" },
        //         "description": null,
        //         "created_at": "2019-03-19T10:30:40Z",
        //         "updated_at": "2019-03-19T10:30:40Z",
        //         "resource": "transaction",
        //         "resource_path": "/v2/accounts/c01d7364-edd7-5f3a-bd1d-de53d4cbb25e/transactions/badb7313-a9d3-5c07-abd0-00f8b44199b1",
        //         "instant_exchange": false,
        //         "details": { title: 'Transferred Bitcoin Cash', subtitle: "To GDAX" }
        //     }
        //
        // deposit transaction from gdax to coinbase
        //
        //     {
        //         "id": "9c4b642c-8688-58bf-8962-13cef64097de",
        //         "type": "exchange_withdrawal",
        //         "status": "completed",
        //         "amount": { amount: "0.57729420", currency: "BTC" },
        //         "native_amount": { amount: "4418.72", currency: "GBP" },
        //         "description": null,
        //         "created_at": "2018-02-17T11:33:33Z",
        //         "updated_at": "2018-02-17T11:33:33Z",
        //         "resource": "transaction",
        //         "resource_path": "/v2/accounts/c6afbd34-4bd0-501e-8616-4862c193cd84/transactions/9c4b642c-8688-58bf-8962-13cef64097de",
        //         "instant_exchange": false,
        //         "details": { title: 'Transferred Bitcoin', subtitle: "From GDAX" }
        //     }
        //
        // deposit transaction from coinbasepro to coinbase
        //
        //     {
        //         "id": "8d6dd0b9-3416-568a-889d-8f112fae9e81",
        //         "type": "pro_withdrawal",
        //         "status": "completed",
        //         "amount": { amount: "0.40555386", currency: "BTC" },
        //         "native_amount": { amount: "1140.27", currency: "GBP" },
        //         "description": null,
        //         "created_at": "2019-03-04T19:41:58Z",
        //         "updated_at": "2019-03-04T19:41:58Z",
        //         "resource": "transaction",
        //         "resource_path": "/v2/accounts/c6afbd34-4bd0-501e-8616-4862c193cd84/transactions/8d6dd0b9-3416-568a-889d-8f112fae9e81",
        //         "instant_exchange": false,
        //         "application": {
        //             "id": "5756ab6e-836b-553b-8950-5e389451225d",
        //             "resource": "application",
        //             "resource_path": "/v2/applications/5756ab6e-836b-553b-8950-5e389451225d"
        //         },
        //         "details": { title: 'Transferred Bitcoin', subtitle: "From Coinbase Pro" }
        //     }
        //
        // sell trade
        //
        //     {
        //         "id": "a9409207-df64-585b-97ab-a50780d2149e",
        //         "type": "sell",
        //         "status": "completed",
        //         "amount": { amount: "-9.09922880", currency: "BTC" },
        //         "native_amount": { amount: "-7285.73", currency: "GBP" },
        //         "description": null,
        //         "created_at": "2017-03-27T15:38:34Z",
        //         "updated_at": "2017-03-27T15:38:34Z",
        //         "resource": "transaction",
        //         "resource_path": "/v2/accounts/c6afbd34-4bd0-501e-8616-4862c193cd84/transactions/a9409207-df64-585b-97ab-a50780d2149e",
        //         "instant_exchange": false,
        //         "sell": {
        //             "id": "e3550b4d-8ae6-5de3-95fe-1fb01ba83051",
        //             "resource": "sell",
        //             "resource_path": "/v2/accounts/c6afbd34-4bd0-501e-8616-4862c193cd84/sells/e3550b4d-8ae6-5de3-95fe-1fb01ba83051"
        //         },
        //         "details": {
        //             "title": "Sold Bitcoin",
        //             "subtitle": "Using EUR Wallet",
        //             "payment_method_name": "EUR Wallet"
        //         }
        //     }
        //
        // buy trade
        //
        //     {
        //         "id": "63eeed67-9396-5912-86e9-73c4f10fe147",
        //         "type": "buy",
        //         "status": "completed",
        //         "amount": { amount: "2.39605772", currency: "ETH" },
        //         "native_amount": { amount: "98.31", currency: "GBP" },
        //         "description": null,
        //         "created_at": "2017-03-27T09:07:56Z",
        //         "updated_at": "2017-03-27T09:07:57Z",
        //         "resource": "transaction",
        //         "resource_path": "/v2/accounts/8902f85d-4a69-5d74-82fe-8e390201bda7/transactions/63eeed67-9396-5912-86e9-73c4f10fe147",
        //         "instant_exchange": false,
        //         "buy": {
        //             "id": "20b25b36-76c6-5353-aa57-b06a29a39d82",
        //             "resource": "buy",
        //             "resource_path": "/v2/accounts/8902f85d-4a69-5d74-82fe-8e390201bda7/buys/20b25b36-76c6-5353-aa57-b06a29a39d82"
        //         },
        //         "details": {
        //             "title": "Bought Ethereum",
        //             "subtitle": "Using EUR Wallet",
        //             "payment_method_name": "EUR Wallet"
        //         }
        //     }
        //
        // fiat deposit transaction
        //
        //     {
        //         "id": "04ed4113-3732-5b0c-af86-b1d2146977d0",
        //         "type": "fiat_deposit",
        //         "status": "completed",
        //         "amount": { amount: "114.02", currency: "EUR" },
        //         "native_amount": { amount: "97.23", currency: "GBP" },
        //         "description": null,
        //         "created_at": "2017-02-09T07:01:21Z",
        //         "updated_at": "2017-02-09T07:01:22Z",
        //         "resource": "transaction",
        //         "resource_path": "/v2/accounts/91cd2d36-3a91-55b6-a5d4-0124cf105483/transactions/04ed4113-3732-5b0c-af86-b1d2146977d0",
        //         "instant_exchange": false,
        //         "fiat_deposit": {
        //             "id": "f34c19f3-b730-5e3d-9f72-96520448677a",
        //             "resource": "fiat_deposit",
        //             "resource_path": "/v2/accounts/91cd2d36-3a91-55b6-a5d4-0124cf105483/deposits/f34c19f3-b730-5e3d-9f72-96520448677a"
        //         },
        //         "details": {
        //             "title": "Deposited funds",
        //             "subtitle": "From SEPA Transfer (GB47 BARC 20..., reference CBADVI)",
        //             "payment_method_name": "SEPA Transfer (GB47 BARC 20..., reference CBADVI)"
        //         }
        //     }
        //
        // fiat withdrawal transaction
        //
        //     {
        //         "id": "957d98e2-f80e-5e2f-a28e-02945aa93079",
        //         "type": "fiat_withdrawal",
        //         "status": "completed",
        //         "amount": { amount: "-11000.00", currency: "EUR" },
        //         "native_amount": { amount: "-9698.22", currency: "GBP" },
        //         "description": null,
        //         "created_at": "2017-12-06T13:19:19Z",
        //         "updated_at": "2017-12-06T13:19:19Z",
        //         "resource": "transaction",
        //         "resource_path": "/v2/accounts/91cd2d36-3a91-55b6-a5d4-0124cf105483/transactions/957d98e2-f80e-5e2f-a28e-02945aa93079",
        //         "instant_exchange": false,
        //         "fiat_withdrawal": {
        //             "id": "f4bf1fd9-ab3b-5de7-906d-ed3e23f7a4e7",
        //             "resource": "fiat_withdrawal",
        //             "resource_path": "/v2/accounts/91cd2d36-3a91-55b6-a5d4-0124cf105483/withdrawals/f4bf1fd9-ab3b-5de7-906d-ed3e23f7a4e7"
        //         },
        //         "details": {
        //             "title": "Withdrew funds",
        //             "subtitle": "To HSBC BANK PLC (GB74 MIDL...)",
        //             "payment_method_name": "HSBC BANK PLC (GB74 MIDL...)"
        //         }
        //     }
        //
        object amountInfo = this.safeDict(item, "amount", new Dictionary<string, object>() {});
        object amount = this.safeString(amountInfo, "amount");
        object direction = null;
        if (isTrue(Precise.stringLt(amount, "0")))
        {
            direction = "out";
            amount = Precise.stringNeg(amount);
        } else
        {
            direction = "in";
        }
        object currencyId = this.safeString(amountInfo, "currency");
        object code = this.safeCurrencyCode(currencyId, currency);
        //
        // the address and txid do not belong to the unified ledger structure
        //
        //     let address = undefined;
        //     if (item['to']) {
        //         address = this.safeString (item['to'], 'address');
        //     }
        //     let txid = undefined;
        //
        object fee = null;
        object networkInfo = this.safeDict(item, "network", new Dictionary<string, object>() {});
        // txid = network['hash']; // txid does not belong to the unified ledger structure
        object feeInfo = this.safeDict(networkInfo, "transaction_fee");
        if (isTrue(!isEqual(feeInfo, null)))
        {
            object feeCurrencyId = this.safeString(feeInfo, "currency");
            object feeCurrencyCode = this.safeCurrencyCode(feeCurrencyId, currency);
            object feeAmount = this.safeNumber(feeInfo, "amount");
            fee = new Dictionary<string, object>() {
                { "cost", feeAmount },
                { "currency", feeCurrencyCode },
            };
        }
        object timestamp = this.parse8601(this.safeString(item, "created_at"));
        object id = this.safeString(item, "id");
        object type = this.parseLedgerEntryType(this.safeString(item, "type"));
        object status = this.parseLedgerEntryStatus(this.safeString(item, "status"));
        object path = this.safeString(item, "resource_path");
        object accountId = null;
        if (isTrue(!isEqual(path, null)))
        {
            object parts = ((string)path).Split(new [] {((string)"/")}, StringSplitOptions.None).ToList<object>();
            object numParts = getArrayLength(parts);
            if (isTrue(isGreaterThan(numParts, 3)))
            {
                accountId = getValue(parts, 3);
            }
        }
        return new Dictionary<string, object>() {
            { "info", item },
            { "id", id },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "direction", direction },
            { "account", accountId },
            { "referenceId", null },
            { "referenceAccount", null },
            { "type", type },
            { "currency", code },
            { "amount", this.parseNumber(amount) },
            { "before", null },
            { "after", null },
            { "status", status },
            { "fee", fee },
        };
    }

    public async virtual Task<object> findAccountId(object code, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        await this.loadAccounts(false, parameters);
        for (object i = 0; isLessThan(i, getArrayLength(this.accounts)); postFixIncrement(ref i))
        {
            object account = getValue(this.accounts, i);
            if (isTrue(isEqual(getValue(account, "code"), code)))
            {
                return getValue(account, "id");
            }
        }
        return null;
    }

    public virtual object prepareAccountRequest(object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object accountId = this.safeString2(parameters, "account_id", "accountId");
        if (isTrue(isEqual(accountId, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " prepareAccountRequest() method requires an account_id (or accountId) parameter")) ;
        }
        object request = new Dictionary<string, object>() {
            { "account_id", accountId },
        };
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        return request;
    }

    public async virtual Task<object> prepareAccountRequestWithCurrencyCode(object code = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object accountId = this.safeString2(parameters, "account_id", "accountId");
        parameters = this.omit(parameters, new List<object>() {"account_id", "accountId"});
        if (isTrue(isEqual(accountId, null)))
        {
            if (isTrue(isEqual(code, null)))
            {
                throw new ArgumentsRequired ((string)add(this.id, " prepareAccountRequestWithCurrencyCode() method requires an account_id (or accountId) parameter OR a currency code argument")) ;
            }
            accountId = await this.findAccountId(code, parameters);
            if (isTrue(isEqual(accountId, null)))
            {
                throw new ExchangeError ((string)add(add(this.id, " prepareAccountRequestWithCurrencyCode() could not find account id for "), code)) ;
            }
        }
        object request = new Dictionary<string, object>() {
            { "account_id", accountId },
        };
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        return new List<object>() {request, parameters};
    }

    public async override Task<object> createMarketBuyOrderWithCost(object symbol, object cost, object parameters = null)
    {
        /**
        * @method
        * @name coinbase#createMarketBuyOrderWithCost
        * @description create a market buy order by providing the symbol and cost
        * @see https://docs.cloud.coinbase.com/advanced-trade-api/reference/retailbrokerageapi_postorder
        * @param {string} symbol unified symbol of the market to create an order in
        * @param {float} cost how much you want to trade in units of the quote currency
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        if (!isTrue(getValue(market, "spot")))
        {
            throw new NotSupported ((string)add(this.id, " createMarketBuyOrderWithCost() supports spot orders only")) ;
        }
        ((IDictionary<string,object>)parameters)["createMarketBuyOrderRequiresPrice"] = false;
        return await this.createOrder(symbol, "market", "buy", cost, null, parameters);
    }

    public async override Task<object> createOrder(object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        /**
        * @method
        * @name coinbase#createOrder
        * @description create a trade order
        * @see https://docs.cloud.coinbase.com/advanced-trade-api/reference/retailbrokerageapi_postorder
        * @param {string} symbol unified symbol of the market to create an order in
        * @param {string} type 'market' or 'limit'
        * @param {string} side 'buy' or 'sell'
        * @param {float} amount how much you want to trade in units of the base currency, quote currency for 'market' 'buy' orders
        * @param {float} [price] the price to fulfill the order, in units of the quote currency, ignored in market orders
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {float} [params.stopPrice] price to trigger stop orders
        * @param {float} [params.triggerPrice] price to trigger stop orders
        * @param {float} [params.stopLossPrice] price to trigger stop-loss orders
        * @param {float} [params.takeProfitPrice] price to trigger take-profit orders
        * @param {bool} [params.postOnly] true or false
        * @param {string} [params.timeInForce] 'GTC', 'IOC', 'GTD' or 'PO', 'FOK'
        * @param {string} [params.stop_direction] 'UNKNOWN_STOP_DIRECTION', 'STOP_DIRECTION_STOP_UP', 'STOP_DIRECTION_STOP_DOWN' the direction the stopPrice is triggered from
        * @param {string} [params.end_time] '2023-05-25T17:01:05.092Z' for 'GTD' orders
        * @param {float} [params.cost] *spot market buy only* the quote quantity that can be used as an alternative for the amount
        * @param {boolean} [params.preview] default to false, wether to use the test/preview endpoint or not
        * @param {float} [params.leverage] default to 1, the leverage to use for the order
        * @param {string} [params.marginMode] 'cross' or 'isolated'
        * @param {string} [params.retail_portfolio_id] portfolio uid
        * @param {boolean} [params.is_max] Used in conjunction with tradable_balance to indicate the user wants to use their entire tradable balance
        * @param {string} [params.tradable_balance] amount of tradable balance
        * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object id = this.safeString(this.options, "brokerId", "ccxt");
        object request = new Dictionary<string, object>() {
            { "client_order_id", add(add(id, "-"), this.uuid()) },
            { "product_id", getValue(market, "id") },
            { "side", ((string)side).ToUpper() },
        };
        object stopPrice = this.safeNumberN(parameters, new List<object>() {"stopPrice", "stop_price", "triggerPrice"});
        object stopLossPrice = this.safeNumber(parameters, "stopLossPrice");
        object takeProfitPrice = this.safeNumber(parameters, "takeProfitPrice");
        object isStop = !isEqual(stopPrice, null);
        object isStopLoss = !isEqual(stopLossPrice, null);
        object isTakeProfit = !isEqual(takeProfitPrice, null);
        object timeInForce = this.safeString(parameters, "timeInForce");
        object postOnly = ((bool) isTrue((isEqual(timeInForce, "PO")))) ? true : this.safeBool2(parameters, "postOnly", "post_only", false);
        object endTime = this.safeString(parameters, "end_time");
        object stopDirection = this.safeString(parameters, "stop_direction");
        if (isTrue(isEqual(type, "limit")))
        {
            if (isTrue(isStop))
            {
                if (isTrue(isEqual(stopDirection, null)))
                {
                    stopDirection = ((bool) isTrue((isEqual(side, "buy")))) ? "STOP_DIRECTION_STOP_DOWN" : "STOP_DIRECTION_STOP_UP";
                }
                if (isTrue(isTrue((isEqual(timeInForce, "GTD"))) || isTrue((!isEqual(endTime, null)))))
                {
                    if (isTrue(isEqual(endTime, null)))
                    {
                        throw new ExchangeError ((string)add(this.id, " createOrder() requires an end_time parameter for a GTD order")) ;
                    }
                    ((IDictionary<string,object>)request)["order_configuration"] = new Dictionary<string, object>() {
                        { "stop_limit_stop_limit_gtd", new Dictionary<string, object>() {
                            { "base_size", this.amountToPrecision(symbol, amount) },
                            { "limit_price", this.priceToPrecision(symbol, price) },
                            { "stop_price", this.priceToPrecision(symbol, stopPrice) },
                            { "stop_direction", stopDirection },
                            { "end_time", endTime },
                        } },
                    };
                } else
                {
                    ((IDictionary<string,object>)request)["order_configuration"] = new Dictionary<string, object>() {
                        { "stop_limit_stop_limit_gtc", new Dictionary<string, object>() {
                            { "base_size", this.amountToPrecision(symbol, amount) },
                            { "limit_price", this.priceToPrecision(symbol, price) },
                            { "stop_price", this.priceToPrecision(symbol, stopPrice) },
                            { "stop_direction", stopDirection },
                        } },
                    };
                }
            } else if (isTrue(isTrue(isStopLoss) || isTrue(isTakeProfit)))
            {
                object triggerPrice = null;
                if (isTrue(isStopLoss))
                {
                    if (isTrue(isEqual(stopDirection, null)))
                    {
                        stopDirection = ((bool) isTrue((isEqual(side, "buy")))) ? "STOP_DIRECTION_STOP_UP" : "STOP_DIRECTION_STOP_DOWN";
                    }
                    triggerPrice = this.priceToPrecision(symbol, stopLossPrice);
                } else
                {
                    if (isTrue(isEqual(stopDirection, null)))
                    {
                        stopDirection = ((bool) isTrue((isEqual(side, "buy")))) ? "STOP_DIRECTION_STOP_DOWN" : "STOP_DIRECTION_STOP_UP";
                    }
                    triggerPrice = this.priceToPrecision(symbol, takeProfitPrice);
                }
                ((IDictionary<string,object>)request)["order_configuration"] = new Dictionary<string, object>() {
                    { "stop_limit_stop_limit_gtc", new Dictionary<string, object>() {
                        { "base_size", this.amountToPrecision(symbol, amount) },
                        { "limit_price", this.priceToPrecision(symbol, price) },
                        { "stop_price", triggerPrice },
                        { "stop_direction", stopDirection },
                    } },
                };
            } else
            {
                if (isTrue(isTrue((isEqual(timeInForce, "GTD"))) || isTrue((!isEqual(endTime, null)))))
                {
                    if (isTrue(isEqual(endTime, null)))
                    {
                        throw new ExchangeError ((string)add(this.id, " createOrder() requires an end_time parameter for a GTD order")) ;
                    }
                    ((IDictionary<string,object>)request)["order_configuration"] = new Dictionary<string, object>() {
                        { "limit_limit_gtd", new Dictionary<string, object>() {
                            { "base_size", this.amountToPrecision(symbol, amount) },
                            { "limit_price", this.priceToPrecision(symbol, price) },
                            { "end_time", endTime },
                            { "post_only", postOnly },
                        } },
                    };
                } else if (isTrue(isEqual(timeInForce, "IOC")))
                {
                    ((IDictionary<string,object>)request)["order_configuration"] = new Dictionary<string, object>() {
                        { "sor_limit_ioc", new Dictionary<string, object>() {
                            { "base_size", this.amountToPrecision(symbol, amount) },
                            { "limit_price", this.priceToPrecision(symbol, price) },
                        } },
                    };
                } else if (isTrue(isEqual(timeInForce, "FOK")))
                {
                    ((IDictionary<string,object>)request)["order_configuration"] = new Dictionary<string, object>() {
                        { "limit_limit_fok", new Dictionary<string, object>() {
                            { "base_size", this.amountToPrecision(symbol, amount) },
                            { "limit_price", this.priceToPrecision(symbol, price) },
                        } },
                    };
                } else
                {
                    ((IDictionary<string,object>)request)["order_configuration"] = new Dictionary<string, object>() {
                        { "limit_limit_gtc", new Dictionary<string, object>() {
                            { "base_size", this.amountToPrecision(symbol, amount) },
                            { "limit_price", this.priceToPrecision(symbol, price) },
                            { "post_only", postOnly },
                        } },
                    };
                }
            }
        } else
        {
            if (isTrue(isTrue(isTrue(isStop) || isTrue(isStopLoss)) || isTrue(isTakeProfit)))
            {
                throw new NotSupported ((string)add(this.id, " createOrder() only stop limit orders are supported")) ;
            }
            if (isTrue(isTrue(getValue(market, "spot")) && isTrue((isEqual(side, "buy")))))
            {
                object total = null;
                object createMarketBuyOrderRequiresPrice = true;
                var createMarketBuyOrderRequiresPriceparametersVariable = this.handleOptionAndParams(parameters, "createOrder", "createMarketBuyOrderRequiresPrice", true);
                createMarketBuyOrderRequiresPrice = ((IList<object>)createMarketBuyOrderRequiresPriceparametersVariable)[0];
                parameters = ((IList<object>)createMarketBuyOrderRequiresPriceparametersVariable)[1];
                object cost = this.safeNumber(parameters, "cost");
                parameters = this.omit(parameters, "cost");
                if (isTrue(!isEqual(cost, null)))
                {
                    total = this.costToPrecision(symbol, cost);
                } else if (isTrue(createMarketBuyOrderRequiresPrice))
                {
                    if (isTrue(isEqual(price, null)))
                    {
                        throw new InvalidOrder ((string)add(this.id, " createOrder() requires a price argument for market buy orders on spot markets to calculate the total amount to spend (amount * price), alternatively set the createMarketBuyOrderRequiresPrice option or param to false and pass the cost to spend in the amount argument")) ;
                    } else
                    {
                        object amountString = this.numberToString(amount);
                        object priceString = this.numberToString(price);
                        object costRequest = Precise.stringMul(amountString, priceString);
                        total = this.costToPrecision(symbol, costRequest);
                    }
                } else
                {
                    total = this.costToPrecision(symbol, amount);
                }
                ((IDictionary<string,object>)request)["order_configuration"] = new Dictionary<string, object>() {
                    { "market_market_ioc", new Dictionary<string, object>() {
                        { "quote_size", total },
                    } },
                };
            } else
            {
                ((IDictionary<string,object>)request)["order_configuration"] = new Dictionary<string, object>() {
                    { "market_market_ioc", new Dictionary<string, object>() {
                        { "base_size", this.amountToPrecision(symbol, amount) },
                    } },
                };
            }
        }
        object marginMode = this.safeString(parameters, "marginMode");
        if (isTrue(!isEqual(marginMode, null)))
        {
            if (isTrue(isEqual(marginMode, "isolated")))
            {
                ((IDictionary<string,object>)request)["margin_type"] = "ISOLATED";
            } else if (isTrue(isEqual(marginMode, "cross")))
            {
                ((IDictionary<string,object>)request)["margin_type"] = "CROSS";
            }
        }
        parameters = this.omit(parameters, new List<object>() {"timeInForce", "triggerPrice", "stopLossPrice", "takeProfitPrice", "stopPrice", "stop_price", "stopDirection", "stop_direction", "clientOrderId", "postOnly", "post_only", "end_time", "marginMode"});
        object preview = this.safeBool2(parameters, "preview", "test", false);
        object response = null;
        if (isTrue(preview))
        {
            parameters = this.omit(parameters, new List<object>() {"preview", "test"});
            request = this.omit(request, "client_order_id");
            response = await this.v3PrivatePostBrokerageOrdersPreview(this.extend(request, parameters));
        } else
        {
            response = await this.v3PrivatePostBrokerageOrders(this.extend(request, parameters));
        }
        //
        // successful order
        //
        //     {
        //         "success": true,
        //         "failure_reason": "UNKNOWN_FAILURE_REASON",
        //         "order_id": "52cfe5e2-0b29-4c19-a245-a6a773de5030",
        //         "success_response": {
        //             "order_id": "52cfe5e2-0b29-4c19-a245-a6a773de5030",
        //             "product_id": "LTC-BTC",
        //             "side": "SELL",
        //             "client_order_id": "4d760580-6fca-4094-a70b-ebcca8626288"
        //         },
        //         "order_configuration": null
        //     }
        //
        // failed order
        //
        //     {
        //         "success": false,
        //         "failure_reason": "UNKNOWN_FAILURE_REASON",
        //         "order_id": "",
        //         "error_response": {
        //             "error": "UNSUPPORTED_ORDER_CONFIGURATION",
        //             "message": "source is not enabled for trading",
        //             "error_details": "",
        //             "new_order_failure_reason": "UNSUPPORTED_ORDER_CONFIGURATION"
        //         },
        //         "order_configuration": {
        //             "limit_limit_gtc": {
        //                 "base_size": "100",
        //                 "limit_price": "40000",
        //                 "post_only": false
        //             }
        //         }
        //     }
        //
        object success = this.safeBool(response, "success");
        if (isTrue(!isEqual(success, true)))
        {
            object errorResponse = this.safeDict(response, "error_response");
            object errorTitle = this.safeString(errorResponse, "error");
            object errorMessage = this.safeString(errorResponse, "message");
            if (isTrue(!isEqual(errorResponse, null)))
            {
                this.throwExactlyMatchedException(getValue(this.exceptions, "exact"), errorTitle, errorMessage);
                this.throwBroadlyMatchedException(getValue(this.exceptions, "broad"), errorTitle, errorMessage);
                throw new ExchangeError ((string)errorMessage) ;
            }
        }
        object data = this.safeDict(response, "success_response", new Dictionary<string, object>() {});
        return this.parseOrder(data, market);
    }

    public override object parseOrder(object order, object market = null)
    {
        //
        // createOrder
        //
        //     {
        //         "order_id": "52cfe5e2-0b29-4c19-a245-a6a773de5030",
        //         "product_id": "LTC-BTC",
        //         "side": "SELL",
        //         "client_order_id": "4d760580-6fca-4094-a70b-ebcca8626288"
        //     }
        //
        // cancelOrder, cancelOrders
        //
        //     {
        //         "success": true,
        //         "failure_reason": "UNKNOWN_CANCEL_FAILURE_REASON",
        //         "order_id": "bb8851a3-4fda-4a2c-aa06-9048db0e0f0d"
        //     }
        //
        // fetchOrder, fetchOrders, fetchOpenOrders, fetchClosedOrders, fetchCanceledOrders
        //
        //     {
        //         "order_id": "9bc1eb3b-5b46-4b71-9628-ae2ed0cca75b",
        //         "product_id": "LTC-BTC",
        //         "user_id": "1111111-1111-1111-1111-111111111111",
        //         "order_configuration": {
        //             "limit_limit_gtc": {
        //                 "base_size": "0.2",
        //                 "limit_price": "0.006",
        //                 "post_only": false
        //             },
        //             "stop_limit_stop_limit_gtc": {
        //                 "base_size": "48.54",
        //                 "limit_price": "6.998",
        //                 "stop_price": "7.0687",
        //                 "stop_direction": "STOP_DIRECTION_STOP_DOWN"
        //             }
        //         },
        //         "side": "SELL",
        //         "client_order_id": "e5fe8482-05bb-428f-ad4d-dbc8ce39239c",
        //         "status": "OPEN",
        //         "time_in_force": "GOOD_UNTIL_CANCELLED",
        //         "created_time": "2023-01-16T23:37:23.947030Z",
        //         "completion_percentage": "0",
        //         "filled_size": "0",
        //         "average_filled_price": "0",
        //         "fee": "",
        //         "number_of_fills": "0",
        //         "filled_value": "0",
        //         "pending_cancel": false,
        //         "size_in_quote": false,
        //         "total_fees": "0",
        //         "size_inclusive_of_fees": false,
        //         "total_value_after_fees": "0",
        //         "trigger_status": "INVALID_ORDER_TYPE",
        //         "order_type": "LIMIT",
        //         "reject_reason": "REJECT_REASON_UNSPECIFIED",
        //         "settled": false,
        //         "product_type": "SPOT",
        //         "reject_message": "",
        //         "cancel_message": ""
        //     }
        //
        object marketId = this.safeString(order, "product_id");
        object symbol = this.safeSymbol(marketId, market, "-");
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
        }
        object orderConfiguration = this.safeDict(order, "order_configuration", new Dictionary<string, object>() {});
        object limitGTC = this.safeDict(orderConfiguration, "limit_limit_gtc");
        object limitGTD = this.safeDict(orderConfiguration, "limit_limit_gtd");
        object limitIOC = this.safeDict(orderConfiguration, "sor_limit_ioc");
        object stopLimitGTC = this.safeDict(orderConfiguration, "stop_limit_stop_limit_gtc");
        object stopLimitGTD = this.safeDict(orderConfiguration, "stop_limit_stop_limit_gtd");
        object marketIOC = this.safeDict(orderConfiguration, "market_market_ioc");
        object isLimit = (isTrue(isTrue((!isEqual(limitGTC, null))) || isTrue((!isEqual(limitGTD, null)))) || isTrue((!isEqual(limitIOC, null))));
        object isStop = (isTrue((!isEqual(stopLimitGTC, null))) || isTrue((!isEqual(stopLimitGTD, null))));
        object price = null;
        object amount = null;
        object postOnly = null;
        object triggerPrice = null;
        if (isTrue(isLimit))
        {
            object target = null;
            if (isTrue(!isEqual(limitGTC, null)))
            {
                target = limitGTC;
            } else if (isTrue(!isEqual(limitGTD, null)))
            {
                target = limitGTD;
            } else
            {
                target = limitIOC;
            }
            price = this.safeString(target, "limit_price");
            amount = this.safeString(target, "base_size");
            postOnly = this.safeBool(target, "post_only");
        } else if (isTrue(isStop))
        {
            object stopTarget = ((bool) isTrue((!isEqual(stopLimitGTC, null)))) ? stopLimitGTC : stopLimitGTD;
            price = this.safeString(stopTarget, "limit_price");
            amount = this.safeString(stopTarget, "base_size");
            postOnly = this.safeBool(stopTarget, "post_only");
            triggerPrice = this.safeString(stopTarget, "stop_price");
        } else
        {
            amount = this.safeString(marketIOC, "base_size");
        }
        object datetime = this.safeString(order, "created_time");
        object totalFees = this.safeString(order, "total_fees");
        object currencyFee = null;
        if (isTrue(isTrue((!isEqual(totalFees, null))) && isTrue((!isEqual(market, null)))))
        {
            currencyFee = getValue(market, "quote");
        }
        return this.safeOrder(new Dictionary<string, object>() {
            { "info", order },
            { "id", this.safeString(order, "order_id") },
            { "clientOrderId", this.safeString(order, "client_order_id") },
            { "timestamp", this.parse8601(datetime) },
            { "datetime", datetime },
            { "lastTradeTimestamp", null },
            { "symbol", symbol },
            { "type", this.parseOrderType(this.safeString(order, "order_type")) },
            { "timeInForce", this.parseTimeInForce(this.safeString(order, "time_in_force")) },
            { "postOnly", postOnly },
            { "side", this.safeStringLower(order, "side") },
            { "price", price },
            { "stopPrice", triggerPrice },
            { "triggerPrice", triggerPrice },
            { "amount", amount },
            { "filled", this.safeString(order, "filled_size") },
            { "remaining", null },
            { "cost", null },
            { "average", this.safeString(order, "average_filled_price") },
            { "status", this.parseOrderStatus(this.safeString(order, "status")) },
            { "fee", new Dictionary<string, object>() {
                { "cost", this.safeString(order, "total_fees") },
                { "currency", currencyFee },
            } },
            { "trades", null },
        }, market);
    }

    public virtual object parseOrderStatus(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "OPEN", "open" },
            { "FILLED", "closed" },
            { "CANCELLED", "canceled" },
            { "EXPIRED", "canceled" },
            { "FAILED", "canceled" },
            { "UNKNOWN_ORDER_STATUS", null },
        };
        return this.safeString(statuses, status, status);
    }

    public virtual object parseOrderType(object type)
    {
        if (isTrue(isEqual(type, "UNKNOWN_ORDER_TYPE")))
        {
            return null;
        }
        object types = new Dictionary<string, object>() {
            { "MARKET", "market" },
            { "LIMIT", "limit" },
            { "STOP", "limit" },
            { "STOP_LIMIT", "limit" },
        };
        return this.safeString(types, type, type);
    }

    public virtual object parseTimeInForce(object timeInForce)
    {
        object timeInForces = new Dictionary<string, object>() {
            { "GOOD_UNTIL_CANCELLED", "GTC" },
            { "GOOD_UNTIL_DATE_TIME", "GTD" },
            { "IMMEDIATE_OR_CANCEL", "IOC" },
            { "FILL_OR_KILL", "FOK" },
            { "UNKNOWN_TIME_IN_FORCE", null },
        };
        return this.safeString(timeInForces, timeInForce, timeInForce);
    }

    public async override Task<object> cancelOrder(object id, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name coinbase#cancelOrder
        * @description cancels an open order
        * @see https://docs.cloud.coinbase.com/advanced-trade-api/reference/retailbrokerageapi_cancelorders
        * @param {string} id order id
        * @param {string} symbol not used by coinbase cancelOrder()
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object orders = await this.cancelOrders(new List<object>() {id}, symbol, parameters);
        return this.safeDict(orders, 0, new Dictionary<string, object>() {});
    }

    public async virtual Task<object> cancelOrders(object ids, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name coinbase#cancelOrders
        * @description cancel multiple orders
        * @see https://docs.cloud.coinbase.com/advanced-trade-api/reference/retailbrokerageapi_cancelorders
        * @param {string[]} ids order ids
        * @param {string} symbol not used by coinbase cancelOrders()
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
        }
        object request = new Dictionary<string, object>() {
            { "order_ids", ids },
        };
        object response = await this.v3PrivatePostBrokerageOrdersBatchCancel(this.extend(request, parameters));
        //
        //     {
        //         "results": [
        //             {
        //                 "success": true,
        //                 "failure_reason": "UNKNOWN_CANCEL_FAILURE_REASON",
        //                 "order_id": "bb8851a3-4fda-4a2c-aa06-9048db0e0f0d"
        //             }
        //         ]
        //     }
        //
        object orders = this.safeList(response, "results", new List<object>() {});
        for (object i = 0; isLessThan(i, getArrayLength(orders)); postFixIncrement(ref i))
        {
            object success = this.safeBool(getValue(orders, i), "success");
            if (isTrue(!isEqual(success, true)))
            {
                throw new BadRequest ((string)add(this.id, " cancelOrders() has failed, check your arguments and parameters")) ;
            }
        }
        return this.parseOrders(orders, market);
    }

    public async override Task<object> editOrder(object id, object symbol, object type, object side, object amount = null, object price = null, object parameters = null)
    {
        /**
        * @method
        * @name coinbase#editOrder
        * @description edit a trade order
        * @see https://docs.cloud.coinbase.com/advanced-trade-api/reference/retailbrokerageapi_editorder
        * @param {string} id cancel order id
        * @param {string} symbol unified symbol of the market to create an order in
        * @param {string} type 'market' or 'limit'
        * @param {string} side 'buy' or 'sell'
        * @param {float} amount how much of currency you want to trade in units of base currency
        * @param {float} [price] the price at which the order is to be fullfilled, in units of the base currency, ignored in market orders
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {boolean} [params.preview] default to false, wether to use the test/preview endpoint or not
        * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "order_id", id },
        };
        if (isTrue(!isEqual(amount, null)))
        {
            ((IDictionary<string,object>)request)["size"] = this.amountToPrecision(symbol, amount);
        }
        if (isTrue(!isEqual(price, null)))
        {
            ((IDictionary<string,object>)request)["price"] = this.priceToPrecision(symbol, price);
        }
        object preview = this.safeBool2(parameters, "preview", "test", false);
        object response = null;
        if (isTrue(preview))
        {
            parameters = this.omit(parameters, new List<object>() {"preview", "test"});
            response = await this.v3PrivatePostBrokerageOrdersEditPreview(this.extend(request, parameters));
        } else
        {
            response = await this.v3PrivatePostBrokerageOrdersEdit(this.extend(request, parameters));
        }
        //
        //     {
        //         "success": true,
        //         "errors": {
        //           "edit_failure_reason": "UNKNOWN_EDIT_ORDER_FAILURE_REASON",
        //           "preview_failure_reason": "UNKNOWN_PREVIEW_FAILURE_REASON"
        //         }
        //     }
        //
        return this.parseOrder(response, market);
    }

    public async override Task<object> fetchOrder(object id, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name coinbase#fetchOrder
        * @description fetches information on an order made by the user
        * @see https://docs.cloud.coinbase.com/advanced-trade-api/reference/retailbrokerageapi_gethistoricalorder
        * @param {string} id the order id
        * @param {string} symbol unified market symbol that the order was made in
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
        }
        object request = new Dictionary<string, object>() {
            { "order_id", id },
        };
        object response = await this.v3PrivateGetBrokerageOrdersHistoricalOrderId(this.extend(request, parameters));
        //
        //     {
        //         "order": {
        //             "order_id": "9bc1eb3b-5b46-4b71-9628-ae2ed0cca75b",
        //             "product_id": "LTC-BTC",
        //             "user_id": "1111111-1111-1111-1111-111111111111",
        //             "order_configuration": {
        //                 "limit_limit_gtc": {
        //                     "base_size": "0.2",
        //                     "limit_price": "0.006",
        //                     "post_only": false
        //                 }
        //             },
        //             "side": "SELL",
        //             "client_order_id": "e5fe8482-05bb-428f-ad4d-dbc8ce39239c",
        //             "status": "OPEN",
        //             "time_in_force": "GOOD_UNTIL_CANCELLED",
        //             "created_time": "2023-01-16T23:37:23.947030Z",
        //             "completion_percentage": "0",
        //             "filled_size": "0",
        //             "average_filled_price": "0",
        //             "fee": "",
        //             "number_of_fills": "0",
        //             "filled_value": "0",
        //             "pending_cancel": false,
        //             "size_in_quote": false,
        //             "total_fees": "0",
        //             "size_inclusive_of_fees": false,
        //             "total_value_after_fees": "0",
        //             "trigger_status": "INVALID_ORDER_TYPE",
        //             "order_type": "LIMIT",
        //             "reject_reason": "REJECT_REASON_UNSPECIFIED",
        //             "settled": false,
        //             "product_type": "SPOT",
        //             "reject_message": "",
        //             "cancel_message": ""
        //         }
        //     }
        //
        object order = this.safeDict(response, "order", new Dictionary<string, object>() {});
        return this.parseOrder(order, market);
    }

    public async override Task<object> fetchOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name coinbase#fetchOrders
        * @description fetches information on multiple orders made by the user
        * @see https://docs.cloud.coinbase.com/advanced-trade-api/reference/retailbrokerageapi_gethistoricalorders
        * @param {string} symbol unified market symbol that the orders were made in
        * @param {int} [since] the earliest time in ms to fetch orders
        * @param {int} [limit] the maximum number of order structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {int} [params.until] the latest time in ms to fetch trades for
        * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [availble parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
        * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        limit ??= 100;
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object paginate = false;
        var paginateparametersVariable = this.handleOptionAndParams(parameters, "fetchOrders", "paginate");
        paginate = ((IList<object>)paginateparametersVariable)[0];
        parameters = ((IList<object>)paginateparametersVariable)[1];
        if (isTrue(paginate))
        {
            return await this.fetchPaginatedCallCursor("fetchOrders", symbol, since, limit, parameters, "cursor", "cursor", null, 1000);
        }
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
        }
        object request = new Dictionary<string, object>() {};
        if (isTrue(!isEqual(market, null)))
        {
            ((IDictionary<string,object>)request)["product_id"] = getValue(market, "id");
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["start_date"] = this.iso8601(since);
        }
        object until = this.safeIntegerN(parameters, new List<object>() {"until"});
        if (isTrue(!isEqual(until, null)))
        {
            parameters = this.omit(parameters, new List<object>() {"until"});
            ((IDictionary<string,object>)request)["end_date"] = this.iso8601(until);
        }
        object response = await this.v3PrivateGetBrokerageOrdersHistoricalBatch(this.extend(request, parameters));
        //
        //     {
        //         "orders": [
        //             {
        //                 "order_id": "813a53c5-3e39-47bb-863d-2faf685d22d8",
        //                 "product_id": "BTC-USDT",
        //                 "user_id": "1111111-1111-1111-1111-111111111111",
        //                 "order_configuration": {
        //                     "market_market_ioc": {
        //                         "quote_size": "6.36"
        //                     }
        //                 },
        //                 "side": "BUY",
        //                 "client_order_id": "18eb9947-db49-4874-8e7b-39b8fe5f4317",
        //                 "status": "FILLED",
        //                 "time_in_force": "IMMEDIATE_OR_CANCEL",
        //                 "created_time": "2023-01-18T01:37:37.975552Z",
        //                 "completion_percentage": "100",
        //                 "filled_size": "0.000297920684505",
        //                 "average_filled_price": "21220.6399999973697697",
        //                 "fee": "",
        //                 "number_of_fills": "2",
        //                 "filled_value": "6.3220675944333996",
        //                 "pending_cancel": false,
        //                 "size_in_quote": true,
        //                 "total_fees": "0.0379324055666004",
        //                 "size_inclusive_of_fees": true,
        //                 "total_value_after_fees": "6.36",
        //                 "trigger_status": "INVALID_ORDER_TYPE",
        //                 "order_type": "MARKET",
        //                 "reject_reason": "REJECT_REASON_UNSPECIFIED",
        //                 "settled": true,
        //                 "product_type": "SPOT",
        //                 "reject_message": "",
        //                 "cancel_message": "Internal error"
        //             },
        //         ],
        //         "sequence": "0",
        //         "has_next": false,
        //         "cursor": ""
        //     }
        //
        object orders = this.safeList(response, "orders", new List<object>() {});
        object first = this.safeDict(orders, 0);
        object cursor = this.safeString(response, "cursor");
        if (isTrue(isTrue((!isEqual(cursor, null))) && isTrue((!isEqual(cursor, "")))))
        {
            ((IDictionary<string,object>)first)["cursor"] = cursor;
            ((List<object>)orders)[Convert.ToInt32(0)] = first;
        }
        return this.parseOrders(orders, market, since, limit);
    }

    public async virtual Task<object> fetchOrdersByStatus(object status, object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
        }
        object request = new Dictionary<string, object>() {
            { "order_status", status },
        };
        if (isTrue(!isEqual(market, null)))
        {
            ((IDictionary<string,object>)request)["product_id"] = getValue(market, "id");
        }
        if (isTrue(isEqual(limit, null)))
        {
            limit = 100;
        }
        ((IDictionary<string,object>)request)["limit"] = limit;
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["start_date"] = this.iso8601(since);
        }
        object until = this.safeIntegerN(parameters, new List<object>() {"until"});
        if (isTrue(!isEqual(until, null)))
        {
            parameters = this.omit(parameters, new List<object>() {"until"});
            ((IDictionary<string,object>)request)["end_date"] = this.iso8601(until);
        }
        object response = await this.v3PrivateGetBrokerageOrdersHistoricalBatch(this.extend(request, parameters));
        //
        //     {
        //         "orders": [
        //             {
        //                 "order_id": "813a53c5-3e39-47bb-863d-2faf685d22d8",
        //                 "product_id": "BTC-USDT",
        //                 "user_id": "1111111-1111-1111-1111-111111111111",
        //                 "order_configuration": {
        //                     "market_market_ioc": {
        //                         "quote_size": "6.36"
        //                     }
        //                 },
        //                 "side": "BUY",
        //                 "client_order_id": "18eb9947-db49-4874-8e7b-39b8fe5f4317",
        //                 "status": "FILLED",
        //                 "time_in_force": "IMMEDIATE_OR_CANCEL",
        //                 "created_time": "2023-01-18T01:37:37.975552Z",
        //                 "completion_percentage": "100",
        //                 "filled_size": "0.000297920684505",
        //                 "average_filled_price": "21220.6399999973697697",
        //                 "fee": "",
        //                 "number_of_fills": "2",
        //                 "filled_value": "6.3220675944333996",
        //                 "pending_cancel": false,
        //                 "size_in_quote": true,
        //                 "total_fees": "0.0379324055666004",
        //                 "size_inclusive_of_fees": true,
        //                 "total_value_after_fees": "6.36",
        //                 "trigger_status": "INVALID_ORDER_TYPE",
        //                 "order_type": "MARKET",
        //                 "reject_reason": "REJECT_REASON_UNSPECIFIED",
        //                 "settled": true,
        //                 "product_type": "SPOT",
        //                 "reject_message": "",
        //                 "cancel_message": "Internal error"
        //             },
        //         ],
        //         "sequence": "0",
        //         "has_next": false,
        //         "cursor": ""
        //     }
        //
        object orders = this.safeList(response, "orders", new List<object>() {});
        object first = this.safeDict(orders, 0);
        object cursor = this.safeString(response, "cursor");
        if (isTrue(isTrue((!isEqual(cursor, null))) && isTrue((!isEqual(cursor, "")))))
        {
            ((IDictionary<string,object>)first)["cursor"] = cursor;
            ((List<object>)orders)[Convert.ToInt32(0)] = first;
        }
        return this.parseOrders(orders, market, since, limit);
    }

    public async override Task<object> fetchOpenOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name coinbase#fetchOpenOrders
        * @description fetches information on all currently open orders
        * @see https://docs.cloud.coinbase.com/advanced-trade-api/reference/retailbrokerageapi_gethistoricalorders
        * @param {string} symbol unified market symbol of the orders
        * @param {int} [since] timestamp in ms of the earliest order, default is undefined
        * @param {int} [limit] the maximum number of open order structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [availble parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
        * @param {int} [params.until] the latest time in ms to fetch trades for
        * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object paginate = false;
        var paginateparametersVariable = this.handleOptionAndParams(parameters, "fetchOpenOrders", "paginate");
        paginate = ((IList<object>)paginateparametersVariable)[0];
        parameters = ((IList<object>)paginateparametersVariable)[1];
        if (isTrue(paginate))
        {
            return await this.fetchPaginatedCallCursor("fetchOpenOrders", symbol, since, limit, parameters, "cursor", "cursor", null, 100);
        }
        return await this.fetchOrdersByStatus("OPEN", symbol, since, limit, parameters);
    }

    public async override Task<object> fetchClosedOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name coinbase#fetchClosedOrders
        * @description fetches information on multiple closed orders made by the user
        * @see https://docs.cloud.coinbase.com/advanced-trade-api/reference/retailbrokerageapi_gethistoricalorders
        * @param {string} symbol unified market symbol of the orders
        * @param {int} [since] timestamp in ms of the earliest order, default is undefined
        * @param {int} [limit] the maximum number of closed order structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [availble parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
        * @param {int} [params.until] the latest time in ms to fetch trades for
        * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object paginate = false;
        var paginateparametersVariable = this.handleOptionAndParams(parameters, "fetchClosedOrders", "paginate");
        paginate = ((IList<object>)paginateparametersVariable)[0];
        parameters = ((IList<object>)paginateparametersVariable)[1];
        if (isTrue(paginate))
        {
            return await this.fetchPaginatedCallCursor("fetchClosedOrders", symbol, since, limit, parameters, "cursor", "cursor", null, 100);
        }
        return await this.fetchOrdersByStatus("FILLED", symbol, since, limit, parameters);
    }

    public async virtual Task<object> fetchCanceledOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name coinbase#fetchCanceledOrders
        * @description fetches information on multiple canceled orders made by the user
        * @see https://docs.cloud.coinbase.com/advanced-trade-api/reference/retailbrokerageapi_gethistoricalorders
        * @param {string} symbol unified market symbol of the orders
        * @param {int} [since] timestamp in ms of the earliest order, default is undefined
        * @param {int} [limit] the maximum number of canceled order structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        return await this.fetchOrdersByStatus("CANCELLED", symbol, since, limit, parameters);
    }

    public async override Task<object> fetchOHLCV(object symbol, object timeframe = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name coinbase#fetchOHLCV
        * @description fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
        * @see https://docs.cloud.coinbase.com/advanced-trade-api/reference/retailbrokerageapi_getpubliccandles
        * @param {string} symbol unified symbol of the market to fetch OHLCV data for
        * @param {string} timeframe the length of time each candle represents
        * @param {int} [since] timestamp in ms of the earliest candle to fetch
        * @param {int} [limit] the maximum amount of candles to fetch, not used by coinbase
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {int} [params.until] the latest time in ms to fetch trades for
        * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [availble parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
        * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
        */
        timeframe ??= "1m";
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object maxLimit = 300;
        limit = ((bool) isTrue((isEqual(limit, null)))) ? maxLimit : mathMin(limit, maxLimit);
        object paginate = false;
        var paginateparametersVariable = this.handleOptionAndParams(parameters, "fetchOHLCV", "paginate", false);
        paginate = ((IList<object>)paginateparametersVariable)[0];
        parameters = ((IList<object>)paginateparametersVariable)[1];
        if (isTrue(paginate))
        {
            return await this.fetchPaginatedCallDeterministic("fetchOHLCV", symbol, since, limit, timeframe, parameters, subtract(maxLimit, 1));
        }
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "product_id", getValue(market, "id") },
            { "granularity", this.safeString(this.timeframes, timeframe, timeframe) },
        };
        object until = this.safeIntegerN(parameters, new List<object>() {"until", "end"});
        parameters = this.omit(parameters, new List<object>() {"until"});
        object duration = this.parseTimeframe(timeframe);
        object requestedDuration = multiply(limit, duration);
        object sinceString = null;
        if (isTrue(!isEqual(since, null)))
        {
            sinceString = this.numberToString(this.parseToInt(divide(since, 1000)));
        } else
        {
            object now = ((object)this.seconds()).ToString();
            sinceString = Precise.stringSub(now, ((object)requestedDuration).ToString());
        }
        ((IDictionary<string,object>)request)["start"] = sinceString;
        if (isTrue(!isEqual(until, null)))
        {
            ((IDictionary<string,object>)request)["end"] = this.numberToString(this.parseToInt(divide(until, 1000)));
        } else
        {
            // 300 candles max
            ((IDictionary<string,object>)request)["end"] = Precise.stringAdd(sinceString, ((object)requestedDuration).ToString());
        }
        object response = await this.v3PublicGetBrokerageMarketProductsProductIdCandles(this.extend(request, parameters));
        //
        //     {
        //         "candles": [
        //             {
        //                 "start": "1673391780",
        //                 "low": "17414.36",
        //                 "high": "17417.99",
        //                 "open": "17417.74",
        //                 "close": "17417.38",
        //                 "volume": "1.87780853"
        //             },
        //         ]
        //     }
        //
        object candles = this.safeList(response, "candles", new List<object>() {});
        return this.parseOHLCVs(candles, market, timeframe, since, limit);
    }

    public override object parseOHLCV(object ohlcv, object market = null)
    {
        //
        //     [
        //         {
        //             "start": "1673391780",
        //             "low": "17414.36",
        //             "high": "17417.99",
        //             "open": "17417.74",
        //             "close": "17417.38",
        //             "volume": "1.87780853"
        //         },
        //     ]
        //
        return new List<object> {this.safeTimestamp(ohlcv, "start"), this.safeNumber(ohlcv, "open"), this.safeNumber(ohlcv, "high"), this.safeNumber(ohlcv, "low"), this.safeNumber(ohlcv, "close"), this.safeNumber(ohlcv, "volume")};
    }

    public async override Task<object> fetchTrades(object symbol, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name coinbase#fetchTrades
        * @description get the list of most recent trades for a particular symbol
        * @see https://docs.cloud.coinbase.com/advanced-trade-api/reference/retailbrokerageapi_getpublicmarkettrades
        * @param {string} symbol unified market symbol of the trades
        * @param {int} [since] not used by coinbase fetchTrades
        * @param {int} [limit] the maximum number of trade structures to fetch
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "product_id", getValue(market, "id") },
        };
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["start"] = this.numberToString(this.parseToInt(divide(since, 1000)));
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = mathMin(limit, 1000);
        }
        object until = null;
        var untilparametersVariable = this.handleOptionAndParams(parameters, "fetchTrades", "until");
        until = ((IList<object>)untilparametersVariable)[0];
        parameters = ((IList<object>)untilparametersVariable)[1];
        if (isTrue(!isEqual(until, null)))
        {
            ((IDictionary<string,object>)request)["end"] = this.numberToString(this.parseToInt(divide(until, 1000)));
        } else if (isTrue(!isEqual(since, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchTrades() requires a `until` parameter when you use `since` argument")) ;
        }
        object response = await this.v3PublicGetBrokerageMarketProductsProductIdTicker(this.extend(request, parameters));
        //
        //     {
        //         "trades": [
        //             {
        //                 "trade_id": "10092327",
        //                 "product_id": "BTC-USDT",
        //                 "price": "17488.12",
        //                 "size": "0.0000623",
        //                 "time": "2023-01-11T00:52:37.557001Z",
        //                 "side": "BUY",
        //                 "bid": "",
        //                 "ask": ""
        //             },
        //         ]
        //     }
        //
        object trades = this.safeList(response, "trades", new List<object>() {});
        return this.parseTrades(trades, market, since, limit);
    }

    public async override Task<object> fetchMyTrades(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name coinbase#fetchMyTrades
        * @description fetch all trades made by the user
        * @see https://docs.cloud.coinbase.com/advanced-trade-api/reference/retailbrokerageapi_getfills
        * @param {string} symbol unified market symbol of the trades
        * @param {int} [since] timestamp in ms of the earliest order, default is undefined
        * @param {int} [limit] the maximum number of trade structures to fetch
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {int} [params.until] the latest time in ms to fetch trades for
        * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [availble parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
        * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object paginate = false;
        var paginateparametersVariable = this.handleOptionAndParams(parameters, "fetchMyTrades", "paginate");
        paginate = ((IList<object>)paginateparametersVariable)[0];
        parameters = ((IList<object>)paginateparametersVariable)[1];
        if (isTrue(paginate))
        {
            return await this.fetchPaginatedCallCursor("fetchMyTrades", symbol, since, limit, parameters, "cursor", "cursor", null, 100);
        }
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
        }
        object request = new Dictionary<string, object>() {};
        if (isTrue(!isEqual(market, null)))
        {
            ((IDictionary<string,object>)request)["product_id"] = getValue(market, "id");
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["start_sequence_timestamp"] = this.iso8601(since);
        }
        object until = this.safeIntegerN(parameters, new List<object>() {"until"});
        if (isTrue(!isEqual(until, null)))
        {
            parameters = this.omit(parameters, new List<object>() {"until"});
            ((IDictionary<string,object>)request)["end_sequence_timestamp"] = this.iso8601(until);
        }
        object response = await this.v3PrivateGetBrokerageOrdersHistoricalFills(this.extend(request, parameters));
        //
        //     {
        //         "fills": [
        //             {
        //                 "entry_id": "b88b82cc89e326a2778874795102cbafd08dd979a2a7a3c69603fc4c23c2e010",
        //                 "trade_id": "cdc39e45-bbd3-44ec-bf02-61742dfb16a1",
        //                 "order_id": "813a53c5-3e39-47bb-863d-2faf685d22d8",
        //                 "trade_time": "2023-01-18T01:37:38.091377090Z",
        //                 "trade_type": "FILL",
        //                 "price": "21220.64",
        //                 "size": "0.0046830664333996",
        //                 "commission": "0.0000280983986004",
        //                 "product_id": "BTC-USDT",
        //                 "sequence_timestamp": "2023-01-18T01:37:38.092520Z",
        //                 "liquidity_indicator": "UNKNOWN_LIQUIDITY_INDICATOR",
        //                 "size_in_quote": true,
        //                 "user_id": "1111111-1111-1111-1111-111111111111",
        //                 "side": "BUY"
        //             },
        //         ],
        //         "cursor": ""
        //     }
        //
        object trades = this.safeList(response, "fills", new List<object>() {});
        object first = this.safeDict(trades, 0);
        object cursor = this.safeString(response, "cursor");
        if (isTrue(isTrue((!isEqual(cursor, null))) && isTrue((!isEqual(cursor, "")))))
        {
            ((IDictionary<string,object>)first)["cursor"] = cursor;
            ((List<object>)trades)[Convert.ToInt32(0)] = first;
        }
        return this.parseTrades(trades, market, since, limit);
    }

    public async override Task<object> fetchOrderBook(object symbol, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name coinbase#fetchOrderBook
        * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
        * @see https://docs.cloud.coinbase.com/advanced-trade-api/reference/retailbrokerageapi_getpublicproductbook
        * @param {string} symbol unified symbol of the market to fetch the order book for
        * @param {int} [limit] the maximum amount of order book entries to return
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "product_id", getValue(market, "id") },
        };
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        object response = await this.v3PublicGetBrokerageMarketProductBook(this.extend(request, parameters));
        //
        //     {
        //         "pricebook": {
        //             "product_id": "BTC-USDT",
        //             "bids": [
        //                 {
        //                     "price": "30757.85",
        //                     "size": "0.115"
        //                 },
        //             ],
        //             "asks": [
        //                 {
        //                     "price": "30759.07",
        //                     "size": "0.04877659"
        //                 },
        //             ],
        //             "time": "2023-06-30T04:02:40.533606Z"
        //         }
        //     }
        //
        object data = this.safeDict(response, "pricebook", new Dictionary<string, object>() {});
        object time = this.safeString(data, "time");
        object timestamp = this.parse8601(time);
        return this.parseOrderBook(data, symbol, timestamp, "bids", "asks", "price", "size");
    }

    public async override Task<object> fetchBidsAsks(object symbols = null, object parameters = null)
    {
        /**
        * @method
        * @name coinbase#fetchBidsAsks
        * @description fetches the bid and ask price and volume for multiple markets
        * @see https://docs.cloud.coinbase.com/advanced-trade-api/reference/retailbrokerageapi_getbestbidask
        * @param {string[]} [symbols] unified symbols of the markets to fetch the bids and asks for, all markets are returned if not assigned
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/#/?id=ticker-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        symbols = this.marketSymbols(symbols);
        object request = new Dictionary<string, object>() {};
        if (isTrue(!isEqual(symbols, null)))
        {
            ((IDictionary<string,object>)request)["product_ids"] = this.marketIds(symbols);
        }
        object response = await this.v3PrivateGetBrokerageBestBidAsk(this.extend(request, parameters));
        //
        //     {
        //         "pricebooks": [
        //             {
        //                 "product_id": "TRAC-EUR",
        //                 "bids": [
        //                     {
        //                         "price": "0.2384",
        //                         "size": "386.1"
        //                     }
        //                 ],
        //                 "asks": [
        //                     {
        //                         "price": "0.2406",
        //                         "size": "672"
        //                     }
        //                 ],
        //                 "time": "2023-06-30T07:15:24.656044Z"
        //             },
        //         ]
        //     }
        //
        object tickers = this.safeList(response, "pricebooks", new List<object>() {});
        return this.parseTickers(tickers, symbols);
    }

    public async override Task<object> withdraw(object code, object amount, object address, object tag = null, object parameters = null)
    {
        /**
        * @method
        * @name coinbase#withdraw
        * @description make a withdrawal
        * @see https://docs.cloud.coinbase.com/sign-in-with-coinbase/docs/api-transactions#send-money
        * @param {string} code unified currency code
        * @param {float} amount the amount to withdraw
        * @param {string} address the address to withdraw to
        * @param {string} [tag] an optional tag for the withdrawal
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
        */
        parameters ??= new Dictionary<string, object>();
        var tagparametersVariable = this.handleWithdrawTagAndParams(tag, parameters);
        tag = ((IList<object>)tagparametersVariable)[0];
        parameters = ((IList<object>)tagparametersVariable)[1];
        this.checkAddress(address);
        await this.loadMarkets();
        object currency = this.currency(code);
        object accountId = this.safeString2(parameters, "account_id", "accountId");
        parameters = this.omit(parameters, new List<object>() {"account_id", "accountId"});
        if (isTrue(isEqual(accountId, null)))
        {
            if (isTrue(isEqual(code, null)))
            {
                throw new ArgumentsRequired ((string)add(this.id, " withdraw() requires an account_id (or accountId) parameter OR a currency code argument")) ;
            }
            accountId = await this.findAccountId(code, parameters);
            if (isTrue(isEqual(accountId, null)))
            {
                throw new ExchangeError ((string)add(add(this.id, " withdraw() could not find account id for "), code)) ;
            }
        }
        object request = new Dictionary<string, object>() {
            { "account_id", accountId },
            { "type", "send" },
            { "to", address },
            { "amount", amount },
            { "currency", getValue(currency, "id") },
        };
        if (isTrue(!isEqual(tag, null)))
        {
            ((IDictionary<string,object>)request)["destination_tag"] = tag;
        }
        object response = await this.v2PrivatePostAccountsAccountIdTransactions(this.extend(request, parameters));
        //
        //     {
        //         "data": {
        //             "id": "a1794ecf-5693-55fa-70cf-ef731748ed82",
        //             "type": "send",
        //             "status": "pending",
        //             "amount": {
        //                 "amount": "-14.008308",
        //                 "currency": "USDC"
        //             },
        //             "native_amount": {
        //                 "amount": "-18.74",
        //                 "currency": "CAD"
        //             },
        //             "description": null,
        //             "created_at": "2024-01-12T01:27:31Z",
        //             "updated_at": "2024-01-12T01:27:31Z",
        //             "resource": "transaction",
        //             "resource_path": "/v2/accounts/a34bgfad-ed67-538b-bffc-730c98c10da0/transactions/a1794ecf-5693-55fa-70cf-ef731748ed82",
        //             "instant_exchange": false,
        //             "network": {
        //                 "status": "pending",
        //                 "status_description": "Pending (est. less than 10 minutes)",
        //                 "transaction_fee": {
        //                     "amount": "4.008308",
        //                     "currency": "USDC"
        //                 },
        //                 "transaction_amount": {
        //                     "amount": "10.000000",
        //                     "currency": "USDC"
        //                 },
        //                 "confirmations": 0
        //             },
        //             "to": {
        //                 "resource": "ethereum_address",
        //                 "address": "0x9...",
        //                 "currency": "USDC",
        //                 "address_info": {
        //                     "address": "0x9..."
        //                 }
        //             },
        //             "idem": "748d8591-dg9a-7831-a45b-crd61dg78762",
        //             "details": {
        //                 "title": "Sent USDC",
        //                 "subtitle": "To USDC address on Ethereum network",
        //                 "header": "Sent 14.008308 USDC ($18.74)",
        //                 "health": "warning"
        //             },
        //             "hide_native_amount": false
        //         }
        //     }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        return this.parseTransaction(data, currency);
    }

    public async override Task<object> fetchDepositAddressesByNetwork(object code, object parameters = null)
    {
        /**
        * @method
        * @name coinbase#fetchDepositAddress
        * @description fetch the deposit address for a currency associated with this account
        * @see https://docs.cloud.coinbase.com/exchange/reference/exchangerestapi_postcoinbaseaccountaddresses
        * @param {string} code unified currency code
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} an [address structure]{@link https://docs.ccxt.com/#/?id=address-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        object request = null;
        var requestparametersVariable = await this.prepareAccountRequestWithCurrencyCode(getValue(currency, "code"));
        request = ((IList<object>)requestparametersVariable)[0];
        parameters = ((IList<object>)requestparametersVariable)[1];
        object response = await this.v2PrivateGetAccountsAccountIdAddresses(this.extend(request, parameters));
        //
        //    {
        //        pagination: {
        //            ending_before: null,
        //            starting_after: null,
        //            previous_ending_before: null,
        //            next_starting_after: null,
        //            limit: '25',
        //            order: 'desc',
        //            previous_uri: null,
        //            next_uri: null
        //        },
        //        data: [
        //            {
        //                id: '64ceb5f1-5fa2-5310-a4ff-9fd46271003d',
        //                address: '5xjPKeAXpnhA2kHyinvdVeui6RXVdEa3B2J3SCAwiKnk',
        //                address_info: { address: '5xjPKeAXpnhA2kHyinvdVeui6RXVdEa3B2J3SCAwiKnk' },
        //                name: null,
        //                created_at: '2023-05-29T21:12:12Z',
        //                updated_at: '2023-05-29T21:12:12Z',
        //                network: 'solana',
        //                uri_scheme: 'solana',
        //                resource: 'address',
        //                resource_path: '/v2/accounts/a7b3d387-bfb8-5ce7-b8da-1f507e81cf25/addresses/64ceb5f1-5fa2-5310-a4ff-9fd46271003d',
        //                warnings: [
        //                    {
        //                    type: 'correct_address_warning',
        //                    title: 'This is an ERC20 USDC address.',
        //                    details: 'Only send ERC20 USD Coin (USDC) to this address.',
        //                    image_url: 'https://www.coinbase.com/assets/addresses/global-receive-warning-a3d91807e61c717e5a38d270965003dcc025ca8a3cea40ec3d7835b7c86087fa.png',
        //                    options: [ { text: 'I understand', style: 'primary', id: 'dismiss' } ]
        //                    }
        //                ],
        //                qr_code_image_url: 'https://static-assets.coinbase.com/p2p/l2/asset_network_combinations/v5/usdc-solana.png',
        //                address_label: 'USDC address (Solana)',
        //                default_receive: true,
        //                deposit_uri: 'solana:5xjPKeAXpnhA2kHyinvdVeui6RXVdEa3B2J3SCAwiKnk?spl-token=EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v',
        //                callback_url: null,
        //                share_address_copy: {
        //                    line1: '5xjPKeAXpnhA2kHyinvdVeui6RXVdEa3B2J3SCAwiKnk',
        //                    line2: 'This address can only receive USDC-SPL from Solana network. Don’t send USDC from other networks, other SPL tokens or NFTs, or it may result in a loss of funds.'
        //                },
        //                receive_subtitle: 'ERC-20',
        //                inline_warning: {
        //                    text: 'This address can only receive USDC-SPL from Solana network. Don’t send USDC from other networks, other SPL tokens or NFTs, or it may result in a loss of funds.',
        //                    tooltip: {
        //                    title: 'USDC (Solana)',
        //                    subtitle: 'This address can only receive USDC-SPL from Solana network.'
        //                    }
        //                }
        //            },
        //            ...
        //        ]
        //    }
        //
        object data = this.safeList(response, "data", new List<object>() {});
        object addressStructures = this.parseDepositAddresses(data, null, false);
        return this.indexBy(addressStructures, "network");
    }

    public override object parseDepositAddress(object depositAddress, object currency = null)
    {
        //
        //    {
        //        id: '64ceb5f1-5fa2-5310-a4ff-9fd46271003d',
        //        address: '5xjPKeAXpnhA2kHyinvdVeui6RXVdEa3B2J3SCAwiKnk',
        //        address_info: {
        //            address: 'GCF74576I7AQ56SLMKBQAP255EGUOWCRVII3S44KEXVNJEOIFVBDMXVL',
        //            destination_tag: '3722061866'
        //        },
        //        name: null,
        //        created_at: '2023-05-29T21:12:12Z',
        //        updated_at: '2023-05-29T21:12:12Z',
        //        network: 'solana',
        //        uri_scheme: 'solana',
        //        resource: 'address',
        //        resource_path: '/v2/accounts/a7b3d387-bfb8-5ce7-b8da-1f507e81cf25/addresses/64ceb5f1-5fa2-5310-a4ff-9fd46271003d',
        //        warnings: [
        //            {
        //            type: 'correct_address_warning',
        //            title: 'This is an ERC20 USDC address.',
        //            details: 'Only send ERC20 USD Coin (USDC) to this address.',
        //            image_url: 'https://www.coinbase.com/assets/addresses/global-receive-warning-a3d91807e61c717e5a38d270965003dcc025ca8a3cea40ec3d7835b7c86087fa.png',
        //            options: [ { text: 'I understand', style: 'primary', id: 'dismiss' } ]
        //            }
        //        ],
        //        qr_code_image_url: 'https://static-assets.coinbase.com/p2p/l2/asset_network_combinations/v5/usdc-solana.png',
        //        address_label: 'USDC address (Solana)',
        //        default_receive: true,
        //        deposit_uri: 'solana:5xjPKeAXpnhA2kHyinvdVeui6RXVdEa3B2J3SCAwiKnk?spl-token=EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v',
        //        callback_url: null,
        //        share_address_copy: {
        //            line1: '5xjPKeAXpnhA2kHyinvdVeui6RXVdEa3B2J3SCAwiKnk',
        //            line2: 'This address can only receive USDC-SPL from Solana network. Don’t send USDC from other networks, other SPL tokens or NFTs, or it may result in a loss of funds.'
        //        },
        //        receive_subtitle: 'ERC-20',
        //        inline_warning: {
        //            text: 'This address can only receive USDC-SPL from Solana network. Don’t send USDC from other networks, other SPL tokens or NFTs, or it may result in a loss of funds.',
        //            tooltip: {
        //            title: 'USDC (Solana)',
        //            subtitle: 'This address can only receive USDC-SPL from Solana network.'
        //            }
        //        }
        //    }
        //
        object address = this.safeString(depositAddress, "address");
        this.checkAddress(address);
        object networkId = this.safeString(depositAddress, "network");
        object code = this.safeCurrencyCode(null, currency);
        object addressLabel = this.safeString(depositAddress, "address_label");
        object splitAddressLabel = ((string)addressLabel).Split(new [] {((string)" ")}, StringSplitOptions.None).ToList<object>();
        object marketId = this.safeString(splitAddressLabel, 0);
        object addressInfo = this.safeDict(depositAddress, "address_info");
        return new Dictionary<string, object>() {
            { "info", depositAddress },
            { "currency", this.safeCurrencyCode(marketId, currency) },
            { "address", address },
            { "tag", this.safeString(addressInfo, "destination_tag") },
            { "network", this.networkIdToCode(networkId, code) },
        };
    }

    public async virtual Task<object> deposit(object code, object amount, object id, object parameters = null)
    {
        /**
        * @method
        * @name coinbase#deposit
        * @description make a deposit
        * @see https://docs.cloud.coinbase.com/sign-in-with-coinbase/docs/api-deposits#deposit-funds
        * @param {string} code unified currency code
        * @param {float} amount the amount to deposit
        * @param {string} id the payment method id to be used for the deposit, can be retrieved from v2PrivateGetPaymentMethods
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {string} [params.accountId] the id of the account to deposit into
        * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object accountId = this.safeString2(parameters, "account_id", "accountId");
        parameters = this.omit(parameters, new List<object>() {"account_id", "accountId"});
        if (isTrue(isEqual(accountId, null)))
        {
            if (isTrue(isEqual(code, null)))
            {
                throw new ArgumentsRequired ((string)add(this.id, " deposit() requires an account_id (or accountId) parameter OR a currency code argument")) ;
            }
            accountId = await this.findAccountId(code, parameters);
            if (isTrue(isEqual(accountId, null)))
            {
                throw new ExchangeError ((string)add(add(this.id, " deposit() could not find account id for "), code)) ;
            }
        }
        object request = new Dictionary<string, object>() {
            { "account_id", accountId },
            { "amount", this.numberToString(amount) },
            { "currency", ((string)code).ToUpper() },
            { "payment_method", id },
        };
        object response = await this.v2PrivatePostAccountsAccountIdDeposits(this.extend(request, parameters));
        //
        //     {
        //         "data": {
        //             "id": "67e0eaec-07d7-54c4-a72c-2e92826897df",
        //             "status": "created",
        //             "payment_method": {
        //                 "id": "83562370-3e5c-51db-87da-752af5ab9559",
        //                 "resource": "payment_method",
        //                 "resource_path": "/v2/payment-methods/83562370-3e5c-51db-87da-752af5ab9559"
        //             },
        //             "transaction": {
        //                 "id": "441b9494-b3f0-5b98-b9b0-4d82c21c252a",
        //                 "resource": "transaction",
        //                 "resource_path": "/v2/accounts/2bbf394c-193b-5b2a-9155-3b4732659ede/transactions/441b9494-b3f0-5b98-b9b0-4d82c21c252a"
        //             },
        //             "amount": {
        //                 "amount": "10.00",
        //                 "currency": "USD"
        //             },
        //             "subtotal": {
        //                 "amount": "10.00",
        //                 "currency": "USD"
        //             },
        //             "created_at": "2015-01-31T20:49:02Z",
        //             "updated_at": "2015-02-11T16:54:02-08:00",
        //             "resource": "deposit",
        //             "resource_path": "/v2/accounts/2bbf394c-193b-5b2a-9155-3b4732659ede/deposits/67e0eaec-07d7-54c4-a72c-2e92826897df",
        //             "committed": true,
        //             "fee": {
        //                 "amount": "0.00",
        //                 "currency": "USD"
        //             },
        //             "payout_at": "2015-02-18T16:54:00-08:00"
        //         }
        //     }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        return this.parseTransaction(data);
    }

    public async virtual Task<object> fetchDeposit(object id, object code = null, object parameters = null)
    {
        /**
        * @method
        * @name coinbase#fetchDeposit
        * @description fetch information on a deposit, fiat only, for crypto transactions use fetchLedger
        * @see https://docs.cloud.coinbase.com/sign-in-with-coinbase/docs/api-deposits#show-deposit
        * @param {string} id deposit id
        * @param {string} [code] unified currency code
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {string} [params.accountId] the id of the account that the funds were deposited into
        * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object accountId = this.safeString2(parameters, "account_id", "accountId");
        parameters = this.omit(parameters, new List<object>() {"account_id", "accountId"});
        if (isTrue(isEqual(accountId, null)))
        {
            if (isTrue(isEqual(code, null)))
            {
                throw new ArgumentsRequired ((string)add(this.id, " fetchDeposit() requires an account_id (or accountId) parameter OR a currency code argument")) ;
            }
            accountId = await this.findAccountId(code, parameters);
            if (isTrue(isEqual(accountId, null)))
            {
                throw new ExchangeError ((string)add(add(this.id, " fetchDeposit() could not find account id for "), code)) ;
            }
        }
        object request = new Dictionary<string, object>() {
            { "account_id", accountId },
            { "deposit_id", id },
        };
        object response = await this.v2PrivateGetAccountsAccountIdDepositsDepositId(this.extend(request, parameters));
        //
        //     {
        //         "data": {
        //             "id": "67e0eaec-07d7-54c4-a72c-2e92826897df",
        //             "status": "completed",
        //             "payment_method": {
        //                 "id": "83562370-3e5c-51db-87da-752af5ab9559",
        //                 "resource": "payment_method",
        //                 "resource_path": "/v2/payment-methods/83562370-3e5c-51db-87da-752af5ab9559"
        //             },
        //             "transaction": {
        //                 "id": "441b9494-b3f0-5b98-b9b0-4d82c21c252a",
        //                 "resource": "transaction",
        //                 "resource_path": "/v2/accounts/2bbf394c-193b-5b2a-9155-3b4732659ede/transactions/441b9494-b3f0-5b98-b9b0-4d82c21c252a"
        //             },
        //             "amount": {
        //                 "amount": "10.00",
        //                 "currency": "USD"
        //             },
        //             "subtotal": {
        //                 "amount": "10.00",
        //                 "currency": "USD"
        //             },
        //             "created_at": "2015-01-31T20:49:02Z",
        //             "updated_at": "2015-02-11T16:54:02-08:00",
        //             "resource": "deposit",
        //             "resource_path": "/v2/accounts/2bbf394c-193b-5b2a-9155-3b4732659ede/deposits/67e0eaec-07d7-54c4-a72c-2e92826897df",
        //             "committed": true,
        //             "fee": {
        //                 "amount": "0.00",
        //                 "currency": "USD"
        //             },
        //             "payout_at": "2015-02-18T16:54:00-08:00"
        //         }
        //     }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        return this.parseTransaction(data);
    }

    public async override Task<object> fetchConvertQuote(object fromCode, object toCode, object amount = null, object parameters = null)
    {
        /**
        * @method
        * @name coinbase#fetchConvertQuote
        * @description fetch a quote for converting from one currency to another
        * @see https://docs.cloud.coinbase.com/advanced-trade-api/reference/retailbrokerageapi_createconvertquote
        * @param {string} fromCode the currency that you want to sell and convert from
        * @param {string} toCode the currency that you want to buy and convert into
        * @param {float} [amount] how much you want to trade in units of the from currency
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {object} [params.trade_incentive_metadata] an object to fill in user incentive data
        * @param {string} [params.trade_incentive_metadata.user_incentive_id] the id of the incentive
        * @param {string} [params.trade_incentive_metadata.code_val] the code value of the incentive
        * @returns {object} a [conversion structure]{@link https://docs.ccxt.com/#/?id=conversion-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {
            { "from_account", fromCode },
            { "to_account", toCode },
            { "amount", this.numberToString(amount) },
        };
        object response = await this.v3PrivatePostBrokerageConvertQuote(this.extend(request, parameters));
        object data = this.safeDict(response, "trade", new Dictionary<string, object>() {});
        return this.parseConversion(data);
    }

    public async virtual Task<object> createConvertTrade(object id, object fromCode, object toCode, object amount = null, object parameters = null)
    {
        /**
        * @method
        * @name coinbase#createConvertTrade
        * @description convert from one currency to another
        * @see https://docs.cloud.coinbase.com/advanced-trade-api/reference/retailbrokerageapi_commitconverttrade
        * @param {string} id the id of the trade that you want to make
        * @param {string} fromCode the currency that you want to sell and convert from
        * @param {string} toCode the currency that you want to buy and convert into
        * @param {float} [amount] how much you want to trade in units of the from currency
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [conversion structure]{@link https://docs.ccxt.com/#/?id=conversion-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {
            { "trade_id", id },
            { "from_account", fromCode },
            { "to_account", toCode },
        };
        object response = await this.v3PrivatePostBrokerageConvertTradeTradeId(this.extend(request, parameters));
        object data = this.safeDict(response, "trade", new Dictionary<string, object>() {});
        return this.parseConversion(data);
    }

    public async virtual Task<object> fetchConvertTrade(object id, object code = null, object parameters = null)
    {
        /**
        * @method
        * @name coinbase#fetchConvertTrade
        * @description fetch the data for a conversion trade
        * @see https://docs.cloud.coinbase.com/advanced-trade-api/reference/retailbrokerageapi_getconverttrade
        * @param {string} id the id of the trade that you want to commit
        * @param {string} code the unified currency code that was converted from
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {strng} params.toCode the unified currency code that was converted into
        * @returns {object} a [conversion structure]{@link https://docs.ccxt.com/#/?id=conversion-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        if (isTrue(isEqual(code, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchConvertTrade() requires a code argument")) ;
        }
        object toCode = this.safeString(parameters, "toCode");
        if (isTrue(isEqual(toCode, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchConvertTrade() requires a toCode parameter")) ;
        }
        parameters = this.omit(parameters, "toCode");
        object request = new Dictionary<string, object>() {
            { "trade_id", id },
            { "from_account", code },
            { "to_account", toCode },
        };
        object response = await this.v3PrivateGetBrokerageConvertTradeTradeId(this.extend(request, parameters));
        object data = this.safeDict(response, "trade", new Dictionary<string, object>() {});
        return this.parseConversion(data);
    }

    public override object parseConversion(object conversion, object fromCurrency = null, object toCurrency = null)
    {
        object fromCoin = this.safeString(conversion, "source_currency");
        object fromCode = this.safeCurrencyCode(fromCoin, fromCurrency);
        object to = this.safeString(conversion, "target_currency");
        object toCode = this.safeCurrencyCode(to, toCurrency);
        object fromAmountStructure = this.safeDict(conversion, "user_entered_amount");
        object feeStructure = this.safeDict(conversion, "total_fee");
        object feeAmountStructure = this.safeDict(feeStructure, "amount");
        return new Dictionary<string, object>() {
            { "info", conversion },
            { "timestamp", null },
            { "datetime", null },
            { "id", this.safeString(conversion, "id") },
            { "fromCurrency", fromCode },
            { "fromAmount", this.safeNumber(fromAmountStructure, "value") },
            { "toCurrency", toCode },
            { "toAmount", null },
            { "price", null },
            { "fee", this.safeNumber(feeAmountStructure, "value") },
        };
    }

    public async override Task<object> closePosition(object symbol, object side = null, object parameters = null)
    {
        /**
        * @method
        * @name coinbase#closePosition
        * @description *futures only* closes open positions for a market
        * @see https://coinbase-api.github.io/docs/#/en-us/swapV2/trade-api.html#One-Click%20Close%20All%20Positions
        * @param {string} symbol Unified CCXT market symbol
        * @param {string} [side] not used by coinbase
        * @param {object} [params] extra parameters specific to the coinbase api endpoint
        * @param {string}  params.clientOrderId *mandatory* the client order id of the position to close
        * @param {float} [params.size] the size of the position to close, optional
        * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        if (!isTrue(getValue(market, "future")))
        {
            throw new NotSupported ((string)add(this.id, " closePosition() only supported for futures markets")) ;
        }
        object clientOrderId = this.safeString2(parameters, "client_order_id", "clientOrderId");
        parameters = this.omit(parameters, "clientOrderId");
        object request = new Dictionary<string, object>() {
            { "product_id", getValue(market, "id") },
        };
        if (isTrue(isEqual(clientOrderId, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " closePosition() requires a clientOrderId parameter")) ;
        }
        ((IDictionary<string,object>)request)["client_order_id"] = clientOrderId;
        object response = await this.v3PrivatePostBrokerageOrdersClosePosition(this.extend(request, parameters));
        object order = this.safeDict(response, "success_response", new Dictionary<string, object>() {});
        return this.parseOrder(order);
    }

    public async override Task<object> fetchPositions(object symbols = null, object parameters = null)
    {
        /**
        * @method
        * @name coinbase#fetchPositions
        * @description fetch all open positions
        * @see https://docs.cloud.coinbase.com/advanced-trade-api/reference/retailbrokerageapi_getfcmpositions
        * @see https://docs.cloud.coinbase.com/advanced-trade-api/reference/retailbrokerageapi_getintxpositions
        * @param {string[]} [symbols] list of unified market symbols
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {string} [params.portfolio] the portfolio UUID to fetch positions for
        * @returns {object[]} a list of [position structure]{@link https://docs.ccxt.com/#/?id=position-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        symbols = this.marketSymbols(symbols);
        object market = null;
        if (isTrue(!isEqual(symbols, null)))
        {
            market = this.market(getValue(symbols, 0));
        }
        object type = null;
        var typeparametersVariable = this.handleMarketTypeAndParams("fetchPositions", market, parameters);
        type = ((IList<object>)typeparametersVariable)[0];
        parameters = ((IList<object>)typeparametersVariable)[1];
        object response = null;
        if (isTrue(isEqual(type, "future")))
        {
            response = await this.v3PrivateGetBrokerageCfmPositions(parameters);
        } else
        {
            object portfolio = null;
            var portfolioparametersVariable = this.handleOptionAndParams(parameters, "fetchPositions", "portfolio");
            portfolio = ((IList<object>)portfolioparametersVariable)[0];
            parameters = ((IList<object>)portfolioparametersVariable)[1];
            if (isTrue(isEqual(portfolio, null)))
            {
                throw new ArgumentsRequired ((string)add(this.id, " fetchPositions() requires a \"portfolio\" value in params (eg: dbcb91e7-2bc9-515), or set as exchange.options[\"portfolio\"]. You can get a list of portfolios with fetchPortfolios()")) ;
            }
            object request = new Dictionary<string, object>() {
                { "portfolio_uuid", portfolio },
            };
            response = await this.v3PrivateGetBrokerageIntxPositionsPortfolioUuid(this.extend(request, parameters));
        }
        object positions = this.safeList(response, "positions", new List<object>() {});
        return this.parsePositions(positions, symbols);
    }

    public async override Task<object> fetchPosition(object symbol, object parameters = null)
    {
        /**
        * @method
        * @name coinbase#fetchPosition
        * @description fetch data on a single open contract trade position
        * @see https://docs.cloud.coinbase.com/advanced-trade-api/reference/retailbrokerageapi_getintxposition
        * @see https://docs.cloud.coinbase.com/advanced-trade-api/reference/retailbrokerageapi_getfcmposition
        * @param {string} symbol unified market symbol of the market the position is held in, default is undefined
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {string} [params.product_id] *futures only* the product id of the position to fetch, required for futures markets only
        * @param {string} [params.portfolio] *perpetual/swaps only* the portfolio UUID to fetch the position for, required for perpetual/swaps markets only
        * @returns {object} a [position structure]{@link https://docs.ccxt.com/#/?id=position-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object response = null;
        if (isTrue(getValue(market, "future")))
        {
            object productId = this.safeString(market, "product_id");
            if (isTrue(isEqual(productId, null)))
            {
                throw new ArgumentsRequired ((string)add(this.id, " fetchPosition() requires a \"product_id\" in params")) ;
            }
            object futureRequest = new Dictionary<string, object>() {
                { "product_id", productId },
            };
            response = await this.v3PrivateGetBrokerageCfmPositionsProductId(this.extend(futureRequest, parameters));
        } else
        {
            object portfolio = null;
            var portfolioparametersVariable = this.handleOptionAndParams(parameters, "fetchPositions", "portfolio");
            portfolio = ((IList<object>)portfolioparametersVariable)[0];
            parameters = ((IList<object>)portfolioparametersVariable)[1];
            if (isTrue(isEqual(portfolio, null)))
            {
                throw new ArgumentsRequired ((string)add(this.id, " fetchPosition() requires a \"portfolio\" value in params (eg: dbcb91e7-2bc9-515), or set as exchange.options[\"portfolio\"]. You can get a list of portfolios with fetchPortfolios()")) ;
            }
            object request = new Dictionary<string, object>() {
                { "symbol", getValue(market, "id") },
                { "portfolio_uuid", portfolio },
            };
            response = await this.v3PrivateGetBrokerageIntxPositionsPortfolioUuidSymbol(this.extend(request, parameters));
        }
        object position = this.safeDict(response, "position", new Dictionary<string, object>() {});
        return this.parsePosition(position, market);
    }

    public override object parsePosition(object position, object market = null)
    {
        //
        // {
        //     "product_id": "1r4njf84-0-0",
        //     "product_uuid": "cd34c18b-3665-4ed8-9305-3db277c49fc5",
        //     "symbol": "ADA-PERP-INTX",
        //     "vwap": {
        //        "value": "0.6171",
        //        "currency": "USDC"
        //     },
        //     "position_side": "POSITION_SIDE_LONG",
        //     "net_size": "20",
        //     "buy_order_size": "0",
        //     "sell_order_size": "0",
        //     "im_contribution": "0.1",
        //     "unrealized_pnl": {
        //        "value": "0.074",
        //        "currency": "USDC"
        //     },
        //     "mark_price": {
        //        "value": "0.6208",
        //        "currency": "USDC"
        //     },
        //     "liquidation_price": {
        //        "value": "0",
        //        "currency": "USDC"
        //     },
        //     "leverage": "1",
        //     "im_notional": {
        //        "value": "12.342",
        //        "currency": "USDC"
        //     },
        //     "mm_notional": {
        //        "value": "0.814572",
        //        "currency": "USDC"
        //     },
        //     "position_notional": {
        //        "value": "12.342",
        //        "currency": "USDC"
        //     },
        //     "margin_type": "MARGIN_TYPE_CROSS",
        //     "liquidation_buffer": "19.677828",
        //     "liquidation_percentage": "4689.3506",
        //     "portfolio_summary": {
        //        "portfolio_uuid": "018ebd63-1f6d-7c8e-ada9-0761c5a2235f",
        //        "collateral": "20.4184",
        //        "position_notional": "12.342",
        //        "open_position_notional": "12.342",
        //        "pending_fees": "0",
        //        "borrow": "0",
        //        "accrued_interest": "0",
        //        "rolling_debt": "0",
        //        "portfolio_initial_margin": "0.1",
        //        "portfolio_im_notional": {
        //           "value": "12.342",
        //           "currency": "USDC"
        //        },
        //        "portfolio_maintenance_margin": "0.066",
        //        "portfolio_mm_notional": {
        //           "value": "0.814572",
        //           "currency": "USDC"
        //        },
        //        "liquidation_percentage": "4689.3506",
        //        "liquidation_buffer": "19.677828",
        //        "margin_type": "MARGIN_TYPE_CROSS",
        //        "margin_flags": "PORTFOLIO_MARGIN_FLAGS_UNSPECIFIED",
        //        "liquidation_status": "PORTFOLIO_LIQUIDATION_STATUS_NOT_LIQUIDATING",
        //        "unrealized_pnl": {
        //           "value": "0.074",
        //           "currency": "USDC"
        //        },
        //        "buying_power": {
        //           "value": "8.1504",
        //           "currency": "USDC"
        //        },
        //        "total_balance": {
        //           "value": "20.4924",
        //           "currency": "USDC"
        //        },
        //        "max_withdrawal": {
        //           "value": "8.0764",
        //           "currency": "USDC"
        //        }
        //     },
        //     "entry_vwap": {
        //        "value": "0.6091",
        //        "currency": "USDC"
        //     }
        // }
        //
        object marketId = this.safeString(position, "symbol", "");
        market = this.safeMarket(marketId, market);
        object rawMargin = this.safeString(position, "margin_type");
        object marginMode = null;
        if (isTrue(!isEqual(rawMargin, null)))
        {
            marginMode = ((bool) isTrue((isEqual(rawMargin, "MARGIN_TYPE_CROSS")))) ? "cross" : "isolated";
        }
        object notionalObject = this.safeDict(position, "position_notional", new Dictionary<string, object>() {});
        object positionSide = this.safeString(position, "position_side");
        object side = ((bool) isTrue((isEqual(positionSide, "POSITION_SIDE_LONG")))) ? "long" : "short";
        object unrealizedPNLObject = this.safeDict(position, "unrealized_pnl", new Dictionary<string, object>() {});
        object liquidationPriceObject = this.safeDict(position, "liquidation_price", new Dictionary<string, object>() {});
        object liquidationPrice = this.safeNumber(liquidationPriceObject, "value");
        object vwapObject = this.safeDict(position, "vwap", new Dictionary<string, object>() {});
        object summaryObject = this.safeDict(position, "portfolio_summary", new Dictionary<string, object>() {});
        return this.safePosition(new Dictionary<string, object>() {
            { "info", position },
            { "id", this.safeString(position, "product_id") },
            { "symbol", this.safeSymbol(marketId, market) },
            { "notional", this.safeNumber(notionalObject, "value") },
            { "marginMode", marginMode },
            { "liquidationPrice", liquidationPrice },
            { "entryPrice", this.safeNumber(vwapObject, "value") },
            { "unrealizedPnl", this.safeNumber(unrealizedPNLObject, "value") },
            { "realizedPnl", null },
            { "percentage", null },
            { "contracts", this.safeNumber(position, "net_size") },
            { "contractSize", getValue(market, "contractSize") },
            { "markPrice", null },
            { "lastPrice", null },
            { "side", side },
            { "hedged", null },
            { "timestamp", null },
            { "datetime", null },
            { "lastUpdateTimestamp", null },
            { "maintenanceMargin", null },
            { "maintenanceMarginPercentage", null },
            { "collateral", this.safeNumber(summaryObject, "collateral") },
            { "initialMargin", null },
            { "initialMarginPercentage", null },
            { "leverage", this.safeNumber(position, "leverage") },
            { "marginRatio", null },
            { "stopLossPrice", null },
            { "takeProfitPrice", null },
        });
    }

    public virtual object createAuthToken(object seconds, object method = null, object url = null)
    {
        // it may not work for v2
        object uri = null;
        if (isTrue(!isEqual(url, null)))
        {
            uri = add(add(method, " "), ((string)url).Replace((string)"https://", (string)""));
            object quesPos = getIndexOf(uri, "?");
            // Due to we use mb_strpos, quesPos could be false in php. In that case, the quesPos >= 0 is true
            // Also it's not possible that the question mark is first character, only check > 0 here.
            if (isTrue(isGreaterThan(quesPos, 0)))
            {
                uri = slice(uri, 0, quesPos);
            }
        }
        object nonce = this.randomBytes(16);
        object request = new Dictionary<string, object>() {
            { "aud", new List<object>() {"retail_rest_api_proxy"} },
            { "iss", "coinbase-cloud" },
            { "nbf", seconds },
            { "exp", add(seconds, 120) },
            { "sub", this.apiKey },
            { "iat", seconds },
        };
        if (isTrue(!isEqual(uri, null)))
        {
            ((IDictionary<string,object>)request)["uri"] = uri;
        }
        object token = jwt(request, this.encode(this.secret), sha256, false, new Dictionary<string, object>() {
            { "kid", this.apiKey },
            { "nonce", nonce },
            { "alg", "ES256" },
        });
        return token;
    }

    public override object sign(object path, object api = null, object method = null, object parameters = null, object headers = null, object body = null)
    {
        api ??= new List<object>();
        method ??= "GET";
        parameters ??= new Dictionary<string, object>();
        object version = getValue(api, 0);
        object signed = isEqual(getValue(api, 1), "private");
        object isV3 = isEqual(version, "v3");
        object pathPart = ((bool) isTrue((isV3))) ? "api/v3" : "v2";
        object fullPath = add(add(add("/", pathPart), "/"), this.implodeParams(path, parameters));
        object query = this.omit(parameters, this.extractParams(path));
        object savedPath = fullPath;
        if (isTrue(isEqual(method, "GET")))
        {
            if (isTrue(getArrayLength(new List<object>(((IDictionary<string,object>)query).Keys))))
            {
                fullPath = add(fullPath, add("?", this.urlencodeWithArrayRepeat(query)));
            }
        }
        object url = add(getValue(getValue(this.urls, "api"), "rest"), fullPath);
        if (isTrue(signed))
        {
            object authorization = this.safeString(this.headers, "Authorization");
            object authorizationString = null;
            if (isTrue(!isEqual(authorization, null)))
            {
                authorizationString = authorization;
            } else if (isTrue(isTrue(this.token) && !isTrue(this.checkRequiredCredentials(false))))
            {
                authorizationString = add("Bearer ", this.token);
            } else
            {
                this.checkRequiredCredentials();
                object seconds = this.seconds();
                object payload = "";
                if (isTrue(!isEqual(method, "GET")))
                {
                    if (isTrue(getArrayLength(new List<object>(((IDictionary<string,object>)query).Keys))))
                    {
                        body = this.json(query);
                        payload = body;
                    }
                } else
                {
                    if (!isTrue(isV3))
                    {
                        if (isTrue(getArrayLength(new List<object>(((IDictionary<string,object>)query).Keys))))
                        {
                            payload = add(payload, add("?", this.urlencode(query)));
                        }
                    }
                }
                // v3: 'GET' doesn't need payload in the signature. inside url is enough
                // https://docs.cloud.coinbase.com/advanced-trade-api/docs/auth#example-request
                // v2: 'GET' require payload in the signature
                // https://docs.cloud.coinbase.com/sign-in-with-coinbase/docs/api-key-authentication
                object isCloudAPiKey = isTrue((isGreaterThanOrEqual(getIndexOf(this.apiKey, "organizations/"), 0))) || isTrue((((string)this.secret).StartsWith(((string)"-----BEGIN"))));
                if (isTrue(isCloudAPiKey))
                {
                    if (isTrue(((string)this.apiKey).StartsWith(((string)"-----BEGIN"))))
                    {
                        throw new ArgumentsRequired ((string)add(this.id, " apiKey should contain the name (eg: organizations/3b910e93....) and not the public key")) ;
                    }
                    // // it may not work for v2
                    // let uri = method + ' ' + url.replace ('https://', '');
                    // const quesPos = uri.indexOf ('?');
                    // // Due to we use mb_strpos, quesPos could be false in php. In that case, the quesPos >= 0 is true
                    // // Also it's not possible that the question mark is first character, only check > 0 here.
                    // if (quesPos > 0) {
                    //     uri = uri.slice (0, quesPos);
                    // }
                    // const nonce = this.randomBytes (16);
                    // const request = {
                    //     'aud': [ 'retail_rest_api_proxy' ],
                    //     'iss': 'coinbase-cloud',
                    //     'nbf': seconds,
                    //     'exp': seconds + 120,
                    //     'sub': this.apiKey,
                    //     'uri': uri,
                    //     'iat': seconds,
                    // };
                    object token = this.createAuthToken(seconds, method, url);
                    // const token = jwt (request, this.encode (this.secret), sha256, false, { 'kid': this.apiKey, 'nonce': nonce, 'alg': 'ES256' });
                    authorizationString = add("Bearer ", token);
                } else
                {
                    object timestampString = ((object)this.seconds()).ToString();
                    object auth = add(add(add(timestampString, method), savedPath), payload);
                    object signature = this.hmac(this.encode(auth), this.encode(this.secret), sha256);
                    headers = new Dictionary<string, object>() {
                        { "CB-ACCESS-KEY", this.apiKey },
                        { "CB-ACCESS-SIGN", signature },
                        { "CB-ACCESS-TIMESTAMP", timestampString },
                        { "Content-Type", "application/json" },
                    };
                }
            }
            if (isTrue(!isEqual(authorizationString, null)))
            {
                headers = new Dictionary<string, object>() {
                    { "Authorization", authorizationString },
                    { "Content-Type", "application/json" },
                };
                if (isTrue(!isEqual(method, "GET")))
                {
                    if (isTrue(getArrayLength(new List<object>(((IDictionary<string,object>)query).Keys))))
                    {
                        body = this.json(query);
                    }
                }
            }
        }
        return new Dictionary<string, object>() {
            { "url", url },
            { "method", method },
            { "body", body },
            { "headers", headers },
        };
    }

    public override object handleErrors(object code, object reason, object url, object method, object headers, object body, object response, object requestHeaders, object requestBody)
    {
        if (isTrue(isEqual(response, null)))
        {
            return null;  // fallback to default error handler
        }
        object feedback = add(add(this.id, " "), body);
        //
        //    {"error": "invalid_request", "error_description": "The request is missing a required parameter, includes an unsupported parameter value, or is otherwise malformed."}
        //
        // or
        //
        //    {
        //      "errors": [
        //        {
        //          "id": "not_found",
        //          "message": "Not found"
        //        }
        //      ]
        //    }
        //
        object errorCode = this.safeString(response, "error");
        if (isTrue(!isEqual(errorCode, null)))
        {
            object errorMessage = this.safeString(response, "error_description");
            this.throwExactlyMatchedException(getValue(this.exceptions, "exact"), errorCode, feedback);
            this.throwBroadlyMatchedException(getValue(this.exceptions, "broad"), errorMessage, feedback);
            throw new ExchangeError ((string)feedback) ;
        }
        object errors = this.safeList(response, "errors");
        if (isTrue(!isEqual(errors, null)))
        {
            if (isTrue(((errors is IList<object>) || (errors.GetType().IsGenericType && errors.GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>))))))
            {
                object numErrors = getArrayLength(errors);
                if (isTrue(isGreaterThan(numErrors, 0)))
                {
                    errorCode = this.safeString(getValue(errors, 0), "id");
                    object errorMessage = this.safeString(getValue(errors, 0), "message");
                    if (isTrue(!isEqual(errorCode, null)))
                    {
                        this.throwExactlyMatchedException(getValue(this.exceptions, "exact"), errorCode, feedback);
                        this.throwBroadlyMatchedException(getValue(this.exceptions, "broad"), errorMessage, feedback);
                        throw new ExchangeError ((string)feedback) ;
                    }
                }
            }
        }
        object advancedTrade = getValue(this.options, "advanced");
        if (isTrue(!isTrue((inOp(response, "data"))) && isTrue((!isTrue(advancedTrade)))))
        {
            throw new ExchangeError ((string)add(add(this.id, " failed due to a malformed response "), this.json(response))) ;
        }
        return null;
    }
}
