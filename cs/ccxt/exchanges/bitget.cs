namespace ccxt;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

public partial class bitget : Exchange
{
    public override object describe()
    {
        return this.deepExtend(base.describe(), new Dictionary<string, object>() {
            { "id", "bitget" },
            { "name", "Bitget" },
            { "countries", new List<object>() {"SG"} },
            { "version", "v2" },
            { "rateLimit", 50 },
            { "certified", true },
            { "pro", true },
            { "has", new Dictionary<string, object>() {
                { "CORS", null },
                { "spot", true },
                { "margin", true },
                { "swap", true },
                { "future", true },
                { "option", false },
                { "addMargin", true },
                { "borrowCrossMargin", true },
                { "borrowIsolatedMargin", true },
                { "cancelAllOrders", true },
                { "cancelOrder", true },
                { "cancelOrders", true },
                { "closeAllPositions", true },
                { "closePosition", true },
                { "createConvertTrade", true },
                { "createDepositAddress", false },
                { "createMarketBuyOrderWithCost", true },
                { "createMarketOrderWithCost", false },
                { "createMarketSellOrderWithCost", false },
                { "createOrder", true },
                { "createOrders", true },
                { "createOrderWithTakeProfitAndStopLoss", true },
                { "createPostOnlyOrder", true },
                { "createReduceOnlyOrder", false },
                { "createStopLimitOrder", true },
                { "createStopLossOrder", true },
                { "createStopMarketOrder", true },
                { "createStopOrder", true },
                { "createTakeProfitOrder", true },
                { "createTrailingAmountOrder", false },
                { "createTrailingPercentOrder", true },
                { "createTriggerOrder", true },
                { "editOrder", true },
                { "fetchAccounts", false },
                { "fetchBalance", true },
                { "fetchBorrowInterest", true },
                { "fetchBorrowRateHistories", false },
                { "fetchBorrowRateHistory", false },
                { "fetchCanceledAndClosedOrders", true },
                { "fetchCanceledOrders", true },
                { "fetchClosedOrders", true },
                { "fetchConvertCurrencies", true },
                { "fetchConvertQuote", true },
                { "fetchConvertTrade", false },
                { "fetchConvertTradeHistory", true },
                { "fetchCrossBorrowRate", true },
                { "fetchCrossBorrowRates", false },
                { "fetchCurrencies", true },
                { "fetchDeposit", false },
                { "fetchDepositAddress", true },
                { "fetchDepositAddresses", false },
                { "fetchDeposits", true },
                { "fetchDepositsWithdrawals", false },
                { "fetchDepositWithdrawFee", "emulated" },
                { "fetchDepositWithdrawFees", true },
                { "fetchFundingHistory", true },
                { "fetchFundingRate", true },
                { "fetchFundingRateHistory", true },
                { "fetchFundingRates", false },
                { "fetchIndexOHLCV", true },
                { "fetchIsolatedBorrowRate", true },
                { "fetchIsolatedBorrowRates", false },
                { "fetchLedger", true },
                { "fetchLeverage", true },
                { "fetchLeverageTiers", false },
                { "fetchLiquidations", false },
                { "fetchMarginAdjustmentHistory", false },
                { "fetchMarginMode", true },
                { "fetchMarketLeverageTiers", true },
                { "fetchMarkets", true },
                { "fetchMarkOHLCV", true },
                { "fetchMyLiquidations", true },
                { "fetchMyTrades", true },
                { "fetchOHLCV", true },
                { "fetchOpenInterest", true },
                { "fetchOpenInterestHistory", false },
                { "fetchOpenOrders", true },
                { "fetchOrder", true },
                { "fetchOrderBook", true },
                { "fetchOrderBooks", false },
                { "fetchOrders", false },
                { "fetchOrderTrades", false },
                { "fetchPosition", true },
                { "fetchPositionHistory", "emulated" },
                { "fetchPositionMode", false },
                { "fetchPositions", true },
                { "fetchPositionsHistory", true },
                { "fetchPositionsRisk", false },
                { "fetchPremiumIndexOHLCV", false },
                { "fetchStatus", false },
                { "fetchTicker", true },
                { "fetchTickers", true },
                { "fetchTime", true },
                { "fetchTrades", true },
                { "fetchTradingFee", true },
                { "fetchTradingFees", true },
                { "fetchTransactions", false },
                { "fetchTransfer", false },
                { "fetchTransfers", true },
                { "fetchWithdrawAddresses", false },
                { "fetchWithdrawal", false },
                { "fetchWithdrawals", true },
                { "reduceMargin", true },
                { "repayCrossMargin", true },
                { "repayIsolatedMargin", true },
                { "setLeverage", true },
                { "setMargin", false },
                { "setMarginMode", true },
                { "setPositionMode", true },
                { "signIn", false },
                { "transfer", true },
                { "withdraw", true },
            } },
            { "timeframes", new Dictionary<string, object>() {
                { "1m", "1m" },
                { "3m", "3m" },
                { "5m", "5m" },
                { "15m", "15m" },
                { "30m", "30m" },
                { "1h", "1h" },
                { "2h", "2h" },
                { "4h", "4h" },
                { "6h", "6h" },
                { "12h", "12h" },
                { "1d", "1d" },
                { "3d", "3d" },
                { "1w", "1w" },
                { "1M", "1m" },
            } },
            { "hostname", "bitget.com" },
            { "urls", new Dictionary<string, object>() {
                { "logo", "https://user-images.githubusercontent.com/1294454/195989417-4253ddb0-afbe-4a1c-9dea-9dbcd121fa5d.jpg" },
                { "api", new Dictionary<string, object>() {
                    { "spot", "https://api.{hostname}" },
                    { "mix", "https://api.{hostname}" },
                    { "user", "https://api.{hostname}" },
                    { "p2p", "https://api.{hostname}" },
                    { "broker", "https://api.{hostname}" },
                    { "margin", "https://api.{hostname}" },
                    { "common", "https://api.{hostname}" },
                    { "tax", "https://api.{hostname}" },
                    { "convert", "https://api.{hostname}" },
                    { "copy", "https://api.{hostname}" },
                    { "earn", "https://api.{hostname}" },
                } },
                { "www", "https://www.bitget.com" },
                { "doc", new List<object>() {"https://www.bitget.com/api-doc/common/intro", "https://www.bitget.com/api-doc/spot/intro", "https://www.bitget.com/api-doc/contract/intro", "https://www.bitget.com/api-doc/broker/intro", "https://www.bitget.com/api-doc/margin/intro", "https://www.bitget.com/api-doc/copytrading/intro", "https://www.bitget.com/api-doc/earn/intro", "https://bitgetlimited.github.io/apidoc/en/mix", "https://bitgetlimited.github.io/apidoc/en/spot", "https://bitgetlimited.github.io/apidoc/en/broker", "https://bitgetlimited.github.io/apidoc/en/margin"} },
                { "fees", "https://www.bitget.cc/zh-CN/rate?tab=1" },
                { "referral", "https://www.bitget.com/expressly?languageType=0&channelCode=ccxt&vipCode=tg9j" },
            } },
            { "api", new Dictionary<string, object>() {
                { "public", new Dictionary<string, object>() {
                    { "common", new Dictionary<string, object>() {
                        { "get", new Dictionary<string, object>() {
                            { "v2/public/annoucements", 1 },
                            { "v2/public/time", 1 },
                        } },
                    } },
                    { "spot", new Dictionary<string, object>() {
                        { "get", new Dictionary<string, object>() {
                            { "spot/v1/notice/queryAllNotices", 1 },
                            { "spot/v1/public/time", 1 },
                            { "spot/v1/public/currencies", 6.6667 },
                            { "spot/v1/public/products", 1 },
                            { "spot/v1/public/product", 1 },
                            { "spot/v1/market/ticker", 1 },
                            { "spot/v1/market/tickers", 1 },
                            { "spot/v1/market/fills", 2 },
                            { "spot/v1/market/fills-history", 2 },
                            { "spot/v1/market/candles", 1 },
                            { "spot/v1/market/depth", 1 },
                            { "spot/v1/market/spot-vip-level", 2 },
                            { "spot/v1/market/merge-depth", 1 },
                            { "spot/v1/market/history-candles", 1 },
                            { "spot/v1/public/loan/coinInfos", 2 },
                            { "spot/v1/public/loan/hour-interest", 2 },
                            { "v2/spot/public/coins", 6.6667 },
                            { "v2/spot/public/symbols", 1 },
                            { "v2/spot/market/vip-fee-rate", 2 },
                            { "v2/spot/market/tickers", 1 },
                            { "v2/spot/market/merge-depth", 1 },
                            { "v2/spot/market/orderbook", 1 },
                            { "v2/spot/market/candles", 1 },
                            { "v2/spot/market/history-candles", 1 },
                            { "v2/spot/market/fills", 2 },
                            { "v2/spot/market/fills-history", 2 },
                        } },
                    } },
                    { "mix", new Dictionary<string, object>() {
                        { "get", new Dictionary<string, object>() {
                            { "mix/v1/market/contracts", 1 },
                            { "mix/v1/market/depth", 1 },
                            { "mix/v1/market/ticker", 1 },
                            { "mix/v1/market/tickers", 1 },
                            { "mix/v1/market/contract-vip-level", 2 },
                            { "mix/v1/market/fills", 1 },
                            { "mix/v1/market/fills-history", 2 },
                            { "mix/v1/market/candles", 1 },
                            { "mix/v1/market/index", 1 },
                            { "mix/v1/market/funding-time", 1 },
                            { "mix/v1/market/history-fundRate", 1 },
                            { "mix/v1/market/current-fundRate", 1 },
                            { "mix/v1/market/open-interest", 1 },
                            { "mix/v1/market/mark-price", 1 },
                            { "mix/v1/market/symbol-leverage", 1 },
                            { "mix/v1/market/queryPositionLever", 1 },
                            { "mix/v1/market/open-limit", 1 },
                            { "mix/v1/market/history-candles", 1 },
                            { "mix/v1/market/history-index-candles", 1 },
                            { "mix/v1/market/history-mark-candles", 1 },
                            { "mix/v1/market/merge-depth", 1 },
                            { "v2/mix/market/vip-fee-rate", 2 },
                            { "v2/mix/market/merge-depth", 1 },
                            { "v2/mix/market/ticker", 1 },
                            { "v2/mix/market/tickers", 1 },
                            { "v2/mix/market/fills", 1 },
                            { "v2/mix/market/fills-history", 2 },
                            { "v2/mix/market/candles", 1 },
                            { "v2/mix/market/history-candles", 1 },
                            { "v2/mix/market/history-index-candles", 1 },
                            { "v2/mix/market/history-mark-candles", 1 },
                            { "v2/mix/market/open-interest", 1 },
                            { "v2/mix/market/funding-time", 1 },
                            { "v2/mix/market/symbol-price", 1 },
                            { "v2/mix/market/history-fund-rate", 1 },
                            { "v2/mix/market/current-fund-rate", 1 },
                            { "v2/mix/market/contracts", 1 },
                            { "v2/mix/market/query-position-lever", 2 },
                        } },
                    } },
                    { "margin", new Dictionary<string, object>() {
                        { "get", new Dictionary<string, object>() {
                            { "margin/v1/cross/public/interestRateAndLimit", 2 },
                            { "margin/v1/isolated/public/interestRateAndLimit", 2 },
                            { "margin/v1/cross/public/tierData", 2 },
                            { "margin/v1/isolated/public/tierData", 2 },
                            { "margin/v1/public/currencies", 1 },
                            { "v2/margin/currencies", 2 },
                        } },
                    } },
                    { "earn", new Dictionary<string, object>() {
                        { "get", new Dictionary<string, object>() {
                            { "v2/earn/loan/public/coinInfos", 2 },
                            { "v2/earn/loan/public/hour-interest", 2 },
                        } },
                    } },
                } },
                { "private", new Dictionary<string, object>() {
                    { "spot", new Dictionary<string, object>() {
                        { "get", new Dictionary<string, object>() {
                            { "spot/v1/wallet/deposit-address", 4 },
                            { "spot/v1/wallet/withdrawal-list", 1 },
                            { "spot/v1/wallet/deposit-list", 1 },
                            { "spot/v1/account/getInfo", 20 },
                            { "spot/v1/account/assets", 2 },
                            { "spot/v1/account/assets-lite", 2 },
                            { "spot/v1/account/transferRecords", 1 },
                            { "spot/v1/convert/currencies", 2 },
                            { "spot/v1/convert/convert-record", 2 },
                            { "spot/v1/loan/ongoing-orders", 2 },
                            { "spot/v1/loan/repay-history", 2 },
                            { "spot/v1/loan/revise-history", 2 },
                            { "spot/v1/loan/borrow-history", 2 },
                            { "spot/v1/loan/debts", 2 },
                            { "v2/spot/trade/orderInfo", 1 },
                            { "v2/spot/trade/unfilled-orders", 1 },
                            { "v2/spot/trade/history-orders", 1 },
                            { "v2/spot/trade/fills", 2 },
                            { "v2/spot/trade/current-plan-order", 1 },
                            { "v2/spot/trade/history-plan-order", 1 },
                            { "v2/spot/account/info", 20 },
                            { "v2/spot/account/assets", 2 },
                            { "v2/spot/account/subaccount-assets", 2 },
                            { "v2/spot/account/bills", 2 },
                            { "v2/spot/account/transferRecords", 1 },
                            { "v2/spot/wallet/deposit-address", 2 },
                            { "v2/spot/wallet/deposit-records", 2 },
                            { "v2/spot/wallet/withdrawal-records", 2 },
                        } },
                        { "post", new Dictionary<string, object>() {
                            { "spot/v1/wallet/transfer", 4 },
                            { "spot/v1/wallet/transfer-v2", 4 },
                            { "spot/v1/wallet/subTransfer", 10 },
                            { "spot/v1/wallet/withdrawal", 4 },
                            { "spot/v1/wallet/withdrawal-v2", 4 },
                            { "spot/v1/wallet/withdrawal-inner", 4 },
                            { "spot/v1/wallet/withdrawal-inner-v2", 4 },
                            { "spot/v1/account/sub-account-spot-assets", 200 },
                            { "spot/v1/account/bills", 2 },
                            { "spot/v1/trade/orders", 2 },
                            { "spot/v1/trade/batch-orders", 4 },
                            { "spot/v1/trade/cancel-order", 2 },
                            { "spot/v1/trade/cancel-order-v2", 2 },
                            { "spot/v1/trade/cancel-symbol-order", 2 },
                            { "spot/v1/trade/cancel-batch-orders", 4 },
                            { "spot/v1/trade/cancel-batch-orders-v2", 4 },
                            { "spot/v1/trade/orderInfo", 1 },
                            { "spot/v1/trade/open-orders", 1 },
                            { "spot/v1/trade/history", 1 },
                            { "spot/v1/trade/fills", 1 },
                            { "spot/v1/plan/placePlan", 1 },
                            { "spot/v1/plan/modifyPlan", 1 },
                            { "spot/v1/plan/cancelPlan", 1 },
                            { "spot/v1/plan/currentPlan", 1 },
                            { "spot/v1/plan/historyPlan", 1 },
                            { "spot/v1/plan/batchCancelPlan", 2 },
                            { "spot/v1/convert/quoted-price", 4 },
                            { "spot/v1/convert/trade", 4 },
                            { "spot/v1/loan/borrow", 2 },
                            { "spot/v1/loan/repay", 2 },
                            { "spot/v1/loan/revise-pledge", 2 },
                            { "spot/v1/trace/order/orderCurrentList", 2 },
                            { "spot/v1/trace/order/orderHistoryList", 2 },
                            { "spot/v1/trace/order/closeTrackingOrder", 2 },
                            { "spot/v1/trace/order/updateTpsl", 2 },
                            { "spot/v1/trace/order/followerEndOrder", 2 },
                            { "spot/v1/trace/order/spotInfoList", 2 },
                            { "spot/v1/trace/config/getTraderSettings", 2 },
                            { "spot/v1/trace/config/getFollowerSettings", 2 },
                            { "spot/v1/trace/user/myTraders", 2 },
                            { "spot/v1/trace/config/setFollowerConfig", 2 },
                            { "spot/v1/trace/user/myFollowers", 2 },
                            { "spot/v1/trace/config/setProductCode", 2 },
                            { "spot/v1/trace/user/removeTrader", 2 },
                            { "spot/v1/trace/getRemovableFollower", 2 },
                            { "spot/v1/trace/user/removeFollower", 2 },
                            { "spot/v1/trace/profit/totalProfitInfo", 2 },
                            { "spot/v1/trace/profit/totalProfitList", 2 },
                            { "spot/v1/trace/profit/profitHisList", 2 },
                            { "spot/v1/trace/profit/profitHisDetailList", 2 },
                            { "spot/v1/trace/profit/waitProfitDetailList", 2 },
                            { "spot/v1/trace/user/getTraderInfo", 2 },
                            { "v2/spot/trade/place-order", 2 },
                            { "v2/spot/trade/cancel-order", 2 },
                            { "v2/spot/trade/batch-orders", 20 },
                            { "v2/spot/trade/batch-cancel-order", 2 },
                            { "v2/spot/trade/cancel-symbol-order", 4 },
                            { "v2/spot/trade/place-plan-order", 1 },
                            { "v2/spot/trade/modify-plan-order", 1 },
                            { "v2/spot/trade/cancel-plan-order", 1 },
                            { "v2/spot/trade/batch-cancel-plan-order", 2 },
                            { "v2/spot/wallet/transfer", 2 },
                            { "v2/spot/wallet/subaccount-transfer", 2 },
                            { "v2/spot/wallet/withdrawal", 2 },
                            { "v2/spot/wallet/cancel-withdrawal", 2 },
                            { "v2/spot/wallet/modify-deposit-account", 2 },
                        } },
                    } },
                    { "mix", new Dictionary<string, object>() {
                        { "get", new Dictionary<string, object>() {
                            { "mix/v1/account/account", 2 },
                            { "mix/v1/account/accounts", 2 },
                            { "mix/v1/position/singlePosition", 2 },
                            { "mix/v1/position/singlePosition-v2", 2 },
                            { "mix/v1/position/allPosition", 4 },
                            { "mix/v1/position/allPosition-v2", 4 },
                            { "mix/v1/position/history-position", 1 },
                            { "mix/v1/account/accountBill", 2 },
                            { "mix/v1/account/accountBusinessBill", 4 },
                            { "mix/v1/order/current", 1 },
                            { "mix/v1/order/marginCoinCurrent", 1 },
                            { "mix/v1/order/history", 2 },
                            { "mix/v1/order/historyProductType", 4 },
                            { "mix/v1/order/detail", 2 },
                            { "mix/v1/order/fills", 2 },
                            { "mix/v1/order/allFills", 2 },
                            { "mix/v1/plan/currentPlan", 1 },
                            { "mix/v1/plan/historyPlan", 2 },
                            { "mix/v1/trace/currentTrack", 2 },
                            { "mix/v1/trace/followerOrder", 2 },
                            { "mix/v1/trace/followerHistoryOrders", 2 },
                            { "mix/v1/trace/historyTrack", 2 },
                            { "mix/v1/trace/summary", 1 },
                            { "mix/v1/trace/profitSettleTokenIdGroup", 1 },
                            { "mix/v1/trace/profitDateGroupList", 1 },
                            { "mix/v1/trade/profitDateList", 2 },
                            { "mix/v1/trace/waitProfitDateList", 1 },
                            { "mix/v1/trace/traderSymbols", 1 },
                            { "mix/v1/trace/traderList", 2 },
                            { "mix/v1/trace/traderDetail", 2 },
                            { "mix/v1/trace/queryTraceConfig", 2 },
                            { "v2/mix/account/account", 2 },
                            { "v2/mix/account/accounts", 2 },
                            { "v2/mix/account/sub-account-assets", 200 },
                            { "v2/mix/account/open-count", 2 },
                            { "v2/mix/account/bill", 2 },
                            { "v2/mix/market/query-position-lever", 2 },
                            { "v2/mix/position/single-position", 2 },
                            { "v2/mix/position/all-position", 4 },
                            { "v2/mix/position/history-position", 1 },
                            { "v2/mix/order/detail", 2 },
                            { "v2/mix/order/fills", 2 },
                            { "v2/mix/order/fill-history", 2 },
                            { "v2/mix/order/orders-pending", 2 },
                            { "v2/mix/order/orders-history", 2 },
                            { "v2/mix/order/orders-plan-pending", 2 },
                            { "v2/mix/order/orders-plan-history", 2 },
                        } },
                        { "post", new Dictionary<string, object>() {
                            { "mix/v1/account/sub-account-contract-assets", 200 },
                            { "mix/v1/account/open-count", 1 },
                            { "mix/v1/account/setLeverage", 4 },
                            { "mix/v1/account/setMargin", 4 },
                            { "mix/v1/account/setMarginMode", 4 },
                            { "mix/v1/account/setPositionMode", 4 },
                            { "mix/v1/order/placeOrder", 2 },
                            { "mix/v1/order/batch-orders", 2 },
                            { "mix/v1/order/cancel-order", 2 },
                            { "mix/v1/order/cancel-batch-orders", 2 },
                            { "mix/v1/order/modifyOrder", 2 },
                            { "mix/v1/order/cancel-symbol-orders", 2 },
                            { "mix/v1/order/cancel-all-orders", 2 },
                            { "mix/v1/order/close-all-positions", 20 },
                            { "mix/v1/plan/placePlan", 2 },
                            { "mix/v1/plan/modifyPlan", 2 },
                            { "mix/v1/plan/modifyPlanPreset", 2 },
                            { "mix/v1/plan/placeTPSL", 2 },
                            { "mix/v1/plan/placeTrailStop", 2 },
                            { "mix/v1/plan/placePositionsTPSL", 2 },
                            { "mix/v1/plan/modifyTPSLPlan", 2 },
                            { "mix/v1/plan/cancelPlan", 2 },
                            { "mix/v1/plan/cancelSymbolPlan", 2 },
                            { "mix/v1/plan/cancelAllPlan", 2 },
                            { "mix/v1/trace/closeTrackOrder", 2 },
                            { "mix/v1/trace/modifyTPSL", 2 },
                            { "mix/v1/trace/closeTrackOrderBySymbol", 2 },
                            { "mix/v1/trace/setUpCopySymbols", 2 },
                            { "mix/v1/trace/followerSetBatchTraceConfig", 2 },
                            { "mix/v1/trace/followerCloseByTrackingNo", 2 },
                            { "mix/v1/trace/followerCloseByAll", 2 },
                            { "mix/v1/trace/followerSetTpsl", 2 },
                            { "mix/v1/trace/cancelCopyTrader", 4 },
                            { "mix/v1/trace/traderUpdateConfig", 2 },
                            { "mix/v1/trace/myTraderList", 2 },
                            { "mix/v1/trace/myFollowerList", 2 },
                            { "mix/v1/trace/removeFollower", 2 },
                            { "mix/v1/trace/public/getFollowerConfig", 2 },
                            { "mix/v1/trace/report/order/historyList", 2 },
                            { "mix/v1/trace/report/order/currentList", 2 },
                            { "mix/v1/trace/queryTraderTpslRatioConfig", 2 },
                            { "mix/v1/trace/traderUpdateTpslRatioConfig", 2 },
                            { "v2/mix/account/set-leverage", 4 },
                            { "v2/mix/account/set-margin", 4 },
                            { "v2/mix/account/set-margin-mode", 4 },
                            { "v2/mix/account/set-position-mode", 4 },
                            { "v2/mix/order/place-order", 20 },
                            { "v2/mix/order/click-backhand", 20 },
                            { "v2/mix/order/batch-place-order", 20 },
                            { "v2/mix/order/modify-order", 2 },
                            { "v2/mix/order/cancel-order", 2 },
                            { "v2/mix/order/batch-cancel-orders", 2 },
                            { "v2/mix/order/close-positions", 20 },
                            { "v2/mix/order/place-tpsl-order", 2 },
                            { "v2/mix/order/place-plan-order", 2 },
                            { "v2/mix/order/modify-tpsl-order", 2 },
                            { "v2/mix/order/modify-plan-order", 2 },
                            { "v2/mix/order/cancel-plan-order", 2 },
                        } },
                    } },
                    { "user", new Dictionary<string, object>() {
                        { "get", new Dictionary<string, object>() {
                            { "user/v1/fee/query", 2 },
                            { "user/v1/sub/virtual-list", 2 },
                            { "user/v1/sub/virtual-api-list", 2 },
                            { "user/v1/tax/spot-record", 1 },
                            { "user/v1/tax/future-record", 1 },
                            { "user/v1/tax/margin-record", 1 },
                            { "user/v1/tax/p2p-record", 1 },
                            { "v2/user/virtual-subaccount-list", 2 },
                            { "v2/user/virtual-subaccount-apikey-list", 2 },
                        } },
                        { "post", new Dictionary<string, object>() {
                            { "user/v1/sub/virtual-create", 4 },
                            { "user/v1/sub/virtual-modify", 4 },
                            { "user/v1/sub/virtual-api-batch-create", 20 },
                            { "user/v1/sub/virtual-api-create", 4 },
                            { "user/v1/sub/virtual-api-modify", 4 },
                            { "v2/user/create-virtual-subaccount", 4 },
                            { "v2/user/modify-virtual-subaccount", 4 },
                            { "v2/user/batch-create-subaccount-and-apikey", 20 },
                            { "v2/user/create-virtual-subaccount-apikey", 4 },
                            { "v2/user/modify-virtual-subaccount-apikey", 4 },
                        } },
                    } },
                    { "p2p", new Dictionary<string, object>() {
                        { "get", new Dictionary<string, object>() {
                            { "p2p/v1/merchant/merchantList", 2 },
                            { "p2p/v1/merchant/merchantInfo", 2 },
                            { "p2p/v1/merchant/advList", 2 },
                            { "p2p/v1/merchant/orderList", 2 },
                            { "v2/p2p/merchantList", 2 },
                            { "v2/p2p/merchantInfo", 2 },
                            { "v2/p2p/orderList", 2 },
                            { "v2/p2p/advList", 2 },
                        } },
                    } },
                    { "broker", new Dictionary<string, object>() {
                        { "get", new Dictionary<string, object>() {
                            { "broker/v1/account/info", 2 },
                            { "broker/v1/account/sub-list", 20 },
                            { "broker/v1/account/sub-email", 20 },
                            { "broker/v1/account/sub-spot-assets", 2 },
                            { "broker/v1/account/sub-future-assets", 2 },
                            { "broker/v1/account/subaccount-transfer", 1 },
                            { "broker/v1/account/subaccount-deposit", 1 },
                            { "broker/v1/account/subaccount-withdrawal", 1 },
                            { "broker/v1/account/sub-api-list", 2 },
                            { "v2/broker/account/info", 2 },
                            { "v2/broker/account/subaccount-list", 20 },
                            { "v2/broker/account/subaccount-email", 2 },
                            { "v2/broker/account/subaccount-spot-assets", 2 },
                            { "v2/broker/account/subaccount-future-assets", 2 },
                            { "v2/broker/manage/subaccount-apikey-list", 2 },
                        } },
                        { "post", new Dictionary<string, object>() {
                            { "broker/v1/account/sub-create", 20 },
                            { "broker/v1/account/sub-modify", 20 },
                            { "broker/v1/account/sub-modify-email", 20 },
                            { "broker/v1/account/sub-address", 2 },
                            { "broker/v1/account/sub-withdrawal", 2 },
                            { "broker/v1/account/sub-auto-transfer", 4 },
                            { "broker/v1/account/sub-api-create", 2 },
                            { "broker/v1/account/sub-api-modify", 2 },
                            { "v2/broker/account/modify-subaccount-email", 2 },
                            { "v2/broker/account/create-subaccount", 20 },
                            { "v2/broker/account/modify-subaccount", 20 },
                            { "v2/broker/account/subaccount-address", 2 },
                            { "v2/broker/account/subaccount-withdrawal", 2 },
                            { "v2/broker/account/set-subaccount-autotransfer", 2 },
                            { "v2/broker/manage/create-subaccount-apikey", 2 },
                            { "v2/broker/manage/modify-subaccount-apikey", 2 },
                        } },
                    } },
                    { "margin", new Dictionary<string, object>() {
                        { "get", new Dictionary<string, object>() {
                            { "margin/v1/cross/account/riskRate", 2 },
                            { "margin/v1/cross/account/maxTransferOutAmount", 2 },
                            { "margin/v1/isolated/account/maxTransferOutAmount", 2 },
                            { "margin/v1/isolated/order/openOrders", 2 },
                            { "margin/v1/isolated/order/history", 2 },
                            { "margin/v1/isolated/order/fills", 2 },
                            { "margin/v1/isolated/loan/list", 2 },
                            { "margin/v1/isolated/repay/list", 2 },
                            { "margin/v1/isolated/interest/list", 2 },
                            { "margin/v1/isolated/liquidation/list", 2 },
                            { "margin/v1/isolated/fin/list", 2 },
                            { "margin/v1/cross/order/openOrders", 2 },
                            { "margin/v1/cross/order/history", 2 },
                            { "margin/v1/cross/order/fills", 2 },
                            { "margin/v1/cross/loan/list", 2 },
                            { "margin/v1/cross/repay/list", 2 },
                            { "margin/v1/cross/interest/list", 2 },
                            { "margin/v1/cross/liquidation/list", 2 },
                            { "margin/v1/cross/fin/list", 2 },
                            { "margin/v1/cross/account/assets", 2 },
                            { "margin/v1/isolated/account/assets", 2 },
                            { "v2/margin/crossed/borrow-history", 2 },
                            { "v2/margin/crossed/repay-history", 2 },
                            { "v2/margin/crossed/interest-history", 2 },
                            { "v2/margin/crossed/liquidation-history", 2 },
                            { "v2/margin/crossed/financial-records", 2 },
                            { "v2/margin/crossed/account/assets", 2 },
                            { "v2/margin/crossed/account/risk-rate", 2 },
                            { "v2/margin/crossed/account/max-borrowable-amount", 2 },
                            { "v2/margin/crossed/account/max-transfer-out-amount", 2 },
                            { "v2/margin/crossed/interest-rate-and-limit", 2 },
                            { "v2/margin/crossed/tier-data", 2 },
                            { "v2/margin/crossed/open-orders", 2 },
                            { "v2/margin/crossed/history-orders", 2 },
                            { "v2/margin/crossed/fills", 2 },
                            { "v2/margin/isolated/borrow-history", 2 },
                            { "v2/margin/isolated/repay-history", 2 },
                            { "v2/margin/isolated/interest-history", 2 },
                            { "v2/margin/isolated/liquidation-history", 2 },
                            { "v2/margin/isolated/financial-records", 2 },
                            { "v2/margin/isolated/account/assets", 2 },
                            { "v2/margin/isolated/account/risk-rate", 2 },
                            { "v2/margin/isolated/account/max-borrowable-amount", 2 },
                            { "v2/margin/isolated/account/max-transfer-out-amount", 2 },
                            { "v2/margin/isolated/interest-rate-and-limit", 2 },
                            { "v2/margin/isolated/tier-data", 2 },
                            { "v2/margin/isolated/open-orders", 2 },
                            { "v2/margin/isolated/history-orders", 2 },
                            { "v2/margin/isolated/fills", 2 },
                        } },
                        { "post", new Dictionary<string, object>() {
                            { "margin/v1/cross/account/borrow", 2 },
                            { "margin/v1/isolated/account/borrow", 2 },
                            { "margin/v1/cross/account/repay", 2 },
                            { "margin/v1/isolated/account/repay", 2 },
                            { "margin/v1/isolated/account/riskRate", 2 },
                            { "margin/v1/cross/account/maxBorrowableAmount", 2 },
                            { "margin/v1/isolated/account/maxBorrowableAmount", 2 },
                            { "margin/v1/isolated/account/flashRepay", 2 },
                            { "margin/v1/isolated/account/queryFlashRepayStatus", 2 },
                            { "margin/v1/cross/account/flashRepay", 2 },
                            { "margin/v1/cross/account/queryFlashRepayStatus", 2 },
                            { "margin/v1/isolated/order/placeOrder", 4 },
                            { "margin/v1/isolated/order/batchPlaceOrder", 4 },
                            { "margin/v1/isolated/order/cancelOrder", 2 },
                            { "margin/v1/isolated/order/batchCancelOrder", 2 },
                            { "margin/v1/cross/order/placeOrder", 2 },
                            { "margin/v1/cross/order/batchPlaceOrder", 2 },
                            { "margin/v1/cross/order/cancelOrder", 2 },
                            { "margin/v1/cross/order/batchCancelOrder", 2 },
                            { "v2/margin/crossed/account/borrow", 2 },
                            { "v2/margin/crossed/account/repay", 2 },
                            { "v2/margin/crossed/account/flash-repay", 2 },
                            { "v2/margin/crossed/account/query-flash-repay-status", 2 },
                            { "v2/margin/crossed/place-order", 2 },
                            { "v2/margin/crossed/batch-place-order", 2 },
                            { "v2/margin/crossed/cancel-order", 2 },
                            { "v2/margin/crossed/batch-cancel-order", 2 },
                            { "v2/margin/isolated/account/borrow", 2 },
                            { "v2/margin/isolated/account/repay", 2 },
                            { "v2/margin/isolated/account/flash-repay", 2 },
                            { "v2/margin/isolated/account/query-flash-repay-status", 2 },
                            { "v2/margin/isolated/place-order", 2 },
                            { "v2/margin/isolated/batch-place-order", 2 },
                            { "v2/margin/isolated/cancel-order", 2 },
                            { "v2/margin/isolated/batch-cancel-order", 2 },
                        } },
                    } },
                    { "copy", new Dictionary<string, object>() {
                        { "get", new Dictionary<string, object>() {
                            { "v2/copy/mix-trader/order-current-track", 2 },
                            { "v2/copy/mix-trader/order-history-track", 2 },
                            { "v2/copy/mix-trader/order-total-detail", 2 },
                            { "v2/copy/mix-trader/profit-history-summarys", 1 },
                            { "v2/copy/mix-trader/profit-history-details", 1 },
                            { "v2/copy/mix-trader/profit-details", 1 },
                            { "v2/copy/mix-trader/profits-group-coin-date", 1 },
                            { "v2/copy/mix-trader/config-query-symbols", 1 },
                            { "v2/copy/mix-trader/config-query-followers", 2 },
                            { "v2/copy/mix-follower/query-current-orders", 2 },
                            { "v2/copy/mix-follower/query-history-orders", 1 },
                            { "v2/copy/mix-follower/query-settings", 2 },
                            { "v2/copy/mix-follower/query-traders", 2 },
                            { "v2/copy/mix-follower/query-quantity-limit", 2 },
                            { "v2/copy/mix-broker/query-traders", 2 },
                            { "v2/copy/mix-broker/query-history-traces", 2 },
                            { "v2/copy/mix-broker/query-current-traces", 2 },
                            { "v2/copy/spot-trader/profit-summarys", 2 },
                            { "v2/copy/spot-trader/profit-history-details", 2 },
                            { "v2/copy/spot-trader/profit-details", 2 },
                            { "v2/copy/spot-trader/order-total-detail", 2 },
                            { "v2/copy/spot-trader/order-history-track", 2 },
                            { "v2/copy/spot-trader/order-current-track", 2 },
                            { "v2/copy/spot-trader/config-query-settings", 2 },
                            { "v2/copy/spot-trader/config-query-followers", 2 },
                            { "v2/copy/spot-follower/query-traders", 2 },
                            { "v2/copy/spot-follower/query-trader-symbols", 2 },
                            { "v2/copy/spot-follower/query-settings", 2 },
                            { "v2/copy/spot-follower/query-history-orders", 2 },
                            { "v2/copy/spot-follower/query-current-orders", 2 },
                        } },
                        { "post", new Dictionary<string, object>() {
                            { "v2/copy/mix-trader/order-modify-tpsl", 2 },
                            { "v2/copy/mix-trader/order-close-positions", 2 },
                            { "v2/copy/mix-trader/config-setting-symbols", 2 },
                            { "v2/copy/mix-trader/config-setting-base", 2 },
                            { "v2/copy/mix-trader/config-remove-follower", 2 },
                            { "v2/copy/mix-follower/setting-tpsl", 1 },
                            { "v2/copy/mix-follower/settings", 2 },
                            { "v2/copy/mix-follower/close-positions", 2 },
                            { "v2/copy/mix-follower/cancel-trader", 4 },
                            { "v2/copy/spot-trader/order-modify-tpsl", 2 },
                            { "v2/copy/spot-trader/order-close-tracking", 2 },
                            { "v2/copy/spot-trader/config-setting-symbols", 2 },
                            { "v2/copy/spot-trader/config-remove-follower", 2 },
                            { "v2/copy/spot-follower/stop-order", 2 },
                            { "v2/copy/spot-follower/settings", 2 },
                            { "v2/copy/spot-follower/setting-tpsl", 2 },
                            { "v2/copy/spot-follower/order-close-tracking", 2 },
                            { "v2/copy/spot-follower/cancel-trader", 2 },
                        } },
                    } },
                    { "tax", new Dictionary<string, object>() {
                        { "get", new Dictionary<string, object>() {
                            { "v2/tax/spot-record", 20 },
                            { "v2/tax/future-record", 20 },
                            { "v2/tax/margin-record", 20 },
                            { "v2/tax/p2p-record", 20 },
                        } },
                    } },
                    { "convert", new Dictionary<string, object>() {
                        { "get", new Dictionary<string, object>() {
                            { "v2/convert/currencies", 2 },
                            { "v2/convert/quoted-price", 2 },
                            { "v2/convert/convert-record", 2 },
                            { "v2/convert/bgb-convert-coin-list", 2 },
                            { "v2/convert/bgb-convert-records", 2 },
                        } },
                        { "post", new Dictionary<string, object>() {
                            { "v2/convert/trade", 2 },
                            { "v2/convert/bgb-convert", 2 },
                        } },
                    } },
                    { "earn", new Dictionary<string, object>() {
                        { "get", new Dictionary<string, object>() {
                            { "v2/earn/savings/product", 2 },
                            { "v2/earn/savings/account", 2 },
                            { "v2/earn/savings/assets", 2 },
                            { "v2/earn/savings/records", 2 },
                            { "v2/earn/savings/subscribe-info", 2 },
                            { "v2/earn/savings/subscribe-result", 2 },
                            { "v2/earn/savings/redeem-result", 2 },
                            { "v2/earn/sharkfin/product", 2 },
                            { "v2/earn/sharkfin/account", 2 },
                            { "v2/earn/sharkfin/assets", 2 },
                            { "v2/earn/sharkfin/records", 2 },
                            { "v2/earn/sharkfin/subscribe-info", 2 },
                            { "v2/earn/sharkfin/subscribe-result", 4 },
                            { "v2/earn/loan/ongoing-orders", 2 },
                            { "v2/earn/loan/repay-history", 2 },
                            { "v2/earn/loan/revise-history", 2 },
                            { "v2/earn/loan/borrow-history", 2 },
                            { "v2/earn/loan/debts", 2 },
                            { "v2/earn/loan/reduces", 2 },
                        } },
                        { "post", new Dictionary<string, object>() {
                            { "v2/earn/savings/subscribe", 2 },
                            { "v2/earn/savings/redeem", 2 },
                            { "v2/earn/sharkfin/subscribe", 2 },
                            { "v2/earn/loan/borrow", 2 },
                            { "v2/earn/loan/repay", 2 },
                            { "v2/earn/loan/revise-pledge", 2 },
                        } },
                    } },
                    { "common", new Dictionary<string, object>() {
                        { "get", new Dictionary<string, object>() {
                            { "v2/common/trade-rate", 2 },
                        } },
                    } },
                } },
            } },
            { "fees", new Dictionary<string, object>() {
                { "spot", new Dictionary<string, object>() {
                    { "taker", this.parseNumber("0.002") },
                    { "maker", this.parseNumber("0.002") },
                } },
                { "swap", new Dictionary<string, object>() {
                    { "taker", this.parseNumber("0.0006") },
                    { "maker", this.parseNumber("0.0004") },
                } },
            } },
            { "requiredCredentials", new Dictionary<string, object>() {
                { "apiKey", true },
                { "secret", true },
                { "password", true },
            } },
            { "exceptions", new Dictionary<string, object>() {
                { "exact", new Dictionary<string, object>() {
                    { "1", typeof(ExchangeError) },
                    { "failure to get a peer from the ring-balancer", typeof(ExchangeNotAvailable) },
                    { "4010", typeof(PermissionDenied) },
                    { "4001", typeof(ExchangeError) },
                    { "4002", typeof(ExchangeError) },
                    { "30001", typeof(AuthenticationError) },
                    { "30002", typeof(AuthenticationError) },
                    { "30003", typeof(AuthenticationError) },
                    { "30004", typeof(AuthenticationError) },
                    { "30005", typeof(InvalidNonce) },
                    { "30006", typeof(AuthenticationError) },
                    { "30007", typeof(BadRequest) },
                    { "30008", typeof(RequestTimeout) },
                    { "30009", typeof(ExchangeError) },
                    { "30010", typeof(AuthenticationError) },
                    { "30011", typeof(PermissionDenied) },
                    { "30012", typeof(AuthenticationError) },
                    { "30013", typeof(AuthenticationError) },
                    { "30014", typeof(DDoSProtection) },
                    { "30015", typeof(AuthenticationError) },
                    { "30016", typeof(ExchangeError) },
                    { "30017", typeof(ExchangeError) },
                    { "30018", typeof(ExchangeError) },
                    { "30019", typeof(ExchangeNotAvailable) },
                    { "30020", typeof(BadRequest) },
                    { "30021", typeof(BadRequest) },
                    { "30022", typeof(PermissionDenied) },
                    { "30023", typeof(BadRequest) },
                    { "30024", typeof(BadSymbol) },
                    { "30025", typeof(BadRequest) },
                    { "30026", typeof(DDoSProtection) },
                    { "30027", typeof(AuthenticationError) },
                    { "30028", typeof(PermissionDenied) },
                    { "30029", typeof(AccountSuspended) },
                    { "30030", typeof(ExchangeError) },
                    { "30031", typeof(BadRequest) },
                    { "30032", typeof(BadSymbol) },
                    { "30033", typeof(BadRequest) },
                    { "30034", typeof(ExchangeError) },
                    { "30035", typeof(ExchangeError) },
                    { "30036", typeof(ExchangeError) },
                    { "30037", typeof(ExchangeNotAvailable) },
                    { "30038", typeof(OnMaintenance) },
                    { "32001", typeof(AccountSuspended) },
                    { "32002", typeof(PermissionDenied) },
                    { "32003", typeof(CancelPending) },
                    { "32004", typeof(ExchangeError) },
                    { "32005", typeof(InvalidOrder) },
                    { "32006", typeof(InvalidOrder) },
                    { "32007", typeof(InvalidOrder) },
                    { "32008", typeof(InvalidOrder) },
                    { "32009", typeof(InvalidOrder) },
                    { "32010", typeof(ExchangeError) },
                    { "32011", typeof(ExchangeError) },
                    { "32012", typeof(ExchangeError) },
                    { "32013", typeof(ExchangeError) },
                    { "32014", typeof(ExchangeError) },
                    { "32015", typeof(ExchangeError) },
                    { "32016", typeof(ExchangeError) },
                    { "32017", typeof(ExchangeError) },
                    { "32018", typeof(ExchangeError) },
                    { "32019", typeof(ExchangeError) },
                    { "32020", typeof(ExchangeError) },
                    { "32021", typeof(ExchangeError) },
                    { "32022", typeof(ExchangeError) },
                    { "32023", typeof(ExchangeError) },
                    { "32024", typeof(ExchangeError) },
                    { "32025", typeof(ExchangeError) },
                    { "32026", typeof(ExchangeError) },
                    { "32027", typeof(ExchangeError) },
                    { "32028", typeof(AccountSuspended) },
                    { "32029", typeof(ExchangeError) },
                    { "32030", typeof(InvalidOrder) },
                    { "32031", typeof(ArgumentsRequired) },
                    { "32038", typeof(AuthenticationError) },
                    { "32040", typeof(ExchangeError) },
                    { "32044", typeof(ExchangeError) },
                    { "32045", typeof(ExchangeError) },
                    { "32046", typeof(ExchangeError) },
                    { "32047", typeof(ExchangeError) },
                    { "32048", typeof(InvalidOrder) },
                    { "32049", typeof(ExchangeError) },
                    { "32050", typeof(InvalidOrder) },
                    { "32051", typeof(InvalidOrder) },
                    { "32052", typeof(ExchangeError) },
                    { "32053", typeof(ExchangeError) },
                    { "32057", typeof(ExchangeError) },
                    { "32054", typeof(ExchangeError) },
                    { "32055", typeof(InvalidOrder) },
                    { "32056", typeof(ExchangeError) },
                    { "32058", typeof(ExchangeError) },
                    { "32059", typeof(InvalidOrder) },
                    { "32060", typeof(InvalidOrder) },
                    { "32061", typeof(InvalidOrder) },
                    { "32062", typeof(InvalidOrder) },
                    { "32063", typeof(InvalidOrder) },
                    { "32064", typeof(ExchangeError) },
                    { "32065", typeof(ExchangeError) },
                    { "32066", typeof(ExchangeError) },
                    { "32067", typeof(ExchangeError) },
                    { "32068", typeof(ExchangeError) },
                    { "32069", typeof(ExchangeError) },
                    { "32070", typeof(ExchangeError) },
                    { "32071", typeof(ExchangeError) },
                    { "32072", typeof(ExchangeError) },
                    { "32073", typeof(ExchangeError) },
                    { "32074", typeof(ExchangeError) },
                    { "32075", typeof(ExchangeError) },
                    { "32076", typeof(ExchangeError) },
                    { "32077", typeof(ExchangeError) },
                    { "32078", typeof(ExchangeError) },
                    { "32079", typeof(ExchangeError) },
                    { "32080", typeof(ExchangeError) },
                    { "32083", typeof(ExchangeError) },
                    { "33001", typeof(PermissionDenied) },
                    { "33002", typeof(AccountSuspended) },
                    { "33003", typeof(InsufficientFunds) },
                    { "33004", typeof(ExchangeError) },
                    { "33005", typeof(ExchangeError) },
                    { "33006", typeof(ExchangeError) },
                    { "33007", typeof(ExchangeError) },
                    { "33008", typeof(InsufficientFunds) },
                    { "33009", typeof(ExchangeError) },
                    { "33010", typeof(ExchangeError) },
                    { "33011", typeof(ExchangeError) },
                    { "33012", typeof(ExchangeError) },
                    { "33013", typeof(InvalidOrder) },
                    { "33014", typeof(OrderNotFound) },
                    { "33015", typeof(InvalidOrder) },
                    { "33016", typeof(ExchangeError) },
                    { "33017", typeof(InsufficientFunds) },
                    { "33018", typeof(ExchangeError) },
                    { "33020", typeof(ExchangeError) },
                    { "33021", typeof(BadRequest) },
                    { "33022", typeof(InvalidOrder) },
                    { "33023", typeof(ExchangeError) },
                    { "33024", typeof(InvalidOrder) },
                    { "33025", typeof(InvalidOrder) },
                    { "33026", typeof(ExchangeError) },
                    { "33027", typeof(InvalidOrder) },
                    { "33028", typeof(InvalidOrder) },
                    { "33029", typeof(InvalidOrder) },
                    { "33034", typeof(ExchangeError) },
                    { "33035", typeof(ExchangeError) },
                    { "33036", typeof(ExchangeError) },
                    { "33037", typeof(ExchangeError) },
                    { "33038", typeof(ExchangeError) },
                    { "33039", typeof(ExchangeError) },
                    { "33040", typeof(ExchangeError) },
                    { "33041", typeof(ExchangeError) },
                    { "33042", typeof(ExchangeError) },
                    { "33043", typeof(ExchangeError) },
                    { "33044", typeof(ExchangeError) },
                    { "33045", typeof(ExchangeError) },
                    { "33046", typeof(ExchangeError) },
                    { "33047", typeof(ExchangeError) },
                    { "33048", typeof(ExchangeError) },
                    { "33049", typeof(ExchangeError) },
                    { "33050", typeof(ExchangeError) },
                    { "33051", typeof(ExchangeError) },
                    { "33059", typeof(BadRequest) },
                    { "33060", typeof(BadRequest) },
                    { "33061", typeof(ExchangeError) },
                    { "33062", typeof(ExchangeError) },
                    { "33063", typeof(ExchangeError) },
                    { "33064", typeof(ExchangeError) },
                    { "33065", typeof(ExchangeError) },
                    { "21009", typeof(ExchangeError) },
                    { "34001", typeof(PermissionDenied) },
                    { "34002", typeof(InvalidAddress) },
                    { "34003", typeof(ExchangeError) },
                    { "34004", typeof(ExchangeError) },
                    { "34005", typeof(ExchangeError) },
                    { "34006", typeof(ExchangeError) },
                    { "34007", typeof(ExchangeError) },
                    { "34008", typeof(InsufficientFunds) },
                    { "34009", typeof(ExchangeError) },
                    { "34010", typeof(ExchangeError) },
                    { "34011", typeof(ExchangeError) },
                    { "34012", typeof(ExchangeError) },
                    { "34013", typeof(ExchangeError) },
                    { "34014", typeof(ExchangeError) },
                    { "34015", typeof(ExchangeError) },
                    { "34016", typeof(PermissionDenied) },
                    { "34017", typeof(AccountSuspended) },
                    { "34018", typeof(AuthenticationError) },
                    { "34019", typeof(PermissionDenied) },
                    { "34020", typeof(PermissionDenied) },
                    { "34021", typeof(InvalidAddress) },
                    { "34022", typeof(ExchangeError) },
                    { "34023", typeof(PermissionDenied) },
                    { "34026", typeof(ExchangeError) },
                    { "34036", typeof(ExchangeError) },
                    { "34037", typeof(ExchangeError) },
                    { "34038", typeof(ExchangeError) },
                    { "34039", typeof(ExchangeError) },
                    { "35001", typeof(ExchangeError) },
                    { "35002", typeof(ExchangeError) },
                    { "35003", typeof(ExchangeError) },
                    { "35004", typeof(ExchangeError) },
                    { "35005", typeof(AuthenticationError) },
                    { "35008", typeof(InvalidOrder) },
                    { "35010", typeof(InvalidOrder) },
                    { "35012", typeof(InvalidOrder) },
                    { "35014", typeof(InvalidOrder) },
                    { "35015", typeof(InvalidOrder) },
                    { "35017", typeof(ExchangeError) },
                    { "35019", typeof(InvalidOrder) },
                    { "35020", typeof(InvalidOrder) },
                    { "35021", typeof(InvalidOrder) },
                    { "35022", typeof(ExchangeError) },
                    { "35024", typeof(ExchangeError) },
                    { "35025", typeof(InsufficientFunds) },
                    { "35026", typeof(ExchangeError) },
                    { "35029", typeof(OrderNotFound) },
                    { "35030", typeof(InvalidOrder) },
                    { "35031", typeof(InvalidOrder) },
                    { "35032", typeof(ExchangeError) },
                    { "35037", typeof(ExchangeError) },
                    { "35039", typeof(ExchangeError) },
                    { "35040", typeof(InvalidOrder) },
                    { "35044", typeof(ExchangeError) },
                    { "35046", typeof(InsufficientFunds) },
                    { "35047", typeof(InsufficientFunds) },
                    { "35048", typeof(ExchangeError) },
                    { "35049", typeof(InvalidOrder) },
                    { "35050", typeof(InvalidOrder) },
                    { "35052", typeof(InsufficientFunds) },
                    { "35053", typeof(ExchangeError) },
                    { "35055", typeof(InsufficientFunds) },
                    { "35057", typeof(ExchangeError) },
                    { "35058", typeof(ExchangeError) },
                    { "35059", typeof(BadRequest) },
                    { "35060", typeof(BadRequest) },
                    { "35061", typeof(BadRequest) },
                    { "35062", typeof(InvalidOrder) },
                    { "35063", typeof(InvalidOrder) },
                    { "35064", typeof(InvalidOrder) },
                    { "35066", typeof(InvalidOrder) },
                    { "35067", typeof(InvalidOrder) },
                    { "35068", typeof(InvalidOrder) },
                    { "35069", typeof(InvalidOrder) },
                    { "35070", typeof(InvalidOrder) },
                    { "35071", typeof(InvalidOrder) },
                    { "35072", typeof(InvalidOrder) },
                    { "35073", typeof(InvalidOrder) },
                    { "35074", typeof(InvalidOrder) },
                    { "35075", typeof(InvalidOrder) },
                    { "35076", typeof(InvalidOrder) },
                    { "35077", typeof(InvalidOrder) },
                    { "35078", typeof(InvalidOrder) },
                    { "35079", typeof(InvalidOrder) },
                    { "35080", typeof(InvalidOrder) },
                    { "35081", typeof(InvalidOrder) },
                    { "35082", typeof(InvalidOrder) },
                    { "35083", typeof(InvalidOrder) },
                    { "35084", typeof(InvalidOrder) },
                    { "35085", typeof(InvalidOrder) },
                    { "35086", typeof(InvalidOrder) },
                    { "35087", typeof(InvalidOrder) },
                    { "35088", typeof(InvalidOrder) },
                    { "35089", typeof(InvalidOrder) },
                    { "35090", typeof(ExchangeError) },
                    { "35091", typeof(ExchangeError) },
                    { "35092", typeof(ExchangeError) },
                    { "35093", typeof(ExchangeError) },
                    { "35094", typeof(ExchangeError) },
                    { "35095", typeof(BadRequest) },
                    { "35096", typeof(ExchangeError) },
                    { "35097", typeof(ExchangeError) },
                    { "35098", typeof(ExchangeError) },
                    { "35099", typeof(ExchangeError) },
                    { "36001", typeof(BadRequest) },
                    { "36002", typeof(BadRequest) },
                    { "36005", typeof(ExchangeError) },
                    { "36101", typeof(AuthenticationError) },
                    { "36102", typeof(PermissionDenied) },
                    { "36103", typeof(AccountSuspended) },
                    { "36104", typeof(PermissionDenied) },
                    { "36105", typeof(PermissionDenied) },
                    { "36106", typeof(AccountSuspended) },
                    { "36107", typeof(PermissionDenied) },
                    { "36108", typeof(InsufficientFunds) },
                    { "36109", typeof(PermissionDenied) },
                    { "36201", typeof(PermissionDenied) },
                    { "36202", typeof(PermissionDenied) },
                    { "36203", typeof(InvalidOrder) },
                    { "36204", typeof(ExchangeError) },
                    { "36205", typeof(BadRequest) },
                    { "36206", typeof(BadRequest) },
                    { "36207", typeof(InvalidOrder) },
                    { "36208", typeof(InvalidOrder) },
                    { "36209", typeof(InvalidOrder) },
                    { "36210", typeof(InvalidOrder) },
                    { "36211", typeof(InvalidOrder) },
                    { "36212", typeof(InvalidOrder) },
                    { "36213", typeof(InvalidOrder) },
                    { "36214", typeof(ExchangeError) },
                    { "36216", typeof(OrderNotFound) },
                    { "36217", typeof(InvalidOrder) },
                    { "36218", typeof(InvalidOrder) },
                    { "36219", typeof(InvalidOrder) },
                    { "36220", typeof(InvalidOrder) },
                    { "36221", typeof(InvalidOrder) },
                    { "36222", typeof(InvalidOrder) },
                    { "36223", typeof(InvalidOrder) },
                    { "36224", typeof(InvalidOrder) },
                    { "36225", typeof(InvalidOrder) },
                    { "36226", typeof(InvalidOrder) },
                    { "36227", typeof(InvalidOrder) },
                    { "36228", typeof(InvalidOrder) },
                    { "36229", typeof(InvalidOrder) },
                    { "36230", typeof(InvalidOrder) },
                    { "400", typeof(BadRequest) },
                    { "401", typeof(AuthenticationError) },
                    { "403", typeof(PermissionDenied) },
                    { "404", typeof(BadRequest) },
                    { "405", typeof(BadRequest) },
                    { "415", typeof(BadRequest) },
                    { "429", typeof(DDoSProtection) },
                    { "500", typeof(ExchangeNotAvailable) },
                    { "1001", typeof(RateLimitExceeded) },
                    { "1002", typeof(ExchangeError) },
                    { "1003", typeof(ExchangeError) },
                    { "40001", typeof(AuthenticationError) },
                    { "40002", typeof(AuthenticationError) },
                    { "40003", typeof(AuthenticationError) },
                    { "40004", typeof(InvalidNonce) },
                    { "40005", typeof(InvalidNonce) },
                    { "40006", typeof(AuthenticationError) },
                    { "40007", typeof(BadRequest) },
                    { "40008", typeof(InvalidNonce) },
                    { "40009", typeof(AuthenticationError) },
                    { "40010", typeof(AuthenticationError) },
                    { "40011", typeof(AuthenticationError) },
                    { "40012", typeof(AuthenticationError) },
                    { "40013", typeof(ExchangeError) },
                    { "40014", typeof(PermissionDenied) },
                    { "40015", typeof(ExchangeError) },
                    { "40016", typeof(PermissionDenied) },
                    { "40017", typeof(ExchangeError) },
                    { "40018", typeof(PermissionDenied) },
                    { "40019", typeof(BadRequest) },
                    { "40031", typeof(AccountSuspended) },
                    { "40037", typeof(AuthenticationError) },
                    { "40102", typeof(BadRequest) },
                    { "40103", typeof(BadRequest) },
                    { "40104", typeof(ExchangeError) },
                    { "40105", typeof(ExchangeError) },
                    { "40106", typeof(ExchangeError) },
                    { "40107", typeof(ExchangeError) },
                    { "40108", typeof(InvalidOrder) },
                    { "40109", typeof(OrderNotFound) },
                    { "40200", typeof(OnMaintenance) },
                    { "40201", typeof(InvalidOrder) },
                    { "40202", typeof(ExchangeError) },
                    { "40203", typeof(BadRequest) },
                    { "40204", typeof(BadRequest) },
                    { "40205", typeof(BadRequest) },
                    { "40206", typeof(BadRequest) },
                    { "40207", typeof(BadRequest) },
                    { "40208", typeof(BadRequest) },
                    { "40209", typeof(BadRequest) },
                    { "40300", typeof(ExchangeError) },
                    { "40301", typeof(PermissionDenied) },
                    { "40302", typeof(BadRequest) },
                    { "40303", typeof(BadRequest) },
                    { "40304", typeof(BadRequest) },
                    { "40305", typeof(BadRequest) },
                    { "40306", typeof(ExchangeError) },
                    { "40308", typeof(OnMaintenance) },
                    { "40309", typeof(BadSymbol) },
                    { "40400", typeof(ExchangeError) },
                    { "40401", typeof(ExchangeError) },
                    { "40402", typeof(BadRequest) },
                    { "40403", typeof(BadRequest) },
                    { "40404", typeof(BadRequest) },
                    { "40405", typeof(BadRequest) },
                    { "40406", typeof(BadRequest) },
                    { "40407", typeof(ExchangeError) },
                    { "40408", typeof(ExchangeError) },
                    { "40409", typeof(ExchangeError) },
                    { "40500", typeof(InvalidOrder) },
                    { "40501", typeof(ExchangeError) },
                    { "40502", typeof(ExchangeError) },
                    { "40503", typeof(ExchangeError) },
                    { "40504", typeof(ExchangeError) },
                    { "40505", typeof(ExchangeError) },
                    { "40506", typeof(AuthenticationError) },
                    { "40507", typeof(AuthenticationError) },
                    { "40508", typeof(ExchangeError) },
                    { "40509", typeof(ExchangeError) },
                    { "40600", typeof(ExchangeError) },
                    { "40601", typeof(ExchangeError) },
                    { "40602", typeof(ExchangeError) },
                    { "40603", typeof(ExchangeError) },
                    { "40604", typeof(ExchangeNotAvailable) },
                    { "40605", typeof(ExchangeError) },
                    { "40606", typeof(ExchangeError) },
                    { "40607", typeof(ExchangeError) },
                    { "40608", typeof(ExchangeError) },
                    { "40609", typeof(ExchangeError) },
                    { "40700", typeof(BadRequest) },
                    { "40701", typeof(ExchangeError) },
                    { "40702", typeof(ExchangeError) },
                    { "40703", typeof(ExchangeError) },
                    { "40704", typeof(ExchangeError) },
                    { "40705", typeof(BadRequest) },
                    { "40706", typeof(InvalidOrder) },
                    { "40707", typeof(BadRequest) },
                    { "40708", typeof(BadRequest) },
                    { "40709", typeof(ExchangeError) },
                    { "40710", typeof(ExchangeError) },
                    { "40711", typeof(InsufficientFunds) },
                    { "40712", typeof(InsufficientFunds) },
                    { "40713", typeof(ExchangeError) },
                    { "40714", typeof(ExchangeError) },
                    { "40768", typeof(OrderNotFound) },
                    { "41114", typeof(OnMaintenance) },
                    { "43011", typeof(InvalidOrder) },
                    { "43012", typeof(InsufficientFunds) },
                    { "43025", typeof(InvalidOrder) },
                    { "43115", typeof(OnMaintenance) },
                    { "45110", typeof(InvalidOrder) },
                    { "invalid sign", typeof(AuthenticationError) },
                    { "invalid currency", typeof(BadSymbol) },
                    { "invalid symbol", typeof(BadSymbol) },
                    { "invalid period", typeof(BadRequest) },
                    { "invalid user", typeof(ExchangeError) },
                    { "invalid amount", typeof(InvalidOrder) },
                    { "invalid type", typeof(InvalidOrder) },
                    { "invalid orderId", typeof(InvalidOrder) },
                    { "invalid record", typeof(ExchangeError) },
                    { "invalid accountId", typeof(BadRequest) },
                    { "invalid address", typeof(BadRequest) },
                    { "accesskey not null", typeof(AuthenticationError) },
                    { "illegal accesskey", typeof(AuthenticationError) },
                    { "sign not null", typeof(AuthenticationError) },
                    { "req_time is too much difference from server time", typeof(InvalidNonce) },
                    { "permissions not right", typeof(PermissionDenied) },
                    { "illegal sign invalid", typeof(AuthenticationError) },
                    { "user locked", typeof(AccountSuspended) },
                    { "Request Frequency Is Too High", typeof(RateLimitExceeded) },
                    { "more than a daily rate of cash", typeof(BadRequest) },
                    { "more than the maximum daily withdrawal amount", typeof(BadRequest) },
                    { "need to bind email or mobile", typeof(ExchangeError) },
                    { "user forbid", typeof(PermissionDenied) },
                    { "User Prohibited Cash Withdrawal", typeof(PermissionDenied) },
                    { "Cash Withdrawal Is Less Than The Minimum Value", typeof(BadRequest) },
                    { "Cash Withdrawal Is More Than The Maximum Value", typeof(BadRequest) },
                    { "the account with in 24 hours ban coin", typeof(PermissionDenied) },
                    { "order cancel fail", typeof(BadRequest) },
                    { "base symbol error", typeof(BadSymbol) },
                    { "base date error", typeof(ExchangeError) },
                    { "api signature not valid", typeof(AuthenticationError) },
                    { "gateway internal error", typeof(ExchangeError) },
                    { "audit failed", typeof(ExchangeError) },
                    { "order queryorder invalid", typeof(BadRequest) },
                    { "market no need price", typeof(InvalidOrder) },
                    { "limit need price", typeof(InvalidOrder) },
                    { "userid not equal to account_id", typeof(ExchangeError) },
                    { "your balance is low", typeof(InsufficientFunds) },
                    { "address invalid cointype", typeof(ExchangeError) },
                    { "system exception", typeof(ExchangeError) },
                    { "50003", typeof(ExchangeError) },
                    { "50004", typeof(BadSymbol) },
                    { "50006", typeof(PermissionDenied) },
                    { "50007", typeof(PermissionDenied) },
                    { "50008", typeof(RequestTimeout) },
                    { "50009", typeof(RateLimitExceeded) },
                    { "50010", typeof(ExchangeError) },
                    { "50014", typeof(InvalidOrder) },
                    { "50015", typeof(InvalidOrder) },
                    { "50016", typeof(InvalidOrder) },
                    { "50017", typeof(InvalidOrder) },
                    { "50018", typeof(InvalidOrder) },
                    { "50019", typeof(InvalidOrder) },
                    { "50020", typeof(InsufficientFunds) },
                    { "50021", typeof(InvalidOrder) },
                    { "50026", typeof(InvalidOrder) },
                    { "invalid order query time", typeof(ExchangeError) },
                    { "invalid start time", typeof(BadRequest) },
                    { "invalid end time", typeof(BadRequest) },
                    { "20003", typeof(ExchangeError) },
                    { "01001", typeof(ExchangeError) },
                    { "43111", typeof(PermissionDenied) },
                } },
                { "broad", new Dictionary<string, object>() {
                    { "invalid size, valid range", typeof(ExchangeError) },
                } },
            } },
            { "precisionMode", TICK_SIZE },
            { "commonCurrencies", new Dictionary<string, object>() {
                { "JADE", "Jade Protocol" },
                { "DEGEN", "DegenReborn" },
                { "TONCOIN", "TON" },
            } },
            { "options", new Dictionary<string, object>() {
                { "timeframes", new Dictionary<string, object>() {
                    { "spot", new Dictionary<string, object>() {
                        { "1m", "1min" },
                        { "5m", "5min" },
                        { "15m", "15min" },
                        { "30m", "30min" },
                        { "1h", "1h" },
                        { "4h", "4h" },
                        { "6h", "6Hutc" },
                        { "12h", "12Hutc" },
                        { "1d", "1Dutc" },
                        { "3d", "3Dutc" },
                        { "1w", "1Wutc" },
                        { "1M", "1Mutc" },
                    } },
                    { "swap", new Dictionary<string, object>() {
                        { "1m", "1m" },
                        { "3m", "3m" },
                        { "5m", "5m" },
                        { "15m", "15m" },
                        { "30m", "30m" },
                        { "1h", "1H" },
                        { "2h", "2H" },
                        { "4h", "4H" },
                        { "6h", "6Hutc" },
                        { "12h", "12Hutc" },
                        { "1d", "1Dutc" },
                        { "3d", "3Dutc" },
                        { "1w", "1Wutc" },
                        { "1M", "1Mutc" },
                    } },
                } },
                { "fetchMarkets", new List<object>() {"spot", "swap"} },
                { "defaultType", "spot" },
                { "defaultSubType", "linear" },
                { "createMarketBuyOrderRequiresPrice", true },
                { "broker", "p4sve" },
                { "withdraw", new Dictionary<string, object>() {
                    { "fillResponseFromRequest", true },
                } },
                { "fetchOHLCV", new Dictionary<string, object>() {
                    { "spot", new Dictionary<string, object>() {
                        { "method", "publicSpotGetV2SpotMarketCandles" },
                    } },
                    { "swap", new Dictionary<string, object>() {
                        { "method", "publicMixGetV2MixMarketCandles" },
                    } },
                    { "maxDaysPerTimeframe", new Dictionary<string, object>() {
                        { "1m", 30 },
                        { "3m", 30 },
                        { "5m", 30 },
                        { "10m", 52 },
                        { "15m", 52 },
                        { "30m", 52 },
                        { "1h", 83 },
                        { "2h", 120 },
                        { "4h", 240 },
                        { "6h", 360 },
                        { "12h", 360 },
                        { "1d", 360 },
                        { "3d", 1000 },
                        { "1w", 1000 },
                        { "1M", 1000 },
                    } },
                } },
                { "fetchTrades", new Dictionary<string, object>() {
                    { "spot", new Dictionary<string, object>() {
                        { "method", "publicSpotGetV2SpotMarketFillsHistory" },
                    } },
                    { "swap", new Dictionary<string, object>() {
                        { "method", "publicMixGetV2MixMarketFillsHistory" },
                    } },
                } },
                { "accountsByType", new Dictionary<string, object>() {
                    { "spot", "spot" },
                    { "cross", "crossed_margin" },
                    { "isolated", "isolated_margin" },
                    { "swap", "usdt_futures" },
                    { "usdc_swap", "usdc_futures" },
                    { "future", "coin_futures" },
                    { "p2p", "p2p" },
                } },
                { "accountsById", new Dictionary<string, object>() {
                    { "spot", "spot" },
                    { "crossed_margin", "cross" },
                    { "isolated_margin", "isolated" },
                    { "usdt_futures", "swap" },
                    { "usdc_futures", "usdc_swap" },
                    { "coin_futures", "future" },
                    { "p2p", "p2p" },
                } },
                { "sandboxMode", false },
                { "networks", new Dictionary<string, object>() {
                    { "TRX", "TRC20" },
                    { "ETH", "ERC20" },
                    { "BSC", "BEP20" },
                } },
                { "networksById", new Dictionary<string, object>() {
                    { "TRC20", "TRX" },
                    { "BSC", "BEP20" },
                } },
                { "fetchPositions", new Dictionary<string, object>() {
                    { "method", "privateMixGetV2MixPositionAllPosition" },
                } },
                { "defaultTimeInForce", "GTC" },
            } },
        });
    }

    public override void setSandboxMode(object enabled)
    {
        ((IDictionary<string,object>)this.options)["sandboxMode"] = enabled;
    }

    public virtual object convertSymbolForSandbox(object symbol)
    {
        if (isTrue(((string)symbol).StartsWith(((string)"S"))))
        {
            // handle using the exchange specified sandbox symbols
            return symbol;
        }
        object convertedSymbol = null;
        if (isTrue(isGreaterThan(getIndexOf(symbol, "/"), -1)))
        {
            if (isTrue(isEqual(getIndexOf(symbol, ":"), -1)))
            {
                throw new NotSupported ((string)add(this.id, " sandbox supports swap and future markets only")) ;
            }
            object splitBase = ((string)symbol).Split(new [] {((string)"/")}, StringSplitOptions.None).ToList<object>();
            object previousBase = this.safeString(splitBase, 0);
            object previousQuoteSettleExpiry = this.safeString(splitBase, 1);
            object splitQuote = ((string)previousQuoteSettleExpiry).Split(new [] {((string)":")}, StringSplitOptions.None).ToList<object>();
            object previousQuote = this.safeString(splitQuote, 0);
            object previousSettleExpiry = this.safeString(splitQuote, 1);
            object splitSettle = ((string)previousSettleExpiry).Split(new [] {((string)"-")}, StringSplitOptions.None).ToList<object>();
            object previousSettle = this.safeString(splitSettle, 0);
            object expiry = this.safeString(splitSettle, 1);
            convertedSymbol = add(add(add(add(add("S", previousBase), "/S"), previousQuote), ":S"), previousSettle);
            if (isTrue(!isEqual(expiry, null)))
            {
                convertedSymbol = add(add(convertedSymbol, "-"), expiry);
            }
        } else
        {
            // handle using a market id instead of a unified symbol
            object bs = slice(symbol, 0, 3);
            object remaining = slice(symbol, 3, null);
            convertedSymbol = add(add(add("S", bs), "S"), remaining);
        }
        return convertedSymbol;
    }

    public virtual object handleProductTypeAndParams(object market = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object subType = null;
        var subTypeparametersVariable = this.handleSubTypeAndParams("handleProductTypeAndParams", null, parameters);
        subType = ((IList<object>)subTypeparametersVariable)[0];
        parameters = ((IList<object>)subTypeparametersVariable)[1];
        object defaultProductType = null;
        if (isTrue(isTrue((!isEqual(subType, null))) && isTrue((isEqual(market, null)))))
        {
            // set default only if subType is defined and market is not defined, since there is also USDC productTypes which are also linear
            object sandboxMode = this.safeBool(this.options, "sandboxMode", false);
            if (isTrue(sandboxMode))
            {
                defaultProductType = ((bool) isTrue((isEqual(subType, "linear")))) ? "SUSDT-FUTURES" : "SCOIN-FUTURES";
            } else
            {
                defaultProductType = ((bool) isTrue((isEqual(subType, "linear")))) ? "USDT-FUTURES" : "COIN-FUTURES";
            }
        }
        object productType = this.safeString(parameters, "productType", defaultProductType);
        if (isTrue(isTrue((isEqual(productType, null))) && isTrue((!isEqual(market, null)))))
        {
            object settle = getValue(market, "settle");
            if (isTrue(isEqual(settle, "USDT")))
            {
                productType = "USDT-FUTURES";
            } else if (isTrue(isEqual(settle, "USDC")))
            {
                productType = "USDC-FUTURES";
            } else if (isTrue(isEqual(settle, "SUSDT")))
            {
                productType = "SUSDT-FUTURES";
            } else if (isTrue(isEqual(settle, "SUSDC")))
            {
                productType = "SUSDC-FUTURES";
            } else if (isTrue(isTrue(isTrue((isEqual(settle, "SBTC"))) || isTrue((isEqual(settle, "SETH")))) || isTrue((isEqual(settle, "SEOS")))))
            {
                productType = "SCOIN-FUTURES";
            } else
            {
                productType = "COIN-FUTURES";
            }
        }
        if (isTrue(isEqual(productType, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " requires a productType param, one of \"USDT-FUTURES\", \"USDC-FUTURES\", \"COIN-FUTURES\", \"SUSDT-FUTURES\", \"SUSDC-FUTURES\" or \"SCOIN-FUTURES\"")) ;
        }
        parameters = this.omit(parameters, "productType");
        return new List<object>() {productType, parameters};
    }

    public async override Task<object> fetchTime(object parameters = null)
    {
        /**
        * @method
        * @name bitget#fetchTime
        * @description fetches the current integer timestamp in milliseconds from the exchange server
        * @see https://www.bitget.com/api-doc/common/public/Get-Server-Time
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {int} the current integer timestamp in milliseconds from the exchange server
        */
        parameters ??= new Dictionary<string, object>();
        object response = await this.publicCommonGetV2PublicTime(parameters);
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1700111073740,
        //         "data": {
        //             "serverTime": "1700111073740"
        //         }
        //     }
        //
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        return this.safeInteger(data, "serverTime");
    }

    public async override Task<object> fetchMarkets(object parameters = null)
    {
        /**
        * @method
        * @name bitget#fetchMarkets
        * @description retrieves data on all markets for bitget
        * @see https://www.bitget.com/api-doc/spot/market/Get-Symbols
        * @see https://www.bitget.com/api-doc/contract/market/Get-All-Symbols-Contracts
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} an array of objects representing market data
        */
        parameters ??= new Dictionary<string, object>();
        object sandboxMode = this.safeBool(this.options, "sandboxMode", false);
        object types = this.safeValue(this.options, "fetchMarkets", new List<object>() {"spot", "swap"});
        if (isTrue(sandboxMode))
        {
            types = new List<object>() {"swap"};
        }
        object promises = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(types)); postFixIncrement(ref i))
        {
            object type = getValue(types, i);
            if (isTrue(isEqual(type, "swap")))
            {
                object subTypes = null;
                if (isTrue(sandboxMode))
                {
                    // the following are simulated trading markets [ 'SUSDT-FUTURES', 'SCOIN-FUTURES', 'SUSDC-FUTURES' ];
                    subTypes = new List<object>() {"SUSDT-FUTURES", "SCOIN-FUTURES", "SUSDC-FUTURES"};
                } else
                {
                    subTypes = new List<object>() {"USDT-FUTURES", "COIN-FUTURES", "USDC-FUTURES"};
                }
                for (object j = 0; isLessThan(j, getArrayLength(subTypes)); postFixIncrement(ref j))
                {
                    ((IList<object>)promises).Add(this.fetchMarketsByType(type, this.extend(parameters, new Dictionary<string, object>() {
                        { "productType", getValue(subTypes, j) },
                    })));
                }
            } else
            {
                ((IList<object>)promises).Add(this.fetchMarketsByType(getValue(types, i), parameters));
            }
        }
        promises = await promiseAll(promises);
        object result = getValue(promises, 0);
        for (object i = 1; isLessThan(i, getArrayLength(promises)); postFixIncrement(ref i))
        {
            result = this.arrayConcat(result, getValue(promises, i));
        }
        return result;
    }

    public override object parseMarket(object market)
    {
        //
        // spot
        //
        //     {
        //         "symbol": "TRXUSDT",
        //         "baseCoin": "TRX",
        //         "quoteCoin": "USDT",
        //         "minTradeAmount": "0",
        //         "maxTradeAmount": "10000000000",
        //         "takerFeeRate": "0.002",
        //         "makerFeeRate": "0.002",
        //         "pricePrecision": "6",
        //         "quantityPrecision": "4",
        //         "quotePrecision": "6",
        //         "status": "online",
        //         "minTradeUSDT": "5",
        //         "buyLimitPriceRatio": "0.05",
        //         "sellLimitPriceRatio": "0.05"
        //     }
        //
        // swap and future
        //
        //     {
        //         "symbol": "BTCUSDT",
        //         "baseCoin": "BTC",
        //         "quoteCoin": "USDT",
        //         "buyLimitPriceRatio": "0.01",
        //         "sellLimitPriceRatio": "0.01",
        //         "feeRateUpRatio": "0.005",
        //         "makerFeeRate": "0.0002",
        //         "takerFeeRate": "0.0006",
        //         "openCostUpRatio": "0.01",
        //         "supportMarginCoins": ["USDT"],
        //         "minTradeNum": "0.001",
        //         "priceEndStep": "1",
        //         "volumePlace": "3",
        //         "pricePlace": "1",
        //         "sizeMultiplier": "0.001",
        //         "symbolType": "perpetual",
        //         "minTradeUSDT": "5",
        //         "maxSymbolOrderNum": "200",
        //         "maxProductOrderNum": "400",
        //         "maxPositionNum": "150",
        //         "symbolStatus": "normal",
        //         "offTime": "-1",
        //         "limitOpenTime": "-1",
        //         "deliveryTime": "",
        //         "deliveryStartTime": "",
        //         "deliveryPeriod": "",
        //         "launchTime": "",
        //         "fundInterval": "8",
        //         "minLever": "1",
        //         "maxLever": "125",
        //         "posLimit": "0.05",
        //         "maintainTime": ""
        //     }
        //
        object marketId = this.safeString(market, "symbol");
        object quoteId = this.safeString(market, "quoteCoin");
        object baseId = this.safeString(market, "baseCoin");
        object quote = this.safeCurrencyCode(quoteId);
        object bs = this.safeCurrencyCode(baseId);
        object supportMarginCoins = this.safeValue(market, "supportMarginCoins", new List<object>() {});
        object settleId = null;
        if (isTrue(this.inArray(baseId, supportMarginCoins)))
        {
            settleId = baseId;
        } else if (isTrue(this.inArray(quoteId, supportMarginCoins)))
        {
            settleId = quoteId;
        } else
        {
            settleId = this.safeString(supportMarginCoins, 0);
        }
        object settle = this.safeCurrencyCode(settleId);
        object symbol = add(add(bs, "/"), quote);
        object type = null;
        object swap = false;
        object spot = false;
        object future = false;
        object contract = false;
        object pricePrecision = null;
        object amountPrecision = null;
        object linear = null;
        object inverse = null;
        object expiry = null;
        object expiryDatetime = null;
        object symbolType = this.safeString(market, "symbolType");
        if (isTrue(isEqual(symbolType, null)))
        {
            type = "spot";
            spot = true;
            pricePrecision = this.parseNumber(this.parsePrecision(this.safeString(market, "pricePrecision")));
            amountPrecision = this.parseNumber(this.parsePrecision(this.safeString(market, "quantityPrecision")));
        } else
        {
            if (isTrue(isEqual(symbolType, "perpetual")))
            {
                type = "swap";
                swap = true;
                symbol = add(add(symbol, ":"), settle);
            } else if (isTrue(isEqual(symbolType, "delivery")))
            {
                expiry = this.safeInteger(market, "deliveryTime");
                expiryDatetime = this.iso8601(expiry);
                object expiryParts = ((string)expiryDatetime).Split(new [] {((string)"-")}, StringSplitOptions.None).ToList<object>();
                object yearPart = this.safeString(expiryParts, 0);
                object dayPart = this.safeString(expiryParts, 2);
                object year = slice(yearPart, 2, 4);
                object month = this.safeString(expiryParts, 1);
                object day = slice(dayPart, 0, 2);
                object expiryString = add(add(year, month), day);
                type = "future";
                future = true;
                symbol = add(add(add(add(symbol, ":"), settle), "-"), expiryString);
            }
            contract = true;
            inverse = (isEqual(bs, settle));
            linear = !isTrue(inverse);
            object priceDecimals = this.safeInteger(market, "pricePlace");
            object amountDecimals = this.safeInteger(market, "volumePlace");
            object priceStep = this.safeString(market, "priceEndStep");
            object amountStep = this.safeString(market, "minTradeNum");
            var precisePrice = new Precise(priceStep);
            precisePrice.decimals = mathMax(precisePrice.decimals, priceDecimals);
            precisePrice.reduce();
            object priceString = ((object)precisePrice).ToString();
            pricePrecision = this.parseNumber(priceString);
            var preciseAmount = new Precise(amountStep);
            preciseAmount.decimals = mathMax(preciseAmount.decimals, amountDecimals);
            preciseAmount.reduce();
            object amountString = ((object)preciseAmount).ToString();
            amountPrecision = this.parseNumber(amountString);
        }
        object status = this.safeString2(market, "status", "symbolStatus");
        object active = null;
        if (isTrue(!isEqual(status, null)))
        {
            active = (isTrue((isEqual(status, "online"))) || isTrue((isEqual(status, "normal"))));
        }
        object minCost = null;
        if (isTrue(isEqual(quote, "USDT")))
        {
            minCost = this.safeNumber(market, "minTradeUSDT");
        }
        object contractSize = ((bool) isTrue(contract)) ? 1 : null;
        return new Dictionary<string, object>() {
            { "id", marketId },
            { "symbol", symbol },
            { "base", bs },
            { "quote", quote },
            { "settle", settle },
            { "baseId", baseId },
            { "quoteId", quoteId },
            { "settleId", settleId },
            { "type", type },
            { "spot", spot },
            { "margin", null },
            { "swap", swap },
            { "future", future },
            { "option", false },
            { "active", active },
            { "contract", contract },
            { "linear", linear },
            { "inverse", inverse },
            { "taker", this.safeNumber(market, "takerFeeRate") },
            { "maker", this.safeNumber(market, "makerFeeRate") },
            { "contractSize", contractSize },
            { "expiry", expiry },
            { "expiryDatetime", expiryDatetime },
            { "strike", null },
            { "optionType", null },
            { "precision", new Dictionary<string, object>() {
                { "amount", amountPrecision },
                { "price", pricePrecision },
            } },
            { "limits", new Dictionary<string, object>() {
                { "leverage", new Dictionary<string, object>() {
                    { "min", this.safeNumber(market, "minLever") },
                    { "max", this.safeNumber(market, "maxLever") },
                } },
                { "amount", new Dictionary<string, object>() {
                    { "min", this.safeNumber2(market, "minTradeNum", "minTradeAmount") },
                    { "max", this.safeNumber(market, "maxTradeAmount") },
                } },
                { "price", new Dictionary<string, object>() {
                    { "min", null },
                    { "max", null },
                } },
                { "cost", new Dictionary<string, object>() {
                    { "min", minCost },
                    { "max", null },
                } },
            } },
            { "created", this.safeInteger(market, "launchTime") },
            { "info", market },
        };
    }

    public async virtual Task<object> fetchMarketsByType(object type, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object response = null;
        if (isTrue(isEqual(type, "spot")))
        {
            response = await this.publicSpotGetV2SpotPublicSymbols(parameters);
        } else if (isTrue(isTrue((isEqual(type, "swap"))) || isTrue((isEqual(type, "future")))))
        {
            response = await this.publicMixGetV2MixMarketContracts(parameters);
        } else
        {
            throw new NotSupported ((string)add(add(add(this.id, " does not support "), type), " market")) ;
        }
        //
        // spot
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1700102364653,
        //         "data": [
        //             {
        //                 "symbol": "TRXUSDT",
        //                 "baseCoin": "TRX",
        //                 "quoteCoin": "USDT",
        //                 "minTradeAmount": "0",
        //                 "maxTradeAmount": "10000000000",
        //                 "takerFeeRate": "0.002",
        //                 "makerFeeRate": "0.002",
        //                 "pricePrecision": "6",
        //                 "quantityPrecision": "4",
        //                 "quotePrecision": "6",
        //                 "status": "online",
        //                 "minTradeUSDT": "5",
        //                 "buyLimitPriceRatio": "0.05",
        //                 "sellLimitPriceRatio": "0.05"
        //             },
        //         ]
        //     }
        //
        // swap and future
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1700102364709,
        //         "data": [
        //             {
        //                 "symbol": "BTCUSDT",
        //                 "baseCoin": "BTC",
        //                 "quoteCoin": "USDT",
        //                 "buyLimitPriceRatio": "0.01",
        //                 "sellLimitPriceRatio": "0.01",
        //                 "feeRateUpRatio": "0.005",
        //                 "makerFeeRate": "0.0002",
        //                 "takerFeeRate": "0.0006",
        //                 "openCostUpRatio": "0.01",
        //                 "supportMarginCoins": ["USDT"],
        //                 "minTradeNum": "0.001",
        //                 "priceEndStep": "1",
        //                 "volumePlace": "3",
        //                 "pricePlace": "1",
        //                 "sizeMultiplier": "0.001",
        //                 "symbolType": "perpetual",
        //                 "minTradeUSDT": "5",
        //                 "maxSymbolOrderNum": "200",
        //                 "maxProductOrderNum": "400",
        //                 "maxPositionNum": "150",
        //                 "symbolStatus": "normal",
        //                 "offTime": "-1",
        //                 "limitOpenTime": "-1",
        //                 "deliveryTime": "",
        //                 "deliveryStartTime": "",
        //                 "deliveryPeriod": "",
        //                 "launchTime": "",
        //                 "fundInterval": "8",
        //                 "minLever": "1",
        //                 "maxLever": "125",
        //                 "posLimit": "0.05",
        //                 "maintainTime": ""
        //             },
        //         ]
        //     }
        //
        object data = this.safeValue(response, "data", new List<object>() {});
        return this.parseMarkets(data);
    }

    public async override Task<object> fetchCurrencies(object parameters = null)
    {
        /**
        * @method
        * @name bitget#fetchCurrencies
        * @description fetches all available currencies on an exchange
        * @see https://www.bitget.com/api-doc/spot/market/Get-Coin-List
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} an associative dictionary of currencies
        */
        parameters ??= new Dictionary<string, object>();
        object response = await this.publicSpotGetV2SpotPublicCoins(parameters);
        //
        //     {
        //         "code": "00000",
        //         "data": [
        //             {
        //                 "chains": [
        //                     {
        //                         "browserUrl": "https://blockchair.com/bitcoin/transaction/",
        //                         "chain": "BTC",
        //                         "depositConfirm": "1",
        //                         "extraWithdrawFee": "0",
        //                         "minDepositAmount": "0.0001",
        //                         "minWithdrawAmount": "0.005",
        //                         "needTag": "false",
        //                         "rechargeable": "true",
        //                         "withdrawConfirm": "1",
        //                         "withdrawFee": "0.0004",
        //                         "withdrawable": "true"
        //                     },
        //                 ],
        //                 "coin": "BTC",
        //                 "coinId": "1",
        //                 "transfer": "true""
        //             }
        //         ],
        //         "msg": "success",
        //         "requestTime": "1700120731773"
        //     }
        //
        object result = new Dictionary<string, object>() {};
        object data = this.safeValue(response, "data", new List<object>() {});
        for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
        {
            object entry = getValue(data, i);
            object id = this.safeString(entry, "coin"); // we don't use 'coinId' as it has no use. it is 'coin' field that needs to be used in currency related endpoints (deposit, withdraw, etc..)
            object code = this.safeCurrencyCode(id);
            object chains = this.safeValue(entry, "chains", new List<object>() {});
            object networks = new Dictionary<string, object>() {};
            object deposit = false;
            object withdraw = false;
            object minWithdrawString = null;
            object minDepositString = null;
            object minWithdrawFeeString = null;
            for (object j = 0; isLessThan(j, getArrayLength(chains)); postFixIncrement(ref j))
            {
                object chain = getValue(chains, j);
                object networkId = this.safeString(chain, "chain");
                object network = this.safeCurrencyCode(networkId);
                object withdrawEnabled = this.safeString(chain, "withdrawable");
                object canWithdraw = isEqual(withdrawEnabled, "true");
                withdraw = ((bool) isTrue((canWithdraw))) ? canWithdraw : withdraw;
                object depositEnabled = this.safeString(chain, "rechargeable");
                object canDeposit = isEqual(depositEnabled, "true");
                deposit = ((bool) isTrue((canDeposit))) ? canDeposit : deposit;
                object networkWithdrawFeeString = this.safeString(chain, "withdrawFee");
                if (isTrue(!isEqual(networkWithdrawFeeString, null)))
                {
                    minWithdrawFeeString = ((bool) isTrue((isEqual(minWithdrawFeeString, null)))) ? networkWithdrawFeeString : Precise.stringMin(networkWithdrawFeeString, minWithdrawFeeString);
                }
                object networkMinWithdrawString = this.safeString(chain, "minWithdrawAmount");
                if (isTrue(!isEqual(networkMinWithdrawString, null)))
                {
                    minWithdrawString = ((bool) isTrue((isEqual(minWithdrawString, null)))) ? networkMinWithdrawString : Precise.stringMin(networkMinWithdrawString, minWithdrawString);
                }
                object networkMinDepositString = this.safeString(chain, "minDepositAmount");
                if (isTrue(!isEqual(networkMinDepositString, null)))
                {
                    minDepositString = ((bool) isTrue((isEqual(minDepositString, null)))) ? networkMinDepositString : Precise.stringMin(networkMinDepositString, minDepositString);
                }
                ((IDictionary<string,object>)networks)[(string)network] = new Dictionary<string, object>() {
                    { "info", chain },
                    { "id", networkId },
                    { "network", network },
                    { "limits", new Dictionary<string, object>() {
                        { "withdraw", new Dictionary<string, object>() {
                            { "min", this.parseNumber(networkMinWithdrawString) },
                            { "max", null },
                        } },
                        { "deposit", new Dictionary<string, object>() {
                            { "min", this.parseNumber(networkMinDepositString) },
                            { "max", null },
                        } },
                    } },
                    { "active", isTrue(canWithdraw) && isTrue(canDeposit) },
                    { "withdraw", canWithdraw },
                    { "deposit", canDeposit },
                    { "fee", this.parseNumber(networkWithdrawFeeString) },
                    { "precision", null },
                };
            }
            ((IDictionary<string,object>)result)[(string)code] = new Dictionary<string, object>() {
                { "info", entry },
                { "id", id },
                { "code", code },
                { "networks", networks },
                { "type", null },
                { "name", null },
                { "active", isTrue(deposit) && isTrue(withdraw) },
                { "deposit", deposit },
                { "withdraw", withdraw },
                { "fee", this.parseNumber(minWithdrawFeeString) },
                { "precision", null },
                { "limits", new Dictionary<string, object>() {
                    { "amount", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                    { "withdraw", new Dictionary<string, object>() {
                        { "min", this.parseNumber(minWithdrawString) },
                        { "max", null },
                    } },
                    { "deposit", new Dictionary<string, object>() {
                        { "min", this.parseNumber(minDepositString) },
                        { "max", null },
                    } },
                } },
                { "created", null },
            };
        }
        return result;
    }

    public async override Task<object> fetchMarketLeverageTiers(object symbol, object parameters = null)
    {
        /**
        * @method
        * @name bitget#fetchMarketLeverageTiers
        * @description retrieve information on the maximum leverage, and maintenance margin for trades of varying trade sizes for a single market
        * @see https://www.bitget.com/api-doc/contract/position/Get-Query-Position-Lever
        * @see https://www.bitget.com/api-doc/margin/cross/account/Cross-Tier-Data
        * @see https://www.bitget.com/api-doc/margin/isolated/account/Isolated-Tier-Data
        * @param {string} symbol unified market symbol
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {string} [params.marginMode] for spot margin 'cross' or 'isolated', default is 'isolated'
        * @param {string} [params.code] required for cross spot margin
        * @param {string} [params.productType] *contract only* 'USDT-FUTURES', 'USDC-FUTURES', 'COIN-FUTURES', 'SUSDT-FUTURES', 'SUSDC-FUTURES' or 'SCOIN-FUTURES'
        * @returns {object} a [leverage tiers structure]{@link https://docs.ccxt.com/#/?id=leverage-tiers-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object sandboxMode = this.safeBool(this.options, "sandboxMode", false);
        object market = null;
        if (isTrue(sandboxMode))
        {
            object sandboxSymbol = this.convertSymbolForSandbox(symbol);
            market = this.market(sandboxSymbol);
        } else
        {
            market = this.market(symbol);
        }
        object request = new Dictionary<string, object>() {};
        object response = null;
        object marginMode = null;
        var marginModeparametersVariable = this.handleMarginModeAndParams("fetchMarketLeverageTiers", parameters, "isolated");
        marginMode = ((IList<object>)marginModeparametersVariable)[0];
        parameters = ((IList<object>)marginModeparametersVariable)[1];
        if (isTrue(isTrue((getValue(market, "swap"))) || isTrue((getValue(market, "future")))))
        {
            object productType = null;
            var productTypeparametersVariable = this.handleProductTypeAndParams(market, parameters);
            productType = ((IList<object>)productTypeparametersVariable)[0];
            parameters = ((IList<object>)productTypeparametersVariable)[1];
            ((IDictionary<string,object>)request)["productType"] = productType;
            ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
            response = await this.publicMixGetV2MixMarketQueryPositionLever(this.extend(request, parameters));
        } else if (isTrue(isEqual(marginMode, "isolated")))
        {
            ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
            response = await this.privateMarginGetV2MarginIsolatedTierData(this.extend(request, parameters));
        } else if (isTrue(isEqual(marginMode, "cross")))
        {
            object code = this.safeString(parameters, "code");
            if (isTrue(isEqual(code, null)))
            {
                throw new ArgumentsRequired ((string)add(this.id, " fetchMarketLeverageTiers() requires a code argument")) ;
            }
            parameters = this.omit(parameters, "code");
            object currency = this.currency(code);
            ((IDictionary<string,object>)request)["coin"] = getValue(currency, "id");
            response = await this.privateMarginGetV2MarginCrossedTierData(this.extend(request, parameters));
        } else
        {
            throw new BadRequest ((string)add(add(this.id, " fetchMarketLeverageTiers() symbol does not support market "), getValue(market, "symbol"))) ;
        }
        //
        // swap and future
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1700290724614,
        //         "data": [
        //             {
        //                 "symbol": "BTCUSDT",
        //                 "level": "1",
        //                 "startUnit": "0",
        //                 "endUnit": "150000",
        //                 "leverage": "125",
        //                 "keepMarginRate": "0.004"
        //             },
        //         ]
        //     }
        //
        // isolated
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1700291531894,
        //         "data": [
        //             {
        //                 "tier": "1",
        //                 "symbol": "BTCUSDT",
        //                 "leverage": "10",
        //                 "baseCoin": "BTC",
        //                 "quoteCoin": "USDT",
        //                 "baseMaxBorrowableAmount": "2",
        //                 "quoteMaxBorrowableAmount": "24000",
        //                 "maintainMarginRate": "0.05",
        //                 "initRate": "0.1111"
        //             },
        //         ]
        //     }
        //
        // cross
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1700291818831,
        //         "data": [
        //             {
        //                 "tier": "1",
        //                 "leverage": "3",
        //                 "coin": "BTC",
        //                 "maxBorrowableAmount": "26",
        //                 "maintainMarginRate": "0.1"
        //             }
        //         ]
        //     }
        //
        object result = this.safeValue(response, "data", new List<object>() {});
        return this.parseMarketLeverageTiers(result, market);
    }

    public override object parseMarketLeverageTiers(object info, object market = null)
    {
        //
        // swap and future
        //
        //     {
        //         "symbol": "BTCUSDT",
        //         "level": "1",
        //         "startUnit": "0",
        //         "endUnit": "150000",
        //         "leverage": "125",
        //         "keepMarginRate": "0.004"
        //     }
        //
        // isolated
        //
        //     {
        //         "tier": "1",
        //         "symbol": "BTCUSDT",
        //         "leverage": "10",
        //         "baseCoin": "BTC",
        //         "quoteCoin": "USDT",
        //         "baseMaxBorrowableAmount": "2",
        //         "quoteMaxBorrowableAmount": "24000",
        //         "maintainMarginRate": "0.05",
        //         "initRate": "0.1111"
        //     }
        //
        // cross
        //
        //     {
        //         "tier": "1",
        //         "leverage": "3",
        //         "coin": "BTC",
        //         "maxBorrowableAmount": "26",
        //         "maintainMarginRate": "0.1"
        //     }
        //
        object tiers = new List<object>() {};
        object minNotional = 0;
        for (object i = 0; isLessThan(i, getArrayLength(info)); postFixIncrement(ref i))
        {
            object item = getValue(info, i);
            object minimumNotional = this.safeNumber(item, "startUnit");
            if (isTrue(!isEqual(minimumNotional, null)))
            {
                minNotional = minimumNotional;
            }
            object maxNotional = this.safeNumberN(item, new List<object>() {"endUnit", "maxBorrowableAmount", "baseMaxBorrowableAmount"});
            object marginCurrency = this.safeString2(item, "coin", "baseCoin");
            object currencyId = ((bool) isTrue((!isEqual(marginCurrency, null)))) ? marginCurrency : getValue(market, "base");
            ((IList<object>)tiers).Add(new Dictionary<string, object>() {
                { "tier", this.safeInteger2(item, "level", "tier") },
                { "currency", this.safeCurrencyCode(currencyId) },
                { "minNotional", minNotional },
                { "maxNotional", maxNotional },
                { "maintenanceMarginRate", this.safeNumber2(item, "keepMarginRate", "maintainMarginRate") },
                { "maxLeverage", this.safeNumber(item, "leverage") },
                { "info", item },
            });
            minNotional = maxNotional;
        }
        return tiers;
    }

    public async override Task<object> fetchDeposits(object code = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bitget#fetchDeposits
        * @description fetch all deposits made to an account
        * @see https://www.bitget.com/api-doc/spot/account/Get-Deposit-Record
        * @param {string} code unified currency code
        * @param {int} [since] the earliest time in ms to fetch deposits for
        * @param {int} [limit] the maximum number of deposits structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {int} [params.until] end time in milliseconds
        * @param {string} [params.idLessThan] return records with id less than the provided value
        * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [available parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
        * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object paginate = false;
        var paginateparametersVariable = this.handleOptionAndParams(parameters, "fetchDeposits", "paginate");
        paginate = ((IList<object>)paginateparametersVariable)[0];
        parameters = ((IList<object>)paginateparametersVariable)[1];
        if (isTrue(paginate))
        {
            return await this.fetchPaginatedCallCursor("fetchDeposits", null, since, limit, parameters, "idLessThan", "idLessThan", null, 100);
        }
        if (isTrue(isEqual(code, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchDeposits() requires a `code` argument")) ;
        }
        object currency = this.currency(code);
        if (isTrue(isEqual(since, null)))
        {
            since = subtract(this.milliseconds(), 7776000000); // 90 days
        }
        object request = new Dictionary<string, object>() {
            { "coin", getValue(currency, "id") },
            { "startTime", since },
            { "endTime", this.milliseconds() },
        };
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        var requestparametersVariable = this.handleUntilOption("endTime", request, parameters);
        request = ((IList<object>)requestparametersVariable)[0];
        parameters = ((IList<object>)requestparametersVariable)[1];
        object response = await this.privateSpotGetV2SpotWalletDepositRecords(this.extend(request, parameters));
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1700528340608,
        //         "data": [
        //             {
        //                 "orderId": "1083832260799930368",
        //                 "tradeId": "35bf0e588a42b25c71a9d45abe7308cabdeec6b7b423910b9bd4743d3a9a9efa",
        //                 "coin": "BTC",
        //                 "type": "deposit",
        //                 "size": "0.00030000",
        //                 "status": "success",
        //                 "toAddress": "1BfZh7JESJGBUszCGeZnzxbVVvBycbJSbA",
        //                 "dest": "on_chain",
        //                 "chain": "BTC",
        //                 "fromAddress": null,
        //                 "cTime": "1694131668281",
        //                 "uTime": "1694131680247"
        //             }
        //         ]
        //     }
        //
        object rawTransactions = this.safeList(response, "data", new List<object>() {});
        return this.parseTransactions(rawTransactions, currency, since, limit);
    }

    public async override Task<object> withdraw(object code, object amount, object address, object tag = null, object parameters = null)
    {
        /**
        * @method
        * @name bitget#withdraw
        * @description make a withdrawal
        * @see https://www.bitget.com/api-doc/spot/account/Wallet-Withdrawal
        * @param {string} code unified currency code
        * @param {float} amount the amount to withdraw
        * @param {string} address the address to withdraw to
        * @param {string} tag
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {string} [params.chain] the blockchain network the withdrawal is taking place on
        * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
        */
        parameters ??= new Dictionary<string, object>();
        this.checkAddress(address);
        object chain = this.safeString2(parameters, "chain", "network");
        parameters = this.omit(parameters, "network");
        if (isTrue(isEqual(chain, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " withdraw() requires a chain parameter or a network parameter")) ;
        }
        await this.loadMarkets();
        object currency = this.currency(code);
        object networkId = this.networkCodeToId(chain);
        object request = new Dictionary<string, object>() {
            { "coin", getValue(currency, "id") },
            { "address", address },
            { "chain", networkId },
            { "size", amount },
            { "transferType", "on_chain" },
        };
        if (isTrue(!isEqual(tag, null)))
        {
            ((IDictionary<string,object>)request)["tag"] = tag;
        }
        object response = await this.privateSpotPostV2SpotWalletWithdrawal(this.extend(request, parameters));
        //
        //     {
        //          "code":"00000",
        //          "msg":"success",
        //          "requestTime":1696784219602,
        //          "data": {
        //              "orderId":"1094957867615789056",
        //              "clientOid":"64f1e4ce842041d296b4517df1b5c2d7"
        //          }
        //      }
        //
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        object result = new Dictionary<string, object>() {
            { "id", this.safeString(data, "orderId") },
            { "info", response },
            { "txid", null },
            { "timestamp", null },
            { "datetime", null },
            { "network", null },
            { "addressFrom", null },
            { "address", null },
            { "addressTo", null },
            { "amount", null },
            { "type", "withdrawal" },
            { "currency", null },
            { "status", null },
            { "updated", null },
            { "tagFrom", null },
            { "tag", null },
            { "tagTo", null },
            { "comment", null },
            { "fee", null },
        };
        object withdrawOptions = this.safeValue(this.options, "withdraw", new Dictionary<string, object>() {});
        object fillResponseFromRequest = this.safeBool(withdrawOptions, "fillResponseFromRequest", true);
        if (isTrue(fillResponseFromRequest))
        {
            ((IDictionary<string,object>)result)["currency"] = code;
            ((IDictionary<string,object>)result)["timestamp"] = this.milliseconds();
            ((IDictionary<string,object>)result)["datetime"] = this.iso8601(this.milliseconds());
            ((IDictionary<string,object>)result)["amount"] = amount;
            ((IDictionary<string,object>)result)["tag"] = tag;
            ((IDictionary<string,object>)result)["address"] = address;
            ((IDictionary<string,object>)result)["addressTo"] = address;
            ((IDictionary<string,object>)result)["network"] = chain;
        }
        return result;
    }

    public async override Task<object> fetchWithdrawals(object code = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bitget#fetchWithdrawals
        * @description fetch all withdrawals made from an account
        * @see https://www.bitget.com/api-doc/spot/account/Get-Withdraw-Record
        * @param {string} code unified currency code
        * @param {int} [since] the earliest time in ms to fetch withdrawals for
        * @param {int} [limit] the maximum number of withdrawals structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {int} [params.until] end time in milliseconds
        * @param {string} [params.idLessThan] return records with id less than the provided value
        * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [available parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
        * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object paginate = false;
        var paginateparametersVariable = this.handleOptionAndParams(parameters, "fetchWithdrawals", "paginate");
        paginate = ((IList<object>)paginateparametersVariable)[0];
        parameters = ((IList<object>)paginateparametersVariable)[1];
        if (isTrue(paginate))
        {
            return await this.fetchPaginatedCallCursor("fetchWithdrawals", null, since, limit, parameters, "idLessThan", "idLessThan", null, 100);
        }
        if (isTrue(isEqual(code, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchWithdrawals() requires a `code` argument")) ;
        }
        object currency = this.currency(code);
        if (isTrue(isEqual(since, null)))
        {
            since = subtract(this.milliseconds(), 7776000000); // 90 days
        }
        object request = new Dictionary<string, object>() {
            { "coin", getValue(currency, "id") },
            { "startTime", since },
            { "endTime", this.milliseconds() },
        };
        var requestparametersVariable = this.handleUntilOption("endTime", request, parameters);
        request = ((IList<object>)requestparametersVariable)[0];
        parameters = ((IList<object>)requestparametersVariable)[1];
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        object response = await this.privateSpotGetV2SpotWalletWithdrawalRecords(this.extend(request, parameters));
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1700528340608,
        //         "data": [
        //             {
        //                 "orderId": "1083832260799930368",
        //                 "tradeId": "35bf0e588a42b25c71a9d45abe7308cabdeec6b7b423910b9bd4743d3a9a9efa",
        //                 "clientOid": "123",
        //                 "coin": "BTC",
        //                 "type": "withdraw",
        //                 "size": "0.00030000",
        //                 "fee": "-1.0000000",
        //                 "status": "success",
        //                 "toAddress": "1BfZh7JESJGBUszCGeZnzxbVVvBycbJSbA",
        //                 "dest": "on_chain",
        //                 "chain": "BTC",
        //                 "confirm": "100",
        //                 "fromAddress": null,
        //                 "cTime": "1694131668281",
        //                 "uTime": "1694131680247"
        //             }
        //         ]
        //     }
        //
        object rawTransactions = this.safeList(response, "data", new List<object>() {});
        return this.parseTransactions(rawTransactions, currency, since, limit);
    }

    public override object parseTransaction(object transaction, object currency = null)
    {
        //
        // fetchDeposits
        //
        //     {
        //         "orderId": "1083832260799930368",
        //         "tradeId": "35bf0e588a42b25c71a9d45abe7308cabdeec6b7b423910b9bd4743d3a9a9efa",
        //         "coin": "BTC",
        //         "type": "deposit",
        //         "size": "0.00030000",
        //         "status": "success",
        //         "toAddress": "1BfZh7JESJGBUszCGeZnzxbVVvBycbJSbA",
        //         "dest": "on_chain",
        //         "chain": "BTC",
        //         "fromAddress": null,
        //         "cTime": "1694131668281",
        //         "uTime": "1694131680247"
        //     }
        //
        // fetchWithdrawals
        //
        //     {
        //         "orderId": "1083832260799930368",
        //         "tradeId": "35bf0e588a42b25c71a9d45abe7308cabdeec6b7b423910b9bd4743d3a9a9efa",
        //         "clientOid": "123",
        //         "coin": "BTC",
        //         "type": "withdraw",
        //         "size": "0.00030000",
        //         "fee": "-1.0000000",
        //         "status": "success",
        //         "toAddress": "1BfZh7JESJGBUszCGeZnzxbVVvBycbJSbA",
        //         "dest": "on_chain",
        //         "chain": "BTC",
        //         "confirm": "100",
        //         "fromAddress": null,
        //         "cTime": "1694131668281",
        //         "uTime": "1694131680247"
        //     }
        //
        object currencyId = this.safeString(transaction, "coin");
        object code = this.safeCurrencyCode(currencyId, currency);
        object timestamp = this.safeInteger(transaction, "cTime");
        object networkId = this.safeString(transaction, "chain");
        object status = this.safeString(transaction, "status");
        object tag = this.safeString(transaction, "tag");
        object feeCostString = this.safeString(transaction, "fee");
        object feeCostAbsString = Precise.stringAbs(feeCostString);
        object fee = null;
        object amountString = this.safeString(transaction, "size");
        if (isTrue(!isEqual(feeCostAbsString, null)))
        {
            fee = new Dictionary<string, object>() {
                { "currency", code },
                { "cost", this.parseNumber(feeCostAbsString) },
            };
            amountString = Precise.stringSub(amountString, feeCostAbsString);
        }
        return new Dictionary<string, object>() {
            { "id", this.safeString(transaction, "orderId") },
            { "info", transaction },
            { "txid", this.safeString(transaction, "tradeId") },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "network", this.networkIdToCode(networkId) },
            { "addressFrom", this.safeString(transaction, "fromAddress") },
            { "address", this.safeString(transaction, "toAddress") },
            { "addressTo", this.safeString(transaction, "toAddress") },
            { "amount", this.parseNumber(amountString) },
            { "type", this.safeString(transaction, "type") },
            { "currency", code },
            { "status", this.parseTransactionStatus(status) },
            { "updated", this.safeInteger(transaction, "uTime") },
            { "tagFrom", null },
            { "tag", tag },
            { "tagTo", tag },
            { "comment", null },
            { "internal", null },
            { "fee", fee },
        };
    }

    public virtual object parseTransactionStatus(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "success", "ok" },
            { "Pending", "pending" },
            { "pending_review", "pending" },
            { "pending_review_fail", "failed" },
            { "reject", "failed" },
        };
        return this.safeString(statuses, status, status);
    }

    public async override Task<object> fetchDepositAddress(object code, object parameters = null)
    {
        /**
        * @method
        * @name bitget#fetchDepositAddress
        * @description fetch the deposit address for a currency associated with this account
        * @see https://www.bitget.com/api-doc/spot/account/Get-Deposit-Address
        * @param {string} code unified currency code
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} an [address structure]{@link https://docs.ccxt.com/#/?id=address-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object networkCode = this.safeString2(parameters, "chain", "network");
        parameters = this.omit(parameters, "network");
        object networkId = null;
        if (isTrue(!isEqual(networkCode, null)))
        {
            networkId = this.networkCodeToId(networkCode, code);
        }
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "coin", getValue(currency, "id") },
        };
        if (isTrue(!isEqual(networkId, null)))
        {
            ((IDictionary<string,object>)request)["chain"] = networkId;
        }
        object response = await this.privateSpotGetV2SpotWalletDepositAddress(this.extend(request, parameters));
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1700532244807,
        //         "data": {
        //             "coin": "BTC",
        //             "address": "1BfZh7JESJGBUszCGeZnzxbVVvBycbJSbA",
        //             "chain": "",
        //             "tag": null,
        //             "url": "https://blockchair.com/bitcoin/transaction/"
        //         }
        //     }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        return this.parseDepositAddress(data, currency);
    }

    public override object parseDepositAddress(object depositAddress, object currency = null)
    {
        //
        //     {
        //         "coin": "BTC",
        //         "address": "1BfZh7JESJGBUszCGeZnzxbVVvBycbJSbA",
        //         "chain": "",
        //         "tag": null,
        //         "url": "https://blockchair.com/bitcoin/transaction/"
        //     }
        //
        object currencyId = this.safeString(depositAddress, "coin");
        object networkId = this.safeString(depositAddress, "chain");
        object parsedCurrency = this.safeCurrencyCode(currencyId, currency);
        object network = null;
        if (isTrue(!isEqual(networkId, null)))
        {
            network = this.networkIdToCode(networkId, parsedCurrency);
        }
        return new Dictionary<string, object>() {
            { "currency", parsedCurrency },
            { "address", this.safeString(depositAddress, "address") },
            { "tag", this.safeString(depositAddress, "tag") },
            { "network", network },
            { "info", depositAddress },
        };
    }

    public async override Task<object> fetchOrderBook(object symbol, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bitget#fetchOrderBook
        * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
        * @see https://www.bitget.com/api-doc/spot/market/Get-Orderbook
        * @see https://www.bitget.com/api-doc/contract/market/Get-Merge-Depth
        * @param {string} symbol unified symbol of the market to fetch the order book for
        * @param {int} [limit] the maximum amount of order book entries to return
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object sandboxMode = this.safeBool(this.options, "sandboxMode", false);
        object market = null;
        if (isTrue(sandboxMode))
        {
            object sandboxSymbol = this.convertSymbolForSandbox(symbol);
            market = this.market(sandboxSymbol);
        } else
        {
            market = this.market(symbol);
        }
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        object response = null;
        if (isTrue(getValue(market, "spot")))
        {
            response = await this.publicSpotGetV2SpotMarketOrderbook(this.extend(request, parameters));
        } else
        {
            object productType = null;
            var productTypeparametersVariable = this.handleProductTypeAndParams(market, parameters);
            productType = ((IList<object>)productTypeparametersVariable)[0];
            parameters = ((IList<object>)productTypeparametersVariable)[1];
            ((IDictionary<string,object>)request)["productType"] = productType;
            response = await this.publicMixGetV2MixMarketMergeDepth(this.extend(request, parameters));
        }
        //
        //     {
        //       "code": "00000",
        //       "msg": "success",
        //       "requestTime": 1645854610294,
        //       "data": {
        //         "asks": [ [ "39102", "11.026" ] ],
        //         "bids": [ [ '39100.5', "1.773" ] ],
        //         "ts": "1645854610294"
        //       }
        //     }
        //
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        object timestamp = this.safeInteger(data, "ts");
        return this.parseOrderBook(data, getValue(market, "symbol"), timestamp);
    }

    public override object parseTicker(object ticker, object market = null)
    {
        //
        // spot: fetchTicker, fetchTickers
        //
        //     {
        //         "open": "37202.46",
        //         "symbol": "BTCUSDT",
        //         "high24h": "37744.75",
        //         "low24h": "36666",
        //         "lastPr": "37583.69",
        //         "quoteVolume": "519127705.303",
        //         "baseVolume": "13907.0386",
        //         "usdtVolume": "519127705.302908",
        //         "ts": "1700532903261",
        //         "bidPr": "37583.68",
        //         "askPr": "37583.69",
        //         "bidSz": "0.0007",
        //         "askSz": "0.0829",
        //         "openUtc": "37449.4",
        //         "changeUtc24h": "0.00359",
        //         "change24h": "0.00321"
        //     }
        //
        // swap and future: fetchTicker
        //
        //     {
        //         "symbol": "BTCUSDT",
        //         "lastPr": "37577.2",
        //         "askPr": "37577.3",
        //         "bidPr": "37577.2",
        //         "bidSz": "3.679",
        //         "askSz": "0.02",
        //         "high24h": "37765",
        //         "low24h": "36628.9",
        //         "ts": "1700533070359",
        //         "change24h": "0.00288",
        //         "baseVolume": "108606.181",
        //         "quoteVolume": "4051316303.9608",
        //         "usdtVolume": "4051316303.9608",
        //         "openUtc": "37451.5",
        //         "changeUtc24h": "0.00336",
        //         "indexPrice": "37574.489253",
        //         "fundingRate": "0.0001",
        //         "holdingAmount": "53464.529",
        //         "deliveryStartTime": null,
        //         "deliveryTime": null,
        //         "deliveryStatus": "",
        //         "open24h": "37235.7"
        //     }
        //
        // swap and future: fetchTickers
        //
        //     {
        //         "open": "14.9776",
        //         "symbol": "LINKUSDT",
        //         "high24h": "15.3942",
        //         "low24h": "14.3457",
        //         "lastPr": "14.3748",
        //         "quoteVolume": "7008612.4299",
        //         "baseVolume": "469908.8523",
        //         "usdtVolume": "7008612.42986561",
        //         "ts": "1700533772309",
        //         "bidPr": "14.375",
        //         "askPr": "14.3769",
        //         "bidSz": "50.004",
        //         "askSz": "0.7647",
        //         "openUtc": "14.478",
        //         "changeUtc24h": "-0.00713",
        //         "change24h": "-0.04978"
        //     }
        //
        object marketId = this.safeString(ticker, "symbol");
        object close = this.safeString(ticker, "lastPr");
        object timestampString = this.omitZero(this.safeString(ticker, "ts")); // exchange sometimes provided 0
        object timestamp = null;
        if (isTrue(!isEqual(timestampString, null)))
        {
            timestamp = this.parseToInt(timestampString);
        }
        object change = this.safeString(ticker, "change24h");
        object open24 = this.safeString(ticker, "open24");
        object open = this.safeString(ticker, "open");
        object symbol = null;
        object openValue = null;
        if (isTrue(isEqual(open, null)))
        {
            symbol = this.safeSymbol(marketId, market, null, "contract");
            openValue = open24;
        } else
        {
            symbol = this.safeSymbol(marketId, market, null, "spot");
            openValue = open;
        }
        return this.safeTicker(new Dictionary<string, object>() {
            { "symbol", symbol },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "high", this.safeString(ticker, "high24h") },
            { "low", this.safeString(ticker, "low24h") },
            { "bid", this.safeString(ticker, "bidPr") },
            { "bidVolume", this.safeString(ticker, "bidSz") },
            { "ask", this.safeString(ticker, "askPr") },
            { "askVolume", this.safeString(ticker, "askSz") },
            { "vwap", null },
            { "open", openValue },
            { "close", close },
            { "last", close },
            { "previousClose", null },
            { "change", change },
            { "percentage", Precise.stringMul(change, "100") },
            { "average", null },
            { "baseVolume", this.safeString(ticker, "baseVolume") },
            { "quoteVolume", this.safeString(ticker, "quoteVolume") },
            { "info", ticker },
        }, market);
    }

    public async override Task<object> fetchTicker(object symbol, object parameters = null)
    {
        /**
        * @method
        * @name bitget#fetchTicker
        * @description fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
        * @see https://www.bitget.com/api-doc/spot/market/Get-Tickers
        * @see https://www.bitget.com/api-doc/contract/market/Get-Ticker
        * @param {string} symbol unified symbol of the market to fetch the ticker for
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object sandboxMode = this.safeBool(this.options, "sandboxMode", false);
        object market = null;
        if (isTrue(sandboxMode))
        {
            object sandboxSymbol = this.convertSymbolForSandbox(symbol);
            market = this.market(sandboxSymbol);
        } else
        {
            market = this.market(symbol);
        }
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object response = null;
        if (isTrue(getValue(market, "spot")))
        {
            response = await this.publicSpotGetV2SpotMarketTickers(this.extend(request, parameters));
        } else
        {
            object productType = null;
            var productTypeparametersVariable = this.handleProductTypeAndParams(market, parameters);
            productType = ((IList<object>)productTypeparametersVariable)[0];
            parameters = ((IList<object>)productTypeparametersVariable)[1];
            ((IDictionary<string,object>)request)["productType"] = productType;
            response = await this.publicMixGetV2MixMarketTicker(this.extend(request, parameters));
        }
        //
        // spot
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1700532903782,
        //         "data": [
        //             {
        //                 "open": "37202.46",
        //                 "symbol": "BTCUSDT",
        //                 "high24h": "37744.75",
        //                 "low24h": "36666",
        //                 "lastPr": "37583.69",
        //                 "quoteVolume": "519127705.303",
        //                 "baseVolume": "13907.0386",
        //                 "usdtVolume": "519127705.302908",
        //                 "ts": "1700532903261",
        //                 "bidPr": "37583.68",
        //                 "askPr": "37583.69",
        //                 "bidSz": "0.0007",
        //                 "askSz": "0.0829",
        //                 "openUtc": "37449.4",
        //                 "changeUtc24h": "0.00359",
        //                 "change24h": "0.00321"
        //             }
        //         ]
        //     }
        //
        // swap and future
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1700533070357,
        //         "data": [
        //             {
        //                 "symbol": "BTCUSDT",
        //                 "lastPr": "37577.2",
        //                 "askPr": "37577.3",
        //                 "bidPr": "37577.2",
        //                 "bidSz": "3.679",
        //                 "askSz": "0.02",
        //                 "high24h": "37765",
        //                 "low24h": "36628.9",
        //                 "ts": "1700533070359",
        //                 "change24h": "0.00288",
        //                 "baseVolume": "108606.181",
        //                 "quoteVolume": "4051316303.9608",
        //                 "usdtVolume": "4051316303.9608",
        //                 "openUtc": "37451.5",
        //                 "changeUtc24h": "0.00336",
        //                 "indexPrice": "37574.489253",
        //                 "fundingRate": "0.0001",
        //                 "holdingAmount": "53464.529",
        //                 "deliveryStartTime": null,
        //                 "deliveryTime": null,
        //                 "deliveryStatus": "",
        //                 "open24h": "37235.7"
        //             }
        //         ]
        //     }
        //
        object data = this.safeList(response, "data", new List<object>() {});
        return this.parseTicker(getValue(data, 0), market);
    }

    public async override Task<object> fetchTickers(object symbols = null, object parameters = null)
    {
        /**
        * @method
        * @name bitget#fetchTickers
        * @description fetches price tickers for multiple markets, statistical information calculated over the past 24 hours for each market
        * @see https://www.bitget.com/api-doc/spot/market/Get-Tickers
        * @see https://www.bitget.com/api-doc/contract/market/Get-All-Symbol-Ticker
        * @param {string[]|undefined} symbols unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {string} [params.subType] *contract only* 'linear', 'inverse'
        * @param {string} [params.productType] *contract only* 'USDT-FUTURES', 'USDC-FUTURES', 'COIN-FUTURES', 'SUSDT-FUTURES', 'SUSDC-FUTURES' or 'SCOIN-FUTURES'
        * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/#/?id=ticker-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = null;
        if (isTrue(!isEqual(symbols, null)))
        {
            object symbol = this.safeValue(symbols, 0);
            object sandboxMode = this.safeBool(this.options, "sandboxMode", false);
            if (isTrue(sandboxMode))
            {
                object sandboxSymbol = this.convertSymbolForSandbox(symbol);
                market = this.market(sandboxSymbol);
            } else
            {
                market = this.market(symbol);
            }
        }
        object response = null;
        object request = new Dictionary<string, object>() {};
        object type = null;
        var typeparametersVariable = this.handleMarketTypeAndParams("fetchTickers", market, parameters);
        type = ((IList<object>)typeparametersVariable)[0];
        parameters = ((IList<object>)typeparametersVariable)[1];
        // Calls like `.fetchTickers (undefined, {subType:'inverse'})` should be supported for this exchange, so
        // as "options.defaultSubType" is also set in exchange options, we should consider `params.subType`
        // with higher priority and only default to spot, if `subType` is not set in params
        object passedSubType = this.safeString(parameters, "subType");
        object productType = null;
        var productTypeparametersVariable = this.handleProductTypeAndParams(market, parameters);
        productType = ((IList<object>)productTypeparametersVariable)[0];
        parameters = ((IList<object>)productTypeparametersVariable)[1];
        // only if passedSubType && productType is undefined, then use spot
        if (isTrue(isTrue(isEqual(type, "spot")) && isTrue(isEqual(passedSubType, null))))
        {
            response = await this.publicSpotGetV2SpotMarketTickers(this.extend(request, parameters));
        } else
        {
            ((IDictionary<string,object>)request)["productType"] = productType;
            response = await this.publicMixGetV2MixMarketTickers(this.extend(request, parameters));
        }
        //
        // spot
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1700532903782,
        //         "data": [
        //             {
        //                 "open": "37202.46",
        //                 "symbol": "BTCUSDT",
        //                 "high24h": "37744.75",
        //                 "low24h": "36666",
        //                 "lastPr": "37583.69",
        //                 "quoteVolume": "519127705.303",
        //                 "baseVolume": "13907.0386",
        //                 "usdtVolume": "519127705.302908",
        //                 "ts": "1700532903261",
        //                 "bidPr": "37583.68",
        //                 "askPr": "37583.69",
        //                 "bidSz": "0.0007",
        //                 "askSz": "0.0829",
        //                 "openUtc": "37449.4",
        //                 "changeUtc24h": "0.00359",
        //                 "change24h": "0.00321"
        //             }
        //         ]
        //     }
        //
        // swap and future
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1700533773477,
        //         "data": [
        //             {
        //                 "open": "14.9776",
        //                 "symbol": "LINKUSDT",
        //                 "high24h": "15.3942",
        //                 "low24h": "14.3457",
        //                 "lastPr": "14.3748",
        //                 "quoteVolume": "7008612.4299",
        //                 "baseVolume": "469908.8523",
        //                 "usdtVolume": "7008612.42986561",
        //                 "ts": "1700533772309",
        //                 "bidPr": "14.375",
        //                 "askPr": "14.3769",
        //                 "bidSz": "50.004",
        //                 "askSz": "0.7647",
        //                 "openUtc": "14.478",
        //                 "changeUtc24h": "-0.00713",
        //                 "change24h": "-0.04978"
        //             },
        //         ]
        //     }
        //
        object data = this.safeList(response, "data", new List<object>() {});
        return this.parseTickers(data, symbols);
    }

    public override object parseTrade(object trade, object market = null)
    {
        //
        // spot, swap and future: fetchTrades
        //
        //     {
        //         "tradeId": "1075199767891652609",
        //         "price": "29376.5",
        //         "size": "6.035",
        //         "side": "Buy",
        //         "ts": "1692073521000",
        //         "symbol": "BTCUSDT"
        //     }
        //
        // spot: fetchMyTrades
        //
        //     {
        //         "userId": "7264631750",
        //         "symbol": "BTCUSDT",
        //         "orderId": "1098394344925597696",
        //         "tradeId": "1098394344974925824",
        //         "orderType": "market",
        //         "side": "sell",
        //         "priceAvg": "28467.68",
        //         "size": "0.0002",
        //         "amount": "5.693536",
        //         "feeDetail": {
        //             "deduction": "no",
        //             "feeCoin": "USDT",
        //             "totalDeductionFee": "",
        //             "totalFee": "-0.005693536"
        //         },
        //         "tradeScope": "taker",
        //         "cTime": "1697603539699",
        //         "uTime": "1697603539754"
        //     }
        //
        // spot margin: fetchMyTrades
        //
        //     {
        //         "orderId": "1099353730455318528",
        //         "tradeId": "1099353730627092481",
        //         "orderType": "market",
        //         "side": "sell",
        //         "priceAvg": "29543.7",
        //         "size": "0.0001",
        //         "amount": "2.95437",
        //         "tradeScope": "taker",
        //         "feeDetail": {
        //             "deduction": "no",
        //             "feeCoin": "USDT",
        //             "totalDeductionFee": "0",
        //             "totalFee": "-0.00295437"
        //         },
        //         "cTime": "1697832275063",
        //         "uTime": "1697832275150"
        //     }
        //
        // swap and future: fetchMyTrades
        //
        //     {
        //         "tradeId": "1111468664328269825",
        //         "symbol": "BTCUSDT",
        //         "orderId": "1111468664264753162",
        //         "price": "37271.4",
        //         "baseVolume": "0.001",
        //         "feeDetail": [
        //             {
        //                 "deduction": "no",
        //                 "feeCoin": "USDT",
        //                 "totalDeductionFee": null,
        //                 "totalFee": "-0.02236284"
        //             }
        //         ],
        //         "side": "buy",
        //         "quoteVolume": "37.2714",
        //         "profit": "-0.0007",
        //         "enterPointSource": "web",
        //         "tradeSide": "close",
        //         "posMode": "hedge_mode",
        //         "tradeScope": "taker",
        //         "cTime": "1700720700342"
        //     }
        //
        object marketId = this.safeString(trade, "symbol");
        object symbol = this.safeSymbol(marketId, market);
        object timestamp = this.safeInteger2(trade, "cTime", "ts");
        object fee = null;
        object feeDetail = this.safeValue(trade, "feeDetail");
        object posMode = this.safeString(trade, "posMode");
        object feeStructure = ((bool) isTrue((!isEqual(posMode, null)))) ? getValue(feeDetail, 0) : feeDetail;
        if (isTrue(!isEqual(feeStructure, null)))
        {
            object currencyCode = this.safeCurrencyCode(this.safeString(feeStructure, "feeCoin"));
            fee = new Dictionary<string, object>() {
                { "currency", currencyCode },
            };
            object feeCostString = this.safeString(feeStructure, "totalFee");
            object deduction = ((bool) isTrue(isEqual(this.safeString(feeStructure, "deduction"), "yes"))) ? true : false;
            if (isTrue(deduction))
            {
                ((IDictionary<string,object>)fee)["cost"] = feeCostString;
            } else
            {
                ((IDictionary<string,object>)fee)["cost"] = Precise.stringNeg(feeCostString);
            }
        }
        return this.safeTrade(new Dictionary<string, object>() {
            { "info", trade },
            { "id", this.safeString(trade, "tradeId") },
            { "order", this.safeString(trade, "orderId") },
            { "symbol", symbol },
            { "side", this.safeStringLower(trade, "side") },
            { "type", this.safeString(trade, "orderType") },
            { "takerOrMaker", this.safeString(trade, "tradeScope") },
            { "price", this.safeString2(trade, "priceAvg", "price") },
            { "amount", this.safeString2(trade, "baseVolume", "size") },
            { "cost", this.safeString2(trade, "quoteVolume", "amount") },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "fee", fee },
        }, market);
    }

    public async override Task<object> fetchTrades(object symbol, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bitget#fetchTrades
        * @description get the list of most recent trades for a particular symbol
        * @see https://www.bitget.com/api-doc/spot/market/Get-Recent-Trades
        * @see https://www.bitget.com/api-doc/spot/market/Get-Market-Trades
        * @see https://www.bitget.com/api-doc/contract/market/Get-Recent-Fills
        * @see https://www.bitget.com/api-doc/contract/market/Get-Fills-History
        * @param {string} symbol unified symbol of the market to fetch trades for
        * @param {int} [since] timestamp in ms of the earliest trade to fetch
        * @param {int} [limit] the maximum amount of trades to fetch
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {int} [params.until] *only applies to publicSpotGetV2SpotMarketFillsHistory and publicMixGetV2MixMarketFillsHistory* the latest time in ms to fetch trades for
        * @param {boolean} [params.paginate] *only applies to publicSpotGetV2SpotMarketFillsHistory and publicMixGetV2MixMarketFillsHistory* default false, when true will automatically paginate by calling this endpoint multiple times
        * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object paginate = false;
        var paginateparametersVariable = this.handleOptionAndParams(parameters, "fetchTrades", "paginate");
        paginate = ((IList<object>)paginateparametersVariable)[0];
        parameters = ((IList<object>)paginateparametersVariable)[1];
        if (isTrue(paginate))
        {
            return await this.fetchPaginatedCallCursor("fetchTrades", symbol, since, limit, parameters, "idLessThan", "idLessThan");
        }
        object sandboxMode = this.safeBool(this.options, "sandboxMode", false);
        object market = null;
        if (isTrue(sandboxMode))
        {
            object sandboxSymbol = this.convertSymbolForSandbox(symbol);
            market = this.market(sandboxSymbol);
        } else
        {
            market = this.market(symbol);
        }
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        if (isTrue(!isEqual(limit, null)))
        {
            if (isTrue(getValue(market, "contract")))
            {
                ((IDictionary<string,object>)request)["limit"] = mathMin(limit, 1000);
            } else
            {
                ((IDictionary<string,object>)request)["limit"] = limit;
            }
        }
        object options = this.safeValue(this.options, "fetchTrades", new Dictionary<string, object>() {});
        object response = null;
        if (isTrue(getValue(market, "spot")))
        {
            object spotOptions = this.safeValue(options, "spot", new Dictionary<string, object>() {});
            object defaultSpotMethod = this.safeString(spotOptions, "method", "publicSpotGetV2SpotMarketFillsHistory");
            object spotMethod = this.safeString(parameters, "method", defaultSpotMethod);
            parameters = this.omit(parameters, "method");
            if (isTrue(isEqual(spotMethod, "publicSpotGetV2SpotMarketFillsHistory")))
            {
                var requestparametersVariable = this.handleUntilOption("endTime", request, parameters);
                request = ((IList<object>)requestparametersVariable)[0];
                parameters = ((IList<object>)requestparametersVariable)[1];
                if (isTrue(!isEqual(since, null)))
                {
                    ((IDictionary<string,object>)request)["startTime"] = since;
                }
                response = await this.publicSpotGetV2SpotMarketFillsHistory(this.extend(request, parameters));
            } else if (isTrue(isEqual(spotMethod, "publicSpotGetV2SpotMarketFills")))
            {
                response = await this.publicSpotGetV2SpotMarketFills(this.extend(request, parameters));
            }
        } else
        {
            object swapOptions = this.safeValue(options, "swap", new Dictionary<string, object>() {});
            object defaultSwapMethod = this.safeString(swapOptions, "method", "publicMixGetV2MixMarketFillsHistory");
            object swapMethod = this.safeString(parameters, "method", defaultSwapMethod);
            parameters = this.omit(parameters, "method");
            object productType = null;
            var productTypeparametersVariable = this.handleProductTypeAndParams(market, parameters);
            productType = ((IList<object>)productTypeparametersVariable)[0];
            parameters = ((IList<object>)productTypeparametersVariable)[1];
            ((IDictionary<string,object>)request)["productType"] = productType;
            if (isTrue(isEqual(swapMethod, "publicMixGetV2MixMarketFillsHistory")))
            {
                var requestparametersVariable = this.handleUntilOption("endTime", request, parameters);
                request = ((IList<object>)requestparametersVariable)[0];
                parameters = ((IList<object>)requestparametersVariable)[1];
                if (isTrue(!isEqual(since, null)))
                {
                    ((IDictionary<string,object>)request)["startTime"] = since;
                }
                response = await this.publicMixGetV2MixMarketFillsHistory(this.extend(request, parameters));
            } else if (isTrue(isEqual(swapMethod, "publicMixGetV2MixMarketFills")))
            {
                response = await this.publicMixGetV2MixMarketFills(this.extend(request, parameters));
            }
        }
        //
        // spot
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1692073693562,
        //         "data": [
        //             {
        //                 "symbol": "BTCUSDT_SPBL",
        //                 "tradeId": "1075200479040323585",
        //                 "side": "Sell",
        //                 "price": "29381.54",
        //                 "size": "0.0056",
        //                 "ts": "1692073691000"
        //             },
        //         ]
        //     }
        //
        // swap
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1692073522689,
        //         "data": [
        //             {
        //                 "tradeId": "1075199767891652609",
        //                 "price": "29376.5",
        //                 "size": "6.035",
        //                 "side": "Buy",
        //                 "ts": "1692073521000",
        //                 "symbol": "BTCUSDT_UMCBL"
        //             },
        //         ]
        //     }
        //
        object data = this.safeList(response, "data", new List<object>() {});
        return this.parseTrades(data, market, since, limit);
    }

    public async override Task<object> fetchTradingFee(object symbol, object parameters = null)
    {
        /**
        * @method
        * @name bitget#fetchTradingFee
        * @description fetch the trading fees for a market
        * @see https://www.bitget.com/api-doc/common/public/Get-Trade-Rate
        * @param {string} symbol unified market symbol
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {string} [params.marginMode] 'isolated' or 'cross', for finding the fee rate of spot margin trading pairs
        * @returns {object} a [fee structure]{@link https://docs.ccxt.com/#/?id=fee-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object marginMode = null;
        var marginModeparametersVariable = this.handleMarginModeAndParams("fetchTradingFee", parameters);
        marginMode = ((IList<object>)marginModeparametersVariable)[0];
        parameters = ((IList<object>)marginModeparametersVariable)[1];
        if (isTrue(getValue(market, "spot")))
        {
            if (isTrue(!isEqual(marginMode, null)))
            {
                ((IDictionary<string,object>)request)["businessType"] = "margin";
            } else
            {
                ((IDictionary<string,object>)request)["businessType"] = "spot";
            }
        } else
        {
            ((IDictionary<string,object>)request)["businessType"] = "contract";
        }
        object response = await this.privateCommonGetV2CommonTradeRate(this.extend(request, parameters));
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1700549524887,
        //         "data": {
        //             "makerFeeRate": "0.001",
        //             "takerFeeRate": "0.001"
        //         }
        //     }
        //
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        return this.parseTradingFee(data, market);
    }

    public async override Task<object> fetchTradingFees(object parameters = null)
    {
        /**
        * @method
        * @name bitget#fetchTradingFees
        * @description fetch the trading fees for multiple markets
        * @see https://www.bitget.com/api-doc/spot/market/Get-Symbols
        * @see https://www.bitget.com/api-doc/contract/market/Get-All-Symbols-Contracts
        * @see https://www.bitget.com/api-doc/margin/common/support-currencies
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {string} [params.productType] *contract only* 'USDT-FUTURES', 'USDC-FUTURES', 'COIN-FUTURES', 'SUSDT-FUTURES', 'SUSDC-FUTURES' or 'SCOIN-FUTURES'
        * @param {boolean} [params.margin] set to true for spot margin
        * @returns {object} a dictionary of [fee structures]{@link https://docs.ccxt.com/#/?id=fee-structure} indexed by market symbols
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = null;
        object marginMode = null;
        object marketType = null;
        var marginModeparametersVariable = this.handleMarginModeAndParams("fetchTradingFees", parameters);
        marginMode = ((IList<object>)marginModeparametersVariable)[0];
        parameters = ((IList<object>)marginModeparametersVariable)[1];
        var marketTypeparametersVariable = this.handleMarketTypeAndParams("fetchTradingFees", null, parameters);
        marketType = ((IList<object>)marketTypeparametersVariable)[0];
        parameters = ((IList<object>)marketTypeparametersVariable)[1];
        if (isTrue(isEqual(marketType, "spot")))
        {
            object margin = this.safeBool(parameters, "margin", false);
            parameters = this.omit(parameters, "margin");
            if (isTrue(isTrue((!isEqual(marginMode, null))) || isTrue(margin)))
            {
                response = await this.publicMarginGetV2MarginCurrencies(parameters);
            } else
            {
                response = await this.publicSpotGetV2SpotPublicSymbols(parameters);
            }
        } else if (isTrue(isTrue((isEqual(marketType, "swap"))) || isTrue((isEqual(marketType, "future")))))
        {
            object productType = null;
            var productTypeparametersVariable = this.handleProductTypeAndParams(null, parameters);
            productType = ((IList<object>)productTypeparametersVariable)[0];
            parameters = ((IList<object>)productTypeparametersVariable)[1];
            ((IDictionary<string,object>)parameters)["productType"] = productType;
            response = await this.publicMixGetV2MixMarketContracts(parameters);
        } else
        {
            throw new NotSupported ((string)add(add(add(this.id, " does not support "), marketType), " market")) ;
        }
        //
        // spot and margin
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1700102364653,
        //         "data": [
        //             {
        //                 "symbol": "TRXUSDT",
        //                 "baseCoin": "TRX",
        //                 "quoteCoin": "USDT",
        //                 "minTradeAmount": "0",
        //                 "maxTradeAmount": "10000000000",
        //                 "takerFeeRate": "0.002",
        //                 "makerFeeRate": "0.002",
        //                 "pricePrecision": "6",
        //                 "quantityPrecision": "4",
        //                 "quotePrecision": "6",
        //                 "status": "online",
        //                 "minTradeUSDT": "5",
        //                 "buyLimitPriceRatio": "0.05",
        //                 "sellLimitPriceRatio": "0.05"
        //             },
        //         ]
        //     }
        //
        // swap and future
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1700102364709,
        //         "data": [
        //             {
        //                 "symbol": "BTCUSDT",
        //                 "baseCoin": "BTC",
        //                 "quoteCoin": "USDT",
        //                 "buyLimitPriceRatio": "0.01",
        //                 "sellLimitPriceRatio": "0.01",
        //                 "feeRateUpRatio": "0.005",
        //                 "makerFeeRate": "0.0002",
        //                 "takerFeeRate": "0.0006",
        //                 "openCostUpRatio": "0.01",
        //                 "supportMarginCoins": ["USDT"],
        //                 "minTradeNum": "0.001",
        //                 "priceEndStep": "1",
        //                 "volumePlace": "3",
        //                 "pricePlace": "1",
        //                 "sizeMultiplier": "0.001",
        //                 "symbolType": "perpetual",
        //                 "minTradeUSDT": "5",
        //                 "maxSymbolOrderNum": "200",
        //                 "maxProductOrderNum": "400",
        //                 "maxPositionNum": "150",
        //                 "symbolStatus": "normal",
        //                 "offTime": "-1",
        //                 "limitOpenTime": "-1",
        //                 "deliveryTime": "",
        //                 "deliveryStartTime": "",
        //                 "deliveryPeriod": "",
        //                 "launchTime": "",
        //                 "fundInterval": "8",
        //                 "minLever": "1",
        //                 "maxLever": "125",
        //                 "posLimit": "0.05",
        //                 "maintainTime": ""
        //             },
        //         ]
        //     }
        //
        object data = this.safeValue(response, "data", new List<object>() {});
        object result = new Dictionary<string, object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
        {
            object entry = getValue(data, i);
            object marketId = this.safeString(entry, "symbol");
            object symbol = this.safeSymbol(marketId, null, null, marketType);
            object market = this.market(symbol);
            object fee = this.parseTradingFee(entry, market);
            ((IDictionary<string,object>)result)[(string)symbol] = fee;
        }
        return result;
    }

    public virtual object parseTradingFee(object data, object market = null)
    {
        object marketId = this.safeString(data, "symbol");
        return new Dictionary<string, object>() {
            { "info", data },
            { "symbol", this.safeSymbol(marketId, market) },
            { "maker", this.safeNumber(data, "makerFeeRate") },
            { "taker", this.safeNumber(data, "takerFeeRate") },
            { "percentage", null },
            { "tierBased", null },
        };
    }

    public override object parseOHLCV(object ohlcv, object market = null)
    {
        //
        //     [
        //         "1645911960000",
        //         "39406",
        //         "39407",
        //         "39374.5",
        //         "39379",
        //         "35.526",
        //         "1399132.341"
        //     ]
        //
        return new List<object> {this.safeInteger(ohlcv, 0), this.safeNumber(ohlcv, 1), this.safeNumber(ohlcv, 2), this.safeNumber(ohlcv, 3), this.safeNumber(ohlcv, 4), this.safeNumber(ohlcv, 5)};
    }

    public async override Task<object> fetchOHLCV(object symbol, object timeframe = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bitget#fetchOHLCV
        * @description fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
        * @see https://www.bitget.com/api-doc/spot/market/Get-Candle-Data
        * @see https://www.bitget.com/api-doc/spot/market/Get-History-Candle-Data
        * @see https://www.bitget.com/api-doc/contract/market/Get-Candle-Data
        * @see https://www.bitget.com/api-doc/contract/market/Get-History-Candle-Data
        * @see https://www.bitget.com/api-doc/contract/market/Get-History-Index-Candle-Data
        * @see https://www.bitget.com/api-doc/contract/market/Get-History-Mark-Candle-Data
        * @param {string} symbol unified symbol of the market to fetch OHLCV data for
        * @param {string} timeframe the length of time each candle represents
        * @param {int} [since] timestamp in ms of the earliest candle to fetch
        * @param {int} [limit] the maximum amount of candles to fetch
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {int} [params.until] timestamp in ms of the latest candle to fetch
        * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [available parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
        * @param {string} [params.price] *swap only* "mark" (to fetch mark price candles) or "index" (to fetch index price candles)
        * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
        */
        timeframe ??= "1m";
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object defaultLimit = 100; // default 100, max 1000
        object maxLimitForRecentEndpoint = 1000;
        object maxLimitForHistoryEndpoint = 200; // note, max 1000 bars are supported for "recent-candles" endpoint, but "historical-candles" support only max 200
        object paginate = false;
        var paginateparametersVariable = this.handleOptionAndParams(parameters, "fetchOHLCV", "paginate");
        paginate = ((IList<object>)paginateparametersVariable)[0];
        parameters = ((IList<object>)paginateparametersVariable)[1];
        if (isTrue(paginate))
        {
            return await this.fetchPaginatedCallDeterministic("fetchOHLCV", symbol, since, limit, timeframe, parameters, maxLimitForHistoryEndpoint);
        }
        object sandboxMode = this.safeBool(this.options, "sandboxMode", false);
        object market = null;
        if (isTrue(sandboxMode))
        {
            object sandboxSymbol = this.convertSymbolForSandbox(symbol);
            market = this.market(sandboxSymbol);
        } else
        {
            market = this.market(symbol);
        }
        object marketType = ((bool) isTrue(getValue(market, "spot"))) ? "spot" : "swap";
        object timeframes = getValue(getValue(this.options, "timeframes"), marketType);
        object msInDay = 86400000;
        object duration = multiply(this.parseTimeframe(timeframe), 1000);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
            { "granularity", this.safeString(timeframes, timeframe, timeframe) },
        };
        object until = this.safeInteger(parameters, "until");
        object limitDefined = !isEqual(limit, null);
        object sinceDefined = !isEqual(since, null);
        object untilDefined = !isEqual(until, null);
        parameters = this.omit(parameters, new List<object>() {"until"});
        object response = null;
        object now = this.milliseconds();
        // retrievable periods listed here:
        // - https://www.bitget.com/api-doc/spot/market/Get-Candle-Data#request-parameters
        // - https://www.bitget.com/api-doc/contract/market/Get-Candle-Data#description
        object ohlcOptions = this.safeDict(this.options, "fetchOHLCV", new Dictionary<string, object>() {});
        object retrievableDaysMap = this.safeDict(ohlcOptions, "maxDaysPerTimeframe", new Dictionary<string, object>() {});
        object maxRetrievableDaysForRecent = this.safeInteger(retrievableDaysMap, timeframe, 30); // default to safe minimum
        object endpointTsBoundary = subtract(now, multiply(maxRetrievableDaysForRecent, msInDay));
        if (isTrue(limitDefined))
        {
            limit = mathMin(limit, maxLimitForRecentEndpoint);
            ((IDictionary<string,object>)request)["limit"] = limit;
        } else
        {
            limit = defaultLimit;
        }
        object limitMultipliedDuration = multiply(limit, duration);
        // exchange aligns from endTime, so it's important, not startTime
        // startTime is supported only on "recent" endpoint, not on "historical" endpoint
        object calculatedStartTime = null;
        object calculatedEndTime = null;
        if (isTrue(sinceDefined))
        {
            calculatedStartTime = since;
            ((IDictionary<string,object>)request)["startTime"] = since;
            if (!isTrue(untilDefined))
            {
                calculatedEndTime = this.sum(calculatedStartTime, limitMultipliedDuration);
                ((IDictionary<string,object>)request)["endTime"] = calculatedEndTime;
            }
        }
        if (isTrue(untilDefined))
        {
            calculatedEndTime = until;
            ((IDictionary<string,object>)request)["endTime"] = calculatedEndTime;
            if (!isTrue(sinceDefined))
            {
                calculatedStartTime = subtract(calculatedEndTime, limitMultipliedDuration);
            }
        }
        object historicalEndpointNeeded = isTrue((!isEqual(calculatedStartTime, null))) && isTrue((isLessThanOrEqual(calculatedStartTime, endpointTsBoundary)));
        if (isTrue(historicalEndpointNeeded))
        {
            // only for "historical-candles" - ensure we use correct max limit
            if (isTrue(limitDefined))
            {
                ((IDictionary<string,object>)request)["limit"] = mathMin(limit, maxLimitForHistoryEndpoint);
            }
        }
        // make request
        if (isTrue(getValue(market, "spot")))
        {
            // checks if we need history endpoint
            if (isTrue(historicalEndpointNeeded))
            {
                response = await this.publicSpotGetV2SpotMarketHistoryCandles(this.extend(request, parameters));
            } else
            {
                response = await this.publicSpotGetV2SpotMarketCandles(this.extend(request, parameters));
            }
        } else
        {
            object maxDistanceDaysForContracts = 90; // for contract, maximum 90 days allowed between start-end times
            // only correct the request to fix 90 days if until was auto-calculated
            if (isTrue(sinceDefined))
            {
                if (!isTrue(untilDefined))
                {
                    ((IDictionary<string,object>)request)["endTime"] = mathMin(calculatedEndTime, this.sum(since, multiply(maxDistanceDaysForContracts, msInDay)));
                } else if (isTrue(isGreaterThan(subtract(calculatedEndTime, calculatedStartTime), multiply(maxDistanceDaysForContracts, msInDay))))
                {
                    throw new BadRequest ((string)add(add(add(this.id, " fetchOHLCV() between start and end must be less than "), ((object)maxDistanceDaysForContracts).ToString()), " days")) ;
                }
            }
            object priceType = null;
            var priceTypeparametersVariable = this.handleParamString(parameters, "price");
            priceType = ((IList<object>)priceTypeparametersVariable)[0];
            parameters = ((IList<object>)priceTypeparametersVariable)[1];
            object productType = null;
            var productTypeparametersVariable = this.handleProductTypeAndParams(market, parameters);
            productType = ((IList<object>)productTypeparametersVariable)[0];
            parameters = ((IList<object>)productTypeparametersVariable)[1];
            ((IDictionary<string,object>)request)["productType"] = productType;
            object extended = this.extend(request, parameters);
            // todo: mark & index also have their "recent" endpoints, but not priority now.
            if (isTrue(isEqual(priceType, "mark")))
            {
                response = await this.publicMixGetV2MixMarketHistoryMarkCandles(extended);
            } else if (isTrue(isEqual(priceType, "index")))
            {
                response = await this.publicMixGetV2MixMarketHistoryIndexCandles(extended);
            } else
            {
                if (isTrue(historicalEndpointNeeded))
                {
                    response = await this.publicMixGetV2MixMarketHistoryCandles(extended);
                } else
                {
                    response = await this.publicMixGetV2MixMarketCandles(extended);
                }
            }
        }
        if (isTrue(isEqual(response, "")))
        {
            return new List<object>() {};  // happens when a new token is listed
        }
        //  [ ["1645911960000","39406","39407","39374.5","39379","35.526","1399132.341"] ]
        object data = this.safeList(response, "data", response);
        return this.parseOHLCVs(data, market, timeframe, since, limit);
    }

    public async override Task<object> fetchBalance(object parameters = null)
    {
        /**
        * @method
        * @name bitget#fetchBalance
        * @description query for balance and get the amount of funds available for trading or funds locked in orders
        * @see https://www.bitget.com/api-doc/spot/account/Get-Account-Assets
        * @see https://www.bitget.com/api-doc/contract/account/Get-Account-List
        * @see https://www.bitget.com/api-doc/margin/cross/account/Get-Cross-Assets
        * @see https://www.bitget.com/api-doc/margin/isolated/account/Get-Isolated-Assets
        * @see https://bitgetlimited.github.io/apidoc/en/margin/#get-cross-assets
        * @see https://bitgetlimited.github.io/apidoc/en/margin/#get-isolated-assets
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {string} [params.productType] *contract only* 'USDT-FUTURES', 'USDC-FUTURES', 'COIN-FUTURES', 'SUSDT-FUTURES', 'SUSDC-FUTURES' or 'SCOIN-FUTURES'
        * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object marketType = null;
        object marginMode = null;
        object response = null;
        var marketTypeparametersVariable = this.handleMarketTypeAndParams("fetchBalance", null, parameters);
        marketType = ((IList<object>)marketTypeparametersVariable)[0];
        parameters = ((IList<object>)marketTypeparametersVariable)[1];
        var marginModeparametersVariable = this.handleMarginModeAndParams("fetchBalance", parameters);
        marginMode = ((IList<object>)marginModeparametersVariable)[0];
        parameters = ((IList<object>)marginModeparametersVariable)[1];
        if (isTrue(isTrue((isEqual(marketType, "swap"))) || isTrue((isEqual(marketType, "future")))))
        {
            object productType = null;
            var productTypeparametersVariable = this.handleProductTypeAndParams(null, parameters);
            productType = ((IList<object>)productTypeparametersVariable)[0];
            parameters = ((IList<object>)productTypeparametersVariable)[1];
            ((IDictionary<string,object>)request)["productType"] = productType;
            response = await this.privateMixGetV2MixAccountAccounts(this.extend(request, parameters));
        } else if (isTrue(isEqual(marginMode, "isolated")))
        {
            response = await this.privateMarginGetMarginV1IsolatedAccountAssets(this.extend(request, parameters));
        } else if (isTrue(isEqual(marginMode, "cross")))
        {
            response = await this.privateMarginGetMarginV1CrossAccountAssets(this.extend(request, parameters));
        } else if (isTrue(isEqual(marketType, "spot")))
        {
            response = await this.privateSpotGetV2SpotAccountAssets(this.extend(request, parameters));
        } else
        {
            throw new NotSupported ((string)add(add(add(this.id, " fetchBalance() does not support "), marketType), " accounts")) ;
        }
        // spot
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1700623852854,
        //         "data": [
        //             {
        //                 "coin": "USDT",
        //                 "available": "0.00000000",
        //                 "limitAvailable": "0",
        //                 "frozen": "0.00000000",
        //                 "locked": "0.00000000",
        //                 "uTime": "1699937566000"
        //             }
        //         ]
        //     }
        //
        // swap
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1700625127294,
        //         "data": [
        //             {
        //                 "marginCoin": "USDT",
        //                 "locked": "0",
        //                 "available": "0",
        //                 "crossedMaxAvailable": "0",
        //                 "isolatedMaxAvailable": "0",
        //                 "maxTransferOut": "0",
        //                 "accountEquity": "0",
        //                 "usdtEquity": "0.000000005166",
        //                 "btcEquity": "0",
        //                 "crossedRiskRate": "0",
        //                 "unrealizedPL": "0",
        //                 "coupon": "0",
        //                 "crossedUnrealizedPL": null,
        //                 "isolatedUnrealizedPL": null
        //             }
        //         ]
        //     }
        //
        // isolated margin
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1697501436571,
        //         "data": [
        //             {
        //                 "symbol": "BTCUSDT",
        //                 "coin": "BTC",
        //                 "totalAmount": "0.00021654",
        //                 "available": "0.00021654",
        //                 "transferable": "0.00021654",
        //                 "frozen": "0",
        //                 "borrow": "0",
        //                 "interest": "0",
        //                 "net": "0.00021654",
        //                 "ctime": "1697248128071"
        //             },
        //         ]
        //     }
        //
        // cross margin
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1697515463804,
        //         "data": [
        //             {
        //                 "coin": "BTC",
        //                 "totalAmount": "0.00024996",
        //                 "available": "0.00024996",
        //                 "transferable": "0.00004994",
        //                 "frozen": "0",
        //                 "borrow": "0.0001",
        //                 "interest": "0.00000001",
        //                 "net": "0.00014995",
        //                 "ctime": "1697251265504"
        //             },
        //         ]
        //     }
        //
        object data = this.safeValue(response, "data", new List<object>() {});
        return this.parseBalance(data);
    }

    public override object parseBalance(object balance)
    {
        object result = new Dictionary<string, object>() {
            { "info", balance },
        };
        //
        // spot
        //
        //     {
        //         "coin": "USDT",
        //         "available": "0.00000000",
        //         "limitAvailable": "0",
        //         "frozen": "0.00000000",
        //         "locked": "0.00000000",
        //         "uTime": "1699937566000"
        //     }
        //
        // swap
        //
        //     {
        //         "marginCoin": "USDT",
        //         "locked": "0",
        //         "available": "0",
        //         "crossedMaxAvailable": "0",
        //         "isolatedMaxAvailable": "0",
        //         "maxTransferOut": "0",
        //         "accountEquity": "0",
        //         "usdtEquity": "0.000000005166",
        //         "btcEquity": "0",
        //         "crossedRiskRate": "0",
        //         "unrealizedPL": "0",
        //         "coupon": "0",
        //         "crossedUnrealizedPL": null,
        //         "isolatedUnrealizedPL": null
        //     }
        //
        // isolated margin
        //
        //     {
        //         "symbol": "BTCUSDT",
        //         "coin": "BTC",
        //         "totalAmount": "0.00021654",
        //         "available": "0.00021654",
        //         "transferable": "0.00021654",
        //         "frozen": "0",
        //         "borrow": "0",
        //         "interest": "0",
        //         "net": "0.00021654",
        //         "ctime": "1697248128071"
        //     }
        //
        // cross margin
        //
        //     {
        //         "coin": "BTC",
        //         "totalAmount": "0.00024995",
        //         "available": "0.00024995",
        //         "transferable": "0.00004993",
        //         "frozen": "0",
        //         "borrow": "0.0001",
        //         "interest": "0.00000001",
        //         "net": "0.00014994",
        //         "ctime": "1697251265504"
        //     }
        //
        for (object i = 0; isLessThan(i, getArrayLength(balance)); postFixIncrement(ref i))
        {
            object entry = getValue(balance, i);
            object account = this.account();
            object currencyId = this.safeString2(entry, "marginCoin", "coin");
            object code = this.safeCurrencyCode(currencyId);
            object borrow = this.safeString(entry, "borrow");
            if (isTrue(!isEqual(borrow, null)))
            {
                object interest = this.safeString(entry, "interest");
                ((IDictionary<string,object>)account)["free"] = this.safeString(entry, "transferable");
                ((IDictionary<string,object>)account)["total"] = this.safeString(entry, "totalAmount");
                ((IDictionary<string,object>)account)["debt"] = Precise.stringAdd(borrow, interest);
            } else
            {
                // Use transferable instead of available for swap and margin https://github.com/ccxt/ccxt/pull/19127
                object spotAccountFree = this.safeString(entry, "available");
                object contractAccountFree = this.safeString(entry, "maxTransferOut");
                if (isTrue(!isEqual(contractAccountFree, null)))
                {
                    ((IDictionary<string,object>)account)["free"] = contractAccountFree;
                    ((IDictionary<string,object>)account)["total"] = this.safeString(entry, "accountEquity");
                } else
                {
                    ((IDictionary<string,object>)account)["free"] = spotAccountFree;
                    object frozen = this.safeString(entry, "frozen");
                    object locked = this.safeString(entry, "locked");
                    ((IDictionary<string,object>)account)["used"] = Precise.stringAdd(frozen, locked);
                }
            }
            ((IDictionary<string,object>)result)[(string)code] = account;
        }
        return this.safeBalance(result);
    }

    public virtual object parseOrderStatus(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "new", "open" },
            { "init", "open" },
            { "not_trigger", "open" },
            { "partial_fill", "open" },
            { "partially_fill", "open" },
            { "partially_filled", "open" },
            { "triggered", "closed" },
            { "full_fill", "closed" },
            { "filled", "closed" },
            { "fail_trigger", "rejected" },
            { "cancel", "canceled" },
            { "cancelled", "canceled" },
            { "canceled", "canceled" },
            { "live", "open" },
            { "fail_execute", "rejected" },
            { "executed", "closed" },
        };
        return this.safeString(statuses, status, status);
    }

    public override object parseOrder(object order, object market = null)
    {
        //
        // createOrder, editOrder, closePosition
        //
        //     {
        //         "clientOid": "abe95dbe-6081-4a6f-a2d3-ae49601cd479",
        //         "orderId": null
        //     }
        //
        // createOrders
        //
        //     [
        //         {
        //             "orderId": "1111397214281175046",
        //             "clientOid": "766d3fc3-7321-4406-a689-15c9987a2e75"
        //         },
        //         {
        //             "orderId": "",
        //             "clientOid": "d1b75cb3-cc15-4ede-ad4c-3937396f75ab",
        //             "errorMsg": "less than the minimum amount 5 USDT",
        //             "errorCode": "45110"
        //         },
        //     ]
        //
        // spot, swap, future and spot margin: cancelOrder, cancelOrders
        //
        //     {
        //         "orderId": "1098758604547850241",
        //         "clientOid": "1098758604585598977"
        //     }
        //
        // spot trigger: cancelOrder
        //
        //     {
        //         "result": "success"
        //     }
        //
        // spot: fetchOrder
        //
        //     {
        //         "userId": "7264631750",
        //         "symbol": "BTCUSDT",
        //         "orderId": "1111461743123927040",
        //         "clientOid": "63f95110-93b5-4309-8f77-46339f1bcf3c",
        //         "price": "25000.0000000000000000",
        //         "size": "0.0002000000000000",
        //         "orderType": "limit",
        //         "side": "buy",
        //         "status": "live",
        //         "priceAvg": "0",
        //         "baseVolume": "0.0000000000000000",
        //         "quoteVolume": "0.0000000000000000",
        //         "enterPointSource": "API",
        //         "feeDetail": "",
        //         "orderSource": "normal",
        //         "cTime": "1700719050198",
        //         "uTime": "1700719050198"
        //     }
        //
        // swap and future: fetchOrder
        //
        //     {
        //         "symbol": "BTCUSDT",
        //         "size": "0.001",
        //         "orderId": "1111465253393825792",
        //         "clientOid": "1111465253431574529",
        //         "baseVolume": "0",
        //         "fee": "0",
        //         "price": "27000",
        //         "priceAvg": "",
        //         "state": "live",
        //         "side": "buy",
        //         "force": "gtc",
        //         "totalProfits": "0",
        //         "posSide": "long",
        //         "marginCoin": "USDT",
        //         "presetStopSurplusPrice": "",
        //         "presetStopLossPrice": "",
        //         "quoteVolume": "0",
        //         "orderType": "limit",
        //         "leverage": "20",
        //         "marginMode": "crossed",
        //         "reduceOnly": "NO",
        //         "enterPointSource": "API",
        //         "tradeSide": "open",
        //         "posMode": "hedge_mode",
        //         "orderSource": "normal",
        //         "cTime": "1700719887120",
        //         "uTime": "1700719887120"
        //     }
        //
        // spot: fetchOpenOrders
        //
        //     {
        //         "userId": "7264631750",
        //         "symbol": "BTCUSDT",
        //         "orderId": "1111499608327360513",
        //         "clientOid": "d0d4dad5-18d0-4869-a074-ec40bb47cba6",
        //         "priceAvg": "25000.0000000000000000",
        //         "size": "0.0002000000000000",
        //         "orderType": "limit",
        //         "side": "buy",
        //         "status": "live",
        //         "basePrice": "0",
        //         "baseVolume": "0.0000000000000000",
        //         "quoteVolume": "0.0000000000000000",
        //         "enterPointSource": "WEB",
        //         "orderSource": "normal",
        //         "cTime": "1700728077966",
        //         "uTime": "1700728077966"
        //     }
        //
        // spot stop: fetchOpenOrders, fetchCanceledAndClosedOrders
        //
        //     {
        //         "orderId": "1111503385931620352",
        //         "clientOid": "1111503385910648832",
        //         "symbol": "BTCUSDT",
        //         "size": "0.0002",
        //         "planType": "AMOUNT",
        //         "executePrice": "25000",
        //         "triggerPrice": "26000",
        //         "status": "live",
        //         "orderType": "limit",
        //         "side": "buy",
        //         "triggerType": "fill_price",
        //         "enterPointSource": "API",
        //         "cTime": "1700728978617",
        //         "uTime": "1700728978617"
        //     }
        //
        // spot margin: fetchOpenOrders, fetchCanceledAndClosedOrders
        //
        //     {
        //         "symbol": "BTCUSDT",
        //         "orderType": "limit",
        //         "enterPointSource": "WEB",
        //         "orderId": "1111506377509580801",
        //         "clientOid": "2043a3b59a60445f9d9f7365bf3e960c",
        //         "loanType": "autoLoanAndRepay",
        //         "price": "25000",
        //         "side": "buy",
        //         "status": "live",
        //         "baseSize": "0.0002",
        //         "quoteSize": "5",
        //         "priceAvg": "0",
        //         "size": "0",
        //         "amount": "0",
        //         "force": "gtc",
        //         "cTime": "1700729691866",
        //         "uTime": "1700729691866"
        //     }
        //
        // swap: fetchOpenOrders, fetchCanceledAndClosedOrders
        //
        //     {
        //         "symbol": "BTCUSDT",
        //         "size": "0.002",
        //         "orderId": "1111488897767604224",
        //         "clientOid": "1111488897805352960",
        //         "baseVolume": "0",
        //         "fee": "0",
        //         "price": "25000",
        //         "priceAvg": "",
        //         "status": "live",
        //         "side": "buy",
        //         "force": "gtc",
        //         "totalProfits": "0",
        //         "posSide": "long",
        //         "marginCoin": "USDT",
        //         "quoteVolume": "0",
        //         "leverage": "20",
        //         "marginMode": "crossed",
        //         "enterPointSource": "web",
        //         "tradeSide": "open",
        //         "posMode": "hedge_mode",
        //         "orderType": "limit",
        //         "orderSource": "normal",
        //         "presetStopSurplusPrice": "",
        //         "presetStopLossPrice": "",
        //         "reduceOnly": "NO",
        //         "cTime": "1700725524378",
        //         "uTime": "1700725524378"
        //     }
        //
        // swap stop: fetchOpenOrders
        //
        //     {
        //         "planType": "normal_plan",
        //         "symbol": "BTCUSDT",
        //         "size": "0.001",
        //         "orderId": "1111491399869075457",
        //         "clientOid": "1111491399869075456",
        //         "price": "27000",
        //         "callbackRatio": "",
        //         "triggerPrice": "24000",
        //         "triggerType": "mark_price",
        //         "planStatus": "live",
        //         "side": "buy",
        //         "posSide": "long",
        //         "marginCoin": "USDT",
        //         "marginMode": "crossed",
        //         "enterPointSource": "API",
        //         "tradeSide": "open",
        //         "posMode": "hedge_mode",
        //         "orderType": "limit",
        //         "stopSurplusTriggerPrice": "",
        //         "stopSurplusExecutePrice": "",
        //         "stopSurplusTriggerType": "fill_price",
        //         "stopLossTriggerPrice": "",
        //         "stopLossExecutePrice": "",
        //         "stopLossTriggerType": "fill_price",
        //         "cTime": "1700726120917",
        //         "uTime": "1700726120917"
        //     }
        //
        // spot: fetchCanceledAndClosedOrders
        //
        //     {
        //         "userId": "7264631750",
        //         "symbol": "BTCUSDT",
        //         "orderId": "1111499608327360513",
        //         "clientOid": "d0d4dad5-18d0-4869-a074-ec40bb47cba6",
        //         "price": "25000.0000000000000000",
        //         "size": "0.0002000000000000",
        //         "orderType": "limit",
        //         "side": "buy",
        //         "status": "cancelled",
        //         "priceAvg": "0",
        //         "baseVolume": "0.0000000000000000",
        //         "quoteVolume": "0.0000000000000000",
        //         "enterPointSource": "WEB",
        //         "feeDetail": "",
        //         "orderSource": "normal",
        //         "cTime": "1700728077966",
        //         "uTime": "1700728911471"
        //     }
        //
        // swap stop: fetchCanceledAndClosedOrders
        //
        //     {
        //         "planType": "normal_plan",
        //         "symbol": "BTCUSDT",
        //         "size": "0.001",
        //         "orderId": "1111491399869075457",
        //         "clientOid": "1111491399869075456",
        //         "planStatus": "cancelled",
        //         "price": "27000",
        //         "feeDetail": null,
        //         "baseVolume": "0",
        //         "callbackRatio": "",
        //         "triggerPrice": "24000",
        //         "triggerType": "mark_price",
        //         "side": "buy",
        //         "posSide": "long",
        //         "marginCoin": "USDT",
        //         "marginMode": "crossed",
        //         "enterPointSource": "API",
        //         "tradeSide": "open",
        //         "posMode": "hedge_mode",
        //         "orderType": "limit",
        //         "stopSurplusTriggerPrice": "",
        //         "stopSurplusExecutePrice": "",
        //         "stopSurplusTriggerType": "fill_price",
        //         "stopLossTriggerPrice": "",
        //         "stopLossExecutePrice": "",
        //         "stopLossTriggerType": "fill_price",
        //         "cTime": "1700726120917",
        //         "uTime": "1700727879652"
        //     }
        //
        object errorMessage = this.safeString(order, "errorMsg");
        if (isTrue(!isEqual(errorMessage, null)))
        {
            return this.safeOrder(new Dictionary<string, object>() {
                { "info", order },
                { "id", this.safeString(order, "orderId") },
                { "clientOrderId", this.safeString2(order, "clientOrderId", "clientOid") },
                { "status", "rejected" },
            }, market);
        }
        object isContractOrder = (inOp(order, "posSide"));
        object marketType = ((bool) isTrue(isContractOrder)) ? "contract" : "spot";
        if (isTrue(!isEqual(market, null)))
        {
            marketType = getValue(market, "type");
        }
        object marketId = this.safeString(order, "symbol");
        market = this.safeMarket(marketId, market, null, marketType);
        object timestamp = this.safeInteger2(order, "cTime", "ctime");
        object updateTimestamp = this.safeInteger(order, "uTime");
        object rawStatus = this.safeString2(order, "status", "state");
        object fee = null;
        object feeCostString = this.safeString(order, "fee");
        if (isTrue(!isEqual(feeCostString, null)))
        {
            // swap
            fee = new Dictionary<string, object>() {
                { "cost", this.parseNumber(Precise.stringAbs(feeCostString)) },
                { "currency", getValue(market, "settle") },
            };
        }
        object feeDetail = this.safeValue(order, "feeDetail");
        if (isTrue(!isEqual(feeDetail, null)))
        {
            object parsedFeeDetail = parseJson(feeDetail);
            object feeValues = new List<object>(((IDictionary<string,object>)parsedFeeDetail).Values);
            object feeObject = null;
            for (object i = 0; isLessThan(i, getArrayLength(feeValues)); postFixIncrement(ref i))
            {
                object feeValue = getValue(feeValues, i);
                if (isTrue(!isEqual(this.safeValue(feeValue, "feeCoinCode"), null)))
                {
                    feeObject = feeValue;
                    break;
                }
            }
            fee = new Dictionary<string, object>() {
                { "cost", this.parseNumber(Precise.stringAbs(this.safeString(feeObject, "totalFee"))) },
                { "currency", this.safeCurrencyCode(this.safeString(feeObject, "feeCoinCode")) },
            };
        }
        object postOnly = null;
        object timeInForce = this.safeStringUpper(order, "force");
        if (isTrue(isEqual(timeInForce, "POST_ONLY")))
        {
            postOnly = true;
            timeInForce = "PO";
        }
        object reduceOnly = null;
        object reduceOnlyRaw = this.safeString(order, "reduceOnly");
        if (isTrue(!isEqual(reduceOnlyRaw, null)))
        {
            reduceOnly = ((bool) isTrue((isEqual(reduceOnlyRaw, "NO")))) ? false : true;
        }
        object price = null;
        object average = null;
        object basePrice = this.safeString(order, "basePrice");
        if (isTrue(!isEqual(basePrice, null)))
        {
            // for spot fetchOpenOrders, the price is priceAvg and the filled price is basePrice
            price = this.safeString(order, "priceAvg");
            average = this.safeString(order, "basePrice");
        } else
        {
            price = this.safeString2(order, "price", "executePrice");
            average = this.safeString(order, "priceAvg");
        }
        object size = null;
        object filled = null;
        object baseSize = this.safeString(order, "baseSize");
        if (isTrue(!isEqual(baseSize, null)))
        {
            // for spot margin fetchOpenOrders, the order size is baseSize and the filled amount is size
            size = baseSize;
            filled = this.safeString(order, "size");
        } else
        {
            size = this.safeString(order, "size");
            filled = this.safeString(order, "baseVolume");
        }
        object side = this.safeString(order, "side");
        object posMode = this.safeString(order, "posMode");
        if (isTrue(isTrue(isEqual(posMode, "hedge_mode")) && isTrue(reduceOnly)))
        {
            side = ((bool) isTrue((isEqual(side, "buy")))) ? "sell" : "buy";
        }
        return this.safeOrder(new Dictionary<string, object>() {
            { "info", order },
            { "id", this.safeString2(order, "orderId", "data") },
            { "clientOrderId", this.safeString2(order, "clientOrderId", "clientOid") },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "lastTradeTimestamp", updateTimestamp },
            { "lastUpdateTimestamp", updateTimestamp },
            { "symbol", getValue(market, "symbol") },
            { "type", this.safeString(order, "orderType") },
            { "side", side },
            { "price", price },
            { "amount", size },
            { "cost", this.safeString2(order, "quoteVolume", "quoteSize") },
            { "average", average },
            { "filled", filled },
            { "remaining", null },
            { "timeInForce", timeInForce },
            { "postOnly", postOnly },
            { "reduceOnly", reduceOnly },
            { "stopPrice", this.safeNumber(order, "triggerPrice") },
            { "triggerPrice", this.safeNumber(order, "triggerPrice") },
            { "takeProfitPrice", this.safeNumber2(order, "presetStopSurplusPrice", "stopSurplusTriggerPrice") },
            { "stopLossPrice", this.safeNumber2(order, "presetStopLossPrice", "stopLossTriggerPrice") },
            { "status", this.parseOrderStatus(rawStatus) },
            { "fee", fee },
            { "trades", null },
        }, market);
    }

    public async override Task<object> createMarketBuyOrderWithCost(object symbol, object cost, object parameters = null)
    {
        /**
        * @method
        * @name bitget#createMarketBuyOrderWithCost
        * @description create a market buy order by providing the symbol and cost
        * @see https://www.bitget.com/api-doc/spot/trade/Place-Order
        * @see https://www.bitget.com/api-doc/margin/cross/trade/Cross-Place-Order
        * @see https://www.bitget.com/api-doc/margin/isolated/trade/Isolated-Place-Order
        * @param {string} symbol unified symbol of the market to create an order in
        * @param {float} cost how much you want to trade in units of the quote currency
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        if (!isTrue(getValue(market, "spot")))
        {
            throw new NotSupported ((string)add(this.id, " createMarketBuyOrderWithCost() supports spot orders only")) ;
        }
        ((IDictionary<string,object>)parameters)["createMarketBuyOrderRequiresPrice"] = false;
        return await this.createOrder(symbol, "market", "buy", cost, null, parameters);
    }

    public async override Task<object> createOrder(object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        /**
        * @method
        * @name bitget#createOrder
        * @description create a trade order
        * @see https://www.bitget.com/api-doc/spot/trade/Place-Order
        * @see https://www.bitget.com/api-doc/spot/plan/Place-Plan-Order
        * @see https://www.bitget.com/api-doc/contract/trade/Place-Order
        * @see https://www.bitget.com/api-doc/contract/plan/Place-Tpsl-Order
        * @see https://www.bitget.com/api-doc/contract/plan/Place-Plan-Order
        * @see https://www.bitget.com/api-doc/margin/cross/trade/Cross-Place-Order
        * @see https://www.bitget.com/api-doc/margin/isolated/trade/Isolated-Place-Order
        * @param {string} symbol unified symbol of the market to create an order in
        * @param {string} type 'market' or 'limit'
        * @param {string} side 'buy' or 'sell'
        * @param {float} amount how much you want to trade in units of the base currency
        * @param {float} [price] the price at which the order is to be fullfilled, in units of the quote currency, ignored in market orders
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {float} [params.cost] *spot only* how much you want to trade in units of the quote currency, for market buy orders only
        * @param {float} [params.triggerPrice] *swap only* The price at which a trigger order is triggered at
        * @param {float} [params.stopLossPrice] *swap only* The price at which a stop loss order is triggered at
        * @param {float} [params.takeProfitPrice] *swap only* The price at which a take profit order is triggered at
        * @param {object} [params.takeProfit] *takeProfit object in params* containing the triggerPrice at which the attached take profit order will be triggered (perpetual swap markets only)
        * @param {float} [params.takeProfit.triggerPrice] *swap only* take profit trigger price
        * @param {object} [params.stopLoss] *stopLoss object in params* containing the triggerPrice at which the attached stop loss order will be triggered (perpetual swap markets only)
        * @param {float} [params.stopLoss.triggerPrice] *swap only* stop loss trigger price
        * @param {string} [params.timeInForce] "GTC", "IOC", "FOK", or "PO"
        * @param {string} [params.marginMode] 'isolated' or 'cross' for spot margin trading
        * @param {string} [params.loanType] *spot margin only* 'normal', 'autoLoan', 'autoRepay', or 'autoLoanAndRepay' default is 'normal'
        * @param {string} [params.holdSide] *contract stopLossPrice, takeProfitPrice only* Two-way position: ('long' or 'short'), one-way position: ('buy' or 'sell')
        * @param {float} [params.stopLoss.price] *swap only* the execution price for a stop loss attached to a trigger order
        * @param {float} [params.takeProfit.price] *swap only* the execution price for a take profit attached to a trigger order
        * @param {string} [params.stopLoss.type] *swap only* the type for a stop loss attached to a trigger order, 'fill_price', 'index_price' or 'mark_price', default is 'mark_price'
        * @param {string} [params.takeProfit.type] *swap only* the type for a take profit attached to a trigger order, 'fill_price', 'index_price' or 'mark_price', default is 'mark_price'
        * @param {string} [params.trailingPercent] *swap and future only* the percent to trail away from the current market price, rate can not be greater than 10
        * @param {string} [params.trailingTriggerPrice] *swap and future only* the price to trigger a trailing stop order, default uses the price argument
        * @param {string} [params.triggerType] *swap and future only* 'fill_price', 'mark_price' or 'index_price'
        * @param {boolean} [params.oneWayMode] *swap and future only* required to set this to true in one_way_mode and you can leave this as undefined in hedge_mode, can adjust the mode using the setPositionMode() method
        * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object marginParams = this.handleMarginModeAndParams("createOrder", parameters);
        object marginMode = getValue(marginParams, 0);
        object triggerPrice = this.safeValue2(parameters, "stopPrice", "triggerPrice");
        object stopLossTriggerPrice = this.safeValue(parameters, "stopLossPrice");
        object takeProfitTriggerPrice = this.safeValue(parameters, "takeProfitPrice");
        object trailingPercent = this.safeString2(parameters, "trailingPercent", "callbackRatio");
        object isTrailingPercentOrder = !isEqual(trailingPercent, null);
        object isTriggerOrder = !isEqual(triggerPrice, null);
        object isStopLossTriggerOrder = !isEqual(stopLossTriggerPrice, null);
        object isTakeProfitTriggerOrder = !isEqual(takeProfitTriggerPrice, null);
        object isStopLossOrTakeProfitTrigger = isTrue(isStopLossTriggerOrder) || isTrue(isTakeProfitTriggerOrder);
        object request = this.createOrderRequest(symbol, type, side, amount, price, parameters);
        object response = null;
        if (isTrue(getValue(market, "spot")))
        {
            if (isTrue(isTriggerOrder))
            {
                response = await this.privateSpotPostV2SpotTradePlacePlanOrder(request);
            } else if (isTrue(isEqual(marginMode, "isolated")))
            {
                response = await this.privateMarginPostV2MarginIsolatedPlaceOrder(request);
            } else if (isTrue(isEqual(marginMode, "cross")))
            {
                response = await this.privateMarginPostV2MarginCrossedPlaceOrder(request);
            } else
            {
                response = await this.privateSpotPostV2SpotTradePlaceOrder(request);
            }
        } else
        {
            if (isTrue(isTrue(isTriggerOrder) || isTrue(isTrailingPercentOrder)))
            {
                response = await this.privateMixPostV2MixOrderPlacePlanOrder(request);
            } else if (isTrue(isStopLossOrTakeProfitTrigger))
            {
                response = await this.privateMixPostV2MixOrderPlaceTpslOrder(request);
            } else
            {
                response = await this.privateMixPostV2MixOrderPlaceOrder(request);
            }
        }
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1645932209602,
        //         "data": {
        //             "orderId": "881669078313766912",
        //             "clientOid": "iauIBf#a45b595f96474d888d0ada"
        //         }
        //     }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        return this.parseOrder(data, market);
    }

    public virtual object createOrderRequest(object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object sandboxMode = this.safeBool(this.options, "sandboxMode", false);
        object market = null;
        if (isTrue(sandboxMode))
        {
            object sandboxSymbol = this.convertSymbolForSandbox(symbol);
            market = this.market(sandboxSymbol);
        } else
        {
            market = this.market(symbol);
        }
        object marketType = null;
        object marginMode = null;
        var marketTypeparametersVariable = this.handleMarketTypeAndParams("createOrder", market, parameters);
        marketType = ((IList<object>)marketTypeparametersVariable)[0];
        parameters = ((IList<object>)marketTypeparametersVariable)[1];
        var marginModeparametersVariable = this.handleMarginModeAndParams("createOrder", parameters);
        marginMode = ((IList<object>)marginModeparametersVariable)[0];
        parameters = ((IList<object>)marginModeparametersVariable)[1];
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
            { "orderType", type },
        };
        object isMarketOrder = isEqual(type, "market");
        object triggerPrice = this.safeValue2(parameters, "stopPrice", "triggerPrice");
        object stopLossTriggerPrice = this.safeValue(parameters, "stopLossPrice");
        object takeProfitTriggerPrice = this.safeValue(parameters, "takeProfitPrice");
        object stopLoss = this.safeValue(parameters, "stopLoss");
        object takeProfit = this.safeValue(parameters, "takeProfit");
        object isTriggerOrder = !isEqual(triggerPrice, null);
        object isStopLossTriggerOrder = !isEqual(stopLossTriggerPrice, null);
        object isTakeProfitTriggerOrder = !isEqual(takeProfitTriggerPrice, null);
        object isStopLoss = !isEqual(stopLoss, null);
        object isTakeProfit = !isEqual(takeProfit, null);
        object isStopLossOrTakeProfitTrigger = isTrue(isStopLossTriggerOrder) || isTrue(isTakeProfitTriggerOrder);
        object isStopLossOrTakeProfit = isTrue(isStopLoss) || isTrue(isTakeProfit);
        object trailingTriggerPrice = this.safeString(parameters, "trailingTriggerPrice", this.numberToString(price));
        object trailingPercent = this.safeString2(parameters, "trailingPercent", "callbackRatio");
        object isTrailingPercentOrder = !isEqual(trailingPercent, null);
        if (isTrue(isGreaterThan(this.sum(isTriggerOrder, isStopLossTriggerOrder, isTakeProfitTriggerOrder, isTrailingPercentOrder), 1)))
        {
            throw new ExchangeError ((string)add(this.id, " createOrder() params can only contain one of triggerPrice, stopLossPrice, takeProfitPrice, trailingPercent")) ;
        }
        if (isTrue(isEqual(type, "limit")))
        {
            ((IDictionary<string,object>)request)["price"] = this.priceToPrecision(symbol, price);
        }
        object triggerType = this.safeString(parameters, "triggerType", "mark_price");
        object reduceOnly = this.safeBool(parameters, "reduceOnly", false);
        object clientOrderId = this.safeString2(parameters, "clientOid", "clientOrderId");
        object exchangeSpecificTifParam = this.safeString2(parameters, "force", "timeInForce");
        object postOnly = null;
        var postOnlyparametersVariable = this.handlePostOnly(isMarketOrder, isEqual(exchangeSpecificTifParam, "post_only"), parameters);
        postOnly = ((IList<object>)postOnlyparametersVariable)[0];
        parameters = ((IList<object>)postOnlyparametersVariable)[1];
        object defaultTimeInForce = this.safeStringUpper(this.options, "defaultTimeInForce");
        object timeInForce = this.safeStringUpper(parameters, "timeInForce", defaultTimeInForce);
        if (isTrue(postOnly))
        {
            ((IDictionary<string,object>)request)["force"] = "post_only";
        } else if (isTrue(isEqual(timeInForce, "GTC")))
        {
            ((IDictionary<string,object>)request)["force"] = "GTC";
        } else if (isTrue(isEqual(timeInForce, "FOK")))
        {
            ((IDictionary<string,object>)request)["force"] = "FOK";
        } else if (isTrue(isEqual(timeInForce, "IOC")))
        {
            ((IDictionary<string,object>)request)["force"] = "IOC";
        }
        parameters = this.omit(parameters, new List<object>() {"stopPrice", "triggerType", "stopLossPrice", "takeProfitPrice", "stopLoss", "takeProfit", "postOnly", "reduceOnly", "clientOrderId", "trailingPercent", "trailingTriggerPrice"});
        if (isTrue(isTrue((isEqual(marketType, "swap"))) || isTrue((isEqual(marketType, "future")))))
        {
            ((IDictionary<string,object>)request)["marginCoin"] = getValue(market, "settleId");
            ((IDictionary<string,object>)request)["size"] = this.amountToPrecision(symbol, amount);
            object productType = null;
            var productTypeparametersVariable = this.handleProductTypeAndParams(market, parameters);
            productType = ((IList<object>)productTypeparametersVariable)[0];
            parameters = ((IList<object>)productTypeparametersVariable)[1];
            ((IDictionary<string,object>)request)["productType"] = productType;
            if (isTrue(!isEqual(clientOrderId, null)))
            {
                ((IDictionary<string,object>)request)["clientOid"] = clientOrderId;
            }
            if (isTrue(isTrue(isTrue(isTriggerOrder) || isTrue(isStopLossOrTakeProfitTrigger)) || isTrue(isTrailingPercentOrder)))
            {
                ((IDictionary<string,object>)request)["triggerType"] = triggerType;
            }
            if (isTrue(isTrailingPercentOrder))
            {
                if (!isTrue(isMarketOrder))
                {
                    throw new BadRequest ((string)add(this.id, " createOrder() bitget trailing orders must be market orders")) ;
                }
                if (isTrue(isEqual(trailingTriggerPrice, null)))
                {
                    throw new ArgumentsRequired ((string)add(this.id, " createOrder() bitget trailing orders must have a trailingTriggerPrice param")) ;
                }
                ((IDictionary<string,object>)request)["planType"] = "track_plan";
                ((IDictionary<string,object>)request)["triggerPrice"] = this.priceToPrecision(symbol, trailingTriggerPrice);
                ((IDictionary<string,object>)request)["callbackRatio"] = trailingPercent;
            } else if (isTrue(isTriggerOrder))
            {
                ((IDictionary<string,object>)request)["planType"] = "normal_plan";
                ((IDictionary<string,object>)request)["triggerPrice"] = this.priceToPrecision(symbol, triggerPrice);
                if (isTrue(!isEqual(price, null)))
                {
                    ((IDictionary<string,object>)request)["executePrice"] = this.priceToPrecision(symbol, price);
                }
                if (isTrue(isStopLoss))
                {
                    object slTriggerPrice = this.safeNumber2(stopLoss, "triggerPrice", "stopPrice");
                    ((IDictionary<string,object>)request)["stopLossTriggerPrice"] = this.priceToPrecision(symbol, slTriggerPrice);
                    object slPrice = this.safeNumber(stopLoss, "price");
                    ((IDictionary<string,object>)request)["stopLossExecutePrice"] = this.priceToPrecision(symbol, slPrice);
                    object slType = this.safeString(stopLoss, "type", "mark_price");
                    ((IDictionary<string,object>)request)["stopLossTriggerType"] = slType;
                }
                if (isTrue(isTakeProfit))
                {
                    object tpTriggerPrice = this.safeNumber2(takeProfit, "triggerPrice", "stopPrice");
                    ((IDictionary<string,object>)request)["stopSurplusTriggerPrice"] = this.priceToPrecision(symbol, tpTriggerPrice);
                    object tpPrice = this.safeNumber(takeProfit, "price");
                    ((IDictionary<string,object>)request)["stopSurplusExecutePrice"] = this.priceToPrecision(symbol, tpPrice);
                    object tpType = this.safeString(takeProfit, "type", "mark_price");
                    ((IDictionary<string,object>)request)["stopSurplusTriggerType"] = tpType;
                }
            } else if (isTrue(isStopLossOrTakeProfitTrigger))
            {
                if (!isTrue(isMarketOrder))
                {
                    throw new ExchangeError ((string)add(this.id, " createOrder() bitget stopLoss or takeProfit orders must be market orders")) ;
                }
                ((IDictionary<string,object>)request)["holdSide"] = ((bool) isTrue((isEqual(side, "buy")))) ? "long" : "short";
                if (isTrue(isStopLossTriggerOrder))
                {
                    ((IDictionary<string,object>)request)["triggerPrice"] = this.priceToPrecision(symbol, stopLossTriggerPrice);
                    ((IDictionary<string,object>)request)["planType"] = "pos_loss";
                } else if (isTrue(isTakeProfitTriggerOrder))
                {
                    ((IDictionary<string,object>)request)["triggerPrice"] = this.priceToPrecision(symbol, takeProfitTriggerPrice);
                    ((IDictionary<string,object>)request)["planType"] = "pos_profit";
                }
            } else
            {
                if (isTrue(isStopLoss))
                {
                    object slTriggerPrice = this.safeValue2(stopLoss, "triggerPrice", "stopPrice");
                    ((IDictionary<string,object>)request)["presetStopLossPrice"] = this.priceToPrecision(symbol, slTriggerPrice);
                }
                if (isTrue(isTakeProfit))
                {
                    object tpTriggerPrice = this.safeValue2(takeProfit, "triggerPrice", "stopPrice");
                    ((IDictionary<string,object>)request)["presetStopSurplusPrice"] = this.priceToPrecision(symbol, tpTriggerPrice);
                }
            }
            if (!isTrue(isStopLossOrTakeProfitTrigger))
            {
                if (isTrue(isEqual(marginMode, null)))
                {
                    marginMode = "cross";
                }
                object marginModeRequest = ((bool) isTrue((isEqual(marginMode, "cross")))) ? "crossed" : "isolated";
                ((IDictionary<string,object>)request)["marginMode"] = marginModeRequest;
                object oneWayMode = this.safeBool(parameters, "oneWayMode", false);
                parameters = this.omit(parameters, "oneWayMode");
                object requestSide = side;
                if (isTrue(reduceOnly))
                {
                    if (isTrue(oneWayMode))
                    {
                        ((IDictionary<string,object>)request)["reduceOnly"] = "YES";
                    } else
                    {
                        // on bitget hedge mode if the position is long the side is always buy, and if the position is short the side is always sell
                        requestSide = ((bool) isTrue((isEqual(side, "buy")))) ? "sell" : "buy";
                        ((IDictionary<string,object>)request)["tradeSide"] = "Close";
                    }
                } else
                {
                    if (!isTrue(oneWayMode))
                    {
                        ((IDictionary<string,object>)request)["tradeSide"] = "Open";
                    }
                }
                ((IDictionary<string,object>)request)["side"] = requestSide;
            }
        } else if (isTrue(isEqual(marketType, "spot")))
        {
            if (isTrue(isTrue(isStopLossOrTakeProfitTrigger) || isTrue(isStopLossOrTakeProfit)))
            {
                throw new InvalidOrder ((string)add(this.id, " createOrder() does not support stop loss/take profit orders on spot markets, only swap markets")) ;
            }
            ((IDictionary<string,object>)request)["side"] = side;
            object quantity = null;
            object planType = null;
            object createMarketBuyOrderRequiresPrice = true;
            var createMarketBuyOrderRequiresPriceparametersVariable = this.handleOptionAndParams(parameters, "createOrder", "createMarketBuyOrderRequiresPrice", true);
            createMarketBuyOrderRequiresPrice = ((IList<object>)createMarketBuyOrderRequiresPriceparametersVariable)[0];
            parameters = ((IList<object>)createMarketBuyOrderRequiresPriceparametersVariable)[1];
            if (isTrue(isTrue(isMarketOrder) && isTrue((isEqual(side, "buy")))))
            {
                planType = "total";
                object cost = this.safeNumber(parameters, "cost");
                parameters = this.omit(parameters, "cost");
                if (isTrue(!isEqual(cost, null)))
                {
                    quantity = this.costToPrecision(symbol, cost);
                } else if (isTrue(createMarketBuyOrderRequiresPrice))
                {
                    if (isTrue(isEqual(price, null)))
                    {
                        throw new InvalidOrder ((string)add(this.id, " createOrder() requires the price argument for market buy orders to calculate the total cost to spend (amount * price), alternatively set the createMarketBuyOrderRequiresPrice option or param to false and pass the cost to spend in the amount argument")) ;
                    } else
                    {
                        object amountString = this.numberToString(amount);
                        object priceString = this.numberToString(price);
                        object quoteAmount = Precise.stringMul(amountString, priceString);
                        quantity = this.costToPrecision(symbol, quoteAmount);
                    }
                } else
                {
                    quantity = this.costToPrecision(symbol, amount);
                }
            } else
            {
                planType = "amount";
                quantity = this.amountToPrecision(symbol, amount);
            }
            if (isTrue(!isEqual(clientOrderId, null)))
            {
                ((IDictionary<string,object>)request)["clientOid"] = clientOrderId;
            }
            if (isTrue(!isEqual(marginMode, null)))
            {
                ((IDictionary<string,object>)request)["loanType"] = "normal";
                if (isTrue(isTrue(isTrue(createMarketBuyOrderRequiresPrice) && isTrue(isMarketOrder)) && isTrue((isEqual(side, "buy")))))
                {
                    ((IDictionary<string,object>)request)["quoteSize"] = quantity;
                } else
                {
                    ((IDictionary<string,object>)request)["baseSize"] = quantity;
                }
            } else
            {
                if (isTrue(!isEqual(quantity, null)))
                {
                    ((IDictionary<string,object>)request)["size"] = quantity;
                }
                if (isTrue(!isEqual(triggerPrice, null)))
                {
                    ((IDictionary<string,object>)request)["planType"] = planType;
                    ((IDictionary<string,object>)request)["triggerType"] = triggerType;
                    ((IDictionary<string,object>)request)["triggerPrice"] = this.priceToPrecision(symbol, triggerPrice);
                    if (isTrue(!isEqual(price, null)))
                    {
                        ((IDictionary<string,object>)request)["executePrice"] = this.priceToPrecision(symbol, price);
                    }
                }
            }
        } else
        {
            throw new NotSupported ((string)add(add(add(this.id, " createOrder() does not support "), marketType), " orders")) ;
        }
        return this.extend(request, parameters);
    }

    public async override Task<object> createOrders(object orders, object parameters = null)
    {
        /**
        * @method
        * @name bitget#createOrders
        * @description create a list of trade orders (all orders should be of the same symbol)
        * @see https://www.bitget.com/api-doc/spot/trade/Batch-Place-Orders
        * @see https://www.bitget.com/api-doc/contract/trade/Batch-Order
        * @see https://www.bitget.com/api-doc/margin/isolated/trade/Isolated-Batch-Order
        * @see https://www.bitget.com/api-doc/margin/cross/trade/Cross-Batch-Order
        * @param {Array} orders list of orders to create, each object should contain the parameters required by createOrder, namely symbol, type, side, amount, price and params
        * @param {object} [params] extra parameters specific to the api endpoint
        * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object ordersRequests = new List<object>() {};
        object symbol = null;
        object marginMode = null;
        for (object i = 0; isLessThan(i, getArrayLength(orders)); postFixIncrement(ref i))
        {
            object rawOrder = getValue(orders, i);
            object marketId = this.safeString(rawOrder, "symbol");
            if (isTrue(isEqual(symbol, null)))
            {
                symbol = marketId;
            } else
            {
                if (isTrue(!isEqual(symbol, marketId)))
                {
                    throw new BadRequest ((string)add(this.id, " createOrders() requires all orders to have the same symbol")) ;
                }
            }
            object type = this.safeString(rawOrder, "type");
            object side = this.safeString(rawOrder, "side");
            object amount = this.safeValue(rawOrder, "amount");
            object price = this.safeValue(rawOrder, "price");
            object orderParams = this.safeValue(rawOrder, "params", new Dictionary<string, object>() {});
            object marginResult = this.handleMarginModeAndParams("createOrders", orderParams);
            object currentMarginMode = getValue(marginResult, 0);
            if (isTrue(!isEqual(currentMarginMode, null)))
            {
                if (isTrue(isEqual(marginMode, null)))
                {
                    marginMode = currentMarginMode;
                } else
                {
                    if (isTrue(!isEqual(marginMode, currentMarginMode)))
                    {
                        throw new BadRequest ((string)add(this.id, " createOrders() requires all orders to have the same margin mode (isolated or cross)")) ;
                    }
                }
            }
            object orderRequest = this.createOrderRequest(marketId, type, side, amount, price, orderParams);
            ((IList<object>)ordersRequests).Add(orderRequest);
        }
        object sandboxMode = this.safeBool(this.options, "sandboxMode", false);
        object market = null;
        if (isTrue(sandboxMode))
        {
            object sandboxSymbol = this.convertSymbolForSandbox(symbol);
            market = this.market(sandboxSymbol);
        } else
        {
            market = this.market(symbol);
        }
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
            { "orderList", ordersRequests },
        };
        object response = null;
        if (isTrue(isTrue((getValue(market, "swap"))) || isTrue((getValue(market, "future")))))
        {
            if (isTrue(isEqual(marginMode, null)))
            {
                marginMode = "cross";
            }
            object marginModeRequest = ((bool) isTrue((isEqual(marginMode, "cross")))) ? "crossed" : "isolated";
            ((IDictionary<string,object>)request)["marginMode"] = marginModeRequest;
            ((IDictionary<string,object>)request)["marginCoin"] = getValue(market, "settleId");
            object productType = null;
            var productTypeparametersVariable = this.handleProductTypeAndParams(market, parameters);
            productType = ((IList<object>)productTypeparametersVariable)[0];
            parameters = ((IList<object>)productTypeparametersVariable)[1];
            ((IDictionary<string,object>)request)["productType"] = productType;
            response = await this.privateMixPostV2MixOrderBatchPlaceOrder(request);
        } else if (isTrue(isEqual(marginMode, "isolated")))
        {
            response = await this.privateMarginPostV2MarginIsolatedBatchPlaceOrder(request);
        } else if (isTrue(isEqual(marginMode, "cross")))
        {
            response = await this.privateMarginPostV2MarginCrossedBatchPlaceOrder(request);
        } else
        {
            response = await this.privateSpotPostV2SpotTradeBatchOrders(request);
        }
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1700703539416,
        //         "data": {
        //             "successList": [
        //                 {
        //                     "orderId": "1111397214281175046",
        //                     "clientOid": "766d3fc3-7321-4406-a689-15c9987a2e75"
        //                 },
        //             ],
        //             "failureList": [
        //                 {
        //                     "orderId": "",
        //                     "clientOid": "d1b75cb3-cc15-4ede-ad4c-3937396f75ab",
        //                     "errorMsg": "less than the minimum amount 5 USDT",
        //                     "errorCode": "45110"
        //                 },
        //             ]
        //         }
        //     }
        //
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        object failure = this.safeValue(data, "failureList", new List<object>() {});
        object orderInfo = this.safeValue(data, "successList", new List<object>() {});
        object both = this.arrayConcat(orderInfo, failure);
        return this.parseOrders(both, market);
    }

    public async override Task<object> editOrder(object id, object symbol, object type, object side, object amount = null, object price = null, object parameters = null)
    {
        /**
        * @method
        * @name bitget#editOrder
        * @description edit a trade order
        * @see https://www.bitget.com/api-doc/spot/plan/Modify-Plan-Order
        * @see https://www.bitget.com/api-doc/contract/trade/Modify-Order
        * @see https://www.bitget.com/api-doc/contract/plan/Modify-Tpsl-Order
        * @see https://www.bitget.com/api-doc/contract/plan/Modify-Plan-Order
        * @param {string} id cancel order id
        * @param {string} symbol unified symbol of the market to create an order in
        * @param {string} type 'market' or 'limit'
        * @param {string} side 'buy' or 'sell'
        * @param {float} amount how much you want to trade in units of the base currency
        * @param {float} [price] the price at which the order is to be fullfilled, in units of the base currency, ignored in market orders
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {float} [params.triggerPrice] the price that a trigger order is triggered at
        * @param {float} [params.stopLossPrice] *swap only* The price at which a stop loss order is triggered at
        * @param {float} [params.takeProfitPrice] *swap only* The price at which a take profit order is triggered at
        * @param {object} [params.takeProfit] *takeProfit object in params* containing the triggerPrice at which the attached take profit order will be triggered (perpetual swap markets only)
        * @param {float} [params.takeProfit.triggerPrice] *swap only* take profit trigger price
        * @param {object} [params.stopLoss] *stopLoss object in params* containing the triggerPrice at which the attached stop loss order will be triggered (perpetual swap markets only)
        * @param {float} [params.stopLoss.triggerPrice] *swap only* stop loss trigger price
        * @param {float} [params.stopLoss.price] *swap only* the execution price for a stop loss attached to a trigger order
        * @param {float} [params.takeProfit.price] *swap only* the execution price for a take profit attached to a trigger order
        * @param {string} [params.stopLoss.type] *swap only* the type for a stop loss attached to a trigger order, 'fill_price', 'index_price' or 'mark_price', default is 'mark_price'
        * @param {string} [params.takeProfit.type] *swap only* the type for a take profit attached to a trigger order, 'fill_price', 'index_price' or 'mark_price', default is 'mark_price'
        * @param {string} [params.trailingPercent] *swap and future only* the percent to trail away from the current market price, rate can not be greater than 10
        * @param {string} [params.trailingTriggerPrice] *swap and future only* the price to trigger a trailing stop order, default uses the price argument
        * @param {string} [params.newTriggerType] *swap and future only* 'fill_price', 'mark_price' or 'index_price'
        * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object sandboxMode = this.safeBool(this.options, "sandboxMode", false);
        object market = null;
        if (isTrue(sandboxMode))
        {
            object sandboxSymbol = this.convertSymbolForSandbox(symbol);
            market = this.market(sandboxSymbol);
        } else
        {
            market = this.market(symbol);
        }
        object request = new Dictionary<string, object>() {
            { "orderId", id },
        };
        object isMarketOrder = isEqual(type, "market");
        object triggerPrice = this.safeValue2(parameters, "stopPrice", "triggerPrice");
        object isTriggerOrder = !isEqual(triggerPrice, null);
        object stopLossPrice = this.safeValue(parameters, "stopLossPrice");
        object isStopLossOrder = !isEqual(stopLossPrice, null);
        object takeProfitPrice = this.safeValue(parameters, "takeProfitPrice");
        object isTakeProfitOrder = !isEqual(takeProfitPrice, null);
        object stopLoss = this.safeValue(parameters, "stopLoss");
        object takeProfit = this.safeValue(parameters, "takeProfit");
        object isStopLoss = !isEqual(stopLoss, null);
        object isTakeProfit = !isEqual(takeProfit, null);
        object trailingTriggerPrice = this.safeString(parameters, "trailingTriggerPrice", this.numberToString(price));
        object trailingPercent = this.safeString2(parameters, "trailingPercent", "newCallbackRatio");
        object isTrailingPercentOrder = !isEqual(trailingPercent, null);
        if (isTrue(isGreaterThan(this.sum(isTriggerOrder, isStopLossOrder, isTakeProfitOrder, isTrailingPercentOrder), 1)))
        {
            throw new ExchangeError ((string)add(this.id, " editOrder() params can only contain one of triggerPrice, stopLossPrice, takeProfitPrice, trailingPercent")) ;
        }
        object clientOrderId = this.safeString2(parameters, "clientOid", "clientOrderId");
        if (isTrue(!isEqual(clientOrderId, null)))
        {
            ((IDictionary<string,object>)request)["clientOid"] = clientOrderId;
        }
        parameters = this.omit(parameters, new List<object>() {"stopPrice", "triggerType", "stopLossPrice", "takeProfitPrice", "stopLoss", "takeProfit", "clientOrderId", "trailingTriggerPrice", "trailingPercent"});
        object response = null;
        if (isTrue(getValue(market, "spot")))
        {
            if (isTrue(isEqual(triggerPrice, null)))
            {
                throw new NotSupported ((string)add(this.id, "editOrder() only supports plan/trigger spot orders")) ;
            }
            object editMarketBuyOrderRequiresPrice = this.safeBool(this.options, "editMarketBuyOrderRequiresPrice", true);
            if (isTrue(isTrue(isTrue(editMarketBuyOrderRequiresPrice) && isTrue(isMarketOrder)) && isTrue((isEqual(side, "buy")))))
            {
                if (isTrue(isEqual(price, null)))
                {
                    throw new InvalidOrder ((string)add(this.id, " editOrder() requires price argument for market buy orders on spot markets to calculate the total amount to spend (amount * price), alternatively set the editMarketBuyOrderRequiresPrice option to false and pass in the cost to spend into the amount parameter")) ;
                } else
                {
                    object amountString = this.numberToString(amount);
                    object priceString = this.numberToString(price);
                    object cost = this.parseNumber(Precise.stringMul(amountString, priceString));
                    ((IDictionary<string,object>)request)["size"] = this.priceToPrecision(symbol, cost);
                }
            } else
            {
                ((IDictionary<string,object>)request)["size"] = this.amountToPrecision(symbol, amount);
            }
            ((IDictionary<string,object>)request)["orderType"] = type;
            ((IDictionary<string,object>)request)["triggerPrice"] = this.priceToPrecision(symbol, triggerPrice);
            ((IDictionary<string,object>)request)["executePrice"] = this.priceToPrecision(symbol, price);
            response = await this.privateSpotPostV2SpotTradeModifyPlanOrder(this.extend(request, parameters));
        } else
        {
            if (isTrue(isTrue((!isTrue(getValue(market, "swap")))) && isTrue((!isTrue(getValue(market, "future"))))))
            {
                throw new NotSupported ((string)add(add(add(this.id, " editOrder() does not support "), getValue(market, "type")), " orders")) ;
            }
            ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
            object productType = null;
            var productTypeparametersVariable = this.handleProductTypeAndParams(market, parameters);
            productType = ((IList<object>)productTypeparametersVariable)[0];
            parameters = ((IList<object>)productTypeparametersVariable)[1];
            ((IDictionary<string,object>)request)["productType"] = productType;
            if (isTrue(!isTrue(isTakeProfitOrder) && !isTrue(isStopLossOrder)))
            {
                ((IDictionary<string,object>)request)["newSize"] = this.amountToPrecision(symbol, amount);
                if (isTrue(isTrue((!isEqual(price, null))) && !isTrue(isTrailingPercentOrder)))
                {
                    ((IDictionary<string,object>)request)["newPrice"] = this.priceToPrecision(symbol, price);
                }
            }
            if (isTrue(isTrailingPercentOrder))
            {
                if (!isTrue(isMarketOrder))
                {
                    throw new BadRequest ((string)add(this.id, " editOrder() bitget trailing orders must be market orders")) ;
                }
                if (isTrue(!isEqual(trailingTriggerPrice, null)))
                {
                    ((IDictionary<string,object>)request)["newTriggerPrice"] = this.priceToPrecision(symbol, trailingTriggerPrice);
                }
                ((IDictionary<string,object>)request)["newCallbackRatio"] = trailingPercent;
                response = await this.privateMixPostV2MixOrderModifyPlanOrder(this.extend(request, parameters));
            } else if (isTrue(isTrue(isTakeProfitOrder) || isTrue(isStopLossOrder)))
            {
                ((IDictionary<string,object>)request)["marginCoin"] = getValue(market, "settleId");
                ((IDictionary<string,object>)request)["size"] = this.amountToPrecision(symbol, amount);
                ((IDictionary<string,object>)request)["executePrice"] = this.priceToPrecision(symbol, price);
                if (isTrue(isStopLossOrder))
                {
                    ((IDictionary<string,object>)request)["triggerPrice"] = this.priceToPrecision(symbol, stopLossPrice);
                } else if (isTrue(isTakeProfitOrder))
                {
                    ((IDictionary<string,object>)request)["triggerPrice"] = this.priceToPrecision(symbol, takeProfitPrice);
                }
                response = await this.privateMixPostV2MixOrderModifyTpslOrder(this.extend(request, parameters));
            } else if (isTrue(isTriggerOrder))
            {
                ((IDictionary<string,object>)request)["newTriggerPrice"] = this.priceToPrecision(symbol, triggerPrice);
                if (isTrue(isStopLoss))
                {
                    object slTriggerPrice = this.safeNumber2(stopLoss, "triggerPrice", "stopPrice");
                    ((IDictionary<string,object>)request)["newStopLossTriggerPrice"] = this.priceToPrecision(symbol, slTriggerPrice);
                    object slPrice = this.safeNumber(stopLoss, "price");
                    ((IDictionary<string,object>)request)["newStopLossExecutePrice"] = this.priceToPrecision(symbol, slPrice);
                    object slType = this.safeString(stopLoss, "type", "mark_price");
                    ((IDictionary<string,object>)request)["newStopLossTriggerType"] = slType;
                }
                if (isTrue(isTakeProfit))
                {
                    object tpTriggerPrice = this.safeNumber2(takeProfit, "triggerPrice", "stopPrice");
                    ((IDictionary<string,object>)request)["newSurplusTriggerPrice"] = this.priceToPrecision(symbol, tpTriggerPrice);
                    object tpPrice = this.safeNumber(takeProfit, "price");
                    ((IDictionary<string,object>)request)["newStopSurplusExecutePrice"] = this.priceToPrecision(symbol, tpPrice);
                    object tpType = this.safeString(takeProfit, "type", "mark_price");
                    ((IDictionary<string,object>)request)["newStopSurplusTriggerType"] = tpType;
                }
                response = await this.privateMixPostV2MixOrderModifyPlanOrder(this.extend(request, parameters));
            } else
            {
                object defaultNewClientOrderId = this.uuid();
                object newClientOrderId = this.safeString2(parameters, "newClientOid", "newClientOrderId", defaultNewClientOrderId);
                parameters = this.omit(parameters, "newClientOrderId");
                ((IDictionary<string,object>)request)["newClientOid"] = newClientOrderId;
                if (isTrue(isStopLoss))
                {
                    object slTriggerPrice = this.safeValue2(stopLoss, "triggerPrice", "stopPrice");
                    ((IDictionary<string,object>)request)["newPresetStopLossPrice"] = this.priceToPrecision(symbol, slTriggerPrice);
                }
                if (isTrue(isTakeProfit))
                {
                    object tpTriggerPrice = this.safeValue2(takeProfit, "triggerPrice", "stopPrice");
                    ((IDictionary<string,object>)request)["newPresetStopSurplusPrice"] = this.priceToPrecision(symbol, tpTriggerPrice);
                }
                response = await this.privateMixPostV2MixOrderModifyOrder(this.extend(request, parameters));
            }
        }
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1700708275737,
        //         "data": {
        //             "clientOid": "abe95dbe-6081-4a6f-a2d3-ae49601cd459",
        //             "orderId": null
        //         }
        //     }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        return this.parseOrder(data, market);
    }

    public async override Task<object> cancelOrder(object id, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name bitget#cancelOrder
        * @description cancels an open order
        * @see https://www.bitget.com/api-doc/spot/trade/Cancel-Order
        * @see https://www.bitget.com/api-doc/spot/plan/Cancel-Plan-Order
        * @see https://www.bitget.com/api-doc/contract/trade/Cancel-Order
        * @see https://www.bitget.com/api-doc/contract/plan/Cancel-Plan-Order
        * @see https://www.bitget.com/api-doc/margin/cross/trade/Cross-Cancel-Order
        * @see https://www.bitget.com/api-doc/margin/isolated/trade/Isolated-Cancel-Order
        * @param {string} id order id
        * @param {string} symbol unified symbol of the market the order was made in
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {string} [params.marginMode] 'isolated' or 'cross' for spot margin trading
        * @param {boolean} [params.stop] set to true for canceling trigger orders
        * @param {string} [params.planType] *swap only* either profit_plan, loss_plan, normal_plan, pos_profit, pos_loss, moving_plan or track_plan
        * @param {boolean} [params.trailing] set to true if you want to cancel a trailing order
        * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " cancelOrder() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object sandboxMode = this.safeBool(this.options, "sandboxMode", false);
        object market = null;
        if (isTrue(sandboxMode))
        {
            object sandboxSymbol = this.convertSymbolForSandbox(symbol);
            market = this.market(sandboxSymbol);
        } else
        {
            market = this.market(symbol);
        }
        object marginMode = null;
        object response = null;
        var marginModeparametersVariable = this.handleMarginModeAndParams("cancelOrder", parameters);
        marginMode = ((IList<object>)marginModeparametersVariable)[0];
        parameters = ((IList<object>)marginModeparametersVariable)[1];
        object request = new Dictionary<string, object>() {};
        object trailing = this.safeValue(parameters, "trailing");
        object stop = this.safeValue2(parameters, "stop", "trigger");
        parameters = this.omit(parameters, new List<object>() {"stop", "trigger", "trailing"});
        if (!isTrue((isTrue(getValue(market, "spot")) && isTrue(stop))))
        {
            ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
        }
        if (!isTrue((isTrue((isTrue(getValue(market, "swap")) || isTrue(getValue(market, "future")))) && isTrue(stop))))
        {
            ((IDictionary<string,object>)request)["orderId"] = id;
        }
        if (isTrue(isTrue((getValue(market, "swap"))) || isTrue((getValue(market, "future")))))
        {
            object productType = null;
            var productTypeparametersVariable = this.handleProductTypeAndParams(market, parameters);
            productType = ((IList<object>)productTypeparametersVariable)[0];
            parameters = ((IList<object>)productTypeparametersVariable)[1];
            ((IDictionary<string,object>)request)["productType"] = productType;
            if (isTrue(isTrue(stop) || isTrue(trailing)))
            {
                object orderIdList = new List<object>() {};
                object orderId = new Dictionary<string, object>() {
                    { "orderId", id },
                };
                ((IList<object>)orderIdList).Add(orderId);
                ((IDictionary<string,object>)request)["orderIdList"] = orderIdList;
            }
            if (isTrue(trailing))
            {
                object planType = this.safeString(parameters, "planType", "track_plan");
                ((IDictionary<string,object>)request)["planType"] = planType;
                response = await this.privateMixPostV2MixOrderCancelPlanOrder(this.extend(request, parameters));
            } else if (isTrue(stop))
            {
                response = await this.privateMixPostV2MixOrderCancelPlanOrder(this.extend(request, parameters));
            } else
            {
                response = await this.privateMixPostV2MixOrderCancelOrder(this.extend(request, parameters));
            }
        } else if (isTrue(getValue(market, "spot")))
        {
            if (isTrue(!isEqual(marginMode, null)))
            {
                if (isTrue(isEqual(marginMode, "isolated")))
                {
                    response = await this.privateMarginPostV2MarginIsolatedCancelOrder(this.extend(request, parameters));
                } else if (isTrue(isEqual(marginMode, "cross")))
                {
                    response = await this.privateMarginPostV2MarginCrossedCancelOrder(this.extend(request, parameters));
                }
            } else
            {
                if (isTrue(stop))
                {
                    response = await this.privateSpotPostV2SpotTradeCancelPlanOrder(this.extend(request, parameters));
                } else
                {
                    response = await this.privateSpotPostV2SpotTradeCancelOrder(this.extend(request, parameters));
                }
            }
        } else
        {
            throw new NotSupported ((string)add(add(add(this.id, " cancelOrder() does not support "), getValue(market, "type")), " orders")) ;
        }
        //
        // spot, swap, future and spot margin
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1697690413177,
        //         "data": {
        //             "orderId": "1098758604547850241",
        //             "clientOid": "1098758604585598977"
        //         }
        //     }
        //
        // swap trigger
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1700711311791,
        //         "data": {
        //             "successList": [
        //                 {
        //                     "clientOid": "1111428059067125760",
        //                     "orderId": "1111428059067125761"
        //                 }
        //             ],
        //             "failureList": []
        //         }
        //     }
        //
        // spot trigger
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1700711728063,
        //         "data": {
        //             "result": "success"
        //         }
        //     }
        //
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        object order = null;
        if (isTrue(isTrue((isTrue(getValue(market, "swap")) || isTrue(getValue(market, "future")))) && isTrue(stop)))
        {
            object orderInfo = this.safeValue(data, "successList", new List<object>() {});
            order = getValue(orderInfo, 0);
        } else
        {
            order = data;
        }
        return this.parseOrder(order, market);
    }

    public async virtual Task<object> cancelOrders(object ids, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name bitget#cancelOrders
        * @description cancel multiple orders
        * @see https://www.bitget.com/api-doc/spot/trade/Batch-Cancel-Orders
        * @see https://www.bitget.com/api-doc/contract/trade/Batch-Cancel-Orders
        * @see https://www.bitget.com/api-doc/contract/plan/Cancel-Plan-Order
        * @see https://www.bitget.com/api-doc/margin/cross/trade/Cross-Batch-Cancel-Order
        * @see https://www.bitget.com/api-doc/margin/isolated/trade/Isolated-Batch-Cancel-Orders
        * @param {string[]} ids order ids
        * @param {string} symbol unified market symbol, default is undefined
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {string} [params.marginMode] 'isolated' or 'cross' for spot margin trading
        * @param {boolean} [params.stop] *contract only* set to true for canceling trigger orders
        * @returns {object} an array of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " cancelOrders() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object sandboxMode = this.safeBool(this.options, "sandboxMode", false);
        object market = null;
        if (isTrue(sandboxMode))
        {
            object sandboxSymbol = this.convertSymbolForSandbox(symbol);
            market = this.market(sandboxSymbol);
        } else
        {
            market = this.market(symbol);
        }
        object marginMode = null;
        var marginModeparametersVariable = this.handleMarginModeAndParams("cancelOrders", parameters);
        marginMode = ((IList<object>)marginModeparametersVariable)[0];
        parameters = ((IList<object>)marginModeparametersVariable)[1];
        object stop = this.safeValue2(parameters, "stop", "trigger");
        parameters = this.omit(parameters, new List<object>() {"stop", "trigger"});
        object orderIdList = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(ids)); postFixIncrement(ref i))
        {
            object individualId = getValue(ids, i);
            object orderId = new Dictionary<string, object>() {
                { "orderId", individualId },
            };
            ((IList<object>)orderIdList).Add(orderId);
        }
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        if (isTrue(isTrue(getValue(market, "spot")) && isTrue((isEqual(marginMode, null)))))
        {
            ((IDictionary<string,object>)request)["orderList"] = orderIdList;
        } else
        {
            ((IDictionary<string,object>)request)["orderIdList"] = orderIdList;
        }
        object response = null;
        if (isTrue(getValue(market, "spot")))
        {
            if (isTrue(!isEqual(marginMode, null)))
            {
                if (isTrue(isEqual(marginMode, "cross")))
                {
                    response = await this.privateMarginPostV2MarginCrossedBatchCancelOrder(this.extend(request, parameters));
                } else
                {
                    response = await this.privateMarginPostV2MarginIsolatedBatchCancelOrder(this.extend(request, parameters));
                }
            } else
            {
                response = await this.privateSpotPostV2SpotTradeBatchCancelOrder(this.extend(request, parameters));
            }
        } else
        {
            object productType = null;
            var productTypeparametersVariable = this.handleProductTypeAndParams(market, parameters);
            productType = ((IList<object>)productTypeparametersVariable)[0];
            parameters = ((IList<object>)productTypeparametersVariable)[1];
            ((IDictionary<string,object>)request)["productType"] = productType;
            if (isTrue(stop))
            {
                response = await this.privateMixPostV2MixOrderCancelPlanOrder(this.extend(request, parameters));
            } else
            {
                response = await this.privateMixPostV2MixOrderBatchCancelOrders(this.extend(request, parameters));
            }
        }
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": "1680008815965",
        //         "data": {
        //             "successList": [
        //                 {
        //                     "orderId": "1024598257429823488",
        //                     "clientOid": "876493ce-c287-4bfc-9f4a-8b1905881313"
        //                 },
        //             ],
        //             "failureList": []
        //         }
        //     }
        //
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        object orders = this.safeList(data, "successList", new List<object>() {});
        return this.parseOrders(orders, market);
    }

    public async override Task<object> cancelAllOrders(object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name bitget#cancelAllOrders
        * @description cancel all open orders
        * @see https://www.bitget.com/api-doc/spot/trade/Cancel-Symbol-Orders
        * @see https://www.bitget.com/api-doc/spot/plan/Batch-Cancel-Plan-Order
        * @see https://www.bitget.com/api-doc/contract/trade/Batch-Cancel-Orders
        * @see https://bitgetlimited.github.io/apidoc/en/margin/#isolated-batch-cancel-orders
        * @see https://bitgetlimited.github.io/apidoc/en/margin/#cross-batch-cancel-order
        * @param {string} symbol unified market symbol
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {string} [params.marginMode] 'isolated' or 'cross' for spot margin trading
        * @param {boolean} [params.stop] *contract only* set to true for canceling trigger orders
        * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " cancelAllOrders() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object sandboxMode = this.safeBool(this.options, "sandboxMode", false);
        object market = null;
        if (isTrue(sandboxMode))
        {
            object sandboxSymbol = this.convertSymbolForSandbox(symbol);
            market = this.market(sandboxSymbol);
        } else
        {
            market = this.market(symbol);
        }
        object marginMode = null;
        var marginModeparametersVariable = this.handleMarginModeAndParams("cancelAllOrders", parameters);
        marginMode = ((IList<object>)marginModeparametersVariable)[0];
        parameters = ((IList<object>)marginModeparametersVariable)[1];
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object stop = this.safeBool2(parameters, "stop", "trigger");
        parameters = this.omit(parameters, new List<object>() {"stop", "trigger"});
        object response = null;
        if (isTrue(getValue(market, "spot")))
        {
            if (isTrue(!isEqual(marginMode, null)))
            {
                if (isTrue(isEqual(marginMode, "cross")))
                {
                    response = await this.privateMarginPostMarginV1CrossOrderBatchCancelOrder(this.extend(request, parameters));
                } else
                {
                    response = await this.privateMarginPostMarginV1IsolatedOrderBatchCancelOrder(this.extend(request, parameters));
                }
            } else
            {
                if (isTrue(stop))
                {
                    object stopRequest = new Dictionary<string, object>() {
                        { "symbolList", new List<object>() {getValue(market, "id")} },
                    };
                    response = await this.privateSpotPostV2SpotTradeBatchCancelPlanOrder(this.extend(stopRequest, parameters));
                } else
                {
                    response = await this.privateSpotPostV2SpotTradeCancelSymbolOrder(this.extend(request, parameters));
                }
            }
        } else
        {
            object productType = null;
            var productTypeparametersVariable = this.handleProductTypeAndParams(market, parameters);
            productType = ((IList<object>)productTypeparametersVariable)[0];
            parameters = ((IList<object>)productTypeparametersVariable)[1];
            ((IDictionary<string,object>)request)["productType"] = productType;
            if (isTrue(stop))
            {
                response = await this.privateMixPostV2MixOrderCancelPlanOrder(this.extend(request, parameters));
            } else
            {
                response = await this.privateMixPostV2MixOrderBatchCancelOrders(this.extend(request, parameters));
            }
        }
        //
        // spot
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1700716953996,
        //         "data": {
        //             "symbol": "BTCUSDT"
        //         }
        //     }
        //
        // swap
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": "1680008815965",
        //         "data": {
        //             "successList": [
        //                 {
        //                     "orderId": "1024598257429823488",
        //                     "clientOid": "876493ce-c287-4bfc-9f4a-8b1905881313"
        //                 },
        //             ],
        //             "failureList": []
        //         }
        //     }
        //
        // spot margin
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1700717155622,
        //         "data": {
        //             "resultList": [
        //                 {
        //                     "orderId": "1111453253721796609",
        //                     "clientOid": "2ae7fc8a4ff949b6b60d770ca3950e2d"
        //                 },
        //             ],
        //             "failure": []
        //         }
        //     }
        //
        return response;
    }

    public async override Task<object> fetchOrder(object id, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name bitget#fetchOrder
        * @description fetches information on an order made by the user
        * @see https://www.bitget.com/api-doc/spot/trade/Get-Order-Info
        * @see https://www.bitget.com/api-doc/contract/trade/Get-Order-Details
        * @param {string} symbol unified symbol of the market the order was made in
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchOrder() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object sandboxMode = this.safeBool(this.options, "sandboxMode", false);
        object market = null;
        if (isTrue(sandboxMode))
        {
            object sandboxSymbol = this.convertSymbolForSandbox(symbol);
            market = this.market(sandboxSymbol);
        } else
        {
            market = this.market(symbol);
        }
        object request = new Dictionary<string, object>() {
            { "orderId", id },
        };
        object response = null;
        if (isTrue(getValue(market, "spot")))
        {
            response = await this.privateSpotGetV2SpotTradeOrderInfo(this.extend(request, parameters));
        } else if (isTrue(isTrue(getValue(market, "swap")) || isTrue(getValue(market, "future"))))
        {
            ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
            object productType = null;
            var productTypeparametersVariable = this.handleProductTypeAndParams(market, parameters);
            productType = ((IList<object>)productTypeparametersVariable)[0];
            parameters = ((IList<object>)productTypeparametersVariable)[1];
            ((IDictionary<string,object>)request)["productType"] = productType;
            response = await this.privateMixGetV2MixOrderDetail(this.extend(request, parameters));
        } else
        {
            throw new NotSupported ((string)add(add(add(this.id, " fetchOrder() does not support "), getValue(market, "type")), " orders")) ;
        }
        //
        // spot
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1700719076263,
        //         "data": [
        //             {
        //                 "userId": "7264631750",
        //                 "symbol": "BTCUSDT",
        //                 "orderId": "1111461743123927040",
        //                 "clientOid": "63f95110-93b5-4309-8f77-46339f1bcf3c",
        //                 "price": "25000.0000000000000000",
        //                 "size": "0.0002000000000000",
        //                 "orderType": "limit",
        //                 "side": "buy",
        //                 "status": "live",
        //                 "priceAvg": "0",
        //                 "baseVolume": "0.0000000000000000",
        //                 "quoteVolume": "0.0000000000000000",
        //                 "enterPointSource": "API",
        //                 "feeDetail": "",
        //                 "orderSource": "normal",
        //                 "cTime": "1700719050198",
        //                 "uTime": "1700719050198"
        //             }
        //         ]
        //     }
        //
        // swap and future
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1700719918781,
        //         "data": {
        //             "symbol": "BTCUSDT",
        //             "size": "0.001",
        //             "orderId": "1111465253393825792",
        //             "clientOid": "1111465253431574529",
        //             "baseVolume": "0",
        //             "fee": "0",
        //             "price": "27000",
        //             "priceAvg": "",
        //             "state": "live",
        //             "side": "buy",
        //             "force": "gtc",
        //             "totalProfits": "0",
        //             "posSide": "long",
        //             "marginCoin": "USDT",
        //             "presetStopSurplusPrice": "",
        //             "presetStopLossPrice": "",
        //             "quoteVolume": "0",
        //             "orderType": "limit",
        //             "leverage": "20",
        //             "marginMode": "crossed",
        //             "reduceOnly": "NO",
        //             "enterPointSource": "API",
        //             "tradeSide": "open",
        //             "posMode": "hedge_mode",
        //             "orderSource": "normal",
        //             "cTime": "1700719887120",
        //             "uTime": "1700719887120"
        //         }
        //     }
        //
        if (isTrue((response is string)))
        {
            response = parseJson(response);
        }
        object data = this.safeDict(response, "data");
        if (isTrue(isTrue((!isEqual(data, null))) && !isTrue(((data is IList<object>) || (data.GetType().IsGenericType && data.GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>)))))))
        {
            return this.parseOrder(data, market);
        }
        object dataList = this.safeList(response, "data", new List<object>() {});
        object first = this.safeDict(dataList, 0, new Dictionary<string, object>() {});
        return this.parseOrder(first, market);
    }

    public async override Task<object> fetchOpenOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bitget#fetchOpenOrders
        * @description fetch all unfilled currently open orders
        * @see https://www.bitget.com/api-doc/spot/trade/Get-Unfilled-Orders
        * @see https://www.bitget.com/api-doc/spot/plan/Get-Current-Plan-Order
        * @see https://www.bitget.com/api-doc/contract/trade/Get-Orders-Pending
        * @see https://www.bitget.com/api-doc/contract/plan/get-orders-plan-pending
        * @see https://www.bitget.com/api-doc/margin/cross/trade/Get-Cross-Open-Orders
        * @see https://www.bitget.com/api-doc/margin/isolated/trade/Isolated-Open-Orders
        * @param {string} symbol unified market symbol
        * @param {int} [since] the earliest time in ms to fetch open orders for
        * @param {int} [limit] the maximum number of open order structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {int} [params.until] the latest time in ms to fetch orders for
        * @param {string} [params.planType] *contract stop only* 'normal_plan': average trigger order, 'profit_loss': opened tp/sl orders, 'track_plan': trailing stop order, default is 'normal_plan'
        * @param {boolean} [params.stop] set to true for fetching trigger orders
        * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [available parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
        * @param {string} [params.isPlan] *swap only* 'plan' for stop orders and 'profit_loss' for tp/sl orders, default is 'plan'
        * @param {boolean} [params.trailing] set to true if you want to fetch trailing orders
        * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object sandboxMode = this.safeBool(this.options, "sandboxMode", false);
        object market = null;
        object type = null;
        object request = new Dictionary<string, object>() {};
        object marginMode = null;
        var marginModeparametersVariable = this.handleMarginModeAndParams("fetchOpenOrders", parameters);
        marginMode = ((IList<object>)marginModeparametersVariable)[0];
        parameters = ((IList<object>)marginModeparametersVariable)[1];
        if (isTrue(!isEqual(symbol, null)))
        {
            if (isTrue(sandboxMode))
            {
                object sandboxSymbol = this.convertSymbolForSandbox(symbol);
                market = this.market(sandboxSymbol);
            } else
            {
                market = this.market(symbol);
            }
            ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
            object defaultType = this.safeString2(this.options, "fetchOpenOrders", "defaultType", "spot");
            object marketType = ((bool) isTrue((inOp(market, "type")))) ? getValue(market, "type") : defaultType;
            type = this.safeString(parameters, "type", marketType);
        } else
        {
            object defaultType = this.safeString2(this.options, "fetchOpenOrders", "defaultType", "spot");
            type = this.safeString(parameters, "type", defaultType);
        }
        object paginate = false;
        var paginateparametersVariable = this.handleOptionAndParams(parameters, "fetchOpenOrders", "paginate");
        paginate = ((IList<object>)paginateparametersVariable)[0];
        parameters = ((IList<object>)paginateparametersVariable)[1];
        if (isTrue(paginate))
        {
            object cursorReceived = null;
            if (isTrue(isEqual(type, "spot")))
            {
                if (isTrue(!isEqual(marginMode, null)))
                {
                    cursorReceived = "minId";
                }
            } else
            {
                cursorReceived = "endId";
            }
            return await this.fetchPaginatedCallCursor("fetchOpenOrders", symbol, since, limit, parameters, cursorReceived, "idLessThan");
        }
        object response = null;
        object trailing = this.safeBool(parameters, "trailing");
        object stop = this.safeBool2(parameters, "stop", "trigger");
        object planTypeDefined = !isEqual(this.safeString(parameters, "planType"), null);
        object isStop = (isTrue(stop) || isTrue(planTypeDefined));
        parameters = this.omit(parameters, new List<object>() {"stop", "trigger", "trailing"});
        var requestparametersVariable = this.handleUntilOption("endTime", request, parameters);
        request = ((IList<object>)requestparametersVariable)[0];
        parameters = ((IList<object>)requestparametersVariable)[1];
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["startTime"] = since;
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        if (isTrue(isTrue(isTrue((isEqual(type, "swap"))) || isTrue((isEqual(type, "future")))) || isTrue((!isEqual(marginMode, null)))))
        {
            object clientOrderId = this.safeString2(parameters, "clientOid", "clientOrderId");
            parameters = this.omit(parameters, "clientOrderId");
            if (isTrue(!isEqual(clientOrderId, null)))
            {
                ((IDictionary<string,object>)request)["clientOid"] = clientOrderId;
            }
        }
        object query = null;
        query = this.omit(parameters, new List<object>() {"type"});
        if (isTrue(isEqual(type, "spot")))
        {
            if (isTrue(!isEqual(marginMode, null)))
            {
                if (isTrue(isEqual(since, null)))
                {
                    since = subtract(this.milliseconds(), 7776000000);
                    ((IDictionary<string,object>)request)["startTime"] = since;
                }
                if (isTrue(isEqual(marginMode, "isolated")))
                {
                    response = await this.privateMarginGetV2MarginIsolatedOpenOrders(this.extend(request, query));
                } else if (isTrue(isEqual(marginMode, "cross")))
                {
                    response = await this.privateMarginGetV2MarginCrossedOpenOrders(this.extend(request, query));
                }
            } else
            {
                if (isTrue(stop))
                {
                    response = await this.privateSpotGetV2SpotTradeCurrentPlanOrder(this.extend(request, query));
                } else
                {
                    response = await this.privateSpotGetV2SpotTradeUnfilledOrders(this.extend(request, query));
                }
            }
        } else
        {
            object productType = null;
            var productTypequeryVariable = this.handleProductTypeAndParams(market, query);
            productType = ((IList<object>)productTypequeryVariable)[0];
            query = ((IList<object>)productTypequeryVariable)[1];
            ((IDictionary<string,object>)request)["productType"] = productType;
            if (isTrue(trailing))
            {
                object planType = this.safeString(parameters, "planType", "track_plan");
                ((IDictionary<string,object>)request)["planType"] = planType;
                response = await this.privateMixGetV2MixOrderOrdersPlanPending(this.extend(request, query));
            } else if (isTrue(isStop))
            {
                object planType = this.safeString(query, "planType", "normal_plan");
                ((IDictionary<string,object>)request)["planType"] = planType;
                response = await this.privateMixGetV2MixOrderOrdersPlanPending(this.extend(request, query));
            } else
            {
                response = await this.privateMixGetV2MixOrderOrdersPending(this.extend(request, query));
            }
        }
        //
        // spot
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1700728123994,
        //         "data": [
        //             {
        //                 "userId": "7264631750",
        //                 "symbol": "BTCUSDT",
        //                 "orderId": "1111499608327360513",
        //                 "clientOid": "d0d4dad5-18d0-4869-a074-ec40bb47cba6",
        //                 "priceAvg": "25000.0000000000000000",
        //                 "size": "0.0002000000000000",
        //                 "orderType": "limit",
        //                 "side": "buy",
        //                 "status": "live",
        //                 "basePrice": "0",
        //                 "baseVolume": "0.0000000000000000",
        //                 "quoteVolume": "0.0000000000000000",
        //                 "enterPointSource": "WEB",
        //                 "orderSource": "normal",
        //                 "cTime": "1700728077966",
        //                 "uTime": "1700728077966"
        //             }
        //         ]
        //     }
        //
        // spot stop
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1700729361609,
        //         "data": {
        //             "nextFlag": false,
        //             "idLessThan": "1111503385931620352",
        //             "orderList": [
        //                 {
        //                     "orderId": "1111503385931620352",
        //                     "clientOid": "1111503385910648832",
        //                     "symbol": "BTCUSDT",
        //                     "size": "0.0002",
        //                     "planType": "AMOUNT",
        //                     "executePrice": "25000",
        //                     "triggerPrice": "26000",
        //                     "status": "live",
        //                     "orderType": "limit",
        //                     "side": "buy",
        //                     "triggerType": "fill_price",
        //                     "enterPointSource": "API",
        //                     "cTime": "1700728978617",
        //                     "uTime": "1700728978617"
        //                 }
        //             ]
        //         }
        //     }
        //
        // spot margin
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1700729887686,
        //         "data": {
        //             "orderList": [
        //                 {
        //                     "symbol": "BTCUSDT",
        //                     "orderType": "limit",
        //                     "enterPointSource": "WEB",
        //                     "orderId": "1111506377509580801",
        //                     "clientOid": "2043a3b59a60445f9d9f7365bf3e960c",
        //                     "loanType": "autoLoanAndRepay",
        //                     "price": "25000",
        //                     "side": "buy",
        //                     "status": "live",
        //                     "baseSize": "0.0002",
        //                     "quoteSize": "5",
        //                     "priceAvg": "0",
        //                     "size": "0",
        //                     "amount": "0",
        //                     "force": "gtc",
        //                     "cTime": "1700729691866",
        //                     "uTime": "1700729691866"
        //                 }
        //             ],
        //             "maxId": "1111506377509580801",
        //             "minId": "1111506377509580801"
        //         }
        //     }
        //
        // swap and future
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1700725609065,
        //         "data": {
        //             "entrustedList": [
        //                 {
        //                     "symbol": "BTCUSDT",
        //                     "size": "0.002",
        //                     "orderId": "1111488897767604224",
        //                     "clientOid": "1111488897805352960",
        //                     "baseVolume": "0",
        //                     "fee": "0",
        //                     "price": "25000",
        //                     "priceAvg": "",
        //                     "status": "live",
        //                     "side": "buy",
        //                     "force": "gtc",
        //                     "totalProfits": "0",
        //                     "posSide": "long",
        //                     "marginCoin": "USDT",
        //                     "quoteVolume": "0",
        //                     "leverage": "20",
        //                     "marginMode": "crossed",
        //                     "enterPointSource": "web",
        //                     "tradeSide": "open",
        //                     "posMode": "hedge_mode",
        //                     "orderType": "limit",
        //                     "orderSource": "normal",
        //                     "presetStopSurplusPrice": "",
        //                     "presetStopLossPrice": "",
        //                     "reduceOnly": "NO",
        //                     "cTime": "1700725524378",
        //                     "uTime": "1700725524378"
        //                 }
        //             ],
        //             "endId": "1111488897767604224"
        //         }
        //     }
        //
        // swap and future stop
        //
        //     {
        //         "code": "00000",\
        //         "msg": "success",
        //         "requestTime": 1700726417495,
        //         "data": {
        //             "entrustedList": [
        //                 {
        //                     "planType": "normal_plan",
        //                     "symbol": "BTCUSDT",
        //                     "size": "0.001",
        //                     "orderId": "1111491399869075457",
        //                     "clientOid": "1111491399869075456",
        //                     "price": "27000",
        //                     "callbackRatio": "",
        //                     "triggerPrice": "24000",
        //                     "triggerType": "mark_price",
        //                     "planStatus": "live",
        //                     "side": "buy",
        //                     "posSide": "long",
        //                     "marginCoin": "USDT",
        //                     "marginMode": "crossed",
        //                     "enterPointSource": "API",
        //                     "tradeSide": "open",
        //                     "posMode": "hedge_mode",
        //                     "orderType": "limit",
        //                     "stopSurplusTriggerPrice": "",
        //                     "stopSurplusExecutePrice": "",
        //                     "stopSurplusTriggerType": "fill_price",
        //                     "stopLossTriggerPrice": "",
        //                     "stopLossExecutePrice": "",
        //                     "stopLossTriggerType": "fill_price",
        //                     "cTime": "1700726120917",
        //                     "uTime": "1700726120917"
        //                 }
        //             ],
        //             "endId": "1111491399869075457"
        //         }
        //     }
        //
        object data = this.safeValue(response, "data");
        if (isTrue(isEqual(type, "spot")))
        {
            if (isTrue(isTrue((!isEqual(marginMode, null))) || isTrue(stop)))
            {
                object resultList = this.safeList(data, "orderList", new List<object>() {});
                return this.parseOrders(resultList, market, since, limit);
            }
        } else
        {
            object result = this.safeList(data, "entrustedList", new List<object>() {});
            return this.parseOrders(result, market, since, limit);
        }
        return this.parseOrders(data, market, since, limit);
    }

    public async override Task<object> fetchClosedOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bitget#fetchClosedOrders
        * @description fetches information on multiple closed orders made by the user
        * @see https://www.bitget.com/api-doc/spot/trade/Get-History-Orders
        * @see https://www.bitget.com/api-doc/spot/plan/Get-History-Plan-Order
        * @see https://www.bitget.com/api-doc/contract/trade/Get-Orders-History
        * @see https://www.bitget.com/api-doc/contract/plan/orders-plan-history
        * @see https://www.bitget.com/api-doc/margin/cross/trade/Get-Cross-Order-History
        * @see https://www.bitget.com/api-doc/margin/isolated/trade/Get-Isolated-Order-History
        * @param {string} symbol unified market symbol of the closed orders
        * @param {int} [since] timestamp in ms of the earliest order
        * @param {int} [limit] the max number of closed orders to return
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {int} [params.until] the latest time in ms to fetch entries for
        * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [available parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
        * @param {string} [params.isPlan] *swap only* 'plan' for stop orders and 'profit_loss' for tp/sl orders, default is 'plan'
        * @param {string} [params.productType] *contract only* 'USDT-FUTURES', 'USDC-FUTURES', 'COIN-FUTURES', 'SUSDT-FUTURES', 'SUSDC-FUTURES' or 'SCOIN-FUTURES'
        * @param {boolean} [params.trailing] set to true if you want to fetch trailing orders
        * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object orders = await this.fetchCanceledAndClosedOrders(symbol, since, limit, parameters);
        return this.filterBy(orders, "status", "closed");
    }

    public async virtual Task<object> fetchCanceledOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bitget#fetchCanceledOrders
        * @description fetches information on multiple canceled orders made by the user
        * @see https://www.bitget.com/api-doc/spot/trade/Get-History-Orders
        * @see https://www.bitget.com/api-doc/spot/plan/Get-History-Plan-Order
        * @see https://www.bitget.com/api-doc/contract/trade/Get-Orders-History
        * @see https://www.bitget.com/api-doc/contract/plan/orders-plan-history
        * @see https://www.bitget.com/api-doc/margin/cross/trade/Get-Cross-Order-History
        * @see https://www.bitget.com/api-doc/margin/isolated/trade/Get-Isolated-Order-History
        * @param {string} symbol unified market symbol of the canceled orders
        * @param {int} [since] timestamp in ms of the earliest order
        * @param {int} [limit] the max number of canceled orders to return
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {int} [params.until] the latest time in ms to fetch entries for
        * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [available parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
        * @param {string} [params.isPlan] *swap only* 'plan' for stop orders and 'profit_loss' for tp/sl orders, default is 'plan'
        * @param {string} [params.productType] *contract only* 'USDT-FUTURES', 'USDC-FUTURES', 'COIN-FUTURES', 'SUSDT-FUTURES', 'SUSDC-FUTURES' or 'SCOIN-FUTURES'
        * @param {boolean} [params.trailing] set to true if you want to fetch trailing orders
        * @returns {object} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object orders = await this.fetchCanceledAndClosedOrders(symbol, since, limit, parameters);
        return this.filterBy(orders, "status", "canceled");
    }

    public async override Task<object> fetchCanceledAndClosedOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bitget#fetchCanceledAndClosedOrders
        * @see https://www.bitget.com/api-doc/spot/trade/Get-History-Orders
        * @see https://www.bitget.com/api-doc/spot/plan/Get-History-Plan-Order
        * @see https://www.bitget.com/api-doc/contract/trade/Get-Orders-History
        * @see https://www.bitget.com/api-doc/contract/plan/orders-plan-history
        * @see https://www.bitget.com/api-doc/margin/cross/trade/Get-Cross-Order-History
        * @see https://www.bitget.com/api-doc/margin/isolated/trade/Get-Isolated-Order-History
        * @description fetches information on multiple canceled and closed orders made by the user
        * @param {string} symbol unified market symbol of the market orders were made in
        * @param {int} [since] the earliest time in ms to fetch orders for
        * @param {int} [limit] the maximum number of order structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object sandboxMode = this.safeBool(this.options, "sandboxMode", false);
        object market = null;
        if (isTrue(sandboxMode))
        {
            if (isTrue(!isEqual(symbol, null)))
            {
                object sandboxSymbol = this.convertSymbolForSandbox(symbol);
                symbol = sandboxSymbol;
            }
        }
        object request = new Dictionary<string, object>() {};
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
        }
        object marketType = null;
        var marketTypeparametersVariable = this.handleMarketTypeAndParams("fetchCanceledAndClosedOrders", market, parameters);
        marketType = ((IList<object>)marketTypeparametersVariable)[0];
        parameters = ((IList<object>)marketTypeparametersVariable)[1];
        object marginMode = null;
        var marginModeparametersVariable = this.handleMarginModeAndParams("fetchCanceledAndClosedOrders", parameters);
        marginMode = ((IList<object>)marginModeparametersVariable)[0];
        parameters = ((IList<object>)marginModeparametersVariable)[1];
        object paginate = false;
        var paginateparametersVariable = this.handleOptionAndParams(parameters, "fetchCanceledAndClosedOrders", "paginate");
        paginate = ((IList<object>)paginateparametersVariable)[0];
        parameters = ((IList<object>)paginateparametersVariable)[1];
        if (isTrue(paginate))
        {
            object cursorReceived = null;
            if (isTrue(isEqual(marketType, "spot")))
            {
                if (isTrue(!isEqual(marginMode, null)))
                {
                    cursorReceived = "minId";
                }
            } else
            {
                cursorReceived = "endId";
            }
            return await this.fetchPaginatedCallCursor("fetchCanceledAndClosedOrders", symbol, since, limit, parameters, cursorReceived, "idLessThan");
        }
        object response = null;
        object trailing = this.safeValue(parameters, "trailing");
        object stop = this.safeBool2(parameters, "stop", "trigger");
        parameters = this.omit(parameters, new List<object>() {"stop", "trigger", "trailing"});
        var requestparametersVariable = this.handleUntilOption("endTime", request, parameters);
        request = ((IList<object>)requestparametersVariable)[0];
        parameters = ((IList<object>)requestparametersVariable)[1];
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["startTime"] = since;
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        if (isTrue(isTrue(isTrue((isEqual(marketType, "swap"))) || isTrue((isEqual(marketType, "future")))) || isTrue((!isEqual(marginMode, null)))))
        {
            object clientOrderId = this.safeString2(parameters, "clientOid", "clientOrderId");
            parameters = this.omit(parameters, "clientOrderId");
            if (isTrue(!isEqual(clientOrderId, null)))
            {
                ((IDictionary<string,object>)request)["clientOid"] = clientOrderId;
            }
        }
        object now = this.milliseconds();
        if (isTrue(isEqual(marketType, "spot")))
        {
            if (isTrue(!isEqual(marginMode, null)))
            {
                if (isTrue(isEqual(since, null)))
                {
                    since = subtract(now, 7776000000);
                    ((IDictionary<string,object>)request)["startTime"] = since;
                }
                if (isTrue(isEqual(marginMode, "isolated")))
                {
                    response = await this.privateMarginGetV2MarginIsolatedHistoryOrders(this.extend(request, parameters));
                } else if (isTrue(isEqual(marginMode, "cross")))
                {
                    response = await this.privateMarginGetV2MarginCrossedHistoryOrders(this.extend(request, parameters));
                }
            } else
            {
                if (isTrue(stop))
                {
                    if (isTrue(isEqual(symbol, null)))
                    {
                        throw new ArgumentsRequired ((string)add(this.id, " fetchCanceledAndClosedOrders() requires a symbol argument")) ;
                    }
                    object endTime = this.safeIntegerN(parameters, new List<object>() {"endTime", "until"});
                    parameters = this.omit(parameters, new List<object>() {"until"});
                    if (isTrue(isEqual(since, null)))
                    {
                        since = subtract(now, 7776000000);
                        ((IDictionary<string,object>)request)["startTime"] = since;
                    }
                    if (isTrue(isEqual(endTime, null)))
                    {
                        ((IDictionary<string,object>)request)["endTime"] = now;
                    }
                    response = await this.privateSpotGetV2SpotTradeHistoryPlanOrder(this.extend(request, parameters));
                } else
                {
                    response = await this.privateSpotGetV2SpotTradeHistoryOrders(this.extend(request, parameters));
                }
            }
        } else
        {
            object productType = null;
            var productTypeparametersVariable = this.handleProductTypeAndParams(market, parameters);
            productType = ((IList<object>)productTypeparametersVariable)[0];
            parameters = ((IList<object>)productTypeparametersVariable)[1];
            ((IDictionary<string,object>)request)["productType"] = productType;
            if (isTrue(trailing))
            {
                object planType = this.safeString(parameters, "planType", "track_plan");
                ((IDictionary<string,object>)request)["planType"] = planType;
                response = await this.privateMixGetV2MixOrderOrdersPlanHistory(this.extend(request, parameters));
            } else if (isTrue(stop))
            {
                object planType = this.safeString(parameters, "planType", "normal_plan");
                ((IDictionary<string,object>)request)["planType"] = planType;
                response = await this.privateMixGetV2MixOrderOrdersPlanHistory(this.extend(request, parameters));
            } else
            {
                response = await this.privateMixGetV2MixOrderOrdersHistory(this.extend(request, parameters));
            }
        }
        //
        // spot
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1700791085380,
        //         "data": [
        //             {
        //                 "userId": "7264631750",
        //                 "symbol": "BTCUSDT",
        //                 "orderId": "1111499608327360513",
        //                 "clientOid": "d0d4dad5-18d0-4869-a074-ec40bb47cba6",
        //                 "price": "25000.0000000000000000",
        //                 "size": "0.0002000000000000",
        //                 "orderType": "limit",
        //                 "side": "buy",
        //                 "status": "cancelled",
        //                 "priceAvg": "0",
        //                 "baseVolume": "0.0000000000000000",
        //                 "quoteVolume": "0.0000000000000000",
        //                 "enterPointSource": "WEB",
        //                 "feeDetail": "",
        //                 "orderSource": "normal",
        //                 "cTime": "1700728077966",
        //                 "uTime": "1700728911471"
        //             },
        //         ]
        //     }
        //
        // spot stop
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1700792099146,
        //         "data": {
        //             "nextFlag": false,
        //             "idLessThan": "1098757597417775104",
        //             "orderList": [
        //                 {
        //                     "orderId": "1111503385931620352",
        //                     "clientOid": "1111503385910648832",
        //                     "symbol": "BTCUSDT",
        //                     "size": "0.0002",
        //                     "planType": "AMOUNT",
        //                     "executePrice": "25000",
        //                     "triggerPrice": "26000",
        //                     "status": "cancelled",
        //                     "orderType": "limit",
        //                     "side": "buy",
        //                     "triggerType": "fill_price",
        //                     "enterPointSource": "API",
        //                     "cTime": "1700728978617",
        //                     "uTime": "1700729666868"
        //                 },
        //             ]
        //         }
        //     }
        //
        // spot margin
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1700792381435,
        //         "data": {
        //             "orderList": [
        //                 {
        //                     "symbol": "BTCUSDT",
        //                     "orderType": "limit",
        //                     "enterPointSource": "WEB",
        //                     "orderId": "1111456274707001345",
        //                     "clientOid": "41e428dd305a4f668671b7f1ed00dc50",
        //                     "loanType": "autoLoanAndRepay",
        //                     "price": "27000",
        //                     "side": "buy",
        //                     "status": "cancelled",
        //                     "baseSize": "0.0002",
        //                     "quoteSize": "5.4",
        //                     "priceAvg": "0",
        //                     "size": "0",
        //                     "amount": "0",
        //                     "force": "gtc",
        //                     "cTime": "1700717746427",
        //                     "uTime": "1700717780636"
        //                 },
        //             ],
        //             "maxId": "1111456274707001345",
        //             "minId": "1098396464990269440"
        //         }
        //     }
        //
        // swap and future
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1700792674673,
        //         "data": {
        //             "entrustedList": [
        //                 {
        //                     "symbol": "BTCUSDT",
        //                     "size": "0.002",
        //                     "orderId": "1111498800817143808",
        //                     "clientOid": "1111498800850698240",
        //                     "baseVolume": "0",
        //                     "fee": "0",
        //                     "price": "25000",
        //                     "priceAvg": "",
        //                     "status": "canceled",
        //                     "side": "buy",
        //                     "force": "gtc",
        //                     "totalProfits": "0",
        //                     "posSide": "long",
        //                     "marginCoin": "USDT",
        //                     "quoteVolume": "0",
        //                     "leverage": "20",
        //                     "marginMode": "crossed",
        //                     "enterPointSource": "web",
        //                     "tradeSide": "open",
        //                     "posMode": "hedge_mode",
        //                     "orderType": "limit",
        //                     "orderSource": "normal",
        //                     "presetStopSurplusPrice": "",
        //                     "presetStopLossPrice": "",
        //                     "reduceOnly": "NO",
        //                     "cTime": "1700727885449",
        //                     "uTime": "1700727944563"
        //                 },
        //             ],
        //             "endId": "1098397008323575809"
        //         }
        //     }
        //
        // swap and future stop
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1700792938359,
        //         "data": {
        //             "entrustedList": [
        //                 {
        //                     "planType": "normal_plan",
        //                     "symbol": "BTCUSDT",
        //                     "size": "0.001",
        //                     "orderId": "1111491399869075457",
        //                     "clientOid": "1111491399869075456",
        //                     "planStatus": "cancelled",
        //                     "price": "27000",
        //                     "feeDetail": null,
        //                     "baseVolume": "0",
        //                     "callbackRatio": "",
        //                     "triggerPrice": "24000",
        //                     "triggerType": "mark_price",
        //                     "side": "buy",
        //                     "posSide": "long",
        //                     "marginCoin": "USDT",
        //                     "marginMode": "crossed",
        //                     "enterPointSource": "API",
        //                     "tradeSide": "open",
        //                     "posMode": "hedge_mode",
        //                     "orderType": "limit",
        //                     "stopSurplusTriggerPrice": "",
        //                     "stopSurplusExecutePrice": "",
        //                     "stopSurplusTriggerType": "fill_price",
        //                     "stopLossTriggerPrice": "",
        //                     "stopLossExecutePrice": "",
        //                     "stopLossTriggerType": "fill_price",
        //                     "cTime": "1700726120917",
        //                     "uTime": "1700727879652"
        //                 },
        //             ],
        //             "endId": "1098760007867502593"
        //         }
        //     }
        //
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        if (isTrue(isEqual(marketType, "spot")))
        {
            if (isTrue(isTrue((!isEqual(marginMode, null))) || isTrue(stop)))
            {
                return this.parseOrders(this.safeValue(data, "orderList", new List<object>() {}), market, since, limit);
            }
        } else
        {
            return this.parseOrders(this.safeValue(data, "entrustedList", new List<object>() {}), market, since, limit);
        }
        if (isTrue((response is string)))
        {
            response = parseJson(response);
        }
        object orders = this.safeList(response, "data", new List<object>() {});
        return this.parseOrders(orders, market, since, limit);
    }

    public async override Task<object> fetchLedger(object code = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bitget#fetchLedger
        * @see https://www.bitget.com/api-doc/spot/account/Get-Account-Bills
        * @see https://www.bitget.com/api-doc/contract/account/Get-Account-Bill
        * @description fetch the history of changes, actions done by the user or operations that altered balance of the user
        * @param {string} code unified currency code, default is undefined
        * @param {int} [since] timestamp in ms of the earliest ledger entry, default is undefined
        * @param {int} [limit] max number of ledger entrys to return, default is undefined
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {int} [params.until] end time in ms
        * @param {string} [params.symbol] *contract only* unified market symbol
        * @param {string} [params.productType] *contract only* 'USDT-FUTURES', 'USDC-FUTURES', 'COIN-FUTURES', 'SUSDT-FUTURES', 'SUSDC-FUTURES' or 'SCOIN-FUTURES'
        * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [available parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
        * @returns {object} a [ledger structure]{@link https://docs.ccxt.com/#/?id=ledger-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object symbol = this.safeString(parameters, "symbol");
        parameters = this.omit(parameters, "symbol");
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            object sandboxMode = this.safeBool(this.options, "sandboxMode", false);
            if (isTrue(sandboxMode))
            {
                object sandboxSymbol = this.convertSymbolForSandbox(symbol);
                market = this.market(sandboxSymbol);
            } else
            {
                market = this.market(symbol);
            }
        }
        object marketType = null;
        var marketTypeparametersVariable = this.handleMarketTypeAndParams("fetchLedger", market, parameters);
        marketType = ((IList<object>)marketTypeparametersVariable)[0];
        parameters = ((IList<object>)marketTypeparametersVariable)[1];
        object paginate = false;
        var paginateparametersVariable = this.handleOptionAndParams(parameters, "fetchLedger", "paginate");
        paginate = ((IList<object>)paginateparametersVariable)[0];
        parameters = ((IList<object>)paginateparametersVariable)[1];
        if (isTrue(paginate))
        {
            object cursorReceived = null;
            if (isTrue(!isEqual(marketType, "spot")))
            {
                cursorReceived = "endId";
            }
            return await this.fetchPaginatedCallCursor("fetchLedger", symbol, since, limit, parameters, cursorReceived, "idLessThan");
        }
        object currency = null;
        object request = new Dictionary<string, object>() {};
        if (isTrue(!isEqual(code, null)))
        {
            currency = this.currency(code);
            ((IDictionary<string,object>)request)["coin"] = getValue(currency, "id");
        }
        var requestparametersVariable = this.handleUntilOption("endTime", request, parameters);
        request = ((IList<object>)requestparametersVariable)[0];
        parameters = ((IList<object>)requestparametersVariable)[1];
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["startTime"] = since;
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        object response = null;
        if (isTrue(isEqual(marketType, "spot")))
        {
            response = await this.privateSpotGetV2SpotAccountBills(this.extend(request, parameters));
        } else
        {
            if (isTrue(!isEqual(symbol, null)))
            {
                ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
            }
            object productType = null;
            var productTypeparametersVariable = this.handleProductTypeAndParams(market, parameters);
            productType = ((IList<object>)productTypeparametersVariable)[0];
            parameters = ((IList<object>)productTypeparametersVariable)[1];
            ((IDictionary<string,object>)request)["productType"] = productType;
            response = await this.privateMixGetV2MixAccountBill(this.extend(request, parameters));
        }
        //
        // spot
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1700795836415,
        //         "data": [
        //             {
        //                 "billId": "1111506298997215233",
        //                 "coin": "USDT",
        //                 "groupType": "transfer",
        //                 "businessType": "transfer_out",
        //                 "size": "-11.64958799",
        //                 "balance": "0.00000000",
        //                 "fees": "0.00000000",
        //                 "cTime": "1700729673028"
        //             },
        //         ]
        //     }
        //
        // swap and future
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1700795977890,
        //         "data": {
        //             "bills": [
        //                 {
        //                     "billId": "1111499428100472833",
        //                     "symbol": "",
        //                     "amount": "-11.64958799",
        //                     "fee": "0",
        //                     "feeByCoupon": "",
        //                     "businessType": "trans_to_exchange",
        //                     "coin": "USDT",
        //                     "cTime": "1700728034996"
        //                 },
        //             ],
        //             "endId": "1098396773329305606"
        //         }
        //     }
        //
        object data = this.safeValue(response, "data");
        if (isTrue(isTrue((isEqual(marketType, "swap"))) || isTrue((isEqual(marketType, "future")))))
        {
            object bills = this.safeValue(data, "bills", new List<object>() {});
            return this.parseLedger(bills, currency, since, limit);
        }
        return this.parseLedger(data, currency, since, limit);
    }

    public override object parseLedgerEntry(object item, object currency = null)
    {
        //
        // spot
        //
        //     {
        //         "billId": "1111506298997215233",
        //         "coin": "USDT",
        //         "groupType": "transfer",
        //         "businessType": "transfer_out",
        //         "size": "-11.64958799",
        //         "balance": "0.00000000",
        //         "fees": "0.00000000",
        //         "cTime": "1700729673028"
        //     }
        //
        // swap and future
        //
        //     {
        //         "billId": "1111499428100472833",
        //         "symbol": "",
        //         "amount": "-11.64958799",
        //         "fee": "0",
        //         "feeByCoupon": "",
        //         "businessType": "trans_to_exchange",
        //         "coin": "USDT",
        //         "cTime": "1700728034996"
        //     }
        //
        object currencyId = this.safeString(item, "coin");
        object code = this.safeCurrencyCode(currencyId, currency);
        object timestamp = this.safeInteger(item, "cTime");
        object after = this.safeNumber(item, "balance");
        object fee = this.safeNumber2(item, "fees", "fee");
        object amountRaw = this.safeString2(item, "size", "amount");
        object amount = this.parseNumber(Precise.stringAbs(amountRaw));
        object direction = "in";
        if (isTrue(isGreaterThanOrEqual(getIndexOf(amountRaw, "-"), 0)))
        {
            direction = "out";
        }
        return new Dictionary<string, object>() {
            { "info", item },
            { "id", this.safeString(item, "billId") },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "direction", direction },
            { "account", null },
            { "referenceId", null },
            { "referenceAccount", null },
            { "type", this.parseLedgerType(this.safeString(item, "businessType")) },
            { "currency", code },
            { "amount", amount },
            { "before", null },
            { "after", after },
            { "status", null },
            { "fee", fee },
        };
    }

    public virtual object parseLedgerType(object type)
    {
        object types = new Dictionary<string, object>() {
            { "trans_to_cross", "transfer" },
            { "trans_from_cross", "transfer" },
            { "trans_to_exchange", "transfer" },
            { "trans_from_exchange", "transfer" },
            { "trans_to_isolated", "transfer" },
            { "trans_from_isolated", "transfer" },
            { "trans_to_contract", "transfer" },
            { "trans_from_contract", "transfer" },
            { "trans_to_otc", "transfer" },
            { "trans_from_otc", "transfer" },
            { "open_long", "trade" },
            { "close_long", "trade" },
            { "open_short", "trade" },
            { "close_short", "trade" },
            { "force_close_long", "trade" },
            { "force_close_short", "trade" },
            { "burst_long_loss_query", "trade" },
            { "burst_short_loss_query", "trade" },
            { "force_buy", "trade" },
            { "force_sell", "trade" },
            { "burst_buy", "trade" },
            { "burst_sell", "trade" },
            { "delivery_long", "settlement" },
            { "delivery_short", "settlement" },
            { "contract_settle_fee", "fee" },
            { "append_margin", "transaction" },
            { "adjust_down_lever_append_margin", "transaction" },
            { "reduce_margin", "transaction" },
            { "auto_append_margin", "transaction" },
            { "cash_gift_issue", "cashback" },
            { "cash_gift_recycle", "cashback" },
            { "bonus_issue", "rebate" },
            { "bonus_recycle", "rebate" },
            { "bonus_expired", "rebate" },
            { "transfer_in", "transfer" },
            { "transfer_out", "transfer" },
            { "deposit", "deposit" },
            { "withdraw", "withdrawal" },
            { "buy", "trade" },
            { "sell", "trade" },
        };
        return this.safeString(types, type, type);
    }

    public async override Task<object> fetchMyTrades(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bitget#fetchMyTrades
        * @description fetch all trades made by the user
        * @see https://www.bitget.com/api-doc/spot/trade/Get-Fills
        * @see https://www.bitget.com/api-doc/contract/trade/Get-Order-Fills
        * @see https://www.bitget.com/api-doc/margin/cross/trade/Get-Cross-Order-Fills
        * @see https://www.bitget.com/api-doc/margin/isolated/trade/Get-Isolated-Transaction-Details
        * @param {string} symbol unified market symbol
        * @param {int} [since] the earliest time in ms to fetch trades for
        * @param {int} [limit] the maximum number of trades structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {int} [params.until] the latest time in ms to fetch trades for
        * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [available parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
        * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
        */
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchMyTrades() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object sandboxMode = this.safeBool(this.options, "sandboxMode", false);
        object market = null;
        if (isTrue(sandboxMode))
        {
            object sandboxSymbol = this.convertSymbolForSandbox(symbol);
            market = this.market(sandboxSymbol);
        } else
        {
            market = this.market(symbol);
        }
        object marginMode = null;
        var marginModeparametersVariable = this.handleMarginModeAndParams("fetchMyTrades", parameters);
        marginMode = ((IList<object>)marginModeparametersVariable)[0];
        parameters = ((IList<object>)marginModeparametersVariable)[1];
        object paginate = false;
        var paginateparametersVariable = this.handleOptionAndParams(parameters, "fetchMyTrades", "paginate");
        paginate = ((IList<object>)paginateparametersVariable)[0];
        parameters = ((IList<object>)paginateparametersVariable)[1];
        if (isTrue(paginate))
        {
            object cursorReceived = null;
            if (isTrue(getValue(market, "spot")))
            {
                if (isTrue(!isEqual(marginMode, null)))
                {
                    cursorReceived = "minId";
                }
            } else
            {
                cursorReceived = "endId";
            }
            return await this.fetchPaginatedCallCursor("fetchMyTrades", symbol, since, limit, parameters, cursorReceived, "idLessThan");
        }
        object response = null;
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        var requestparametersVariable = this.handleUntilOption("endTime", request, parameters);
        request = ((IList<object>)requestparametersVariable)[0];
        parameters = ((IList<object>)requestparametersVariable)[1];
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["startTime"] = since;
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        if (isTrue(getValue(market, "spot")))
        {
            if (isTrue(!isEqual(marginMode, null)))
            {
                if (isTrue(isEqual(since, null)))
                {
                    ((IDictionary<string,object>)request)["startTime"] = subtract(this.milliseconds(), 7776000000);
                }
                if (isTrue(isEqual(marginMode, "isolated")))
                {
                    response = await this.privateMarginGetV2MarginIsolatedFills(this.extend(request, parameters));
                } else if (isTrue(isEqual(marginMode, "cross")))
                {
                    response = await this.privateMarginGetV2MarginCrossedFills(this.extend(request, parameters));
                }
            } else
            {
                response = await this.privateSpotGetV2SpotTradeFills(this.extend(request, parameters));
            }
        } else
        {
            object productType = null;
            var productTypeparametersVariable = this.handleProductTypeAndParams(market, parameters);
            productType = ((IList<object>)productTypeparametersVariable)[0];
            parameters = ((IList<object>)productTypeparametersVariable)[1];
            ((IDictionary<string,object>)request)["productType"] = productType;
            response = await this.privateMixGetV2MixOrderFills(this.extend(request, parameters));
        }
        //
        // spot
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1700802995406,
        //         "data": [
        //             {
        //                 "userId": "7264631750",
        //                 "symbol": "BTCUSDT",
        //                 "orderId": "1098394344925597696",
        //                 "tradeId": "1098394344974925824",
        //                 "orderType": "market",
        //                 "side": "sell",
        //                 "priceAvg": "28467.68",
        //                 "size": "0.0002",
        //                 "amount": "5.693536",
        //                 "feeDetail": {
        //                     "deduction": "no",
        //                     "feeCoin": "USDT",
        //                     "totalDeductionFee": "",
        //                     "totalFee": "-0.005693536"
        //                 },
        //                 "tradeScope": "taker",
        //                 "cTime": "1697603539699",
        //                 "uTime": "1697603539754"
        //             }
        //         ]
        //     }
        //
        // spot margin
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1700803176399,
        //         "data": {
        //             "fills": [
        //                 {
        //                     "orderId": "1099353730455318528",
        //                     "tradeId": "1099353730627092481",
        //                     "orderType": "market",
        //                     "side": "sell",
        //                     "priceAvg": "29543.7",
        //                     "size": "0.0001",
        //                     "amount": "2.95437",
        //                     "tradeScope": "taker",
        //                     "feeDetail": {
        //                         "deduction": "no",
        //                         "feeCoin": "USDT",
        //                         "totalDeductionFee": "0",
        //                         "totalFee": "-0.00295437"
        //                     },
        //                     "cTime": "1697832275063",
        //                     "uTime": "1697832275150"
        //                 },
        //             ],
        //             "minId": "1099353591699161118",
        //             "maxId": "1099353730627092481"
        //         }
        //     }
        //
        // swap and future
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1700803357487,
        //         "data": {
        //             "fillList": [
        //                 {
        //                     "tradeId": "1111468664328269825",
        //                     "symbol": "BTCUSDT",
        //                     "orderId": "1111468664264753162",
        //                     "price": "37271.4",
        //                     "baseVolume": "0.001",
        //                     "feeDetail": [
        //                         {
        //                             "deduction": "no",
        //                             "feeCoin": "USDT",
        //                             "totalDeductionFee": null,
        //                             "totalFee": "-0.02236284"
        //                         }
        //                     ],
        //                     "side": "buy",
        //                     "quoteVolume": "37.2714",
        //                     "profit": "-0.0007",
        //                     "enterPointSource": "web",
        //                     "tradeSide": "close",
        //                     "posMode": "hedge_mode",
        //                     "tradeScope": "taker",
        //                     "cTime": "1700720700342"
        //                 },
        //             ],
        //             "endId": "1099351587643699201"
        //         }
        //     }
        //
        object data = this.safeValue(response, "data");
        if (isTrue(isTrue((getValue(market, "swap"))) || isTrue((getValue(market, "future")))))
        {
            object fillList = this.safeList(data, "fillList", new List<object>() {});
            return this.parseTrades(fillList, market, since, limit);
        } else if (isTrue(!isEqual(marginMode, null)))
        {
            object fills = this.safeList(data, "fills", new List<object>() {});
            return this.parseTrades(fills, market, since, limit);
        }
        return this.parseTrades(data, market, since, limit);
    }

    public async override Task<object> fetchPosition(object symbol, object parameters = null)
    {
        /**
        * @method
        * @name bitget#fetchPosition
        * @description fetch data on a single open contract trade position
        * @see https://www.bitget.com/api-doc/contract/position/get-single-position
        * @param {string} symbol unified market symbol of the market the position is held in
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [position structure]{@link https://docs.ccxt.com/#/?id=position-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object sandboxMode = this.safeBool(this.options, "sandboxMode", false);
        object market = null;
        if (isTrue(sandboxMode))
        {
            object sandboxSymbol = this.convertSymbolForSandbox(symbol);
            market = this.market(sandboxSymbol);
        } else
        {
            market = this.market(symbol);
        }
        object productType = null;
        var productTypeparametersVariable = this.handleProductTypeAndParams(market, parameters);
        productType = ((IList<object>)productTypeparametersVariable)[0];
        parameters = ((IList<object>)productTypeparametersVariable)[1];
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
            { "marginCoin", getValue(market, "settleId") },
            { "productType", productType },
        };
        object response = await this.privateMixGetV2MixPositionSinglePosition(this.extend(request, parameters));
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1700807531673,
        //         "data": [
        //             {
        //                 "marginCoin": "USDT",
        //                 "symbol": "BTCUSDT",
        //                 "holdSide": "long",
        //                 "openDelegateSize": "0",
        //                 "marginSize": "3.73555",
        //                 "available": "0.002",
        //                 "locked": "0",
        //                 "total": "0.002",
        //                 "leverage": "20",
        //                 "achievedProfits": "0",
        //                 "openPriceAvg": "37355.5",
        //                 "marginMode": "crossed",
        //                 "posMode": "hedge_mode",
        //                 "unrealizedPL": "0.007",
        //                 "liquidationPrice": "31724.970702417",
        //                 "keepMarginRate": "0.004",
        //                 "markPrice": "37359",
        //                 "marginRatio": "0.029599540355",
        //                 "cTime": "1700807507275"
        //             }
        //         ]
        //     }
        //
        object data = this.safeList(response, "data", new List<object>() {});
        object first = this.safeDict(data, 0, new Dictionary<string, object>() {});
        return this.parsePosition(first, market);
    }

    public async override Task<object> fetchPositions(object symbols = null, object parameters = null)
    {
        /**
        * @method
        * @name bitget#fetchPositions
        * @description fetch all open positions
        * @see https://www.bitget.com/api-doc/contract/position/get-all-position
        * @see https://www.bitget.com/api-doc/contract/position/Get-History-Position
        * @param {string[]} [symbols] list of unified market symbols
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {string} [params.marginCoin] the settle currency of the positions, needs to match the productType
        * @param {string} [params.productType] 'USDT-FUTURES', 'USDC-FUTURES', 'COIN-FUTURES', 'SUSDT-FUTURES', 'SUSDC-FUTURES' or 'SCOIN-FUTURES'
        * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [available parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
        * @param {boolean} [params.useHistoryEndpoint] default false, when true  will use the historic endpoint to fetch positions
        * @param {string} [params.method] either (default) 'privateMixGetV2MixPositionAllPosition' or 'privateMixGetV2MixPositionHistoryPosition'
        * @returns {object[]} a list of [position structure]{@link https://docs.ccxt.com/#/?id=position-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object paginate = false;
        var paginateparametersVariable = this.handleOptionAndParams(parameters, "fetchPositions", "paginate");
        paginate = ((IList<object>)paginateparametersVariable)[0];
        parameters = ((IList<object>)paginateparametersVariable)[1];
        if (isTrue(paginate))
        {
            return await this.fetchPaginatedCallCursor("fetchPositions", null, null, null, parameters, "endId", "idLessThan");
        }
        object method = null;
        object useHistoryEndpoint = this.safeBool(parameters, "useHistoryEndpoint", false);
        if (isTrue(useHistoryEndpoint))
        {
            method = "privateMixGetV2MixPositionHistoryPosition";
        } else
        {
            var methodparametersVariable = this.handleOptionAndParams(parameters, "fetchPositions", "method", "privateMixGetV2MixPositionAllPosition");
            method = ((IList<object>)methodparametersVariable)[0];
            parameters = ((IList<object>)methodparametersVariable)[1];
        }
        object market = null;
        if (isTrue(!isEqual(symbols, null)))
        {
            object first = this.safeString(symbols, 0);
            object sandboxMode = this.safeBool(this.options, "sandboxMode", false);
            if (isTrue(sandboxMode))
            {
                object sandboxSymbol = this.convertSymbolForSandbox(first);
                market = this.market(sandboxSymbol);
            } else
            {
                market = this.market(first);
            }
        }
        object productType = null;
        var productTypeparametersVariable = this.handleProductTypeAndParams(market, parameters);
        productType = ((IList<object>)productTypeparametersVariable)[0];
        parameters = ((IList<object>)productTypeparametersVariable)[1];
        object request = new Dictionary<string, object>() {
            { "productType", productType },
        };
        object response = null;
        object isHistory = false;
        if (isTrue(isEqual(method, "privateMixGetV2MixPositionAllPosition")))
        {
            object marginCoin = this.safeString(parameters, "marginCoin", "USDT");
            if (isTrue(!isEqual(symbols, null)))
            {
                marginCoin = getValue(market, "settleId");
            } else if (isTrue(isEqual(productType, "USDT-FUTURES")))
            {
                marginCoin = "USDT";
            } else if (isTrue(isEqual(productType, "USDC-FUTURES")))
            {
                marginCoin = "USDC";
            } else if (isTrue(isEqual(productType, "SUSDT-FUTURES")))
            {
                marginCoin = "SUSDT";
            } else if (isTrue(isEqual(productType, "SUSDC-FUTURES")))
            {
                marginCoin = "SUSDC";
            } else if (isTrue(isTrue((isEqual(productType, "SCOIN-FUTURES"))) || isTrue((isEqual(productType, "COIN-FUTURES")))))
            {
                if (isTrue(isEqual(marginCoin, null)))
                {
                    throw new ArgumentsRequired ((string)add(this.id, " fetchPositions() requires a marginCoin parameter that matches the productType")) ;
                }
            }
            ((IDictionary<string,object>)request)["marginCoin"] = marginCoin;
            response = await this.privateMixGetV2MixPositionAllPosition(this.extend(request, parameters));
        } else
        {
            isHistory = true;
            if (isTrue(!isEqual(market, null)))
            {
                ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
            }
            response = await this.privateMixGetV2MixPositionHistoryPosition(this.extend(request, parameters));
        }
        //
        // privateMixGetV2MixPositionAllPosition
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1700807810221,
        //         "data": [
        //             {
        //                 "marginCoin": "USDT",
        //                 "symbol": "BTCUSDT",
        //                 "holdSide": "long",
        //                 "openDelegateSize": "0",
        //                 "marginSize": "3.73555",
        //                 "available": "0.002",
        //                 "locked": "0",
        //                 "total": "0.002",
        //                 "leverage": "20",
        //                 "achievedProfits": "0",
        //                 "openPriceAvg": "37355.5",
        //                 "marginMode": "crossed",
        //                 "posMode": "hedge_mode",
        //                 "unrealizedPL": "0.03",
        //                 "liquidationPrice": "31725.023602417",
        //                 "keepMarginRate": "0.004",
        //                 "markPrice": "37370.5",
        //                 "marginRatio": "0.029550120396",
        //                 "cTime": "1700807507275"
        //             }
        //         ]
        //     }
        //
        // privateMixGetV2MixPositionHistoryPosition
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1700808051002,
        //         "data": {
        //             "list": [
        //                 {
        //                     "symbol": "BTCUSDT",
        //                     "marginCoin": "USDT",
        //                     "holdSide": "long",
        //                     "openAvgPrice": "37272.1",
        //                     "closeAvgPrice": "37271.4",
        //                     "marginMode": "crossed",
        //                     "openTotalPos": "0.001",
        //                     "closeTotalPos": "0.001",
        //                     "pnl": "-0.0007",
        //                     "netProfit": "-0.0454261",
        //                     "totalFunding": "0",
        //                     "openFee": "-0.02236326",
        //                     "closeFee": "-0.02236284",
        //                     "utime": "1700720700400",
        //                     "ctime": "1700720651684"
        //                 },
        //             ],
        //             "endId": "1099351653866962944"
        //         }
        //     }
        //
        object position = new List<object>() {};
        if (!isTrue(isHistory))
        {
            position = this.safeList(response, "data", new List<object>() {});
        } else
        {
            object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
            position = this.safeList(data, "list", new List<object>() {});
        }
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(position)); postFixIncrement(ref i))
        {
            ((IList<object>)result).Add(this.parsePosition(getValue(position, i), market));
        }
        symbols = this.marketSymbols(symbols);
        return this.filterByArrayPositions(result, "symbol", symbols, false);
    }

    public override object parsePosition(object position, object market = null)
    {
        //
        // fetchPosition
        //
        //     {
        //         "marginCoin": "USDT",
        //         "symbol": "BTCUSDT",
        //         "holdSide": "long",
        //         "openDelegateSize": "0",
        //         "marginSize": "3.73555",
        //         "available": "0.002",
        //         "locked": "0",
        //         "total": "0.002",
        //         "leverage": "20",
        //         "achievedProfits": "0",
        //         "openPriceAvg": "37355.5",
        //         "marginMode": "crossed",
        //         "posMode": "hedge_mode",
        //         "unrealizedPL": "0.007",
        //         "liquidationPrice": "31724.970702417",
        //         "keepMarginRate": "0.004",
        //         "markPrice": "37359",
        //         "marginRatio": "0.029599540355",
        //         "cTime": "1700807507275"
        //     }
        //
        // fetchPositions: privateMixGetV2MixPositionAllPosition
        //
        //     {
        //         "marginCoin": "USDT",
        //         "symbol": "BTCUSDT",
        //         "holdSide": "long",
        //         "openDelegateSize": "0",
        //         "marginSize": "3.73555",
        //         "available": "0.002",
        //         "locked": "0",
        //         "total": "0.002",
        //         "leverage": "20",
        //         "achievedProfits": "0",
        //         "openPriceAvg": "37355.5",
        //         "marginMode": "crossed",
        //         "posMode": "hedge_mode",
        //         "unrealizedPL": "0.03",
        //         "liquidationPrice": "31725.023602417",
        //         "keepMarginRate": "0.004",
        //         "markPrice": "37370.5",
        //         "marginRatio": "0.029550120396",
        //         "cTime": "1700807507275"
        //     }
        //
        // fetchPositionsHistory: privateMixGetV2MixPositionHistoryPosition
        //
        //     {
        //         "symbol": "BTCUSDT",
        //         "marginCoin": "USDT",
        //         "holdSide": "long",
        //         "openAvgPrice": "37272.1",
        //         "closeAvgPrice": "37271.4",
        //         "marginMode": "crossed",
        //         "openTotalPos": "0.001",
        //         "closeTotalPos": "0.001",
        //         "pnl": "-0.0007",
        //         "netProfit": "-0.0454261",
        //         "totalFunding": "0",
        //         "openFee": "-0.02236326",
        //         "closeFee": "-0.02236284",
        //         "utime": "1700720700400",
        //         "ctime": "1700720651684"
        //     }
        //
        // closeAllPositions
        //
        //     {
        //         "orderId": "1120923953904893955",
        //         "clientOid": "1120923953904893956"
        //     }
        //
        object marketId = this.safeString(position, "symbol");
        market = this.safeMarket(marketId, market, null, "contract");
        object symbol = getValue(market, "symbol");
        object timestamp = this.safeInteger2(position, "cTime", "ctime");
        object marginMode = this.safeString(position, "marginMode");
        object collateral = null;
        object initialMargin = null;
        object unrealizedPnl = this.safeString(position, "unrealizedPL");
        object rawCollateral = this.safeString(position, "marginSize");
        if (isTrue(isEqual(marginMode, "isolated")))
        {
            collateral = Precise.stringAdd(rawCollateral, unrealizedPnl);
        } else if (isTrue(isEqual(marginMode, "crossed")))
        {
            marginMode = "cross";
            initialMargin = rawCollateral;
        }
        object holdMode = this.safeString(position, "posMode");
        object hedged = null;
        if (isTrue(isEqual(holdMode, "hedge_mode")))
        {
            hedged = true;
        } else if (isTrue(isEqual(holdMode, "one_way_mode")))
        {
            hedged = false;
        }
        object side = this.safeString(position, "holdSide");
        object leverage = this.safeString(position, "leverage");
        object contractSizeNumber = this.safeValue(market, "contractSize");
        object contractSize = this.numberToString(contractSizeNumber);
        object baseAmount = this.safeString(position, "total");
        object entryPrice = this.safeString2(position, "openPriceAvg", "openAvgPrice");
        object maintenanceMarginPercentage = this.safeString(position, "keepMarginRate");
        object openNotional = Precise.stringMul(entryPrice, baseAmount);
        if (isTrue(isEqual(initialMargin, null)))
        {
            initialMargin = Precise.stringDiv(openNotional, leverage);
        }
        object contracts = this.parseNumber(Precise.stringDiv(baseAmount, contractSize));
        if (isTrue(isEqual(contracts, null)))
        {
            contracts = this.safeNumber(position, "closeTotalPos");
        }
        object markPrice = this.safeString(position, "markPrice");
        object notional = Precise.stringMul(baseAmount, markPrice);
        object initialMarginPercentage = Precise.stringDiv(initialMargin, notional);
        object liquidationPrice = this.parseNumber(this.omitZero(this.safeString(position, "liquidationPrice")));
        object calcTakerFeeRate = "0.0006";
        object calcTakerFeeMult = "0.9994";
        if (isTrue(isTrue(isTrue((isEqual(liquidationPrice, null))) && isTrue((isEqual(marginMode, "isolated")))) && isTrue(Precise.stringGt(baseAmount, "0"))))
        {
            object signedMargin = Precise.stringDiv(rawCollateral, baseAmount);
            object signedMmp = maintenanceMarginPercentage;
            if (isTrue(isEqual(side, "short")))
            {
                signedMargin = Precise.stringNeg(signedMargin);
                signedMmp = Precise.stringNeg(signedMmp);
            }
            object mmrMinusOne = Precise.stringSub("1", signedMmp);
            object numerator = Precise.stringSub(entryPrice, signedMargin);
            if (isTrue(isEqual(side, "long")))
            {
                mmrMinusOne = Precise.stringMul(mmrMinusOne, calcTakerFeeMult);
            } else
            {
                numerator = Precise.stringMul(numerator, calcTakerFeeMult);
            }
            liquidationPrice = this.parseNumber(Precise.stringDiv(numerator, mmrMinusOne));
        }
        object feeToClose = Precise.stringMul(notional, calcTakerFeeRate);
        object maintenanceMargin = Precise.stringAdd(Precise.stringMul(maintenanceMarginPercentage, notional), feeToClose);
        object percentage = Precise.stringMul(Precise.stringDiv(unrealizedPnl, initialMargin, 4), "100");
        return this.safePosition(new Dictionary<string, object>() {
            { "info", position },
            { "id", this.safeString(position, "orderId") },
            { "symbol", symbol },
            { "notional", this.parseNumber(notional) },
            { "marginMode", marginMode },
            { "liquidationPrice", liquidationPrice },
            { "entryPrice", this.parseNumber(entryPrice) },
            { "unrealizedPnl", this.parseNumber(unrealizedPnl) },
            { "realizedPnl", this.safeNumber(position, "pnl") },
            { "percentage", this.parseNumber(percentage) },
            { "contracts", contracts },
            { "contractSize", contractSizeNumber },
            { "markPrice", this.parseNumber(markPrice) },
            { "lastPrice", this.safeNumber(position, "closeAvgPrice") },
            { "side", side },
            { "hedged", hedged },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "lastUpdateTimestamp", this.safeInteger(position, "utime") },
            { "maintenanceMargin", this.parseNumber(maintenanceMargin) },
            { "maintenanceMarginPercentage", this.parseNumber(maintenanceMarginPercentage) },
            { "collateral", this.parseNumber(collateral) },
            { "initialMargin", this.parseNumber(initialMargin) },
            { "initialMarginPercentage", this.parseNumber(initialMarginPercentage) },
            { "leverage", this.parseNumber(leverage) },
            { "marginRatio", this.safeNumber(position, "marginRatio") },
            { "stopLossPrice", null },
            { "takeProfitPrice", null },
        });
    }

    public async override Task<object> fetchFundingRateHistory(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bitget#fetchFundingRateHistory
        * @description fetches historical funding rate prices
        * @see https://www.bitget.com/api-doc/contract/market/Get-History-Funding-Rate
        * @param {string} symbol unified symbol of the market to fetch the funding rate history for
        * @param {int} [since] timestamp in ms of the earliest funding rate to fetch
        * @param {int} [limit] the maximum amount of funding rate structures to fetch
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [availble parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
        * @returns {object[]} a list of [funding rate structures]{@link https://docs.ccxt.com/#/?id=funding-rate-history-structure}
        */
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchFundingRateHistory() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object paginate = false;
        var paginateparametersVariable = this.handleOptionAndParams(parameters, "fetchFundingRateHistory", "paginate");
        paginate = ((IList<object>)paginateparametersVariable)[0];
        parameters = ((IList<object>)paginateparametersVariable)[1];
        if (isTrue(paginate))
        {
            return await this.fetchPaginatedCallIncremental("fetchFundingRateHistory", symbol, since, limit, parameters, "pageNo", 100);
        }
        object sandboxMode = this.safeBool(this.options, "sandboxMode", false);
        object market = null;
        if (isTrue(sandboxMode))
        {
            object sandboxSymbol = this.convertSymbolForSandbox(symbol);
            market = this.market(sandboxSymbol);
        } else
        {
            market = this.market(symbol);
        }
        object productType = null;
        var productTypeparametersVariable = this.handleProductTypeAndParams(market, parameters);
        productType = ((IList<object>)productTypeparametersVariable)[0];
        parameters = ((IList<object>)productTypeparametersVariable)[1];
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
            { "productType", productType },
        };
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["pageSize"] = limit;
        }
        object response = await this.publicMixGetV2MixMarketHistoryFundRate(this.extend(request, parameters));
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1652406728393,
        //         "data": [
        //             {
        //                 "symbol": "BTCUSDT",
        //                 "fundingRate": "-0.0003",
        //                 "fundingTime": "1652396400000"
        //             },
        //         ]
        //     }
        //
        object data = this.safeValue(response, "data", new List<object>() {});
        object rates = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
        {
            object entry = getValue(data, i);
            object marketId = this.safeString(entry, "symbol");
            object symbolInner = this.safeSymbol(marketId, market);
            object timestamp = this.safeInteger(entry, "fundingTime");
            ((IList<object>)rates).Add(new Dictionary<string, object>() {
                { "info", entry },
                { "symbol", symbolInner },
                { "fundingRate", this.safeNumber(entry, "fundingRate") },
                { "timestamp", timestamp },
                { "datetime", this.iso8601(timestamp) },
            });
        }
        object sorted = this.sortBy(rates, "timestamp");
        return this.filterBySymbolSinceLimit(sorted, getValue(market, "symbol"), since, limit);
    }

    public async override Task<object> fetchFundingRate(object symbol, object parameters = null)
    {
        /**
        * @method
        * @name bitget#fetchFundingRate
        * @description fetch the current funding rate
        * @see https://www.bitget.com/api-doc/contract/market/Get-Current-Funding-Rate
        * @param {string} symbol unified market symbol
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [funding rate structure]{@link https://docs.ccxt.com/#/?id=funding-rate-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object sandboxMode = this.safeBool(this.options, "sandboxMode", false);
        object market = null;
        if (isTrue(sandboxMode))
        {
            object sandboxSymbol = this.convertSymbolForSandbox(symbol);
            market = this.market(sandboxSymbol);
        } else
        {
            market = this.market(symbol);
        }
        if (!isTrue(getValue(market, "swap")))
        {
            throw new BadSymbol ((string)add(this.id, " fetchFundingRate() supports swap contracts only")) ;
        }
        object productType = null;
        var productTypeparametersVariable = this.handleProductTypeAndParams(market, parameters);
        productType = ((IList<object>)productTypeparametersVariable)[0];
        parameters = ((IList<object>)productTypeparametersVariable)[1];
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
            { "productType", productType },
        };
        object response = await this.publicMixGetV2MixMarketCurrentFundRate(this.extend(request, parameters));
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1700811542124,
        //         "data": [
        //             {
        //                 "symbol": "BTCUSDT",
        //                 "fundingRate": "0.000106"
        //             }
        //         ]
        //     }
        //
        object data = this.safeValue(response, "data", new List<object>() {});
        return this.parseFundingRate(getValue(data, 0), market);
    }

    public override object parseFundingRate(object contract, object market = null)
    {
        //
        //     {
        //         "symbol": "BTCUSDT",
        //         "fundingRate": "-0.000182"
        //     }
        //
        object marketId = this.safeString(contract, "symbol");
        object symbol = this.safeSymbol(marketId, market, null, "swap");
        return new Dictionary<string, object>() {
            { "info", contract },
            { "symbol", symbol },
            { "markPrice", null },
            { "indexPrice", null },
            { "interestRate", null },
            { "estimatedSettlePrice", null },
            { "timestamp", null },
            { "datetime", null },
            { "fundingRate", this.safeNumber(contract, "fundingRate") },
            { "fundingTimestamp", null },
            { "fundingDatetime", null },
            { "nextFundingRate", null },
            { "nextFundingTimestamp", null },
            { "nextFundingDatetime", null },
            { "previousFundingRate", null },
            { "previousFundingTimestamp", null },
            { "previousFundingDatetime", null },
        };
    }

    public async override Task<object> fetchFundingHistory(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bitget#fetchFundingHistory
        * @description fetch the funding history
        * @see https://www.bitget.com/api-doc/contract/account/Get-Account-Bill
        * @param {string} symbol unified market symbol
        * @param {int} [since] the starting timestamp in milliseconds
        * @param {int} [limit] the number of entries to return
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {int} [params.until] the latest time in ms to fetch funding history for
        * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [available parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
        * @returns {object[]} a list of [funding history structures]{@link https://docs.ccxt.com/#/?id=funding-history-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchFundingHistory() requires a symbol argument")) ;
        }
        object paginate = false;
        var paginateparametersVariable = this.handleOptionAndParams(parameters, "fetchFundingHistory", "paginate");
        paginate = ((IList<object>)paginateparametersVariable)[0];
        parameters = ((IList<object>)paginateparametersVariable)[1];
        if (isTrue(paginate))
        {
            return await this.fetchPaginatedCallCursor("fetchFundingHistory", symbol, since, limit, parameters, "endId", "idLessThan");
        }
        object sandboxMode = this.safeBool(this.options, "sandboxMode", false);
        object market = null;
        if (isTrue(sandboxMode))
        {
            object sandboxSymbol = this.convertSymbolForSandbox(symbol);
            market = this.market(sandboxSymbol);
        } else
        {
            market = this.market(symbol);
        }
        if (!isTrue(getValue(market, "swap")))
        {
            throw new BadSymbol ((string)add(this.id, " fetchFundingHistory() supports swap contracts only")) ;
        }
        object productType = null;
        var productTypeparametersVariable = this.handleProductTypeAndParams(market, parameters);
        productType = ((IList<object>)productTypeparametersVariable)[0];
        parameters = ((IList<object>)productTypeparametersVariable)[1];
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
            { "marginCoin", getValue(market, "settleId") },
            { "businessType", "contract_settle_fee" },
            { "productType", productType },
        };
        var requestparametersVariable = this.handleUntilOption("endTime", request, parameters);
        request = ((IList<object>)requestparametersVariable)[0];
        parameters = ((IList<object>)requestparametersVariable)[1];
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["startTime"] = since;
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        object response = await this.privateMixGetV2MixAccountBill(this.extend(request, parameters));
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1700795977890,
        //         "data": {
        //             "bills": [
        //                 {
        //                     "billId": "1111499428100472833",
        //                     "symbol": "BTCUSDT",
        //                     "amount": "-0.004992",
        //                     "fee": "0",
        //                     "feeByCoupon": "",
        //                     "businessType": "contract_settle_fee",
        //                     "coin": "USDT",
        //                     "cTime": "1700728034996"
        //                 },
        //             ],
        //             "endId": "1098396773329305606"
        //         }
        //     }
        //
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        object result = this.safeValue(data, "bills", new List<object>() {});
        return this.parseFundingHistories(result, market, since, limit);
    }

    public virtual object parseFundingHistory(object contract, object market = null)
    {
        //
        //     {
        //         "billId": "1111499428100472833",
        //         "symbol": "BTCUSDT",
        //         "amount": "-0.004992",
        //         "fee": "0",
        //         "feeByCoupon": "",
        //         "businessType": "contract_settle_fee",
        //         "coin": "USDT",
        //         "cTime": "1700728034996"
        //     }
        //
        object marketId = this.safeString(contract, "symbol");
        object currencyId = this.safeString(contract, "coin");
        object timestamp = this.safeInteger(contract, "cTime");
        return new Dictionary<string, object>() {
            { "info", contract },
            { "symbol", this.safeSymbol(marketId, market, null, "swap") },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "code", this.safeCurrencyCode(currencyId) },
            { "amount", this.safeNumber(contract, "amount") },
            { "id", this.safeString(contract, "billId") },
        };
    }

    public virtual object parseFundingHistories(object contracts, object market = null, object since = null, object limit = null)
    {
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(contracts)); postFixIncrement(ref i))
        {
            object contract = getValue(contracts, i);
            object business = this.safeString(contract, "businessType");
            if (isTrue(!isEqual(business, "contract_settle_fee")))
            {
                continue;
            }
            ((IList<object>)result).Add(this.parseFundingHistory(contract, market));
        }
        object sorted = this.sortBy(result, "timestamp");
        return this.filterBySinceLimit(sorted, since, limit);
    }

    public async virtual Task<object> modifyMarginHelper(object symbol, object amount, object type, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object holdSide = this.safeString(parameters, "holdSide");
        object sandboxMode = this.safeBool(this.options, "sandboxMode", false);
        object market = null;
        if (isTrue(sandboxMode))
        {
            object sandboxSymbol = this.convertSymbolForSandbox(symbol);
            market = this.market(sandboxSymbol);
        } else
        {
            market = this.market(symbol);
        }
        object productType = null;
        var productTypeparametersVariable = this.handleProductTypeAndParams(market, parameters);
        productType = ((IList<object>)productTypeparametersVariable)[0];
        parameters = ((IList<object>)productTypeparametersVariable)[1];
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
            { "marginCoin", getValue(market, "settleId") },
            { "amount", this.amountToPrecision(symbol, amount) },
            { "holdSide", holdSide },
            { "productType", productType },
        };
        parameters = this.omit(parameters, "holdSide");
        object response = await this.privateMixPostV2MixAccountSetMargin(this.extend(request, parameters));
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1700813444618,
        //         "data": ""
        //     }
        //
        return this.extend(this.parseMarginModification(response, market), new Dictionary<string, object>() {
            { "amount", this.parseNumber(amount) },
            { "type", type },
        });
    }

    public override object parseMarginModification(object data, object market = null)
    {
        //
        // addMargin/reduceMargin
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1700813444618,
        //         "data": ""
        //     }
        //
        object errorCode = this.safeString(data, "code");
        object status = ((bool) isTrue((isEqual(errorCode, "00000")))) ? "ok" : "failed";
        return new Dictionary<string, object>() {
            { "info", data },
            { "symbol", getValue(market, "symbol") },
            { "type", null },
            { "marginMode", "isolated" },
            { "amount", null },
            { "total", null },
            { "code", getValue(market, "settle") },
            { "status", status },
            { "timestamp", null },
            { "datetime", null },
        };
    }

    public async override Task<object> reduceMargin(object symbol, object amount, object parameters = null)
    {
        /**
        * @method
        * @name bitget#reduceMargin
        * @description remove margin from a position
        * @see https://www.bitget.com/api-doc/contract/account/Change-Margin
        * @param {string} symbol unified market symbol
        * @param {float} amount the amount of margin to remove
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [margin structure]{@link https://docs.ccxt.com/#/?id=reduce-margin-structure}
        */
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isGreaterThan(amount, 0)))
        {
            throw new BadRequest ((string)add(this.id, " reduceMargin() amount parameter must be a negative value")) ;
        }
        object holdSide = this.safeString(parameters, "holdSide");
        if (isTrue(isEqual(holdSide, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " reduceMargin() requires a holdSide parameter, either long or short")) ;
        }
        return await this.modifyMarginHelper(symbol, amount, "reduce", parameters);
    }

    public async override Task<object> addMargin(object symbol, object amount, object parameters = null)
    {
        /**
        * @method
        * @name bitget#addMargin
        * @description add margin
        * @see https://www.bitget.com/api-doc/contract/account/Change-Margin
        * @param {string} symbol unified market symbol
        * @param {float} amount the amount of margin to add
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [margin structure]{@link https://docs.ccxt.com/#/?id=add-margin-structure}
        */
        parameters ??= new Dictionary<string, object>();
        object holdSide = this.safeString(parameters, "holdSide");
        if (isTrue(isEqual(holdSide, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " addMargin() requires a holdSide parameter, either long or short")) ;
        }
        return await this.modifyMarginHelper(symbol, amount, "add", parameters);
    }

    public async override Task<object> fetchLeverage(object symbol, object parameters = null)
    {
        /**
        * @method
        * @name bitget#fetchLeverage
        * @description fetch the set leverage for a market
        * @see https://www.bitget.com/api-doc/contract/account/Get-Single-Account
        * @param {string} symbol unified market symbol
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [leverage structure]{@link https://docs.ccxt.com/#/?id=leverage-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object sandboxMode = this.safeBool(this.options, "sandboxMode", false);
        object market = null;
        if (isTrue(sandboxMode))
        {
            object sandboxSymbol = this.convertSymbolForSandbox(symbol);
            market = this.market(sandboxSymbol);
        } else
        {
            market = this.market(symbol);
        }
        object productType = null;
        var productTypeparametersVariable = this.handleProductTypeAndParams(market, parameters);
        productType = ((IList<object>)productTypeparametersVariable)[0];
        parameters = ((IList<object>)productTypeparametersVariable)[1];
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
            { "marginCoin", getValue(market, "settleId") },
            { "productType", productType },
        };
        object response = await this.privateMixGetV2MixAccountAccount(this.extend(request, parameters));
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1709366911964,
        //         "data": {
        //             "marginCoin": "USDT",
        //             "locked": "0",
        //             "available": "0",
        //             "crossedMaxAvailable": "0",
        //             "isolatedMaxAvailable": "0",
        //             "maxTransferOut": "0",
        //             "accountEquity": "0",
        //             "usdtEquity": "0.000000009166",
        //             "btcEquity": "0",
        //             "crossedRiskRate": "0",
        //             "crossedMarginLeverage": 20,
        //             "isolatedLongLever": 20,
        //             "isolatedShortLever": 20,
        //             "marginMode": "crossed",
        //             "posMode": "hedge_mode",
        //             "unrealizedPL": "0",
        //             "coupon": "0",
        //             "crossedUnrealizedPL": "0",
        //             "isolatedUnrealizedPL": ""
        //         }
        //     }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        return this.parseLeverage(data, market);
    }

    public override object parseLeverage(object leverage, object market = null)
    {
        return new Dictionary<string, object>() {
            { "info", leverage },
            { "symbol", getValue(market, "symbol") },
            { "marginMode", "isolated" },
            { "longLeverage", this.safeInteger(leverage, "isolatedLongLever") },
            { "shortLeverage", this.safeInteger(leverage, "isolatedShortLever") },
        };
    }

    public async override Task<object> setLeverage(object leverage, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name bitget#setLeverage
        * @description set the level of leverage for a market
        * @see https://www.bitget.com/api-doc/contract/account/Change-Leverage
        * @param {int} leverage the rate of leverage
        * @param {string} symbol unified market symbol
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {string} [params.holdSide] *isolated only* position direction, 'long' or 'short'
        * @returns {object} response from the exchange
        */
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " setLeverage() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object sandboxMode = this.safeBool(this.options, "sandboxMode", false);
        object market = null;
        if (isTrue(sandboxMode))
        {
            object sandboxSymbol = this.convertSymbolForSandbox(symbol);
            market = this.market(sandboxSymbol);
        } else
        {
            market = this.market(symbol);
        }
        object productType = null;
        var productTypeparametersVariable = this.handleProductTypeAndParams(market, parameters);
        productType = ((IList<object>)productTypeparametersVariable)[0];
        parameters = ((IList<object>)productTypeparametersVariable)[1];
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
            { "marginCoin", getValue(market, "settleId") },
            { "leverage", this.numberToString(leverage) },
            { "productType", productType },
        };
        object response = await this.privateMixPostV2MixAccountSetLeverage(this.extend(request, parameters));
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1700864711517,
        //         "data": {
        //             "symbol": "BTCUSDT",
        //             "marginCoin": "USDT",
        //             "longLeverage": "25",
        //             "shortLeverage": "25",
        //             "crossMarginLeverage": "25",
        //             "marginMode": "crossed"
        //         }
        //     }
        //
        return response;
    }

    public async override Task<object> setMarginMode(object marginMode, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name bitget#setMarginMode
        * @description set margin mode to 'cross' or 'isolated'
        * @see https://www.bitget.com/api-doc/contract/account/Change-Margin-Mode
        * @param {string} marginMode 'cross' or 'isolated'
        * @param {string} symbol unified market symbol
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} response from the exchange
        */
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " setMarginMode() requires a symbol argument")) ;
        }
        marginMode = ((string)marginMode).ToLower();
        if (isTrue(isEqual(marginMode, "cross")))
        {
            marginMode = "crossed";
        }
        if (isTrue(isTrue((!isEqual(marginMode, "isolated"))) && isTrue((!isEqual(marginMode, "crossed")))))
        {
            throw new ArgumentsRequired ((string)add(this.id, " setMarginMode() marginMode must be either isolated or crossed (cross)")) ;
        }
        await this.loadMarkets();
        object sandboxMode = this.safeBool(this.options, "sandboxMode", false);
        object market = null;
        if (isTrue(sandboxMode))
        {
            object sandboxSymbol = this.convertSymbolForSandbox(symbol);
            market = this.market(sandboxSymbol);
        } else
        {
            market = this.market(symbol);
        }
        object productType = null;
        var productTypeparametersVariable = this.handleProductTypeAndParams(market, parameters);
        productType = ((IList<object>)productTypeparametersVariable)[0];
        parameters = ((IList<object>)productTypeparametersVariable)[1];
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
            { "marginCoin", getValue(market, "settleId") },
            { "marginMode", marginMode },
            { "productType", productType },
        };
        object response = await this.privateMixPostV2MixAccountSetMarginMode(this.extend(request, parameters));
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1700865205552,
        //         "data": {
        //             "symbol": "BTCUSDT",
        //             "marginCoin": "USDT",
        //             "longLeverage": "20",
        //             "shortLeverage": "3",
        //             "marginMode": "isolated"
        //         }
        //     }
        //
        return response;
    }

    public async override Task<object> setPositionMode(object hedged, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name bitget#setPositionMode
        * @description set hedged to true or false for a market
        * @see https://www.bitget.com/api-doc/contract/account/Change-Hold-Mode
        * @param {bool} hedged set to true to use dualSidePosition
        * @param {string} symbol not used by bitget setPositionMode ()
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {string} [params.productType] required if symbol is undefined: 'USDT-FUTURES', 'USDC-FUTURES', 'COIN-FUTURES', 'SUSDT-FUTURES', 'SUSDC-FUTURES' or 'SCOIN-FUTURES'
        * @returns {object} response from the exchange
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object posMode = ((bool) isTrue(hedged)) ? "hedge_mode" : "one_way_mode";
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            object sandboxMode = this.safeBool(this.options, "sandboxMode", false);
            if (isTrue(sandboxMode))
            {
                object sandboxSymbol = this.convertSymbolForSandbox(symbol);
                market = this.market(sandboxSymbol);
            } else
            {
                market = this.market(symbol);
            }
        }
        object productType = null;
        var productTypeparametersVariable = this.handleProductTypeAndParams(market, parameters);
        productType = ((IList<object>)productTypeparametersVariable)[0];
        parameters = ((IList<object>)productTypeparametersVariable)[1];
        object request = new Dictionary<string, object>() {
            { "posMode", posMode },
            { "productType", productType },
        };
        object response = await this.privateMixPostV2MixAccountSetPositionMode(this.extend(request, parameters));
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1700865608009,
        //         "data": {
        //             "posMode": "hedge_mode"
        //         }
        //     }
        //
        return response;
    }

    public async override Task<object> fetchOpenInterest(object symbol, object parameters = null)
    {
        /**
        * @method
        * @name bitget#fetchOpenInterest
        * @description retrieves the open interest of a contract trading pair
        * @see https://www.bitget.com/api-doc/contract/market/Get-Open-Interest
        * @param {string} symbol unified CCXT market symbol
        * @param {object} [params] exchange specific parameters
        * @returns {object} an open interest structure{@link https://docs.ccxt.com/#/?id=open-interest-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object sandboxMode = this.safeBool(this.options, "sandboxMode", false);
        object market = null;
        if (isTrue(sandboxMode))
        {
            object sandboxSymbol = this.convertSymbolForSandbox(symbol);
            market = this.market(sandboxSymbol);
        } else
        {
            market = this.market(symbol);
        }
        if (!isTrue(getValue(market, "contract")))
        {
            throw new BadRequest ((string)add(this.id, " fetchOpenInterest() supports contract markets only")) ;
        }
        object productType = null;
        var productTypeparametersVariable = this.handleProductTypeAndParams(market, parameters);
        productType = ((IList<object>)productTypeparametersVariable)[0];
        parameters = ((IList<object>)productTypeparametersVariable)[1];
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
            { "productType", productType },
        };
        object response = await this.publicMixGetV2MixMarketOpenInterest(this.extend(request, parameters));
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1700866041022,
        //         "data": {
        //             "openInterestList": [
        //                 {
        //                     "symbol": "BTCUSDT",
        //                     "size": "52234.134"
        //                 }
        //             ],
        //             "ts": "1700866041023"
        //         }
        //     }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        return this.parseOpenInterest(data, market);
    }

    public override object parseOpenInterest(object interest, object market = null)
    {
        //
        //     {
        //         "openInterestList": [
        //             {
        //                 "symbol": "BTCUSDT",
        //                 "size": "52234.134"
        //             }
        //         ],
        //         "ts": "1700866041023"
        //     }
        //
        object data = this.safeValue(interest, "openInterestList", new List<object>() {});
        object timestamp = this.safeInteger(interest, "ts");
        object marketId = this.safeString(getValue(data, 0), "symbol");
        return this.safeOpenInterest(new Dictionary<string, object>() {
            { "symbol", this.safeSymbol(marketId, market, null, "contract") },
            { "openInterestAmount", this.safeNumber(getValue(data, 0), "size") },
            { "openInterestValue", null },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "info", interest },
        }, market);
    }

    public async virtual Task<object> fetchTransfers(object code = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bitget#fetchTransfers
        * @description fetch a history of internal transfers made on an account
        * @see https://www.bitget.com/api-doc/spot/account/Get-Account-TransferRecords
        * @param {string} code unified currency code of the currency transferred
        * @param {int} [since] the earliest time in ms to fetch transfers for
        * @param {int} [limit] the maximum number of transfers structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {int} [params.until] the latest time in ms to fetch entries for
        * @returns {object[]} a list of [transfer structures]{@link https://docs.ccxt.com/#/?id=transfer-structure}
        */
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(code, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchTransfers() requires a code argument")) ;
        }
        await this.loadMarkets();
        object type = null;
        var typeparametersVariable = this.handleMarketTypeAndParams("fetchTransfers", null, parameters);
        type = ((IList<object>)typeparametersVariable)[0];
        parameters = ((IList<object>)typeparametersVariable)[1];
        object fromAccount = this.safeString(parameters, "fromAccount", type);
        parameters = this.omit(parameters, "fromAccount");
        object accountsByType = this.safeValue(this.options, "accountsByType", new Dictionary<string, object>() {});
        type = this.safeString(accountsByType, fromAccount);
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "coin", getValue(currency, "id") },
            { "fromType", type },
        };
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["startTime"] = since;
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        var requestparametersVariable = this.handleUntilOption("endTime", request, parameters);
        request = ((IList<object>)requestparametersVariable)[0];
        parameters = ((IList<object>)requestparametersVariable)[1];
        object response = await this.privateSpotGetV2SpotAccountTransferRecords(this.extend(request, parameters));
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1700873854651,
        //         "data": [
        //             {
        //                 "coin": "USDT",
        //                 "status": "Successful",
        //                 "toType": "crossed_margin",
        //                 "toSymbol": "",
        //                 "fromType": "spot",
        //                 "fromSymbol": "",
        //                 "size": "11.64958799",
        //                 "ts": "1700729673028",
        //                 "clientOid": "1111506298504744960",
        //                 "transferId": "24930940"
        //             },
        //         ]
        //     }
        //
        object data = this.safeList(response, "data", new List<object>() {});
        return this.parseTransfers(data, currency, since, limit);
    }

    public async override Task<object> transfer(object code, object amount, object fromAccount, object toAccount, object parameters = null)
    {
        /**
        * @method
        * @name bitget#transfer
        * @description transfer currency internally between wallets on the same account
        * @see https://www.bitget.com/api-doc/spot/account/Wallet-Transfer
        * @param {string} code unified currency code
        * @param {float} amount amount to transfer
        * @param {string} fromAccount account to transfer from
        * @param {string} toAccount account to transfer to
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {string} [params.symbol] unified CCXT market symbol, required when transferring to or from an account type that is a leveraged position-by-position account
        * @param {string} [params.clientOid] custom id
        * @returns {object} a [transfer structure]{@link https://docs.ccxt.com/#/?id=transfer-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        object accountsByType = this.safeValue(this.options, "accountsByType", new Dictionary<string, object>() {});
        object fromType = this.safeString(accountsByType, fromAccount);
        object toType = this.safeString(accountsByType, toAccount);
        object request = new Dictionary<string, object>() {
            { "fromType", fromType },
            { "toType", toType },
            { "amount", amount },
            { "coin", getValue(currency, "id") },
        };
        object symbol = this.safeString(parameters, "symbol");
        parameters = this.omit(parameters, "symbol");
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
        }
        object response = await this.privateSpotPostV2SpotWalletTransfer(this.extend(request, parameters));
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1700874302021,
        //         "data": {
        //             "transferId": "1112112916581847040",
        //             "clientOrderId": null
        //         }
        //     }
        //
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        ((IDictionary<string,object>)data)["ts"] = this.safeInteger(response, "requestTime");
        return this.parseTransfer(data, currency);
    }

    public override object parseTransfer(object transfer, object currency = null)
    {
        //
        // transfer
        //
        //     {
        //         "transferId": "1112112916581847040",
        //         "clientOrderId": null,
        //         "ts": 1700874302021
        //     }
        //
        // fetchTransfers
        //
        //     {
        //         "coin": "USDT",
        //         "status": "Successful",
        //         "toType": "crossed_margin",
        //         "toSymbol": "",
        //         "fromType": "spot",
        //         "fromSymbol": "",
        //         "size": "11.64958799",
        //         "ts": "1700729673028",
        //         "clientOid": "1111506298504744960",
        //         "transferId": "24930940"
        //     }
        //
        object timestamp = this.safeInteger(transfer, "ts");
        object status = this.safeStringLower(transfer, "status");
        object currencyId = this.safeString(transfer, "coin");
        object fromAccountRaw = this.safeString(transfer, "fromType");
        object accountsById = this.safeValue(this.options, "accountsById", new Dictionary<string, object>() {});
        object fromAccount = this.safeString(accountsById, fromAccountRaw, fromAccountRaw);
        object toAccountRaw = this.safeString(transfer, "toType");
        object toAccount = this.safeString(accountsById, toAccountRaw, toAccountRaw);
        return new Dictionary<string, object>() {
            { "info", transfer },
            { "id", this.safeString(transfer, "transferId") },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "currency", this.safeCurrencyCode(currencyId, currency) },
            { "amount", this.safeNumber(transfer, "size") },
            { "fromAccount", fromAccount },
            { "toAccount", toAccount },
            { "status", this.parseTransferStatus(status) },
        };
    }

    public virtual object parseTransferStatus(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "successful", "ok" },
        };
        return this.safeString(statuses, status, status);
    }

    public override object parseDepositWithdrawFee(object fee, object currency = null)
    {
        //
        //     {
        //         "chains": [
        //             {
        //                 "browserUrl": "https://blockchair.com/bitcoin/transaction/",
        //                 "chain": "BTC",
        //                 "depositConfirm": "1",
        //                 "extraWithdrawFee": "0",
        //                 "minDepositAmount": "0.0001",
        //                 "minWithdrawAmount": "0.005",
        //                 "needTag": "false",
        //                 "rechargeable": "true",
        //                 "withdrawConfirm": "1",
        //                 "withdrawFee": "0.0004",
        //                 "withdrawable": "true"
        //             },
        //         ],
        //         "coin": "BTC",
        //         "coinId": "1",
        //         "transfer": "true""
        //     }
        //
        object chains = this.safeValue(fee, "chains", new List<object>() {});
        object chainsLength = getArrayLength(chains);
        object result = new Dictionary<string, object>() {
            { "info", fee },
            { "withdraw", new Dictionary<string, object>() {
                { "fee", null },
                { "percentage", null },
            } },
            { "deposit", new Dictionary<string, object>() {
                { "fee", null },
                { "percentage", null },
            } },
            { "networks", new Dictionary<string, object>() {} },
        };
        for (object i = 0; isLessThan(i, chainsLength); postFixIncrement(ref i))
        {
            object chain = getValue(chains, i);
            object networkId = this.safeString(chain, "chain");
            object currencyCode = this.safeString(currency, "code");
            object networkCode = this.networkIdToCode(networkId, currencyCode);
            ((IDictionary<string,object>)getValue(result, "networks"))[(string)networkCode] = new Dictionary<string, object>() {
                { "deposit", new Dictionary<string, object>() {
                    { "fee", null },
                    { "percentage", null },
                } },
                { "withdraw", new Dictionary<string, object>() {
                    { "fee", this.safeNumber(chain, "withdrawFee") },
                    { "percentage", false },
                } },
            };
            if (isTrue(isEqual(chainsLength, 1)))
            {
                ((IDictionary<string,object>)getValue(result, "withdraw"))["fee"] = this.safeNumber(chain, "withdrawFee");
                ((IDictionary<string,object>)getValue(result, "withdraw"))["percentage"] = false;
            }
        }
        return result;
    }

    public async override Task<object> fetchDepositWithdrawFees(object codes = null, object parameters = null)
    {
        /**
        * @method
        * @name bitget#fetchDepositWithdrawFees
        * @description fetch deposit and withdraw fees
        * @see https://www.bitget.com/api-doc/spot/market/Get-Coin-List
        * @param {string[]|undefined} codes list of unified currency codes
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a list of [fee structures]{@link https://docs.ccxt.com/#/?id=fee-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.publicSpotGetV2SpotPublicCoins(parameters);
        //
        //     {
        //         "code": "00000",
        //         "data": [
        //             {
        //                 "chains": [
        //                     {
        //                         "browserUrl": "https://blockchair.com/bitcoin/transaction/",
        //                         "chain": "BTC",
        //                         "depositConfirm": "1",
        //                         "extraWithdrawFee": "0",
        //                         "minDepositAmount": "0.0001",
        //                         "minWithdrawAmount": "0.005",
        //                         "needTag": "false",
        //                         "rechargeable": "true",
        //                         "withdrawConfirm": "1",
        //                         "withdrawFee": "0.0004",
        //                         "withdrawable": "true"
        //                     },
        //                 ],
        //                 "coin": "BTC",
        //                 "coinId": "1",
        //                 "transfer": "true""
        //             }
        //         ],
        //         "msg": "success",
        //         "requestTime": "1700120731773"
        //     }
        //
        object data = this.safeList(response, "data", new List<object>() {});
        return this.parseDepositWithdrawFees(data, codes, "coin");
    }

    public async override Task<object> borrowCrossMargin(object code, object amount, object parameters = null)
    {
        /**
        * @method
        * @name bitget#borrowCrossMargin
        * @description create a loan to borrow margin
        * @see https://www.bitget.com/api-doc/margin/cross/account/Cross-Borrow
        * @param {string} code unified currency code of the currency to borrow
        * @param {string} amount the amount to borrow
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [margin loan structure]{@link https://docs.ccxt.com/#/?id=margin-loan-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "coin", getValue(currency, "id") },
            { "borrowAmount", this.currencyToPrecision(code, amount) },
        };
        object response = await this.privateMarginPostV2MarginCrossedAccountBorrow(this.extend(request, parameters));
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1700876470931,
        //         "data": {
        //             "loanId": "1112122013642272769",
        //             "coin": "USDT",
        //             "borrowAmount": "4"
        //         }
        //     }
        //
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        return this.parseMarginLoan(data, currency);
    }

    public async override Task<object> borrowIsolatedMargin(object symbol, object code, object amount, object parameters = null)
    {
        /**
        * @method
        * @name bitget#borrowIsolatedMargin
        * @description create a loan to borrow margin
        * @see https://www.bitget.com/api-doc/margin/isolated/account/Isolated-Borrow
        * @param {string} symbol unified market symbol
        * @param {string} code unified currency code of the currency to borrow
        * @param {string} amount the amount to borrow
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [margin loan structure]{@link https://docs.ccxt.com/#/?id=margin-loan-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "coin", getValue(currency, "id") },
            { "borrowAmount", this.currencyToPrecision(code, amount) },
            { "symbol", getValue(market, "id") },
        };
        object response = await this.privateMarginPostV2MarginIsolatedAccountBorrow(this.extend(request, parameters));
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1700877255605,
        //         "data": {
        //             "loanId": "1112125304879067137",
        //             "symbol": "BTCUSDT",
        //             "coin": "USDT",
        //             "borrowAmount": "4"
        //         }
        //     }
        //
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        return this.parseMarginLoan(data, currency, market);
    }

    public async override Task<object> repayIsolatedMargin(object symbol, object code, object amount, object parameters = null)
    {
        /**
        * @method
        * @name bitget#repayIsolatedMargin
        * @description repay borrowed margin and interest
        * @see https://www.bitget.com/api-doc/margin/isolated/account/Isolated-Repay
        * @param {string} symbol unified market symbol
        * @param {string} code unified currency code of the currency to repay
        * @param {string} amount the amount to repay
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [margin loan structure]{@link https://docs.ccxt.com/#/?id=margin-loan-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "coin", getValue(currency, "id") },
            { "repayAmount", this.currencyToPrecision(code, amount) },
            { "symbol", getValue(market, "id") },
        };
        object response = await this.privateMarginPostV2MarginIsolatedAccountRepay(this.extend(request, parameters));
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1700877518012,
        //         "data": {
        //             "remainDebtAmount": "0",
        //             "repayId": "1112126405439270912",
        //             "symbol": "BTCUSDT",
        //             "coin": "USDT",
        //             "repayAmount": "8.000137"
        //         }
        //     }
        //
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        return this.parseMarginLoan(data, currency, market);
    }

    public async override Task<object> repayCrossMargin(object code, object amount, object parameters = null)
    {
        /**
        * @method
        * @name bitget#repayCrossMargin
        * @description repay borrowed margin and interest
        * @see https://www.bitget.com/api-doc/margin/cross/account/Cross-Repay
        * @param {string} code unified currency code of the currency to repay
        * @param {string} amount the amount to repay
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [margin loan structure]{@link https://docs.ccxt.com/#/?id=margin-loan-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "coin", getValue(currency, "id") },
            { "repayAmount", this.currencyToPrecision(code, amount) },
        };
        object response = await this.privateMarginPostV2MarginCrossedAccountRepay(this.extend(request, parameters));
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1700876704885,
        //         "data": {
        //             "remainDebtAmount": "0",
        //             "repayId": "1112122994945830912",
        //             "coin": "USDT",
        //             "repayAmount": "4.00006834"
        //         }
        //     }
        //
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        return this.parseMarginLoan(data, currency);
    }

    public virtual object parseMarginLoan(object info, object currency = null, object market = null)
    {
        //
        // isolated: borrowMargin
        //
        //     {
        //         "loanId": "1112125304879067137",
        //         "symbol": "BTCUSDT",
        //         "coin": "USDT",
        //         "borrowAmount": "4"
        //     }
        //
        // cross: borrowMargin
        //
        //     {
        //         "loanId": "1112122013642272769",
        //         "coin": "USDT",
        //         "borrowAmount": "4"
        //     }
        //
        // isolated: repayMargin
        //
        //     {
        //         "remainDebtAmount": "0",
        //         "repayId": "1112126405439270912",
        //         "symbol": "BTCUSDT",
        //         "coin": "USDT",
        //         "repayAmount": "8.000137"
        //     }
        //
        // cross: repayMargin
        //
        //     {
        //         "remainDebtAmount": "0",
        //         "repayId": "1112122994945830912",
        //         "coin": "USDT",
        //         "repayAmount": "4.00006834"
        //     }
        //
        object currencyId = this.safeString(info, "coin");
        object marketId = this.safeString(info, "symbol");
        object symbol = null;
        if (isTrue(!isEqual(marketId, null)))
        {
            symbol = this.safeSymbol(marketId, market, null, "spot");
        }
        return new Dictionary<string, object>() {
            { "id", this.safeString2(info, "loanId", "repayId") },
            { "currency", this.safeCurrencyCode(currencyId, currency) },
            { "amount", this.safeNumber2(info, "borrowAmount", "repayAmount") },
            { "symbol", symbol },
            { "timestamp", null },
            { "datetime", null },
            { "info", info },
        };
    }

    public async override Task<object> fetchMyLiquidations(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bitget#fetchMyLiquidations
        * @description retrieves the users liquidated positions
        * @see https://www.bitget.com/api-doc/margin/cross/record/Get-Cross-Liquidation-Records
        * @see https://www.bitget.com/api-doc/margin/isolated/record/Get-Isolated-Liquidation-Records
        * @param {string} [symbol] unified CCXT market symbol
        * @param {int} [since] the earliest time in ms to fetch liquidations for
        * @param {int} [limit] the maximum number of liquidation structures to retrieve
        * @param {object} [params] exchange specific parameters for the bitget api endpoint
        * @param {int} [params.until] timestamp in ms of the latest liquidation
        * @param {string} [params.marginMode] 'cross' or 'isolated' default value is 'cross'
        * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [available parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
        * @returns {object} an array of [liquidation structures]{@link https://docs.ccxt.com/#/?id=liquidation-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object paginate = false;
        var paginateparametersVariable = this.handleOptionAndParams(parameters, "fetchMyLiquidations", "paginate");
        paginate = ((IList<object>)paginateparametersVariable)[0];
        parameters = ((IList<object>)paginateparametersVariable)[1];
        if (isTrue(paginate))
        {
            return await this.fetchPaginatedCallCursor("fetchMyLiquidations", symbol, since, limit, parameters, "minId", "idLessThan");
        }
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
        }
        object type = null;
        var typeparametersVariable = this.handleMarketTypeAndParams("fetchMyLiquidations", market, parameters);
        type = ((IList<object>)typeparametersVariable)[0];
        parameters = ((IList<object>)typeparametersVariable)[1];
        if (isTrue(!isEqual(type, "spot")))
        {
            throw new NotSupported ((string)add(this.id, " fetchMyLiquidations() supports spot margin markets only")) ;
        }
        object request = new Dictionary<string, object>() {};
        var requestparametersVariable = this.handleUntilOption("endTime", request, parameters);
        request = ((IList<object>)requestparametersVariable)[0];
        parameters = ((IList<object>)requestparametersVariable)[1];
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["startTime"] = since;
        } else
        {
            ((IDictionary<string,object>)request)["startTime"] = subtract(this.milliseconds(), 7776000000);
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        object response = null;
        object marginMode = null;
        var marginModeparametersVariable = this.handleMarginModeAndParams("fetchMyLiquidations", parameters, "cross");
        marginMode = ((IList<object>)marginModeparametersVariable)[0];
        parameters = ((IList<object>)marginModeparametersVariable)[1];
        if (isTrue(isEqual(marginMode, "isolated")))
        {
            if (isTrue(isEqual(symbol, null)))
            {
                throw new ArgumentsRequired ((string)add(this.id, " fetchMyLiquidations() requires a symbol argument")) ;
            }
            ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
            response = await this.privateMarginGetV2MarginIsolatedLiquidationHistory(this.extend(request, parameters));
        } else if (isTrue(isEqual(marginMode, "cross")))
        {
            response = await this.privateMarginGetV2MarginCrossedLiquidationHistory(this.extend(request, parameters));
        }
        //
        // isolated
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1698114119193,
        //         "data": {
        //             "resultList": [
        //                 {
        //                     "liqId": "123",
        //                     "symbol": "BTCUSDT",
        //                     "liqStartTime": "1653453245342",
        //                     "liqEndTime": "16312423423432",
        //                     "liqRiskRatio": "1.01",
        //                     "totalAssets": "1242.34",
        //                     "totalDebt": "1100",
        //                     "liqFee": "1.2",
        //                     "uTime": "1668134458717",
        //                     "cTime": "1653453245342"
        //                 }
        //             ],
        //             "maxId": "0",
        //             "minId": "0"
        //         }
        //     }
        //
        // cross
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1698114119193,
        //         "data": {
        //             "resultList": [
        //                 {
        //                     "liqId": "123",
        //                     "liqStartTime": "1653453245342",
        //                     "liqEndTime": "16312423423432",
        //                     "liqRiskRatio": "1.01",
        //                     "totalAssets": "1242.34",
        //                     "totalDebt": "1100",
        //                     "LiqFee": "1.2",
        //                     "uTime": "1668134458717",
        //                     "cTime": "1653453245342"
        //                 }
        //             ],
        //             "maxId": "0",
        //             "minId": "0"
        //         }
        //     }
        //
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        object liquidations = this.safeList(data, "resultList", new List<object>() {});
        return this.parseLiquidations(liquidations, market, since, limit);
    }

    public override object parseLiquidation(object liquidation, object market = null)
    {
        //
        // isolated
        //
        //     {
        //         "liqId": "123",
        //         "symbol": "BTCUSDT",
        //         "liqStartTime": "1653453245342",
        //         "liqEndTime": "16312423423432",
        //         "liqRiskRatio": "1.01",
        //         "totalAssets": "1242.34",
        //         "totalDebt": "1100",
        //         "liqFee": "1.2",
        //         "uTime": "1692690126000"
        //         "cTime": "1653453245342"
        //     }
        //
        // cross
        //
        //     {
        //         "liqId": "123",
        //         "liqStartTime": "1653453245342",
        //         "liqEndTime": "16312423423432",
        //         "liqRiskRatio": "1.01",
        //         "totalAssets": "1242.34",
        //         "totalDebt": "1100",
        //         "LiqFee": "1.2",
        //         "uTime": "1692690126000"
        //         "cTime": "1653453245342"
        //     }
        //
        object marketId = this.safeString(liquidation, "symbol");
        object timestamp = this.safeInteger(liquidation, "liqEndTime");
        object liquidationFee = this.safeString2(liquidation, "LiqFee", "liqFee");
        object totalDebt = this.safeString(liquidation, "totalDebt");
        object quoteValueString = Precise.stringAdd(liquidationFee, totalDebt);
        return this.safeLiquidation(new Dictionary<string, object>() {
            { "info", liquidation },
            { "symbol", this.safeSymbol(marketId, market) },
            { "contracts", null },
            { "contractSize", null },
            { "price", null },
            { "baseValue", null },
            { "quoteValue", this.parseNumber(quoteValueString) },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
        });
    }

    public async override Task<object> fetchIsolatedBorrowRate(object symbol, object parameters = null)
    {
        /**
        * @method
        * @name bitget#fetchIsolatedBorrowRate
        * @description fetch the rate of interest to borrow a currency for margin trading
        * @see https://www.bitget.com/api-doc/margin/isolated/account/Isolated-Margin-Interest-Rate-And-Max-Borrowable-Amount
        * @param {string} symbol unified market symbol
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} an [isolated borrow rate structure]{@link https://docs.ccxt.com/#/?id=isolated-borrow-rate-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object response = await this.privateMarginGetV2MarginIsolatedInterestRateAndLimit(this.extend(request, parameters));
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1700878692567,
        //         "data": [
        //             {
        //                 "symbol": "BTCUSDT",
        //                 "leverage": "10",
        //                 "baseCoin": "BTC",
        //                 "baseTransferable": true,
        //                 "baseBorrowable": true,
        //                 "baseDailyInterestRate": "0.00007",
        //                 "baseAnnuallyInterestRate": "0.02555",
        //                 "baseMaxBorrowableAmount": "27",
        //                 "baseVipList": [
        //                     {"level":"0","dailyInterestRate":"0.00007","limit":"27","annuallyInterestRate":"0.02555","discountRate":"1"},
        //                     {"level":"1","dailyInterestRate":"0.0000679","limit":"27.81","annuallyInterestRate":"0.0247835","discountRate":"0.97"},
        //                     {"level":"2","dailyInterestRate":"0.0000644","limit":"29.16","annuallyInterestRate":"0.023506","discountRate":"0.92"},
        //                     {"level":"3","dailyInterestRate":"0.0000602","limit":"31.32","annuallyInterestRate":"0.021973","discountRate":"0.86"},
        //                     {"level":"4","dailyInterestRate":"0.0000525","limit":"35.91","annuallyInterestRate":"0.0191625","discountRate":"0.75"},
        //                     {"level":"5","dailyInterestRate":"0.000042","limit":"44.82","annuallyInterestRate":"0.01533","discountRate":"0.6"}
        //                 ],
        //                 "quoteCoin": "USDT",
        //                 "quoteTransferable": true,
        //                 "quoteBorrowable": true,
        //                 "quoteDailyInterestRate": "0.00041095",
        //                 "quoteAnnuallyInterestRate": "0.14999675",
        //                 "quoteMaxBorrowableAmount": "300000",
        //                 "quoteList": [
        //                     {"level":"0","dailyInterestRate":"0.00041095","limit":"300000","annuallyInterestRate":"0.14999675","discountRate":"1"},
        //                     {"level":"1","dailyInterestRate":"0.00039863","limit":"309000","annuallyInterestRate":"0.14549995","discountRate":"0.97"},
        //                     {"level":"2","dailyInterestRate":"0.00037808","limit":"324000","annuallyInterestRate":"0.1379992","discountRate":"0.92"},
        //                     {"level":"3","dailyInterestRate":"0.00035342","limit":"348000","annuallyInterestRate":"0.1289983","discountRate":"0.86"},
        //                     {"level":"4","dailyInterestRate":"0.00030822","limit":"399000","annuallyInterestRate":"0.1125003","discountRate":"0.75"},
        //                     {"level":"5","dailyInterestRate":"0.00024657","limit":"498000","annuallyInterestRate":"0.08999805","discountRate":"0.6"}
        //                 ]
        //             }
        //         ]
        //     }
        //
        object timestamp = this.safeInteger(response, "requestTime");
        object data = this.safeValue(response, "data", new List<object>() {});
        object first = this.safeValue(data, 0, new Dictionary<string, object>() {});
        ((IDictionary<string,object>)first)["timestamp"] = timestamp;
        return this.parseIsolatedBorrowRate(first, market);
    }

    public override object parseIsolatedBorrowRate(object info, object market = null)
    {
        //
        //     {
        //         "symbol": "BTCUSDT",
        //         "leverage": "10",
        //         "baseCoin": "BTC",
        //         "baseTransferable": true,
        //         "baseBorrowable": true,
        //         "baseDailyInterestRate": "0.00007",
        //         "baseAnnuallyInterestRate": "0.02555",
        //         "baseMaxBorrowableAmount": "27",
        //         "baseVipList": [
        //             {"level":"0","dailyInterestRate":"0.00007","limit":"27","annuallyInterestRate":"0.02555","discountRate":"1"},
        //             {"level":"1","dailyInterestRate":"0.0000679","limit":"27.81","annuallyInterestRate":"0.0247835","discountRate":"0.97"},
        //             {"level":"2","dailyInterestRate":"0.0000644","limit":"29.16","annuallyInterestRate":"0.023506","discountRate":"0.92"},
        //             {"level":"3","dailyInterestRate":"0.0000602","limit":"31.32","annuallyInterestRate":"0.021973","discountRate":"0.86"},
        //             {"level":"4","dailyInterestRate":"0.0000525","limit":"35.91","annuallyInterestRate":"0.0191625","discountRate":"0.75"},
        //             {"level":"5","dailyInterestRate":"0.000042","limit":"44.82","annuallyInterestRate":"0.01533","discountRate":"0.6"}
        //         ],
        //         "quoteCoin": "USDT",
        //         "quoteTransferable": true,
        //         "quoteBorrowable": true,
        //         "quoteDailyInterestRate": "0.00041095",
        //         "quoteAnnuallyInterestRate": "0.14999675",
        //         "quoteMaxBorrowableAmount": "300000",
        //         "quoteList": [
        //             {"level":"0","dailyInterestRate":"0.00041095","limit":"300000","annuallyInterestRate":"0.14999675","discountRate":"1"},
        //             {"level":"1","dailyInterestRate":"0.00039863","limit":"309000","annuallyInterestRate":"0.14549995","discountRate":"0.97"},
        //             {"level":"2","dailyInterestRate":"0.00037808","limit":"324000","annuallyInterestRate":"0.1379992","discountRate":"0.92"},
        //             {"level":"3","dailyInterestRate":"0.00035342","limit":"348000","annuallyInterestRate":"0.1289983","discountRate":"0.86"},
        //             {"level":"4","dailyInterestRate":"0.00030822","limit":"399000","annuallyInterestRate":"0.1125003","discountRate":"0.75"},
        //             {"level":"5","dailyInterestRate":"0.00024657","limit":"498000","annuallyInterestRate":"0.08999805","discountRate":"0.6"}
        //         ]
        //     }
        //
        object marketId = this.safeString(info, "symbol");
        object symbol = this.safeSymbol(marketId, market, null, "spot");
        object baseId = this.safeString(info, "baseCoin");
        object quoteId = this.safeString(info, "quoteCoin");
        object timestamp = this.safeInteger(info, "timestamp");
        return new Dictionary<string, object>() {
            { "symbol", symbol },
            { "base", this.safeCurrencyCode(baseId) },
            { "baseRate", this.safeNumber(info, "baseDailyInterestRate") },
            { "quote", this.safeCurrencyCode(quoteId) },
            { "quoteRate", this.safeNumber(info, "quoteDailyInterestRate") },
            { "period", 86400000 },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "info", info },
        };
    }

    public async override Task<object> fetchCrossBorrowRate(object code, object parameters = null)
    {
        /**
        * @method
        * @name bitget#fetchCrossBorrowRate
        * @description fetch the rate of interest to borrow a currency for margin trading
        * @see https://www.bitget.com/api-doc/margin/cross/account/Get-Cross-Margin-Interest-Rate-And-Borrowable
        * @param {string} code unified currency code
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {string} [params.symbol] required for isolated margin
        * @returns {object} a [borrow rate structure]{@link https://github.com/ccxt/ccxt/wiki/Manual#borrow-rate-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "coin", getValue(currency, "id") },
        };
        object response = await this.privateMarginGetV2MarginCrossedInterestRateAndLimit(this.extend(request, parameters));
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1700879047861,
        //         "data": [
        //             {
        //                 "coin": "BTC",
        //                 "leverage": "3",
        //                 "transferable": true,
        //                 "borrowable": true,
        //                 "dailyInterestRate": "0.00007",
        //                 "annualInterestRate": "0.02555",
        //                 "maxBorrowableAmount": "26",
        //                 "vipList": [
        //                     {"level":"0","limit":"26","dailyInterestRate":"0.00007","annualInterestRate":"0.02555","discountRate":"1"},
        //                     {"level":"1","limit":"26.78","dailyInterestRate":"0.0000679","annualInterestRate":"0.0247835","discountRate":"0.97"},
        //                     {"level":"2","limit":"28.08","dailyInterestRate":"0.0000644","annualInterestRate":"0.023506","discountRate":"0.92"},
        //                     {"level":"3","limit":"30.16","dailyInterestRate":"0.0000602","annualInterestRate":"0.021973","discountRate":"0.86"},
        //                     {"level":"4","limit":"34.58","dailyInterestRate":"0.0000525","annualInterestRate":"0.0191625","discountRate":"0.75"},
        //                     {"level":"5","limit":"43.16","dailyInterestRate":"0.000042","annualInterestRate":"0.01533","discountRate":"0.6"}
        //                 ]
        //             }
        //         ]
        //     }
        //
        object timestamp = this.safeInteger(response, "requestTime");
        object data = this.safeValue(response, "data", new List<object>() {});
        object first = this.safeValue(data, 0, new Dictionary<string, object>() {});
        ((IDictionary<string,object>)first)["timestamp"] = timestamp;
        return this.parseBorrowRate(first, currency);
    }

    public virtual object parseBorrowRate(object info, object currency = null)
    {
        //
        //     {
        //         "coin": "BTC",
        //         "leverage": "3",
        //         "transferable": true,
        //         "borrowable": true,
        //         "dailyInterestRate": "0.00007",
        //         "annualInterestRate": "0.02555",
        //         "maxBorrowableAmount": "26",
        //         "vipList": [
        //             {"level":"0","limit":"26","dailyInterestRate":"0.00007","annualInterestRate":"0.02555","discountRate":"1"},
        //             {"level":"1","limit":"26.78","dailyInterestRate":"0.0000679","annualInterestRate":"0.0247835","discountRate":"0.97"},
        //             {"level":"2","limit":"28.08","dailyInterestRate":"0.0000644","annualInterestRate":"0.023506","discountRate":"0.92"},
        //             {"level":"3","limit":"30.16","dailyInterestRate":"0.0000602","annualInterestRate":"0.021973","discountRate":"0.86"},
        //             {"level":"4","limit":"34.58","dailyInterestRate":"0.0000525","annualInterestRate":"0.0191625","discountRate":"0.75"},
        //             {"level":"5","limit":"43.16","dailyInterestRate":"0.000042","annualInterestRate":"0.01533","discountRate":"0.6"}
        //         ]
        //     }
        //
        object currencyId = this.safeString(info, "coin");
        object timestamp = this.safeInteger(info, "timestamp");
        return new Dictionary<string, object>() {
            { "currency", this.safeCurrencyCode(currencyId, currency) },
            { "rate", this.safeNumber(info, "dailyInterestRate") },
            { "period", 86400000 },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "info", info },
        };
    }

    public async override Task<object> fetchBorrowInterest(object code = null, object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bitget#fetchBorrowInterest
        * @description fetch the interest owed by the user for borrowing currency for margin trading
        * @see https://www.bitget.com/api-doc/margin/cross/record/Get-Cross-Interest-Records
        * @see https://www.bitget.com/api-doc/margin/isolated/record/Get-Isolated-Interest-Records
        * @param {string} [code] unified currency code
        * @param {string} [symbol] unified market symbol when fetching interest in isolated markets
        * @param {int} [since] the earliest time in ms to fetch borrow interest for
        * @param {int} [limit] the maximum number of structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [available parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
        * @returns {object[]} a list of [borrow interest structures]{@link https://docs.ccxt.com/#/?id=borrow-interest-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object paginate = false;
        var paginateparametersVariable = this.handleOptionAndParams(parameters, "fetchBorrowInterest", "paginate");
        paginate = ((IList<object>)paginateparametersVariable)[0];
        parameters = ((IList<object>)paginateparametersVariable)[1];
        if (isTrue(paginate))
        {
            return await this.fetchPaginatedCallCursor("fetchBorrowInterest", symbol, since, limit, parameters, "minId", "idLessThan");
        }
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
        }
        object request = new Dictionary<string, object>() {};
        object currency = null;
        if (isTrue(!isEqual(code, null)))
        {
            currency = this.currency(code);
            ((IDictionary<string,object>)request)["coin"] = getValue(currency, "id");
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["startTime"] = since;
        } else
        {
            ((IDictionary<string,object>)request)["startTime"] = subtract(this.milliseconds(), 7776000000);
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        object response = null;
        object marginMode = null;
        var marginModeparametersVariable = this.handleMarginModeAndParams("fetchBorrowInterest", parameters, "cross");
        marginMode = ((IList<object>)marginModeparametersVariable)[0];
        parameters = ((IList<object>)marginModeparametersVariable)[1];
        if (isTrue(isEqual(marginMode, "isolated")))
        {
            if (isTrue(isEqual(symbol, null)))
            {
                throw new ArgumentsRequired ((string)add(this.id, " fetchBorrowInterest() requires a symbol argument")) ;
            }
            ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
            response = await this.privateMarginGetV2MarginIsolatedInterestHistory(this.extend(request, parameters));
        } else if (isTrue(isEqual(marginMode, "cross")))
        {
            response = await this.privateMarginGetV2MarginCrossedInterestHistory(this.extend(request, parameters));
        }
        //
        // isolated
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1700879935189,
        //         "data": {
        //             "resultList": [
        //                 {
        //                     "interestId": "1112125304879067137",
        //                     "interestCoin": "USDT",
        //                     "dailyInterestRate": "0.00041095",
        //                     "loanCoin": "USDT",
        //                     "interestAmount": "0.0000685",
        //                     "interstType": "first",
        //                     "symbol": "BTCUSDT",
        //                     "cTime": "1700877255648",
        //                     "uTime": "1700877255648"
        //                 },
        //             ],
        //             "maxId": "1112125304879067137",
        //             "minId": "1100138015672119298"
        //         }
        //     }
        //
        // cross
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1700879597044,
        //         "data": {
        //             "resultList": [
        //                 {
        //                     "interestId": "1112122013642272769",
        //                     "interestCoin": "USDT",
        //                     "dailyInterestRate": "0.00041",
        //                     "loanCoin": "USDT",
        //                     "interestAmount": "0.00006834",
        //                     "interstType": "first",
        //                     "cTime": "1700876470957",
        //                     "uTime": "1700876470957"
        //                 },
        //             ],
        //             "maxId": "1112122013642272769",
        //             "minId": "1096917004629716993"
        //         }
        //     }
        //
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        object rows = this.safeValue(data, "resultList", new List<object>() {});
        object interest = this.parseBorrowInterests(rows, market);
        return this.filterByCurrencySinceLimit(interest, code, since, limit);
    }

    public override object parseBorrowInterest(object info, object market = null)
    {
        //
        // isolated
        //
        //     {
        //         "interestId": "1112125304879067137",
        //         "interestCoin": "USDT",
        //         "dailyInterestRate": "0.00041095",
        //         "loanCoin": "USDT",
        //         "interestAmount": "0.0000685",
        //         "interstType": "first",
        //         "symbol": "BTCUSDT",
        //         "cTime": "1700877255648",
        //         "uTime": "1700877255648"
        //     }
        //
        // cross
        //
        //     {
        //         "interestId": "1112122013642272769",
        //         "interestCoin": "USDT",
        //         "dailyInterestRate": "0.00041",
        //         "loanCoin": "USDT",
        //         "interestAmount": "0.00006834",
        //         "interstType": "first",
        //         "cTime": "1700876470957",
        //         "uTime": "1700876470957"
        //     }
        //
        object marketId = this.safeString(info, "symbol");
        market = this.safeMarket(marketId, market);
        object marginMode = ((bool) isTrue((!isEqual(marketId, null)))) ? "isolated" : "cross";
        object timestamp = this.safeInteger(info, "cTime");
        return new Dictionary<string, object>() {
            { "symbol", this.safeString(market, "symbol") },
            { "marginMode", marginMode },
            { "currency", this.safeCurrencyCode(this.safeString(info, "interestCoin")) },
            { "interest", this.safeNumber(info, "interestAmount") },
            { "interestRate", this.safeNumber(info, "dailyInterestRate") },
            { "amountBorrowed", null },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "info", info },
        };
    }

    public async override Task<object> closePosition(object symbol, object side = null, object parameters = null)
    {
        /**
        * @method
        * @name bitget#closePosition
        * @description closes an open position for a market
        * @see https://www.bitget.com/api-doc/contract/trade/Flash-Close-Position
        * @param {string} symbol unified CCXT market symbol
        * @param {string} [side] one-way mode: 'buy' or 'sell', hedge-mode: 'long' or 'short'
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object sandboxMode = this.safeBool(this.options, "sandboxMode", false);
        object market = null;
        if (isTrue(sandboxMode))
        {
            object sandboxSymbol = this.convertSymbolForSandbox(symbol);
            market = this.market(sandboxSymbol);
        } else
        {
            market = this.market(symbol);
        }
        object productType = null;
        var productTypeparametersVariable = this.handleProductTypeAndParams(market, parameters);
        productType = ((IList<object>)productTypeparametersVariable)[0];
        parameters = ((IList<object>)productTypeparametersVariable)[1];
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
            { "productType", productType },
        };
        if (isTrue(!isEqual(side, null)))
        {
            ((IDictionary<string,object>)request)["holdSide"] = side;
        }
        object response = await this.privateMixPostV2MixOrderClosePositions(this.extend(request, parameters));
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1702975017017,
        //         "data": {
        //             "successList": [
        //                 {
        //                     "orderId": "1120923953904893955",
        //                     "clientOid": "1120923953904893956"
        //                 }
        //             ],
        //             "failureList": [],
        //             "result": false
        //         }
        //     }
        //
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        object order = this.safeList(data, "successList", new List<object>() {});
        return this.parseOrder(getValue(order, 0), market);
    }

    public async override Task<object> closeAllPositions(object parameters = null)
    {
        /**
        * @method
        * @name bitget#closeAllPositions
        * @description closes all open positions for a market type
        * @see https://www.bitget.com/api-doc/contract/trade/Flash-Close-Position
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {string} [params.productType] 'USDT-FUTURES', 'USDC-FUTURES', 'COIN-FUTURES', 'SUSDT-FUTURES', 'SUSDC-FUTURES' or 'SCOIN-FUTURES'
        * @returns {object[]} A list of [position structures]{@link https://docs.ccxt.com/#/?id=position-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object productType = null;
        var productTypeparametersVariable = this.handleProductTypeAndParams(null, parameters);
        productType = ((IList<object>)productTypeparametersVariable)[0];
        parameters = ((IList<object>)productTypeparametersVariable)[1];
        object request = new Dictionary<string, object>() {
            { "productType", productType },
        };
        object response = await this.privateMixPostV2MixOrderClosePositions(this.extend(request, parameters));
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1702975017017,
        //         "data": {
        //             "successList": [
        //                 {
        //                     "orderId": "1120923953904893955",
        //                     "clientOid": "1120923953904893956"
        //                 }
        //             ],
        //             "failureList": [],
        //             "result": false
        //         }
        //     }
        //
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        object orderInfo = this.safeList(data, "successList", new List<object>() {});
        return this.parsePositions(orderInfo, null, parameters);
    }

    public async override Task<object> fetchMarginMode(object symbol, object parameters = null)
    {
        /**
        * @method
        * @name bitget#fetchMarginMode
        * @description fetches the margin mode of a trading pair
        * @see https://www.bitget.com/api-doc/contract/account/Get-Single-Account
        * @param {string} symbol unified symbol of the market to fetch the margin mode for
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [margin mode structure]{@link https://docs.ccxt.com/#/?id=margin-mode-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object sandboxMode = this.safeBool(this.options, "sandboxMode", false);
        object market = null;
        if (isTrue(sandboxMode))
        {
            object sandboxSymbol = this.convertSymbolForSandbox(symbol);
            market = this.market(sandboxSymbol);
        } else
        {
            market = this.market(symbol);
        }
        object productType = null;
        var productTypeparametersVariable = this.handleProductTypeAndParams(market, parameters);
        productType = ((IList<object>)productTypeparametersVariable)[0];
        parameters = ((IList<object>)productTypeparametersVariable)[1];
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
            { "marginCoin", getValue(market, "settleId") },
            { "productType", productType },
        };
        object response = await this.privateMixGetV2MixAccountAccount(this.extend(request, parameters));
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1709791216652,
        //         "data": {
        //             "marginCoin": "USDT",
        //             "locked": "0",
        //             "available": "19.88811074",
        //             "crossedMaxAvailable": "19.88811074",
        //             "isolatedMaxAvailable": "19.88811074",
        //             "maxTransferOut": "19.88811074",
        //             "accountEquity": "19.88811074",
        //             "usdtEquity": "19.888110749166",
        //             "btcEquity": "0.000302183391",
        //             "crossedRiskRate": "0",
        //             "crossedMarginLeverage": 20,
        //             "isolatedLongLever": 20,
        //             "isolatedShortLever": 20,
        //             "marginMode": "crossed",
        //             "posMode": "hedge_mode",
        //             "unrealizedPL": "0",
        //             "coupon": "0",
        //             "crossedUnrealizedPL": "0",
        //             "isolatedUnrealizedPL": ""
        //         }
        //     }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        return this.parseMarginMode(data, market);
    }

    public override object parseMarginMode(object marginMode, object market = null)
    {
        object marginType = this.safeString(marginMode, "marginMode");
        marginType = ((bool) isTrue((isEqual(marginType, "crossed")))) ? "cross" : marginType;
        return new Dictionary<string, object>() {
            { "info", marginMode },
            { "symbol", getValue(market, "symbol") },
            { "marginMode", marginType },
        };
    }

    public async override Task<object> fetchPositionsHistory(object symbols = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bitget#fetchPositionsHistory
        * @description fetches historical positions
        * @see https://www.bitget.com/api-doc/contract/position/Get-History-Position
        * @param {string[]} [symbols] unified contract symbols
        * @param {int} [since] timestamp in ms of the earliest position to fetch, default=3 months ago, max range for params["until"] - since is 3 months
        * @param {int} [limit] the maximum amount of records to fetch, default=20, max=100
        * @param {object} params extra parameters specific to the exchange api endpoint
        * @param {int} [params.until] timestamp in ms of the latest position to fetch, max range for params["until"] - since is 3 months
        *
        * EXCHANGE SPECIFIC PARAMETERS
        * @param {string} [params.productType] USDT-FUTURES (default), COIN-FUTURES, USDC-FUTURES, SUSDT-FUTURES, SCOIN-FUTURES, or SUSDC-FUTURES
        * @returns {object[]} a list of [position structures]{@link https://docs.ccxt.com/#/?id=position-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object until = this.safeInteger(parameters, "until");
        parameters = this.omit(parameters, "until");
        object request = new Dictionary<string, object>() {};
        if (isTrue(!isEqual(symbols, null)))
        {
            object symbolsLength = getArrayLength(symbols);
            if (isTrue(isGreaterThan(symbolsLength, 0)))
            {
                object market = this.market(getValue(symbols, 0));
                ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
            }
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["startTime"] = since;
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        if (isTrue(!isEqual(until, null)))
        {
            ((IDictionary<string,object>)request)["endTime"] = until;
        }
        object response = await this.privateMixGetV2MixPositionHistoryPosition(this.extend(request, parameters));
        //
        //    {
        //        code: '00000',
        //        msg: 'success',
        //        requestTime: '1712794148791',
        //        data: {
        //            list: [
        //                {
        //                    symbol: 'XRPUSDT',
        //                    marginCoin: 'USDT',
        //                    holdSide: 'long',
        //                    openAvgPrice: '0.64967',
        //                    closeAvgPrice: '0.58799',
        //                    marginMode: 'isolated',
        //                    openTotalPos: '10',
        //                    closeTotalPos: '10',
        //                    pnl: '-0.62976205',
        //                    netProfit: '-0.65356802',
        //                    totalFunding: '-0.01638',
        //                    openFee: '-0.00389802',
        //                    closeFee: '-0.00352794',
        //                    ctime: '1709590322199',
        //                    utime: '1709667583395'
        //                },
        //                ...
        //            ]
        //        }
        //    }
        //
        object data = this.safeDict(response, "data");
        object responseList = this.safeList(data, "list");
        object positions = this.parsePositions(responseList, symbols, parameters);
        return this.filterBySinceLimit(positions, since, limit);
    }

    public async override Task<object> fetchConvertQuote(object fromCode, object toCode, object amount = null, object parameters = null)
    {
        /**
        * @method
        * @name bitget#fetchConvertQuote
        * @description fetch a quote for converting from one currency to another
        * @see https://www.bitget.com/api-doc/common/convert/Get-Quoted-Price
        * @param {string} fromCode the currency that you want to sell and convert from
        * @param {string} toCode the currency that you want to buy and convert into
        * @param {float} [amount] how much you want to trade in units of the from currency
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [conversion structure]{@link https://docs.ccxt.com/#/?id=conversion-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {
            { "fromCoin", fromCode },
            { "toCoin", toCode },
            { "fromCoinSize", this.numberToString(amount) },
        };
        object response = await this.privateConvertGetV2ConvertQuotedPrice(this.extend(request, parameters));
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1712121940158,
        //         "data": {
        //             "fromCoin": "USDT",
        //             "fromCoinSize": "5",
        //             "cnvtPrice": "0.9993007892377704",
        //             "toCoin": "USDC",
        //             "toCoinSize": "4.99650394",
        //             "traceId": "1159288930228187140",
        //             "fee": "0"
        //         }
        //     }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        object fromCurrencyId = this.safeString(data, "fromCoin", fromCode);
        object fromCurrency = this.currency(fromCurrencyId);
        object toCurrencyId = this.safeString(data, "toCoin", toCode);
        object toCurrency = this.currency(toCurrencyId);
        return this.parseConversion(data, fromCurrency, toCurrency);
    }

    public async virtual Task<object> createConvertTrade(object id, object fromCode, object toCode, object amount = null, object parameters = null)
    {
        /**
        * @method
        * @name bitget#createConvertTrade
        * @description convert from one currency to another
        * @see https://www.bitget.com/api-doc/common/convert/Trade
        * @param {string} id the id of the trade that you want to make
        * @param {string} fromCode the currency that you want to sell and convert from
        * @param {string} toCode the currency that you want to buy and convert into
        * @param {float} amount how much you want to trade in units of the from currency
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {string} params.price the price of the conversion, obtained from fetchConvertQuote()
        * @param {string} params.toAmount the amount you want to trade in units of the toCurrency, obtained from fetchConvertQuote()
        * @returns {object} a [conversion structure]{@link https://docs.ccxt.com/#/?id=conversion-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object price = this.safeString2(parameters, "price", "cnvtPrice");
        if (isTrue(isEqual(price, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " createConvertTrade() requires a price parameter")) ;
        }
        object toAmount = this.safeString2(parameters, "toAmount", "toCoinSize");
        if (isTrue(isEqual(toAmount, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " createConvertTrade() requires a toAmount parameter")) ;
        }
        parameters = this.omit(parameters, new List<object>() {"price", "toAmount"});
        object request = new Dictionary<string, object>() {
            { "traceId", id },
            { "fromCoin", fromCode },
            { "toCoin", toCode },
            { "fromCoinSize", this.numberToString(amount) },
            { "toCoinSize", toAmount },
            { "cnvtPrice", price },
        };
        object response = await this.privateConvertPostV2ConvertTrade(this.extend(request, parameters));
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1712123746203,
        //         "data": {
        //             "cnvtPrice": "0.99940076",
        //             "toCoin": "USDC",
        //             "toCoinSize": "4.99700379",
        //             "ts": "1712123746217"
        //         }
        //     }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        object toCurrencyId = this.safeString(data, "toCoin", toCode);
        object toCurrency = this.currency(toCurrencyId);
        return this.parseConversion(data, null, toCurrency);
    }

    public async virtual Task<object> fetchConvertTradeHistory(object code = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bitget#fetchConvertTradeHistory
        * @description fetch the users history of conversion trades
        * @see https://www.bitget.com/api-doc/common/convert/Get-Convert-Record
        * @param {string} [code] the unified currency code
        * @param {int} [since] the earliest time in ms to fetch conversions for
        * @param {int} [limit] the maximum number of conversion structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} a list of [conversion structures]{@link https://docs.ccxt.com/#/?id=conversion-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object msInDay = 86400000;
        object now = this.milliseconds();
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["startTime"] = since;
        } else
        {
            ((IDictionary<string,object>)request)["startTime"] = subtract(now, msInDay);
        }
        object endTime = this.safeString2(parameters, "endTime", "until");
        if (isTrue(!isEqual(endTime, null)))
        {
            ((IDictionary<string,object>)request)["endTime"] = endTime;
        } else
        {
            ((IDictionary<string,object>)request)["endTime"] = now;
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        parameters = this.omit(parameters, "until");
        object response = await this.privateConvertGetV2ConvertConvertRecord(this.extend(request, parameters));
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1712124371799,
        //         "data": {
        //             "dataList": [
        //                 {
        //                     "id": "1159296505255219205",
        //                     "fromCoin": "USDT",
        //                     "fromCoinSize": "5",
        //                     "cnvtPrice": "0.99940076",
        //                     "toCoin": "USDC",
        //                     "toCoinSize": "4.99700379",
        //                     "ts": "1712123746217",
        //                     "fee": "0"
        //                 }
        //             ],
        //             "endId": "1159296505255219205"
        //         }
        //     }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        object dataList = this.safeList(data, "dataList", new List<object>() {});
        return this.parseConversions(dataList, code, "fromCoin", "toCoin", since, limit);
    }

    public override object parseConversion(object conversion, object fromCurrency = null, object toCurrency = null)
    {
        //
        // fetchConvertQuote
        //
        //     {
        //         "fromCoin": "USDT",
        //         "fromCoinSize": "5",
        //         "cnvtPrice": "0.9993007892377704",
        //         "toCoin": "USDC",
        //         "toCoinSize": "4.99650394",
        //         "traceId": "1159288930228187140",
        //         "fee": "0"
        //     }
        //
        // createConvertTrade
        //
        //     {
        //         "cnvtPrice": "0.99940076",
        //         "toCoin": "USDC",
        //         "toCoinSize": "4.99700379",
        //         "ts": "1712123746217"
        //     }
        //
        // fetchConvertTradeHistory
        //
        //     {
        //         "id": "1159296505255219205",
        //         "fromCoin": "USDT",
        //         "fromCoinSize": "5",
        //         "cnvtPrice": "0.99940076",
        //         "toCoin": "USDC",
        //         "toCoinSize": "4.99700379",
        //         "ts": "1712123746217",
        //         "fee": "0"
        //     }
        //
        object timestamp = this.safeInteger(conversion, "ts");
        object fromCoin = this.safeString(conversion, "fromCoin");
        object fromCode = this.safeCurrencyCode(fromCoin, fromCurrency);
        object to = this.safeString(conversion, "toCoin");
        object toCode = this.safeCurrencyCode(to, toCurrency);
        return new Dictionary<string, object>() {
            { "info", conversion },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "id", this.safeString2(conversion, "id", "traceId") },
            { "fromCurrency", fromCode },
            { "fromAmount", this.safeNumber(conversion, "fromCoinSize") },
            { "toCurrency", toCode },
            { "toAmount", this.safeNumber(conversion, "toCoinSize") },
            { "price", this.safeNumber(conversion, "cnvtPrice") },
            { "fee", this.safeNumber(conversion, "fee") },
        };
    }

    public async override Task<object> fetchConvertCurrencies(object parameters = null)
    {
        /**
        * @method
        * @name bitget#fetchConvertCurrencies
        * @description fetches all available currencies that can be converted
        * @see https://www.bitget.com/api-doc/common/convert/Get-Convert-Currencies
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} an associative dictionary of currencies
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.privateConvertGetV2ConvertCurrencies(parameters);
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1712121755897,
        //         "data": [
        //             {
        //                 "coin": "BTC",
        //                 "available": "0.00009850",
        //                 "maxAmount": "0.756266",
        //                 "minAmount": "0.00001"
        //             },
        //         ]
        //     }
        //
        object result = new Dictionary<string, object>() {};
        object data = this.safeList(response, "data", new List<object>() {});
        for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
        {
            object entry = getValue(data, i);
            object id = this.safeString(entry, "coin");
            object code = this.safeCurrencyCode(id);
            ((IDictionary<string,object>)result)[(string)code] = new Dictionary<string, object>() {
                { "info", entry },
                { "id", id },
                { "code", code },
                { "networks", null },
                { "type", null },
                { "name", null },
                { "active", null },
                { "deposit", null },
                { "withdraw", this.safeNumber(entry, "available") },
                { "fee", null },
                { "precision", null },
                { "limits", new Dictionary<string, object>() {
                    { "amount", new Dictionary<string, object>() {
                        { "min", this.safeNumber(entry, "minAmount") },
                        { "max", this.safeNumber(entry, "maxAmount") },
                    } },
                    { "withdraw", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                    { "deposit", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                } },
                { "created", null },
            };
        }
        return result;
    }

    public override object handleErrors(object code, object reason, object url, object method, object headers, object body, object response, object requestHeaders, object requestBody)
    {
        if (!isTrue(response))
        {
            return null;  // fallback to default error handler
        }
        //
        // spot
        //
        //     {"code":"00000","msg":"success","requestTime":1713294492511,"data":[...]}"
        //
        //     {"status":"fail","err_code":"01001","err_msg":"系统异常，请稍后重试"}
        //     {"status":"error","ts":1595594160149,"err_code":"invalid-parameter","err_msg":"invalid size, valid range: [1,2000]"}
        //     {"status":"error","ts":1595684716042,"err_code":"invalid-parameter","err_msg":"illegal sign invalid"}
        //     {"status":"error","ts":1595700216275,"err_code":"bad-request","err_msg":"your balance is low!"}
        //     {"status":"error","ts":1595700344504,"err_code":"invalid-parameter","err_msg":"invalid type"}
        //     {"status":"error","ts":1595703343035,"err_code":"bad-request","err_msg":"order cancel fail"}
        //     {"status":"error","ts":1595704360508,"err_code":"invalid-parameter","err_msg":"accesskey not null"}
        //     {"status":"error","ts":1595704490084,"err_code":"invalid-parameter","err_msg":"permissions not right"}
        //     {"status":"error","ts":1595711862763,"err_code":"system exception","err_msg":"system exception"}
        //     {"status":"error","ts":1595730308979,"err_code":"bad-request","err_msg":"20003"}
        //
        // swap
        //
        //     {"code":"40015","msg":"","requestTime":1595698564931,"data":null}
        //     {"code":"40017","msg":"Order id must not be blank","requestTime":1595702477835,"data":null}
        //     {"code":"40017","msg":"Order Type must not be blank","requestTime":1595698516162,"data":null}
        //     {"code":"40301","msg":"","requestTime":1595667662503,"data":null}
        //     {"code":"40017","msg":"Contract code must not be blank","requestTime":1595703151651,"data":null}
        //     {"code":"40108","msg":"","requestTime":1595885064600,"data":null}
        //     {"order_id":"513468410013679613","client_oid":null,"symbol":"ethusd","result":false,"err_code":"order_no_exist_error","err_msg":"订单不存在！"}
        //
        object message = this.safeString2(response, "err_msg", "msg");
        object feedback = add(add(this.id, " "), body);
        object nonEmptyMessage = (isTrue(isTrue((!isEqual(message, null))) && isTrue((!isEqual(message, "")))) && isTrue((!isEqual(message, "success"))));
        if (isTrue(nonEmptyMessage))
        {
            this.throwExactlyMatchedException(getValue(this.exceptions, "exact"), message, feedback);
            this.throwBroadlyMatchedException(getValue(this.exceptions, "broad"), message, feedback);
        }
        object errorCode = this.safeString2(response, "code", "err_code");
        object nonZeroErrorCode = isTrue((!isEqual(errorCode, null))) && isTrue((!isEqual(errorCode, "00000")));
        if (isTrue(nonZeroErrorCode))
        {
            this.throwExactlyMatchedException(getValue(this.exceptions, "exact"), errorCode, feedback);
        }
        if (isTrue(isTrue(nonZeroErrorCode) || isTrue(nonEmptyMessage)))
        {
            throw new ExchangeError ((string)feedback) ;
        }
        return null;
    }

    public override object sign(object path, object api = null, object method = null, object parameters = null, object headers = null, object body = null)
    {
        api ??= new List<object>();
        method ??= "GET";
        parameters ??= new Dictionary<string, object>();
        object signed = isEqual(getValue(api, 0), "private");
        object endpoint = getValue(api, 1);
        object pathPart = "/api";
        object request = add("/", this.implodeParams(path, parameters));
        object payload = add(pathPart, request);
        object url = add(this.implodeHostname(getValue(getValue(this.urls, "api"), endpoint)), payload);
        object query = this.omit(parameters, this.extractParams(path));
        if (isTrue(!isTrue(signed) && isTrue((isEqual(method, "GET")))))
        {
            object keys = new List<object>(((IDictionary<string,object>)query).Keys);
            object keysLength = getArrayLength(keys);
            if (isTrue(isGreaterThan(keysLength, 0)))
            {
                url = add(add(url, "?"), this.urlencode(query));
            }
        }
        if (isTrue(signed))
        {
            this.checkRequiredCredentials();
            object timestamp = ((object)this.milliseconds()).ToString();
            object auth = add(add(timestamp, method), payload);
            if (isTrue(isEqual(method, "POST")))
            {
                body = this.json(parameters);
                auth = add(auth, body);
            } else
            {
                if (isTrue(getArrayLength(new List<object>(((IDictionary<string,object>)parameters).Keys))))
                {
                    object queryInner = add("?", this.urlencode(this.keysort(parameters)));
                    // check #21169 pr
                    if (isTrue(isGreaterThan(getIndexOf(queryInner, "%24"), -1)))
                    {
                        queryInner = ((string)queryInner).Replace((string)"%24", (string)"$");
                    }
                    url = add(url, queryInner);
                    auth = add(auth, queryInner);
                }
            }
            object signature = this.hmac(this.encode(auth), this.encode(this.secret), sha256, "base64");
            object broker = this.safeString(this.options, "broker");
            headers = new Dictionary<string, object>() {
                { "ACCESS-KEY", this.apiKey },
                { "ACCESS-SIGN", signature },
                { "ACCESS-TIMESTAMP", timestamp },
                { "ACCESS-PASSPHRASE", this.password },
                { "X-CHANNEL-API-CODE", broker },
            };
            if (isTrue(isEqual(method, "POST")))
            {
                ((IDictionary<string,object>)headers)["Content-Type"] = "application/json";
            }
        }
        return new Dictionary<string, object>() {
            { "url", url },
            { "method", method },
            { "body", body },
            { "headers", headers },
        };
    }
}
