namespace ccxt;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

public partial class bitget : Exchange
{
    public override object describe()
    {
        return this.deepExtend(base.describe(), new Dictionary<string, object>() {
            { "id", "bitget" },
            { "name", "Bitget" },
            { "countries", new List<object>() {"SG"} },
            { "version", "v2" },
            { "rateLimit", 50 },
            { "certified", true },
            { "pro", true },
            { "has", new Dictionary<string, object>() {
                { "CORS", null },
                { "spot", true },
                { "margin", true },
                { "swap", true },
                { "future", true },
                { "option", false },
                { "addMargin", true },
                { "borrowCrossMargin", true },
                { "borrowIsolatedMargin", true },
                { "cancelAllOrders", true },
                { "cancelOrder", true },
                { "cancelOrders", true },
                { "closeAllPositions", true },
                { "closePosition", true },
                { "createConvertTrade", true },
                { "createDepositAddress", false },
                { "createMarketBuyOrderWithCost", true },
                { "createMarketOrderWithCost", false },
                { "createMarketSellOrderWithCost", false },
                { "createOrder", true },
                { "createOrders", true },
                { "createOrderWithTakeProfitAndStopLoss", true },
                { "createPostOnlyOrder", true },
                { "createReduceOnlyOrder", false },
                { "createStopLimitOrder", true },
                { "createStopLossOrder", true },
                { "createStopMarketOrder", true },
                { "createStopOrder", true },
                { "createTakeProfitOrder", true },
                { "createTrailingAmountOrder", false },
                { "createTrailingPercentOrder", true },
                { "createTriggerOrder", true },
                { "editOrder", true },
                { "fetchAccounts", false },
                { "fetchBalance", true },
                { "fetchBorrowInterest", true },
                { "fetchBorrowRateHistories", false },
                { "fetchBorrowRateHistory", false },
                { "fetchCanceledAndClosedOrders", true },
                { "fetchCanceledOrders", true },
                { "fetchClosedOrders", true },
                { "fetchConvertCurrencies", true },
                { "fetchConvertQuote", true },
                { "fetchConvertTrade", false },
                { "fetchConvertTradeHistory", true },
                { "fetchCrossBorrowRate", true },
                { "fetchCrossBorrowRates", false },
                { "fetchCurrencies", true },
                { "fetchDeposit", false },
                { "fetchDepositAddress", true },
                { "fetchDepositAddresses", false },
                { "fetchDepositAddressesByNetwork", false },
                { "fetchDeposits", true },
                { "fetchDepositsWithdrawals", false },
                { "fetchDepositWithdrawFee", "emulated" },
                { "fetchDepositWithdrawFees", true },
                { "fetchFundingHistory", true },
                { "fetchFundingInterval", true },
                { "fetchFundingIntervals", true },
                { "fetchFundingRate", true },
                { "fetchFundingRateHistory", true },
                { "fetchFundingRates", true },
                { "fetchIndexOHLCV", true },
                { "fetchIsolatedBorrowRate", true },
                { "fetchIsolatedBorrowRates", false },
                { "fetchLedger", true },
                { "fetchLeverage", true },
                { "fetchLeverageTiers", false },
                { "fetchLiquidations", false },
                { "fetchLongShortRatio", false },
                { "fetchLongShortRatioHistory", true },
                { "fetchMarginAdjustmentHistory", false },
                { "fetchMarginMode", true },
                { "fetchMarketLeverageTiers", true },
                { "fetchMarkets", true },
                { "fetchMarkOHLCV", true },
                { "fetchMarkPrice", true },
                { "fetchMyLiquidations", true },
                { "fetchMyTrades", true },
                { "fetchOHLCV", true },
                { "fetchOpenInterest", true },
                { "fetchOpenInterestHistory", false },
                { "fetchOpenOrders", true },
                { "fetchOrder", true },
                { "fetchOrderBook", true },
                { "fetchOrderBooks", false },
                { "fetchOrders", false },
                { "fetchOrderTrades", false },
                { "fetchPosition", true },
                { "fetchPositionHistory", "emulated" },
                { "fetchPositionMode", false },
                { "fetchPositions", true },
                { "fetchPositionsHistory", true },
                { "fetchPositionsRisk", false },
                { "fetchPremiumIndexOHLCV", false },
                { "fetchStatus", false },
                { "fetchTicker", true },
                { "fetchTickers", true },
                { "fetchTime", true },
                { "fetchTrades", true },
                { "fetchTradingFee", true },
                { "fetchTradingFees", true },
                { "fetchTransactions", false },
                { "fetchTransfer", false },
                { "fetchTransfers", true },
                { "fetchWithdrawAddresses", false },
                { "fetchWithdrawal", false },
                { "fetchWithdrawals", true },
                { "reduceMargin", true },
                { "repayCrossMargin", true },
                { "repayIsolatedMargin", true },
                { "setLeverage", true },
                { "setMargin", false },
                { "setMarginMode", true },
                { "setPositionMode", true },
                { "signIn", false },
                { "transfer", true },
                { "withdraw", true },
            } },
            { "timeframes", new Dictionary<string, object>() {
                { "1m", "1m" },
                { "3m", "3m" },
                { "5m", "5m" },
                { "15m", "15m" },
                { "30m", "30m" },
                { "1h", "1h" },
                { "2h", "2h" },
                { "4h", "4h" },
                { "6h", "6h" },
                { "12h", "12h" },
                { "1d", "1d" },
                { "3d", "3d" },
                { "1w", "1w" },
                { "1M", "1m" },
            } },
            { "hostname", "bitget.com" },
            { "urls", new Dictionary<string, object>() {
                { "logo", "https://github.com/user-attachments/assets/fbaa10cc-a277-441d-a5b7-997dd9a87658" },
                { "api", new Dictionary<string, object>() {
                    { "spot", "https://api.{hostname}" },
                    { "mix", "https://api.{hostname}" },
                    { "user", "https://api.{hostname}" },
                    { "p2p", "https://api.{hostname}" },
                    { "broker", "https://api.{hostname}" },
                    { "margin", "https://api.{hostname}" },
                    { "common", "https://api.{hostname}" },
                    { "tax", "https://api.{hostname}" },
                    { "convert", "https://api.{hostname}" },
                    { "copy", "https://api.{hostname}" },
                    { "earn", "https://api.{hostname}" },
                    { "uta", "https://api.{hostname}" },
                } },
                { "www", "https://www.bitget.com" },
                { "doc", new List<object>() {"https://www.bitget.com/api-doc/common/intro", "https://www.bitget.com/api-doc/spot/intro", "https://www.bitget.com/api-doc/contract/intro", "https://www.bitget.com/api-doc/broker/intro", "https://www.bitget.com/api-doc/margin/intro", "https://www.bitget.com/api-doc/copytrading/intro", "https://www.bitget.com/api-doc/earn/intro", "https://bitgetlimited.github.io/apidoc/en/mix", "https://bitgetlimited.github.io/apidoc/en/spot", "https://bitgetlimited.github.io/apidoc/en/broker", "https://bitgetlimited.github.io/apidoc/en/margin"} },
                { "fees", "https://www.bitget.cc/zh-CN/rate?tab=1" },
                { "referral", "https://www.bitget.com/expressly?languageType=0&channelCode=ccxt&vipCode=tg9j" },
            } },
            { "api", new Dictionary<string, object>() {
                { "public", new Dictionary<string, object>() {
                    { "common", new Dictionary<string, object>() {
                        { "get", new Dictionary<string, object>() {
                            { "v2/public/annoucements", 1 },
                            { "v2/public/time", 1 },
                        } },
                    } },
                    { "spot", new Dictionary<string, object>() {
                        { "get", new Dictionary<string, object>() {
                            { "spot/v1/notice/queryAllNotices", 1 },
                            { "spot/v1/public/time", 1 },
                            { "spot/v1/public/currencies", 6.6667 },
                            { "spot/v1/public/products", 1 },
                            { "spot/v1/public/product", 1 },
                            { "spot/v1/market/ticker", 1 },
                            { "spot/v1/market/tickers", 1 },
                            { "spot/v1/market/fills", 2 },
                            { "spot/v1/market/fills-history", 2 },
                            { "spot/v1/market/candles", 1 },
                            { "spot/v1/market/depth", 1 },
                            { "spot/v1/market/spot-vip-level", 2 },
                            { "spot/v1/market/merge-depth", 1 },
                            { "spot/v1/market/history-candles", 1 },
                            { "spot/v1/public/loan/coinInfos", 2 },
                            { "spot/v1/public/loan/hour-interest", 2 },
                            { "v2/spot/public/coins", 6.6667 },
                            { "v2/spot/public/symbols", 1 },
                            { "v2/spot/market/vip-fee-rate", 2 },
                            { "v2/spot/market/tickers", 1 },
                            { "v2/spot/market/merge-depth", 1 },
                            { "v2/spot/market/orderbook", 1 },
                            { "v2/spot/market/candles", 1 },
                            { "v2/spot/market/history-candles", 1 },
                            { "v2/spot/market/fills", 2 },
                            { "v2/spot/market/fills-history", 2 },
                        } },
                    } },
                    { "mix", new Dictionary<string, object>() {
                        { "get", new Dictionary<string, object>() {
                            { "mix/v1/market/contracts", 1 },
                            { "mix/v1/market/depth", 1 },
                            { "mix/v1/market/ticker", 1 },
                            { "mix/v1/market/tickers", 1 },
                            { "mix/v1/market/contract-vip-level", 2 },
                            { "mix/v1/market/fills", 1 },
                            { "mix/v1/market/fills-history", 2 },
                            { "mix/v1/market/candles", 1 },
                            { "mix/v1/market/index", 1 },
                            { "mix/v1/market/funding-time", 1 },
                            { "mix/v1/market/history-fundRate", 1 },
                            { "mix/v1/market/current-fundRate", 1 },
                            { "mix/v1/market/open-interest", 1 },
                            { "mix/v1/market/mark-price", 1 },
                            { "mix/v1/market/symbol-leverage", 1 },
                            { "mix/v1/market/queryPositionLever", 1 },
                            { "mix/v1/market/open-limit", 1 },
                            { "mix/v1/market/history-candles", 1 },
                            { "mix/v1/market/history-index-candles", 1 },
                            { "mix/v1/market/history-mark-candles", 1 },
                            { "mix/v1/market/merge-depth", 1 },
                            { "v2/mix/market/vip-fee-rate", 2 },
                            { "v2/mix/market/union-interest-rate-history", 4 },
                            { "v2/mix/market/exchange-rate", 4 },
                            { "v2/mix/market/discount-rate", 4 },
                            { "v2/mix/market/merge-depth", 1 },
                            { "v2/mix/market/ticker", 1 },
                            { "v2/mix/market/tickers", 1 },
                            { "v2/mix/market/fills", 1 },
                            { "v2/mix/market/fills-history", 2 },
                            { "v2/mix/market/candles", 1 },
                            { "v2/mix/market/history-candles", 1 },
                            { "v2/mix/market/history-index-candles", 1 },
                            { "v2/mix/market/history-mark-candles", 1 },
                            { "v2/mix/market/open-interest", 1 },
                            { "v2/mix/market/funding-time", 1 },
                            { "v2/mix/market/symbol-price", 1 },
                            { "v2/mix/market/history-fund-rate", 1 },
                            { "v2/mix/market/current-fund-rate", 1 },
                            { "v2/mix/market/oi-limit", 2 },
                            { "v2/mix/market/contracts", 1 },
                            { "v2/mix/market/query-position-lever", 2 },
                            { "v2/mix/market/account-long-short", 20 },
                        } },
                    } },
                    { "margin", new Dictionary<string, object>() {
                        { "get", new Dictionary<string, object>() {
                            { "margin/v1/cross/public/interestRateAndLimit", 2 },
                            { "margin/v1/isolated/public/interestRateAndLimit", 2 },
                            { "margin/v1/cross/public/tierData", 2 },
                            { "margin/v1/isolated/public/tierData", 2 },
                            { "margin/v1/public/currencies", 1 },
                            { "v2/margin/currencies", 2 },
                            { "v2/margin/market/long-short-ratio", 20 },
                        } },
                    } },
                    { "earn", new Dictionary<string, object>() {
                        { "get", new Dictionary<string, object>() {
                            { "v2/earn/loan/public/coinInfos", 2 },
                            { "v2/earn/loan/public/hour-interest", 2 },
                        } },
                    } },
                    { "uta", new Dictionary<string, object>() {
                        { "get", new Dictionary<string, object>() {
                            { "v3/market/instruments", 1 },
                            { "v3/market/tickers", 1 },
                            { "v3/market/orderbook", 1 },
                            { "v3/market/fills", 1 },
                            { "v3/market/open-interest", 1 },
                            { "v3/market/candles", 1 },
                            { "v3/market/history-candles", 1 },
                            { "v3/market/current-fund-rate", 1 },
                            { "v3/market/history-fund-rate", 1 },
                            { "v3/market/risk-reserve", 1 },
                            { "v3/market/discount-rate", 1 },
                            { "v3/market/margin-loans", 1 },
                            { "v3/market/position-tier", 1 },
                            { "v3/market/oi-limit", 2 },
                        } },
                    } },
                } },
                { "private", new Dictionary<string, object>() {
                    { "spot", new Dictionary<string, object>() {
                        { "get", new Dictionary<string, object>() {
                            { "spot/v1/wallet/deposit-address", 4 },
                            { "spot/v1/wallet/withdrawal-list", 1 },
                            { "spot/v1/wallet/deposit-list", 1 },
                            { "spot/v1/account/getInfo", 20 },
                            { "spot/v1/account/assets", 2 },
                            { "spot/v1/account/assets-lite", 2 },
                            { "spot/v1/account/transferRecords", 1 },
                            { "spot/v1/convert/currencies", 2 },
                            { "spot/v1/convert/convert-record", 2 },
                            { "spot/v1/loan/ongoing-orders", 2 },
                            { "spot/v1/loan/repay-history", 2 },
                            { "spot/v1/loan/revise-history", 2 },
                            { "spot/v1/loan/borrow-history", 2 },
                            { "spot/v1/loan/debts", 2 },
                            { "v2/spot/trade/orderInfo", 1 },
                            { "v2/spot/trade/unfilled-orders", 1 },
                            { "v2/spot/trade/history-orders", 1 },
                            { "v2/spot/trade/fills", 2 },
                            { "v2/spot/trade/current-plan-order", 1 },
                            { "v2/spot/trade/history-plan-order", 1 },
                            { "v2/spot/account/info", 20 },
                            { "v2/spot/account/assets", 2 },
                            { "v2/spot/account/subaccount-assets", 2 },
                            { "v2/spot/account/bills", 2 },
                            { "v2/spot/account/transferRecords", 1 },
                            { "v2/account/funding-assets", 2 },
                            { "v2/account/bot-assets", 2 },
                            { "v2/account/all-account-balance", 20 },
                            { "v2/spot/wallet/deposit-address", 2 },
                            { "v2/spot/wallet/deposit-records", 2 },
                            { "v2/spot/wallet/withdrawal-records", 2 },
                        } },
                        { "post", new Dictionary<string, object>() {
                            { "spot/v1/wallet/transfer", 4 },
                            { "spot/v1/wallet/transfer-v2", 4 },
                            { "spot/v1/wallet/subTransfer", 10 },
                            { "spot/v1/wallet/withdrawal", 4 },
                            { "spot/v1/wallet/withdrawal-v2", 4 },
                            { "spot/v1/wallet/withdrawal-inner", 4 },
                            { "spot/v1/wallet/withdrawal-inner-v2", 4 },
                            { "spot/v1/account/sub-account-spot-assets", 200 },
                            { "spot/v1/account/bills", 2 },
                            { "spot/v1/trade/orders", 2 },
                            { "spot/v1/trade/batch-orders", 4 },
                            { "spot/v1/trade/cancel-order", 2 },
                            { "spot/v1/trade/cancel-order-v2", 2 },
                            { "spot/v1/trade/cancel-symbol-order", 2 },
                            { "spot/v1/trade/cancel-batch-orders", 4 },
                            { "spot/v1/trade/cancel-batch-orders-v2", 4 },
                            { "spot/v1/trade/orderInfo", 1 },
                            { "spot/v1/trade/open-orders", 1 },
                            { "spot/v1/trade/history", 1 },
                            { "spot/v1/trade/fills", 1 },
                            { "spot/v1/plan/placePlan", 1 },
                            { "spot/v1/plan/modifyPlan", 1 },
                            { "spot/v1/plan/cancelPlan", 1 },
                            { "spot/v1/plan/currentPlan", 1 },
                            { "spot/v1/plan/historyPlan", 1 },
                            { "spot/v1/plan/batchCancelPlan", 2 },
                            { "spot/v1/convert/quoted-price", 4 },
                            { "spot/v1/convert/trade", 4 },
                            { "spot/v1/loan/borrow", 2 },
                            { "spot/v1/loan/repay", 2 },
                            { "spot/v1/loan/revise-pledge", 2 },
                            { "spot/v1/trace/order/orderCurrentList", 2 },
                            { "spot/v1/trace/order/orderHistoryList", 2 },
                            { "spot/v1/trace/order/closeTrackingOrder", 2 },
                            { "spot/v1/trace/order/updateTpsl", 2 },
                            { "spot/v1/trace/order/followerEndOrder", 2 },
                            { "spot/v1/trace/order/spotInfoList", 2 },
                            { "spot/v1/trace/config/getTraderSettings", 2 },
                            { "spot/v1/trace/config/getFollowerSettings", 2 },
                            { "spot/v1/trace/user/myTraders", 2 },
                            { "spot/v1/trace/config/setFollowerConfig", 2 },
                            { "spot/v1/trace/user/myFollowers", 2 },
                            { "spot/v1/trace/config/setProductCode", 2 },
                            { "spot/v1/trace/user/removeTrader", 2 },
                            { "spot/v1/trace/getRemovableFollower", 2 },
                            { "spot/v1/trace/user/removeFollower", 2 },
                            { "spot/v1/trace/profit/totalProfitInfo", 2 },
                            { "spot/v1/trace/profit/totalProfitList", 2 },
                            { "spot/v1/trace/profit/profitHisList", 2 },
                            { "spot/v1/trace/profit/profitHisDetailList", 2 },
                            { "spot/v1/trace/profit/waitProfitDetailList", 2 },
                            { "spot/v1/trace/user/getTraderInfo", 2 },
                            { "v2/spot/trade/place-order", 2 },
                            { "v2/spot/trade/cancel-order", 2 },
                            { "v2/spot/trade/batch-orders", 20 },
                            { "v2/spot/trade/batch-cancel-order", 2 },
                            { "v2/spot/trade/cancel-symbol-order", 4 },
                            { "v2/spot/trade/place-plan-order", 1 },
                            { "v2/spot/trade/modify-plan-order", 1 },
                            { "v2/spot/trade/cancel-plan-order", 1 },
                            { "v2/spot/trade/cancel-replace-order", 2 },
                            { "v2/spot/trade/batch-cancel-plan-order", 2 },
                            { "v2/spot/wallet/transfer", 2 },
                            { "v2/spot/wallet/subaccount-transfer", 2 },
                            { "v2/spot/wallet/withdrawal", 2 },
                            { "v2/spot/wallet/cancel-withdrawal", 2 },
                            { "v2/spot/wallet/modify-deposit-account", 2 },
                        } },
                    } },
                    { "mix", new Dictionary<string, object>() {
                        { "get", new Dictionary<string, object>() {
                            { "mix/v1/account/account", 2 },
                            { "mix/v1/account/accounts", 2 },
                            { "mix/v1/position/singlePosition", 2 },
                            { "mix/v1/position/singlePosition-v2", 2 },
                            { "mix/v1/position/allPosition", 4 },
                            { "mix/v1/position/allPosition-v2", 4 },
                            { "mix/v1/position/history-position", 1 },
                            { "mix/v1/account/accountBill", 2 },
                            { "mix/v1/account/accountBusinessBill", 4 },
                            { "mix/v1/order/current", 1 },
                            { "mix/v1/order/marginCoinCurrent", 1 },
                            { "mix/v1/order/history", 2 },
                            { "mix/v1/order/historyProductType", 4 },
                            { "mix/v1/order/detail", 2 },
                            { "mix/v1/order/fills", 2 },
                            { "mix/v1/order/allFills", 2 },
                            { "mix/v1/plan/currentPlan", 1 },
                            { "mix/v1/plan/historyPlan", 2 },
                            { "mix/v1/trace/currentTrack", 2 },
                            { "mix/v1/trace/followerOrder", 2 },
                            { "mix/v1/trace/followerHistoryOrders", 2 },
                            { "mix/v1/trace/historyTrack", 2 },
                            { "mix/v1/trace/summary", 1 },
                            { "mix/v1/trace/profitSettleTokenIdGroup", 1 },
                            { "mix/v1/trace/profitDateGroupList", 1 },
                            { "mix/v1/trade/profitDateList", 2 },
                            { "mix/v1/trace/waitProfitDateList", 1 },
                            { "mix/v1/trace/traderSymbols", 1 },
                            { "mix/v1/trace/traderList", 2 },
                            { "mix/v1/trace/traderDetail", 2 },
                            { "mix/v1/trace/queryTraceConfig", 2 },
                            { "v2/mix/account/account", 2 },
                            { "v2/mix/account/accounts", 2 },
                            { "v2/mix/account/sub-account-assets", 200 },
                            { "v2/mix/account/interest-history", 4 },
                            { "v2/mix/account/max-open", 1 },
                            { "v2/mix/account/liq-price", 1 },
                            { "v2/mix/account/open-count", 2 },
                            { "v2/mix/account/bill", 2 },
                            { "v2/mix/account/transfer-limits", 20 },
                            { "v2/mix/account/union-config", 20 },
                            { "v2/mix/account/switch-union-usdt", 20 },
                            { "v2/mix/account/isolated-symbols", 2 },
                            { "v2/mix/market/query-position-lever", 2 },
                            { "v2/mix/position/single-position", 2 },
                            { "v2/mix/position/all-position", 4 },
                            { "v2/mix/position/adlRank", 4 },
                            { "v2/mix/position/history-position", 1 },
                            { "v2/mix/order/detail", 2 },
                            { "v2/mix/order/fills", 2 },
                            { "v2/mix/order/fill-history", 2 },
                            { "v2/mix/order/orders-pending", 2 },
                            { "v2/mix/order/orders-history", 2 },
                            { "v2/mix/order/plan-sub-order", 2 },
                            { "v2/mix/order/orders-plan-pending", 2 },
                            { "v2/mix/order/orders-plan-history", 2 },
                            { "v2/mix/market/position-long-short", 20 },
                        } },
                        { "post", new Dictionary<string, object>() {
                            { "mix/v1/account/sub-account-contract-assets", 200 },
                            { "mix/v1/account/open-count", 1 },
                            { "mix/v1/account/setLeverage", 4 },
                            { "mix/v1/account/setMargin", 4 },
                            { "mix/v1/account/setMarginMode", 4 },
                            { "mix/v1/account/setPositionMode", 4 },
                            { "mix/v1/order/placeOrder", 2 },
                            { "mix/v1/order/batch-orders", 2 },
                            { "mix/v1/order/cancel-order", 2 },
                            { "mix/v1/order/cancel-batch-orders", 2 },
                            { "mix/v1/order/modifyOrder", 2 },
                            { "mix/v1/order/cancel-symbol-orders", 2 },
                            { "mix/v1/order/cancel-all-orders", 2 },
                            { "mix/v1/order/close-all-positions", 20 },
                            { "mix/v1/plan/placePlan", 2 },
                            { "mix/v1/plan/modifyPlan", 2 },
                            { "mix/v1/plan/modifyPlanPreset", 2 },
                            { "mix/v1/plan/placeTPSL", 2 },
                            { "mix/v1/plan/placeTrailStop", 2 },
                            { "mix/v1/plan/placePositionsTPSL", 2 },
                            { "mix/v1/plan/modifyTPSLPlan", 2 },
                            { "mix/v1/plan/cancelPlan", 2 },
                            { "mix/v1/plan/cancelSymbolPlan", 2 },
                            { "mix/v1/plan/cancelAllPlan", 2 },
                            { "mix/v1/trace/closeTrackOrder", 2 },
                            { "mix/v1/trace/modifyTPSL", 2 },
                            { "mix/v1/trace/closeTrackOrderBySymbol", 2 },
                            { "mix/v1/trace/setUpCopySymbols", 2 },
                            { "mix/v1/trace/followerSetBatchTraceConfig", 2 },
                            { "mix/v1/trace/followerCloseByTrackingNo", 2 },
                            { "mix/v1/trace/followerCloseByAll", 2 },
                            { "mix/v1/trace/followerSetTpsl", 2 },
                            { "mix/v1/trace/cancelCopyTrader", 4 },
                            { "mix/v1/trace/traderUpdateConfig", 2 },
                            { "mix/v1/trace/myTraderList", 2 },
                            { "mix/v1/trace/myFollowerList", 2 },
                            { "mix/v1/trace/removeFollower", 2 },
                            { "mix/v1/trace/public/getFollowerConfig", 2 },
                            { "mix/v1/trace/report/order/historyList", 2 },
                            { "mix/v1/trace/report/order/currentList", 2 },
                            { "mix/v1/trace/queryTraderTpslRatioConfig", 2 },
                            { "mix/v1/trace/traderUpdateTpslRatioConfig", 2 },
                            { "v2/mix/account/set-auto-margin", 4 },
                            { "v2/mix/account/set-leverage", 4 },
                            { "v2/mix/account/set-all-leverage", 4 },
                            { "v2/mix/account/set-margin", 4 },
                            { "v2/mix/account/set-asset-mode", 10 },
                            { "v2/mix/account/set-margin-mode", 4 },
                            { "v2/mix/account/union-convert", 20 },
                            { "v2/mix/account/set-position-mode", 4 },
                            { "v2/mix/order/place-order", 2 },
                            { "v2/mix/order/click-backhand", 20 },
                            { "v2/mix/order/batch-place-order", 20 },
                            { "v2/mix/order/modify-order", 2 },
                            { "v2/mix/order/cancel-order", 2 },
                            { "v2/mix/order/batch-cancel-orders", 2 },
                            { "v2/mix/order/close-positions", 20 },
                            { "v2/mix/order/cancel-all-orders", 20 },
                            { "v2/mix/order/place-tpsl-order", 2 },
                            { "v2/mix/order/place-pos-tpsl", 2 },
                            { "v2/mix/order/place-plan-order", 2 },
                            { "v2/mix/order/modify-tpsl-order", 2 },
                            { "v2/mix/order/modify-plan-order", 2 },
                            { "v2/mix/order/cancel-plan-order", 2 },
                        } },
                    } },
                    { "user", new Dictionary<string, object>() {
                        { "get", new Dictionary<string, object>() {
                            { "user/v1/fee/query", 2 },
                            { "user/v1/sub/virtual-list", 2 },
                            { "user/v1/sub/virtual-api-list", 2 },
                            { "user/v1/tax/spot-record", 1 },
                            { "user/v1/tax/future-record", 1 },
                            { "user/v1/tax/margin-record", 1 },
                            { "user/v1/tax/p2p-record", 1 },
                            { "v2/user/virtual-subaccount-list", 2 },
                            { "v2/user/virtual-subaccount-apikey-list", 2 },
                        } },
                        { "post", new Dictionary<string, object>() {
                            { "user/v1/sub/virtual-create", 4 },
                            { "user/v1/sub/virtual-modify", 4 },
                            { "user/v1/sub/virtual-api-batch-create", 20 },
                            { "user/v1/sub/virtual-api-create", 4 },
                            { "user/v1/sub/virtual-api-modify", 4 },
                            { "v2/user/create-virtual-subaccount", 4 },
                            { "v2/user/modify-virtual-subaccount", 4 },
                            { "v2/user/batch-create-subaccount-and-apikey", 20 },
                            { "v2/user/create-virtual-subaccount-apikey", 4 },
                            { "v2/user/modify-virtual-subaccount-apikey", 4 },
                        } },
                    } },
                    { "p2p", new Dictionary<string, object>() {
                        { "get", new Dictionary<string, object>() {
                            { "p2p/v1/merchant/merchantList", 2 },
                            { "p2p/v1/merchant/merchantInfo", 2 },
                            { "p2p/v1/merchant/advList", 2 },
                            { "p2p/v1/merchant/orderList", 2 },
                            { "v2/p2p/merchantList", 2 },
                            { "v2/p2p/merchantInfo", 2 },
                            { "v2/p2p/orderList", 2 },
                            { "v2/p2p/advList", 2 },
                        } },
                    } },
                    { "broker", new Dictionary<string, object>() {
                        { "get", new Dictionary<string, object>() {
                            { "broker/v1/account/info", 2 },
                            { "broker/v1/account/sub-list", 20 },
                            { "broker/v1/account/sub-email", 20 },
                            { "broker/v1/account/sub-spot-assets", 2 },
                            { "broker/v1/account/sub-future-assets", 2 },
                            { "broker/v1/account/subaccount-transfer", 1 },
                            { "broker/v1/account/subaccount-deposit", 1 },
                            { "broker/v1/account/subaccount-withdrawal", 1 },
                            { "broker/v1/account/sub-api-list", 2 },
                            { "v2/broker/account/info", 2 },
                            { "v2/broker/account/subaccount-list", 20 },
                            { "v2/broker/account/subaccount-email", 2 },
                            { "v2/broker/account/subaccount-spot-assets", 2 },
                            { "v2/broker/account/subaccount-future-assets", 2 },
                            { "v2/broker/manage/subaccount-apikey-list", 2 },
                        } },
                        { "post", new Dictionary<string, object>() {
                            { "broker/v1/account/sub-create", 20 },
                            { "broker/v1/account/sub-modify", 20 },
                            { "broker/v1/account/sub-modify-email", 20 },
                            { "broker/v1/account/sub-address", 2 },
                            { "broker/v1/account/sub-withdrawal", 2 },
                            { "broker/v1/account/sub-auto-transfer", 4 },
                            { "broker/v1/account/sub-api-create", 2 },
                            { "broker/v1/account/sub-api-modify", 2 },
                            { "v2/broker/account/modify-subaccount-email", 2 },
                            { "v2/broker/account/create-subaccount", 20 },
                            { "v2/broker/account/modify-subaccount", 20 },
                            { "v2/broker/account/subaccount-address", 2 },
                            { "v2/broker/account/subaccount-withdrawal", 2 },
                            { "v2/broker/account/set-subaccount-autotransfer", 2 },
                            { "v2/broker/manage/create-subaccount-apikey", 2 },
                            { "v2/broker/manage/modify-subaccount-apikey", 2 },
                        } },
                    } },
                    { "margin", new Dictionary<string, object>() {
                        { "get", new Dictionary<string, object>() {
                            { "margin/v1/cross/account/riskRate", 2 },
                            { "margin/v1/cross/account/maxTransferOutAmount", 2 },
                            { "margin/v1/isolated/account/maxTransferOutAmount", 2 },
                            { "margin/v1/isolated/order/openOrders", 2 },
                            { "margin/v1/isolated/order/history", 2 },
                            { "margin/v1/isolated/order/fills", 2 },
                            { "margin/v1/isolated/loan/list", 2 },
                            { "margin/v1/isolated/repay/list", 2 },
                            { "margin/v1/isolated/interest/list", 2 },
                            { "margin/v1/isolated/liquidation/list", 2 },
                            { "margin/v1/isolated/fin/list", 2 },
                            { "margin/v1/cross/order/openOrders", 2 },
                            { "margin/v1/cross/order/history", 2 },
                            { "margin/v1/cross/order/fills", 2 },
                            { "margin/v1/cross/loan/list", 2 },
                            { "margin/v1/cross/repay/list", 2 },
                            { "margin/v1/cross/interest/list", 2 },
                            { "margin/v1/cross/liquidation/list", 2 },
                            { "margin/v1/cross/fin/list", 2 },
                            { "margin/v1/cross/account/assets", 2 },
                            { "margin/v1/isolated/account/assets", 2 },
                            { "v2/margin/crossed/borrow-history", 2 },
                            { "v2/margin/crossed/repay-history", 2 },
                            { "v2/margin/crossed/interest-history", 2 },
                            { "v2/margin/crossed/liquidation-history", 2 },
                            { "v2/margin/crossed/financial-records", 2 },
                            { "v2/margin/crossed/account/assets", 2 },
                            { "v2/margin/crossed/account/risk-rate", 2 },
                            { "v2/margin/crossed/account/max-borrowable-amount", 2 },
                            { "v2/margin/crossed/account/max-transfer-out-amount", 2 },
                            { "v2/margin/crossed/interest-rate-and-limit", 2 },
                            { "v2/margin/crossed/tier-data", 2 },
                            { "v2/margin/crossed/open-orders", 2 },
                            { "v2/margin/crossed/history-orders", 2 },
                            { "v2/margin/crossed/fills", 2 },
                            { "v2/margin/isolated/borrow-history", 2 },
                            { "v2/margin/isolated/repay-history", 2 },
                            { "v2/margin/isolated/interest-history", 2 },
                            { "v2/margin/isolated/liquidation-history", 2 },
                            { "v2/margin/isolated/financial-records", 2 },
                            { "v2/margin/isolated/account/assets", 2 },
                            { "v2/margin/isolated/account/risk-rate", 2 },
                            { "v2/margin/isolated/account/max-borrowable-amount", 2 },
                            { "v2/margin/isolated/account/max-transfer-out-amount", 2 },
                            { "v2/margin/isolated/interest-rate-and-limit", 2 },
                            { "v2/margin/isolated/tier-data", 2 },
                            { "v2/margin/isolated/open-orders", 2 },
                            { "v2/margin/isolated/history-orders", 2 },
                            { "v2/margin/isolated/fills", 2 },
                        } },
                        { "post", new Dictionary<string, object>() {
                            { "margin/v1/cross/account/borrow", 2 },
                            { "margin/v1/isolated/account/borrow", 2 },
                            { "margin/v1/cross/account/repay", 2 },
                            { "margin/v1/isolated/account/repay", 2 },
                            { "margin/v1/isolated/account/riskRate", 2 },
                            { "margin/v1/cross/account/maxBorrowableAmount", 2 },
                            { "margin/v1/isolated/account/maxBorrowableAmount", 2 },
                            { "margin/v1/isolated/account/flashRepay", 2 },
                            { "margin/v1/isolated/account/queryFlashRepayStatus", 2 },
                            { "margin/v1/cross/account/flashRepay", 2 },
                            { "margin/v1/cross/account/queryFlashRepayStatus", 2 },
                            { "margin/v1/isolated/order/placeOrder", 4 },
                            { "margin/v1/isolated/order/batchPlaceOrder", 4 },
                            { "margin/v1/isolated/order/cancelOrder", 2 },
                            { "margin/v1/isolated/order/batchCancelOrder", 2 },
                            { "margin/v1/cross/order/placeOrder", 2 },
                            { "margin/v1/cross/order/batchPlaceOrder", 2 },
                            { "margin/v1/cross/order/cancelOrder", 2 },
                            { "margin/v1/cross/order/batchCancelOrder", 2 },
                            { "v2/margin/crossed/account/borrow", 2 },
                            { "v2/margin/crossed/account/repay", 2 },
                            { "v2/margin/crossed/account/flash-repay", 2 },
                            { "v2/margin/crossed/account/query-flash-repay-status", 2 },
                            { "v2/margin/crossed/place-order", 2 },
                            { "v2/margin/crossed/batch-place-order", 2 },
                            { "v2/margin/crossed/cancel-order", 2 },
                            { "v2/margin/crossed/batch-cancel-order", 2 },
                            { "v2/margin/isolated/account/borrow", 2 },
                            { "v2/margin/isolated/account/repay", 2 },
                            { "v2/margin/isolated/account/flash-repay", 2 },
                            { "v2/margin/isolated/account/query-flash-repay-status", 2 },
                            { "v2/margin/isolated/place-order", 2 },
                            { "v2/margin/isolated/batch-place-order", 2 },
                            { "v2/margin/isolated/cancel-order", 2 },
                            { "v2/margin/isolated/batch-cancel-order", 2 },
                        } },
                    } },
                    { "copy", new Dictionary<string, object>() {
                        { "get", new Dictionary<string, object>() {
                            { "v2/copy/mix-trader/order-current-track", 2 },
                            { "v2/copy/mix-trader/order-history-track", 2 },
                            { "v2/copy/mix-trader/order-total-detail", 2 },
                            { "v2/copy/mix-trader/profit-history-summarys", 1 },
                            { "v2/copy/mix-trader/profit-history-details", 1 },
                            { "v2/copy/mix-trader/profit-details", 1 },
                            { "v2/copy/mix-trader/profits-group-coin-date", 1 },
                            { "v2/copy/mix-trader/config-query-symbols", 1 },
                            { "v2/copy/mix-trader/config-query-followers", 2 },
                            { "v2/copy/mix-follower/query-current-orders", 2 },
                            { "v2/copy/mix-follower/query-history-orders", 1 },
                            { "v2/copy/mix-follower/query-settings", 2 },
                            { "v2/copy/mix-follower/query-traders", 2 },
                            { "v2/copy/mix-follower/query-quantity-limit", 2 },
                            { "v2/copy/mix-broker/query-traders", 2 },
                            { "v2/copy/mix-broker/query-history-traces", 2 },
                            { "v2/copy/mix-broker/query-current-traces", 2 },
                            { "v2/copy/spot-trader/profit-summarys", 2 },
                            { "v2/copy/spot-trader/profit-history-details", 2 },
                            { "v2/copy/spot-trader/profit-details", 2 },
                            { "v2/copy/spot-trader/order-total-detail", 2 },
                            { "v2/copy/spot-trader/order-history-track", 2 },
                            { "v2/copy/spot-trader/order-current-track", 2 },
                            { "v2/copy/spot-trader/config-query-settings", 2 },
                            { "v2/copy/spot-trader/config-query-followers", 2 },
                            { "v2/copy/spot-follower/query-traders", 2 },
                            { "v2/copy/spot-follower/query-trader-symbols", 2 },
                            { "v2/copy/spot-follower/query-settings", 2 },
                            { "v2/copy/spot-follower/query-history-orders", 2 },
                            { "v2/copy/spot-follower/query-current-orders", 2 },
                        } },
                        { "post", new Dictionary<string, object>() {
                            { "v2/copy/mix-trader/order-modify-tpsl", 2 },
                            { "v2/copy/mix-trader/order-close-positions", 2 },
                            { "v2/copy/mix-trader/config-setting-symbols", 2 },
                            { "v2/copy/mix-trader/config-setting-base", 2 },
                            { "v2/copy/mix-trader/config-remove-follower", 2 },
                            { "v2/copy/mix-follower/setting-tpsl", 1 },
                            { "v2/copy/mix-follower/settings", 2 },
                            { "v2/copy/mix-follower/close-positions", 2 },
                            { "v2/copy/mix-follower/cancel-trader", 4 },
                            { "v2/copy/spot-trader/order-modify-tpsl", 2 },
                            { "v2/copy/spot-trader/order-close-tracking", 2 },
                            { "v2/copy/spot-trader/config-setting-symbols", 2 },
                            { "v2/copy/spot-trader/config-remove-follower", 2 },
                            { "v2/copy/spot-follower/stop-order", 2 },
                            { "v2/copy/spot-follower/settings", 2 },
                            { "v2/copy/spot-follower/setting-tpsl", 2 },
                            { "v2/copy/spot-follower/order-close-tracking", 2 },
                            { "v2/copy/spot-follower/cancel-trader", 2 },
                        } },
                    } },
                    { "tax", new Dictionary<string, object>() {
                        { "get", new Dictionary<string, object>() {
                            { "v2/tax/spot-record", 20 },
                            { "v2/tax/future-record", 20 },
                            { "v2/tax/margin-record", 20 },
                            { "v2/tax/p2p-record", 20 },
                        } },
                    } },
                    { "convert", new Dictionary<string, object>() {
                        { "get", new Dictionary<string, object>() {
                            { "v2/convert/currencies", 2 },
                            { "v2/convert/quoted-price", 2 },
                            { "v2/convert/convert-record", 2 },
                            { "v2/convert/bgb-convert-coin-list", 2 },
                            { "v2/convert/bgb-convert-records", 2 },
                        } },
                        { "post", new Dictionary<string, object>() {
                            { "v2/convert/trade", 2 },
                            { "v2/convert/bgb-convert", 2 },
                        } },
                    } },
                    { "earn", new Dictionary<string, object>() {
                        { "get", new Dictionary<string, object>() {
                            { "v2/earn/savings/product", 2 },
                            { "v2/earn/savings/account", 2 },
                            { "v2/earn/savings/assets", 2 },
                            { "v2/earn/savings/records", 2 },
                            { "v2/earn/savings/subscribe-info", 2 },
                            { "v2/earn/savings/subscribe-result", 2 },
                            { "v2/earn/savings/redeem-result", 2 },
                            { "v2/earn/sharkfin/product", 2 },
                            { "v2/earn/sharkfin/account", 2 },
                            { "v2/earn/sharkfin/assets", 2 },
                            { "v2/earn/sharkfin/records", 2 },
                            { "v2/earn/sharkfin/subscribe-info", 2 },
                            { "v2/earn/sharkfin/subscribe-result", 4 },
                            { "v2/earn/loan/ongoing-orders", 2 },
                            { "v2/earn/loan/repay-history", 2 },
                            { "v2/earn/loan/revise-history", 2 },
                            { "v2/earn/loan/borrow-history", 2 },
                            { "v2/earn/loan/debts", 2 },
                            { "v2/earn/loan/reduces", 2 },
                            { "v2/earn/account/assets", 2 },
                        } },
                        { "post", new Dictionary<string, object>() {
                            { "v2/earn/savings/subscribe", 2 },
                            { "v2/earn/savings/redeem", 2 },
                            { "v2/earn/sharkfin/subscribe", 2 },
                            { "v2/earn/loan/borrow", 2 },
                            { "v2/earn/loan/repay", 2 },
                            { "v2/earn/loan/revise-pledge", 2 },
                        } },
                    } },
                    { "common", new Dictionary<string, object>() {
                        { "get", new Dictionary<string, object>() {
                            { "v2/common/trade-rate", 2 },
                        } },
                    } },
                    { "uta", new Dictionary<string, object>() {
                        { "get", new Dictionary<string, object>() {
                            { "v3/account/assets", 1 },
                            { "v3/account/settings", 1 },
                            { "v3/account/deposit-records", 2 },
                            { "v3/account/financial-records", 1 },
                            { "v3/account/repayable-coins", 2 },
                            { "v3/account/payment-coins", 2 },
                            { "v3/account/convert-records", 1 },
                            { "v3/account/transferable-coins", 2 },
                            { "v3/account/sub-transfer-record", 4 },
                            { "v3/ins-loan/transfered", 6.6667 },
                            { "v3/ins-loan/symbols", 6.6667 },
                            { "v3/ins-loan/risk-unit", 6.6667 },
                            { "v3/ins-loan/repaid-history", 6.6667 },
                            { "v3/ins-loan/product-infos", 6.6667 },
                            { "v3/ins-loan/loan-order", 6.6667 },
                            { "v3/ins-loan/ltv-convert", 6.6667 },
                            { "v3/ins-loan/ensure-coins-convert", 6.6667 },
                            { "v3/position/current-position", 1 },
                            { "v3/position/history-position", 1 },
                            { "v3/trade/order-info", 1 },
                            { "v3/trade/unfilled-orders", 1 },
                            { "v3/trade/unfilled-strategy-orders", 1 },
                            { "v3/trade/history-orders", 1 },
                            { "v3/trade/history-strategy-orders", 1 },
                            { "v3/trade/fills", 1 },
                            { "v3/user/sub-list", 2 },
                            { "v3/user/sub-api-list", 2 },
                        } },
                        { "post", new Dictionary<string, object>() {
                            { "v3/account/set-leverage", 2 },
                            { "v3/account/set-hold-mode", 2 },
                            { "v3/account/repay", 4 },
                            { "v3/account/transfer", 4 },
                            { "v3/account/sub-transfer", 4 },
                            { "v3/account/max-open-available", 4 },
                            { "v3/ins-loan/bind-uid", 6.6667 },
                            { "v3/trade/place-order", 2 },
                            { "v3/trade/place-strategy-order", 2 },
                            { "v3/trade/modify-order", 2 },
                            { "v3/trade/modify-strategy-order", 2 },
                            { "v3/trade/cancel-order", 2 },
                            { "v3/trade/cancel-strategy-order", 2 },
                            { "v3/trade/place-batch", 4 },
                            { "v3/trade/batch-modify-order", 2 },
                            { "v3/trade/cancel-batch", 4 },
                            { "v3/trade/cancel-symbol-order", 4 },
                            { "v3/trade/close-positions", 4 },
                            { "v3/user/create-sub", 2 },
                            { "v3/user/freeze-sub", 2 },
                            { "v3/user/create-sub-api", 2 },
                            { "v3/user/update-sub-api", 2 },
                            { "v3/user/delete-sub-api", 2 },
                        } },
                    } },
                } },
            } },
            { "fees", new Dictionary<string, object>() {
                { "spot", new Dictionary<string, object>() {
                    { "taker", this.parseNumber("0.002") },
                    { "maker", this.parseNumber("0.002") },
                } },
                { "swap", new Dictionary<string, object>() {
                    { "taker", this.parseNumber("0.0006") },
                    { "maker", this.parseNumber("0.0004") },
                } },
            } },
            { "requiredCredentials", new Dictionary<string, object>() {
                { "apiKey", true },
                { "secret", true },
                { "password", true },
            } },
            { "exceptions", new Dictionary<string, object>() {
                { "exact", new Dictionary<string, object>() {
                    { "1", typeof(ExchangeError) },
                    { "failure to get a peer from the ring-balancer", typeof(ExchangeNotAvailable) },
                    { "4010", typeof(PermissionDenied) },
                    { "4001", typeof(ExchangeError) },
                    { "4002", typeof(ExchangeError) },
                    { "40020", typeof(BadRequest) },
                    { "30001", typeof(AuthenticationError) },
                    { "30002", typeof(AuthenticationError) },
                    { "30003", typeof(AuthenticationError) },
                    { "30004", typeof(AuthenticationError) },
                    { "30005", typeof(InvalidNonce) },
                    { "30006", typeof(AuthenticationError) },
                    { "30007", typeof(BadRequest) },
                    { "30008", typeof(RequestTimeout) },
                    { "30009", typeof(ExchangeError) },
                    { "30010", typeof(AuthenticationError) },
                    { "30011", typeof(PermissionDenied) },
                    { "30012", typeof(AuthenticationError) },
                    { "30013", typeof(AuthenticationError) },
                    { "30014", typeof(DDoSProtection) },
                    { "30015", typeof(AuthenticationError) },
                    { "30016", typeof(ExchangeError) },
                    { "30017", typeof(ExchangeError) },
                    { "30018", typeof(ExchangeError) },
                    { "30019", typeof(ExchangeNotAvailable) },
                    { "30020", typeof(BadRequest) },
                    { "30021", typeof(BadRequest) },
                    { "30022", typeof(PermissionDenied) },
                    { "30023", typeof(BadRequest) },
                    { "30024", typeof(BadSymbol) },
                    { "30025", typeof(BadRequest) },
                    { "30026", typeof(DDoSProtection) },
                    { "30027", typeof(AuthenticationError) },
                    { "30028", typeof(PermissionDenied) },
                    { "30029", typeof(AccountSuspended) },
                    { "30030", typeof(ExchangeError) },
                    { "30031", typeof(BadRequest) },
                    { "30032", typeof(BadSymbol) },
                    { "30033", typeof(BadRequest) },
                    { "30034", typeof(ExchangeError) },
                    { "30035", typeof(ExchangeError) },
                    { "30036", typeof(ExchangeError) },
                    { "30037", typeof(ExchangeNotAvailable) },
                    { "30038", typeof(OnMaintenance) },
                    { "32001", typeof(AccountSuspended) },
                    { "32002", typeof(PermissionDenied) },
                    { "32003", typeof(CancelPending) },
                    { "32004", typeof(ExchangeError) },
                    { "32005", typeof(InvalidOrder) },
                    { "32006", typeof(InvalidOrder) },
                    { "32007", typeof(InvalidOrder) },
                    { "32008", typeof(InvalidOrder) },
                    { "32009", typeof(InvalidOrder) },
                    { "32010", typeof(ExchangeError) },
                    { "32011", typeof(ExchangeError) },
                    { "32012", typeof(ExchangeError) },
                    { "32013", typeof(ExchangeError) },
                    { "32014", typeof(ExchangeError) },
                    { "32015", typeof(ExchangeError) },
                    { "32016", typeof(ExchangeError) },
                    { "32017", typeof(ExchangeError) },
                    { "32018", typeof(ExchangeError) },
                    { "32019", typeof(ExchangeError) },
                    { "32020", typeof(ExchangeError) },
                    { "32021", typeof(ExchangeError) },
                    { "32022", typeof(ExchangeError) },
                    { "32023", typeof(ExchangeError) },
                    { "32024", typeof(ExchangeError) },
                    { "32025", typeof(ExchangeError) },
                    { "32026", typeof(ExchangeError) },
                    { "32027", typeof(ExchangeError) },
                    { "32028", typeof(AccountSuspended) },
                    { "32029", typeof(ExchangeError) },
                    { "32030", typeof(InvalidOrder) },
                    { "32031", typeof(ArgumentsRequired) },
                    { "32038", typeof(AuthenticationError) },
                    { "32040", typeof(ExchangeError) },
                    { "32044", typeof(ExchangeError) },
                    { "32045", typeof(ExchangeError) },
                    { "32046", typeof(ExchangeError) },
                    { "32047", typeof(ExchangeError) },
                    { "32048", typeof(InvalidOrder) },
                    { "32049", typeof(ExchangeError) },
                    { "32050", typeof(InvalidOrder) },
                    { "32051", typeof(InvalidOrder) },
                    { "32052", typeof(ExchangeError) },
                    { "32053", typeof(ExchangeError) },
                    { "32057", typeof(ExchangeError) },
                    { "32054", typeof(ExchangeError) },
                    { "32055", typeof(InvalidOrder) },
                    { "32056", typeof(ExchangeError) },
                    { "32058", typeof(ExchangeError) },
                    { "32059", typeof(InvalidOrder) },
                    { "32060", typeof(InvalidOrder) },
                    { "32061", typeof(InvalidOrder) },
                    { "32062", typeof(InvalidOrder) },
                    { "32063", typeof(InvalidOrder) },
                    { "32064", typeof(ExchangeError) },
                    { "32065", typeof(ExchangeError) },
                    { "32066", typeof(ExchangeError) },
                    { "32067", typeof(ExchangeError) },
                    { "32068", typeof(ExchangeError) },
                    { "32069", typeof(ExchangeError) },
                    { "32070", typeof(ExchangeError) },
                    { "32071", typeof(ExchangeError) },
                    { "32072", typeof(ExchangeError) },
                    { "32073", typeof(ExchangeError) },
                    { "32074", typeof(ExchangeError) },
                    { "32075", typeof(ExchangeError) },
                    { "32076", typeof(ExchangeError) },
                    { "32077", typeof(ExchangeError) },
                    { "32078", typeof(ExchangeError) },
                    { "32079", typeof(ExchangeError) },
                    { "32080", typeof(ExchangeError) },
                    { "32083", typeof(ExchangeError) },
                    { "33001", typeof(PermissionDenied) },
                    { "33002", typeof(AccountSuspended) },
                    { "33003", typeof(InsufficientFunds) },
                    { "33004", typeof(ExchangeError) },
                    { "33005", typeof(ExchangeError) },
                    { "33006", typeof(ExchangeError) },
                    { "33007", typeof(ExchangeError) },
                    { "33008", typeof(InsufficientFunds) },
                    { "33009", typeof(ExchangeError) },
                    { "33010", typeof(ExchangeError) },
                    { "33011", typeof(ExchangeError) },
                    { "33012", typeof(ExchangeError) },
                    { "33013", typeof(InvalidOrder) },
                    { "33014", typeof(OrderNotFound) },
                    { "33015", typeof(InvalidOrder) },
                    { "33016", typeof(ExchangeError) },
                    { "33017", typeof(InsufficientFunds) },
                    { "33018", typeof(ExchangeError) },
                    { "33020", typeof(ExchangeError) },
                    { "33021", typeof(BadRequest) },
                    { "33022", typeof(InvalidOrder) },
                    { "33023", typeof(ExchangeError) },
                    { "33024", typeof(InvalidOrder) },
                    { "33025", typeof(InvalidOrder) },
                    { "33026", typeof(ExchangeError) },
                    { "33027", typeof(InvalidOrder) },
                    { "33028", typeof(InvalidOrder) },
                    { "33029", typeof(InvalidOrder) },
                    { "33034", typeof(ExchangeError) },
                    { "33035", typeof(ExchangeError) },
                    { "33036", typeof(ExchangeError) },
                    { "33037", typeof(ExchangeError) },
                    { "33038", typeof(ExchangeError) },
                    { "33039", typeof(ExchangeError) },
                    { "33040", typeof(ExchangeError) },
                    { "33041", typeof(ExchangeError) },
                    { "33042", typeof(ExchangeError) },
                    { "33043", typeof(ExchangeError) },
                    { "33044", typeof(ExchangeError) },
                    { "33045", typeof(ExchangeError) },
                    { "33046", typeof(ExchangeError) },
                    { "33047", typeof(ExchangeError) },
                    { "33048", typeof(ExchangeError) },
                    { "33049", typeof(ExchangeError) },
                    { "33050", typeof(ExchangeError) },
                    { "33051", typeof(ExchangeError) },
                    { "33059", typeof(BadRequest) },
                    { "33060", typeof(BadRequest) },
                    { "33061", typeof(ExchangeError) },
                    { "33062", typeof(ExchangeError) },
                    { "33063", typeof(ExchangeError) },
                    { "33064", typeof(ExchangeError) },
                    { "33065", typeof(ExchangeError) },
                    { "21009", typeof(ExchangeError) },
                    { "34001", typeof(PermissionDenied) },
                    { "34002", typeof(InvalidAddress) },
                    { "34003", typeof(ExchangeError) },
                    { "34004", typeof(ExchangeError) },
                    { "34005", typeof(ExchangeError) },
                    { "34006", typeof(ExchangeError) },
                    { "34007", typeof(ExchangeError) },
                    { "34008", typeof(InsufficientFunds) },
                    { "34009", typeof(ExchangeError) },
                    { "34010", typeof(ExchangeError) },
                    { "34011", typeof(ExchangeError) },
                    { "34012", typeof(ExchangeError) },
                    { "34013", typeof(ExchangeError) },
                    { "34014", typeof(ExchangeError) },
                    { "34015", typeof(ExchangeError) },
                    { "34016", typeof(PermissionDenied) },
                    { "34017", typeof(AccountSuspended) },
                    { "34018", typeof(AuthenticationError) },
                    { "34019", typeof(PermissionDenied) },
                    { "34020", typeof(PermissionDenied) },
                    { "34021", typeof(InvalidAddress) },
                    { "34022", typeof(ExchangeError) },
                    { "34023", typeof(PermissionDenied) },
                    { "34026", typeof(ExchangeError) },
                    { "34036", typeof(ExchangeError) },
                    { "34037", typeof(ExchangeError) },
                    { "34038", typeof(ExchangeError) },
                    { "34039", typeof(ExchangeError) },
                    { "35001", typeof(ExchangeError) },
                    { "35002", typeof(ExchangeError) },
                    { "35003", typeof(ExchangeError) },
                    { "35004", typeof(ExchangeError) },
                    { "35005", typeof(AuthenticationError) },
                    { "35008", typeof(InvalidOrder) },
                    { "35010", typeof(InvalidOrder) },
                    { "35012", typeof(InvalidOrder) },
                    { "35014", typeof(InvalidOrder) },
                    { "35015", typeof(InvalidOrder) },
                    { "35017", typeof(ExchangeError) },
                    { "35019", typeof(InvalidOrder) },
                    { "35020", typeof(InvalidOrder) },
                    { "35021", typeof(InvalidOrder) },
                    { "35022", typeof(ExchangeError) },
                    { "35024", typeof(ExchangeError) },
                    { "35025", typeof(InsufficientFunds) },
                    { "35026", typeof(ExchangeError) },
                    { "35029", typeof(OrderNotFound) },
                    { "35030", typeof(InvalidOrder) },
                    { "35031", typeof(InvalidOrder) },
                    { "35032", typeof(ExchangeError) },
                    { "35037", typeof(ExchangeError) },
                    { "35039", typeof(ExchangeError) },
                    { "35040", typeof(InvalidOrder) },
                    { "35044", typeof(ExchangeError) },
                    { "35046", typeof(InsufficientFunds) },
                    { "35047", typeof(InsufficientFunds) },
                    { "35048", typeof(ExchangeError) },
                    { "35049", typeof(InvalidOrder) },
                    { "35050", typeof(InvalidOrder) },
                    { "35052", typeof(InsufficientFunds) },
                    { "35053", typeof(ExchangeError) },
                    { "35055", typeof(InsufficientFunds) },
                    { "35057", typeof(ExchangeError) },
                    { "35058", typeof(ExchangeError) },
                    { "35059", typeof(BadRequest) },
                    { "35060", typeof(BadRequest) },
                    { "35061", typeof(BadRequest) },
                    { "35062", typeof(InvalidOrder) },
                    { "35063", typeof(InvalidOrder) },
                    { "35064", typeof(InvalidOrder) },
                    { "35066", typeof(InvalidOrder) },
                    { "35067", typeof(InvalidOrder) },
                    { "35068", typeof(InvalidOrder) },
                    { "35069", typeof(InvalidOrder) },
                    { "35070", typeof(InvalidOrder) },
                    { "35071", typeof(InvalidOrder) },
                    { "35072", typeof(InvalidOrder) },
                    { "35073", typeof(InvalidOrder) },
                    { "35074", typeof(InvalidOrder) },
                    { "35075", typeof(InvalidOrder) },
                    { "35076", typeof(InvalidOrder) },
                    { "35077", typeof(InvalidOrder) },
                    { "35078", typeof(InvalidOrder) },
                    { "35079", typeof(InvalidOrder) },
                    { "35080", typeof(InvalidOrder) },
                    { "35081", typeof(InvalidOrder) },
                    { "35082", typeof(InvalidOrder) },
                    { "35083", typeof(InvalidOrder) },
                    { "35084", typeof(InvalidOrder) },
                    { "35085", typeof(InvalidOrder) },
                    { "35086", typeof(InvalidOrder) },
                    { "35087", typeof(InvalidOrder) },
                    { "35088", typeof(InvalidOrder) },
                    { "35089", typeof(InvalidOrder) },
                    { "35090", typeof(ExchangeError) },
                    { "35091", typeof(ExchangeError) },
                    { "35092", typeof(ExchangeError) },
                    { "35093", typeof(ExchangeError) },
                    { "35094", typeof(ExchangeError) },
                    { "35095", typeof(BadRequest) },
                    { "35096", typeof(ExchangeError) },
                    { "35097", typeof(ExchangeError) },
                    { "35098", typeof(ExchangeError) },
                    { "35099", typeof(ExchangeError) },
                    { "36001", typeof(BadRequest) },
                    { "36002", typeof(BadRequest) },
                    { "36005", typeof(ExchangeError) },
                    { "36101", typeof(AuthenticationError) },
                    { "36102", typeof(PermissionDenied) },
                    { "36103", typeof(AccountSuspended) },
                    { "36104", typeof(PermissionDenied) },
                    { "36105", typeof(PermissionDenied) },
                    { "36106", typeof(AccountSuspended) },
                    { "36107", typeof(PermissionDenied) },
                    { "36108", typeof(InsufficientFunds) },
                    { "36109", typeof(PermissionDenied) },
                    { "36201", typeof(PermissionDenied) },
                    { "36202", typeof(PermissionDenied) },
                    { "36203", typeof(InvalidOrder) },
                    { "36204", typeof(ExchangeError) },
                    { "36205", typeof(BadRequest) },
                    { "36206", typeof(BadRequest) },
                    { "36207", typeof(InvalidOrder) },
                    { "36208", typeof(InvalidOrder) },
                    { "36209", typeof(InvalidOrder) },
                    { "36210", typeof(InvalidOrder) },
                    { "36211", typeof(InvalidOrder) },
                    { "36212", typeof(InvalidOrder) },
                    { "36213", typeof(InvalidOrder) },
                    { "36214", typeof(ExchangeError) },
                    { "36216", typeof(OrderNotFound) },
                    { "36217", typeof(InvalidOrder) },
                    { "36218", typeof(InvalidOrder) },
                    { "36219", typeof(InvalidOrder) },
                    { "36220", typeof(InvalidOrder) },
                    { "36221", typeof(InvalidOrder) },
                    { "36222", typeof(InvalidOrder) },
                    { "36223", typeof(InvalidOrder) },
                    { "36224", typeof(InvalidOrder) },
                    { "36225", typeof(InvalidOrder) },
                    { "36226", typeof(InvalidOrder) },
                    { "36227", typeof(InvalidOrder) },
                    { "36228", typeof(InvalidOrder) },
                    { "36229", typeof(InvalidOrder) },
                    { "36230", typeof(InvalidOrder) },
                    { "400", typeof(BadRequest) },
                    { "401", typeof(AuthenticationError) },
                    { "403", typeof(PermissionDenied) },
                    { "404", typeof(BadRequest) },
                    { "405", typeof(BadRequest) },
                    { "415", typeof(BadRequest) },
                    { "429", typeof(DDoSProtection) },
                    { "500", typeof(ExchangeNotAvailable) },
                    { "1001", typeof(RateLimitExceeded) },
                    { "1002", typeof(ExchangeError) },
                    { "1003", typeof(ExchangeError) },
                    { "40001", typeof(AuthenticationError) },
                    { "40002", typeof(AuthenticationError) },
                    { "40003", typeof(AuthenticationError) },
                    { "40004", typeof(InvalidNonce) },
                    { "40005", typeof(InvalidNonce) },
                    { "40006", typeof(AuthenticationError) },
                    { "40007", typeof(BadRequest) },
                    { "40008", typeof(InvalidNonce) },
                    { "40009", typeof(AuthenticationError) },
                    { "40010", typeof(AuthenticationError) },
                    { "40011", typeof(AuthenticationError) },
                    { "40012", typeof(AuthenticationError) },
                    { "40013", typeof(ExchangeError) },
                    { "40014", typeof(PermissionDenied) },
                    { "40015", typeof(ExchangeError) },
                    { "40016", typeof(PermissionDenied) },
                    { "40017", typeof(ExchangeError) },
                    { "40018", typeof(PermissionDenied) },
                    { "40019", typeof(BadRequest) },
                    { "40031", typeof(AccountSuspended) },
                    { "40037", typeof(AuthenticationError) },
                    { "40102", typeof(BadRequest) },
                    { "40103", typeof(BadRequest) },
                    { "40104", typeof(ExchangeError) },
                    { "40105", typeof(ExchangeError) },
                    { "40106", typeof(ExchangeError) },
                    { "40107", typeof(ExchangeError) },
                    { "40108", typeof(InvalidOrder) },
                    { "40109", typeof(OrderNotFound) },
                    { "40200", typeof(OnMaintenance) },
                    { "40201", typeof(InvalidOrder) },
                    { "40202", typeof(ExchangeError) },
                    { "40203", typeof(BadRequest) },
                    { "40204", typeof(BadRequest) },
                    { "40205", typeof(BadRequest) },
                    { "40206", typeof(BadRequest) },
                    { "40207", typeof(BadRequest) },
                    { "40208", typeof(BadRequest) },
                    { "40209", typeof(BadRequest) },
                    { "40300", typeof(ExchangeError) },
                    { "40301", typeof(PermissionDenied) },
                    { "40302", typeof(BadRequest) },
                    { "40303", typeof(BadRequest) },
                    { "40304", typeof(BadRequest) },
                    { "40305", typeof(BadRequest) },
                    { "40306", typeof(ExchangeError) },
                    { "40308", typeof(OnMaintenance) },
                    { "40309", typeof(BadSymbol) },
                    { "40400", typeof(ExchangeError) },
                    { "40401", typeof(ExchangeError) },
                    { "40402", typeof(BadRequest) },
                    { "40403", typeof(BadRequest) },
                    { "40404", typeof(BadRequest) },
                    { "40405", typeof(BadRequest) },
                    { "40406", typeof(BadRequest) },
                    { "40407", typeof(ExchangeError) },
                    { "40408", typeof(ExchangeError) },
                    { "40409", typeof(ExchangeError) },
                    { "40500", typeof(InvalidOrder) },
                    { "40501", typeof(ExchangeError) },
                    { "40502", typeof(ExchangeError) },
                    { "40503", typeof(ExchangeError) },
                    { "40504", typeof(ExchangeError) },
                    { "40505", typeof(ExchangeError) },
                    { "40506", typeof(AuthenticationError) },
                    { "40507", typeof(AuthenticationError) },
                    { "40508", typeof(ExchangeError) },
                    { "40509", typeof(ExchangeError) },
                    { "40600", typeof(ExchangeError) },
                    { "40601", typeof(ExchangeError) },
                    { "40602", typeof(ExchangeError) },
                    { "40603", typeof(ExchangeError) },
                    { "40604", typeof(ExchangeNotAvailable) },
                    { "40605", typeof(ExchangeError) },
                    { "40606", typeof(ExchangeError) },
                    { "40607", typeof(ExchangeError) },
                    { "40608", typeof(ExchangeError) },
                    { "40609", typeof(ExchangeError) },
                    { "40700", typeof(BadRequest) },
                    { "40701", typeof(ExchangeError) },
                    { "40702", typeof(ExchangeError) },
                    { "40703", typeof(ExchangeError) },
                    { "40704", typeof(ExchangeError) },
                    { "40705", typeof(BadRequest) },
                    { "40706", typeof(InvalidOrder) },
                    { "40707", typeof(BadRequest) },
                    { "40708", typeof(BadRequest) },
                    { "40709", typeof(ExchangeError) },
                    { "40710", typeof(ExchangeError) },
                    { "40711", typeof(InsufficientFunds) },
                    { "40712", typeof(InsufficientFunds) },
                    { "40713", typeof(ExchangeError) },
                    { "40714", typeof(ExchangeError) },
                    { "40762", typeof(InsufficientFunds) },
                    { "40768", typeof(OrderNotFound) },
                    { "40808", typeof(InvalidOrder) },
                    { "41103", typeof(InvalidOrder) },
                    { "41114", typeof(OnMaintenance) },
                    { "43011", typeof(InvalidOrder) },
                    { "43001", typeof(OrderNotFound) },
                    { "43012", typeof(InsufficientFunds) },
                    { "43025", typeof(InvalidOrder) },
                    { "43115", typeof(OnMaintenance) },
                    { "45110", typeof(InvalidOrder) },
                    { "40774", typeof(InvalidOrder) },
                    { "45122", typeof(InvalidOrder) },
                    { "invalid sign", typeof(AuthenticationError) },
                    { "invalid currency", typeof(BadSymbol) },
                    { "invalid symbol", typeof(BadSymbol) },
                    { "invalid period", typeof(BadRequest) },
                    { "invalid user", typeof(ExchangeError) },
                    { "invalid amount", typeof(InvalidOrder) },
                    { "invalid type", typeof(InvalidOrder) },
                    { "invalid orderId", typeof(InvalidOrder) },
                    { "invalid record", typeof(ExchangeError) },
                    { "invalid accountId", typeof(BadRequest) },
                    { "invalid address", typeof(BadRequest) },
                    { "accesskey not null", typeof(AuthenticationError) },
                    { "illegal accesskey", typeof(AuthenticationError) },
                    { "sign not null", typeof(AuthenticationError) },
                    { "req_time is too much difference from server time", typeof(InvalidNonce) },
                    { "permissions not right", typeof(PermissionDenied) },
                    { "illegal sign invalid", typeof(AuthenticationError) },
                    { "user locked", typeof(AccountSuspended) },
                    { "Request Frequency Is Too High", typeof(RateLimitExceeded) },
                    { "more than a daily rate of cash", typeof(BadRequest) },
                    { "more than the maximum daily withdrawal amount", typeof(BadRequest) },
                    { "need to bind email or mobile", typeof(ExchangeError) },
                    { "user forbid", typeof(PermissionDenied) },
                    { "User Prohibited Cash Withdrawal", typeof(PermissionDenied) },
                    { "Cash Withdrawal Is Less Than The Minimum Value", typeof(BadRequest) },
                    { "Cash Withdrawal Is More Than The Maximum Value", typeof(BadRequest) },
                    { "the account with in 24 hours ban coin", typeof(PermissionDenied) },
                    { "order cancel fail", typeof(BadRequest) },
                    { "base symbol error", typeof(BadSymbol) },
                    { "base date error", typeof(ExchangeError) },
                    { "api signature not valid", typeof(AuthenticationError) },
                    { "gateway internal error", typeof(ExchangeError) },
                    { "audit failed", typeof(ExchangeError) },
                    { "order queryorder invalid", typeof(BadRequest) },
                    { "market no need price", typeof(InvalidOrder) },
                    { "limit need price", typeof(InvalidOrder) },
                    { "userid not equal to account_id", typeof(ExchangeError) },
                    { "your balance is low", typeof(InsufficientFunds) },
                    { "address invalid cointype", typeof(ExchangeError) },
                    { "system exception", typeof(ExchangeError) },
                    { "50003", typeof(ExchangeError) },
                    { "50004", typeof(BadSymbol) },
                    { "50006", typeof(PermissionDenied) },
                    { "50007", typeof(PermissionDenied) },
                    { "50008", typeof(RequestTimeout) },
                    { "50009", typeof(RateLimitExceeded) },
                    { "50010", typeof(ExchangeError) },
                    { "50014", typeof(InvalidOrder) },
                    { "50015", typeof(InvalidOrder) },
                    { "50016", typeof(InvalidOrder) },
                    { "50017", typeof(InvalidOrder) },
                    { "50018", typeof(InvalidOrder) },
                    { "50019", typeof(InvalidOrder) },
                    { "50020", typeof(InsufficientFunds) },
                    { "50021", typeof(InvalidOrder) },
                    { "50026", typeof(InvalidOrder) },
                    { "invalid order query time", typeof(ExchangeError) },
                    { "invalid start time", typeof(BadRequest) },
                    { "invalid end time", typeof(BadRequest) },
                    { "20003", typeof(ExchangeError) },
                    { "01001", typeof(ExchangeError) },
                    { "40024", typeof(RestrictedLocation) },
                    { "43111", typeof(PermissionDenied) },
                } },
                { "broad", new Dictionary<string, object>() {
                    { "invalid size, valid range", typeof(ExchangeError) },
                } },
            } },
            { "precisionMode", TICK_SIZE },
            { "commonCurrencies", new Dictionary<string, object>() {
                { "APX", "AstroPepeX" },
                { "DEGEN", "DegenReborn" },
                { "EVA", "Evadore" },
                { "JADE", "Jade Protocol" },
                { "OMNI", "omni" },
                { "TONCOIN", "TON" },
            } },
            { "options", new Dictionary<string, object>() {
                { "uta", false },
                { "timeDifference", 0 },
                { "adjustForTimeDifference", false },
                { "timeframes", new Dictionary<string, object>() {
                    { "spot", new Dictionary<string, object>() {
                        { "1m", "1min" },
                        { "5m", "5min" },
                        { "3m", "3min" },
                        { "15m", "15min" },
                        { "30m", "30min" },
                        { "1h", "1h" },
                        { "4h", "4h" },
                        { "6h", "6Hutc" },
                        { "12h", "12Hutc" },
                        { "1d", "1Dutc" },
                        { "3d", "3Dutc" },
                        { "1w", "1Wutc" },
                        { "1M", "1Mutc" },
                    } },
                    { "swap", new Dictionary<string, object>() {
                        { "1m", "1m" },
                        { "3m", "3m" },
                        { "5m", "5m" },
                        { "15m", "15m" },
                        { "30m", "30m" },
                        { "1h", "1H" },
                        { "2h", "2H" },
                        { "4h", "4H" },
                        { "6h", "6Hutc" },
                        { "12h", "12Hutc" },
                        { "1d", "1Dutc" },
                        { "3d", "3Dutc" },
                        { "1w", "1Wutc" },
                        { "1M", "1Mutc" },
                    } },
                    { "uta", new Dictionary<string, object>() {
                        { "1m", "1m" },
                        { "3m", "3m" },
                        { "5m", "5m" },
                        { "15m", "15m" },
                        { "30m", "30m" },
                        { "1h", "1H" },
                        { "2h", "2H" },
                        { "4h", "4H" },
                        { "6h", "6H" },
                        { "12h", "12H" },
                        { "1d", "1D" },
                    } },
                } },
                { "fetchMarkets", new Dictionary<string, object>() {
                    { "types", new List<object>() {"spot", "swap"} },
                } },
                { "defaultType", "spot" },
                { "defaultSubType", "linear" },
                { "createMarketBuyOrderRequiresPrice", true },
                { "broker", "p4sve" },
                { "withdraw", new Dictionary<string, object>() {
                    { "fillResponseFromRequest", true },
                } },
                { "fetchOHLCV", new Dictionary<string, object>() {
                    { "maxRecentDaysPerTimeframe", new Dictionary<string, object>() {
                        { "1m", 30 },
                        { "3m", 30 },
                        { "5m", 30 },
                        { "15m", 30 },
                        { "30m", 30 },
                        { "1h", 60 },
                        { "2h", 120 },
                        { "4h", 240 },
                        { "6h", 360 },
                        { "12h", 720 },
                        { "1d", 1440 },
                        { "3d", multiply(1440, 3) },
                        { "1w", multiply(1440, 7) },
                        { "1M", multiply(1440, 30) },
                    } },
                    { "spot", new Dictionary<string, object>() {
                        { "maxLimitPerTimeframe", new Dictionary<string, object>() {
                            { "1d", 300 },
                            { "3d", 100 },
                            { "1w", 100 },
                            { "1M", 100 },
                        } },
                        { "method", "publicSpotGetV2SpotMarketCandles" },
                    } },
                    { "swap", new Dictionary<string, object>() {
                        { "maxLimitPerTimeframe", new Dictionary<string, object>() {
                            { "4h", 540 },
                            { "6h", 360 },
                            { "12h", 180 },
                            { "1d", 90 },
                            { "3d", 30 },
                            { "1w", 13 },
                            { "1M", 4 },
                        } },
                        { "method", "publicMixGetV2MixMarketCandles" },
                    } },
                } },
                { "fetchTrades", new Dictionary<string, object>() {
                    { "spot", new Dictionary<string, object>() {
                        { "method", "publicSpotGetV2SpotMarketFillsHistory" },
                    } },
                    { "swap", new Dictionary<string, object>() {
                        { "method", "publicMixGetV2MixMarketFillsHistory" },
                    } },
                } },
                { "fetchFundingRate", new Dictionary<string, object>() {
                    { "method", "publicMixGetV2MixMarketCurrentFundRate" },
                } },
                { "accountsByType", new Dictionary<string, object>() {
                    { "spot", "spot" },
                    { "cross", "crossed_margin" },
                    { "isolated", "isolated_margin" },
                    { "swap", "usdt_futures" },
                    { "usdc_swap", "usdc_futures" },
                    { "future", "coin_futures" },
                    { "p2p", "p2p" },
                } },
                { "accountsById", new Dictionary<string, object>() {
                    { "spot", "spot" },
                    { "crossed_margin", "cross" },
                    { "isolated_margin", "isolated" },
                    { "usdt_futures", "swap" },
                    { "usdc_futures", "usdc_swap" },
                    { "coin_futures", "future" },
                    { "p2p", "p2p" },
                } },
                { "sandboxMode", false },
                { "networks", new Dictionary<string, object>() {
                    { "TRC20", "TRC20" },
                    { "ERC20", "ERC20" },
                    { "BEP20", "BSC" },
                    { "ATOM", "ATOM" },
                    { "ACA", "AcalaToken" },
                    { "APT", "Aptos" },
                    { "ARBONE", "ArbitrumOne" },
                    { "ARBNOVA", "ArbitrumNova" },
                    { "AVAXC", "C-Chain" },
                    { "AVAXX", "X-Chain" },
                    { "AR", "Arweave" },
                    { "BCH", "BCH" },
                    { "BCHA", "BCHA" },
                    { "BITCI", "BITCI" },
                    { "BTC", "BTC" },
                    { "CELO", "CELO" },
                    { "CSPR", "CSPR" },
                    { "ADA", "Cardano" },
                    { "CHZ", "ChilizChain" },
                    { "CRC20", "CronosChain" },
                    { "DOGE", "DOGE" },
                    { "DOT", "DOT" },
                    { "EOS", "EOS" },
                    { "ETHF", "ETHFAIR" },
                    { "ETHW", "ETHW" },
                    { "ETC", "ETC" },
                    { "EGLD", "Elrond" },
                    { "FIL", "FIL" },
                    { "FIO", "FIO" },
                    { "FTM", "Fantom" },
                    { "HRC20", "HECO" },
                    { "ONE", "Harmony" },
                    { "HNT", "Helium" },
                    { "ICP", "ICP" },
                    { "IOTX", "IoTeX" },
                    { "KARDIA", "KAI" },
                    { "KAVA", "KAVA" },
                    { "KDA", "KDA" },
                    { "KLAY", "Klaytn" },
                    { "KSM", "Kusama" },
                    { "LAT", "LAT" },
                    { "LTC", "LTC" },
                    { "MINA", "MINA" },
                    { "MOVR", "MOVR" },
                    { "METIS", "MetisToken" },
                    { "GLMR", "Moonbeam" },
                    { "NEAR", "NEARProtocol" },
                    { "NULS", "NULS" },
                    { "OASYS", "OASYS" },
                    { "OASIS", "ROSE" },
                    { "OMNI", "OMNI" },
                    { "ONT", "Ontology" },
                    { "OPTIMISM", "Optimism" },
                    { "OSMO", "Osmosis" },
                    { "POKT", "PocketNetwork" },
                    { "MATIC", "Polygon" },
                    { "QTUM", "QTUM" },
                    { "REEF", "REEF" },
                    { "SOL", "SOL" },
                    { "SYS", "SYS" },
                    { "SXP", "Solar" },
                    { "XYM", "Symbol" },
                    { "TON", "TON" },
                    { "TT", "TT" },
                    { "TLOS", "Telos" },
                    { "THETA", "ThetaToken" },
                    { "VITE", "VITE" },
                    { "WAVES", "WAVES" },
                    { "WAX", "WAXP" },
                    { "WEMIX", "WEMIXMainnet" },
                    { "XDC", "XDCNetworkXDC" },
                    { "XRP", "XRP" },
                    { "FET", "FETCH" },
                    { "NEM", "NEM" },
                    { "REI", "REINetwork" },
                    { "ZIL", "ZIL" },
                    { "ABBC", "ABBCCoin" },
                    { "RSK", "RSK" },
                    { "AZERO", "AZERO" },
                    { "TRC10", "TRC10" },
                    { "JUNO", "JUNO" },
                    { "ZKSYNC", "zkSyncEra" },
                    { "STARKNET", "Starknet" },
                    { "VIC", "VICTION" },
                } },
                { "networksById", new Dictionary<string, object>() {} },
                { "fetchPositions", new Dictionary<string, object>() {
                    { "method", "privateMixGetV2MixPositionAllPosition" },
                } },
                { "defaultTimeInForce", "GTC" },
                { "fiatCurrencies", new List<object>() {"EUR", "VND", "PLN", "CZK", "HUF", "DKK", "AUD", "CAD", "NOK", "SEK", "CHF", "MXN", "COP", "ARS", "GBP", "BRL", "UAH", "ZAR"} },
            } },
            { "rollingWindowSize", 1000 },
            { "features", new Dictionary<string, object>() {
                { "spot", new Dictionary<string, object>() {
                    { "sandbox", true },
                    { "createOrder", new Dictionary<string, object>() {
                        { "marginMode", true },
                        { "triggerPrice", true },
                        { "triggerPriceType", new Dictionary<string, object>() {
                            { "last", true },
                            { "mark", true },
                            { "index", false },
                        } },
                        { "triggerDirection", false },
                        { "stopLossPrice", true },
                        { "takeProfitPrice", true },
                        { "attachedStopLossTakeProfit", new Dictionary<string, object>() {
                            { "triggerPriceType", new Dictionary<string, object>() {
                                { "last", false },
                                { "mark", false },
                                { "index", false },
                            } },
                            { "price", true },
                        } },
                        { "timeInForce", new Dictionary<string, object>() {
                            { "IOC", true },
                            { "FOK", true },
                            { "PO", true },
                            { "GTD", false },
                        } },
                        { "hedged", false },
                        { "trailing", false },
                        { "marketBuyRequiresPrice", true },
                        { "marketBuyByCost", true },
                    } },
                    { "createOrders", new Dictionary<string, object>() {
                        { "max", 50 },
                    } },
                    { "fetchMyTrades", new Dictionary<string, object>() {
                        { "marginMode", true },
                        { "limit", 100 },
                        { "daysBack", null },
                        { "untilDays", 90 },
                        { "symbolRequired", true },
                    } },
                    { "fetchOrder", new Dictionary<string, object>() {
                        { "marginMode", false },
                        { "trigger", false },
                        { "trailing", false },
                        { "symbolRequired", true },
                    } },
                    { "fetchOpenOrders", new Dictionary<string, object>() {
                        { "marginMode", true },
                        { "limit", 100 },
                        { "trigger", true },
                        { "trailing", false },
                        { "symbolRequired", false },
                    } },
                    { "fetchOrders", null },
                    { "fetchClosedOrders", new Dictionary<string, object>() {
                        { "marginMode", true },
                        { "limit", 100 },
                        { "daysBack", null },
                        { "daysBackCanceled", null },
                        { "untilDays", 90 },
                        { "trigger", true },
                        { "trailing", false },
                        { "symbolRequired", false },
                    } },
                    { "fetchOHLCV", new Dictionary<string, object>() {
                        { "limit", 200 },
                    } },
                } },
                { "forPerps", new Dictionary<string, object>() {
                    { "extends", "spot" },
                    { "createOrder", new Dictionary<string, object>() {
                        { "triggerPrice", true },
                        { "triggerPriceType", new Dictionary<string, object>() {
                            { "last", true },
                            { "mark", true },
                            { "index", false },
                        } },
                        { "triggerDirection", false },
                        { "stopLossPrice", true },
                        { "takeProfitPrice", true },
                        { "attachedStopLossTakeProfit", new Dictionary<string, object>() {
                            { "triggerPriceType", new Dictionary<string, object>() {
                                { "last", true },
                                { "mark", true },
                                { "index", true },
                            } },
                            { "price", false },
                        } },
                        { "timeInForce", new Dictionary<string, object>() {
                            { "IOC", true },
                            { "FOK", true },
                            { "PO", true },
                            { "GTD", false },
                        } },
                        { "hedged", true },
                        { "trailing", true },
                        { "marketBuyRequiresPrice", false },
                        { "marketBuyByCost", false },
                    } },
                    { "fetchMyTrades", new Dictionary<string, object>() {
                        { "untilDays", 7 },
                    } },
                    { "fetchClosedOrders", new Dictionary<string, object>() {
                        { "trailing", true },
                    } },
                } },
                { "swap", new Dictionary<string, object>() {
                    { "linear", new Dictionary<string, object>() {
                        { "extends", "forPerps" },
                    } },
                    { "inverse", new Dictionary<string, object>() {
                        { "extends", "forPerps" },
                    } },
                } },
                { "future", new Dictionary<string, object>() {
                    { "linear", new Dictionary<string, object>() {
                        { "extends", "forPerps" },
                    } },
                    { "inverse", new Dictionary<string, object>() {
                        { "extends", "forPerps" },
                    } },
                } },
            } },
        });
    }

    /**
     * @method
     * @name bitget#setSandboxMode
     * @description enables or disables demo trading mode, if enabled will send PAPTRADING=1 in headers
     * @param enabled
     */
    public override void setSandboxMode(object enabled)
    {
        ((IDictionary<string,object>)this.options)["sandboxMode"] = enabled;
    }

    /**
     * @method
     * @name bitget#enableDemoTrading
     * @description enables or disables demo trading mode, if enabled will send PAPTRADING=1 in headers
     * @param enabled
     */
    public override void enableDemoTrading(object enabled)
    {
        this.setSandboxMode(enabled);
    }

    public virtual object handleProductTypeAndParams(object market = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object subType = null;
        var subTypeparametersVariable = this.handleSubTypeAndParams("handleProductTypeAndParams", null, parameters);
        subType = ((IList<object>)subTypeparametersVariable)[0];
        parameters = ((IList<object>)subTypeparametersVariable)[1];
        object defaultProductType = null;
        if (isTrue(isTrue((!isEqual(subType, null))) && isTrue((isEqual(market, null)))))
        {
            // set default only if subType is defined and market is not defined, since there is also USDC productTypes which are also linear
            // const sandboxMode = this.safeBool (this.options, 'sandboxMode', false);
            // if (sandboxMode) {
            //     defaultProductType = (subType === 'linear') ? 'SUSDT-FUTURES' : 'SCOIN-FUTURES';
            // } else {
            defaultProductType = ((bool) isTrue((isEqual(subType, "linear")))) ? "USDT-FUTURES" : "COIN-FUTURES";
        }
        object productType = this.safeString2(parameters, "productType", "category", defaultProductType);
        if (isTrue(isTrue((isEqual(productType, null))) && isTrue((!isEqual(market, null)))))
        {
            object settle = getValue(market, "settle");
            if (isTrue(getValue(market, "spot")))
            {
                object marginMode = null;
                var marginModeparametersVariable = this.handleMarginModeAndParams("handleProductTypeAndParams", parameters);
                marginMode = ((IList<object>)marginModeparametersVariable)[0];
                parameters = ((IList<object>)marginModeparametersVariable)[1];
                if (isTrue(!isEqual(marginMode, null)))
                {
                    productType = "MARGIN";
                } else
                {
                    productType = "SPOT";
                }
            } else if (isTrue(isEqual(settle, "USDT")))
            {
                productType = "USDT-FUTURES";
            } else if (isTrue(isEqual(settle, "USDC")))
            {
                productType = "USDC-FUTURES";
            } else if (isTrue(isEqual(settle, "SUSDT")))
            {
                productType = "SUSDT-FUTURES";
            } else if (isTrue(isEqual(settle, "SUSDC")))
            {
                productType = "SUSDC-FUTURES";
            } else if (isTrue(isTrue(isTrue((isEqual(settle, "SBTC"))) || isTrue((isEqual(settle, "SETH")))) || isTrue((isEqual(settle, "SEOS")))))
            {
                productType = "SCOIN-FUTURES";
            } else
            {
                productType = "COIN-FUTURES";
            }
        }
        if (isTrue(isEqual(productType, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " requires a productType param, one of \"USDT-FUTURES\", \"USDC-FUTURES\", \"COIN-FUTURES\", \"SUSDT-FUTURES\", \"SUSDC-FUTURES\", \"SCOIN-FUTURES\" or for uta only \"SPOT\"")) ;
        }
        parameters = this.omit(parameters, new List<object>() {"productType", "category"});
        return new List<object>() {productType, parameters};
    }

    /**
     * @method
     * @name bitget#fetchTime
     * @description fetches the current integer timestamp in milliseconds from the exchange server
     * @see https://www.bitget.com/api-doc/common/public/Get-Server-Time
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {int} the current integer timestamp in milliseconds from the exchange server
     */
    public async override Task<object> fetchTime(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object response = await this.publicCommonGetV2PublicTime(parameters);
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1700111073740,
        //         "data": {
        //             "serverTime": "1700111073740"
        //         }
        //     }
        //
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        return this.safeInteger(data, "serverTime");
    }

    /**
     * @method
     * @name bitget#fetchMarkets
     * @description retrieves data on all markets for bitget
     * @see https://www.bitget.com/api-doc/spot/market/Get-Symbols
     * @see https://www.bitget.com/api-doc/contract/market/Get-All-Symbols-Contracts
     * @see https://www.bitget.com/api-doc/margin/common/support-currencies
     * @see https://www.bitget.com/api-doc/uta/public/Instruments
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {boolean} [params.uta] set to true for the unified trading account (uta), defaults to false
     * @returns {object[]} an array of objects representing market data
     */
    public async override Task<object> fetchMarkets(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (isTrue(getValue(this.options, "adjustForTimeDifference")))
        {
            await this.loadTimeDifference();
        }
        object uta = null;
        var utaparametersVariable = this.handleOptionAndParams(parameters, "fetchMarkets", "uta", false);
        uta = ((IList<object>)utaparametersVariable)[0];
        parameters = ((IList<object>)utaparametersVariable)[1];
        if (isTrue(uta))
        {
            return await this.fetchUtaMarkets(parameters);
        } else
        {
            return await this.fetchDefaultMarkets(parameters);
        }
    }

    public async virtual Task<object> fetchDefaultMarkets(object parameters)
    {
        object types = null;
        object fetchMarketsOptions = this.safeDict(this.options, "fetchMarkets");
        object defaultMarkets = new List<object>() {"spot", "swap"};
        if (isTrue(!isEqual(fetchMarketsOptions, null)))
        {
            types = this.safeList(fetchMarketsOptions, "types", defaultMarkets);
        } else
        {
            // for backward-compatibility
            types = this.safeList(this.options, "fetchMarkets", defaultMarkets);
        }
        object promises = new List<object>() {};
        object fetchMargins = false;
        for (object i = 0; isLessThan(i, getArrayLength(types)); postFixIncrement(ref i))
        {
            object type = getValue(types, i);
            if (isTrue(isTrue((isEqual(type, "swap"))) || isTrue((isEqual(type, "future")))))
            {
                object subTypes = new List<object>() {"USDT-FUTURES", "COIN-FUTURES", "USDC-FUTURES", "SUSDT-FUTURES", "SCOIN-FUTURES", "SUSDC-FUTURES"};
                for (object j = 0; isLessThan(j, getArrayLength(subTypes)); postFixIncrement(ref j))
                {
                    ((IList<object>)promises).Add(this.publicMixGetV2MixMarketContracts(this.extend(parameters, new Dictionary<string, object>() {
                        { "productType", getValue(subTypes, j) },
                    })));
                }
            } else if (isTrue(isEqual(type, "spot")))
            {
                ((IList<object>)promises).Add(this.publicSpotGetV2SpotPublicSymbols(parameters));
                fetchMargins = true;
                ((IList<object>)promises).Add(this.publicMarginGetV2MarginCurrencies(parameters));
            } else
            {
                throw new NotSupported ((string)add(add(add(this.id, " does not support "), type), " market")) ;
            }
        }
        object results = await promiseAll(promises);
        object markets = new List<object>() {};
        ((IDictionary<string,object>)this.options)["crossMarginPairsData"] = new List<object>() {};
        ((IDictionary<string,object>)this.options)["isolatedMarginPairsData"] = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(results)); postFixIncrement(ref i))
        {
            object res = this.safeDict(results, i);
            object data = this.safeList(res, "data", new List<object>() {});
            object firstData = this.safeDict(data, 0, new Dictionary<string, object>() {});
            object isBorrowable = this.safeBool(firstData, "isBorrowable");
            if (isTrue(isTrue(fetchMargins) && isTrue(!isEqual(isBorrowable, null))))
            {
                object keysList = new List<object>(((IDictionary<string,object>)this.indexBy(data, "symbol")).Keys);
                ((IDictionary<string,object>)this.options)["crossMarginPairsData"] = keysList;
                ((IDictionary<string,object>)this.options)["isolatedMarginPairsData"] = keysList;
            } else
            {
                markets = this.arrayConcat(markets, data);
            }
        }
        //
        // spot
        //
        //     {
        //         "symbol": "TRXUSDT",
        //         "baseCoin": "TRX",
        //         "quoteCoin": "USDT",
        //         "minTradeAmount": "0",
        //         "maxTradeAmount": "10000000000",
        //         "takerFeeRate": "0.002",
        //         "makerFeeRate": "0.002",
        //         "pricePrecision": "6",
        //         "quantityPrecision": "4",
        //         "quotePrecision": "6",
        //         "status": "online",
        //         "minTradeUSDT": "5",
        //         "buyLimitPriceRatio": "0.05",
        //         "sellLimitPriceRatio": "0.05"
        //     }
        //
        // swap and future
        //
        //     {
        //         "symbol": "BTCUSDT",
        //         "baseCoin": "BTC",
        //         "quoteCoin": "USDT",
        //         "buyLimitPriceRatio": "0.01",
        //         "sellLimitPriceRatio": "0.01",
        //         "feeRateUpRatio": "0.005",
        //         "makerFeeRate": "0.0002",
        //         "takerFeeRate": "0.0006",
        //         "openCostUpRatio": "0.01",
        //         "supportMarginCoins": ["USDT"],
        //         "minTradeNum": "0.001",
        //         "priceEndStep": "1",
        //         "volumePlace": "3",
        //         "pricePlace": "1",
        //         "sizeMultiplier": "0.001",
        //         "symbolType": "perpetual",
        //         "minTradeUSDT": "5",
        //         "maxSymbolOrderNum": "200",
        //         "maxProductOrderNum": "400",
        //         "maxPositionNum": "150",
        //         "symbolStatus": "normal",
        //         "offTime": "-1",
        //         "limitOpenTime": "-1",
        //         "deliveryTime": "",
        //         "deliveryStartTime": "",
        //         "deliveryPeriod": "",
        //         "launchTime": "",
        //         "fundInterval": "8",
        //         "minLever": "1",
        //         "maxLever": "125",
        //         "posLimit": "0.05",
        //         "maintainTime": ""
        //     }
        //
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(markets)); postFixIncrement(ref i))
        {
            object market = getValue(markets, i);
            object marketId = this.safeString(market, "symbol");
            object quoteId = this.safeString(market, "quoteCoin");
            object baseId = this.safeString(market, "baseCoin");
            object quote = this.safeCurrencyCode(quoteId);
            object bs = this.safeCurrencyCode(baseId);
            object supportMarginCoins = this.safeValue(market, "supportMarginCoins", new List<object>() {});
            object settleId = null;
            if (isTrue(this.inArray(baseId, supportMarginCoins)))
            {
                settleId = baseId;
            } else if (isTrue(this.inArray(quoteId, supportMarginCoins)))
            {
                settleId = quoteId;
            } else
            {
                settleId = this.safeString(supportMarginCoins, 0);
            }
            object settle = this.safeCurrencyCode(settleId);
            object symbol = add(add(bs, "/"), quote);
            object type = null;
            object swap = false;
            object spot = false;
            object future = false;
            object contract = false;
            object pricePrecision = null;
            object amountPrecision = null;
            object linear = null;
            object inverse = null;
            object expiry = null;
            object expiryDatetime = null;
            object symbolType = this.safeString(market, "symbolType");
            object marginModes = null;
            object isMarginTradingAllowed = false;
            if (isTrue(isEqual(symbolType, null)))
            {
                type = "spot";
                spot = true;
                pricePrecision = this.parseNumber(this.parsePrecision(this.safeString(market, "pricePrecision")));
                amountPrecision = this.parseNumber(this.parsePrecision(this.safeString(market, "quantityPrecision")));
                object hasCrossMargin = this.inArray(marketId, getValue(this.options, "crossMarginPairsData"));
                object hasIsolatedMargin = this.inArray(marketId, getValue(this.options, "isolatedMarginPairsData"));
                marginModes = new Dictionary<string, object>() {
                    { "cross", hasCrossMargin },
                    { "isolated", hasIsolatedMargin },
                };
                isMarginTradingAllowed = isTrue(hasCrossMargin) || isTrue(hasIsolatedMargin);
            } else
            {
                if (isTrue(isEqual(symbolType, "perpetual")))
                {
                    type = "swap";
                    swap = true;
                    symbol = add(add(symbol, ":"), settle);
                } else if (isTrue(isEqual(symbolType, "delivery")))
                {
                    expiry = this.safeInteger(market, "deliveryTime");
                    expiryDatetime = this.iso8601(expiry);
                    object expiryParts = ((string)expiryDatetime).Split(new [] {((string)"-")}, StringSplitOptions.None).ToList<object>();
                    object yearPart = this.safeString(expiryParts, 0);
                    object dayPart = this.safeString(expiryParts, 2);
                    object year = slice(yearPart, 2, 4);
                    object month = this.safeString(expiryParts, 1);
                    object day = slice(dayPart, 0, 2);
                    object expiryString = add(add(year, month), day);
                    type = "future";
                    future = true;
                    symbol = add(add(add(add(symbol, ":"), settle), "-"), expiryString);
                }
                contract = true;
                inverse = (isEqual(bs, settle));
                linear = !isTrue(inverse);
                object priceDecimals = this.safeInteger(market, "pricePlace");
                object amountDecimals = this.safeInteger(market, "volumePlace");
                object priceStep = this.safeString(market, "priceEndStep");
                object amountStep = this.safeString(market, "sizeMultiplier");
                var precise = new Precise(priceStep);
                precise.decimals = mathMax(precise.decimals, priceDecimals);
                precise.reduce();
                object priceString = ((object)precise).ToString();
                pricePrecision = this.parseNumber(priceString);
                var preciseAmount = new Precise(amountStep);
                preciseAmount.decimals = mathMax(preciseAmount.decimals, amountDecimals);
                preciseAmount.reduce();
                object amountString = ((object)preciseAmount).ToString();
                amountPrecision = this.parseNumber(amountString);
                marginModes = new Dictionary<string, object>() {
                    { "cross", true },
                    { "isolated", true },
                };
            }
            object status = this.safeString2(market, "status", "symbolStatus");
            object active = null;
            if (isTrue(!isEqual(status, null)))
            {
                active = (isTrue((isEqual(status, "online"))) || isTrue((isEqual(status, "normal"))));
            }
            object minCost = null;
            if (isTrue(isEqual(quote, "USDT")))
            {
                minCost = this.safeNumber(market, "minTradeUSDT");
            }
            object contractSize = ((bool) isTrue(contract)) ? 1 : null;
            ((IList<object>)result).Add(this.safeMarketStructure(new Dictionary<string, object>() {
                { "id", marketId },
                { "symbol", symbol },
                { "base", bs },
                { "quote", quote },
                { "settle", settle },
                { "baseId", baseId },
                { "quoteId", quoteId },
                { "settleId", settleId },
                { "type", type },
                { "spot", spot },
                { "margin", isTrue(spot) && isTrue(isMarginTradingAllowed) },
                { "marginModes", marginModes },
                { "swap", swap },
                { "future", future },
                { "option", false },
                { "active", active },
                { "contract", contract },
                { "linear", linear },
                { "inverse", inverse },
                { "taker", this.safeNumber(market, "takerFeeRate") },
                { "maker", this.safeNumber(market, "makerFeeRate") },
                { "contractSize", contractSize },
                { "expiry", expiry },
                { "expiryDatetime", expiryDatetime },
                { "strike", null },
                { "optionType", null },
                { "precision", new Dictionary<string, object>() {
                    { "amount", amountPrecision },
                    { "price", pricePrecision },
                } },
                { "limits", new Dictionary<string, object>() {
                    { "leverage", new Dictionary<string, object>() {
                        { "min", this.safeNumber(market, "minLever") },
                        { "max", this.safeNumber(market, "maxLever") },
                    } },
                    { "amount", new Dictionary<string, object>() {
                        { "min", this.safeNumber2(market, "minTradeNum", "minTradeAmount") },
                        { "max", this.safeNumber(market, "maxTradeAmount") },
                    } },
                    { "price", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                    { "cost", new Dictionary<string, object>() {
                        { "min", minCost },
                        { "max", null },
                    } },
                } },
                { "created", this.safeInteger(market, "launchTime") },
                { "info", market },
            }));
        }
        return result;
    }

    public async virtual Task<object> fetchUtaMarkets(object parameters)
    {
        object subTypes = new List<object>() {"SPOT", "USDT-FUTURES", "COIN-FUTURES", "USDC-FUTURES"};
        object promises = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(subTypes)); postFixIncrement(ref i))
        {
            object req = this.extend(parameters, new Dictionary<string, object>() {
                { "category", getValue(subTypes, i) },
            });
            ((IList<object>)promises).Add(this.publicUtaGetV3MarketInstruments(req));
        }
        object results = await promiseAll(promises);
        object markets = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(results)); postFixIncrement(ref i))
        {
            object res = this.safeDict(results, i);
            object data = this.safeList(res, "data", new List<object>() {});
            markets = this.arrayConcat(markets, data);
        }
        //
        // spot uta
        //
        //     {
        //         "symbol": "BTCUSDT",
        //         "category": "SPOT",
        //         "baseCoin": "BTC",
        //         "quoteCoin": "USDT",
        //         "buyLimitPriceRatio": "0.05",
        //         "sellLimitPriceRatio": "0.05",
        //         "minOrderQty": "0.000001",
        //         "maxOrderQty": "0",
        //         "pricePrecision": "2",
        //         "quantityPrecision": "6",
        //         "quotePrecision": "8",
        //         "minOrderAmount": "1",
        //         "maxSymbolOrderNum": "400",
        //         "maxProductOrderNum": "400",
        //         "status": "online",
        //         "maintainTime": ""
        //     }
        //
        // margin uta
        //
        //     {
        //         "symbol": "BTCUSDC",
        //         "category": "MARGIN",
        //         "baseCoin": "BTC",
        //         "quoteCoin": "USDC",
        //         "buyLimitPriceRatio": "0.05",
        //         "sellLimitPriceRatio": "0.05",
        //         "minOrderQty": "0.00001",
        //         "maxOrderQty": "0",
        //         "pricePrecision": "2",
        //         "quantityPrecision": "5",
        //         "quotePrecision": "7",
        //         "minOrderAmount": "1",
        //         "maxSymbolOrderNum": "400",
        //         "maxProductOrderNum": "400",
        //         "status": "online",
        //         "maintainTime": "",
        //         "isIsolatedBaseBorrowable": "NO",
        //         "isIsolatedQuotedBorrowable": "NO",
        //         "warningRiskRatio": "0.8",
        //         "liquidationRiskRatio": "1",
        //         "maxCrossedLeverage": "3",
        //         "maxIsolatedLeverage": "0",
        //         "userMinBorrow": "0.00000001",
        //         "areaSymbol": "no"
        //     }
        //
        // swap and future uta
        //
        //     {
        //         "symbol": "BTCPERP",
        //         "category": "USDC-FUTURES",
        //         "baseCoin": "BTC",
        //         "quoteCoin": "USDC",
        //         "buyLimitPriceRatio": "0.02",
        //         "sellLimitPriceRatio": "0.02",
        //         "feeRateUpRatio": "0.005",
        //         "makerFeeRate": "0.0002",
        //         "takerFeeRate": "0.0006",
        //         "openCostUpRatio": "0.01",
        //         "minOrderQty": "0.0001",
        //         "maxOrderQty": "",
        //         "pricePrecision": "1",
        //         "quantityPrecision": "4",
        //         "quotePrecision": null,
        //         "priceMultiplier": "0.5",
        //         "quantityMultiplier": "0.0001",
        //         "type": "perpetual",
        //         "minOrderAmount": "5",
        //         "maxSymbolOrderNum": "200",
        //         "maxProductOrderNum": "1000",
        //         "maxPositionNum": "150",
        //         "status": "online",
        //         "offTime": "-1",
        //         "limitOpenTime": "-1",
        //         "deliveryTime": "",
        //         "deliveryStartTime": "",
        //         "deliveryPeriod": "",
        //         "launchTime": "",
        //         "fundInterval": "8",
        //         "minLeverage": "1",
        //         "maxLeverage": "125",
        //         "maintainTime": ""
        //     }
        //
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(markets)); postFixIncrement(ref i))
        {
            object market = getValue(markets, i);
            object category = this.safeString(market, "category");
            object marketId = this.safeString(market, "symbol");
            object quoteId = this.safeString(market, "quoteCoin");
            object baseId = this.safeString(market, "baseCoin");
            object quote = this.safeCurrencyCode(quoteId);
            object bs = this.safeCurrencyCode(baseId);
            object settleId = null;
            object settle = null;
            if (isTrue(isEqual(category, "USDT-FUTURES")))
            {
                settleId = "USDT";
            } else if (isTrue(isEqual(category, "USDC-FUTURES")))
            {
                settleId = "USDC";
            } else if (isTrue(isEqual(category, "COIN-FUTURES")))
            {
                settleId = bs;
            }
            if (isTrue(!isEqual(settleId, null)))
            {
                settle = this.safeCurrencyCode(settleId);
            }
            object symbol = add(add(bs, "/"), quote);
            object type = null;
            object swap = false;
            object spot = false;
            object future = false;
            object contract = false;
            object pricePrecision = null;
            object amountPrecision = null;
            object linear = null;
            object inverse = null;
            object expiry = null;
            object expiryDatetime = null;
            object symbolType = this.safeString(market, "type");
            object marginModes = null;
            object isMarginTradingAllowed = false;
            object isUtaMargin = (isEqual(category, "MARGIN"));
            if (isTrue(isTrue(isUtaMargin) || isTrue((isEqual(category, "SPOT")))))
            {
                type = "spot";
                spot = true;
                if (isTrue(isUtaMargin))
                {
                    object isolatedBase = this.safeString(market, "isIsolatedBaseBorrowable");
                    object isolatedQuote = this.safeString(market, "isIsolatedQuotedBorrowable");
                    object isolated = isTrue((isEqual(isolatedBase, "YES"))) || isTrue((isEqual(isolatedQuote, "YES")));
                    object maxCrossLeverage = this.safeString(market, "maxCrossedLeverage");
                    object cross = (!isEqual(maxCrossLeverage, "0"));
                    marginModes = new Dictionary<string, object>() {
                        { "cross", cross },
                        { "isolated", isolated },
                    };
                    isMarginTradingAllowed = true;
                }
            } else
            {
                if (isTrue(isEqual(symbolType, "perpetual")))
                {
                    type = "swap";
                    swap = true;
                    symbol = add(add(symbol, ":"), settle);
                } else if (isTrue(isEqual(symbolType, "delivery")))
                {
                    expiry = this.safeInteger(market, "deliveryTime");
                    expiryDatetime = this.iso8601(expiry);
                    object expiryParts = ((string)expiryDatetime).Split(new [] {((string)"-")}, StringSplitOptions.None).ToList<object>();
                    object yearPart = this.safeString(expiryParts, 0);
                    object dayPart = this.safeString(expiryParts, 2);
                    object year = slice(yearPart, 2, 4);
                    object month = this.safeString(expiryParts, 1);
                    object day = slice(dayPart, 0, 2);
                    object expiryString = add(add(year, month), day);
                    type = "future";
                    future = true;
                    symbol = add(add(add(add(symbol, ":"), settle), "-"), expiryString);
                }
                contract = true;
                inverse = (isEqual(bs, settle));
                linear = !isTrue(inverse);
                marginModes = new Dictionary<string, object>() {
                    { "cross", true },
                    { "isolated", true },
                };
            }
            pricePrecision = this.parseNumber(this.parsePrecision(this.safeString(market, "pricePrecision")));
            amountPrecision = this.parseNumber(this.parsePrecision(this.safeString(market, "quantityPrecision")));
            object status = this.safeString(market, "status");
            object active = null;
            if (isTrue(!isEqual(status, null)))
            {
                active = (isTrue((isEqual(status, "online"))) || isTrue((isEqual(status, "normal"))));
            }
            object contractSize = ((bool) isTrue(contract)) ? 1 : null;
            ((IList<object>)result).Add(this.safeMarketStructure(new Dictionary<string, object>() {
                { "id", marketId },
                { "symbol", symbol },
                { "base", bs },
                { "quote", quote },
                { "settle", settle },
                { "baseId", baseId },
                { "quoteId", quoteId },
                { "settleId", settleId },
                { "type", type },
                { "spot", spot },
                { "margin", isTrue(spot) && isTrue(isMarginTradingAllowed) },
                { "marginModes", marginModes },
                { "swap", swap },
                { "future", future },
                { "option", false },
                { "active", active },
                { "contract", contract },
                { "linear", linear },
                { "inverse", inverse },
                { "taker", this.safeNumber(market, "takerFeeRate") },
                { "maker", this.safeNumber(market, "makerFeeRate") },
                { "contractSize", contractSize },
                { "expiry", expiry },
                { "expiryDatetime", expiryDatetime },
                { "strike", null },
                { "optionType", null },
                { "precision", new Dictionary<string, object>() {
                    { "amount", amountPrecision },
                    { "price", pricePrecision },
                } },
                { "limits", new Dictionary<string, object>() {
                    { "leverage", new Dictionary<string, object>() {
                        { "min", this.safeNumber(market, "minLeverage") },
                        { "max", this.safeNumber(market, "maxLeverage") },
                    } },
                    { "amount", new Dictionary<string, object>() {
                        { "min", this.safeNumber(market, "minOrderQty") },
                        { "max", this.safeNumber(market, "maxOrderQty") },
                    } },
                    { "price", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                    { "cost", new Dictionary<string, object>() {
                        { "min", this.safeNumber(market, "minOrderAmount") },
                        { "max", null },
                    } },
                } },
                { "created", this.safeInteger(market, "launchTime") },
                { "info", market },
            }));
        }
        return result;
    }

    /**
     * @method
     * @name bitget#fetchCurrencies
     * @description fetches all available currencies on an exchange
     * @see https://www.bitget.com/api-doc/spot/market/Get-Coin-List
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} an associative dictionary of currencies
     */
    public async override Task<object> fetchCurrencies(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object response = await this.publicSpotGetV2SpotPublicCoins(parameters);
        //
        //    {
        //        "code": "00000",
        //        "msg": "success",
        //        "requestTime": "1746195617812",
        //        "data": [
        //            {
        //                "coinId": "1456",
        //                "coin": "NEIROETH",
        //                "transfer": "false",
        //                "chains": [
        //                    {
        //                        "chain": "ERC20",
        //                        "needTag": "false",
        //                        "withdrawable": "true",
        //                        "rechargeable": "true",
        //                        "withdrawFee": "44.91017965",
        //                        "extraWithdrawFee": "0",
        //                        "depositConfirm": "12",
        //                        "withdrawConfirm": "64",
        //                        "minDepositAmount": "0.06",
        //                        "minWithdrawAmount": "60",
        //                        "browserUrl": "https://etherscan.io/tx/",
        //                        "contractAddress": "0xee2a03aa6dacf51c18679c516ad5283d8e7c2637",
        //                        "withdrawStep": "0",
        //                        "withdrawMinScale": "8",
        //                        "congestion": "normal"
        //                    }
        //                ],
        //                "areaCoin": "no"
        //            },
        //            ...
        //
        object result = new Dictionary<string, object>() {};
        object data = this.safeValue(response, "data", new List<object>() {});
        object fiatCurrencies = this.safeList(this.options, "fiatCurrencies", new List<object>() {});
        for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
        {
            object entry = getValue(data, i);
            object id = this.safeString(entry, "coin"); // we don't use 'coinId' as it has no use. it is 'coin' field that needs to be used in currency related endpoints (deposit, withdraw, etc..)
            object code = this.safeCurrencyCode(id);
            object chains = this.safeValue(entry, "chains", new List<object>() {});
            object networks = new Dictionary<string, object>() {};
            object withdraw = null;
            object deposit = null;
            object chainsLength = getArrayLength(chains);
            if (isTrue(isEqual(chainsLength, 0)))
            {
                withdraw = false;
                deposit = false;
            }
            for (object j = 0; isLessThan(j, chainsLength); postFixIncrement(ref j))
            {
                object chain = getValue(chains, j);
                object networkId = this.safeString(chain, "chain");
                object network = this.networkIdToCode(networkId, code);
                network = ((string)network).ToUpper();
                object withdrawable = (isEqual(this.safeString(chain, "withdrawable"), "true"));
                object rechargeable = (isEqual(this.safeString(chain, "rechargeable"), "true"));
                withdraw = ((bool) isTrue((isEqual(withdraw, null)))) ? withdrawable : (isTrue(withdraw) || isTrue(withdrawable));
                deposit = ((bool) isTrue((isEqual(deposit, null)))) ? rechargeable : (isTrue(deposit) || isTrue(rechargeable));
                ((IDictionary<string,object>)networks)[(string)network] = new Dictionary<string, object>() {
                    { "info", chain },
                    { "id", networkId },
                    { "network", network },
                    { "limits", new Dictionary<string, object>() {
                        { "withdraw", new Dictionary<string, object>() {
                            { "min", this.safeNumber(chain, "minWithdrawAmount") },
                            { "max", null },
                        } },
                        { "deposit", new Dictionary<string, object>() {
                            { "min", this.safeNumber(chain, "minDepositAmount") },
                            { "max", null },
                        } },
                    } },
                    { "active", null },
                    { "withdraw", withdrawable },
                    { "deposit", rechargeable },
                    { "fee", this.safeNumber(chain, "withdrawFee") },
                    { "precision", this.parseNumber(this.parsePrecision(this.safeString(chain, "withdrawMinScale"))) },
                };
            }
            object active = isTrue(withdraw) && isTrue(deposit);
            object isFiat = this.inArray(code, fiatCurrencies);
            ((IDictionary<string,object>)result)[(string)code] = this.safeCurrencyStructure(new Dictionary<string, object>() {
                { "info", entry },
                { "id", id },
                { "code", code },
                { "networks", networks },
                { "type", ((bool) isTrue(isFiat)) ? "fiat" : "crypto" },
                { "name", null },
                { "active", active },
                { "deposit", deposit },
                { "withdraw", withdraw },
                { "fee", null },
                { "precision", null },
                { "limits", new Dictionary<string, object>() {
                    { "amount", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                    { "withdraw", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                    { "deposit", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                } },
                { "created", null },
            });
        }
        return result;
    }

    /**
     * @method
     * @name bitget#fetchMarketLeverageTiers
     * @description retrieve information on the maximum leverage, and maintenance margin for trades of varying trade sizes for a single market
     * @see https://www.bitget.com/api-doc/contract/position/Get-Query-Position-Lever
     * @see https://www.bitget.com/api-doc/margin/cross/account/Cross-Tier-Data
     * @see https://www.bitget.com/api-doc/margin/isolated/account/Isolated-Tier-Data
     * @see https://www.bitget.com/api-doc/uta/public/Get-Position-Tier-Data
     * @param {string} symbol unified market symbol
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.marginMode] for spot margin 'cross' or 'isolated', default is 'isolated'
     * @param {string} [params.code] required for cross spot margin
     * @param {string} [params.productType] *contract and uta only* 'USDT-FUTURES', 'USDC-FUTURES', 'COIN-FUTURES', 'SUSDT-FUTURES', 'SUSDC-FUTURES' or 'SCOIN-FUTURES'
     * @param {boolean} [params.uta] set to true for the unified trading account (uta), defaults to false
     * @returns {object} a [leverage tiers structure]{@link https://docs.ccxt.com/?id=leverage-tiers-structure}
     */
    public async override Task<object> fetchMarketLeverageTiers(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {};
        object response = null;
        object marginMode = null;
        object productType = null;
        object uta = null;
        var marginModeparametersVariable = this.handleMarginModeAndParams("fetchMarketLeverageTiers", parameters, "isolated");
        marginMode = ((IList<object>)marginModeparametersVariable)[0];
        parameters = ((IList<object>)marginModeparametersVariable)[1];
        var productTypeparametersVariable = this.handleProductTypeAndParams(market, parameters);
        productType = ((IList<object>)productTypeparametersVariable)[0];
        parameters = ((IList<object>)productTypeparametersVariable)[1];
        var utaparametersVariable = this.handleOptionAndParams(parameters, "fetchMarketLeverageTiers", "uta", false);
        uta = ((IList<object>)utaparametersVariable)[0];
        parameters = ((IList<object>)utaparametersVariable)[1];
        if (isTrue(uta))
        {
            if (isTrue(isEqual(productType, "SPOT")))
            {
                if (isTrue(!isEqual(marginMode, null)))
                {
                    productType = "MARGIN";
                }
            }
            ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
            ((IDictionary<string,object>)request)["category"] = productType;
            response = await this.publicUtaGetV3MarketPositionTier(this.extend(request, parameters));
        } else if (isTrue(isTrue((getValue(market, "swap"))) || isTrue((getValue(market, "future")))))
        {
            ((IDictionary<string,object>)request)["productType"] = productType;
            ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
            response = await this.publicMixGetV2MixMarketQueryPositionLever(this.extend(request, parameters));
        } else if (isTrue(isEqual(marginMode, "isolated")))
        {
            ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
            response = await this.privateMarginGetV2MarginIsolatedTierData(this.extend(request, parameters));
        } else if (isTrue(isEqual(marginMode, "cross")))
        {
            object code = this.safeString(parameters, "code");
            if (isTrue(isEqual(code, null)))
            {
                throw new ArgumentsRequired ((string)add(this.id, " fetchMarketLeverageTiers() requires a code argument")) ;
            }
            parameters = this.omit(parameters, "code");
            object currency = this.currency(code);
            ((IDictionary<string,object>)request)["coin"] = getValue(currency, "id");
            response = await this.privateMarginGetV2MarginCrossedTierData(this.extend(request, parameters));
        } else
        {
            throw new BadRequest ((string)add(add(this.id, " fetchMarketLeverageTiers() symbol does not support market "), getValue(market, "symbol"))) ;
        }
        //
        // swap and future
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1700290724614,
        //         "data": [
        //             {
        //                 "symbol": "BTCUSDT",
        //                 "level": "1",
        //                 "startUnit": "0",
        //                 "endUnit": "150000",
        //                 "leverage": "125",
        //                 "keepMarginRate": "0.004"
        //             },
        //         ]
        //     }
        //
        // isolated
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1700291531894,
        //         "data": [
        //             {
        //                 "tier": "1",
        //                 "symbol": "BTCUSDT",
        //                 "leverage": "10",
        //                 "baseCoin": "BTC",
        //                 "quoteCoin": "USDT",
        //                 "baseMaxBorrowableAmount": "2",
        //                 "quoteMaxBorrowableAmount": "24000",
        //                 "maintainMarginRate": "0.05",
        //                 "initRate": "0.1111"
        //             },
        //         ]
        //     }
        //
        // cross
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1700291818831,
        //         "data": [
        //             {
        //                 "tier": "1",
        //                 "leverage": "3",
        //                 "coin": "BTC",
        //                 "maxBorrowableAmount": "26",
        //                 "maintainMarginRate": "0.1"
        //             }
        //         ]
        //     }
        //
        // uta
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1752735673127,
        //         "data": [
        //             {
        //                 "tier": "1",
        //                 "minTierValue": "0",
        //                 "maxTierValue": "150000",
        //                 "leverage": "125",
        //                 "mmr": "0.004"
        //             },
        //         ]
        //     }
        //
        object result = this.safeValue(response, "data", new List<object>() {});
        return this.parseMarketLeverageTiers(result, market);
    }

    public override object parseMarketLeverageTiers(object info, object market = null)
    {
        //
        // swap and future
        //
        //     {
        //         "symbol": "BTCUSDT",
        //         "level": "1",
        //         "startUnit": "0",
        //         "endUnit": "150000",
        //         "leverage": "125",
        //         "keepMarginRate": "0.004"
        //     }
        //
        // isolated
        //
        //     {
        //         "tier": "1",
        //         "symbol": "BTCUSDT",
        //         "leverage": "10",
        //         "baseCoin": "BTC",
        //         "quoteCoin": "USDT",
        //         "baseMaxBorrowableAmount": "2",
        //         "quoteMaxBorrowableAmount": "24000",
        //         "maintainMarginRate": "0.05",
        //         "initRate": "0.1111"
        //     }
        //
        // cross
        //
        //     {
        //         "tier": "1",
        //         "leverage": "3",
        //         "coin": "BTC",
        //         "maxBorrowableAmount": "26",
        //         "maintainMarginRate": "0.1"
        //     }
        //
        // uta
        //
        //     {
        //         "tier": "1",
        //         "minTierValue": "0",
        //         "maxTierValue": "150000",
        //         "leverage": "125",
        //         "mmr": "0.004"
        //     }
        //
        object tiers = new List<object>() {};
        object minNotional = 0;
        for (object i = 0; isLessThan(i, getArrayLength(info)); postFixIncrement(ref i))
        {
            object item = getValue(info, i);
            object minimumNotional = this.safeNumber2(item, "startUnit", "minTierValue");
            if (isTrue(!isEqual(minimumNotional, null)))
            {
                minNotional = minimumNotional;
            }
            object maxNotional = this.safeNumberN(item, new List<object>() {"endUnit", "maxBorrowableAmount", "baseMaxBorrowableAmount", "maxTierValue"});
            object marginCurrency = this.safeString2(item, "coin", "baseCoin");
            object currencyId = ((bool) isTrue((!isEqual(marginCurrency, null)))) ? marginCurrency : getValue(market, "base");
            object marketId = this.safeString(item, "symbol");
            ((IList<object>)tiers).Add(new Dictionary<string, object>() {
                { "tier", this.safeInteger2(item, "level", "tier") },
                { "symbol", this.safeSymbol(marketId, market) },
                { "currency", this.safeCurrencyCode(currencyId) },
                { "minNotional", minNotional },
                { "maxNotional", maxNotional },
                { "maintenanceMarginRate", this.safeNumberN(item, new List<object>() {"keepMarginRate", "maintainMarginRate", "mmr"}) },
                { "maxLeverage", this.safeNumber(item, "leverage") },
                { "info", item },
            });
            minNotional = maxNotional;
        }
        return tiers;
    }

    /**
     * @method
     * @name bitget#fetchDeposits
     * @description fetch all deposits made to an account
     * @see https://www.bitget.com/api-doc/spot/account/Get-Deposit-Record
     * @param {string} code unified currency code
     * @param {int} [since] the earliest time in ms to fetch deposits for
     * @param {int} [limit] the maximum number of deposits structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {int} [params.until] end time in milliseconds
     * @param {string} [params.idLessThan] return records with id less than the provided value
     * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [available parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
     * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/?id=transaction-structure}
     */
    public async override Task<object> fetchDeposits(object code = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object paginate = false;
        var paginateparametersVariable = this.handleOptionAndParams(parameters, "fetchDeposits", "paginate");
        paginate = ((IList<object>)paginateparametersVariable)[0];
        parameters = ((IList<object>)paginateparametersVariable)[1];
        if (isTrue(paginate))
        {
            return await this.fetchPaginatedCallCursor("fetchDeposits", null, since, limit, parameters, "idLessThan", "idLessThan", null, 100);
        }
        if (isTrue(isEqual(since, null)))
        {
            since = subtract(this.milliseconds(), 7776000000); // 90 days
        }
        object request = new Dictionary<string, object>() {
            { "startTime", since },
            { "endTime", this.milliseconds() },
        };
        object currency = null;
        if (isTrue(!isEqual(code, null)))
        {
            currency = this.currency(code);
            ((IDictionary<string,object>)request)["coin"] = getValue(currency, "id");
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        var requestparametersVariable = this.handleUntilOption("endTime", request, parameters);
        request = ((IList<object>)requestparametersVariable)[0];
        parameters = ((IList<object>)requestparametersVariable)[1];
        object response = await this.privateSpotGetV2SpotWalletDepositRecords(this.extend(request, parameters));
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1700528340608,
        //         "data": [
        //             {
        //                 "orderId": "1083832260799930368",
        //                 "tradeId": "35bf0e588a42b25c71a9d45abe7308cabdeec6b7b423910b9bd4743d3a9a9efa",
        //                 "coin": "BTC",
        //                 "type": "deposit",
        //                 "size": "0.00030000",
        //                 "status": "success",
        //                 "toAddress": "1BfZh7JESJGBUszCGeZnzxbVVvBycbJSbA",
        //                 "dest": "on_chain",
        //                 "chain": "BTC",
        //                 "fromAddress": null,
        //                 "cTime": "1694131668281",
        //                 "uTime": "1694131680247"
        //             }
        //         ]
        //     }
        //
        object rawTransactions = this.safeList(response, "data", new List<object>() {});
        return this.parseTransactions(rawTransactions, null, since, limit);
    }

    /**
     * @method
     * @name bitget#withdraw
     * @description make a withdrawal
     * @see https://www.bitget.com/api-doc/spot/account/Wallet-Withdrawal
     * @param {string} code unified currency code
     * @param {float} amount the amount to withdraw
     * @param {string} address the address to withdraw to
     * @param {string} tag
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.chain] the blockchain network the withdrawal is taking place on
     * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/?id=transaction-structure}
     */
    public async override Task<object> withdraw(object code, object amount, object address, object tag = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        this.checkAddress(address);
        object networkCode = null;
        var networkCodeparametersVariable = this.handleNetworkCodeAndParams(parameters);
        networkCode = ((IList<object>)networkCodeparametersVariable)[0];
        parameters = ((IList<object>)networkCodeparametersVariable)[1];
        if (isTrue(isEqual(networkCode, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " withdraw() requires a \"network\" parameter")) ;
        }
        await this.loadMarkets();
        object currency = this.currency(code);
        object networkId = this.networkCodeToId(networkCode);
        object request = new Dictionary<string, object>() {
            { "coin", getValue(currency, "id") },
            { "address", address },
            { "chain", networkId },
            { "size", this.currencyToPrecision(code, amount, networkCode) },
            { "transferType", "on_chain" },
        };
        if (isTrue(!isEqual(tag, null)))
        {
            ((IDictionary<string,object>)request)["tag"] = tag;
        }
        object response = await this.privateSpotPostV2SpotWalletWithdrawal(this.extend(request, parameters));
        //
        //     {
        //          "code":"00000",
        //          "msg":"success",
        //          "requestTime":1696784219602,
        //          "data": {
        //              "orderId":"1094957867615789056",
        //              "clientOid":"64f1e4ce842041d296b4517df1b5c2d7"
        //          }
        //      }
        //
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        object result = this.parseTransaction(data, currency);
        ((IDictionary<string,object>)result)["type"] = "withdrawal";
        object withdrawOptions = this.safeValue(this.options, "withdraw", new Dictionary<string, object>() {});
        object fillResponseFromRequest = this.safeBool(withdrawOptions, "fillResponseFromRequest", true);
        if (isTrue(fillResponseFromRequest))
        {
            ((IDictionary<string,object>)result)["currency"] = code;
            ((IDictionary<string,object>)result)["amount"] = amount;
            ((IDictionary<string,object>)result)["tag"] = tag;
            ((IDictionary<string,object>)result)["address"] = address;
            ((IDictionary<string,object>)result)["addressTo"] = address;
            ((IDictionary<string,object>)result)["network"] = networkCode;
        }
        return result;
    }

    /**
     * @method
     * @name bitget#fetchWithdrawals
     * @description fetch all withdrawals made from an account
     * @see https://www.bitget.com/api-doc/spot/account/Get-Withdraw-Record
     * @param {string} code unified currency code
     * @param {int} [since] the earliest time in ms to fetch withdrawals for
     * @param {int} [limit] the maximum number of withdrawals structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {int} [params.until] end time in milliseconds
     * @param {string} [params.idLessThan] return records with id less than the provided value
     * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [available parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
     * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/?id=transaction-structure}
     */
    public async override Task<object> fetchWithdrawals(object code = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object paginate = false;
        var paginateparametersVariable = this.handleOptionAndParams(parameters, "fetchWithdrawals", "paginate");
        paginate = ((IList<object>)paginateparametersVariable)[0];
        parameters = ((IList<object>)paginateparametersVariable)[1];
        if (isTrue(paginate))
        {
            return await this.fetchPaginatedCallCursor("fetchWithdrawals", null, since, limit, parameters, "idLessThan", "idLessThan", null, 100);
        }
        object currency = null;
        if (isTrue(!isEqual(code, null)))
        {
            currency = this.currency(code);
        }
        if (isTrue(isEqual(since, null)))
        {
            since = subtract(this.milliseconds(), 7776000000); // 90 days
        }
        object request = new Dictionary<string, object>() {
            { "startTime", since },
            { "endTime", this.milliseconds() },
        };
        if (isTrue(!isEqual(currency, null)))
        {
            ((IDictionary<string,object>)request)["coin"] = getValue(currency, "id");
        }
        var requestparametersVariable = this.handleUntilOption("endTime", request, parameters);
        request = ((IList<object>)requestparametersVariable)[0];
        parameters = ((IList<object>)requestparametersVariable)[1];
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        object response = await this.privateSpotGetV2SpotWalletWithdrawalRecords(this.extend(request, parameters));
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1700528340608,
        //         "data": [
        //             {
        //                 "orderId": "1083832260799930368",
        //                 "tradeId": "35bf0e588a42b25c71a9d45abe7308cabdeec6b7b423910b9bd4743d3a9a9efa",
        //                 "clientOid": "123",
        //                 "coin": "BTC",
        //                 "type": "withdraw",
        //                 "size": "0.00030000",
        //                 "fee": "-1.0000000",
        //                 "status": "success",
        //                 "toAddress": "1BfZh7JESJGBUszCGeZnzxbVVvBycbJSbA",
        //                 "dest": "on_chain",
        //                 "chain": "BTC",
        //                 "confirm": "100",
        //                 "fromAddress": null,
        //                 "cTime": "1694131668281",
        //                 "uTime": "1694131680247"
        //             }
        //         ]
        //     }
        //
        object rawTransactions = this.safeList(response, "data", new List<object>() {});
        return this.parseTransactions(rawTransactions, currency, since, limit);
    }

    public override object parseTransaction(object transaction, object currency = null)
    {
        //
        // fetchDeposits
        //
        //     {
        //         "orderId": "1083832260799930368",
        //         "tradeId": "35bf0e588a42b25c71a9d45abe7308cabdeec6b7b423910b9bd4743d3a9a9efa",
        //         "coin": "BTC",
        //         "type": "deposit",
        //         "size": "0.00030000",
        //         "status": "success",
        //         "toAddress": "1BfZh7JESJGBUszCGeZnzxbVVvBycbJSbA",
        //         "dest": "on_chain",
        //         "chain": "BTC",
        //         "fromAddress": null,
        //         "cTime": "1694131668281",
        //         "uTime": "1694131680247"
        //     }
        //
        // fetchWithdrawals
        //
        //     {
        //         "orderId": "1083832260799930368",
        //         "tradeId": "35bf0e588a42b25c71a9d45abe7308cabdeec6b7b423910b9bd4743d3a9a9efa",
        //         "clientOid": "123",
        //         "coin": "BTC",
        //         "type": "withdraw",
        //         "size": "0.00030000",
        //         "fee": "-1.0000000",
        //         "status": "success",
        //         "toAddress": "1BfZh7JESJGBUszCGeZnzxbVVvBycbJSbA",
        //         "dest": "on_chain",
        //         "chain": "BTC",
        //         "confirm": "100",
        //         "fromAddress": null,
        //         "cTime": "1694131668281",
        //         "uTime": "1694131680247"
        //     }
        //
        object currencyId = this.safeString(transaction, "coin");
        object code = this.safeCurrencyCode(currencyId, currency);
        object timestamp = this.safeInteger(transaction, "cTime");
        object networkId = this.safeString(transaction, "chain");
        object status = this.safeString(transaction, "status");
        object tag = this.safeString(transaction, "tag");
        object feeCostString = this.safeString(transaction, "fee");
        object feeCostAbsString = null;
        if (isTrue(!isEqual(feeCostString, null)))
        {
            feeCostAbsString = Precise.stringAbs(feeCostString);
        }
        object fee = null;
        object amountString = this.safeString(transaction, "size");
        if (isTrue(!isEqual(feeCostAbsString, null)))
        {
            fee = new Dictionary<string, object>() {
                { "currency", code },
                { "cost", this.parseNumber(feeCostAbsString) },
            };
            amountString = Precise.stringSub(amountString, feeCostAbsString);
        }
        return new Dictionary<string, object>() {
            { "id", this.safeString(transaction, "orderId") },
            { "info", transaction },
            { "txid", this.safeString(transaction, "tradeId") },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "network", this.networkIdToCode(networkId) },
            { "addressFrom", this.safeString(transaction, "fromAddress") },
            { "address", this.safeString(transaction, "toAddress") },
            { "addressTo", this.safeString(transaction, "toAddress") },
            { "amount", this.parseNumber(amountString) },
            { "type", this.safeString(transaction, "type") },
            { "currency", code },
            { "status", this.parseTransactionStatus(status) },
            { "updated", this.safeInteger(transaction, "uTime") },
            { "tagFrom", null },
            { "tag", tag },
            { "tagTo", tag },
            { "comment", null },
            { "internal", null },
            { "fee", fee },
        };
    }

    public virtual object parseTransactionStatus(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "success", "ok" },
            { "Pending", "pending" },
            { "pending_review", "pending" },
            { "pending_review_fail", "failed" },
            { "reject", "failed" },
        };
        return this.safeString(statuses, status, status);
    }

    /**
     * @method
     * @name bitget#fetchDepositAddress
     * @description fetch the deposit address for a currency associated with this account
     * @see https://www.bitget.com/api-doc/spot/account/Get-Deposit-Address
     * @param {string} code unified currency code
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} an [address structure]{@link https://docs.ccxt.com/?id=address-structure}
     */
    public async override Task<object> fetchDepositAddress(object code, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object networkCode = null;
        var networkCodeparametersVariable = this.handleNetworkCodeAndParams(parameters);
        networkCode = ((IList<object>)networkCodeparametersVariable)[0];
        parameters = ((IList<object>)networkCodeparametersVariable)[1];
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "coin", getValue(currency, "id") },
        };
        if (isTrue(!isEqual(networkCode, null)))
        {
            ((IDictionary<string,object>)request)["chain"] = this.networkCodeToId(networkCode, code);
        }
        object response = await this.privateSpotGetV2SpotWalletDepositAddress(this.extend(request, parameters));
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1700532244807,
        //         "data": {
        //             "coin": "BTC",
        //             "address": "1BfZh7JESJGBUszCGeZnzxbVVvBycbJSbA",
        //             "chain": "",
        //             "tag": null,
        //             "url": "https://blockchair.com/bitcoin/transaction/"
        //         }
        //     }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        return this.parseDepositAddress(data, currency);
    }

    public override object parseDepositAddress(object depositAddress, object currency = null)
    {
        //
        //     {
        //         "coin": "BTC",
        //         "address": "1BfZh7JESJGBUszCGeZnzxbVVvBycbJSbA",
        //         "chain": "",
        //         "tag": null,
        //         "url": "https://blockchair.com/bitcoin/transaction/"
        //     }
        //
        object currencyId = this.safeString(depositAddress, "coin");
        object networkId = this.safeString(depositAddress, "chain");
        object parsedCurrency = this.safeCurrencyCode(currencyId, currency);
        object network = null;
        if (isTrue(!isEqual(networkId, null)))
        {
            network = this.networkIdToCode(networkId, parsedCurrency);
        }
        return new Dictionary<string, object>() {
            { "info", depositAddress },
            { "currency", parsedCurrency },
            { "network", network },
            { "address", this.safeString(depositAddress, "address") },
            { "tag", this.safeString(depositAddress, "tag") },
        };
    }

    /**
     * @method
     * @name bitget#fetchOrderBook
     * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
     * @see https://www.bitget.com/api-doc/spot/market/Get-Orderbook
     * @see https://www.bitget.com/api-doc/contract/market/Get-Merge-Depth
     * @see https://www.bitget.com/api-doc/uta/public/OrderBook
     * @param {string} symbol unified symbol of the market to fetch the order book for
     * @param {int} [limit] the maximum amount of order book entries to return
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {boolean} [params.uta] set to true for the unified trading account (uta), defaults to false
     * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/?id=order-book-structure} indexed by market symbols
     */
    public async override Task<object> fetchOrderBook(object symbol, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        object productType = null;
        var productTypeparametersVariable = this.handleProductTypeAndParams(market, parameters);
        productType = ((IList<object>)productTypeparametersVariable)[0];
        parameters = ((IList<object>)productTypeparametersVariable)[1];
        object response = null;
        object uta = null;
        var utaparametersVariable = this.handleOptionAndParams(parameters, "fetchOrderBook", "uta", false);
        uta = ((IList<object>)utaparametersVariable)[0];
        parameters = ((IList<object>)utaparametersVariable)[1];
        if (isTrue(uta))
        {
            ((IDictionary<string,object>)request)["category"] = productType;
            response = await this.publicUtaGetV3MarketOrderbook(this.extend(request, parameters));
        } else if (isTrue(getValue(market, "spot")))
        {
            response = await this.publicSpotGetV2SpotMarketOrderbook(this.extend(request, parameters));
        } else
        {
            ((IDictionary<string,object>)request)["productType"] = productType;
            response = await this.publicMixGetV2MixMarketMergeDepth(this.extend(request, parameters));
        }
        //
        //     {
        //       "code": "00000",
        //       "msg": "success",
        //       "requestTime": 1645854610294,
        //       "data": {
        //         "asks": [ [ "39102", "11.026" ] ],
        //         "bids": [ [ '39100.5', "1.773" ] ],
        //         "ts": "1645854610294"
        //       }
        //     }
        //
        // uta
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1750329437753,
        //         "data": {
        //             "a": [ [ 104992.60, 0.018411 ] ],
        //             "b":[ [104927.40, 0.229914 ] ],
        //             "ts": "1750329437763"
        //         }
        //     }
        //
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        object bidsKey = ((bool) isTrue(uta)) ? "b" : "bids";
        object asksKey = ((bool) isTrue(uta)) ? "a" : "asks";
        object timestamp = this.safeInteger(data, "ts");
        return this.parseOrderBook(data, getValue(market, "symbol"), timestamp, bidsKey, asksKey);
    }

    public override object parseTicker(object ticker, object market = null)
    {
        //
        //   {
        //       "symbol": "BTCUSDT",
        //       "price": "26242",
        //       "indexPrice": "34867",
        //       "markPrice": "25555",
        //       "ts": "1695793390482"
        //   }
        //
        // spot
        //
        //     {
        //         "open": "37202.46",
        //         "symbol": "BTCUSDT",
        //         "high24h": "37744.75",
        //         "low24h": "36666",
        //         "lastPr": "37583.69",
        //         "quoteVolume": "519127705.303",
        //         "baseVolume": "13907.0386",
        //         "usdtVolume": "519127705.302908",
        //         "ts": "1700532903261",
        //         "bidPr": "37583.68",
        //         "askPr": "37583.69",
        //         "bidSz": "0.0007",
        //         "askSz": "0.0829",
        //         "openUtc": "37449.4",
        //         "changeUtc24h": "0.00359",
        //         "change24h": "0.00321"
        //     }
        //
        // swap and future
        //
        //     {
        //         "symbol": "BTCUSDT",
        //         "lastPr": "104823.8",
        //         "askPr": "104823.8",
        //         "bidPr": "104823.5",
        //         "bidSz": "0.703",
        //         "askSz": "13.894",
        //         "high24h": "105289.3",
        //         "low24h": "103447.9",
        //         "ts": "1750332210370",
        //         "change24h": "0.00471",
        //         "baseVolume": "79089.5675",
        //         "quoteVolume": "8274870921.80485",
        //         "usdtVolume": "8274870921.80485",
        //         "openUtc": "104833",
        //         "changeUtc24h": "-0.00009",
        //         "indexPrice": "104881.953125",
        //         "fundingRate": "-0.000014",
        //         "holdingAmount": "7452.6421",
        //         "deliveryStartTime": null,
        //         "deliveryTime": null,
        //         "deliveryStatus": "",
        //         "open24h": "104332.3",
        //         "markPrice": "104824.2"
        //     }
        //
        // spot uta
        //
        //     {
        //         "category": "SPOT",
        //         "symbol": "BTCUSDT",
        //         "ts": "1750330651972",
        //         "lastPrice": "104900.2",
        //         "openPrice24h": "104321.2",
        //         "highPrice24h": "107956.8",
        //         "lowPrice24h": "103600.1",
        //         "ask1Price": "104945.8",
        //         "bid1Price": "104880.6",
        //         "bid1Size": "0.266534",
        //         "ask1Size": "0.014001",
        //         "price24hPcnt": "0.00555",
        //         "volume24h": "355.941109",
        //         "turnover24h": "37302936.008134"
        //     }
        //
        // swap and future uta
        //
        //     {
        //         "category": "USDT-FUTURES",
        //         "symbol": "BTCUSDT",
        //         "ts": "1750332730472",
        //         "lastPrice": "104738",
        //         "openPrice24h": "104374",
        //         "highPrice24h": "105289.3",
        //         "lowPrice24h": "103447.9",
        //         "ask1Price": "104738",
        //         "bid1Price": "104737.7",
        //         "bid1Size": "2.036",
        //         "ask1Size": "8.094",
        //         "price24hPcnt": "0.00349",
        //         "volume24h": "79101.6477",
        //         "turnover24h": "8276293391.45973",
        //         "indexPrice": "104785.956168",
        //         "markPrice": "104738",
        //         "fundingRate": "-0.000007",
        //         "openInterest": "7465.5938",
        //         "deliveryStartTime": "",
        //         "deliveryTime": "",
        //         "deliveryStatus": ""
        //     }
        //
        object marketId = this.safeString(ticker, "symbol");
        object close = this.safeString2(ticker, "lastPr", "lastPrice");
        object timestamp = this.safeIntegerOmitZero(ticker, "ts"); // exchange bitget provided 0
        object category = this.safeString(ticker, "category");
        object markPrice = this.safeString(ticker, "markPrice");
        object marketType = null;
        if (isTrue(isTrue((!isEqual(markPrice, null))) && isTrue((!isEqual(category, "SPOT")))))
        {
            marketType = "contract";
        } else
        {
            marketType = "spot";
        }
        object percentage = this.safeString(ticker, "price24hPcnt");
        if (isTrue(isEqual(percentage, null)))
        {
            object change24h = this.safeString(ticker, "change24h");
            percentage = Precise.stringMul(change24h, "100");
        }
        return this.safeTicker(new Dictionary<string, object>() {
            { "symbol", this.safeSymbol(marketId, market, null, marketType) },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "high", this.safeString2(ticker, "high24h", "highPrice24h") },
            { "low", this.safeString2(ticker, "low24h", "lowPrice24h") },
            { "bid", this.safeString2(ticker, "bidPr", "bid1Price") },
            { "bidVolume", this.safeString2(ticker, "bidSz", "bid1Size") },
            { "ask", this.safeString2(ticker, "askPr", "ask1Price") },
            { "askVolume", this.safeString2(ticker, "askSz", "ask1Size") },
            { "vwap", null },
            { "open", this.safeStringN(ticker, new List<object>() {"open", "open24h", "openPrice24h"}) },
            { "close", close },
            { "last", close },
            { "previousClose", null },
            { "change", null },
            { "percentage", percentage },
            { "average", null },
            { "baseVolume", this.safeString2(ticker, "baseVolume", "volume24h") },
            { "quoteVolume", this.safeString2(ticker, "quoteVolume", "turnover24h") },
            { "indexPrice", this.safeString(ticker, "indexPrice") },
            { "markPrice", markPrice },
            { "info", ticker },
        }, market);
    }

    /**
     * @method
     * @name bitget#fetchTicker
     * @description fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
     * @see https://www.bitget.com/api-doc/spot/market/Get-Tickers
     * @see https://www.bitget.com/api-doc/contract/market/Get-Ticker
     * @see https://www.bitget.com/api-doc/uta/public/Tickers
     * @param {string} symbol unified symbol of the market to fetch the ticker for
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {boolean} [params.uta] set to true for the unified trading account (uta), defaults to false
     * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/?id=ticker-structure}
     */
    public async override Task<object> fetchTicker(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object productType = null;
        var productTypeparametersVariable = this.handleProductTypeAndParams(market, parameters);
        productType = ((IList<object>)productTypeparametersVariable)[0];
        parameters = ((IList<object>)productTypeparametersVariable)[1];
        object response = null;
        object uta = null;
        var utaparametersVariable = this.handleOptionAndParams(parameters, "fetchTicker", "uta", false);
        uta = ((IList<object>)utaparametersVariable)[0];
        parameters = ((IList<object>)utaparametersVariable)[1];
        if (isTrue(uta))
        {
            ((IDictionary<string,object>)request)["category"] = productType;
            response = await this.publicUtaGetV3MarketTickers(this.extend(request, parameters));
        } else if (isTrue(getValue(market, "spot")))
        {
            response = await this.publicSpotGetV2SpotMarketTickers(this.extend(request, parameters));
        } else
        {
            ((IDictionary<string,object>)request)["productType"] = productType;
            response = await this.publicMixGetV2MixMarketTicker(this.extend(request, parameters));
        }
        //
        // spot
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1700532903782,
        //         "data": [
        //             {
        //                 "open": "37202.46",
        //                 "symbol": "BTCUSDT",
        //                 "high24h": "37744.75",
        //                 "low24h": "36666",
        //                 "lastPr": "37583.69",
        //                 "quoteVolume": "519127705.303",
        //                 "baseVolume": "13907.0386",
        //                 "usdtVolume": "519127705.302908",
        //                 "ts": "1700532903261",
        //                 "bidPr": "37583.68",
        //                 "askPr": "37583.69",
        //                 "bidSz": "0.0007",
        //                 "askSz": "0.0829",
        //                 "openUtc": "37449.4",
        //                 "changeUtc24h": "0.00359",
        //                 "change24h": "0.00321"
        //             }
        //         ]
        //     }
        //
        // swap and future
        //
        //      {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1750332210369,
        //         "data": [
        //             {
        //                 "symbol": "BTCUSDT",
        //                 "lastPr": "104823.8",
        //                 "askPr": "104823.8",
        //                 "bidPr": "104823.5",
        //                 "bidSz": "0.703",
        //                 "askSz": "13.894",
        //                 "high24h": "105289.3",
        //                 "low24h": "103447.9",
        //                 "ts": "1750332210370",
        //                 "change24h": "0.00471",
        //                 "baseVolume": "79089.5675",
        //                 "quoteVolume": "8274870921.80485",
        //                 "usdtVolume": "8274870921.80485",
        //                 "openUtc": "104833",
        //                 "changeUtc24h": "-0.00009",
        //                 "indexPrice": "104881.953125",
        //                 "fundingRate": "-0.000014",
        //                 "holdingAmount": "7452.6421",
        //                 "deliveryStartTime": null,
        //                 "deliveryTime": null,
        //                 "deliveryStatus": "",
        //                 "open24h": "104332.3",
        //                 "markPrice": "104824.2"
        //             }
        //         ]
        //     }
        //
        // spot uta
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1750330653575,
        //         "data": [
        //             {
        //                 "category": "SPOT",
        //                 "symbol": "BTCUSDT",
        //                 "ts": "1750330651972",
        //                 "lastPrice": "104900.2",
        //                 "openPrice24h": "104321.2",
        //                 "highPrice24h": "107956.8",
        //                 "lowPrice24h": "103600.1",
        //                 "ask1Price": "104945.8",
        //                 "bid1Price": "104880.6",
        //                 "bid1Size": "0.266534",
        //                 "ask1Size": "0.014001",
        //                 "price24hPcnt": "0.00555",
        //                 "volume24h": "355.941109",
        //                 "turnover24h": "37302936.008134"
        //             }
        //         ]
        //     }
        //
        // swap and future uta
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1750332731203,
        //         "data": [
        //             {
        //                 "category": "USDT-FUTURES",
        //                 "symbol": "BTCUSDT",
        //                 "ts": "1750332730472",
        //                 "lastPrice": "104738",
        //                 "openPrice24h": "104374",
        //                 "highPrice24h": "105289.3",
        //                 "lowPrice24h": "103447.9",
        //                 "ask1Price": "104738",
        //                 "bid1Price": "104737.7",
        //                 "bid1Size": "2.036",
        //                 "ask1Size": "8.094",
        //                 "price24hPcnt": "0.00349",
        //                 "volume24h": "79101.6477",
        //                 "turnover24h": "8276293391.45973",
        //                 "indexPrice": "104785.956168",
        //                 "markPrice": "104738",
        //                 "fundingRate": "-0.000007",
        //                 "openInterest": "7465.5938",
        //                 "deliveryStartTime": "",
        //                 "deliveryTime": "",
        //                 "deliveryStatus": ""
        //             }
        //         ]
        //     }
        //
        object data = this.safeList(response, "data", new List<object>() {});
        return this.parseTicker(getValue(data, 0), market);
    }

    /**
     * @method
     * @name bitget#fetchMarkPrice
     * @description fetches the mark price for a specific market
     * @see https://www.bitget.com/api-doc/contract/market/Get-Symbol-Price
     * @param {string} symbol unified symbol of the market to fetch the ticker for
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/?id=ticker-structure}
     */
    public async override Task<object> fetchMarkPrice(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object response = null;
        if (isTrue(getValue(market, "spot")))
        {
            throw new NotSupported ((string)add(this.id, " fetchMarkPrice() is not supported for spot markets")) ;
        } else
        {
            object productType = null;
            var productTypeparametersVariable = this.handleProductTypeAndParams(market, parameters);
            productType = ((IList<object>)productTypeparametersVariable)[0];
            parameters = ((IList<object>)productTypeparametersVariable)[1];
            ((IDictionary<string,object>)request)["productType"] = productType;
            response = await this.publicMixGetV2MixMarketSymbolPrice(this.extend(request, parameters));
        }
        object data = this.safeList(response, "data", new List<object>() {});
        return this.parseTicker(getValue(data, 0), market);
    }

    /**
     * @method
     * @name bitget#fetchTickers
     * @description fetches price tickers for multiple markets, statistical information calculated over the past 24 hours for each market
     * @see https://www.bitget.com/api-doc/spot/market/Get-Tickers
     * @see https://www.bitget.com/api-doc/contract/market/Get-All-Symbol-Ticker
     * @see https://www.bitget.com/api-doc/uta/public/Tickers
     * @param {string[]|undefined} symbols unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {boolean} [params.uta] set to true for the unified trading account (uta), defaults to false
     * @param {string} [params.subType] *contract only* 'linear', 'inverse'
     * @param {string} [params.productType] *contract only* 'USDT-FUTURES', 'USDC-FUTURES', 'COIN-FUTURES', 'SUSDT-FUTURES', 'SUSDC-FUTURES' or 'SCOIN-FUTURES'
     * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/?id=ticker-structure}
     */
    public async override Task<object> fetchTickers(object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = null;
        if (isTrue(!isEqual(symbols, null)))
        {
            object symbol = this.safeValue(symbols, 0);
            market = this.market(symbol);
        }
        object response = null;
        object request = new Dictionary<string, object>() {};
        object type = null;
        var typeparametersVariable = this.handleMarketTypeAndParams("fetchTickers", market, parameters);
        type = ((IList<object>)typeparametersVariable)[0];
        parameters = ((IList<object>)typeparametersVariable)[1];
        // Calls like `.fetchTickers (undefined, {subType:'inverse'})` should be supported for this exchange, so
        // as "options.defaultSubType" is also set in exchange options, we should consider `params.subType`
        // with higher priority and only default to spot, if `subType` is not set in params
        object passedSubType = this.safeString(parameters, "subType");
        object productType = null;
        var productTypeparametersVariable = this.handleProductTypeAndParams(market, parameters);
        productType = ((IList<object>)productTypeparametersVariable)[0];
        parameters = ((IList<object>)productTypeparametersVariable)[1];
        // only if passedSubType && productType is undefined, then use spot
        object uta = null;
        var utaparametersVariable = this.handleOptionAndParams(parameters, "fetchTickers", "uta", false);
        uta = ((IList<object>)utaparametersVariable)[0];
        parameters = ((IList<object>)utaparametersVariable)[1];
        if (isTrue(uta))
        {
            object symbolsLength = getArrayLength(symbols);
            if (isTrue(isTrue((!isEqual(symbols, null))) && isTrue((isEqual(symbolsLength, 1)))))
            {
                ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
            }
            ((IDictionary<string,object>)request)["category"] = productType;
            response = await this.publicUtaGetV3MarketTickers(this.extend(request, parameters));
        } else if (isTrue(isTrue(isEqual(type, "spot")) && isTrue(isEqual(passedSubType, null))))
        {
            response = await this.publicSpotGetV2SpotMarketTickers(this.extend(request, parameters));
        } else
        {
            ((IDictionary<string,object>)request)["productType"] = productType;
            response = await this.publicMixGetV2MixMarketTickers(this.extend(request, parameters));
        }
        //
        // spot
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1700532903782,
        //         "data": [
        //             {
        //                 "open": "37202.46",
        //                 "symbol": "BTCUSDT",
        //                 "high24h": "37744.75",
        //                 "low24h": "36666",
        //                 "lastPr": "37583.69",
        //                 "quoteVolume": "519127705.303",
        //                 "baseVolume": "13907.0386",
        //                 "usdtVolume": "519127705.302908",
        //                 "ts": "1700532903261",
        //                 "bidPr": "37583.68",
        //                 "askPr": "37583.69",
        //                 "bidSz": "0.0007",
        //                 "askSz": "0.0829",
        //                 "openUtc": "37449.4",
        //                 "changeUtc24h": "0.00359",
        //                 "change24h": "0.00321"
        //             }
        //         ]
        //     }
        //
        // swap and future
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1700533773477,
        //         "data": [
        //             {
        //                 "open": "14.9776",
        //                 "symbol": "LINKUSDT",
        //                 "high24h": "15.3942",
        //                 "low24h": "14.3457",
        //                 "lastPr": "14.3748",
        //                 "quoteVolume": "7008612.4299",
        //                 "baseVolume": "469908.8523",
        //                 "usdtVolume": "7008612.42986561",
        //                 "ts": "1700533772309",
        //                 "bidPr": "14.375",
        //                 "askPr": "14.3769",
        //                 "bidSz": "50.004",
        //                 "askSz": "0.7647",
        //                 "openUtc": "14.478",
        //                 "changeUtc24h": "-0.00713",
        //                 "change24h": "-0.04978"
        //             },
        //         ]
        //     }
        //
        // spot uta
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1750330653575,
        //         "data": [
        //             {
        //                 "category": "SPOT",
        //                 "symbol": "BTCUSDT",
        //                 "ts": "1750330651972",
        //                 "lastPrice": "104900.2",
        //                 "openPrice24h": "104321.2",
        //                 "highPrice24h": "107956.8",
        //                 "lowPrice24h": "103600.1",
        //                 "ask1Price": "104945.8",
        //                 "bid1Price": "104880.6",
        //                 "bid1Size": "0.266534",
        //                 "ask1Size": "0.014001",
        //                 "price24hPcnt": "0.00555",
        //                 "volume24h": "355.941109",
        //                 "turnover24h": "37302936.008134"
        //             }
        //         ]
        //     }
        //
        // swap and future uta
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1750332731203,
        //         "data": [
        //             {
        //                 "category": "USDT-FUTURES",
        //                 "symbol": "BTCUSDT",
        //                 "ts": "1750332730472",
        //                 "lastPrice": "104738",
        //                 "openPrice24h": "104374",
        //                 "highPrice24h": "105289.3",
        //                 "lowPrice24h": "103447.9",
        //                 "ask1Price": "104738",
        //                 "bid1Price": "104737.7",
        //                 "bid1Size": "2.036",
        //                 "ask1Size": "8.094",
        //                 "price24hPcnt": "0.00349",
        //                 "volume24h": "79101.6477",
        //                 "turnover24h": "8276293391.45973",
        //                 "indexPrice": "104785.956168",
        //                 "markPrice": "104738",
        //                 "fundingRate": "-0.000007",
        //                 "openInterest": "7465.5938",
        //                 "deliveryStartTime": "",
        //                 "deliveryTime": "",
        //                 "deliveryStatus": ""
        //             }
        //         ]
        //     }
        //
        object data = this.safeList(response, "data", new List<object>() {});
        return this.parseTickers(data, symbols);
    }

    public override object parseTrade(object trade, object market = null)
    {
        //
        // spot, swap and future: fetchTrades
        //
        //     {
        //         "tradeId": "1075199767891652609",
        //         "price": "29376.5",
        //         "size": "6.035",
        //         "side": "Buy",
        //         "ts": "1692073521000",
        //         "symbol": "BTCUSDT"
        //     }
        //
        // spot: fetchMyTrades
        //
        //     {
        //         "userId": "7264631750",
        //         "symbol": "BTCUSDT",
        //         "orderId": "1098394344925597696",
        //         "tradeId": "1098394344974925824",
        //         "orderType": "market",
        //         "side": "sell",
        //         "priceAvg": "28467.68",
        //         "size": "0.0002",
        //         "amount": "5.693536",
        //         "feeDetail": {
        //             "deduction": "no",
        //             "feeCoin": "USDT",
        //             "totalDeductionFee": "",
        //             "totalFee": "-0.005693536"
        //         },
        //         "tradeScope": "taker",
        //         "cTime": "1697603539699",
        //         "uTime": "1697603539754"
        //     }
        //
        // spot margin: fetchMyTrades
        //
        //     {
        //         "orderId": "1099353730455318528",
        //         "tradeId": "1099353730627092481",
        //         "orderType": "market",
        //         "side": "sell",
        //         "priceAvg": "29543.7",
        //         "size": "0.0001",
        //         "amount": "2.95437",
        //         "tradeScope": "taker",
        //         "feeDetail": {
        //             "deduction": "no",
        //             "feeCoin": "USDT",
        //             "totalDeductionFee": "0",
        //             "totalFee": "-0.00295437"
        //         },
        //         "cTime": "1697832275063",
        //         "uTime": "1697832275150"
        //     }
        //
        // swap and future: fetchMyTrades
        //
        //     {
        //         "tradeId": "1111468664328269825",
        //         "symbol": "BTCUSDT",
        //         "orderId": "1111468664264753162",
        //         "price": "37271.4",
        //         "baseVolume": "0.001",
        //         "feeDetail": [
        //             {
        //                 "deduction": "no",
        //                 "feeCoin": "USDT",
        //                 "totalDeductionFee": null,
        //                 "totalFee": "-0.02236284"
        //             }
        //         ],
        //         "side": "buy",
        //         "quoteVolume": "37.2714",
        //         "profit": "-0.0007",
        //         "enterPointSource": "web",
        //         "tradeSide": "close",
        //         "posMode": "hedge_mode",
        //         "tradeScope": "taker",
        //         "cTime": "1700720700342"
        //     }
        //
        // uta fetchTrades
        //
        //     {
        //         "execId": "1319896716324937729",
        //         "price": "105909.1",
        //         "size": "6.3090",
        //         "side": "sell",
        //         "ts": "1750413820344"
        //     }
        //
        // uta fetchMyTrades
        //
        //     {
        //         "execId": "1322441401010528257",
        //         "orderId": "1322441400976261120",
        //         "category": "USDT-FUTURES",
        //         "symbol": "BTCUSDT",
        //         "orderType": "market",
        //         "side": "sell",
        //         "execPrice": "107005.4",
        //         "execQty": "0.0001",
        //         "execValue": "10.7005",
        //         "tradeScope": "taker",
        //         "feeDetail": [{
        //             "feeCoin": "USDT",
        //             "fee":"0.00642032"
        //         }],
        //         "createdTime": "1751020520451",
        //         "updatedTime": "1751020520458",
        //         "execPnl": "0.00017"
        //     }
        //
        object marketId = this.safeString(trade, "symbol");
        object symbol = this.safeSymbol(marketId, market);
        object timestamp = this.safeIntegerN(trade, new List<object>() {"cTime", "ts", "createdTime"});
        object fee = null;
        object feeDetail = this.safeValue(trade, "feeDetail");
        object posMode = this.safeString(trade, "posMode");
        object category = this.safeString(trade, "category");
        object isFeeStructure = isTrue((!isEqual(posMode, null))) || isTrue((!isEqual(category, null)));
        object feeStructure = ((bool) isTrue(isFeeStructure)) ? getValue(feeDetail, 0) : feeDetail;
        if (isTrue(!isEqual(feeStructure, null)))
        {
            object currencyCode = this.safeCurrencyCode(this.safeString(feeStructure, "feeCoin"));
            fee = new Dictionary<string, object>() {
                { "currency", currencyCode },
            };
            object feeCostString = this.safeString2(feeStructure, "totalFee", "fee");
            object deduction = ((bool) isTrue(isEqual(this.safeString(feeStructure, "deduction"), "yes"))) ? true : false;
            if (isTrue(deduction))
            {
                ((IDictionary<string,object>)fee)["cost"] = feeCostString;
            } else
            {
                ((IDictionary<string,object>)fee)["cost"] = Precise.stringNeg(feeCostString);
            }
        }
        return this.safeTrade(new Dictionary<string, object>() {
            { "info", trade },
            { "id", this.safeString2(trade, "tradeId", "execId") },
            { "order", this.safeString(trade, "orderId") },
            { "symbol", symbol },
            { "side", this.safeStringLower(trade, "side") },
            { "type", this.safeString(trade, "orderType") },
            { "takerOrMaker", this.safeString(trade, "tradeScope") },
            { "price", this.safeStringN(trade, new List<object>() {"priceAvg", "price", "execPrice"}) },
            { "amount", this.safeStringN(trade, new List<object>() {"baseVolume", "size", "execQty"}) },
            { "cost", this.safeStringN(trade, new List<object>() {"quoteVolume", "amount", "execValue"}) },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "fee", fee },
        }, market);
    }

    /**
     * @method
     * @name bitget#fetchTrades
     * @description get the list of most recent trades for a particular symbol
     * @see https://www.bitget.com/api-doc/spot/market/Get-Recent-Trades
     * @see https://www.bitget.com/api-doc/spot/market/Get-Market-Trades
     * @see https://www.bitget.com/api-doc/contract/market/Get-Recent-Fills
     * @see https://www.bitget.com/api-doc/contract/market/Get-Fills-History
     * @see https://www.bitget.com/api-doc/uta/public/Fills
     * @param {string} symbol unified symbol of the market to fetch trades for
     * @param {int} [since] timestamp in ms of the earliest trade to fetch
     * @param {int} [limit] the maximum amount of trades to fetch
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {boolean} [params.uta] set to true for the unified trading account (uta), defaults to false
     * @param {int} [params.until] *only applies to publicSpotGetV2SpotMarketFillsHistory and publicMixGetV2MixMarketFillsHistory* the latest time in ms to fetch trades for
     * @param {boolean} [params.paginate] *only applies to publicSpotGetV2SpotMarketFillsHistory and publicMixGetV2MixMarketFillsHistory* default false, when true will automatically paginate by calling this endpoint multiple times
     * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/?id=public-trades}
     */
    public async override Task<object> fetchTrades(object symbol, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object paginate = false;
        var paginateparametersVariable = this.handleOptionAndParams(parameters, "fetchTrades", "paginate");
        paginate = ((IList<object>)paginateparametersVariable)[0];
        parameters = ((IList<object>)paginateparametersVariable)[1];
        if (isTrue(paginate))
        {
            return await this.fetchPaginatedCallCursor("fetchTrades", symbol, since, limit, parameters, "idLessThan", "idLessThan");
        }
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object uta = null;
        var utaparametersVariable = this.handleOptionAndParams(parameters, "fetchTrades", "uta", false);
        uta = ((IList<object>)utaparametersVariable)[0];
        parameters = ((IList<object>)utaparametersVariable)[1];
        if (isTrue(!isEqual(limit, null)))
        {
            if (isTrue(uta))
            {
                ((IDictionary<string,object>)request)["limit"] = mathMin(limit, 100);
            } else if (isTrue(getValue(market, "contract")))
            {
                ((IDictionary<string,object>)request)["limit"] = mathMin(limit, 1000);
            } else
            {
                ((IDictionary<string,object>)request)["limit"] = limit;
            }
        }
        object options = this.safeValue(this.options, "fetchTrades", new Dictionary<string, object>() {});
        object response = null;
        object productType = null;
        var productTypeparametersVariable = this.handleProductTypeAndParams(market, parameters);
        productType = ((IList<object>)productTypeparametersVariable)[0];
        parameters = ((IList<object>)productTypeparametersVariable)[1];
        if (isTrue(uta))
        {
            if (isTrue(isEqual(productType, "SPOT")))
            {
                object marginMode = null;
                var marginModeparametersVariable = this.handleMarginModeAndParams("fetchTrades", parameters);
                marginMode = ((IList<object>)marginModeparametersVariable)[0];
                parameters = ((IList<object>)marginModeparametersVariable)[1];
                if (isTrue(!isEqual(marginMode, null)))
                {
                    productType = "MARGIN";
                }
            }
            ((IDictionary<string,object>)request)["category"] = productType;
            response = await this.publicUtaGetV3MarketFills(this.extend(request, parameters));
        } else if (isTrue(getValue(market, "spot")))
        {
            object spotOptions = this.safeValue(options, "spot", new Dictionary<string, object>() {});
            object defaultSpotMethod = this.safeString(spotOptions, "method", "publicSpotGetV2SpotMarketFillsHistory");
            object spotMethod = this.safeString(parameters, "method", defaultSpotMethod);
            parameters = this.omit(parameters, "method");
            if (isTrue(isEqual(spotMethod, "publicSpotGetV2SpotMarketFillsHistory")))
            {
                var requestparametersVariable = this.handleUntilOption("endTime", request, parameters);
                request = ((IList<object>)requestparametersVariable)[0];
                parameters = ((IList<object>)requestparametersVariable)[1];
                if (isTrue(!isEqual(since, null)))
                {
                    ((IDictionary<string,object>)request)["startTime"] = since;
                }
                response = await this.publicSpotGetV2SpotMarketFillsHistory(this.extend(request, parameters));
            } else if (isTrue(isEqual(spotMethod, "publicSpotGetV2SpotMarketFills")))
            {
                response = await this.publicSpotGetV2SpotMarketFills(this.extend(request, parameters));
            }
        } else
        {
            object swapOptions = this.safeValue(options, "swap", new Dictionary<string, object>() {});
            object defaultSwapMethod = this.safeString(swapOptions, "method", "publicMixGetV2MixMarketFillsHistory");
            object swapMethod = this.safeString(parameters, "method", defaultSwapMethod);
            parameters = this.omit(parameters, "method");
            ((IDictionary<string,object>)request)["productType"] = productType;
            if (isTrue(isEqual(swapMethod, "publicMixGetV2MixMarketFillsHistory")))
            {
                var requestparametersVariable = this.handleUntilOption("endTime", request, parameters);
                request = ((IList<object>)requestparametersVariable)[0];
                parameters = ((IList<object>)requestparametersVariable)[1];
                if (isTrue(!isEqual(since, null)))
                {
                    ((IDictionary<string,object>)request)["startTime"] = since;
                }
                response = await this.publicMixGetV2MixMarketFillsHistory(this.extend(request, parameters));
            } else if (isTrue(isEqual(swapMethod, "publicMixGetV2MixMarketFills")))
            {
                response = await this.publicMixGetV2MixMarketFills(this.extend(request, parameters));
            }
        }
        //
        // spot
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1692073693562,
        //         "data": [
        //             {
        //                 "symbol": "BTCUSDT_SPBL",
        //                 "tradeId": "1075200479040323585",
        //                 "side": "Sell",
        //                 "price": "29381.54",
        //                 "size": "0.0056",
        //                 "ts": "1692073691000"
        //             },
        //         ]
        //     }
        //
        // swap
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1692073522689,
        //         "data": [
        //             {
        //                 "tradeId": "1075199767891652609",
        //                 "price": "29376.5",
        //                 "size": "6.035",
        //                 "side": "Buy",
        //                 "ts": "1692073521000",
        //                 "symbol": "BTCUSDT_UMCBL"
        //             },
        //         ]
        //     }
        //
        // uta
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1750413823980,
        //         "data": [
        //             {
        //                 "execId": "1319896716324937729",
        //                 "price": "105909.1",
        //                 "size": "6.3090",
        //                 "side": "sell",
        //                 "ts": "1750413820344"
        //             }
        //         ]
        //     }
        //
        object data = this.safeList(response, "data", new List<object>() {});
        return this.parseTrades(data, market, since, limit);
    }

    /**
     * @method
     * @name bitget#fetchTradingFee
     * @description fetch the trading fees for a market
     * @see https://www.bitget.com/api-doc/common/public/Get-Trade-Rate
     * @param {string} symbol unified market symbol
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.marginMode] 'isolated' or 'cross', for finding the fee rate of spot margin trading pairs
     * @returns {object} a [fee structure]{@link https://docs.ccxt.com/?id=fee-structure}
     */
    public async override Task<object> fetchTradingFee(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object marginMode = null;
        var marginModeparametersVariable = this.handleMarginModeAndParams("fetchTradingFee", parameters);
        marginMode = ((IList<object>)marginModeparametersVariable)[0];
        parameters = ((IList<object>)marginModeparametersVariable)[1];
        if (isTrue(getValue(market, "spot")))
        {
            if (isTrue(!isEqual(marginMode, null)))
            {
                ((IDictionary<string,object>)request)["businessType"] = "margin";
            } else
            {
                ((IDictionary<string,object>)request)["businessType"] = "spot";
            }
        } else
        {
            ((IDictionary<string,object>)request)["businessType"] = "mix";
        }
        object response = await this.privateCommonGetV2CommonTradeRate(this.extend(request, parameters));
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1700549524887,
        //         "data": {
        //             "makerFeeRate": "0.001",
        //             "takerFeeRate": "0.001"
        //         }
        //     }
        //
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        return this.parseTradingFee(data, market);
    }

    /**
     * @method
     * @name bitget#fetchTradingFees
     * @description fetch the trading fees for multiple markets
     * @see https://www.bitget.com/api-doc/spot/market/Get-Symbols
     * @see https://www.bitget.com/api-doc/contract/market/Get-All-Symbols-Contracts
     * @see https://www.bitget.com/api-doc/margin/common/support-currencies
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.productType] *contract only* 'USDT-FUTURES', 'USDC-FUTURES', 'COIN-FUTURES', 'SUSDT-FUTURES', 'SUSDC-FUTURES' or 'SCOIN-FUTURES'
     * @param {boolean} [params.margin] set to true for spot margin
     * @returns {object} a dictionary of [fee structures]{@link https://docs.ccxt.com/?id=fee-structure} indexed by market symbols
     */
    public async override Task<object> fetchTradingFees(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = null;
        object marginMode = null;
        object marketType = null;
        var marginModeparametersVariable = this.handleMarginModeAndParams("fetchTradingFees", parameters);
        marginMode = ((IList<object>)marginModeparametersVariable)[0];
        parameters = ((IList<object>)marginModeparametersVariable)[1];
        var marketTypeparametersVariable = this.handleMarketTypeAndParams("fetchTradingFees", null, parameters);
        marketType = ((IList<object>)marketTypeparametersVariable)[0];
        parameters = ((IList<object>)marketTypeparametersVariable)[1];
        if (isTrue(isEqual(marketType, "spot")))
        {
            object margin = this.safeBool(parameters, "margin", false);
            parameters = this.omit(parameters, "margin");
            if (isTrue(isTrue((!isEqual(marginMode, null))) || isTrue(margin)))
            {
                response = await this.publicMarginGetV2MarginCurrencies(parameters);
            } else
            {
                response = await this.publicSpotGetV2SpotPublicSymbols(parameters);
            }
        } else if (isTrue(isTrue((isEqual(marketType, "swap"))) || isTrue((isEqual(marketType, "future")))))
        {
            object productType = null;
            var productTypeparametersVariable = this.handleProductTypeAndParams(null, parameters);
            productType = ((IList<object>)productTypeparametersVariable)[0];
            parameters = ((IList<object>)productTypeparametersVariable)[1];
            ((IDictionary<string,object>)parameters)["productType"] = productType;
            response = await this.publicMixGetV2MixMarketContracts(parameters);
        } else
        {
            throw new NotSupported ((string)add(add(add(this.id, " does not support "), marketType), " market")) ;
        }
        //
        // spot and margin
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1700102364653,
        //         "data": [
        //             {
        //                 "symbol": "TRXUSDT",
        //                 "baseCoin": "TRX",
        //                 "quoteCoin": "USDT",
        //                 "minTradeAmount": "0",
        //                 "maxTradeAmount": "10000000000",
        //                 "takerFeeRate": "0.002",
        //                 "makerFeeRate": "0.002",
        //                 "pricePrecision": "6",
        //                 "quantityPrecision": "4",
        //                 "quotePrecision": "6",
        //                 "status": "online",
        //                 "minTradeUSDT": "5",
        //                 "buyLimitPriceRatio": "0.05",
        //                 "sellLimitPriceRatio": "0.05"
        //             },
        //         ]
        //     }
        //
        // swap and future
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1700102364709,
        //         "data": [
        //             {
        //                 "symbol": "BTCUSDT",
        //                 "baseCoin": "BTC",
        //                 "quoteCoin": "USDT",
        //                 "buyLimitPriceRatio": "0.01",
        //                 "sellLimitPriceRatio": "0.01",
        //                 "feeRateUpRatio": "0.005",
        //                 "makerFeeRate": "0.0002",
        //                 "takerFeeRate": "0.0006",
        //                 "openCostUpRatio": "0.01",
        //                 "supportMarginCoins": ["USDT"],
        //                 "minTradeNum": "0.001",
        //                 "priceEndStep": "1",
        //                 "volumePlace": "3",
        //                 "pricePlace": "1",
        //                 "sizeMultiplier": "0.001",
        //                 "symbolType": "perpetual",
        //                 "minTradeUSDT": "5",
        //                 "maxSymbolOrderNum": "200",
        //                 "maxProductOrderNum": "400",
        //                 "maxPositionNum": "150",
        //                 "symbolStatus": "normal",
        //                 "offTime": "-1",
        //                 "limitOpenTime": "-1",
        //                 "deliveryTime": "",
        //                 "deliveryStartTime": "",
        //                 "deliveryPeriod": "",
        //                 "launchTime": "",
        //                 "fundInterval": "8",
        //                 "minLever": "1",
        //                 "maxLever": "125",
        //                 "posLimit": "0.05",
        //                 "maintainTime": ""
        //             },
        //         ]
        //     }
        //
        object data = this.safeValue(response, "data", new List<object>() {});
        object result = new Dictionary<string, object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
        {
            object entry = getValue(data, i);
            object marketId = this.safeString(entry, "symbol");
            object symbol = this.safeSymbol(marketId, null, null, marketType);
            object market = this.market(symbol);
            object fee = this.parseTradingFee(entry, market);
            ((IDictionary<string,object>)result)[(string)symbol] = fee;
        }
        return result;
    }

    public virtual object parseTradingFee(object data, object market = null)
    {
        object marketId = this.safeString(data, "symbol");
        return new Dictionary<string, object>() {
            { "info", data },
            { "symbol", this.safeSymbol(marketId, market) },
            { "maker", this.safeNumber(data, "makerFeeRate") },
            { "taker", this.safeNumber(data, "takerFeeRate") },
            { "percentage", null },
            { "tierBased", null },
        };
    }

    public override object parseOHLCV(object ohlcv, object market = null)
    {
        //
        //     [
        //         "1645911960000",
        //         "39406",
        //         "39407",
        //         "39374.5",
        //         "39379",
        //         "35.526",
        //         "1399132.341"
        //     ]
        //
        object inverse = this.safeBool(market, "inverse");
        object volumeIndex = ((bool) isTrue(inverse)) ? 6 : 5;
        return new List<object> {this.safeInteger(ohlcv, 0), this.safeNumber(ohlcv, 1), this.safeNumber(ohlcv, 2), this.safeNumber(ohlcv, 3), this.safeNumber(ohlcv, 4), this.safeNumber(ohlcv, volumeIndex)};
    }

    /**
     * @method
     * @name bitget#fetchOHLCV
     * @description fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
     * @see https://www.bitget.com/api-doc/spot/market/Get-Candle-Data
     * @see https://www.bitget.com/api-doc/spot/market/Get-History-Candle-Data
     * @see https://www.bitget.com/api-doc/contract/market/Get-Candle-Data
     * @see https://www.bitget.com/api-doc/contract/market/Get-History-Candle-Data
     * @see https://www.bitget.com/api-doc/contract/market/Get-History-Index-Candle-Data
     * @see https://www.bitget.com/api-doc/contract/market/Get-History-Mark-Candle-Data
     * @see https://www.bitget.com/api-doc/uta/public/Get-Candle-Data
     * @param {string} symbol unified symbol of the market to fetch OHLCV data for
     * @param {string} timeframe the length of time each candle represents
     * @param {int} [since] timestamp in ms of the earliest candle to fetch
     * @param {int} [limit] the maximum amount of candles to fetch
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {boolean} [params.uta] set to true for the unified trading account (uta), defaults to false
     * @param {int} [params.until] timestamp in ms of the latest candle to fetch
     * @param {boolean} [params.useHistoryEndpoint] whether to force to use historical endpoint (it has max limit of 200)
     * @param {boolean} [params.useHistoryEndpointForPagination] whether to force to use historical endpoint for pagination (default true)
     * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [available parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
     * @param {string} [params.price] *swap only* "mark" (to fetch mark price candles) or "index" (to fetch index price candles)
     * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
     */
    public async override Task<object> fetchOHLCV(object symbol, object timeframe = null, object since = null, object limit = null, object parameters = null)
    {
        timeframe ??= "1m";
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object defaultLimit = 100; // default 100, max 1000
        object maxLimitForRecentEndpoint = 1000;
        object maxLimitForHistoryEndpoint = 200; // note, max 1000 bars are supported for "recent-candles" endpoint, but "historical-candles" support only max 200
        object useHistoryEndpoint = this.safeBool(parameters, "useHistoryEndpoint", false);
        object useHistoryEndpointForPagination = this.safeBool(parameters, "useHistoryEndpointForPagination", true);
        object paginate = false;
        var paginateparametersVariable = this.handleOptionAndParams(parameters, "fetchOHLCV", "paginate");
        paginate = ((IList<object>)paginateparametersVariable)[0];
        parameters = ((IList<object>)paginateparametersVariable)[1];
        if (isTrue(paginate))
        {
            object limitForPagination = ((bool) isTrue(useHistoryEndpointForPagination)) ? maxLimitForHistoryEndpoint : maxLimitForRecentEndpoint;
            return await this.fetchPaginatedCallDeterministic("fetchOHLCV", symbol, since, limit, timeframe, parameters, limitForPagination);
        }
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object marketType = null;
        object timeframes = null;
        object uta = null;
        var utaparametersVariable = this.handleOptionAndParams(parameters, "fetchOHLCV", "uta", false);
        uta = ((IList<object>)utaparametersVariable)[0];
        parameters = ((IList<object>)utaparametersVariable)[1];
        if (isTrue(uta))
        {
            timeframes = getValue(getValue(this.options, "timeframes"), "uta");
            ((IDictionary<string,object>)request)["interval"] = this.safeString(timeframes, timeframe, timeframe);
        } else
        {
            marketType = ((bool) isTrue(getValue(market, "spot"))) ? "spot" : "swap";
            timeframes = getValue(getValue(this.options, "timeframes"), marketType);
            ((IDictionary<string,object>)request)["granularity"] = this.safeString(timeframes, timeframe, timeframe);
        }
        object msInDay = 86400000;
        object now = this.milliseconds();
        object duration = multiply(this.parseTimeframe(timeframe), 1000);
        object until = this.safeInteger(parameters, "until");
        object limitDefined = !isEqual(limit, null);
        object sinceDefined = !isEqual(since, null);
        object untilDefined = !isEqual(until, null);
        parameters = this.omit(parameters, new List<object>() {"until"});
        // retrievable periods listed here:
        // - https://www.bitget.com/api-doc/spot/market/Get-Candle-Data#request-parameters
        // - https://www.bitget.com/api-doc/contract/market/Get-Candle-Data#description
        object key = ((bool) isTrue(getValue(market, "spot"))) ? "spot" : "swap";
        object ohlcOptions = this.safeDict(getValue(this.options, "fetchOHLCV"), key, new Dictionary<string, object>() {});
        object maxLimitPerTimeframe = this.safeDict(ohlcOptions, "maxLimitPerTimeframe", new Dictionary<string, object>() {});
        object maxLimitForThisTimeframe = this.safeInteger(maxLimitPerTimeframe, timeframe, limit);
        object recentEndpointDaysMap = this.safeDict(getValue(this.options, "fetchOHLCV"), "maxRecentDaysPerTimeframe", new Dictionary<string, object>() {});
        object recentEndpointAvailableDays = this.safeInteger(recentEndpointDaysMap, timeframe);
        object recentEndpointBoundaryTs = subtract(now, multiply((subtract(recentEndpointAvailableDays, 1)), msInDay));
        if (isTrue(limitDefined))
        {
            limit = mathMin(limit, maxLimitForRecentEndpoint);
            limit = mathMin(limit, maxLimitForThisTimeframe);
        } else
        {
            limit = defaultLimit;
        }
        object limitMultipliedDuration = multiply(limit, duration);
        // exchange aligns from endTime, so it's important, not startTime
        // startTime is supported only on "recent" endpoint, not on "historical" endpoint
        object calculatedStartTime = null;
        object calculatedEndTime = null;
        if (isTrue(sinceDefined))
        {
            calculatedStartTime = since;
            ((IDictionary<string,object>)request)["startTime"] = since;
            if (!isTrue(untilDefined))
            {
                calculatedEndTime = this.sum(calculatedStartTime, limitMultipliedDuration);
                if (isTrue(isGreaterThan(calculatedEndTime, now)))
                {
                    calculatedEndTime = now;
                }
                ((IDictionary<string,object>)request)["endTime"] = calculatedEndTime;
            }
        }
        if (isTrue(untilDefined))
        {
            calculatedEndTime = until;
            if (isTrue(isGreaterThan(calculatedEndTime, now)))
            {
                calculatedEndTime = now;
            }
            ((IDictionary<string,object>)request)["endTime"] = calculatedEndTime;
            if (!isTrue(sinceDefined))
            {
                calculatedStartTime = subtract(calculatedEndTime, limitMultipliedDuration);
            }
        }
        // if historical endpoint is needed, we should re-set the variables
        object historicalEndpointNeeded = false;
        if (isTrue(isTrue((isTrue(!isEqual(calculatedStartTime, null)) && isTrue(isLessThanOrEqual(calculatedStartTime, recentEndpointBoundaryTs)))) || isTrue(useHistoryEndpoint)))
        {
            historicalEndpointNeeded = true;
            // only for "historical-candles" - ensure we use correct max limit
            limit = mathMin(limit, maxLimitForHistoryEndpoint);
            limitMultipliedDuration = multiply(limit, duration);
            calculatedStartTime = subtract(calculatedEndTime, limitMultipliedDuration);
            ((IDictionary<string,object>)request)["startTime"] = calculatedStartTime;
            // for contract, maximum 90 days allowed between start-end times
            if (!isTrue(getValue(market, "spot")))
            {
                object maxDistanceDaysForContracts = 90;
                // only correct if request is larger
                if (isTrue(isGreaterThan(subtract(calculatedEndTime, calculatedStartTime), multiply(maxDistanceDaysForContracts, msInDay))))
                {
                    calculatedEndTime = this.sum(calculatedStartTime, multiply(maxDistanceDaysForContracts, msInDay));
                    ((IDictionary<string,object>)request)["endTime"] = calculatedEndTime;
                }
            }
        }
        // we need to set limit to safely cover the period
        ((IDictionary<string,object>)request)["limit"] = limit;
        // make request
        object response = null;
        object productType = null;
        object priceType = null;
        var priceTypeparametersVariable = this.handleParamString(parameters, "price");
        priceType = ((IList<object>)priceTypeparametersVariable)[0];
        parameters = ((IList<object>)priceTypeparametersVariable)[1];
        var productTypeparametersVariable = this.handleProductTypeAndParams(market, parameters);
        productType = ((IList<object>)productTypeparametersVariable)[0];
        parameters = ((IList<object>)productTypeparametersVariable)[1];
        if (isTrue(uta))
        {
            if (isTrue(!isEqual(priceType, null)))
            {
                if (isTrue(isEqual(priceType, "mark")))
                {
                    ((IDictionary<string,object>)request)["type"] = "MARK";
                } else if (isTrue(isEqual(priceType, "index")))
                {
                    ((IDictionary<string,object>)request)["type"] = "INDEX";
                }
            }
            ((IDictionary<string,object>)request)["category"] = productType;
            response = await this.publicUtaGetV3MarketCandles(this.extend(request, parameters));
        } else if (isTrue(getValue(market, "spot")))
        {
            // checks if we need history endpoint
            if (isTrue(historicalEndpointNeeded))
            {
                response = await this.publicSpotGetV2SpotMarketHistoryCandles(this.extend(request, parameters));
            } else
            {
                if (!isTrue(limitDefined))
                {
                    ((IDictionary<string,object>)request)["limit"] = 1000;
                    limit = 1000;
                }
                response = await this.publicSpotGetV2SpotMarketCandles(this.extend(request, parameters));
            }
        } else
        {
            ((IDictionary<string,object>)request)["productType"] = productType;
            object extended = this.extend(request, parameters);
            if (isTrue(!isTrue(historicalEndpointNeeded) && isTrue((isTrue(isEqual(priceType, "mark")) || isTrue(isEqual(priceType, "index"))))))
            {
                if (!isTrue(limitDefined))
                {
                    ((IDictionary<string,object>)extended)["limit"] = 1000;
                    limit = 1000;
                }
                // Recent endpoint for mark/index prices
                // https://www.bitget.com/api-doc/contract/market/Get-Candle-Data
                response = await this.publicMixGetV2MixMarketCandles(this.extend(new Dictionary<string, object>() {
                    { "kLineType", priceType },
                }, extended));
            } else if (isTrue(isEqual(priceType, "mark")))
            {
                response = await this.publicMixGetV2MixMarketHistoryMarkCandles(extended);
            } else if (isTrue(isEqual(priceType, "index")))
            {
                response = await this.publicMixGetV2MixMarketHistoryIndexCandles(extended);
            } else
            {
                if (isTrue(historicalEndpointNeeded))
                {
                    response = await this.publicMixGetV2MixMarketHistoryCandles(extended);
                } else
                {
                    if (!isTrue(limitDefined))
                    {
                        ((IDictionary<string,object>)extended)["limit"] = 1000;
                        limit = 1000;
                    }
                    response = await this.publicMixGetV2MixMarketCandles(extended);
                }
            }
        }
        if (isTrue(isEqual(response, "")))
        {
            return new List<object>() {};  // happens when a new token is listed
        }
        //  [ ["1645911960000","39406","39407","39374.5","39379","35.526","1399132.341"] ]
        object data = this.safeList(response, "data", response);
        return this.parseOHLCVs(data, market, timeframe, since, limit);
    }

    /**
     * @method
     * @name bitget#fetchBalance
     * @description query for balance and get the amount of funds available for trading or funds locked in orders
     * @see https://www.bitget.com/api-doc/spot/account/Get-Account-Assets
     * @see https://www.bitget.com/api-doc/contract/account/Get-Account-List
     * @see https://www.bitget.com/api-doc/margin/cross/account/Get-Cross-Assets
     * @see https://www.bitget.com/api-doc/margin/isolated/account/Get-Isolated-Assets
     * @see https://bitgetlimited.github.io/apidoc/en/margin/#get-cross-assets
     * @see https://bitgetlimited.github.io/apidoc/en/margin/#get-isolated-assets
     * @see https://www.bitget.com/api-doc/uta/account/Get-Account
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.productType] *contract only* 'USDT-FUTURES', 'USDC-FUTURES', 'COIN-FUTURES', 'SUSDT-FUTURES', 'SUSDC-FUTURES' or 'SCOIN-FUTURES'
     * @param {string} [params.uta] set to true for the unified trading account (uta), defaults to false
     * @returns {object} a [balance structure]{@link https://docs.ccxt.com/?id=balance-structure}
     */
    public async override Task<object> fetchBalance(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object marketType = null;
        object marginMode = null;
        object response = null;
        object uta = null;
        var utaparametersVariable = this.handleOptionAndParams(parameters, "fetchBalance", "uta", false);
        uta = ((IList<object>)utaparametersVariable)[0];
        parameters = ((IList<object>)utaparametersVariable)[1];
        var marketTypeparametersVariable = this.handleMarketTypeAndParams("fetchBalance", null, parameters);
        marketType = ((IList<object>)marketTypeparametersVariable)[0];
        parameters = ((IList<object>)marketTypeparametersVariable)[1];
        var marginModeparametersVariable = this.handleMarginModeAndParams("fetchBalance", parameters);
        marginMode = ((IList<object>)marginModeparametersVariable)[0];
        parameters = ((IList<object>)marginModeparametersVariable)[1];
        if (isTrue(uta))
        {
            response = await this.privateUtaGetV3AccountAssets(this.extend(request, parameters));
            object results = this.safeDict(response, "data", new Dictionary<string, object>() {});
            object assets = this.safeList(results, "assets", new List<object>() {});
            return this.parseUtaBalance(assets);
        } else if (isTrue(isTrue((isEqual(marketType, "swap"))) || isTrue((isEqual(marketType, "future")))))
        {
            object productType = null;
            var productTypeparametersVariable = this.handleProductTypeAndParams(null, parameters);
            productType = ((IList<object>)productTypeparametersVariable)[0];
            parameters = ((IList<object>)productTypeparametersVariable)[1];
            ((IDictionary<string,object>)request)["productType"] = productType;
            response = await this.privateMixGetV2MixAccountAccounts(this.extend(request, parameters));
        } else if (isTrue(isEqual(marginMode, "isolated")))
        {
            response = await this.privateMarginGetV2MarginIsolatedAccountAssets(this.extend(request, parameters));
        } else if (isTrue(isEqual(marginMode, "cross")))
        {
            response = await this.privateMarginGetV2MarginCrossedAccountAssets(this.extend(request, parameters));
        } else if (isTrue(isEqual(marketType, "spot")))
        {
            response = await this.privateSpotGetV2SpotAccountAssets(this.extend(request, parameters));
        } else
        {
            throw new NotSupported ((string)add(add(add(this.id, " fetchBalance() does not support "), marketType), " accounts")) ;
        }
        // spot
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1700623852854,
        //         "data": [
        //             {
        //                 "coin": "USDT",
        //                 "available": "0.00000000",
        //                 "limitAvailable": "0",
        //                 "frozen": "0.00000000",
        //                 "locked": "0.00000000",
        //                 "uTime": "1699937566000"
        //             }
        //         ]
        //     }
        //
        // swap
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1700625127294,
        //         "data": [
        //             {
        //                 "marginCoin": "USDT",
        //                 "locked": "0",
        //                 "available": "0",
        //                 "crossedMaxAvailable": "0",
        //                 "isolatedMaxAvailable": "0",
        //                 "maxTransferOut": "0",
        //                 "accountEquity": "0",
        //                 "usdtEquity": "0.000000005166",
        //                 "btcEquity": "0",
        //                 "crossedRiskRate": "0",
        //                 "unrealizedPL": "0",
        //                 "coupon": "0",
        //                 "crossedUnrealizedPL": null,
        //                 "isolatedUnrealizedPL": null
        //             }
        //         ]
        //     }
        //
        // uta
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1749980065089,
        //         "data": {
        //             "accountEquity": "11.13919278",
        //             "usdtEquity": "11.13921165",
        //             "btcEquity": "0.00011256",
        //             "unrealisedPnl": "0",
        //             "usdtUnrealisedPnl": "0",
        //             "btcUnrealizedPnl": "0",
        //             "effEquity": "6.19299777",
        //             "mmr": "0",
        //             "imr": "0",
        //             "mgnRatio": "0",
        //             "positionMgnRatio": "0",
        //             "assets": [
        //                 {
        //                     "coin": "USDT",
        //                     "equity": "6.19300826",
        //                     "usdValue": "6.19299777",
        //                     "balance": "6.19300826",
        //                     "available": "6.19300826",
        //                     "debt": "0",
        //                     "locked": "0"
        //                 }
        //             ]
        //         }
        //     }
        //
        object data = this.safeValue(response, "data", new List<object>() {});
        return this.parseBalance(data);
    }

    public virtual object parseUtaBalance(object balance)
    {
        object result = new Dictionary<string, object>() {
            { "info", balance },
        };
        //
        //     {
        //         "coin": "USDT",
        //         "equity": "6.19300826",
        //         "usdValue": "6.19299777",
        //         "balance": "6.19300826",
        //         "available": "6.19300826",
        //         "debt": "0",
        //         "locked": "0"
        //     }
        //
        for (object i = 0; isLessThan(i, getArrayLength(balance)); postFixIncrement(ref i))
        {
            object entry = getValue(balance, i);
            object account = this.account();
            object currencyId = this.safeString(entry, "coin");
            object code = this.safeCurrencyCode(currencyId);
            ((IDictionary<string,object>)account)["debt"] = this.safeString(entry, "debt");
            ((IDictionary<string,object>)account)["used"] = this.safeString(entry, "locked");
            ((IDictionary<string,object>)account)["free"] = this.safeString(entry, "available");
            ((IDictionary<string,object>)account)["total"] = this.safeString(entry, "balance");
            ((IDictionary<string,object>)result)[(string)code] = account;
        }
        return this.safeBalance(result);
    }

    public override object parseBalance(object balance)
    {
        object result = new Dictionary<string, object>() {
            { "info", balance },
        };
        //
        // spot
        //
        //     {
        //         "coin": "USDT",
        //         "available": "0.00000000",
        //         "limitAvailable": "0",
        //         "frozen": "0.00000000",
        //         "locked": "0.00000000",
        //         "uTime": "1699937566000"
        //     }
        //
        // swap
        //
        //     {
        //         "marginCoin": "USDT",
        //         "locked": "0",
        //         "available": "0",
        //         "crossedMaxAvailable": "0",
        //         "isolatedMaxAvailable": "0",
        //         "maxTransferOut": "0",
        //         "accountEquity": "0",
        //         "usdtEquity": "0.000000005166",
        //         "btcEquity": "0",
        //         "crossedRiskRate": "0",
        //         "unrealizedPL": "0",
        //         "coupon": "0",
        //         "crossedUnrealizedPL": null,
        //         "isolatedUnrealizedPL": null
        //     }
        //
        // cross & isolated margin
        //
        //      {
        //           "coin": "USDT",
        //           "totalAmount": "0.01",
        //           "available": "0.01",
        //           "frozen": "0",
        //           "borrow": "0",
        //           "interest": "0",
        //           "net": "0.01",
        //           "coupon": "0",
        //           "cTime": "1759828511592",
        //           "uTime": "1759828511592"
        //           // "symbol": "BTCUSDT" // only for isolated margin
        //       }
        //
        for (object i = 0; isLessThan(i, getArrayLength(balance)); postFixIncrement(ref i))
        {
            object entry = getValue(balance, i);
            object account = this.account();
            object currencyId = this.safeString2(entry, "marginCoin", "coin");
            object code = this.safeCurrencyCode(currencyId);
            object borrow = this.safeString(entry, "borrow");
            if (isTrue(!isEqual(borrow, null)))
            {
                object interest = this.safeString(entry, "interest");
                ((IDictionary<string,object>)account)["free"] = this.safeString(entry, "transferable");
                ((IDictionary<string,object>)account)["total"] = this.safeString(entry, "totalAmount");
                ((IDictionary<string,object>)account)["debt"] = Precise.stringAdd(borrow, interest);
            } else
            {
                // Use transferable instead of available for swap and margin https://github.com/ccxt/ccxt/pull/19127
                object spotAccountFree = this.safeString(entry, "available");
                object contractAccountFree = this.safeString(entry, "maxTransferOut");
                if (isTrue(!isEqual(contractAccountFree, null)))
                {
                    ((IDictionary<string,object>)account)["free"] = contractAccountFree;
                    ((IDictionary<string,object>)account)["total"] = this.safeString(entry, "accountEquity");
                } else
                {
                    ((IDictionary<string,object>)account)["free"] = spotAccountFree;
                    object frozen = this.safeString(entry, "frozen");
                    object locked = this.safeString(entry, "locked");
                    ((IDictionary<string,object>)account)["used"] = Precise.stringAdd(frozen, locked);
                }
            }
            ((IDictionary<string,object>)result)[(string)code] = account;
        }
        return this.safeBalance(result);
    }

    public virtual object parseOrderStatus(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "new", "open" },
            { "init", "open" },
            { "not_trigger", "open" },
            { "partial_fill", "open" },
            { "partially_fill", "open" },
            { "partially_filled", "open" },
            { "triggered", "closed" },
            { "full_fill", "closed" },
            { "filled", "closed" },
            { "fail_trigger", "rejected" },
            { "cancel", "canceled" },
            { "cancelled", "canceled" },
            { "canceled", "canceled" },
            { "live", "open" },
            { "fail_execute", "rejected" },
            { "executed", "closed" },
        };
        return this.safeString(statuses, status, status);
    }

    public override object parseOrder(object order, object market = null)
    {
        //
        // createOrder, editOrder, closePosition
        //
        //     {
        //         "clientOid": "abe95dbe-6081-4a6f-a2d3-ae49601cd479",
        //         "orderId": null
        //     }
        //
        // createOrders
        //
        //     [
        //         {
        //             "orderId": "1111397214281175046",
        //             "clientOid": "766d3fc3-7321-4406-a689-15c9987a2e75"
        //         },
        //         {
        //             "orderId": "",
        //             "clientOid": "d1b75cb3-cc15-4ede-ad4c-3937396f75ab",
        //             "errorMsg": "less than the minimum amount 5 USDT",
        //             "errorCode": "45110"
        //         },
        //     ]
        //
        // spot, swap, future, spot margin and uta: cancelOrder, cancelOrders, cancelAllOrders
        //
        //     {
        //         "orderId": "1098758604547850241",
        //         "clientOid": "1098758604585598977"
        //     }
        //
        // spot trigger: cancelOrder
        //
        //     {
        //         "result": "success"
        //     }
        //
        // spot: fetchOrder, fetchOpenOrders, fetchCanceledAndClosedOrders
        //
        //     {
        //         "userId": "7264631750",
        //         "symbol": "BTCUSDT",
        //         "orderId": "1111499608327360513",
        //         "clientOid": "d0d4dad5-18d0-4869-a074-ec40bb47cba6",
        //         "size": "0.0002000000000000", // COST for 'buy market' order! AMOUNT in all other cases
        //         "price": "0", // in fetchOrder: 0 for market order, otherwise limit price (field not present in fetchOpenOrders
        //         "orderType": "limit",
        //         "side": "buy",
        //         "status": "live",
        //         "basePrice": "0",
        //         "priceAvg": "25000.0000000000000000",   // 0 if nothing filled
        //         "baseVolume": "0.0000000000000000",     // 0 if nothing filled
        //         "quoteVolume": "0.0000000000000000",    // 0 if nothing filled
        //         "enterPointSource": "WEB",
        //         "orderSource": "normal",
        //         "cTime": "1700728077966",
        //         "uTime": "1700728077966"
        //         "feeDetail": "{\\"newFees\\":{\\"c\\":0,\\"d\\":0,\\"deduction\\":false,\\"r\\":-0.0064699886,\\"t\\":-0.0064699886,\\"totalDeductionFee\\":0},\\"USDT\\":{\\"deduction\\":false,\\"feeCoinCode\\":\\"USDT\\",\\"totalDeductionFee\\":0,\\"totalFee\\":-0.0064699886000000}}", // might not be present in fetchOpenOrders
        //         "triggerPrice": null,
        //         "tpslType": "normal",
        //         "quoteCoin": "USDT",  // not present in fetchOpenOrders
        //         "baseCoin": "DOT",    // not present in fetchOpenOrders
        //         "cancelReason": "",   // not present in fetchOpenOrders
        //     }
        //
        // spot trigger: fetchOpenOrders, fetchCanceledAndClosedOrders
        //
        //     {
        //         "orderId": "1111503385931620352",
        //         "clientOid": "1111503385910648832",
        //         "symbol": "BTCUSDT",
        //         "size": "0.0002",
        //         "planType": "AMOUNT",
        //         "executePrice": "25000",
        //         "triggerPrice": "26000",
        //         "status": "live",
        //         "orderType": "limit",
        //         "side": "buy",
        //         "triggerType": "fill_price",
        //         "enterPointSource": "API",
        //         "cTime": "1700728978617",
        //         "uTime": "1700728978617"
        //     }
        //
        // spot margin: fetchOpenOrders, fetchCanceledAndClosedOrders
        //
        //     {
        //         "symbol": "BTCUSDT",
        //         "orderType": "limit",
        //         "enterPointSource": "WEB",
        //         "orderId": "1111506377509580801",
        //         "clientOid": "2043a3b59a60445f9d9f7365bf3e960c",
        //         "loanType": "autoLoanAndRepay",
        //         "price": "25000",
        //         "side": "buy",
        //         "status": "live",
        //         "baseSize": "0.0002",
        //         "quoteSize": "5",
        //         "priceAvg": "0",
        //         "size": "0",
        //         "amount": "0",
        //         "force": "gtc",
        //         "cTime": "1700729691866",
        //         "uTime": "1700729691866"
        //     }
        //
        // swap and future: fetchOrder, fetchOpenOrders, fetchCanceledAndClosedOrders
        //
        //     {
        //         "symbol": "BTCUSDT",
        //         "size": "0.001",
        //         "orderId": "1111465253393825792",
        //         "clientOid": "1111465253431574529",
        //         "baseVolume": "0",
        //         "fee": "0",
        //         "price": "27000",
        //         "priceAvg": "",
        //         "state": "live",
        //         // "status": "live", // key for fetchOpenOrders, fetchClosedOrders
        //         "side": "buy",
        //         "force": "gtc",
        //         "totalProfits": "0",
        //         "posSide": "long",
        //         "marginCoin": "USDT",
        //         "quoteVolume": "0",
        //         "leverage": "20",
        //         "marginMode": "crossed",
        //         "enterPointSource": "API",
        //         "tradeSide": "open",
        //         "posMode": "hedge_mode",
        //         "orderType": "limit",
        //         "orderSource": "normal",
        //         "presetStopSurplusPrice": "",
        //         "presetStopLossPrice": "",
        //         "reduceOnly": "NO",
        //         "cTime": "1700719887120",
        //         "uTime": "1700719887120"
        //
        //     for swap trigger order, the additional below fields are present:
        //
        //         "planType": "normal_plan",
        //         "callbackRatio": "",
        //         "triggerPrice": "24000",
        //         "triggerType": "mark_price",
        //         "planStatus": "live",
        //         "stopSurplusTriggerPrice": "",
        //         "stopSurplusExecutePrice": "",
        //         "stopSurplusTriggerType": "fill_price",
        //         "stopLossTriggerPrice": "",
        //         "stopLossExecutePrice": "",
        //         "stopLossTriggerType": "fill_price",
        //     }
        //
        // uta: fetchOrder, fetchOpenOrders, fetchCanceledAndClosedOrders
        //
        //     {
        //         "orderId": "1320244799629316096",
        //         "clientOid": "1320244799633510400",
        //         "category": "USDT-FUTURES",
        //         "symbol": "BTCUSDT",
        //         "orderType": "limit",
        //         "side": "buy",
        //         "price": "50000",
        //         "qty": "0.001",
        //         "amount": "0",
        //         "cumExecQty": "0",
        //         "cumExecValue": "0",
        //         "avgPrice": "0",
        //         "timeInForce": "gtc",
        //         "orderStatus": "live",
        //         "posSide": "long",
        //         "holdMode": "hedge_mode",
        //         "reduceOnly": "NO",
        //         "feeDetail": [{
        //             "feeCoin": "",
        //             "fee": ""
        //         }],
        //         "createdTime": "1750496809871",
        //         "updatedTime": "1750496809886",
        //         "cancelReason": "",
        //         "execType": "normal",
        //         "stpMode": "none",
        //         "tpTriggerBy": null,
        //         "slTriggerBy": null,
        //         "takeProfit": null,
        //         "stopLoss": null,
        //         "tpOrderType": null,
        //         "slOrderType": null,
        //         "tpLimitPrice": null,
        //         "slLimitPrice": null
        //     }
        //
        // uta trigger: fetchClosedOrders, fetchCanceledOrders
        //
        //     {
        //         "orderId": "1330984742276198400",
        //         "clientOid": "1330984742276198400",
        //         "symbol": "BTCUSDT",
        //         "category": "USDT-FUTURES",
        //         "qty": "0.001",
        //         "posSide": "long",
        //         "tpTriggerBy": "market",
        //         "slTriggerBy": "mark",
        //         "takeProfit": "",
        //         "stopLoss": "112000",
        //         "tpOrderType": "market",
        //         "slOrderType": "limit",
        //         "tpLimitPrice": "",
        //         "slLimitPrice": "111000",
        //         "createdTime": "1753057411736",
        //         "updatedTime": "1753058267412"
        //     }
        //
        object errorMessage = this.safeString(order, "errorMsg");
        if (isTrue(!isEqual(errorMessage, null)))
        {
            return this.safeOrder(new Dictionary<string, object>() {
                { "info", order },
                { "id", this.safeString(order, "orderId") },
                { "clientOrderId", this.safeString2(order, "clientOrderId", "clientOid") },
                { "status", "rejected" },
            }, market);
        }
        object posSide = this.safeString(order, "posSide");
        object isContractOrder = (!isEqual(posSide, null));
        object marketType = ((bool) isTrue(isContractOrder)) ? "contract" : "spot";
        if (isTrue(!isEqual(market, null)))
        {
            marketType = getValue(market, "type");
        }
        object marketId = this.safeString(order, "symbol");
        market = this.safeMarket(marketId, market, null, marketType);
        object timestamp = this.safeIntegerN(order, new List<object>() {"cTime", "ctime", "createdTime"});
        object updateTimestamp = this.safeInteger2(order, "uTime", "updatedTime");
        object rawStatus = this.safeStringN(order, new List<object>() {"status", "state", "orderStatus", "planStatus"});
        object fee = null;
        object feeCostString = this.safeString(order, "fee");
        if (isTrue(!isEqual(feeCostString, null)))
        {
            // swap
            fee = new Dictionary<string, object>() {
                { "cost", this.parseNumber(Precise.stringNeg(feeCostString)) },
                { "currency", getValue(market, "settle") },
            };
        }
        object feeDetail = this.safeValue(order, "feeDetail");
        object uta = !isEqual(this.safeString(order, "category"), null);
        if (isTrue(uta))
        {
            object feeResult = this.safeDict(feeDetail, 0, new Dictionary<string, object>() {});
            object utaFee = this.safeString(feeResult, "fee");
            fee = new Dictionary<string, object>() {
                { "cost", this.parseNumber(Precise.stringNeg(utaFee)) },
                { "currency", getValue(market, "settle") },
            };
        } else
        {
            if (isTrue(!isEqual(feeDetail, null)))
            {
                object parsedFeeDetail = parseJson(feeDetail);
                object feeValues = new List<object>(((IDictionary<string,object>)parsedFeeDetail).Values);
                object feeObject = null;
                for (object i = 0; isLessThan(i, getArrayLength(feeValues)); postFixIncrement(ref i))
                {
                    object feeValue = getValue(feeValues, i);
                    if (isTrue(!isEqual(this.safeValue(feeValue, "feeCoinCode"), null)))
                    {
                        feeObject = feeValue;
                        break;
                    }
                }
                fee = new Dictionary<string, object>() {
                    { "cost", this.parseNumber(Precise.stringNeg(this.safeString(feeObject, "totalFee"))) },
                    { "currency", this.safeCurrencyCode(this.safeString(feeObject, "feeCoinCode")) },
                };
            }
        }
        object postOnly = null;
        object timeInForce = this.safeStringUpper2(order, "force", "timeInForce");
        if (isTrue(isEqual(timeInForce, "POST_ONLY")))
        {
            postOnly = true;
            timeInForce = "PO";
        }
        object reduceOnly = null;
        object reduceOnlyRaw = this.safeString(order, "reduceOnly");
        if (isTrue(!isEqual(reduceOnlyRaw, null)))
        {
            reduceOnly = ((bool) isTrue((isEqual(reduceOnlyRaw, "NO")))) ? false : true;
        }
        object price = null;
        object average = null;
        object basePrice = this.safeString(order, "basePrice");
        if (isTrue(!isEqual(basePrice, null)))
        {
            // for spot fetchOpenOrders, the price is priceAvg and the filled price is basePrice
            price = this.safeString(order, "priceAvg");
            average = this.safeString(order, "basePrice");
        } else
        {
            price = this.safeStringN(order, new List<object>() {"price", "executePrice", "slLimitPrice", "tpLimitPrice"});
            average = this.safeString(order, "priceAvg");
        }
        object size = null;
        object filled = null;
        object baseSize = this.safeString(order, "baseSize");
        if (isTrue(!isEqual(baseSize, null)))
        {
            // for spot margin fetchOpenOrders, the order size is baseSize and the filled amount is size
            size = baseSize;
            filled = this.safeString(order, "size");
        } else
        {
            size = this.safeString2(order, "size", "qty");
            filled = this.safeString2(order, "baseVolume", "cumExecQty");
        }
        object side = this.safeString(order, "side");
        object posMode = this.safeString(order, "posMode");
        if (isTrue(isTrue(isEqual(posMode, "hedge_mode")) && isTrue(reduceOnly)))
        {
            side = ((bool) isTrue((isEqual(side, "buy")))) ? "sell" : "buy";
        }
        object orderType = this.safeString(order, "orderType");
        object isBuyMarket = isTrue((isEqual(side, "buy"))) && isTrue((isEqual(orderType, "market")));
        if (isTrue(isTrue(getValue(market, "spot")) && isTrue(isBuyMarket)))
        {
            // as noted in top comment, for 'buy market' the 'size' field is COST, not AMOUNT
            size = this.safeString(order, "baseVolume");
        }
        return this.safeOrder(new Dictionary<string, object>() {
            { "info", order },
            { "id", this.safeString2(order, "orderId", "data") },
            { "clientOrderId", this.safeString2(order, "clientOrderId", "clientOid") },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "lastTradeTimestamp", updateTimestamp },
            { "lastUpdateTimestamp", updateTimestamp },
            { "symbol", getValue(market, "symbol") },
            { "type", orderType },
            { "side", side },
            { "price", price },
            { "amount", size },
            { "cost", this.safeString2(order, "quoteVolume", "quoteSize") },
            { "average", average },
            { "filled", filled },
            { "remaining", null },
            { "timeInForce", timeInForce },
            { "postOnly", postOnly },
            { "reduceOnly", reduceOnly },
            { "triggerPrice", this.safeNumber(order, "triggerPrice") },
            { "takeProfitPrice", this.safeNumberN(order, new List<object>() {"presetStopSurplusPrice", "stopSurplusTriggerPrice", "takeProfit"}) },
            { "stopLossPrice", this.safeNumberN(order, new List<object>() {"presetStopLossPrice", "stopLossTriggerPrice", "stopLoss"}) },
            { "status", this.parseOrderStatus(rawStatus) },
            { "fee", fee },
            { "trades", null },
        }, market);
    }

    /**
     * @method
     * @name bitget#createMarketBuyOrderWithCost
     * @description create a market buy order by providing the symbol and cost
     * @see https://www.bitget.com/api-doc/spot/trade/Place-Order
     * @see https://www.bitget.com/api-doc/margin/cross/trade/Cross-Place-Order
     * @see https://www.bitget.com/api-doc/margin/isolated/trade/Isolated-Place-Order
     * @param {string} symbol unified symbol of the market to create an order in
     * @param {float} cost how much you want to trade in units of the quote currency
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} an [order structure]{@link https://docs.ccxt.com/?id=order-structure}
     */
    public async override Task<object> createMarketBuyOrderWithCost(object symbol, object cost, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        if (!isTrue(getValue(market, "spot")))
        {
            throw new NotSupported ((string)add(this.id, " createMarketBuyOrderWithCost() supports spot orders only")) ;
        }
        object req = new Dictionary<string, object>() {
            { "createMarketBuyOrderRequiresPrice", false },
        };
        return await this.createOrder(symbol, "market", "buy", cost, null, this.extend(req, parameters));
    }

    /**
     * @method
     * @name bitget#createOrder
     * @description create a trade order
     * @see https://www.bitget.com/api-doc/spot/trade/Place-Order
     * @see https://www.bitget.com/api-doc/spot/plan/Place-Plan-Order
     * @see https://www.bitget.com/api-doc/contract/trade/Place-Order
     * @see https://www.bitget.com/api-doc/contract/plan/Place-Tpsl-Order
     * @see https://www.bitget.com/api-doc/contract/plan/Place-Plan-Order
     * @see https://www.bitget.com/api-doc/margin/cross/trade/Cross-Place-Order
     * @see https://www.bitget.com/api-doc/margin/isolated/trade/Isolated-Place-Order
     * @see https://www.bitget.com/api-doc/uta/trade/Place-Order
     * @see https://www.bitget.com/api-doc/uta/strategy/Place-Strategy-Order
     * @param {string} symbol unified symbol of the market to create an order in
     * @param {string} type 'market' or 'limit'
     * @param {string} side 'buy' or 'sell'
     * @param {float} amount how much you want to trade in units of the base currency
     * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {float} [params.cost] *spot only* how much you want to trade in units of the quote currency, for market buy orders only
     * @param {float} [params.triggerPrice] *swap only* The price at which a trigger order is triggered at
     * @param {float} [params.stopLossPrice] *swap only* The price at which a stop loss order is triggered at
     * @param {float} [params.takeProfitPrice] *swap only* The price at which a take profit order is triggered at
     * @param {object} [params.takeProfit] *takeProfit object in params* containing the triggerPrice at which the attached take profit order will be triggered (perpetual swap markets only)
     * @param {float} [params.takeProfit.triggerPrice] *swap only* take profit trigger price
     * @param {object} [params.stopLoss] *stopLoss object in params* containing the triggerPrice at which the attached stop loss order will be triggered (perpetual swap markets only)
     * @param {float} [params.stopLoss.triggerPrice] *swap only* stop loss trigger price
     * @param {string} [params.timeInForce] "GTC", "IOC", "FOK", or "PO"
     * @param {string} [params.marginMode] 'isolated' or 'cross' for spot margin trading
     * @param {string} [params.loanType] *spot margin only* 'normal', 'autoLoan', 'autoRepay', or 'autoLoanAndRepay' default is 'normal'
     * @param {string} [params.holdSide] *contract stopLossPrice, takeProfitPrice only* Two-way position: ('long' or 'short'), one-way position: ('buy' or 'sell')
     * @param {float} [params.stopLoss.price] *swap only* the execution price for a stop loss attached to a trigger order
     * @param {float} [params.takeProfit.price] *swap only* the execution price for a take profit attached to a trigger order
     * @param {string} [params.stopLoss.type] *swap only* the type for a stop loss attached to a trigger order, 'fill_price', 'index_price' or 'mark_price', default is 'mark_price'
     * @param {string} [params.takeProfit.type] *swap only* the type for a take profit attached to a trigger order, 'fill_price', 'index_price' or 'mark_price', default is 'mark_price'
     * @param {string} [params.trailingPercent] *swap and future only* the percent to trail away from the current market price, rate can not be greater than 10
     * @param {string} [params.trailingTriggerPrice] *swap and future only* the price to trigger a trailing stop order, default uses the price argument
     * @param {string} [params.triggerType] *swap and future only* 'fill_price', 'mark_price' or 'index_price'
     * @param {boolean} [params.oneWayMode] *swap and future only* required to set this to true in one_way_mode and you can leave this as undefined in hedge_mode, can adjust the mode using the setPositionMode() method
     * @param {bool} [params.hedged] *swap and future only* true for hedged mode, false for one way mode, default is false
     * @param {bool} [params.reduceOnly] true or false whether the order is reduce-only
     * @param {boolean} [params.uta] set to true for the unified trading account (uta), defaults to false
     * @param {string} [params.posSide] *uta only* hedged two-way position side, long or short
     * @returns {object} an [order structure]{@link https://docs.ccxt.com/?id=order-structure}
     */
    public async override Task<object> createOrder(object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object marginParams = this.handleMarginModeAndParams("createOrder", parameters);
        object marginMode = getValue(marginParams, 0);
        object triggerPrice = this.safeValue2(parameters, "stopPrice", "triggerPrice");
        object stopLossTriggerPrice = this.safeValue(parameters, "stopLossPrice");
        object takeProfitTriggerPrice = this.safeValue(parameters, "takeProfitPrice");
        object trailingPercent = this.safeString2(parameters, "trailingPercent", "callbackRatio");
        object isTrailingPercentOrder = !isEqual(trailingPercent, null);
        object isTriggerOrder = !isEqual(triggerPrice, null);
        object isStopLossTriggerOrder = !isEqual(stopLossTriggerPrice, null);
        object isTakeProfitTriggerOrder = !isEqual(takeProfitTriggerPrice, null);
        object isStopLossOrTakeProfitTrigger = isTrue(isStopLossTriggerOrder) || isTrue(isTakeProfitTriggerOrder);
        object response = null;
        object uta = null;
        var utaparametersVariable = this.handleOptionAndParams(parameters, "createOrder", "uta", false);
        uta = ((IList<object>)utaparametersVariable)[0];
        parameters = ((IList<object>)utaparametersVariable)[1];
        if (isTrue(uta))
        {
            object request = this.createUtaOrderRequest(symbol, type, side, amount, price, parameters);
            if (isTrue(isStopLossOrTakeProfitTrigger))
            {
                response = await this.privateUtaPostV3TradePlaceStrategyOrder(request);
            } else
            {
                response = await this.privateUtaPostV3TradePlaceOrder(request);
            }
        } else
        {
            object request = this.createOrderRequest(symbol, type, side, amount, price, parameters);
            if (isTrue(getValue(market, "spot")))
            {
                if (isTrue(isTriggerOrder))
                {
                    response = await this.privateSpotPostV2SpotTradePlacePlanOrder(request);
                } else if (isTrue(isEqual(marginMode, "isolated")))
                {
                    response = await this.privateMarginPostV2MarginIsolatedPlaceOrder(request);
                } else if (isTrue(isEqual(marginMode, "cross")))
                {
                    response = await this.privateMarginPostV2MarginCrossedPlaceOrder(request);
                } else
                {
                    response = await this.privateSpotPostV2SpotTradePlaceOrder(request);
                }
            } else
            {
                if (isTrue(isTrue(isTriggerOrder) || isTrue(isTrailingPercentOrder)))
                {
                    response = await this.privateMixPostV2MixOrderPlacePlanOrder(request);
                } else if (isTrue(isStopLossOrTakeProfitTrigger))
                {
                    response = await this.privateMixPostV2MixOrderPlaceTpslOrder(request);
                } else
                {
                    response = await this.privateMixPostV2MixOrderPlaceOrder(request);
                }
            }
        }
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1645932209602,
        //         "data": {
        //             "orderId": "881669078313766912",
        //             "clientOid": "iauIBf#a45b595f96474d888d0ada"
        //         }
        //     }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        return this.parseOrder(data, market);
    }

    public virtual object createUtaOrderRequest(object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object market = this.market(symbol);
        object productType = null;
        var productTypeparametersVariable = this.handleProductTypeAndParams(market, parameters);
        productType = ((IList<object>)productTypeparametersVariable)[0];
        parameters = ((IList<object>)productTypeparametersVariable)[1];
        if (isTrue(isEqual(productType, "SPOT")))
        {
            object marginMode = null;
            var marginModeparametersVariable = this.handleMarginModeAndParams("createOrder", parameters);
            marginMode = ((IList<object>)marginModeparametersVariable)[0];
            parameters = ((IList<object>)marginModeparametersVariable)[1];
            if (isTrue(!isEqual(marginMode, null)))
            {
                productType = "MARGIN";
            }
        }
        object request = new Dictionary<string, object>() {
            { "category", productType },
            { "symbol", getValue(market, "id") },
            { "qty", this.amountToPrecision(symbol, amount) },
            { "side", side },
        };
        object clientOrderId = this.safeString2(parameters, "clientOid", "clientOrderId");
        if (isTrue(!isEqual(clientOrderId, null)))
        {
            ((IDictionary<string,object>)request)["clientOid"] = clientOrderId;
            parameters = this.omit(parameters, "clientOrderId");
        }
        object stopLossTriggerPrice = this.safeNumber(parameters, "stopLossPrice");
        object takeProfitTriggerPrice = this.safeNumber(parameters, "takeProfitPrice");
        object stopLoss = this.safeValue(parameters, "stopLoss");
        object takeProfit = this.safeValue(parameters, "takeProfit");
        object hasStopLoss = !isEqual(stopLoss, null);
        object hasTakeProfit = !isEqual(takeProfit, null);
        object isStopLossTrigger = !isEqual(stopLossTriggerPrice, null);
        object isTakeProfitTrigger = !isEqual(takeProfitTriggerPrice, null);
        object isStopLossOrTakeProfitTrigger = isTrue(isStopLossTrigger) || isTrue(isTakeProfitTrigger);
        if (isTrue(isStopLossOrTakeProfitTrigger))
        {
            if (isTrue(isStopLossTrigger))
            {
                object slType = this.safeString(parameters, "slTriggerBy", "mark");
                ((IDictionary<string,object>)request)["slTriggerBy"] = slType;
                ((IDictionary<string,object>)request)["stopLoss"] = this.priceToPrecision(symbol, stopLossTriggerPrice);
                if (isTrue(!isEqual(price, null)))
                {
                    ((IDictionary<string,object>)request)["slLimitPrice"] = this.priceToPrecision(symbol, price);
                    ((IDictionary<string,object>)request)["slOrderType"] = this.safeString(parameters, "slOrderType", "limit");
                } else
                {
                    ((IDictionary<string,object>)request)["slOrderType"] = this.safeString(parameters, "slOrderType", "market");
                }
            } else if (isTrue(isTakeProfitTrigger))
            {
                object tpType = this.safeString(parameters, "tpTriggerBy", "mark");
                ((IDictionary<string,object>)request)["tpTriggerBy"] = tpType;
                ((IDictionary<string,object>)request)["takeProfit"] = this.priceToPrecision(symbol, takeProfitTriggerPrice);
                if (isTrue(!isEqual(price, null)))
                {
                    ((IDictionary<string,object>)request)["tpLimitPrice"] = this.priceToPrecision(symbol, price);
                    ((IDictionary<string,object>)request)["tpOrderType"] = this.safeString(parameters, "tpOrderType", "limit");
                } else
                {
                    ((IDictionary<string,object>)request)["tpOrderType"] = this.safeString(parameters, "tpOrderType", "market");
                }
            }
            parameters = this.omit(parameters, new List<object>() {"stopLossPrice", "takeProfitPrice"});
        } else
        {
            if (isTrue(hasStopLoss))
            {
                object slTriggerPrice = this.safeNumber2(stopLoss, "triggerPrice", "stopPrice");
                object slLimitPrice = this.safeNumber(stopLoss, "price");
                ((IDictionary<string,object>)request)["stopLoss"] = this.priceToPrecision(symbol, slTriggerPrice);
                if (isTrue(!isEqual(slLimitPrice, null)))
                {
                    ((IDictionary<string,object>)request)["slLimitPrice"] = this.priceToPrecision(symbol, slLimitPrice);
                    ((IDictionary<string,object>)request)["slOrderType"] = this.safeString(parameters, "slOrderType", "limit");
                } else
                {
                    ((IDictionary<string,object>)request)["slOrderType"] = this.safeString(parameters, "slOrderType", "market");
                }
            }
            if (isTrue(hasTakeProfit))
            {
                object tpTriggerPrice = this.safeNumber2(takeProfit, "triggerPrice", "stopPrice");
                object tpLimitPrice = this.safeNumber(takeProfit, "price");
                ((IDictionary<string,object>)request)["takeProfit"] = this.priceToPrecision(symbol, tpTriggerPrice);
                if (isTrue(!isEqual(tpLimitPrice, null)))
                {
                    ((IDictionary<string,object>)request)["tpLimitPrice"] = this.priceToPrecision(symbol, tpLimitPrice);
                    ((IDictionary<string,object>)request)["tpOrderType"] = this.safeString(parameters, "tpOrderType", "limit");
                } else
                {
                    ((IDictionary<string,object>)request)["tpOrderType"] = this.safeString(parameters, "tpOrderType", "market");
                }
            }
            object isMarketOrder = isEqual(type, "market");
            if (!isTrue(isMarketOrder))
            {
                ((IDictionary<string,object>)request)["price"] = this.priceToPrecision(symbol, price);
            }
            ((IDictionary<string,object>)request)["orderType"] = type;
            object exchangeSpecificTifParam = this.safeString(parameters, "timeInForce");
            object postOnly = null;
            var postOnlyparametersVariable = this.handlePostOnly(isMarketOrder, isEqual(exchangeSpecificTifParam, "post_only"), parameters);
            postOnly = ((IList<object>)postOnlyparametersVariable)[0];
            parameters = ((IList<object>)postOnlyparametersVariable)[1];
            object defaultTimeInForce = this.safeStringUpper(this.options, "defaultTimeInForce");
            object timeInForce = this.safeStringUpper(parameters, "timeInForce", defaultTimeInForce);
            if (isTrue(postOnly))
            {
                ((IDictionary<string,object>)request)["timeInForce"] = "post_only";
            } else if (isTrue(isEqual(timeInForce, "GTC")))
            {
                ((IDictionary<string,object>)request)["timeInForce"] = "gtc";
            } else if (isTrue(isEqual(timeInForce, "FOK")))
            {
                ((IDictionary<string,object>)request)["timeInForce"] = "fok";
            } else if (isTrue(isEqual(timeInForce, "IOC")))
            {
                ((IDictionary<string,object>)request)["timeInForce"] = "ioc";
            }
        }
        object reduceOnly = this.safeBool(parameters, "reduceOnly", false);
        object hedged = null;
        var hedgedparametersVariable = this.handleParamBool(parameters, "hedged", false);
        hedged = ((IList<object>)hedgedparametersVariable)[0];
        parameters = ((IList<object>)hedgedparametersVariable)[1];
        if (isTrue(reduceOnly))
        {
            if (isTrue(isTrue(hedged) || isTrue(isStopLossOrTakeProfitTrigger)))
            {
                object reduceOnlyPosSide = ((bool) isTrue((isEqual(side, "sell")))) ? "long" : "short";
                ((IDictionary<string,object>)request)["posSide"] = reduceOnlyPosSide;
            } else if (!isTrue(isStopLossOrTakeProfitTrigger))
            {
                ((IDictionary<string,object>)request)["reduceOnly"] = "yes";
            }
        } else
        {
            if (isTrue(hedged))
            {
                object posSide = ((bool) isTrue((isEqual(side, "buy")))) ? "long" : "short";
                ((IDictionary<string,object>)request)["posSide"] = posSide;
            }
        }
        parameters = this.omit(parameters, new List<object>() {"stopLoss", "takeProfit", "postOnly", "reduceOnly", "hedged"});
        return this.extend(request, parameters);
    }

    public virtual object createOrderRequest(object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object market = this.market(symbol);
        object marketType = null;
        object marginMode = null;
        var marketTypeparametersVariable = this.handleMarketTypeAndParams("createOrder", market, parameters);
        marketType = ((IList<object>)marketTypeparametersVariable)[0];
        parameters = ((IList<object>)marketTypeparametersVariable)[1];
        var marginModeparametersVariable = this.handleMarginModeAndParams("createOrder", parameters);
        marginMode = ((IList<object>)marginModeparametersVariable)[0];
        parameters = ((IList<object>)marginModeparametersVariable)[1];
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
            { "orderType", type },
        };
        object hedged = null;
        var hedgedparametersVariable = this.handleParamBool(parameters, "hedged", false);
        hedged = ((IList<object>)hedgedparametersVariable)[0];
        parameters = ((IList<object>)hedgedparametersVariable)[1];
        // backward compatibility for `oneWayMode`
        object oneWayMode = null;
        var oneWayModeparametersVariable = this.handleParamBool(parameters, "oneWayMode");
        oneWayMode = ((IList<object>)oneWayModeparametersVariable)[0];
        parameters = ((IList<object>)oneWayModeparametersVariable)[1];
        if (isTrue(!isEqual(oneWayMode, null)))
        {
            hedged = !isTrue(oneWayMode);
        }
        object isMarketOrder = isEqual(type, "market");
        object triggerPrice = this.safeValue2(parameters, "stopPrice", "triggerPrice");
        object stopLossTriggerPrice = this.safeValue(parameters, "stopLossPrice");
        object takeProfitTriggerPrice = this.safeValue(parameters, "takeProfitPrice");
        object stopLoss = this.safeValue(parameters, "stopLoss");
        object takeProfit = this.safeValue(parameters, "takeProfit");
        object isTriggerOrder = !isEqual(triggerPrice, null);
        object isStopLossTriggerOrder = !isEqual(stopLossTriggerPrice, null);
        object isTakeProfitTriggerOrder = !isEqual(takeProfitTriggerPrice, null);
        object hasStopLoss = !isEqual(stopLoss, null);
        object hasTakeProfit = !isEqual(takeProfit, null);
        object isStopLossOrTakeProfitTrigger = isTrue(isStopLossTriggerOrder) || isTrue(isTakeProfitTriggerOrder);
        object isStopLossOrTakeProfit = isTrue(hasStopLoss) || isTrue(hasTakeProfit);
        object trailingTriggerPrice = this.safeString(parameters, "trailingTriggerPrice", this.numberToString(price));
        object trailingPercent = this.safeString2(parameters, "trailingPercent", "callbackRatio");
        object isTrailingPercentOrder = !isEqual(trailingPercent, null);
        if (isTrue(isGreaterThan(this.sum(isTriggerOrder, isStopLossTriggerOrder, isTakeProfitTriggerOrder, isTrailingPercentOrder), 1)))
        {
            throw new ExchangeError ((string)add(this.id, " createOrder() params can only contain one of triggerPrice, stopLossPrice, takeProfitPrice, trailingPercent")) ;
        }
        if (isTrue(isEqual(type, "limit")))
        {
            ((IDictionary<string,object>)request)["price"] = this.priceToPrecision(symbol, price);
        }
        object triggerPriceType = this.safeString2(parameters, "triggerPriceType", "triggerType", "mark_price");
        object reduceOnly = this.safeBool(parameters, "reduceOnly", false);
        object clientOrderId = this.safeString2(parameters, "clientOid", "clientOrderId");
        object exchangeSpecificTifParam = this.safeString2(parameters, "force", "timeInForce");
        object postOnly = null;
        var postOnlyparametersVariable = this.handlePostOnly(isMarketOrder, isEqual(exchangeSpecificTifParam, "post_only"), parameters);
        postOnly = ((IList<object>)postOnlyparametersVariable)[0];
        parameters = ((IList<object>)postOnlyparametersVariable)[1];
        object defaultTimeInForce = this.safeStringUpper(this.options, "defaultTimeInForce");
        object timeInForce = this.safeStringUpper(parameters, "timeInForce", defaultTimeInForce);
        if (isTrue(postOnly))
        {
            ((IDictionary<string,object>)request)["force"] = "post_only";
        } else if (isTrue(isEqual(timeInForce, "GTC")))
        {
            ((IDictionary<string,object>)request)["force"] = "GTC";
        } else if (isTrue(isEqual(timeInForce, "FOK")))
        {
            ((IDictionary<string,object>)request)["force"] = "FOK";
        } else if (isTrue(isEqual(timeInForce, "IOC")))
        {
            ((IDictionary<string,object>)request)["force"] = "IOC";
        }
        parameters = this.omit(parameters, new List<object>() {"stopPrice", "triggerType", "stopLossPrice", "takeProfitPrice", "stopLoss", "takeProfit", "postOnly", "reduceOnly", "clientOrderId", "trailingPercent", "trailingTriggerPrice"});
        if (isTrue(isTrue((isEqual(marketType, "swap"))) || isTrue((isEqual(marketType, "future")))))
        {
            ((IDictionary<string,object>)request)["marginCoin"] = getValue(market, "settleId");
            ((IDictionary<string,object>)request)["size"] = this.amountToPrecision(symbol, amount);
            object productType = null;
            var productTypeparametersVariable = this.handleProductTypeAndParams(market, parameters);
            productType = ((IList<object>)productTypeparametersVariable)[0];
            parameters = ((IList<object>)productTypeparametersVariable)[1];
            ((IDictionary<string,object>)request)["productType"] = productType;
            if (isTrue(!isEqual(clientOrderId, null)))
            {
                ((IDictionary<string,object>)request)["clientOid"] = clientOrderId;
            }
            if (isTrue(isTrue(isTrue(isTriggerOrder) || isTrue(isStopLossOrTakeProfitTrigger)) || isTrue(isTrailingPercentOrder)))
            {
                ((IDictionary<string,object>)request)["triggerType"] = triggerPriceType;
            }
            if (isTrue(isTrailingPercentOrder))
            {
                if (!isTrue(isMarketOrder))
                {
                    throw new BadRequest ((string)add(this.id, " createOrder() bitget trailing orders must be market orders")) ;
                }
                if (isTrue(isEqual(trailingTriggerPrice, null)))
                {
                    throw new ArgumentsRequired ((string)add(this.id, " createOrder() bitget trailing orders must have a trailingTriggerPrice param")) ;
                }
                ((IDictionary<string,object>)request)["planType"] = "track_plan";
                ((IDictionary<string,object>)request)["triggerPrice"] = this.priceToPrecision(symbol, trailingTriggerPrice);
                ((IDictionary<string,object>)request)["callbackRatio"] = trailingPercent;
            } else if (isTrue(isTriggerOrder))
            {
                ((IDictionary<string,object>)request)["planType"] = "normal_plan";
                ((IDictionary<string,object>)request)["triggerPrice"] = this.priceToPrecision(symbol, triggerPrice);
                if (isTrue(!isEqual(price, null)))
                {
                    ((IDictionary<string,object>)request)["executePrice"] = this.priceToPrecision(symbol, price);
                }
                if (isTrue(hasStopLoss))
                {
                    object slTriggerPrice = this.safeString2(stopLoss, "triggerPrice", "stopPrice");
                    ((IDictionary<string,object>)request)["stopLossTriggerPrice"] = this.priceToPrecision(symbol, slTriggerPrice);
                    object slPrice = this.safeString(stopLoss, "price");
                    ((IDictionary<string,object>)request)["stopLossExecutePrice"] = this.priceToPrecision(symbol, slPrice);
                    object slType = this.safeString(stopLoss, "type", "mark_price");
                    ((IDictionary<string,object>)request)["stopLossTriggerType"] = slType;
                }
                if (isTrue(hasTakeProfit))
                {
                    object tpTriggerPrice = this.safeString2(takeProfit, "triggerPrice", "stopPrice");
                    ((IDictionary<string,object>)request)["stopSurplusTriggerPrice"] = this.priceToPrecision(symbol, tpTriggerPrice);
                    object tpPrice = this.safeString(takeProfit, "price");
                    ((IDictionary<string,object>)request)["stopSurplusExecutePrice"] = this.priceToPrecision(symbol, tpPrice);
                    object tpType = this.safeString(takeProfit, "type", "mark_price");
                    ((IDictionary<string,object>)request)["stopSurplusTriggerType"] = tpType;
                }
            } else if (isTrue(isStopLossOrTakeProfitTrigger))
            {
                if (!isTrue(isMarketOrder))
                {
                    throw new ExchangeError ((string)add(this.id, " createOrder() bitget stopLoss or takeProfit orders must be market orders")) ;
                }
                if (isTrue(hedged))
                {
                    ((IDictionary<string,object>)request)["holdSide"] = ((bool) isTrue((isEqual(side, "sell")))) ? "long" : "short";
                } else
                {
                    ((IDictionary<string,object>)request)["holdSide"] = ((bool) isTrue((isEqual(side, "sell")))) ? "buy" : "sell";
                }
                if (isTrue(isStopLossTriggerOrder))
                {
                    ((IDictionary<string,object>)request)["triggerPrice"] = this.priceToPrecision(symbol, stopLossTriggerPrice);
                    ((IDictionary<string,object>)request)["planType"] = "pos_loss";
                } else if (isTrue(isTakeProfitTriggerOrder))
                {
                    ((IDictionary<string,object>)request)["triggerPrice"] = this.priceToPrecision(symbol, takeProfitTriggerPrice);
                    ((IDictionary<string,object>)request)["planType"] = "pos_profit";
                }
            } else
            {
                if (isTrue(hasStopLoss))
                {
                    object slTriggerPrice = this.safeValue2(stopLoss, "triggerPrice", "stopPrice");
                    ((IDictionary<string,object>)request)["presetStopLossPrice"] = this.priceToPrecision(symbol, slTriggerPrice);
                }
                if (isTrue(hasTakeProfit))
                {
                    object tpTriggerPrice = this.safeValue2(takeProfit, "triggerPrice", "stopPrice");
                    ((IDictionary<string,object>)request)["presetStopSurplusPrice"] = this.priceToPrecision(symbol, tpTriggerPrice);
                }
            }
            if (!isTrue(isStopLossOrTakeProfitTrigger))
            {
                if (isTrue(isEqual(marginMode, null)))
                {
                    marginMode = "cross";
                }
                object marginModeRequest = ((bool) isTrue((isEqual(marginMode, "cross")))) ? "crossed" : "isolated";
                ((IDictionary<string,object>)request)["marginMode"] = marginModeRequest;
                object requestSide = side;
                if (isTrue(reduceOnly))
                {
                    if (!isTrue(hedged))
                    {
                        ((IDictionary<string,object>)request)["reduceOnly"] = "YES";
                    } else
                    {
                        // on bitget hedge mode if the position is long the side is always buy, and if the position is short the side is always sell
                        requestSide = ((bool) isTrue((isEqual(side, "buy")))) ? "sell" : "buy";
                        ((IDictionary<string,object>)request)["tradeSide"] = "Close";
                    }
                } else
                {
                    if (isTrue(hedged))
                    {
                        ((IDictionary<string,object>)request)["tradeSide"] = "Open";
                    }
                }
                ((IDictionary<string,object>)request)["side"] = requestSide;
            }
        } else if (isTrue(isEqual(marketType, "spot")))
        {
            if (isTrue(isTrue(isStopLossOrTakeProfitTrigger) || isTrue(isStopLossOrTakeProfit)))
            {
                throw new InvalidOrder ((string)add(this.id, " createOrder() does not support stop loss/take profit orders on spot markets, only swap markets")) ;
            }
            ((IDictionary<string,object>)request)["side"] = side;
            object quantity = null;
            object planType = null;
            object createMarketBuyOrderRequiresPrice = true;
            var createMarketBuyOrderRequiresPriceparametersVariable = this.handleOptionAndParams(parameters, "createOrder", "createMarketBuyOrderRequiresPrice", true);
            createMarketBuyOrderRequiresPrice = ((IList<object>)createMarketBuyOrderRequiresPriceparametersVariable)[0];
            parameters = ((IList<object>)createMarketBuyOrderRequiresPriceparametersVariable)[1];
            if (isTrue(isTrue(isMarketOrder) && isTrue((isEqual(side, "buy")))))
            {
                planType = "total";
                object cost = this.safeNumber(parameters, "cost");
                parameters = this.omit(parameters, "cost");
                if (isTrue(!isEqual(cost, null)))
                {
                    quantity = this.costToPrecision(symbol, cost);
                } else if (isTrue(createMarketBuyOrderRequiresPrice))
                {
                    if (isTrue(isEqual(price, null)))
                    {
                        throw new InvalidOrder ((string)add(this.id, " createOrder() requires the price argument for market buy orders to calculate the total cost to spend (amount * price), alternatively set the createMarketBuyOrderRequiresPrice option or param to false and pass the cost to spend in the amount argument")) ;
                    } else
                    {
                        object amountString = this.numberToString(amount);
                        object priceString = this.numberToString(price);
                        object quoteAmount = Precise.stringMul(amountString, priceString);
                        quantity = this.costToPrecision(symbol, quoteAmount);
                    }
                } else
                {
                    quantity = this.costToPrecision(symbol, amount);
                }
            } else
            {
                planType = "amount";
                quantity = this.amountToPrecision(symbol, amount);
            }
            if (isTrue(!isEqual(clientOrderId, null)))
            {
                ((IDictionary<string,object>)request)["clientOid"] = clientOrderId;
            }
            if (isTrue(!isEqual(marginMode, null)))
            {
                ((IDictionary<string,object>)request)["loanType"] = "normal";
                if (isTrue(isTrue(isMarketOrder) && isTrue((isEqual(side, "buy")))))
                {
                    ((IDictionary<string,object>)request)["quoteSize"] = quantity;
                } else
                {
                    ((IDictionary<string,object>)request)["baseSize"] = quantity;
                }
            } else
            {
                if (isTrue(!isEqual(quantity, null)))
                {
                    ((IDictionary<string,object>)request)["size"] = quantity;
                }
                if (isTrue(!isEqual(triggerPrice, null)))
                {
                    ((IDictionary<string,object>)request)["planType"] = planType;
                    ((IDictionary<string,object>)request)["triggerType"] = triggerPriceType;
                    ((IDictionary<string,object>)request)["triggerPrice"] = this.priceToPrecision(symbol, triggerPrice);
                    if (isTrue(!isEqual(price, null)))
                    {
                        ((IDictionary<string,object>)request)["executePrice"] = this.priceToPrecision(symbol, price);
                    }
                }
            }
        } else
        {
            throw new NotSupported ((string)add(add(add(this.id, " createOrder() does not support "), marketType), " orders")) ;
        }
        return this.extend(request, parameters);
    }

    public async virtual Task<object> createUtaOrders(object orders, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object ordersRequests = new List<object>() {};
        object symbol = null;
        object marginMode = null;
        for (object i = 0; isLessThan(i, getArrayLength(orders)); postFixIncrement(ref i))
        {
            object rawOrder = getValue(orders, i);
            object marketId = this.safeString(rawOrder, "symbol");
            if (isTrue(isEqual(symbol, null)))
            {
                symbol = marketId;
            } else
            {
                if (isTrue(!isEqual(symbol, marketId)))
                {
                    throw new BadRequest ((string)add(this.id, " createOrders() requires all orders to have the same symbol")) ;
                }
            }
            object type = this.safeString(rawOrder, "type");
            object side = this.safeString(rawOrder, "side");
            object amount = this.safeValue(rawOrder, "amount");
            object price = this.safeValue(rawOrder, "price");
            object orderParams = this.safeValue(rawOrder, "params", new Dictionary<string, object>() {});
            object marginResult = this.handleMarginModeAndParams("createOrders", orderParams);
            object currentMarginMode = getValue(marginResult, 0);
            if (isTrue(!isEqual(currentMarginMode, null)))
            {
                if (isTrue(isEqual(marginMode, null)))
                {
                    marginMode = currentMarginMode;
                } else
                {
                    if (isTrue(!isEqual(marginMode, currentMarginMode)))
                    {
                        throw new BadRequest ((string)add(this.id, " createOrders() requires all orders to have the same margin mode (isolated or cross)")) ;
                    }
                }
            }
            object orderRequest = this.createUtaOrderRequest(marketId, type, side, amount, price, orderParams);
            ((IList<object>)ordersRequests).Add(orderRequest);
        }
        object market = this.market(symbol);
        object response = await this.privateUtaPostV3TradePlaceBatch(ordersRequests);
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1752810184560,
        //         "data": [
        //             {
        //                 "orderId": "1329947796441513984",
        //                 "clientOid": "1329947796483457024"
        //             },
        //         ]
        //     }
        //
        object data = this.safeList(response, "data", new List<object>() {});
        return this.parseOrders(data, market);
    }

    /**
     * @method
     * @name bitget#createOrders
     * @description create a list of trade orders (all orders should be of the same symbol)
     * @see https://www.bitget.com/api-doc/spot/trade/Batch-Place-Orders
     * @see https://www.bitget.com/api-doc/contract/trade/Batch-Order
     * @see https://www.bitget.com/api-doc/margin/isolated/trade/Isolated-Batch-Order
     * @see https://www.bitget.com/api-doc/margin/cross/trade/Cross-Batch-Order
     * @see https://www.bitget.com/api-doc/uta/trade/Place-Batch
     * @param {Array} orders list of orders to create, each object should contain the parameters required by createOrder, namely symbol, type, side, amount, price and params
     * @param {object} [params] extra parameters specific to the api endpoint
     * @param {boolean} [params.uta] set to true for the unified trading account (uta), defaults to false
     * @returns {object} an [order structure]{@link https://docs.ccxt.com/?id=order-structure}
     */
    public async override Task<object> createOrders(object orders, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object uta = null;
        var utaparametersVariable = this.handleOptionAndParams(parameters, "createOrders", "uta", false);
        uta = ((IList<object>)utaparametersVariable)[0];
        parameters = ((IList<object>)utaparametersVariable)[1];
        if (isTrue(uta))
        {
            return await this.createUtaOrders(orders, parameters);
        }
        object ordersRequests = new List<object>() {};
        object symbol = null;
        object marginMode = null;
        for (object i = 0; isLessThan(i, getArrayLength(orders)); postFixIncrement(ref i))
        {
            object rawOrder = getValue(orders, i);
            object marketId = this.safeString(rawOrder, "symbol");
            if (isTrue(isEqual(symbol, null)))
            {
                symbol = marketId;
            } else
            {
                if (isTrue(!isEqual(symbol, marketId)))
                {
                    throw new BadRequest ((string)add(this.id, " createOrders() requires all orders to have the same symbol")) ;
                }
            }
            object type = this.safeString(rawOrder, "type");
            object side = this.safeString(rawOrder, "side");
            object amount = this.safeValue(rawOrder, "amount");
            object price = this.safeValue(rawOrder, "price");
            object orderParams = this.safeValue(rawOrder, "params", new Dictionary<string, object>() {});
            object marginResult = this.handleMarginModeAndParams("createOrders", orderParams);
            object currentMarginMode = getValue(marginResult, 0);
            if (isTrue(!isEqual(currentMarginMode, null)))
            {
                if (isTrue(isEqual(marginMode, null)))
                {
                    marginMode = currentMarginMode;
                } else
                {
                    if (isTrue(!isEqual(marginMode, currentMarginMode)))
                    {
                        throw new BadRequest ((string)add(this.id, " createOrders() requires all orders to have the same margin mode (isolated or cross)")) ;
                    }
                }
            }
            object orderRequest = this.createOrderRequest(marketId, type, side, amount, price, orderParams);
            ((IList<object>)ordersRequests).Add(orderRequest);
        }
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
            { "orderList", ordersRequests },
        };
        object response = null;
        if (isTrue(isTrue((getValue(market, "swap"))) || isTrue((getValue(market, "future")))))
        {
            if (isTrue(isEqual(marginMode, null)))
            {
                marginMode = "cross";
            }
            object marginModeRequest = ((bool) isTrue((isEqual(marginMode, "cross")))) ? "crossed" : "isolated";
            ((IDictionary<string,object>)request)["marginMode"] = marginModeRequest;
            ((IDictionary<string,object>)request)["marginCoin"] = getValue(market, "settleId");
            object productType = null;
            var productTypeparametersVariable = this.handleProductTypeAndParams(market, parameters);
            productType = ((IList<object>)productTypeparametersVariable)[0];
            parameters = ((IList<object>)productTypeparametersVariable)[1];
            ((IDictionary<string,object>)request)["productType"] = productType;
            response = await this.privateMixPostV2MixOrderBatchPlaceOrder(request);
        } else if (isTrue(isEqual(marginMode, "isolated")))
        {
            response = await this.privateMarginPostV2MarginIsolatedBatchPlaceOrder(request);
        } else if (isTrue(isEqual(marginMode, "cross")))
        {
            response = await this.privateMarginPostV2MarginCrossedBatchPlaceOrder(request);
        } else
        {
            response = await this.privateSpotPostV2SpotTradeBatchOrders(request);
        }
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1700703539416,
        //         "data": {
        //             "successList": [
        //                 {
        //                     "orderId": "1111397214281175046",
        //                     "clientOid": "766d3fc3-7321-4406-a689-15c9987a2e75"
        //                 },
        //             ],
        //             "failureList": [
        //                 {
        //                     "orderId": "",
        //                     "clientOid": "d1b75cb3-cc15-4ede-ad4c-3937396f75ab",
        //                     "errorMsg": "less than the minimum amount 5 USDT",
        //                     "errorCode": "45110"
        //                 },
        //             ]
        //         }
        //     }
        //
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        object failure = this.safeValue(data, "failureList", new List<object>() {});
        object orderInfo = this.safeValue(data, "successList", new List<object>() {});
        object both = this.arrayConcat(orderInfo, failure);
        return this.parseOrders(both, market);
    }

    /**
     * @method
     * @name bitget#editOrder
     * @description edit a trade order
     * @see https://www.bitget.com/api-doc/spot/plan/Modify-Plan-Order
     * @see https://www.bitget.com/api-doc/spot/trade/Cancel-Replace-Order
     * @see https://www.bitget.com/api-doc/contract/trade/Modify-Order
     * @see https://www.bitget.com/api-doc/contract/plan/Modify-Tpsl-Order
     * @see https://www.bitget.com/api-doc/contract/plan/Modify-Plan-Order
     * @see https://www.bitget.com/api-doc/uta/trade/Modify-Order
     * @see https://www.bitget.com/api-doc/uta/strategy/Modify-Strategy-Order
     * @param {string} id cancel order id
     * @param {string} symbol unified symbol of the market to create an order in
     * @param {string} type 'market' or 'limit'
     * @param {string} side 'buy' or 'sell'
     * @param {float} amount how much you want to trade in units of the base currency
     * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {float} [params.triggerPrice] the price that a trigger order is triggered at
     * @param {float} [params.stopLossPrice] *swap only* The price at which a stop loss order is triggered at
     * @param {float} [params.takeProfitPrice] *swap only* The price at which a take profit order is triggered at
     * @param {object} [params.takeProfit] *takeProfit object in params* containing the triggerPrice at which the attached take profit order will be triggered (perpetual swap markets only)
     * @param {float} [params.takeProfit.triggerPrice] *swap only* take profit trigger price
     * @param {object} [params.stopLoss] *stopLoss object in params* containing the triggerPrice at which the attached stop loss order will be triggered (perpetual swap markets only)
     * @param {float} [params.stopLoss.triggerPrice] *swap only* stop loss trigger price
     * @param {float} [params.stopLoss.price] *swap only* the execution price for a stop loss attached to a trigger order
     * @param {float} [params.takeProfit.price] *swap only* the execution price for a take profit attached to a trigger order
     * @param {string} [params.stopLoss.type] *swap only* the type for a stop loss attached to a trigger order, 'fill_price', 'index_price' or 'mark_price', default is 'mark_price'
     * @param {string} [params.takeProfit.type] *swap only* the type for a take profit attached to a trigger order, 'fill_price', 'index_price' or 'mark_price', default is 'mark_price'
     * @param {string} [params.trailingPercent] *swap and future only* the percent to trail away from the current market price, rate can not be greater than 10
     * @param {string} [params.trailingTriggerPrice] *swap and future only* the price to trigger a trailing stop order, default uses the price argument
     * @param {string} [params.newTriggerType] *swap and future only* 'fill_price', 'mark_price' or 'index_price'
     * @param {boolean} [params.uta] set to true for the unified trading account (uta), defaults to false
     * @returns {object} an [order structure]{@link https://docs.ccxt.com/?id=order-structure}
     */
    public async override Task<object> editOrder(object id, object symbol, object type, object side, object amount = null, object price = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {};
        object clientOrderId = this.safeString2(parameters, "clientOrderId", "clientOid");
        if (isTrue(!isEqual(clientOrderId, null)))
        {
            parameters = this.omit(parameters, new List<object>() {"clientOrderId"});
            ((IDictionary<string,object>)request)["clientOid"] = clientOrderId;
        } else
        {
            ((IDictionary<string,object>)request)["orderId"] = id;
        }
        object isMarketOrder = isEqual(type, "market");
        object triggerPrice = this.safeValue2(parameters, "stopPrice", "triggerPrice");
        object isTriggerOrder = !isEqual(triggerPrice, null);
        object stopLossPrice = this.safeValue(parameters, "stopLossPrice");
        object isStopLossOrder = !isEqual(stopLossPrice, null);
        object takeProfitPrice = this.safeValue(parameters, "takeProfitPrice");
        object isTakeProfitOrder = !isEqual(takeProfitPrice, null);
        object stopLoss = this.safeValue(parameters, "stopLoss");
        object takeProfit = this.safeValue(parameters, "takeProfit");
        object hasStopLoss = !isEqual(stopLoss, null);
        object hasTakeProfit = !isEqual(takeProfit, null);
        object trailingTriggerPrice = this.safeString(parameters, "trailingTriggerPrice", this.numberToString(price));
        object trailingPercent = this.safeString2(parameters, "trailingPercent", "newCallbackRatio");
        object isTrailingPercentOrder = !isEqual(trailingPercent, null);
        if (isTrue(isGreaterThan(this.sum(isTriggerOrder, isStopLossOrder, isTakeProfitOrder, isTrailingPercentOrder), 1)))
        {
            throw new ExchangeError ((string)add(this.id, " editOrder() params can only contain one of triggerPrice, stopLossPrice, takeProfitPrice, trailingPercent")) ;
        }
        parameters = this.omit(parameters, new List<object>() {"stopPrice", "triggerType", "stopLossPrice", "takeProfitPrice", "stopLoss", "takeProfit", "clientOrderId", "trailingTriggerPrice", "trailingPercent"});
        object response = null;
        object productType = null;
        object uta = null;
        var productTypeparametersVariable = this.handleProductTypeAndParams(market, parameters);
        productType = ((IList<object>)productTypeparametersVariable)[0];
        parameters = ((IList<object>)productTypeparametersVariable)[1];
        var utaparametersVariable = this.handleOptionAndParams(parameters, "editOrder", "uta", false);
        uta = ((IList<object>)utaparametersVariable)[0];
        parameters = ((IList<object>)utaparametersVariable)[1];
        if (isTrue(uta))
        {
            if (isTrue(!isEqual(amount, null)))
            {
                ((IDictionary<string,object>)request)["qty"] = this.amountToPrecision(symbol, amount);
            }
            if (isTrue(isTrue(isStopLossOrder) || isTrue(isTakeProfitOrder)))
            {
                if (isTrue(isStopLossOrder))
                {
                    object slType = this.safeString(parameters, "slTriggerBy", "mark");
                    ((IDictionary<string,object>)request)["slTriggerBy"] = slType;
                    ((IDictionary<string,object>)request)["stopLoss"] = this.priceToPrecision(symbol, stopLossPrice);
                    if (isTrue(!isEqual(price, null)))
                    {
                        ((IDictionary<string,object>)request)["slLimitPrice"] = this.priceToPrecision(symbol, price);
                        ((IDictionary<string,object>)request)["slOrderType"] = this.safeString(parameters, "slOrderType", "limit");
                    } else
                    {
                        ((IDictionary<string,object>)request)["slOrderType"] = this.safeString(parameters, "slOrderType", "market");
                    }
                } else if (isTrue(isTakeProfitOrder))
                {
                    object tpType = this.safeString(parameters, "tpTriggerBy", "mark");
                    ((IDictionary<string,object>)request)["tpTriggerBy"] = tpType;
                    ((IDictionary<string,object>)request)["takeProfit"] = this.priceToPrecision(symbol, takeProfitPrice);
                    if (isTrue(!isEqual(price, null)))
                    {
                        ((IDictionary<string,object>)request)["tpLimitPrice"] = this.priceToPrecision(symbol, price);
                        ((IDictionary<string,object>)request)["tpOrderType"] = this.safeString(parameters, "tpOrderType", "limit");
                    } else
                    {
                        ((IDictionary<string,object>)request)["tpOrderType"] = this.safeString(parameters, "tpOrderType", "market");
                    }
                }
                parameters = this.omit(parameters, new List<object>() {"stopLossPrice", "takeProfitPrice"});
                response = await this.privateUtaPostV3TradeModifyStrategyOrder(this.extend(request, parameters));
            } else
            {
                if (isTrue(!isEqual(price, null)))
                {
                    ((IDictionary<string,object>)request)["price"] = this.priceToPrecision(symbol, price);
                }
                response = await this.privateUtaPostV3TradeModifyOrder(this.extend(request, parameters));
            }
        } else if (isTrue(getValue(market, "spot")))
        {
            object cost = this.safeString(parameters, "cost");
            parameters = this.omit(parameters, "cost");
            object editMarketBuyOrderRequiresPrice = this.safeBool(this.options, "editMarketBuyOrderRequiresPrice", true);
            if (isTrue(isTrue(isTrue((isTrue(editMarketBuyOrderRequiresPrice) || isTrue((!isEqual(cost, null))))) && isTrue(isMarketOrder)) && isTrue((isEqual(side, "buy")))))
            {
                if (isTrue(isTrue(isEqual(price, null)) && isTrue(isEqual(cost, null))))
                {
                    throw new InvalidOrder ((string)add(this.id, " editOrder() requires price argument for market buy orders on spot markets to calculate the total amount to spend (amount * price), alternatively provide `cost` in the params")) ;
                } else
                {
                    object amountString = this.numberToString(amount);
                    object priceString = this.numberToString(price);
                    object finalCost = ((bool) isTrue((isEqual(cost, null)))) ? (Precise.stringMul(amountString, priceString)) : cost;
                    ((IDictionary<string,object>)request)["size"] = this.priceToPrecision(symbol, finalCost);
                }
            } else
            {
                ((IDictionary<string,object>)request)["size"] = this.amountToPrecision(symbol, amount);
            }
            ((IDictionary<string,object>)request)["orderType"] = type;
            if (isTrue(!isEqual(triggerPrice, null)))
            {
                ((IDictionary<string,object>)request)["triggerPrice"] = this.priceToPrecision(symbol, triggerPrice);
                ((IDictionary<string,object>)request)["executePrice"] = this.priceToPrecision(symbol, price);
            } else
            {
                ((IDictionary<string,object>)request)["price"] = this.priceToPrecision(symbol, price);
            }
            if (isTrue(!isEqual(triggerPrice, null)))
            {
                response = await this.privateSpotPostV2SpotTradeModifyPlanOrder(this.extend(request, parameters));
            } else
            {
                ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
                response = await this.privateSpotPostV2SpotTradeCancelReplaceOrder(this.extend(request, parameters));
            }
        } else
        {
            if (isTrue(isTrue((!isTrue(getValue(market, "swap")))) && isTrue((!isTrue(getValue(market, "future"))))))
            {
                throw new NotSupported ((string)add(add(add(this.id, " editOrder() does not support "), getValue(market, "type")), " orders")) ;
            }
            ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
            ((IDictionary<string,object>)request)["productType"] = productType;
            if (isTrue(!isTrue(isTakeProfitOrder) && !isTrue(isStopLossOrder)))
            {
                if (isTrue(!isEqual(amount, null)))
                {
                    ((IDictionary<string,object>)request)["newSize"] = this.amountToPrecision(symbol, amount);
                }
                if (isTrue(isTrue((!isEqual(price, null))) && !isTrue(isTrailingPercentOrder)))
                {
                    ((IDictionary<string,object>)request)["newPrice"] = this.priceToPrecision(symbol, price);
                }
            }
            if (isTrue(isTrailingPercentOrder))
            {
                if (!isTrue(isMarketOrder))
                {
                    throw new BadRequest ((string)add(this.id, " editOrder() bitget trailing orders must be market orders")) ;
                }
                if (isTrue(!isEqual(trailingTriggerPrice, null)))
                {
                    ((IDictionary<string,object>)request)["newTriggerPrice"] = this.priceToPrecision(symbol, trailingTriggerPrice);
                }
                ((IDictionary<string,object>)request)["newCallbackRatio"] = trailingPercent;
                response = await this.privateMixPostV2MixOrderModifyPlanOrder(this.extend(request, parameters));
            } else if (isTrue(isTrue(isTakeProfitOrder) || isTrue(isStopLossOrder)))
            {
                ((IDictionary<string,object>)request)["marginCoin"] = getValue(market, "settleId");
                ((IDictionary<string,object>)request)["size"] = this.amountToPrecision(symbol, amount);
                if (isTrue(!isEqual(price, null)))
                {
                    ((IDictionary<string,object>)request)["executePrice"] = this.priceToPrecision(symbol, price);
                }
                if (isTrue(isStopLossOrder))
                {
                    ((IDictionary<string,object>)request)["triggerPrice"] = this.priceToPrecision(symbol, stopLossPrice);
                } else if (isTrue(isTakeProfitOrder))
                {
                    ((IDictionary<string,object>)request)["triggerPrice"] = this.priceToPrecision(symbol, takeProfitPrice);
                }
                response = await this.privateMixPostV2MixOrderModifyTpslOrder(this.extend(request, parameters));
            } else if (isTrue(isTriggerOrder))
            {
                ((IDictionary<string,object>)request)["newTriggerPrice"] = this.priceToPrecision(symbol, triggerPrice);
                if (isTrue(hasStopLoss))
                {
                    object slTriggerPrice = this.safeNumber2(stopLoss, "triggerPrice", "stopPrice");
                    ((IDictionary<string,object>)request)["newStopLossTriggerPrice"] = this.priceToPrecision(symbol, slTriggerPrice);
                    object slPrice = this.safeNumber(stopLoss, "price");
                    ((IDictionary<string,object>)request)["newStopLossExecutePrice"] = this.priceToPrecision(symbol, slPrice);
                    object slType = this.safeString(stopLoss, "type", "mark_price");
                    ((IDictionary<string,object>)request)["newStopLossTriggerType"] = slType;
                }
                if (isTrue(hasTakeProfit))
                {
                    object tpTriggerPrice = this.safeNumber2(takeProfit, "triggerPrice", "stopPrice");
                    ((IDictionary<string,object>)request)["newSurplusTriggerPrice"] = this.priceToPrecision(symbol, tpTriggerPrice);
                    object tpPrice = this.safeNumber(takeProfit, "price");
                    ((IDictionary<string,object>)request)["newStopSurplusExecutePrice"] = this.priceToPrecision(symbol, tpPrice);
                    object tpType = this.safeString(takeProfit, "type", "mark_price");
                    ((IDictionary<string,object>)request)["newStopSurplusTriggerType"] = tpType;
                }
                response = await this.privateMixPostV2MixOrderModifyPlanOrder(this.extend(request, parameters));
            } else
            {
                object defaultNewClientOrderId = this.uuid();
                object newClientOrderId = this.safeString2(parameters, "newClientOid", "newClientOrderId", defaultNewClientOrderId);
                parameters = this.omit(parameters, "newClientOrderId");
                ((IDictionary<string,object>)request)["newClientOid"] = newClientOrderId;
                if (isTrue(hasStopLoss))
                {
                    object slTriggerPrice = this.safeValue2(stopLoss, "triggerPrice", "stopPrice");
                    ((IDictionary<string,object>)request)["newPresetStopLossPrice"] = this.priceToPrecision(symbol, slTriggerPrice);
                }
                if (isTrue(hasTakeProfit))
                {
                    object tpTriggerPrice = this.safeValue2(takeProfit, "triggerPrice", "stopPrice");
                    ((IDictionary<string,object>)request)["newPresetStopSurplusPrice"] = this.priceToPrecision(symbol, tpTriggerPrice);
                }
                response = await this.privateMixPostV2MixOrderModifyOrder(this.extend(request, parameters));
            }
        }
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1700708275737,
        //         "data": {
        //             "clientOid": "abe95dbe-6081-4a6f-a2d3-ae49601cd459",
        //             "orderId": null
        //         }
        //     }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        return this.parseOrder(data, market);
    }

    /**
     * @method
     * @name bitget#cancelOrder
     * @description cancels an open order
     * @see https://www.bitget.com/api-doc/spot/trade/Cancel-Order
     * @see https://www.bitget.com/api-doc/spot/plan/Cancel-Plan-Order
     * @see https://www.bitget.com/api-doc/contract/trade/Cancel-Order
     * @see https://www.bitget.com/api-doc/contract/plan/Cancel-Plan-Order
     * @see https://www.bitget.com/api-doc/margin/cross/trade/Cross-Cancel-Order
     * @see https://www.bitget.com/api-doc/margin/isolated/trade/Isolated-Cancel-Order
     * @see https://www.bitget.com/api-doc/uta/trade/Cancel-Order
     * @see https://www.bitget.com/api-doc/uta/strategy/Cancel-Strategy-Order
     * @param {string} id order id
     * @param {string} symbol unified symbol of the market the order was made in
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.marginMode] 'isolated' or 'cross' for spot margin trading
     * @param {boolean} [params.trigger] set to true for canceling trigger orders
     * @param {string} [params.planType] *swap only* either profit_plan, loss_plan, normal_plan, pos_profit, pos_loss, moving_plan or track_plan
     * @param {boolean} [params.trailing] set to true if you want to cancel a trailing order
     * @param {boolean} [params.uta] set to true for the unified trading account (uta), defaults to false
     * @param {string} [params.clientOrderId] the clientOrderId of the order, id does not need to be provided if clientOrderId is provided
     * @returns {object} An [order structure]{@link https://docs.ccxt.com/?id=order-structure}
     */
    public async override Task<object> cancelOrder(object id, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " cancelOrder() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object marginMode = null;
        object response = null;
        var marginModeparametersVariable = this.handleMarginModeAndParams("cancelOrder", parameters);
        marginMode = ((IList<object>)marginModeparametersVariable)[0];
        parameters = ((IList<object>)marginModeparametersVariable)[1];
        object request = new Dictionary<string, object>() {};
        object trailing = this.safeValue(parameters, "trailing");
        object trigger = this.safeValue2(parameters, "stop", "trigger");
        parameters = this.omit(parameters, new List<object>() {"stop", "trigger", "trailing"});
        if (!isTrue((isTrue(getValue(market, "spot")) && isTrue(trigger))))
        {
            ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
        }
        object uta = null;
        var utaparametersVariable = this.handleOptionAndParams(parameters, "cancelOrder", "uta", false);
        uta = ((IList<object>)utaparametersVariable)[0];
        parameters = ((IList<object>)utaparametersVariable)[1];
        object isPlanOrder = isTrue(trigger) || isTrue(trailing);
        object isContract = isTrue(getValue(market, "swap")) || isTrue(getValue(market, "future"));
        object isContractTriggerEndpoint = isTrue(isTrue(isContract) && isTrue(isPlanOrder)) && !isTrue(uta);
        object clientOrderId = this.safeString2(parameters, "clientOrderId", "clientOid");
        if (isTrue(isContractTriggerEndpoint))
        {
            object orderIdList = new List<object>() {};
            object orderId = new Dictionary<string, object>() {};
            if (isTrue(!isEqual(clientOrderId, null)))
            {
                parameters = this.omit(parameters, "clientOrderId");
                ((IDictionary<string,object>)orderId)["clientOid"] = clientOrderId;
            } else
            {
                ((IDictionary<string,object>)orderId)["orderId"] = id;
            }
            ((IList<object>)orderIdList).Add(orderId);
            ((IDictionary<string,object>)request)["orderIdList"] = orderIdList;
        } else
        {
            if (isTrue(!isEqual(clientOrderId, null)))
            {
                parameters = this.omit(parameters, "clientOrderId");
                ((IDictionary<string,object>)request)["clientOid"] = clientOrderId;
            } else
            {
                ((IDictionary<string,object>)request)["orderId"] = id;
            }
        }
        if (isTrue(uta))
        {
            if (isTrue(trigger))
            {
                response = await this.privateUtaPostV3TradeCancelStrategyOrder(this.extend(request, parameters));
            } else
            {
                response = await this.privateUtaPostV3TradeCancelOrder(this.extend(request, parameters));
            }
        } else if (isTrue(isTrue((getValue(market, "swap"))) || isTrue((getValue(market, "future")))))
        {
            object productType = null;
            var productTypeparametersVariable = this.handleProductTypeAndParams(market, parameters);
            productType = ((IList<object>)productTypeparametersVariable)[0];
            parameters = ((IList<object>)productTypeparametersVariable)[1];
            ((IDictionary<string,object>)request)["productType"] = productType;
            if (isTrue(trailing))
            {
                object planType = this.safeString(parameters, "planType", "track_plan");
                ((IDictionary<string,object>)request)["planType"] = planType;
                response = await this.privateMixPostV2MixOrderCancelPlanOrder(this.extend(request, parameters));
            } else if (isTrue(trigger))
            {
                response = await this.privateMixPostV2MixOrderCancelPlanOrder(this.extend(request, parameters));
            } else
            {
                response = await this.privateMixPostV2MixOrderCancelOrder(this.extend(request, parameters));
            }
        } else if (isTrue(getValue(market, "spot")))
        {
            if (isTrue(!isEqual(marginMode, null)))
            {
                if (isTrue(isEqual(marginMode, "isolated")))
                {
                    response = await this.privateMarginPostV2MarginIsolatedCancelOrder(this.extend(request, parameters));
                } else if (isTrue(isEqual(marginMode, "cross")))
                {
                    response = await this.privateMarginPostV2MarginCrossedCancelOrder(this.extend(request, parameters));
                }
            } else
            {
                if (isTrue(trigger))
                {
                    response = await this.privateSpotPostV2SpotTradeCancelPlanOrder(this.extend(request, parameters));
                } else
                {
                    response = await this.privateSpotPostV2SpotTradeCancelOrder(this.extend(request, parameters));
                }
            }
        } else
        {
            throw new NotSupported ((string)add(add(add(this.id, " cancelOrder() does not support "), getValue(market, "type")), " orders")) ;
        }
        //
        // spot, swap, future and spot margin
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1697690413177,
        //         "data": {
        //             "orderId": "1098758604547850241",
        //             "clientOid": "1098758604585598977"
        //         }
        //     }
        //
        // swap trigger
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1700711311791,
        //         "data": {
        //             "successList": [
        //                 {
        //                     "clientOid": "1111428059067125760",
        //                     "orderId": "1111428059067125761"
        //                 }
        //             ],
        //             "failureList": []
        //         }
        //     }
        //
        // spot trigger
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1700711728063,
        //         "data": {
        //             "result": "success"
        //         }
        //     }
        //
        // uta trigger
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": "1753058267399",
        //         "data": null
        //     }
        //
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        object order = null;
        if (isTrue(isContractTriggerEndpoint))
        {
            object orderInfo = this.safeValue(data, "successList", new List<object>() {});
            order = getValue(orderInfo, 0);
        } else
        {
            if (isTrue(isTrue(uta) && isTrue(trigger)))
            {
                order = response;
            } else
            {
                order = data;
            }
        }
        return this.parseOrder(order, market);
    }

    public async virtual Task<object> cancelUtaOrders(object ids, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " cancelOrders() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object productType = null;
        var productTypeparametersVariable = this.handleProductTypeAndParams(market, parameters);
        productType = ((IList<object>)productTypeparametersVariable)[0];
        parameters = ((IList<object>)productTypeparametersVariable)[1];
        object requestList = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(ids)); postFixIncrement(ref i))
        {
            object individualId = getValue(ids, i);
            object order = new Dictionary<string, object>() {
                { "orderId", individualId },
                { "symbol", getValue(market, "id") },
                { "category", productType },
            };
            ((IList<object>)requestList).Add(order);
        }
        object response = await this.privateUtaPostV3TradeCancelBatch(requestList);
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1752813731517,
        //         "data": [
        //             {
        //                 "orderId": "1329948909442023424",
        //                 "clientOid": "1329948909446217728"
        //             },
        //         ]
        //     }
        //
        object data = this.safeList(response, "data", new List<object>() {});
        return this.parseOrders(data, market);
    }

    /**
     * @method
     * @name bitget#cancelOrders
     * @description cancel multiple orders
     * @see https://www.bitget.com/api-doc/spot/trade/Batch-Cancel-Orders
     * @see https://www.bitget.com/api-doc/contract/trade/Batch-Cancel-Orders
     * @see https://www.bitget.com/api-doc/contract/plan/Cancel-Plan-Order
     * @see https://www.bitget.com/api-doc/margin/cross/trade/Cross-Batch-Cancel-Order
     * @see https://www.bitget.com/api-doc/margin/isolated/trade/Isolated-Batch-Cancel-Orders
     * @see https://www.bitget.com/api-doc/uta/trade/Cancel-Batch
     * @param {string[]} ids order ids
     * @param {string} symbol unified market symbol, default is undefined
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.marginMode] 'isolated' or 'cross' for spot margin trading
     * @param {boolean} [params.trigger] *contract only* set to true for canceling trigger orders
     * @param {boolean} [params.uta] set to true for the unified trading account (uta), defaults to false
     * @returns {object} an array of [order structures]{@link https://docs.ccxt.com/?id=order-structure}
     */
    public async override Task<object> cancelOrders(object ids, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " cancelOrders() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object uta = null;
        var utaparametersVariable = this.handleOptionAndParams(parameters, "cancelOrders", "uta", false);
        uta = ((IList<object>)utaparametersVariable)[0];
        parameters = ((IList<object>)utaparametersVariable)[1];
        if (isTrue(uta))
        {
            return await this.cancelUtaOrders(ids, symbol, parameters);
        }
        object marginMode = null;
        var marginModeparametersVariable = this.handleMarginModeAndParams("cancelOrders", parameters);
        marginMode = ((IList<object>)marginModeparametersVariable)[0];
        parameters = ((IList<object>)marginModeparametersVariable)[1];
        object trigger = this.safeValue2(parameters, "stop", "trigger");
        parameters = this.omit(parameters, new List<object>() {"stop", "trigger"});
        object orderIdList = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(ids)); postFixIncrement(ref i))
        {
            object individualId = getValue(ids, i);
            object orderId = new Dictionary<string, object>() {
                { "orderId", individualId },
            };
            ((IList<object>)orderIdList).Add(orderId);
        }
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        if (isTrue(isTrue(getValue(market, "spot")) && isTrue((isEqual(marginMode, null)))))
        {
            ((IDictionary<string,object>)request)["orderList"] = orderIdList;
        } else
        {
            ((IDictionary<string,object>)request)["orderIdList"] = orderIdList;
        }
        object response = null;
        if (isTrue(getValue(market, "spot")))
        {
            if (isTrue(!isEqual(marginMode, null)))
            {
                if (isTrue(isEqual(marginMode, "cross")))
                {
                    response = await this.privateMarginPostV2MarginCrossedBatchCancelOrder(this.extend(request, parameters));
                } else
                {
                    response = await this.privateMarginPostV2MarginIsolatedBatchCancelOrder(this.extend(request, parameters));
                }
            } else
            {
                response = await this.privateSpotPostV2SpotTradeBatchCancelOrder(this.extend(request, parameters));
            }
        } else
        {
            object productType = null;
            var productTypeparametersVariable = this.handleProductTypeAndParams(market, parameters);
            productType = ((IList<object>)productTypeparametersVariable)[0];
            parameters = ((IList<object>)productTypeparametersVariable)[1];
            ((IDictionary<string,object>)request)["productType"] = productType;
            if (isTrue(trigger))
            {
                response = await this.privateMixPostV2MixOrderCancelPlanOrder(this.extend(request, parameters));
            } else
            {
                response = await this.privateMixPostV2MixOrderBatchCancelOrders(this.extend(request, parameters));
            }
        }
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": "1680008815965",
        //         "data": {
        //             "successList": [
        //                 {
        //                     "orderId": "1024598257429823488",
        //                     "clientOid": "876493ce-c287-4bfc-9f4a-8b1905881313"
        //                 },
        //             ],
        //             "failureList": []
        //         }
        //     }
        //
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        object orders = this.safeList(data, "successList", new List<object>() {});
        return this.parseOrders(orders, market);
    }

    /**
     * @method
     * @name bitget#cancelAllOrders
     * @description cancel all open orders
     * @see https://www.bitget.com/api-doc/spot/trade/Cancel-Symbol-Orders
     * @see https://www.bitget.com/api-doc/spot/plan/Batch-Cancel-Plan-Order
     * @see https://www.bitget.com/api-doc/contract/trade/Batch-Cancel-Orders
     * @see https://www.bitget.com/api-doc/margin/cross/trade/Cross-Batch-Cancel-Order
     * @see https://www.bitget.com/api-doc/margin/isolated/trade/Isolated-Batch-Cancel-Orders
     * @param {string} symbol unified market symbol
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.marginMode] 'isolated' or 'cross' for spot margin trading
     * @param {boolean} [params.trigger] *contract only* set to true for canceling trigger orders
     * @param {boolean} [params.uta] set to true for the unified trading account (uta), defaults to false
     * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/?id=order-structure}
     */
    public async override Task<object> cancelAllOrders(object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " cancelAllOrders() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object marginMode = null;
        var marginModeparametersVariable = this.handleMarginModeAndParams("cancelAllOrders", parameters);
        marginMode = ((IList<object>)marginModeparametersVariable)[0];
        parameters = ((IList<object>)marginModeparametersVariable)[1];
        object productType = null;
        var productTypeparametersVariable = this.handleProductTypeAndParams(market, parameters);
        productType = ((IList<object>)productTypeparametersVariable)[0];
        parameters = ((IList<object>)productTypeparametersVariable)[1];
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object trigger = this.safeBool2(parameters, "stop", "trigger");
        parameters = this.omit(parameters, new List<object>() {"stop", "trigger"});
        object response = null;
        object uta = null;
        var utaparametersVariable = this.handleOptionAndParams(parameters, "cancelAllOrders", "uta", false);
        uta = ((IList<object>)utaparametersVariable)[0];
        parameters = ((IList<object>)utaparametersVariable)[1];
        if (isTrue(uta))
        {
            if (isTrue(isEqual(productType, "SPOT")))
            {
                if (isTrue(!isEqual(marginMode, null)))
                {
                    productType = "MARGIN";
                }
            }
            ((IDictionary<string,object>)request)["category"] = productType;
            response = await this.privateUtaPostV3TradeCancelSymbolOrder(this.extend(request, parameters));
        } else if (isTrue(getValue(market, "spot")))
        {
            if (isTrue(!isEqual(marginMode, null)))
            {
                throw new NotSupported ((string)add(this.id, " cancelAllOrders() does not support margin markets, you can use cancelOrders() instead")) ;
            } else
            {
                if (isTrue(trigger))
                {
                    object stopRequest = new Dictionary<string, object>() {
                        { "symbolList", new List<object>() {getValue(market, "id")} },
                    };
                    response = await this.privateSpotPostV2SpotTradeBatchCancelPlanOrder(this.extend(stopRequest, parameters));
                } else
                {
                    response = await this.privateSpotPostV2SpotTradeCancelSymbolOrder(this.extend(request, parameters));
                }
                //
                //     {
                //         "code": "00000",
                //         "msg": "success",
                //         "requestTime": 1700716953996,
                //         "data": {
                //             "symbol": "BTCUSDT"
                //         }
                //     }
                //
                object timestamp = this.safeInteger(response, "requestTime");
                object responseData = this.safeDict(response, "data");
                object marketId = this.safeString(responseData, "symbol");
                return new List<object> {this.safeOrder(new Dictionary<string, object>() {
    { "info", response },
    { "symbol", this.safeSymbol(marketId, null, null, "spot") },
    { "timestamp", timestamp },
    { "datetime", this.iso8601(timestamp) },
})};
            }
        } else
        {
            ((IDictionary<string,object>)request)["productType"] = productType;
            if (isTrue(trigger))
            {
                response = await this.privateMixPostV2MixOrderCancelPlanOrder(this.extend(request, parameters));
            } else
            {
                response = await this.privateMixPostV2MixOrderBatchCancelOrders(this.extend(request, parameters));
            }
        }
        object data = this.safeDict(response, "data");
        object resultList = this.safeListN(data, new List<object>() {"resultList", "successList", "list"});
        object failureList = this.safeList2(data, "failure", "failureList");
        object responseList = null;
        if (isTrue(isTrue((!isEqual(resultList, null))) && isTrue((!isEqual(failureList, null)))))
        {
            responseList = this.arrayConcat(resultList, failureList);
        } else
        {
            responseList = resultList;
        }
        return this.parseOrders(responseList);
    }

    /**
     * @method
     * @name bitget#fetchOrder
     * @description fetches information on an order made by the user
     * @see https://www.bitget.com/api-doc/spot/trade/Get-Order-Info
     * @see https://www.bitget.com/api-doc/contract/trade/Get-Order-Details
     * @see https://www.bitget.com/api-doc/uta/trade/Get-Order-Details
     * @param {string} id the order id
     * @param {string} symbol unified symbol of the market the order was made in
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {boolean} [params.uta] set to true for the unified trading account (uta), defaults to false
     * @param {string} [params.clientOrderId] the clientOrderId of the order, id does not need to be provided if clientOrderId is provided
     * @returns {object} An [order structure]{@link https://docs.ccxt.com/?id=order-structure}
     */
    public async override Task<object> fetchOrder(object id, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchOrder() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {};
        object clientOrderId = this.safeString2(parameters, "clientOrderId", "clientOid");
        if (isTrue(!isEqual(clientOrderId, null)))
        {
            parameters = this.omit(parameters, new List<object>() {"clientOrderId"});
            ((IDictionary<string,object>)request)["clientOid"] = clientOrderId;
        } else
        {
            ((IDictionary<string,object>)request)["orderId"] = id;
        }
        object response = null;
        object uta = null;
        var utaparametersVariable = this.handleOptionAndParams(parameters, "fetchOrder", "uta", false);
        uta = ((IList<object>)utaparametersVariable)[0];
        parameters = ((IList<object>)utaparametersVariable)[1];
        if (isTrue(uta))
        {
            response = await this.privateUtaGetV3TradeOrderInfo(this.extend(request, parameters));
        } else if (isTrue(getValue(market, "spot")))
        {
            response = await this.privateSpotGetV2SpotTradeOrderInfo(this.extend(request, parameters));
        } else if (isTrue(isTrue(getValue(market, "swap")) || isTrue(getValue(market, "future"))))
        {
            ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
            object productType = null;
            var productTypeparametersVariable = this.handleProductTypeAndParams(market, parameters);
            productType = ((IList<object>)productTypeparametersVariable)[0];
            parameters = ((IList<object>)productTypeparametersVariable)[1];
            ((IDictionary<string,object>)request)["productType"] = productType;
            response = await this.privateMixGetV2MixOrderDetail(this.extend(request, parameters));
        } else
        {
            throw new NotSupported ((string)add(add(add(this.id, " fetchOrder() does not support "), getValue(market, "type")), " orders")) ;
        }
        //
        // spot
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1700719076263,
        //         "data": [
        //             {
        //                 "userId": "7264631750",
        //                 "symbol": "BTCUSDT",
        //                 "orderId": "1111461743123927040",
        //                 "clientOid": "63f95110-93b5-4309-8f77-46339f1bcf3c",
        //                 "price": "25000.0000000000000000",
        //                 "size": "0.0002000000000000",
        //                 "orderType": "limit",
        //                 "side": "buy",
        //                 "status": "live",
        //                 "priceAvg": "0",
        //                 "baseVolume": "0.0000000000000000",
        //                 "quoteVolume": "0.0000000000000000",
        //                 "enterPointSource": "API",
        //                 "feeDetail": "",
        //                 "orderSource": "normal",
        //                 "cTime": "1700719050198",
        //                 "uTime": "1700719050198"
        //             }
        //         ]
        //     }
        //
        // swap and future
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1700719918781,
        //         "data": {
        //             "symbol": "BTCUSDT",
        //             "size": "0.001",
        //             "orderId": "1111465253393825792",
        //             "clientOid": "1111465253431574529",
        //             "baseVolume": "0",
        //             "fee": "0",
        //             "price": "27000",
        //             "priceAvg": "",
        //             "state": "live",
        //             "side": "buy",
        //             "force": "gtc",
        //             "totalProfits": "0",
        //             "posSide": "long",
        //             "marginCoin": "USDT",
        //             "presetStopSurplusPrice": "",
        //             "presetStopLossPrice": "",
        //             "quoteVolume": "0",
        //             "orderType": "limit",
        //             "leverage": "20",
        //             "marginMode": "crossed",
        //             "reduceOnly": "NO",
        //             "enterPointSource": "API",
        //             "tradeSide": "open",
        //             "posMode": "hedge_mode",
        //             "orderSource": "normal",
        //             "cTime": "1700719887120",
        //             "uTime": "1700719887120"
        //         }
        //     }
        //
        // uta
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1750496858333,
        //         "data": {
        //             "orderId": "1320244799629316096",
        //             "clientOid": "1320244799633510400",
        //             "category": "USDT-FUTURES",
        //             "symbol": "BTCUSDT",
        //             "orderType": "limit",
        //             "side": "buy",
        //             "price": "50000",
        //             "qty": "0.001",
        //             "amount": "0",
        //             "cumExecQty": "0",
        //             "cumExecValue": "0",
        //             "avgPrice": "0",
        //             "timeInForce": "gtc",
        //             "orderStatus": "live",
        //             "posSide": "long",
        //             "holdMode": "hedge_mode",
        //             "reduceOnly": "NO",
        //             "feeDetail": [{
        //                 "feeCoin": "",
        //                 "fee": ""
        //             }],
        //             "createdTime": "1750496809871",
        //             "updatedTime": "1750496809886",
        //             "cancelReason": "",
        //             "execType": "normal",
        //             "stpMode": "none",
        //             "tpTriggerBy": null,
        //             "slTriggerBy": null,
        //             "takeProfit": null,
        //             "stopLoss": null,
        //             "tpOrderType": null,
        //             "slOrderType": null,
        //             "tpLimitPrice": null,
        //             "slLimitPrice": null
        //         }
        //     }
        //
        if (isTrue(!isTrue(uta) && isTrue(((response is string)))))
        {
            response = parseJson(response);
        }
        object data = this.safeDict(response, "data");
        if (isTrue((!isEqual(data, null))))
        {
            if (!isTrue(((data is IList<object>) || (data.GetType().IsGenericType && data.GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>))))))
            {
                return this.parseOrder(data, market);
            }
        }
        object dataList = this.safeList(response, "data", new List<object>() {});
        object dataListLength = getArrayLength(dataList);
        if (isTrue(isEqual(dataListLength, 0)))
        {
            throw new OrderNotFound ((string)add(add(add(add(this.id, " fetchOrder() could not find order id "), id), " in "), this.json(response))) ;
        }
        object first = this.safeDict(dataList, 0, new Dictionary<string, object>() {});
        return this.parseOrder(first, market);
    }

    /**
     * @method
     * @name bitget#fetchOpenOrders
     * @description fetch all unfilled currently open orders
     * @see https://www.bitget.com/api-doc/spot/trade/Get-Unfilled-Orders
     * @see https://www.bitget.com/api-doc/spot/plan/Get-Current-Plan-Order
     * @see https://www.bitget.com/api-doc/contract/trade/Get-Orders-Pending
     * @see https://www.bitget.com/api-doc/contract/plan/get-orders-plan-pending
     * @see https://www.bitget.com/api-doc/margin/cross/trade/Get-Cross-Open-Orders
     * @see https://www.bitget.com/api-doc/margin/isolated/trade/Isolated-Open-Orders
     * @see https://www.bitget.com/api-doc/uta/strategy/Get-Unfilled-Strategy-Orders
     * @param {string} symbol unified market symbol
     * @param {int} [since] the earliest time in ms to fetch open orders for
     * @param {int} [limit] the maximum number of open order structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {int} [params.until] the latest time in ms to fetch orders for
     * @param {string} [params.planType] *contract stop only* 'normal_plan': average trigger order, 'profit_loss': opened tp/sl orders, 'track_plan': trailing stop order, default is 'normal_plan'
     * @param {boolean} [params.trigger] set to true for fetching trigger orders
     * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [available parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
     * @param {string} [params.isPlan] *swap only* 'plan' for stop orders and 'profit_loss' for tp/sl orders, default is 'plan'
     * @param {boolean} [params.trailing] set to true if you want to fetch trailing orders
     * @param {boolean} [params.uta] set to true for the unified trading account (uta), defaults to false
     * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/?id=order-structure}
     */
    public async override Task<object> fetchOpenOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = null;
        object type = null;
        object request = new Dictionary<string, object>() {};
        object marginMode = null;
        var marginModeparametersVariable = this.handleMarginModeAndParams("fetchOpenOrders", parameters);
        marginMode = ((IList<object>)marginModeparametersVariable)[0];
        parameters = ((IList<object>)marginModeparametersVariable)[1];
        object uta = null;
        var utaparametersVariable = this.handleOptionAndParams(parameters, "fetchOpenOrders", "uta", false);
        uta = ((IList<object>)utaparametersVariable)[0];
        parameters = ((IList<object>)utaparametersVariable)[1];
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
            object defaultType = this.safeString2(this.options, "fetchOpenOrders", "defaultType", "spot");
            object marketType = ((bool) isTrue((inOp(market, "type")))) ? getValue(market, "type") : defaultType;
            type = this.safeString(parameters, "type", marketType);
        } else
        {
            object defaultType = this.safeString2(this.options, "fetchOpenOrders", "defaultType", "spot");
            type = this.safeString(parameters, "type", defaultType);
        }
        object paginate = false;
        var paginateparametersVariable = this.handleOptionAndParams(parameters, "fetchOpenOrders", "paginate");
        paginate = ((IList<object>)paginateparametersVariable)[0];
        parameters = ((IList<object>)paginateparametersVariable)[1];
        if (isTrue(paginate))
        {
            object cursorReceived = null;
            object cursorSent = null;
            if (isTrue(uta))
            {
                cursorReceived = "cursor";
                cursorSent = "cursor";
            } else if (isTrue(isEqual(type, "spot")))
            {
                if (isTrue(!isEqual(marginMode, null)))
                {
                    cursorReceived = "minId";
                    cursorSent = "idLessThan";
                }
            } else
            {
                cursorReceived = "endId";
                cursorSent = "idLessThan";
            }
            return await this.fetchPaginatedCallCursor("fetchOpenOrders", symbol, since, limit, parameters, cursorReceived, cursorSent);
        }
        object response = null;
        object trailing = this.safeBool(parameters, "trailing");
        object trigger = this.safeBool2(parameters, "stop", "trigger");
        object planTypeDefined = !isEqual(this.safeString(parameters, "planType"), null);
        object isTrigger = (isTrue(trigger) || isTrue(planTypeDefined));
        var requestparametersVariable = this.handleUntilOption("endTime", request, parameters);
        request = ((IList<object>)requestparametersVariable)[0];
        parameters = ((IList<object>)requestparametersVariable)[1];
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["startTime"] = since;
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        if (isTrue(!isTrue(uta) && isTrue((isTrue(isTrue((isEqual(type, "swap"))) || isTrue((isEqual(type, "future")))) || isTrue((!isEqual(marginMode, null)))))))
        {
            object clientOrderId = this.safeString2(parameters, "clientOid", "clientOrderId");
            parameters = this.omit(parameters, "clientOrderId");
            if (isTrue(!isEqual(clientOrderId, null)))
            {
                ((IDictionary<string,object>)request)["clientOid"] = clientOrderId;
            }
        }
        object productType = null;
        var productTypeparametersVariable = this.handleProductTypeAndParams(market, parameters);
        productType = ((IList<object>)productTypeparametersVariable)[0];
        parameters = ((IList<object>)productTypeparametersVariable)[1];
        parameters = this.omit(parameters, new List<object>() {"type", "stop", "trigger", "trailing"});
        if (isTrue(uta))
        {
            if (isTrue(isEqual(type, "spot")))
            {
                if (isTrue(!isEqual(marginMode, null)))
                {
                    productType = "MARGIN";
                }
            }
            ((IDictionary<string,object>)request)["category"] = productType;
            if (isTrue(trigger))
            {
                response = await this.privateUtaGetV3TradeUnfilledStrategyOrders(this.extend(request, parameters));
            } else
            {
                response = await this.privateUtaGetV3TradeUnfilledOrders(this.extend(request, parameters));
            }
        } else if (isTrue(isEqual(type, "spot")))
        {
            if (isTrue(!isEqual(marginMode, null)))
            {
                if (isTrue(isEqual(since, null)))
                {
                    since = subtract(this.milliseconds(), 7776000000);
                    ((IDictionary<string,object>)request)["startTime"] = since;
                }
                if (isTrue(isEqual(marginMode, "isolated")))
                {
                    response = await this.privateMarginGetV2MarginIsolatedOpenOrders(this.extend(request, parameters));
                } else if (isTrue(isEqual(marginMode, "cross")))
                {
                    response = await this.privateMarginGetV2MarginCrossedOpenOrders(this.extend(request, parameters));
                }
            } else
            {
                if (isTrue(trigger))
                {
                    response = await this.privateSpotGetV2SpotTradeCurrentPlanOrder(this.extend(request, parameters));
                } else
                {
                    response = await this.privateSpotGetV2SpotTradeUnfilledOrders(this.extend(request, parameters));
                }
            }
        } else
        {
            ((IDictionary<string,object>)request)["productType"] = productType;
            if (isTrue(trailing))
            {
                object planType = this.safeString(parameters, "planType", "track_plan");
                ((IDictionary<string,object>)request)["planType"] = planType;
                response = await this.privateMixGetV2MixOrderOrdersPlanPending(this.extend(request, parameters));
            } else if (isTrue(isTrigger))
            {
                object planType = this.safeString(parameters, "planType", "normal_plan");
                ((IDictionary<string,object>)request)["planType"] = planType;
                response = await this.privateMixGetV2MixOrderOrdersPlanPending(this.extend(request, parameters));
            } else
            {
                response = await this.privateMixGetV2MixOrderOrdersPending(this.extend(request, parameters));
            }
        }
        //
        // spot
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1700728123994,
        //         "data": [
        //             {
        //                 "userId": "7264631750",
        //                 "symbol": "BTCUSDT",
        //                 "orderId": "1111499608327360513",
        //                 "clientOid": "d0d4dad5-18d0-4869-a074-ec40bb47cba6",
        //                 "priceAvg": "25000.0000000000000000",
        //                 "size": "0.0002000000000000",
        //                 "orderType": "limit",
        //                 "side": "buy",
        //                 "status": "live",
        //                 "basePrice": "0",
        //                 "baseVolume": "0.0000000000000000",
        //                 "quoteVolume": "0.0000000000000000",
        //                 "enterPointSource": "WEB",
        //                 "orderSource": "normal",
        //                 "cTime": "1700728077966",
        //                 "uTime": "1700728077966"
        //             }
        //         ]
        //     }
        //
        // spot stop
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1700729361609,
        //         "data": {
        //             "nextFlag": false,
        //             "idLessThan": "1111503385931620352",
        //             "orderList": [
        //                 {
        //                     "orderId": "1111503385931620352",
        //                     "clientOid": "1111503385910648832",
        //                     "symbol": "BTCUSDT",
        //                     "size": "0.0002",
        //                     "planType": "AMOUNT",
        //                     "executePrice": "25000",
        //                     "triggerPrice": "26000",
        //                     "status": "live",
        //                     "orderType": "limit",
        //                     "side": "buy",
        //                     "triggerType": "fill_price",
        //                     "enterPointSource": "API",
        //                     "cTime": "1700728978617",
        //                     "uTime": "1700728978617"
        //                 }
        //             ]
        //         }
        //     }
        //
        // spot margin
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1700729887686,
        //         "data": {
        //             "orderList": [
        //                 {
        //                     "symbol": "BTCUSDT",
        //                     "orderType": "limit",
        //                     "enterPointSource": "WEB",
        //                     "orderId": "1111506377509580801",
        //                     "clientOid": "2043a3b59a60445f9d9f7365bf3e960c",
        //                     "loanType": "autoLoanAndRepay",
        //                     "price": "25000",
        //                     "side": "buy",
        //                     "status": "live",
        //                     "baseSize": "0.0002",
        //                     "quoteSize": "5",
        //                     "priceAvg": "0",
        //                     "size": "0",
        //                     "amount": "0",
        //                     "force": "gtc",
        //                     "cTime": "1700729691866",
        //                     "uTime": "1700729691866"
        //                 }
        //             ],
        //             "maxId": "1111506377509580801",
        //             "minId": "1111506377509580801"
        //         }
        //     }
        //
        // swap and future
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1700725609065,
        //         "data": {
        //             "entrustedList": [
        //                 {
        //                     "symbol": "BTCUSDT",
        //                     "size": "0.002",
        //                     "orderId": "1111488897767604224",
        //                     "clientOid": "1111488897805352960",
        //                     "baseVolume": "0",
        //                     "fee": "0",
        //                     "price": "25000",
        //                     "priceAvg": "",
        //                     "status": "live",
        //                     "side": "buy",
        //                     "force": "gtc",
        //                     "totalProfits": "0",
        //                     "posSide": "long",
        //                     "marginCoin": "USDT",
        //                     "quoteVolume": "0",
        //                     "leverage": "20",
        //                     "marginMode": "crossed",
        //                     "enterPointSource": "web",
        //                     "tradeSide": "open",
        //                     "posMode": "hedge_mode",
        //                     "orderType": "limit",
        //                     "orderSource": "normal",
        //                     "presetStopSurplusPrice": "",
        //                     "presetStopLossPrice": "",
        //                     "reduceOnly": "NO",
        //                     "cTime": "1700725524378",
        //                     "uTime": "1700725524378"
        //                 }
        //             ],
        //             "endId": "1111488897767604224"
        //         }
        //     }
        //
        // swap and future stop
        //
        //     {
        //         "code": "00000",\
        //         "msg": "success",
        //         "requestTime": 1700726417495,
        //         "data": {
        //             "entrustedList": [
        //                 {
        //                     "planType": "normal_plan",
        //                     "symbol": "BTCUSDT",
        //                     "size": "0.001",
        //                     "orderId": "1111491399869075457",
        //                     "clientOid": "1111491399869075456",
        //                     "price": "27000",
        //                     "callbackRatio": "",
        //                     "triggerPrice": "24000",
        //                     "triggerType": "mark_price",
        //                     "planStatus": "live",
        //                     "side": "buy",
        //                     "posSide": "long",
        //                     "marginCoin": "USDT",
        //                     "marginMode": "crossed",
        //                     "enterPointSource": "API",
        //                     "tradeSide": "open",
        //                     "posMode": "hedge_mode",
        //                     "orderType": "limit",
        //                     "stopSurplusTriggerPrice": "",
        //                     "stopSurplusExecutePrice": "",
        //                     "stopSurplusTriggerType": "fill_price",
        //                     "stopLossTriggerPrice": "",
        //                     "stopLossExecutePrice": "",
        //                     "stopLossTriggerType": "fill_price",
        //                     "cTime": "1700726120917",
        //                     "uTime": "1700726120917"
        //                 }
        //             ],
        //             "endId": "1111491399869075457"
        //         }
        //     }
        //
        // uta
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1750753395850,
        //         "data": {
        //             "list": [
        //                 {
        //                     "orderId": "1321320757371228160",
        //                     "clientOid": "1321320757371228161",
        //                     "category": "USDT-FUTURES",
        //                     "symbol": "BTCUSDT",
        //                     "orderType": "limit",
        //                     "side": "buy",
        //                     "price": "50000",
        //                     "qty": "0.001",
        //                     "amount": "0",
        //                     "cumExecQty": "0",
        //                     "cumExecValue": "0",
        //                     "avgPrice": "0",
        //                     "timeInForce": "gtc",
        //                     "orderStatus": "live",
        //                     "posSide": "long",
        //                     "holdMode": "hedge_mode",
        //                     "reduceOnly": "NO",
        //                     "feeDetail": [
        //                         {
        //                             "feeCoin": "",
        //                             "fee": ""
        //                         }
        //                     ],
        //                     "createdTime": "1750753338186",
        //                     "updatedTime": "1750753338203",
        //                     "stpMode": "none",
        //                     "tpTriggerBy": null,
        //                     "slTriggerBy": null,
        //                     "takeProfit": null,
        //                     "stopLoss": null,
        //                     "tpOrderType": null,
        //                     "slOrderType": null,
        //                     "tpLimitPrice": null,
        //                     "slLimitPrice": null
        //                 }
        //             ],
        //             "cursor": "1321320757371228160"
        //         }
        //     }
        //
        // uta trigger
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1753057527060,
        //         "data": [
        //             {
        //                 "orderId": "1330984742276198400",
        //                 "clientOid": "1330984742276198400",
        //                 "symbol": "BTCUSDT",
        //                 "category": "USDT-FUTURES",
        //                 "qty": "0.001",
        //                 "posSide": "long",
        //                 "tpTriggerBy": "market",
        //                 "slTriggerBy": "mark",
        //                 "takeProfit": "",
        //                 "stopLoss":"114000",
        //                 "tpOrderType": "market",
        //                 "slOrderType": "limit",
        //                 "tpLimitPrice": "",
        //                 "slLimitPrice": "113000",
        //                 "createdTime": "1753057411736",
        //                 "updatedTime": "1753057411747"
        //             }
        //         ]
        //     }
        //
        object data = this.safeValue(response, "data");
        if (isTrue(uta))
        {
            object result = null;
            if (isTrue(trigger))
            {
                result = this.safeList(response, "data", new List<object>() {});
            } else
            {
                result = this.safeList(data, "list", new List<object>() {});
            }
            return this.parseOrders(result, market, since, limit);
        } else if (isTrue(isEqual(type, "spot")))
        {
            if (isTrue(isTrue((!isEqual(marginMode, null))) || isTrue(trigger)))
            {
                object resultList = this.safeList(data, "orderList", new List<object>() {});
                return this.parseOrders(resultList, market, since, limit);
            }
        } else
        {
            object result = this.safeList(data, "entrustedList", new List<object>() {});
            return this.parseOrders(result, market, since, limit);
        }
        return this.parseOrders(data, market, since, limit);
    }

    /**
     * @method
     * @name bitget#fetchClosedOrders
     * @description fetches information on multiple closed orders made by the user
     * @see https://www.bitget.com/api-doc/spot/trade/Get-History-Orders
     * @see https://www.bitget.com/api-doc/spot/plan/Get-History-Plan-Order
     * @see https://www.bitget.com/api-doc/contract/trade/Get-Orders-History
     * @see https://www.bitget.com/api-doc/contract/plan/orders-plan-history
     * @see https://www.bitget.com/api-doc/margin/cross/trade/Get-Cross-Order-History
     * @see https://www.bitget.com/api-doc/margin/isolated/trade/Get-Isolated-Order-History
     * @see https://www.bitget.com/api-doc/uta/trade/Get-Order-History
     * @param {string} symbol unified market symbol of the closed orders
     * @param {int} [since] timestamp in ms of the earliest order
     * @param {int} [limit] the max number of closed orders to return
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {int} [params.until] the latest time in ms to fetch orders for
     * @param {string} [params.planType] *contract stop only* 'normal_plan': average trigger order, 'profit_loss': opened tp/sl orders, 'track_plan': trailing stop order, default is 'normal_plan'
     * @param {boolean} [params.trigger] set to true for fetching trigger orders
     * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [available parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
     * @param {string} [params.isPlan] *swap only* 'plan' for stop orders and 'profit_loss' for tp/sl orders, default is 'plan'
     * @param {boolean} [params.trailing] set to true if you want to fetch trailing orders
     * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/?id=order-structure}
     */
    public async override Task<object> fetchClosedOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object orders = await this.fetchCanceledAndClosedOrders(symbol, since, limit, parameters);
        return this.filterBy(orders, "status", "closed");
    }

    /**
     * @method
     * @name bitget#fetchCanceledOrders
     * @description fetches information on multiple canceled orders made by the user
     * @see https://www.bitget.com/api-doc/spot/trade/Get-History-Orders
     * @see https://www.bitget.com/api-doc/spot/plan/Get-History-Plan-Order
     * @see https://www.bitget.com/api-doc/contract/trade/Get-Orders-History
     * @see https://www.bitget.com/api-doc/contract/plan/orders-plan-history
     * @see https://www.bitget.com/api-doc/margin/cross/trade/Get-Cross-Order-History
     * @see https://www.bitget.com/api-doc/margin/isolated/trade/Get-Isolated-Order-History
     * @see https://www.bitget.com/api-doc/uta/trade/Get-Order-History
     * @param {string} symbol unified market symbol of the canceled orders
     * @param {int} [since] timestamp in ms of the earliest order
     * @param {int} [limit] the max number of canceled orders to return
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {int} [params.until] the latest time in ms to fetch orders for
     * @param {string} [params.planType] *contract stop only* 'normal_plan': average trigger order, 'profit_loss': opened tp/sl orders, 'track_plan': trailing stop order, default is 'normal_plan'
     * @param {boolean} [params.trigger] set to true for fetching trigger orders
     * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [available parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
     * @param {string} [params.isPlan] *swap only* 'plan' for stop orders and 'profit_loss' for tp/sl orders, default is 'plan'
     * @param {boolean} [params.trailing] set to true if you want to fetch trailing orders
     * @returns {object} a list of [order structures]{@link https://docs.ccxt.com/?id=order-structure}
     */
    public async override Task<object> fetchCanceledOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object orders = await this.fetchCanceledAndClosedOrders(symbol, since, limit, parameters);
        return this.filterBy(orders, "status", "canceled");
    }

    /**
     * @method
     * @name bitget#fetchCanceledAndClosedOrders
     * @see https://www.bitget.com/api-doc/spot/trade/Get-History-Orders
     * @see https://www.bitget.com/api-doc/spot/plan/Get-History-Plan-Order
     * @see https://www.bitget.com/api-doc/contract/trade/Get-Orders-History
     * @see https://www.bitget.com/api-doc/contract/plan/orders-plan-history
     * @see https://www.bitget.com/api-doc/margin/cross/trade/Get-Cross-Order-History
     * @see https://www.bitget.com/api-doc/margin/isolated/trade/Get-Isolated-Order-History
     * @see https://www.bitget.com/api-doc/uta/trade/Get-Order-History
     * @see https://www.bitget.com/api-doc/uta/strategy/Get-History-Strategy-Orders
     * @description fetches information on multiple canceled and closed orders made by the user
     * @param {string} symbol unified market symbol of the market orders were made in
     * @param {int} [since] the earliest time in ms to fetch orders for
     * @param {int} [limit] the maximum number of order structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {int} [params.until] the latest time in ms to fetch orders for
     * @param {string} [params.planType] *contract stop only* 'normal_plan': average trigger order, 'profit_loss': opened tp/sl orders, 'track_plan': trailing stop order, default is 'normal_plan'
     * @param {boolean} [params.trigger] set to true for fetching trigger orders
     * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [available parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
     * @param {string} [params.isPlan] *swap only* 'plan' for stop orders and 'profit_loss' for tp/sl orders, default is 'plan'
     * @param {boolean} [params.trailing] set to true if you want to fetch trailing orders
     * @param {boolean} [params.uta] set to true for the unified trading account (uta), defaults to false
     * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/?id=order-structure}
     */
    public async override Task<object> fetchCanceledAndClosedOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object uta = null;
        var utaparametersVariable = this.handleOptionAndParams(parameters, "fetchCanceledAndClosedOrders", "uta", false);
        uta = ((IList<object>)utaparametersVariable)[0];
        parameters = ((IList<object>)utaparametersVariable)[1];
        if (isTrue(uta))
        {
            return await this.fetchUtaCanceledAndClosedOrders(symbol, since, limit, parameters);
        }
        await this.loadMarkets();
        object market = null;
        object request = new Dictionary<string, object>() {};
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
        }
        object marketType = null;
        var marketTypeparametersVariable = this.handleMarketTypeAndParams("fetchCanceledAndClosedOrders", market, parameters);
        marketType = ((IList<object>)marketTypeparametersVariable)[0];
        parameters = ((IList<object>)marketTypeparametersVariable)[1];
        object marginMode = null;
        var marginModeparametersVariable = this.handleMarginModeAndParams("fetchCanceledAndClosedOrders", parameters);
        marginMode = ((IList<object>)marginModeparametersVariable)[0];
        parameters = ((IList<object>)marginModeparametersVariable)[1];
        object paginate = false;
        var paginateparametersVariable = this.handleOptionAndParams(parameters, "fetchCanceledAndClosedOrders", "paginate");
        paginate = ((IList<object>)paginateparametersVariable)[0];
        parameters = ((IList<object>)paginateparametersVariable)[1];
        if (isTrue(paginate))
        {
            object cursorReceived = null;
            if (isTrue(isEqual(marketType, "spot")))
            {
                if (isTrue(!isEqual(marginMode, null)))
                {
                    cursorReceived = "minId";
                }
            } else
            {
                cursorReceived = "endId";
            }
            return await this.fetchPaginatedCallCursor("fetchCanceledAndClosedOrders", symbol, since, limit, parameters, cursorReceived, "idLessThan");
        }
        object response = null;
        object trailing = this.safeBool(parameters, "trailing");
        object trigger = this.safeBool2(parameters, "stop", "trigger");
        parameters = this.omit(parameters, new List<object>() {"stop", "trigger", "trailing"});
        var requestparametersVariable = this.handleUntilOption("endTime", request, parameters);
        request = ((IList<object>)requestparametersVariable)[0];
        parameters = ((IList<object>)requestparametersVariable)[1];
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["startTime"] = since;
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        if (isTrue(isTrue(isTrue((isEqual(marketType, "swap"))) || isTrue((isEqual(marketType, "future")))) || isTrue((!isEqual(marginMode, null)))))
        {
            object clientOrderId = this.safeString2(parameters, "clientOid", "clientOrderId");
            parameters = this.omit(parameters, "clientOrderId");
            if (isTrue(!isEqual(clientOrderId, null)))
            {
                ((IDictionary<string,object>)request)["clientOid"] = clientOrderId;
            }
        }
        object now = this.milliseconds();
        if (isTrue(isEqual(marketType, "spot")))
        {
            if (isTrue(!isEqual(marginMode, null)))
            {
                if (isTrue(isEqual(since, null)))
                {
                    since = subtract(now, 7776000000);
                    ((IDictionary<string,object>)request)["startTime"] = since;
                }
                if (isTrue(isEqual(marginMode, "isolated")))
                {
                    response = await this.privateMarginGetV2MarginIsolatedHistoryOrders(this.extend(request, parameters));
                } else if (isTrue(isEqual(marginMode, "cross")))
                {
                    response = await this.privateMarginGetV2MarginCrossedHistoryOrders(this.extend(request, parameters));
                }
            } else if (isTrue(trigger))
            {
                if (isTrue(isEqual(symbol, null)))
                {
                    throw new ArgumentsRequired ((string)add(this.id, " fetchCanceledAndClosedOrders() requires a symbol argument")) ;
                }
                object endTime = this.safeIntegerN(parameters, new List<object>() {"endTime", "until"});
                parameters = this.omit(parameters, new List<object>() {"until"});
                if (isTrue(isEqual(since, null)))
                {
                    since = subtract(now, 7776000000);
                    ((IDictionary<string,object>)request)["startTime"] = since;
                }
                if (isTrue(isEqual(endTime, null)))
                {
                    ((IDictionary<string,object>)request)["endTime"] = now;
                }
                response = await this.privateSpotGetV2SpotTradeHistoryPlanOrder(this.extend(request, parameters));
            } else
            {
                response = await this.privateSpotGetV2SpotTradeHistoryOrders(this.extend(request, parameters));
            }
        } else
        {
            object productType = null;
            var productTypeparametersVariable = this.handleProductTypeAndParams(market, parameters);
            productType = ((IList<object>)productTypeparametersVariable)[0];
            parameters = ((IList<object>)productTypeparametersVariable)[1];
            ((IDictionary<string,object>)request)["productType"] = productType;
            object planTypeDefined = !isEqual(this.safeString(parameters, "planType"), null);
            if (isTrue(trailing))
            {
                object planType = this.safeString(parameters, "planType", "track_plan");
                ((IDictionary<string,object>)request)["planType"] = planType;
                response = await this.privateMixGetV2MixOrderOrdersPlanHistory(this.extend(request, parameters));
            } else if (isTrue(isTrue(trigger) || isTrue(planTypeDefined)))
            {
                object planType = this.safeString(parameters, "planType", "normal_plan");
                ((IDictionary<string,object>)request)["planType"] = planType;
                response = await this.privateMixGetV2MixOrderOrdersPlanHistory(this.extend(request, parameters));
            } else
            {
                response = await this.privateMixGetV2MixOrderOrdersHistory(this.extend(request, parameters));
            }
        }
        //
        // spot
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1700791085380,
        //         "data": [
        //             {
        //                 "userId": "7264631750",
        //                 "symbol": "BTCUSDT",
        //                 "orderId": "1111499608327360513",
        //                 "clientOid": "d0d4dad5-18d0-4869-a074-ec40bb47cba6",
        //                 "price": "25000.0000000000000000",
        //                 "size": "0.0002000000000000",
        //                 "orderType": "limit",
        //                 "side": "buy",
        //                 "status": "cancelled",
        //                 "priceAvg": "0",
        //                 "baseVolume": "0.0000000000000000",
        //                 "quoteVolume": "0.0000000000000000",
        //                 "enterPointSource": "WEB",
        //                 "feeDetail": "",
        //                 "orderSource": "normal",
        //                 "cTime": "1700728077966",
        //                 "uTime": "1700728911471"
        //             },
        //         ]
        //     }
        //
        // spot stop
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1700792099146,
        //         "data": {
        //             "nextFlag": false,
        //             "idLessThan": "1098757597417775104",
        //             "orderList": [
        //                 {
        //                     "orderId": "1111503385931620352",
        //                     "clientOid": "1111503385910648832",
        //                     "symbol": "BTCUSDT",
        //                     "size": "0.0002",
        //                     "planType": "AMOUNT",
        //                     "executePrice": "25000",
        //                     "triggerPrice": "26000",
        //                     "status": "cancelled",
        //                     "orderType": "limit",
        //                     "side": "buy",
        //                     "triggerType": "fill_price",
        //                     "enterPointSource": "API",
        //                     "cTime": "1700728978617",
        //                     "uTime": "1700729666868"
        //                 },
        //             ]
        //         }
        //     }
        //
        // spot margin
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1700792381435,
        //         "data": {
        //             "orderList": [
        //                 {
        //                     "symbol": "BTCUSDT",
        //                     "orderType": "limit",
        //                     "enterPointSource": "WEB",
        //                     "orderId": "1111456274707001345",
        //                     "clientOid": "41e428dd305a4f668671b7f1ed00dc50",
        //                     "loanType": "autoLoanAndRepay",
        //                     "price": "27000",
        //                     "side": "buy",
        //                     "status": "cancelled",
        //                     "baseSize": "0.0002",
        //                     "quoteSize": "5.4",
        //                     "priceAvg": "0",
        //                     "size": "0",
        //                     "amount": "0",
        //                     "force": "gtc",
        //                     "cTime": "1700717746427",
        //                     "uTime": "1700717780636"
        //                 },
        //             ],
        //             "maxId": "1111456274707001345",
        //             "minId": "1098396464990269440"
        //         }
        //     }
        //
        // swap and future
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1700792674673,
        //         "data": {
        //             "entrustedList": [
        //                 {
        //                     "symbol": "BTCUSDT",
        //                     "size": "0.002",
        //                     "orderId": "1111498800817143808",
        //                     "clientOid": "1111498800850698240",
        //                     "baseVolume": "0",
        //                     "fee": "0",
        //                     "price": "25000",
        //                     "priceAvg": "",
        //                     "status": "canceled",
        //                     "side": "buy",
        //                     "force": "gtc",
        //                     "totalProfits": "0",
        //                     "posSide": "long",
        //                     "marginCoin": "USDT",
        //                     "quoteVolume": "0",
        //                     "leverage": "20",
        //                     "marginMode": "crossed",
        //                     "enterPointSource": "web",
        //                     "tradeSide": "open",
        //                     "posMode": "hedge_mode",
        //                     "orderType": "limit",
        //                     "orderSource": "normal",
        //                     "presetStopSurplusPrice": "",
        //                     "presetStopLossPrice": "",
        //                     "reduceOnly": "NO",
        //                     "cTime": "1700727885449",
        //                     "uTime": "1700727944563"
        //                 },
        //             ],
        //             "endId": "1098397008323575809"
        //         }
        //     }
        //
        // swap and future stop
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1700792938359,
        //         "data": {
        //             "entrustedList": [
        //                 {
        //                     "planType": "normal_plan",
        //                     "symbol": "BTCUSDT",
        //                     "size": "0.001",
        //                     "orderId": "1111491399869075457",
        //                     "clientOid": "1111491399869075456",
        //                     "planStatus": "cancelled",
        //                     "price": "27000",
        //                     "feeDetail": null,
        //                     "baseVolume": "0",
        //                     "callbackRatio": "",
        //                     "triggerPrice": "24000",
        //                     "triggerType": "mark_price",
        //                     "side": "buy",
        //                     "posSide": "long",
        //                     "marginCoin": "USDT",
        //                     "marginMode": "crossed",
        //                     "enterPointSource": "API",
        //                     "tradeSide": "open",
        //                     "posMode": "hedge_mode",
        //                     "orderType": "limit",
        //                     "stopSurplusTriggerPrice": "",
        //                     "stopSurplusExecutePrice": "",
        //                     "stopSurplusTriggerType": "fill_price",
        //                     "stopLossTriggerPrice": "",
        //                     "stopLossExecutePrice": "",
        //                     "stopLossTriggerType": "fill_price",
        //                     "cTime": "1700726120917",
        //                     "uTime": "1700727879652"
        //                 },
        //             ],
        //             "endId": "1098760007867502593"
        //         }
        //     }
        //
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        if (isTrue(isEqual(marketType, "spot")))
        {
            if (isTrue(isTrue((!isEqual(marginMode, null))) || isTrue(trigger)))
            {
                return this.parseOrders(this.safeValue(data, "orderList", new List<object>() {}), market, since, limit);
            }
        } else
        {
            return this.parseOrders(this.safeValue(data, "entrustedList", new List<object>() {}), market, since, limit);
        }
        if (isTrue((response is string)))
        {
            response = parseJson(response);
        }
        object orders = this.safeList(response, "data", new List<object>() {});
        return this.parseOrders(orders, market, since, limit);
    }

    public async virtual Task<object> fetchUtaCanceledAndClosedOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
        }
        object productType = null;
        var productTypeparametersVariable = this.handleProductTypeAndParams(market, parameters);
        productType = ((IList<object>)productTypeparametersVariable)[0];
        parameters = ((IList<object>)productTypeparametersVariable)[1];
        if (isTrue(isEqual(productType, "SPOT")))
        {
            object marginMode = null;
            var marginModeparametersVariable = this.handleMarginModeAndParams("fetchCanceledAndClosedOrders", parameters);
            marginMode = ((IList<object>)marginModeparametersVariable)[0];
            parameters = ((IList<object>)marginModeparametersVariable)[1];
            if (isTrue(!isEqual(marginMode, null)))
            {
                productType = "MARGIN";
            }
        }
        object request = new Dictionary<string, object>() {
            { "category", productType },
        };
        object paginate = false;
        var paginateparametersVariable = this.handleOptionAndParams(parameters, "fetchCanceledAndClosedOrders", "paginate");
        paginate = ((IList<object>)paginateparametersVariable)[0];
        parameters = ((IList<object>)paginateparametersVariable)[1];
        if (isTrue(paginate))
        {
            return await this.fetchPaginatedCallCursor("fetchCanceledAndClosedOrders", symbol, since, limit, parameters, "cursor", "cursor");
        }
        var requestparametersVariable = this.handleUntilOption("endTime", request, parameters);
        request = ((IList<object>)requestparametersVariable)[0];
        parameters = ((IList<object>)requestparametersVariable)[1];
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["startTime"] = since;
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        object response = null;
        object trigger = this.safeBool2(parameters, "stop", "trigger");
        parameters = this.omit(parameters, new List<object>() {"stop", "trigger"});
        if (isTrue(trigger))
        {
            response = await this.privateUtaGetV3TradeHistoryStrategyOrders(this.extend(request, parameters));
        } else
        {
            response = await this.privateUtaGetV3TradeHistoryOrders(this.extend(request, parameters));
        }
        //
        // uta
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1752531592855,
        //         "data": {
        //             "list": [
        //                 {
        //                     "orderId": "1322441400976261120",
        //                     "clientOid": "1322441400976261121",
        //                     "category": "USDT-FUTURES",
        //                     "symbol": "BTCUSDT",
        //                     "orderType": "market",
        //                     "side": "sell",
        //                     "price": "0",
        //                     "qty": "0.0001",
        //                     "amount": "0",
        //                     "cumExecQty": "0.0001",
        //                     "cumExecValue": "10.7005",
        //                     "avgPrice": "107005.4",
        //                     "timeInForce": "gtc",
        //                     "orderStatus": "filled",
        //                     "posSide": "long",
        //                     "holdMode": "hedge_mode",
        //                     "reduceOnly": "NO",
        //                     "feeDetail": [
        //                         {
        //                             "feeCoin": "USDT",
        //                             "fee": "0.00642032"
        //                         }
        //                     ],
        //                     "createdTime": "1751020520442",
        //                     "updatedTime": "1751020520457",
        //                     "cancelReason": "",
        //                     "execType": "normal",
        //                     "stpMode": "none",
        //                     "tpTriggerBy": null,
        //                     "slTriggerBy": null,
        //                     "takeProfit": null,
        //                     "stopLoss": null,
        //                     "tpOrderType": null,
        //                     "slOrderType": null,
        //                     "tpLimitPrice": null,
        //                     "slLimitPrice": null
        //                 },
        //             ],
        //             "cursor": "1322441328637100035"
        //         }
        //     }
        //
        // uta trigger
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1753058447920,
        //         "data": {
        //             "list": [
        //                 {
        //                     "orderId": "1330984742276198400",
        //                     "clientOid": "1330984742276198400",
        //                     "symbol": "BTCUSDT",
        //                     "category": "USDT-FUTURES",
        //                     "qty": "0.001",
        //                     "posSide": "long",
        //                     "tpTriggerBy": "market",
        //                     "slTriggerBy": "mark",
        //                     "takeProfit": "",
        //                     "stopLoss": "112000",
        //                     "tpOrderType": "market",
        //                     "slOrderType": "limit",
        //                     "tpLimitPrice": "",
        //                     "slLimitPrice": "111000",
        //                     "createdTime": "1753057411736",
        //                     "updatedTime": "1753058267412"
        //                 },
        //             ],
        //             "cursor": 1330960754317619202
        //         }
        //     }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        object orders = this.safeList(data, "list", new List<object>() {});
        return this.parseOrders(orders, market, since, limit);
    }

    /**
     * @method
     * @name bitget#fetchLedger
     * @description fetch the history of changes, actions done by the user or operations that altered the balance of the user
     * @see https://www.bitget.com/api-doc/spot/account/Get-Account-Bills
     * @see https://www.bitget.com/api-doc/contract/account/Get-Account-Bill
     * @param {string} [code] unified currency code, default is undefined
     * @param {int} [since] timestamp in ms of the earliest ledger entry, default is undefined
     * @param {int} [limit] max number of ledger entries to return, default is undefined
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {int} [params.until] end time in ms
     * @param {string} [params.symbol] *contract only* unified market symbol
     * @param {string} [params.productType] *contract only* 'USDT-FUTURES', 'USDC-FUTURES', 'COIN-FUTURES', 'SUSDT-FUTURES', 'SUSDC-FUTURES' or 'SCOIN-FUTURES'
     * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [available parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
     * @returns {object} a [ledger structure]{@link https://docs.ccxt.com/?id=ledger-entry-structure}
     */
    public async override Task<object> fetchLedger(object code = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object symbol = this.safeString(parameters, "symbol");
        parameters = this.omit(parameters, "symbol");
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
        }
        object marketType = null;
        var marketTypeparametersVariable = this.handleMarketTypeAndParams("fetchLedger", market, parameters);
        marketType = ((IList<object>)marketTypeparametersVariable)[0];
        parameters = ((IList<object>)marketTypeparametersVariable)[1];
        object paginate = false;
        var paginateparametersVariable = this.handleOptionAndParams(parameters, "fetchLedger", "paginate");
        paginate = ((IList<object>)paginateparametersVariable)[0];
        parameters = ((IList<object>)paginateparametersVariable)[1];
        if (isTrue(paginate))
        {
            object cursorReceived = null;
            if (isTrue(!isEqual(marketType, "spot")))
            {
                cursorReceived = "endId";
            }
            return await this.fetchPaginatedCallCursor("fetchLedger", symbol, since, limit, parameters, cursorReceived, "idLessThan");
        }
        object currency = null;
        object request = new Dictionary<string, object>() {};
        if (isTrue(!isEqual(code, null)))
        {
            currency = this.currency(code);
            ((IDictionary<string,object>)request)["coin"] = getValue(currency, "id");
        }
        var requestparametersVariable = this.handleUntilOption("endTime", request, parameters);
        request = ((IList<object>)requestparametersVariable)[0];
        parameters = ((IList<object>)requestparametersVariable)[1];
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["startTime"] = since;
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        object response = null;
        if (isTrue(isEqual(marketType, "spot")))
        {
            response = await this.privateSpotGetV2SpotAccountBills(this.extend(request, parameters));
        } else
        {
            if (isTrue(!isEqual(symbol, null)))
            {
                ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
            }
            object productType = null;
            var productTypeparametersVariable = this.handleProductTypeAndParams(market, parameters);
            productType = ((IList<object>)productTypeparametersVariable)[0];
            parameters = ((IList<object>)productTypeparametersVariable)[1];
            ((IDictionary<string,object>)request)["productType"] = productType;
            response = await this.privateMixGetV2MixAccountBill(this.extend(request, parameters));
        }
        //
        // spot
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1700795836415,
        //         "data": [
        //             {
        //                 "billId": "1111506298997215233",
        //                 "coin": "USDT",
        //                 "groupType": "transfer",
        //                 "businessType": "transfer_out",
        //                 "size": "-11.64958799",
        //                 "balance": "0.00000000",
        //                 "fees": "0.00000000",
        //                 "cTime": "1700729673028"
        //             },
        //         ]
        //     }
        //
        // swap and future
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1700795977890,
        //         "data": {
        //             "bills": [
        //                 {
        //                     "billId": "1111499428100472833",
        //                     "symbol": "",
        //                     "amount": "-11.64958799",
        //                     "fee": "0",
        //                     "feeByCoupon": "",
        //                     "businessType": "trans_to_exchange",
        //                     "coin": "USDT",
        //                     "cTime": "1700728034996"
        //                 },
        //             ],
        //             "endId": "1098396773329305606"
        //         }
        //     }
        //
        object data = this.safeValue(response, "data");
        if (isTrue(isTrue((isEqual(marketType, "swap"))) || isTrue((isEqual(marketType, "future")))))
        {
            object bills = this.safeValue(data, "bills", new List<object>() {});
            return this.parseLedger(bills, currency, since, limit);
        }
        return this.parseLedger(data, currency, since, limit);
    }

    public override object parseLedgerEntry(object item, object currency = null)
    {
        //
        // spot
        //
        //     {
        //         "billId": "1111506298997215233",
        //         "coin": "USDT",
        //         "groupType": "transfer",
        //         "businessType": "transfer_out",
        //         "size": "-11.64958799",
        //         "balance": "0.00000000",
        //         "fees": "0.00000000",
        //         "cTime": "1700729673028"
        //     }
        //
        // swap and future
        //
        //     {
        //         "billId": "1111499428100472833",
        //         "symbol": "",
        //         "amount": "-11.64958799",
        //         "fee": "0",
        //         "feeByCoupon": "",
        //         "businessType": "trans_to_exchange",
        //         "coin": "USDT",
        //         "cTime": "1700728034996"
        //     }
        //
        object currencyId = this.safeString(item, "coin");
        object code = this.safeCurrencyCode(currencyId, currency);
        currency = this.safeCurrency(currencyId, currency);
        object timestamp = this.safeInteger(item, "cTime");
        object after = this.safeNumber(item, "balance");
        object fee = this.safeNumber2(item, "fees", "fee");
        object amountRaw = this.safeString2(item, "size", "amount");
        object amount = this.parseNumber(Precise.stringAbs(amountRaw));
        object direction = "in";
        if (isTrue(isGreaterThanOrEqual(getIndexOf(amountRaw, "-"), 0)))
        {
            direction = "out";
        }
        return this.safeLedgerEntry(new Dictionary<string, object>() {
            { "info", item },
            { "id", this.safeString(item, "billId") },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "direction", direction },
            { "account", null },
            { "referenceId", null },
            { "referenceAccount", null },
            { "type", this.parseLedgerType(this.safeString(item, "businessType")) },
            { "currency", code },
            { "amount", amount },
            { "before", null },
            { "after", after },
            { "status", null },
            { "fee", new Dictionary<string, object>() {
                { "currency", code },
                { "cost", fee },
            } },
        }, currency);
    }

    public virtual object parseLedgerType(object type)
    {
        object types = new Dictionary<string, object>() {
            { "trans_to_cross", "transfer" },
            { "trans_from_cross", "transfer" },
            { "trans_to_exchange", "transfer" },
            { "trans_from_exchange", "transfer" },
            { "trans_to_isolated", "transfer" },
            { "trans_from_isolated", "transfer" },
            { "trans_to_contract", "transfer" },
            { "trans_from_contract", "transfer" },
            { "trans_to_otc", "transfer" },
            { "trans_from_otc", "transfer" },
            { "open_long", "trade" },
            { "close_long", "trade" },
            { "open_short", "trade" },
            { "close_short", "trade" },
            { "force_close_long", "trade" },
            { "force_close_short", "trade" },
            { "burst_long_loss_query", "trade" },
            { "burst_short_loss_query", "trade" },
            { "force_buy", "trade" },
            { "force_sell", "trade" },
            { "burst_buy", "trade" },
            { "burst_sell", "trade" },
            { "delivery_long", "settlement" },
            { "delivery_short", "settlement" },
            { "contract_settle_fee", "fee" },
            { "append_margin", "transaction" },
            { "adjust_down_lever_append_margin", "transaction" },
            { "reduce_margin", "transaction" },
            { "auto_append_margin", "transaction" },
            { "cash_gift_issue", "cashback" },
            { "cash_gift_recycle", "cashback" },
            { "bonus_issue", "rebate" },
            { "bonus_recycle", "rebate" },
            { "bonus_expired", "rebate" },
            { "transfer_in", "transfer" },
            { "transfer_out", "transfer" },
            { "deposit", "deposit" },
            { "withdraw", "withdrawal" },
            { "buy", "trade" },
            { "sell", "trade" },
        };
        return this.safeString(types, type, type);
    }

    /**
     * @method
     * @name bitget#fetchMyTrades
     * @description fetch all trades made by the user
     * @see https://www.bitget.com/api-doc/spot/trade/Get-Fills
     * @see https://www.bitget.com/api-doc/contract/trade/Get-Order-Fills
     * @see https://www.bitget.com/api-doc/margin/cross/trade/Get-Cross-Order-Fills
     * @see https://www.bitget.com/api-doc/margin/isolated/trade/Get-Isolated-Transaction-Details
     * @see https://www.bitget.com/api-doc/uta/trade/Get-Order-Fills
     * @param {string} symbol unified market symbol
     * @param {int} [since] the earliest time in ms to fetch trades for
     * @param {int} [limit] the maximum number of trades structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {int} [params.until] the latest time in ms to fetch trades for
     * @param {boolean} [params.uta] set to true for the unified trading account (uta), defaults to false
     * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [available parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
     * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/?id=trade-structure}
     */
    public async override Task<object> fetchMyTrades(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object uta = null;
        var utaparametersVariable = this.handleOptionAndParams(parameters, "fetchMyTrades", "uta", false);
        uta = ((IList<object>)utaparametersVariable)[0];
        parameters = ((IList<object>)utaparametersVariable)[1];
        if (isTrue(!isTrue(uta) && isTrue((isEqual(symbol, null)))))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchMyTrades() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {};
        var requestparametersVariable = this.handleUntilOption("endTime", request, parameters);
        request = ((IList<object>)requestparametersVariable)[0];
        parameters = ((IList<object>)requestparametersVariable)[1];
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["startTime"] = since;
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        object paginate = false;
        object marginMode = null;
        var paginateparametersVariable = this.handleOptionAndParams(parameters, "fetchMyTrades", "paginate");
        paginate = ((IList<object>)paginateparametersVariable)[0];
        parameters = ((IList<object>)paginateparametersVariable)[1];
        var marginModeparametersVariable = this.handleMarginModeAndParams("fetchMyTrades", parameters);
        marginMode = ((IList<object>)marginModeparametersVariable)[0];
        parameters = ((IList<object>)marginModeparametersVariable)[1];
        if (isTrue(paginate))
        {
            object cursorReceived = null;
            object cursorSent = null;
            if (isTrue(uta))
            {
                cursorReceived = "cursor";
                cursorSent = "cursor";
            } else if (isTrue(getValue(market, "spot")))
            {
                if (isTrue(!isEqual(marginMode, null)))
                {
                    cursorReceived = "minId";
                    cursorSent = "idLessThan";
                }
            } else
            {
                cursorReceived = "endId";
                cursorSent = "idLessThan";
            }
            return await this.fetchPaginatedCallCursor("fetchMyTrades", symbol, since, limit, parameters, cursorReceived, cursorSent);
        }
        object response = null;
        if (isTrue(uta))
        {
            response = await this.privateUtaGetV3TradeFills(this.extend(request, parameters));
        } else
        {
            ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
            if (isTrue(getValue(market, "spot")))
            {
                if (isTrue(!isEqual(marginMode, null)))
                {
                    if (isTrue(isEqual(since, null)))
                    {
                        ((IDictionary<string,object>)request)["startTime"] = subtract(this.milliseconds(), 7776000000);
                    }
                    if (isTrue(isEqual(marginMode, "isolated")))
                    {
                        response = await this.privateMarginGetV2MarginIsolatedFills(this.extend(request, parameters));
                    } else if (isTrue(isEqual(marginMode, "cross")))
                    {
                        response = await this.privateMarginGetV2MarginCrossedFills(this.extend(request, parameters));
                    }
                } else
                {
                    response = await this.privateSpotGetV2SpotTradeFills(this.extend(request, parameters));
                }
            } else
            {
                object productType = null;
                var productTypeparametersVariable = this.handleProductTypeAndParams(market, parameters);
                productType = ((IList<object>)productTypeparametersVariable)[0];
                parameters = ((IList<object>)productTypeparametersVariable)[1];
                ((IDictionary<string,object>)request)["productType"] = productType;
                response = await this.privateMixGetV2MixOrderFills(this.extend(request, parameters));
            }
        }
        //
        // spot
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1700802995406,
        //         "data": [
        //             {
        //                 "userId": "7264631751",
        //                 "symbol": "BTCUSDT",
        //                 "orderId": "1098394344925597696",
        //                 "tradeId": "1098394344974925824",
        //                 "orderType": "market",
        //                 "side": "sell",
        //                 "priceAvg": "28467.68",
        //                 "size": "0.0002",
        //                 "amount": "5.693536",
        //                 "feeDetail": {
        //                     "deduction": "no",
        //                     "feeCoin": "USDT",
        //                     "totalDeductionFee": "",
        //                     "totalFee": "-0.005693536"
        //                 },
        //                 "tradeScope": "taker",
        //                 "cTime": "1697603539699",
        //                 "uTime": "1697603539754"
        //             }
        //         ]
        //     }
        //
        // spot margin
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1700803176399,
        //         "data": {
        //             "fills": [
        //                 {
        //                     "orderId": "1099353730455318528",
        //                     "tradeId": "1099353730627092481",
        //                     "orderType": "market",
        //                     "side": "sell",
        //                     "priceAvg": "29543.7",
        //                     "size": "0.0001",
        //                     "amount": "2.95437",
        //                     "tradeScope": "taker",
        //                     "feeDetail": {
        //                         "deduction": "no",
        //                         "feeCoin": "USDT",
        //                         "totalDeductionFee": "0",
        //                         "totalFee": "-0.00295437"
        //                     },
        //                     "cTime": "1697832275063",
        //                     "uTime": "1697832275150"
        //                 },
        //             ],
        //             "minId": "1099353591699161118",
        //             "maxId": "1099353730627092481"
        //         }
        //     }
        //
        // swap and future
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1700803357487,
        //         "data": {
        //             "fillList": [
        //                 {
        //                     "tradeId": "1111468664328269825",
        //                     "symbol": "BTCUSDT",
        //                     "orderId": "1111468664264753162",
        //                     "price": "37271.4",
        //                     "baseVolume": "0.001",
        //                     "feeDetail": [
        //                         {
        //                             "deduction": "no",
        //                             "feeCoin": "USDT",
        //                             "totalDeductionFee": null,
        //                             "totalFee": "-0.02236284"
        //                         }
        //                     ],
        //                     "side": "buy",
        //                     "quoteVolume": "37.2714",
        //                     "profit": "-0.0007",
        //                     "enterPointSource": "web",
        //                     "tradeSide": "close",
        //                     "posMode": "hedge_mode",
        //                     "tradeScope": "taker",
        //                     "cTime": "1700720700342"
        //                 },
        //             ],
        //             "endId": "1099351587643699201"
        //         }
        //     }
        //
        // uta
        //
        //      {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1751099666579,
        //         "data": {
        //             "list": [
        //                 {
        //                     "execId": "1322441401010528257",
        //                     "orderId": "1322441400976261120",
        //                     "category": "USDT-FUTURES",
        //                     "symbol": "BTCUSDT",
        //                     "orderType": "market",
        //                     "side": "sell",
        //                     "execPrice": "107005.4",
        //                     "execQty": "0.0001",
        //                     "execValue": "10.7005",
        //                     "tradeScope": "taker",
        //                     "feeDetail": [{
        //                         "feeCoin": "USDT",
        //                         "fee":"0.00642032"
        //                     }],
        //                     "createdTime": "1751020520451",
        //                     "updatedTime": "1751020520458",
        //                     "execPnl": "0.00017"
        //                 },
        //             ],
        //             "cursor": "1322061241878880257"
        //         }
        //     }
        //
        object data = this.safeValue(response, "data");
        if (isTrue(uta))
        {
            object fills = this.safeList(data, "list", new List<object>() {});
            return this.parseTrades(fills, market, since, limit);
        } else if (isTrue((isTrue(getValue(market, "swap")) || isTrue((getValue(market, "future"))))))
        {
            object fills = this.safeList(data, "fillList", new List<object>() {});
            return this.parseTrades(fills, market, since, limit);
        } else if (isTrue(!isEqual(marginMode, null)))
        {
            object fills = this.safeList(data, "fills", new List<object>() {});
            return this.parseTrades(fills, market, since, limit);
        }
        return this.parseTrades(data, market, since, limit);
    }

    /**
     * @method
     * @name bitget#fetchPosition
     * @description fetch data on a single open contract trade position
     * @see https://www.bitget.com/api-doc/contract/position/get-single-position
     * @see https://www.bitget.com/api-doc/uta/trade/Get-Position
     * @param {string} symbol unified market symbol of the market the position is held in
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {boolean} [params.uta] set to true for the unified trading account (uta), defaults to false
     * @returns {object} a [position structure]{@link https://docs.ccxt.com/?id=position-structure}
     */
    public async override Task<object> fetchPosition(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object productType = null;
        var productTypeparametersVariable = this.handleProductTypeAndParams(market, parameters);
        productType = ((IList<object>)productTypeparametersVariable)[0];
        parameters = ((IList<object>)productTypeparametersVariable)[1];
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object response = null;
        object uta = null;
        object result = null;
        var utaparametersVariable = this.handleOptionAndParams(parameters, "fetchPosition", "uta", false);
        uta = ((IList<object>)utaparametersVariable)[0];
        parameters = ((IList<object>)utaparametersVariable)[1];
        if (isTrue(uta))
        {
            ((IDictionary<string,object>)request)["category"] = productType;
            response = await this.privateUtaGetV3PositionCurrentPosition(this.extend(request, parameters));
            //
            //     {
            //         "code": "00000",
            //         "msg": "success",
            //         "requestTime": 1750929905423,
            //         "data": {
            //             "list": [
            //                 {
            //                     "category": "USDT-FUTURES",
            //                     "symbol": "BTCUSDT",
            //                     "marginCoin": "USDT",
            //                     "holdMode": "hedge_mode",
            //                     "posSide": "long",
            //                     "marginMode": "crossed",
            //                     "positionBalance": "5.435199",
            //                     "available": "0.001",
            //                     "frozen": "0",
            //                     "total": "0.001",
            //                     "leverage": "20",
            //                     "curRealisedPnl": "0",
            //                     "avgPrice": "107410.3",
            //                     "positionStatus": "normal",
            //                     "unrealisedPnl": "0.0047",
            //                     "liquidationPrice": "0",
            //                     "mmr": "0.004",
            //                     "profitRate": "0.0008647337475591",
            //                     "markPrice": "107415.3",
            //                     "breakEvenPrice": "107539.2",
            //                     "totalFunding": "0",
            //                     "openFeeTotal": "-0.06444618",
            //                     "closeFeeTotal": "0",
            //                     "createdTime": "1750495670699",
            //                     "updatedTime": "1750929883465"
            //                 }
            //             ]
            //         }
            //     }
            //
            object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
            result = this.safeList(data, "list", new List<object>() {});
        } else
        {
            ((IDictionary<string,object>)request)["marginCoin"] = getValue(market, "settleId");
            ((IDictionary<string,object>)request)["productType"] = productType;
            response = await this.privateMixGetV2MixPositionSinglePosition(this.extend(request, parameters));
            //
            //     {
            //         "code": "00000",
            //         "msg": "success",
            //         "requestTime": 1700807531673,
            //         "data": [
            //             {
            //                 "marginCoin": "USDT",
            //                 "symbol": "BTCUSDT",
            //                 "holdSide": "long",
            //                 "openDelegateSize": "0",
            //                 "marginSize": "3.73555",
            //                 "available": "0.002",
            //                 "locked": "0",
            //                 "total": "0.002",
            //                 "leverage": "20",
            //                 "achievedProfits": "0",
            //                 "openPriceAvg": "37355.5",
            //                 "marginMode": "crossed",
            //                 "posMode": "hedge_mode",
            //                 "unrealizedPL": "0.007",
            //                 "liquidationPrice": "31724.970702417",
            //                 "keepMarginRate": "0.004",
            //                 "markPrice": "37359",
            //                 "marginRatio": "0.029599540355",
            //                 "cTime": "1700807507275"
            //             }
            //         ]
            //     }
            //
            result = this.safeList(response, "data", new List<object>() {});
        }
        object first = this.safeDict(result, 0, new Dictionary<string, object>() {});
        return this.parsePosition(first, market);
    }

    /**
     * @method
     * @name bitget#fetchPositions
     * @description fetch all open positions
     * @see https://www.bitget.com/api-doc/contract/position/get-all-position
     * @see https://www.bitget.com/api-doc/contract/position/Get-History-Position
     * @see https://www.bitget.com/api-doc/uta/trade/Get-Position
     * @param {string[]} [symbols] list of unified market symbols
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.marginCoin] the settle currency of the positions, needs to match the productType
     * @param {string} [params.productType] 'USDT-FUTURES', 'USDC-FUTURES', 'COIN-FUTURES', 'SUSDT-FUTURES', 'SUSDC-FUTURES' or 'SCOIN-FUTURES'
     * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [available parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
     * @param {boolean} [params.useHistoryEndpoint] default false, when true  will use the historic endpoint to fetch positions
     * @param {string} [params.method] either (default) 'privateMixGetV2MixPositionAllPosition', 'privateMixGetV2MixPositionHistoryPosition', or 'privateUtaGetV3PositionCurrentPosition'
     * @param {boolean} [params.uta] set to true for the unified trading account (uta), defaults to false
     * @returns {object[]} a list of [position structure]{@link https://docs.ccxt.com/?id=position-structure}
     */
    public async override Task<object> fetchPositions(object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object paginate = false;
        var paginateparametersVariable = this.handleOptionAndParams(parameters, "fetchPositions", "paginate");
        paginate = ((IList<object>)paginateparametersVariable)[0];
        parameters = ((IList<object>)paginateparametersVariable)[1];
        if (isTrue(paginate))
        {
            return await this.fetchPaginatedCallCursor("fetchPositions", null, null, null, parameters, "endId", "idLessThan");
        }
        object method = null;
        object useHistoryEndpoint = this.safeBool(parameters, "useHistoryEndpoint", false);
        if (isTrue(useHistoryEndpoint))
        {
            method = "privateMixGetV2MixPositionHistoryPosition";
        } else
        {
            var methodparametersVariable = this.handleOptionAndParams(parameters, "fetchPositions", "method", "privateMixGetV2MixPositionAllPosition");
            method = ((IList<object>)methodparametersVariable)[0];
            parameters = ((IList<object>)methodparametersVariable)[1];
        }
        object market = null;
        if (isTrue(!isEqual(symbols, null)))
        {
            object first = this.safeString(symbols, 0);
            // symbols can be undefined or []
            if (isTrue(!isEqual(first, null)))
            {
                market = this.market(first);
            }
        }
        object productType = null;
        var productTypeparametersVariable = this.handleProductTypeAndParams(market, parameters);
        productType = ((IList<object>)productTypeparametersVariable)[0];
        parameters = ((IList<object>)productTypeparametersVariable)[1];
        object request = new Dictionary<string, object>() {};
        object response = null;
        object isHistory = false;
        object uta = null;
        var utaparametersVariable = this.handleOptionAndParams(parameters, "fetchPositions", "uta", false);
        uta = ((IList<object>)utaparametersVariable)[0];
        parameters = ((IList<object>)utaparametersVariable)[1];
        if (isTrue(uta))
        {
            ((IDictionary<string,object>)request)["category"] = productType;
            response = await this.privateUtaGetV3PositionCurrentPosition(this.extend(request, parameters));
        } else if (isTrue(isEqual(method, "privateMixGetV2MixPositionAllPosition")))
        {
            object marginCoin = this.safeString(parameters, "marginCoin", "USDT");
            if (isTrue(!isEqual(market, null)))
            {
                marginCoin = getValue(market, "settleId");
            } else if (isTrue(isEqual(productType, "USDT-FUTURES")))
            {
                marginCoin = "USDT";
            } else if (isTrue(isEqual(productType, "USDC-FUTURES")))
            {
                marginCoin = "USDC";
            } else if (isTrue(isEqual(productType, "SUSDT-FUTURES")))
            {
                marginCoin = "SUSDT";
            } else if (isTrue(isEqual(productType, "SUSDC-FUTURES")))
            {
                marginCoin = "SUSDC";
            } else if (isTrue(isTrue((isEqual(productType, "SCOIN-FUTURES"))) || isTrue((isEqual(productType, "COIN-FUTURES")))))
            {
                if (isTrue(isEqual(marginCoin, null)))
                {
                    throw new ArgumentsRequired ((string)add(this.id, " fetchPositions() requires a marginCoin parameter that matches the productType")) ;
                }
            }
            ((IDictionary<string,object>)request)["marginCoin"] = marginCoin;
            ((IDictionary<string,object>)request)["productType"] = productType;
            response = await this.privateMixGetV2MixPositionAllPosition(this.extend(request, parameters));
        } else
        {
            isHistory = true;
            if (isTrue(!isEqual(market, null)))
            {
                ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
            }
            ((IDictionary<string,object>)request)["productType"] = productType;
            response = await this.privateMixGetV2MixPositionHistoryPosition(this.extend(request, parameters));
        }
        //
        // privateMixGetV2MixPositionAllPosition
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1700807810221,
        //         "data": [
        //             {
        //                 "marginCoin": "USDT",
        //                 "symbol": "BTCUSDT",
        //                 "holdSide": "long",
        //                 "openDelegateSize": "0",
        //                 "marginSize": "3.73555",
        //                 "available": "0.002",
        //                 "locked": "0",
        //                 "total": "0.002",
        //                 "leverage": "20",
        //                 "achievedProfits": "0",
        //                 "openPriceAvg": "37355.5",
        //                 "marginMode": "crossed",
        //                 "posMode": "hedge_mode",
        //                 "unrealizedPL": "0.03",
        //                 "liquidationPrice": "31725.023602417",
        //                 "keepMarginRate": "0.004",
        //                 "markPrice": "37370.5",
        //                 "marginRatio": "0.029550120396",
        //                 "cTime": "1700807507275"
        //             }
        //         ]
        //     }
        //
        // privateMixGetV2MixPositionHistoryPosition
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1700808051002,
        //         "data": {
        //             "list": [
        //                 {
        //                     "symbol": "BTCUSDT",
        //                     "marginCoin": "USDT",
        //                     "holdSide": "long",
        //                     "openAvgPrice": "37272.1",
        //                     "closeAvgPrice": "37271.4",
        //                     "marginMode": "crossed",
        //                     "openTotalPos": "0.001",
        //                     "closeTotalPos": "0.001",
        //                     "pnl": "-0.0007",
        //                     "netProfit": "-0.0454261",
        //                     "totalFunding": "0",
        //                     "openFee": "-0.02236326",
        //                     "closeFee": "-0.02236284",
        //                     "utime": "1700720700400",
        //                     "ctime": "1700720651684"
        //                 },
        //             ],
        //             "endId": "1099351653866962944"
        //         }
        //     }
        //
        // privateUtaGetV3PositionCurrentPosition
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1750929905423,
        //         "data": {
        //             "list": [
        //                 {
        //                     "category": "USDT-FUTURES",
        //                     "symbol": "BTCUSDT",
        //                     "marginCoin": "USDT",
        //                     "holdMode": "hedge_mode",
        //                     "posSide": "long",
        //                     "marginMode": "crossed",
        //                     "positionBalance": "5.435199",
        //                     "available": "0.001",
        //                     "frozen": "0",
        //                     "total": "0.001",
        //                     "leverage": "20",
        //                     "curRealisedPnl": "0",
        //                     "avgPrice": "107410.3",
        //                     "positionStatus": "normal",
        //                     "unrealisedPnl": "0.0047",
        //                     "liquidationPrice": "0",
        //                     "mmr": "0.004",
        //                     "profitRate": "0.0008647337475591",
        //                     "markPrice": "107415.3",
        //                     "breakEvenPrice": "107539.2",
        //                     "totalFunding": "0",
        //                     "openFeeTotal": "-0.06444618",
        //                     "closeFeeTotal": "0",
        //                     "createdTime": "1750495670699",
        //                     "updatedTime": "1750929883465"
        //                 }
        //             ]
        //         }
        //     }
        //
        object position = new List<object>() {};
        if (isTrue(isTrue(uta) || isTrue(isHistory)))
        {
            object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
            position = this.safeList(data, "list", new List<object>() {});
        } else
        {
            position = this.safeList(response, "data", new List<object>() {});
        }
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(position)); postFixIncrement(ref i))
        {
            ((IList<object>)result).Add(this.parsePosition(getValue(position, i), market));
        }
        symbols = this.marketSymbols(symbols);
        return this.filterByArrayPositions(result, "symbol", symbols, false);
    }

    public override object parsePosition(object position, object market = null)
    {
        //
        // fetchPosition
        //
        //     {
        //         "marginCoin": "USDT",
        //         "symbol": "BTCUSDT",
        //         "holdSide": "long",
        //         "openDelegateSize": "0",
        //         "marginSize": "3.73555",
        //         "available": "0.002",
        //         "locked": "0",
        //         "total": "0.002",
        //         "leverage": "20",
        //         "achievedProfits": "0",
        //         "openPriceAvg": "37355.5",
        //         "marginMode": "crossed",
        //         "posMode": "hedge_mode",
        //         "unrealizedPL": "0.007",
        //         "liquidationPrice": "31724.970702417",
        //         "keepMarginRate": "0.004",
        //         "markPrice": "37359",
        //         "marginRatio": "0.029599540355",
        //         "cTime": "1700807507275"
        //     }
        //
        // uta: fetchPosition
        //
        //     {
        //         "category": "USDT-FUTURES",
        //         "symbol": "BTCUSDT",
        //         "marginCoin": "USDT",
        //         "holdMode": "hedge_mode",
        //         "posSide": "long",
        //         "marginMode": "crossed",
        //         "positionBalance": "5.435199",
        //         "available": "0.001",
        //         "frozen": "0",
        //         "total": "0.001",
        //         "leverage": "20",
        //         "curRealisedPnl": "0",
        //         "avgPrice": "107410.3",
        //         "positionStatus": "normal",
        //         "unrealisedPnl": "0.0047",
        //         "liquidationPrice": "0",
        //         "mmr": "0.004",
        //         "profitRate": "0.0008647337475591",
        //         "markPrice": "107415.3",
        //         "breakEvenPrice": "107539.2",
        //         "totalFunding": "0",
        //         "openFeeTotal": "-0.06444618",
        //         "closeFeeTotal": "0",
        //         "createdTime": "1750495670699",
        //         "updatedTime": "1750929883465"
        //     }
        //
        // fetchPositions: privateMixGetV2MixPositionAllPosition
        //
        //     {
        //         "marginCoin": "USDT",
        //         "symbol": "BTCUSDT",
        //         "holdSide": "long",
        //         "openDelegateSize": "0",
        //         "marginSize": "3.73555",
        //         "available": "0.002",
        //         "locked": "0",
        //         "total": "0.002",
        //         "leverage": "20",
        //         "achievedProfits": "0",
        //         "openPriceAvg": "37355.5",
        //         "marginMode": "crossed",
        //         "posMode": "hedge_mode",
        //         "unrealizedPL": "0.03",
        //         "liquidationPrice": "31725.023602417",
        //         "keepMarginRate": "0.004",
        //         "markPrice": "37370.5",
        //         "marginRatio": "0.029550120396",
        //         "cTime": "1700807507275"
        //     }
        //
        // fetchPositionsHistory: privateMixGetV2MixPositionHistoryPosition
        //
        //     {
        //         "symbol": "BTCUSDT",
        //         "marginCoin": "USDT",
        //         "holdSide": "long",
        //         "openAvgPrice": "37272.1",
        //         "closeAvgPrice": "37271.4",
        //         "marginMode": "crossed",
        //         "openTotalPos": "0.001",
        //         "closeTotalPos": "0.001",
        //         "pnl": "-0.0007",
        //         "netProfit": "-0.0454261",
        //         "totalFunding": "0",
        //         "openFee": "-0.02236326",
        //         "closeFee": "-0.02236284",
        //         "utime": "1700720700400",
        //         "ctime": "1700720651684"
        //     }
        //
        // closeAllPositions
        //
        //     {
        //         "orderId": "1120923953904893955",
        //         "clientOid": "1120923953904893956"
        //     }
        //
        // uta: fetchPositionsHistory
        //
        //     {
        //         "positionId": "1322441328637100049",
        //         "category": "USDT-FUTURES",
        //         "symbol": "BTCUSDT",
        //         "marginCoin": "USDT",
        //         "holdMode": "hedge_mode",
        //         "posSide": "long",
        //         "marginMode": "crossed",
        //         "openPriceAvg": "107003.7",
        //         "closePriceAvg": "107005.4",
        //         "openTotalPos": "0.0001",
        //         "closeTotalPos": "0.0001",
        //         "cumRealisedPnl": "0.00017",
        //         "netProfit": "-0.01267055",
        //         "totalFunding": "0",
        //         "openFeeTotal": "-0.00642022",
        //         "closeFeeTotal": "-0.00642032",
        //         "createdTime": "1751020503195",
        //         "updatedTime": "1751020520458"
        //     }
        //
        object marketId = this.safeString(position, "symbol");
        market = this.safeMarket(marketId, market, null, "contract");
        object symbol = getValue(market, "symbol");
        object timestamp = this.safeIntegerN(position, new List<object>() {"cTime", "ctime", "createdTime"});
        object marginMode = this.safeString(position, "marginMode");
        object collateral = null;
        object initialMargin = null;
        object unrealizedPnl = this.safeString2(position, "unrealizedPL", "unrealisedPnl");
        object rawCollateral = this.safeString2(position, "marginSize", "positionBalance");
        if (isTrue(isEqual(marginMode, "isolated")))
        {
            collateral = Precise.stringAdd(rawCollateral, unrealizedPnl);
        } else if (isTrue(isEqual(marginMode, "crossed")))
        {
            marginMode = "cross";
            initialMargin = rawCollateral;
        }
        object holdMode = this.safeString2(position, "posMode", "holdMode");
        object hedged = null;
        if (isTrue(isEqual(holdMode, "hedge_mode")))
        {
            hedged = true;
        } else if (isTrue(isEqual(holdMode, "one_way_mode")))
        {
            hedged = false;
        }
        object side = this.safeString2(position, "holdSide", "posSide");
        object leverage = this.safeString(position, "leverage");
        object contractSizeNumber = this.safeValue(market, "contractSize");
        object contractSize = this.numberToString(contractSizeNumber);
        object baseAmount = this.safeString2(position, "total", "openTotalPos");
        object entryPrice = this.safeStringN(position, new List<object>() {"openPriceAvg", "openAvgPrice", "avgPrice"});
        object maintenanceMarginPercentage = this.safeString(position, "keepMarginRate");
        object openNotional = Precise.stringMul(entryPrice, baseAmount);
        if (isTrue(isEqual(initialMargin, null)))
        {
            initialMargin = Precise.stringDiv(openNotional, leverage);
        }
        object contracts = this.parseNumber(Precise.stringDiv(baseAmount, contractSize));
        if (isTrue(isEqual(contracts, null)))
        {
            contracts = this.safeNumber(position, "closeTotalPos");
        }
        object markPrice = this.safeString(position, "markPrice");
        object notional = Precise.stringMul(baseAmount, markPrice);
        object initialMarginPercentage = Precise.stringDiv(initialMargin, notional);
        object liquidationPrice = this.parseNumber(this.omitZero(this.safeString(position, "liquidationPrice")));
        object calcTakerFeeRate = "0.0006";
        object calcTakerFeeMult = "0.9994";
        if (isTrue(isTrue(isTrue((isEqual(liquidationPrice, null))) && isTrue((isEqual(marginMode, "isolated")))) && isTrue(Precise.stringGt(baseAmount, "0"))))
        {
            object signedMargin = Precise.stringDiv(rawCollateral, baseAmount);
            object signedMmp = maintenanceMarginPercentage;
            if (isTrue(isEqual(side, "short")))
            {
                signedMargin = Precise.stringNeg(signedMargin);
                signedMmp = Precise.stringNeg(signedMmp);
            }
            object mmrMinusOne = Precise.stringSub("1", signedMmp);
            object numerator = Precise.stringSub(entryPrice, signedMargin);
            if (isTrue(isEqual(side, "long")))
            {
                mmrMinusOne = Precise.stringMul(mmrMinusOne, calcTakerFeeMult);
            } else
            {
                numerator = Precise.stringMul(numerator, calcTakerFeeMult);
            }
            liquidationPrice = this.parseNumber(Precise.stringDiv(numerator, mmrMinusOne));
        }
        object feeToClose = Precise.stringMul(notional, calcTakerFeeRate);
        object maintenanceMargin = Precise.stringAdd(Precise.stringMul(maintenanceMarginPercentage, notional), feeToClose);
        object percentage = Precise.stringMul(Precise.stringDiv(unrealizedPnl, initialMargin, 4), "100");
        return this.safePosition(new Dictionary<string, object>() {
            { "info", position },
            { "id", this.safeString2(position, "orderId", "positionId") },
            { "symbol", symbol },
            { "notional", this.parseNumber(notional) },
            { "marginMode", marginMode },
            { "liquidationPrice", liquidationPrice },
            { "entryPrice", this.parseNumber(entryPrice) },
            { "unrealizedPnl", this.parseNumber(unrealizedPnl) },
            { "realizedPnl", this.safeNumberN(position, new List<object>() {"pnl", "curRealisedPnl", "cumRealisedPnl"}) },
            { "percentage", this.parseNumber(percentage) },
            { "contracts", contracts },
            { "contractSize", contractSizeNumber },
            { "markPrice", this.parseNumber(markPrice) },
            { "lastPrice", this.safeNumber2(position, "closeAvgPrice", "closePriceAvg") },
            { "side", side },
            { "hedged", hedged },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "lastUpdateTimestamp", this.safeInteger2(position, "utime", "updatedTime") },
            { "maintenanceMargin", this.parseNumber(maintenanceMargin) },
            { "maintenanceMarginPercentage", this.parseNumber(maintenanceMarginPercentage) },
            { "collateral", this.parseNumber(collateral) },
            { "initialMargin", this.parseNumber(initialMargin) },
            { "initialMarginPercentage", this.parseNumber(initialMarginPercentage) },
            { "leverage", this.parseNumber(leverage) },
            { "marginRatio", this.safeNumber2(position, "marginRatio", "mmr") },
            { "stopLossPrice", null },
            { "takeProfitPrice", null },
        });
    }

    /**
     * @method
     * @name bitget#fetchFundingRateHistory
     * @description fetches historical funding rate prices
     * @see https://www.bitget.com/api-doc/contract/market/Get-History-Funding-Rate
     * @see https://www.bitget.com/api-doc/uta/public/Get-History-Funding-Rate
     * @param {string} symbol unified symbol of the market to fetch the funding rate history for
     * @param {int} [since] timestamp in ms of the earliest funding rate to fetch
     * @param {int} [limit] the maximum amount of funding rate structures to fetch
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {boolean} [params.uta] set to true for the unified trading account (uta), defaults to false
     * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [availble parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
     * @returns {object[]} a list of [funding rate structures]{@link https://docs.ccxt.com/?id=funding-rate-history-structure}
     */
    public async override Task<object> fetchFundingRateHistory(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchFundingRateHistory() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object productType = null;
        object uta = null;
        object response = null;
        object result = null;
        var productTypeparametersVariable = this.handleProductTypeAndParams(market, parameters);
        productType = ((IList<object>)productTypeparametersVariable)[0];
        parameters = ((IList<object>)productTypeparametersVariable)[1];
        var utaparametersVariable = this.handleOptionAndParams(parameters, "fetchFundingRateHistory", "uta", false);
        uta = ((IList<object>)utaparametersVariable)[0];
        parameters = ((IList<object>)utaparametersVariable)[1];
        if (isTrue(uta))
        {
            if (isTrue(!isEqual(limit, null)))
            {
                ((IDictionary<string,object>)request)["limit"] = limit;
            }
            ((IDictionary<string,object>)request)["category"] = productType;
            response = await this.publicUtaGetV3MarketHistoryFundRate(this.extend(request, parameters));
            //
            //     {
            //         "code": "00000",
            //         "msg": "success",
            //         "requestTime": 1750435113658,
            //         "data": {
            //             "resultList": [
            //                 {
            //                     "symbol": "BTCUSDT",
            //                     "fundingRate": "-0.000017",
            //                     "fundingRateTimestamp": "1750431600000"
            //                 },
            //             ]
            //         }
            //     }
            //
            object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
            result = this.safeList(data, "resultList", new List<object>() {});
        } else
        {
            object paginate = false;
            var paginateparametersVariable = this.handleOptionAndParams(parameters, "fetchFundingRateHistory", "paginate");
            paginate = ((IList<object>)paginateparametersVariable)[0];
            parameters = ((IList<object>)paginateparametersVariable)[1];
            if (isTrue(paginate))
            {
                return await this.fetchPaginatedCallIncremental("fetchFundingRateHistory", symbol, since, limit, parameters, "pageNo", 100);
            }
            if (isTrue(!isEqual(limit, null)))
            {
                ((IDictionary<string,object>)request)["pageSize"] = limit;
            }
            ((IDictionary<string,object>)request)["productType"] = productType;
            response = await this.publicMixGetV2MixMarketHistoryFundRate(this.extend(request, parameters));
            //
            //     {
            //         "code": "00000",
            //         "msg": "success",
            //         "requestTime": 1652406728393,
            //         "data": [
            //             {
            //                 "symbol": "BTCUSDT",
            //                 "fundingRate": "-0.0003",
            //                 "fundingTime": "1652396400000"
            //             },
            //         ]
            //     }
            //
            result = this.safeList(response, "data", new List<object>() {});
        }
        object rates = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(result)); postFixIncrement(ref i))
        {
            object entry = getValue(result, i);
            object marketId = this.safeString(entry, "symbol");
            object symbolInner = this.safeSymbol(marketId, market);
            object timestamp = this.safeInteger2(entry, "fundingTime", "fundingRateTimestamp");
            ((IList<object>)rates).Add(new Dictionary<string, object>() {
                { "info", entry },
                { "symbol", symbolInner },
                { "fundingRate", this.safeNumber(entry, "fundingRate") },
                { "timestamp", timestamp },
                { "datetime", this.iso8601(timestamp) },
            });
        }
        object sorted = this.sortBy(rates, "timestamp");
        return this.filterBySymbolSinceLimit(sorted, getValue(market, "symbol"), since, limit);
    }

    /**
     * @method
     * @name bitget#fetchFundingRate
     * @description fetch the current funding rate
     * @see https://www.bitget.com/api-doc/contract/market/Get-Current-Funding-Rate
     * @see https://www.bitget.com/api-doc/contract/market/Get-Symbol-Next-Funding-Time
     * @see https://www.bitget.com/api-doc/uta/public/Get-Current-Funding-Rate
     * @param {string} symbol unified market symbol
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {boolean} [params.uta] set to true for the unified trading account (uta), defaults to false
     * @param {string} [params.method] either (default) 'publicMixGetV2MixMarketCurrentFundRate' or 'publicMixGetV2MixMarketFundingTime'
     * @returns {object} a [funding rate structure]{@link https://docs.ccxt.com/?id=funding-rate-structure}
     */
    public async override Task<object> fetchFundingRate(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        if (!isTrue(getValue(market, "swap")))
        {
            throw new BadSymbol ((string)add(this.id, " fetchFundingRate() supports swap contracts only")) ;
        }
        object productType = null;
        var productTypeparametersVariable = this.handleProductTypeAndParams(market, parameters);
        productType = ((IList<object>)productTypeparametersVariable)[0];
        parameters = ((IList<object>)productTypeparametersVariable)[1];
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object uta = null;
        object response = null;
        var utaparametersVariable = this.handleOptionAndParams(parameters, "fetchFundingRate", "uta", false);
        uta = ((IList<object>)utaparametersVariable)[0];
        parameters = ((IList<object>)utaparametersVariable)[1];
        if (isTrue(uta))
        {
            response = await this.publicUtaGetV3MarketCurrentFundRate(this.extend(request, parameters));
        } else
        {
            ((IDictionary<string,object>)request)["productType"] = productType;
            object method = null;
            var methodparametersVariable = this.handleOptionAndParams(parameters, "fetchFundingRate", "method", "publicMixGetV2MixMarketCurrentFundRate");
            method = ((IList<object>)methodparametersVariable)[0];
            parameters = ((IList<object>)methodparametersVariable)[1];
            if (isTrue(isEqual(method, "publicMixGetV2MixMarketCurrentFundRate")))
            {
                response = await this.publicMixGetV2MixMarketCurrentFundRate(this.extend(request, parameters));
            } else if (isTrue(isEqual(method, "publicMixGetV2MixMarketFundingTime")))
            {
                response = await this.publicMixGetV2MixMarketFundingTime(this.extend(request, parameters));
            }
        }
        object data = this.safeList(response, "data", new List<object>() {});
        return this.parseFundingRate(getValue(data, 0), market);
    }

    /**
     * @method
     * @name bitget#fetchFundingRates
     * @description fetch the current funding rates for all markets
     * @see https://www.bitget.com/api-doc/contract/market/Get-All-Symbol-Ticker
     * @param {string[]} [symbols] list of unified market symbols
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.subType] *contract only* 'linear', 'inverse'
     * @param {string} [params.productType] *contract only* 'USDT-FUTURES', 'USDC-FUTURES', 'COIN-FUTURES', 'SUSDT-FUTURES', 'SUSDC-FUTURES' or 'SCOIN-FUTURES'
     * @param {string} [params.method] either (default) 'publicMixGetV2MixMarketTickers' or 'publicMixGetV2MixMarketCurrentFundRate'
     * @returns {object} a dictionary of [funding rate structures]{@link https://docs.ccxt.com/?id=funding-rates-structure}, indexed by market symbols
     */
    public async override Task<object> fetchFundingRates(object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = null;
        if (isTrue(!isEqual(symbols, null)))
        {
            object symbol = this.safeValue(symbols, 0);
            market = this.market(symbol);
        }
        object request = new Dictionary<string, object>() {};
        object productType = null;
        var productTypeparametersVariable = this.handleProductTypeAndParams(market, parameters);
        productType = ((IList<object>)productTypeparametersVariable)[0];
        parameters = ((IList<object>)productTypeparametersVariable)[1];
        object method = "publicMixGetV2MixMarketTickers";
        var methodparametersVariable = this.handleOptionAndParams(parameters, "fetchFundingRates", "method", method);
        method = ((IList<object>)methodparametersVariable)[0];
        parameters = ((IList<object>)methodparametersVariable)[1];
        object response = null;
        ((IDictionary<string,object>)request)["productType"] = productType;
        if (isTrue(isEqual(method, "publicMixGetV2MixMarketTickers")))
        {
            // {
            //     "code": "00000",
            //     "msg": "success",
            //     "requestTime": 1700533773477,
            //     "data": [
            //         {
            //             "symbol": "BTCUSD",
            //             "lastPr": "29904.5",
            //             "askPr": "29904.5",
            //             "bidPr": "29903.5",
            //             "bidSz": "0.5091",
            //             "askSz": "2.2694",
            //             "high24h": "0",
            //             "low24h": "0",
            //             "ts": "1695794271400",
            //             "change24h": "0",
            //             "baseVolume": "0",
            //             "quoteVolume": "0",
            //             "usdtVolume": "0",
            //             "openUtc": "0",
            //             "changeUtc24h": "0",
            //             "indexPrice": "29132.353333",
            //             "fundingRate": "-0.0007",
            //             "holdingAmount": "125.6844",
            //             "deliveryStartTime": null,
            //             "deliveryTime": null,
            //             "deliveryStatus": "delivery_normal",
            //             "open24h": "0",
            //             "markPrice": "12345"
            //         },
            //     ]
            // }
            response = await this.publicMixGetV2MixMarketTickers(this.extend(request, parameters));
        } else if (isTrue(isEqual(method, "publicMixGetV2MixMarketCurrentFundRate")))
        {
            //
            //     {
            //         "code": "00000",
            //         "msg": "success",
            //         "requestTime":1761659449917,
            //         "data":[
            //             {
            //                 "symbol": "BTCUSDT",
            //                 "fundingRate": "-0.000024",
            //                 "fundingRateInterval": "8",
            //                 "nextUpdate": "1761667200000",
            //                 "minFundingRate": "-0.003",
            //                 "maxFundingRate": "0.003"
            //             }
            //         ]
            //     }
            //
            response = await this.publicMixGetV2MixMarketCurrentFundRate(this.extend(request, parameters));
        }
        symbols = this.marketSymbols(symbols);
        object data = this.safeList(response, "data", new List<object>() {});
        return this.parseFundingRates(data, symbols);
    }

    /**
     * @method
     * @name bitget#fetchFundingIntervals
     * @description fetch the funding rate interval for multiple markets
     * @see https://www.bitget.com/api-doc/contract/market/Get-All-Symbol-Ticker
     * @param {string[]} [symbols] list of unified market symbols
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.productType] 'USDT-FUTURES' (default), 'USDC-FUTURES', 'COIN-FUTURES', 'SUSDT-FUTURES', 'SUSDC-FUTURES' or 'SCOIN-FUTURES'
     * @returns {object[]} a list of [funding rate structures]{@link https://docs.ccxt.com/?id=funding-rate-structure}
     */
    public async override Task<object> fetchFundingIntervals(object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        parameters = this.extend(new Dictionary<string, object>() {
            { "method", "publicMixGetV2MixMarketCurrentFundRate" },
        }, parameters);
        return await this.fetchFundingRates(symbols, parameters);
    }

    public override object parseFundingRate(object contract, object market = null)
    {
        //
        // fetchFundingRate: publicMixGetV2MixMarketCurrentFundRate, publicUtaGetV3MarketCurrentFundRate
        //
        //     {
        //         "symbol": "BTCUSDT",
        //         "fundingRate": "-0.000013",
        //         "fundingRateInterval": "8",
        //         "nextUpdate": "1745510400000",
        //         "minFundingRate": "-0.003",
        //         "maxFundingRate": "0.003"
        //     }
        //
        // fetchFundingRate: publicMixGetV2MixMarketFundingTime
        //
        //     {
        //         "symbol": "BTCUSDT",
        //         "nextFundingTime": "1745424000000",
        //         "ratePeriod": "8"
        //     }
        //
        // fetchFundingInterval
        //
        //     {
        //         "symbol": "BTCUSDT",
        //         "nextFundingTime": "1727942400000",
        //         "ratePeriod": "8"
        //     }
        //
        // fetchFundingRates
        //
        //     {
        //         "symbol": "BTCUSD",
        //         "lastPr": "29904.5",
        //         "askPr": "29904.5",
        //         "bidPr": "29903.5",
        //         "bidSz": "0.5091",
        //         "askSz": "2.2694",
        //         "high24h": "0",
        //         "low24h": "0",
        //         "ts": "1695794271400",
        //         "change24h": "0",
        //         "baseVolume": "0",
        //         "quoteVolume": "0",
        //         "usdtVolume": "0",
        //         "openUtc": "0",
        //         "changeUtc24h": "0",
        //         "indexPrice": "29132.353333",
        //         "fundingRate": "-0.0007",
        //         "holdingAmount": "125.6844",
        //         "deliveryStartTime": null,
        //         "deliveryTime": null,
        //         "deliveryStatus": "delivery_normal",
        //         "open24h": "0",
        //         "markPrice": "12345"
        //     }
        //
        object marketId = this.safeString(contract, "symbol");
        object symbol = this.safeSymbol(marketId, market, null, "swap");
        object fundingTimestamp = this.safeInteger2(contract, "nextFundingTime", "nextUpdate");
        object interval = this.safeString2(contract, "ratePeriod", "fundingRateInterval");
        object timestamp = this.safeInteger(contract, "ts");
        object markPrice = this.safeNumber(contract, "markPrice");
        object indexPrice = this.safeNumber(contract, "indexPrice");
        object intervalString = null;
        if (isTrue(!isEqual(interval, null)))
        {
            intervalString = add(interval, "h");
        }
        return new Dictionary<string, object>() {
            { "info", contract },
            { "symbol", symbol },
            { "markPrice", markPrice },
            { "indexPrice", indexPrice },
            { "interestRate", null },
            { "estimatedSettlePrice", null },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "fundingRate", this.safeNumber(contract, "fundingRate") },
            { "fundingTimestamp", fundingTimestamp },
            { "fundingDatetime", this.iso8601(fundingTimestamp) },
            { "nextFundingRate", null },
            { "nextFundingTimestamp", null },
            { "nextFundingDatetime", null },
            { "previousFundingRate", null },
            { "previousFundingTimestamp", null },
            { "previousFundingDatetime", null },
            { "interval", intervalString },
        };
    }

    /**
     * @method
     * @name bitget#fetchFundingHistory
     * @description fetch the funding history
     * @see https://www.bitget.com/api-doc/contract/account/Get-Account-Bill
     * @param {string} symbol unified market symbol
     * @param {int} [since] the starting timestamp in milliseconds
     * @param {int} [limit] the number of entries to return
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {int} [params.until] the latest time in ms to fetch funding history for
     * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [available parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
     * @returns {object[]} a list of [funding history structures]{@link https://docs.ccxt.com/?id=funding-history-structure}
     */
    public async override Task<object> fetchFundingHistory(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchFundingHistory() requires a symbol argument")) ;
        }
        object paginate = false;
        var paginateparametersVariable = this.handleOptionAndParams(parameters, "fetchFundingHistory", "paginate");
        paginate = ((IList<object>)paginateparametersVariable)[0];
        parameters = ((IList<object>)paginateparametersVariable)[1];
        if (isTrue(paginate))
        {
            return await this.fetchPaginatedCallCursor("fetchFundingHistory", symbol, since, limit, parameters, "endId", "idLessThan");
        }
        object market = this.market(symbol);
        if (!isTrue(getValue(market, "swap")))
        {
            throw new BadSymbol ((string)add(this.id, " fetchFundingHistory() supports swap contracts only")) ;
        }
        object productType = null;
        var productTypeparametersVariable = this.handleProductTypeAndParams(market, parameters);
        productType = ((IList<object>)productTypeparametersVariable)[0];
        parameters = ((IList<object>)productTypeparametersVariable)[1];
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
            { "marginCoin", getValue(market, "settleId") },
            { "businessType", "contract_settle_fee" },
            { "productType", productType },
        };
        var requestparametersVariable = this.handleUntilOption("endTime", request, parameters);
        request = ((IList<object>)requestparametersVariable)[0];
        parameters = ((IList<object>)requestparametersVariable)[1];
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["startTime"] = since;
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        object response = await this.privateMixGetV2MixAccountBill(this.extend(request, parameters));
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1700795977890,
        //         "data": {
        //             "bills": [
        //                 {
        //                     "billId": "1111499428100472833",
        //                     "symbol": "BTCUSDT",
        //                     "amount": "-0.004992",
        //                     "fee": "0",
        //                     "feeByCoupon": "",
        //                     "businessType": "contract_settle_fee",
        //                     "coin": "USDT",
        //                     "cTime": "1700728034996"
        //                 },
        //             ],
        //             "endId": "1098396773329305606"
        //         }
        //     }
        //
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        object result = this.safeValue(data, "bills", new List<object>() {});
        return this.parseFundingHistories(result, market, since, limit);
    }

    public virtual object parseFundingHistory(object contract, object market = null)
    {
        //
        //     {
        //         "billId": "1111499428100472833",
        //         "symbol": "BTCUSDT",
        //         "amount": "-0.004992",
        //         "fee": "0",
        //         "feeByCoupon": "",
        //         "businessType": "contract_settle_fee",
        //         "coin": "USDT",
        //         "cTime": "1700728034996"
        //     }
        //
        object marketId = this.safeString(contract, "symbol");
        object currencyId = this.safeString(contract, "coin");
        object timestamp = this.safeInteger(contract, "cTime");
        return new Dictionary<string, object>() {
            { "info", contract },
            { "symbol", this.safeSymbol(marketId, market, null, "swap") },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "code", this.safeCurrencyCode(currencyId) },
            { "amount", this.safeNumber(contract, "amount") },
            { "id", this.safeString(contract, "billId") },
        };
    }

    public virtual object parseFundingHistories(object contracts, object market = null, object since = null, object limit = null)
    {
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(contracts)); postFixIncrement(ref i))
        {
            object contract = getValue(contracts, i);
            object business = this.safeString(contract, "businessType");
            if (isTrue(!isEqual(business, "contract_settle_fee")))
            {
                continue;
            }
            ((IList<object>)result).Add(this.parseFundingHistory(contract, market));
        }
        object sorted = this.sortBy(result, "timestamp");
        object symbol = null;
        if (isTrue(!isEqual(market, null)))
        {
            symbol = getValue(market, "symbol");
        }
        return this.filterBySymbolSinceLimit(sorted, symbol, since, limit);
    }

    public async virtual Task<object> modifyMarginHelper(object symbol, object amount, object type, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object holdSide = this.safeString(parameters, "holdSide");
        object market = this.market(symbol);
        object productType = null;
        var productTypeparametersVariable = this.handleProductTypeAndParams(market, parameters);
        productType = ((IList<object>)productTypeparametersVariable)[0];
        parameters = ((IList<object>)productTypeparametersVariable)[1];
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
            { "marginCoin", getValue(market, "settleId") },
            { "amount", this.amountToPrecision(symbol, amount) },
            { "holdSide", holdSide },
            { "productType", productType },
        };
        parameters = this.omit(parameters, "holdSide");
        object response = await this.privateMixPostV2MixAccountSetMargin(this.extend(request, parameters));
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1700813444618,
        //         "data": ""
        //     }
        //
        return this.extend(this.parseMarginModification(response, market), new Dictionary<string, object>() {
            { "amount", this.parseNumber(amount) },
            { "type", type },
        });
    }

    public override object parseMarginModification(object data, object market = null)
    {
        //
        // addMargin/reduceMargin
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1700813444618,
        //         "data": ""
        //     }
        //
        object errorCode = this.safeString(data, "code");
        object status = ((bool) isTrue((isEqual(errorCode, "00000")))) ? "ok" : "failed";
        return new Dictionary<string, object>() {
            { "info", data },
            { "symbol", getValue(market, "symbol") },
            { "type", null },
            { "marginMode", "isolated" },
            { "amount", null },
            { "total", null },
            { "code", getValue(market, "settle") },
            { "status", status },
            { "timestamp", null },
            { "datetime", null },
        };
    }

    /**
     * @method
     * @name bitget#reduceMargin
     * @description remove margin from a position
     * @see https://www.bitget.com/api-doc/contract/account/Change-Margin
     * @param {string} symbol unified market symbol
     * @param {float} amount the amount of margin to remove
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [margin structure]{@link https://docs.ccxt.com/?id=margin-structure}
     */
    public async override Task<object> reduceMargin(object symbol, object amount, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isGreaterThan(amount, 0)))
        {
            throw new BadRequest ((string)add(this.id, " reduceMargin() amount parameter must be a negative value")) ;
        }
        object holdSide = this.safeString(parameters, "holdSide");
        if (isTrue(isEqual(holdSide, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " reduceMargin() requires a holdSide parameter, either long or short")) ;
        }
        return await this.modifyMarginHelper(symbol, amount, "reduce", parameters);
    }

    /**
     * @method
     * @name bitget#addMargin
     * @description add margin
     * @see https://www.bitget.com/api-doc/contract/account/Change-Margin
     * @param {string} symbol unified market symbol
     * @param {float} amount the amount of margin to add
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [margin structure]{@link https://docs.ccxt.com/?id=margin-structure}
     */
    public async override Task<object> addMargin(object symbol, object amount, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object holdSide = this.safeString(parameters, "holdSide");
        if (isTrue(isEqual(holdSide, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " addMargin() requires a holdSide parameter, either long or short")) ;
        }
        return await this.modifyMarginHelper(symbol, amount, "add", parameters);
    }

    /**
     * @method
     * @name bitget#fetchLeverage
     * @description fetch the set leverage for a market
     * @see https://www.bitget.com/api-doc/contract/account/Get-Single-Account
     * @param {string} symbol unified market symbol
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [leverage structure]{@link https://docs.ccxt.com/?id=leverage-structure}
     */
    public async override Task<object> fetchLeverage(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object productType = null;
        var productTypeparametersVariable = this.handleProductTypeAndParams(market, parameters);
        productType = ((IList<object>)productTypeparametersVariable)[0];
        parameters = ((IList<object>)productTypeparametersVariable)[1];
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
            { "marginCoin", getValue(market, "settleId") },
            { "productType", productType },
        };
        object response = await this.privateMixGetV2MixAccountAccount(this.extend(request, parameters));
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1709366911964,
        //         "data": {
        //             "marginCoin": "USDT",
        //             "locked": "0",
        //             "available": "0",
        //             "crossedMaxAvailable": "0",
        //             "isolatedMaxAvailable": "0",
        //             "maxTransferOut": "0",
        //             "accountEquity": "0",
        //             "usdtEquity": "0.000000009166",
        //             "btcEquity": "0",
        //             "crossedRiskRate": "0",
        //             "crossedMarginLeverage": 20,
        //             "isolatedLongLever": 20,
        //             "isolatedShortLever": 20,
        //             "marginMode": "crossed",
        //             "posMode": "hedge_mode",
        //             "unrealizedPL": "0",
        //             "coupon": "0",
        //             "crossedUnrealizedPL": "0",
        //             "isolatedUnrealizedPL": ""
        //         }
        //     }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        return this.parseLeverage(data, market);
    }

    public override object parseLeverage(object leverage, object market = null)
    {
        object isCrossMarginMode = isEqual(this.safeString(leverage, "marginMode"), "crossed");
        object longLevKey = ((bool) isTrue(isCrossMarginMode)) ? "crossedMarginLeverage" : "isolatedLongLever";
        object shortLevKey = ((bool) isTrue(isCrossMarginMode)) ? "crossedMarginLeverage" : "isolatedShortLever";
        return new Dictionary<string, object>() {
            { "info", leverage },
            { "symbol", getValue(market, "symbol") },
            { "marginMode", ((bool) isTrue(isCrossMarginMode)) ? "cross" : "isolated" },
            { "longLeverage", this.safeInteger(leverage, longLevKey) },
            { "shortLeverage", this.safeInteger(leverage, shortLevKey) },
        };
    }

    /**
     * @method
     * @name bitget#setLeverage
     * @description set the level of leverage for a market
     * @see https://www.bitget.com/api-doc/contract/account/Change-Leverage
     * @see https://www.bitget.com/api-doc/uta/account/Change-Leverage
     * @param {int} leverage the rate of leverage
     * @param {string} symbol unified market symbol
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.holdSide] *isolated only* position direction, 'long' or 'short'
     * @param {boolean} [params.uta] set to true for the unified trading account (uta), defaults to false
     * @param {boolean} [params.posSide] required for uta isolated margin, long or short
     * @returns {object} response from the exchange
     */
    public async override Task<object> setLeverage(object leverage, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " setLeverage() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object productType = null;
        var productTypeparametersVariable = this.handleProductTypeAndParams(market, parameters);
        productType = ((IList<object>)productTypeparametersVariable)[0];
        parameters = ((IList<object>)productTypeparametersVariable)[1];
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
            { "leverage", this.numberToString(leverage) },
        };
        object uta = null;
        object response = null;
        var utaparametersVariable = this.handleOptionAndParams(parameters, "setLeverage", "uta", false);
        uta = ((IList<object>)utaparametersVariable)[0];
        parameters = ((IList<object>)utaparametersVariable)[1];
        if (isTrue(uta))
        {
            if (isTrue(isEqual(productType, "SPOT")))
            {
                object marginMode = null;
                var marginModeparametersVariable = this.handleMarginModeAndParams("fetchTrades", parameters);
                marginMode = ((IList<object>)marginModeparametersVariable)[0];
                parameters = ((IList<object>)marginModeparametersVariable)[1];
                if (isTrue(!isEqual(marginMode, null)))
                {
                    productType = "MARGIN";
                }
            }
            ((IDictionary<string,object>)request)["coin"] = getValue(market, "settleId");
            ((IDictionary<string,object>)request)["category"] = productType;
            response = await this.privateUtaPostV3AccountSetLeverage(this.extend(request, parameters));
        } else
        {
            ((IDictionary<string,object>)request)["marginCoin"] = getValue(market, "settleId");
            ((IDictionary<string,object>)request)["productType"] = productType;
            response = await this.privateMixPostV2MixAccountSetLeverage(this.extend(request, parameters));
        }
        return response;
    }

    /**
     * @method
     * @name bitget#setMarginMode
     * @description set margin mode to 'cross' or 'isolated'
     * @see https://www.bitget.com/api-doc/contract/account/Change-Margin-Mode
     * @param {string} marginMode 'cross' or 'isolated'
     * @param {string} symbol unified market symbol
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} response from the exchange
     */
    public async override Task<object> setMarginMode(object marginMode, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " setMarginMode() requires a symbol argument")) ;
        }
        marginMode = ((string)marginMode).ToLower();
        if (isTrue(isEqual(marginMode, "cross")))
        {
            marginMode = "crossed";
        }
        if (isTrue(isTrue((!isEqual(marginMode, "isolated"))) && isTrue((!isEqual(marginMode, "crossed")))))
        {
            throw new ArgumentsRequired ((string)add(this.id, " setMarginMode() marginMode must be either isolated or crossed (cross)")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object productType = null;
        var productTypeparametersVariable = this.handleProductTypeAndParams(market, parameters);
        productType = ((IList<object>)productTypeparametersVariable)[0];
        parameters = ((IList<object>)productTypeparametersVariable)[1];
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
            { "marginCoin", getValue(market, "settleId") },
            { "marginMode", marginMode },
            { "productType", productType },
        };
        object response = await this.privateMixPostV2MixAccountSetMarginMode(this.extend(request, parameters));
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1700865205552,
        //         "data": {
        //             "symbol": "BTCUSDT",
        //             "marginCoin": "USDT",
        //             "longLeverage": "20",
        //             "shortLeverage": "3",
        //             "marginMode": "isolated"
        //         }
        //     }
        //
        return response;
    }

    /**
     * @method
     * @name bitget#setPositionMode
     * @description set hedged to true or false for a market
     * @see https://www.bitget.com/api-doc/contract/account/Change-Hold-Mode
     * @see https://www.bitget.com/api-doc/uta/account/Change-Position-Mode
     * @param {bool} hedged set to true to use dualSidePosition
     * @param {string} symbol not used by bitget setPositionMode ()
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.productType] required if not uta and symbol is undefined: 'USDT-FUTURES', 'USDC-FUTURES', 'COIN-FUTURES', 'SUSDT-FUTURES', 'SUSDC-FUTURES' or 'SCOIN-FUTURES'
     * @param {boolean} [params.uta] set to true for the unified trading account (uta), defaults to false
     * @returns {object} response from the exchange
     */
    public async override Task<object> setPositionMode(object hedged, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object posMode = ((bool) isTrue(hedged)) ? "hedge_mode" : "one_way_mode";
        object request = new Dictionary<string, object>() {};
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
        }
        object productType = null;
        object uta = null;
        object response = null;
        var productTypeparametersVariable = this.handleProductTypeAndParams(market, parameters);
        productType = ((IList<object>)productTypeparametersVariable)[0];
        parameters = ((IList<object>)productTypeparametersVariable)[1];
        var utaparametersVariable = this.handleOptionAndParams(parameters, "setPositionMode", "uta", false);
        uta = ((IList<object>)utaparametersVariable)[0];
        parameters = ((IList<object>)utaparametersVariable)[1];
        if (isTrue(uta))
        {
            ((IDictionary<string,object>)request)["holdMode"] = posMode;
            response = await this.privateUtaPostV3AccountSetHoldMode(this.extend(request, parameters));
        } else
        {
            ((IDictionary<string,object>)request)["posMode"] = posMode;
            ((IDictionary<string,object>)request)["productType"] = productType;
            response = await this.privateMixPostV2MixAccountSetPositionMode(this.extend(request, parameters));
        }
        return response;
    }

    /**
     * @method
     * @name bitget#fetchOpenInterest
     * @description retrieves the open interest of a contract trading pair
     * @see https://www.bitget.com/api-doc/contract/market/Get-Open-Interest
     * @see https://www.bitget.com/api-doc/uta/public/Get-Open-Interest
     * @param {string} symbol unified CCXT market symbol
     * @param {object} [params] exchange specific parameters
     * @param {boolean} [params.uta] set to true for the unified trading account (uta), defaults to false
     * @returns {object} an open interest structure{@link https://docs.ccxt.com/?id=open-interest-structure}
     */
    public async override Task<object> fetchOpenInterest(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        if (!isTrue(getValue(market, "contract")))
        {
            throw new BadRequest ((string)add(this.id, " fetchOpenInterest() supports contract markets only")) ;
        }
        object productType = null;
        var productTypeparametersVariable = this.handleProductTypeAndParams(market, parameters);
        productType = ((IList<object>)productTypeparametersVariable)[0];
        parameters = ((IList<object>)productTypeparametersVariable)[1];
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object uta = null;
        object response = null;
        var utaparametersVariable = this.handleOptionAndParams(parameters, "fetchOpenInterest", "uta", false);
        uta = ((IList<object>)utaparametersVariable)[0];
        parameters = ((IList<object>)utaparametersVariable)[1];
        if (isTrue(uta))
        {
            ((IDictionary<string,object>)request)["category"] = productType;
            response = await this.publicUtaGetV3MarketOpenInterest(this.extend(request, parameters));
        } else
        {
            ((IDictionary<string,object>)request)["productType"] = productType;
            response = await this.publicMixGetV2MixMarketOpenInterest(this.extend(request, parameters));
        }
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        return this.parseOpenInterest(data, market);
    }

    public override object parseOpenInterest(object interest, object market = null)
    {
        //
        // default
        //
        //     {
        //         "openInterestList": [
        //             {
        //                 "symbol": "BTCUSDT",
        //                 "size": "52234.134"
        //             }
        //         ],
        //         "ts": "1700866041023"
        //     }
        //
        // uta
        //
        //     {
        //         "list": [
        //             {
        //                 "symbol": "BTCUSDT",
        //                 "openInterest": "18166.3583"
        //             }
        //         ],
        //         "ts": "1751101220993"
        //     }
        //
        object data = this.safeList2(interest, "openInterestList", "list", new List<object>() {});
        object timestamp = this.safeInteger(interest, "ts");
        object marketId = this.safeString(getValue(data, 0), "symbol");
        return this.safeOpenInterest(new Dictionary<string, object>() {
            { "symbol", this.safeSymbol(marketId, market, null, "contract") },
            { "openInterestAmount", this.safeNumber2(getValue(data, 0), "size", "openInterest") },
            { "openInterestValue", null },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "info", interest },
        }, market);
    }

    /**
     * @method
     * @name bitget#fetchTransfers
     * @description fetch a history of internal transfers made on an account
     * @see https://www.bitget.com/api-doc/spot/account/Get-Account-TransferRecords
     * @param {string} code unified currency code of the currency transferred
     * @param {int} [since] the earliest time in ms to fetch transfers for
     * @param {int} [limit] the maximum number of transfers structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {int} [params.until] the latest time in ms to fetch entries for
     * @returns {object[]} a list of [transfer structures]{@link https://docs.ccxt.com/?id=transfer-structure}
     */
    public async override Task<object> fetchTransfers(object code = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(code, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchTransfers() requires a code argument")) ;
        }
        await this.loadMarkets();
        object type = null;
        var typeparametersVariable = this.handleMarketTypeAndParams("fetchTransfers", null, parameters);
        type = ((IList<object>)typeparametersVariable)[0];
        parameters = ((IList<object>)typeparametersVariable)[1];
        object fromAccount = this.safeString(parameters, "fromAccount", type);
        parameters = this.omit(parameters, "fromAccount");
        object accountsByType = this.safeValue(this.options, "accountsByType", new Dictionary<string, object>() {});
        type = this.safeString(accountsByType, fromAccount);
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "coin", getValue(currency, "id") },
            { "fromType", type },
        };
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["startTime"] = since;
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        var requestparametersVariable = this.handleUntilOption("endTime", request, parameters);
        request = ((IList<object>)requestparametersVariable)[0];
        parameters = ((IList<object>)requestparametersVariable)[1];
        object response = await this.privateSpotGetV2SpotAccountTransferRecords(this.extend(request, parameters));
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1700873854651,
        //         "data": [
        //             {
        //                 "coin": "USDT",
        //                 "status": "Successful",
        //                 "toType": "crossed_margin",
        //                 "toSymbol": "",
        //                 "fromType": "spot",
        //                 "fromSymbol": "",
        //                 "size": "11.64958799",
        //                 "ts": "1700729673028",
        //                 "clientOid": "1111506298504744960",
        //                 "transferId": "24930940"
        //             },
        //         ]
        //     }
        //
        object data = this.safeList(response, "data", new List<object>() {});
        return this.parseTransfers(data, currency, since, limit);
    }

    /**
     * @method
     * @name bitget#transfer
     * @description transfer currency internally between wallets on the same account
     * @see https://www.bitget.com/api-doc/spot/account/Wallet-Transfer
     * @param {string} code unified currency code
     * @param {float} amount amount to transfer
     * @param {string} fromAccount account to transfer from
     * @param {string} toAccount account to transfer to
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.symbol] unified CCXT market symbol, required when transferring to or from an account type that is a leveraged position-by-position account
     * @param {string} [params.clientOid] custom id
     * @returns {object} a [transfer structure]{@link https://docs.ccxt.com/?id=transfer-structure}
     */
    public async override Task<object> transfer(object code, object amount, object fromAccount, object toAccount, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        object accountsByType = this.safeValue(this.options, "accountsByType", new Dictionary<string, object>() {});
        object fromType = this.safeString(accountsByType, fromAccount);
        object toType = this.safeString(accountsByType, toAccount);
        object request = new Dictionary<string, object>() {
            { "fromType", fromType },
            { "toType", toType },
            { "amount", amount },
            { "coin", getValue(currency, "id") },
        };
        object symbol = this.safeString(parameters, "symbol");
        parameters = this.omit(parameters, "symbol");
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
        }
        object response = await this.privateSpotPostV2SpotWalletTransfer(this.extend(request, parameters));
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1700874302021,
        //         "data": {
        //             "transferId": "1112112916581847040",
        //             "clientOrderId": null
        //         }
        //     }
        //
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        ((IDictionary<string,object>)data)["ts"] = this.safeInteger(response, "requestTime");
        return this.parseTransfer(data, currency);
    }

    public override object parseTransfer(object transfer, object currency = null)
    {
        //
        // transfer
        //
        //     {
        //         "transferId": "1112112916581847040",
        //         "clientOrderId": null,
        //         "ts": 1700874302021
        //     }
        //
        // fetchTransfers
        //
        //     {
        //         "coin": "USDT",
        //         "status": "Successful",
        //         "toType": "crossed_margin",
        //         "toSymbol": "",
        //         "fromType": "spot",
        //         "fromSymbol": "",
        //         "size": "11.64958799",
        //         "ts": "1700729673028",
        //         "clientOid": "1111506298504744960",
        //         "transferId": "24930940"
        //     }
        //
        object timestamp = this.safeInteger(transfer, "ts");
        object status = this.safeStringLower(transfer, "status");
        object currencyId = this.safeString(transfer, "coin");
        object fromAccountRaw = this.safeString(transfer, "fromType");
        object accountsById = this.safeValue(this.options, "accountsById", new Dictionary<string, object>() {});
        object fromAccount = this.safeString(accountsById, fromAccountRaw, fromAccountRaw);
        object toAccountRaw = this.safeString(transfer, "toType");
        object toAccount = this.safeString(accountsById, toAccountRaw, toAccountRaw);
        return new Dictionary<string, object>() {
            { "info", transfer },
            { "id", this.safeString(transfer, "transferId") },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "currency", this.safeCurrencyCode(currencyId, currency) },
            { "amount", this.safeNumber(transfer, "size") },
            { "fromAccount", fromAccount },
            { "toAccount", toAccount },
            { "status", this.parseTransferStatus(status) },
        };
    }

    public virtual object parseTransferStatus(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "successful", "ok" },
        };
        return this.safeString(statuses, status, status);
    }

    public override object parseDepositWithdrawFee(object fee, object currency = null)
    {
        //
        //     {
        //         "chains": [
        //             {
        //                 "browserUrl": "https://blockchair.com/bitcoin/transaction/",
        //                 "chain": "BTC",
        //                 "depositConfirm": "1",
        //                 "extraWithdrawFee": "0",
        //                 "minDepositAmount": "0.0001",
        //                 "minWithdrawAmount": "0.005",
        //                 "needTag": "false",
        //                 "rechargeable": "true",
        //                 "withdrawConfirm": "1",
        //                 "withdrawFee": "0.0004",
        //                 "withdrawable": "true"
        //             },
        //         ],
        //         "coin": "BTC",
        //         "coinId": "1",
        //         "transfer": "true""
        //     }
        //
        object chains = this.safeValue(fee, "chains", new List<object>() {});
        object chainsLength = getArrayLength(chains);
        object result = new Dictionary<string, object>() {
            { "info", fee },
            { "withdraw", new Dictionary<string, object>() {
                { "fee", null },
                { "percentage", null },
            } },
            { "deposit", new Dictionary<string, object>() {
                { "fee", null },
                { "percentage", null },
            } },
            { "networks", new Dictionary<string, object>() {} },
        };
        for (object i = 0; isLessThan(i, chainsLength); postFixIncrement(ref i))
        {
            object chain = getValue(chains, i);
            object networkId = this.safeString(chain, "chain");
            object currencyCode = this.safeString(currency, "code");
            object networkCode = this.networkIdToCode(networkId, currencyCode);
            ((IDictionary<string,object>)getValue(result, "networks"))[(string)networkCode] = new Dictionary<string, object>() {
                { "deposit", new Dictionary<string, object>() {
                    { "fee", null },
                    { "percentage", null },
                } },
                { "withdraw", new Dictionary<string, object>() {
                    { "fee", this.safeNumber(chain, "withdrawFee") },
                    { "percentage", false },
                } },
            };
            if (isTrue(isEqual(chainsLength, 1)))
            {
                ((IDictionary<string,object>)getValue(result, "withdraw"))["fee"] = this.safeNumber(chain, "withdrawFee");
                ((IDictionary<string,object>)getValue(result, "withdraw"))["percentage"] = false;
            }
        }
        return result;
    }

    /**
     * @method
     * @name bitget#fetchDepositWithdrawFees
     * @description fetch deposit and withdraw fees
     * @see https://www.bitget.com/api-doc/spot/market/Get-Coin-List
     * @param {string[]|undefined} codes list of unified currency codes
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a list of [fee structures]{@link https://docs.ccxt.com/?id=fee-structure}
     */
    public async override Task<object> fetchDepositWithdrawFees(object codes = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.publicSpotGetV2SpotPublicCoins(parameters);
        //
        //     {
        //         "code": "00000",
        //         "data": [
        //             {
        //                 "chains": [
        //                     {
        //                         "browserUrl": "https://blockchair.com/bitcoin/transaction/",
        //                         "chain": "BTC",
        //                         "depositConfirm": "1",
        //                         "extraWithdrawFee": "0",
        //                         "minDepositAmount": "0.0001",
        //                         "minWithdrawAmount": "0.005",
        //                         "needTag": "false",
        //                         "rechargeable": "true",
        //                         "withdrawConfirm": "1",
        //                         "withdrawFee": "0.0004",
        //                         "withdrawable": "true"
        //                     },
        //                 ],
        //                 "coin": "BTC",
        //                 "coinId": "1",
        //                 "transfer": "true""
        //             }
        //         ],
        //         "msg": "success",
        //         "requestTime": "1700120731773"
        //     }
        //
        object data = this.safeList(response, "data", new List<object>() {});
        return this.parseDepositWithdrawFees(data, codes, "coin");
    }

    /**
     * @method
     * @name bitget#borrowCrossMargin
     * @description create a loan to borrow margin
     * @see https://www.bitget.com/api-doc/margin/cross/account/Cross-Borrow
     * @param {string} code unified currency code of the currency to borrow
     * @param {string} amount the amount to borrow
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [margin loan structure]{@link https://docs.ccxt.com/?id=margin-loan-structure}
     */
    public async override Task<object> borrowCrossMargin(object code, object amount, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "coin", getValue(currency, "id") },
            { "borrowAmount", this.currencyToPrecision(code, amount) },
        };
        object response = await this.privateMarginPostV2MarginCrossedAccountBorrow(this.extend(request, parameters));
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1700876470931,
        //         "data": {
        //             "loanId": "1112122013642272769",
        //             "coin": "USDT",
        //             "borrowAmount": "4"
        //         }
        //     }
        //
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        return this.parseMarginLoan(data, currency);
    }

    /**
     * @method
     * @name bitget#borrowIsolatedMargin
     * @description create a loan to borrow margin
     * @see https://www.bitget.com/api-doc/margin/isolated/account/Isolated-Borrow
     * @param {string} symbol unified market symbol
     * @param {string} code unified currency code of the currency to borrow
     * @param {string} amount the amount to borrow
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [margin loan structure]{@link https://docs.ccxt.com/?id=margin-loan-structure}
     */
    public async override Task<object> borrowIsolatedMargin(object symbol, object code, object amount, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "coin", getValue(currency, "id") },
            { "borrowAmount", this.currencyToPrecision(code, amount) },
            { "symbol", getValue(market, "id") },
        };
        object response = await this.privateMarginPostV2MarginIsolatedAccountBorrow(this.extend(request, parameters));
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1700877255605,
        //         "data": {
        //             "loanId": "1112125304879067137",
        //             "symbol": "BTCUSDT",
        //             "coin": "USDT",
        //             "borrowAmount": "4"
        //         }
        //     }
        //
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        return this.parseMarginLoan(data, currency, market);
    }

    /**
     * @method
     * @name bitget#repayIsolatedMargin
     * @description repay borrowed margin and interest
     * @see https://www.bitget.com/api-doc/margin/isolated/account/Isolated-Repay
     * @param {string} symbol unified market symbol
     * @param {string} code unified currency code of the currency to repay
     * @param {string} amount the amount to repay
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [margin loan structure]{@link https://docs.ccxt.com/?id=margin-loan-structure}
     */
    public async override Task<object> repayIsolatedMargin(object symbol, object code, object amount, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "coin", getValue(currency, "id") },
            { "repayAmount", this.currencyToPrecision(code, amount) },
            { "symbol", getValue(market, "id") },
        };
        object response = await this.privateMarginPostV2MarginIsolatedAccountRepay(this.extend(request, parameters));
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1700877518012,
        //         "data": {
        //             "remainDebtAmount": "0",
        //             "repayId": "1112126405439270912",
        //             "symbol": "BTCUSDT",
        //             "coin": "USDT",
        //             "repayAmount": "8.000137"
        //         }
        //     }
        //
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        return this.parseMarginLoan(data, currency, market);
    }

    /**
     * @method
     * @name bitget#repayCrossMargin
     * @description repay borrowed margin and interest
     * @see https://www.bitget.com/api-doc/margin/cross/account/Cross-Repay
     * @param {string} code unified currency code of the currency to repay
     * @param {string} amount the amount to repay
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [margin loan structure]{@link https://docs.ccxt.com/?id=margin-loan-structure}
     */
    public async override Task<object> repayCrossMargin(object code, object amount, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "coin", getValue(currency, "id") },
            { "repayAmount", this.currencyToPrecision(code, amount) },
        };
        object response = await this.privateMarginPostV2MarginCrossedAccountRepay(this.extend(request, parameters));
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1700876704885,
        //         "data": {
        //             "remainDebtAmount": "0",
        //             "repayId": "1112122994945830912",
        //             "coin": "USDT",
        //             "repayAmount": "4.00006834"
        //         }
        //     }
        //
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        return this.parseMarginLoan(data, currency);
    }

    public virtual object parseMarginLoan(object info, object currency = null, object market = null)
    {
        //
        // isolated: borrowMargin
        //
        //     {
        //         "loanId": "1112125304879067137",
        //         "symbol": "BTCUSDT",
        //         "coin": "USDT",
        //         "borrowAmount": "4"
        //     }
        //
        // cross: borrowMargin
        //
        //     {
        //         "loanId": "1112122013642272769",
        //         "coin": "USDT",
        //         "borrowAmount": "4"
        //     }
        //
        // isolated: repayMargin
        //
        //     {
        //         "remainDebtAmount": "0",
        //         "repayId": "1112126405439270912",
        //         "symbol": "BTCUSDT",
        //         "coin": "USDT",
        //         "repayAmount": "8.000137"
        //     }
        //
        // cross: repayMargin
        //
        //     {
        //         "remainDebtAmount": "0",
        //         "repayId": "1112122994945830912",
        //         "coin": "USDT",
        //         "repayAmount": "4.00006834"
        //     }
        //
        object currencyId = this.safeString(info, "coin");
        object marketId = this.safeString(info, "symbol");
        object symbol = null;
        if (isTrue(!isEqual(marketId, null)))
        {
            symbol = this.safeSymbol(marketId, market, null, "spot");
        }
        return new Dictionary<string, object>() {
            { "id", this.safeString2(info, "loanId", "repayId") },
            { "currency", this.safeCurrencyCode(currencyId, currency) },
            { "amount", this.safeNumber2(info, "borrowAmount", "repayAmount") },
            { "symbol", symbol },
            { "timestamp", null },
            { "datetime", null },
            { "info", info },
        };
    }

    /**
     * @method
     * @name bitget#fetchMyLiquidations
     * @description retrieves the users liquidated positions
     * @see https://www.bitget.com/api-doc/margin/cross/record/Get-Cross-Liquidation-Records
     * @see https://www.bitget.com/api-doc/margin/isolated/record/Get-Isolated-Liquidation-Records
     * @param {string} [symbol] unified CCXT market symbol
     * @param {int} [since] the earliest time in ms to fetch liquidations for
     * @param {int} [limit] the maximum number of liquidation structures to retrieve
     * @param {object} [params] exchange specific parameters for the bitget api endpoint
     * @param {int} [params.until] timestamp in ms of the latest liquidation
     * @param {string} [params.marginMode] 'cross' or 'isolated' default value is 'cross'
     * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [available parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
     * @returns {object} an array of [liquidation structures]{@link https://docs.ccxt.com/?id=liquidation-structure}
     */
    public async override Task<object> fetchMyLiquidations(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object paginate = false;
        var paginateparametersVariable = this.handleOptionAndParams(parameters, "fetchMyLiquidations", "paginate");
        paginate = ((IList<object>)paginateparametersVariable)[0];
        parameters = ((IList<object>)paginateparametersVariable)[1];
        if (isTrue(paginate))
        {
            return await this.fetchPaginatedCallCursor("fetchMyLiquidations", symbol, since, limit, parameters, "minId", "idLessThan");
        }
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
        }
        object type = null;
        var typeparametersVariable = this.handleMarketTypeAndParams("fetchMyLiquidations", market, parameters);
        type = ((IList<object>)typeparametersVariable)[0];
        parameters = ((IList<object>)typeparametersVariable)[1];
        if (isTrue(!isEqual(type, "spot")))
        {
            throw new NotSupported ((string)add(this.id, " fetchMyLiquidations() supports spot margin markets only")) ;
        }
        object request = new Dictionary<string, object>() {};
        var requestparametersVariable = this.handleUntilOption("endTime", request, parameters);
        request = ((IList<object>)requestparametersVariable)[0];
        parameters = ((IList<object>)requestparametersVariable)[1];
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["startTime"] = since;
        } else
        {
            ((IDictionary<string,object>)request)["startTime"] = subtract(this.milliseconds(), 7776000000);
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        object response = null;
        object marginMode = null;
        var marginModeparametersVariable = this.handleMarginModeAndParams("fetchMyLiquidations", parameters, "cross");
        marginMode = ((IList<object>)marginModeparametersVariable)[0];
        parameters = ((IList<object>)marginModeparametersVariable)[1];
        if (isTrue(isEqual(marginMode, "isolated")))
        {
            if (isTrue(isEqual(symbol, null)))
            {
                throw new ArgumentsRequired ((string)add(this.id, " fetchMyLiquidations() requires a symbol argument")) ;
            }
            ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
            response = await this.privateMarginGetV2MarginIsolatedLiquidationHistory(this.extend(request, parameters));
        } else if (isTrue(isEqual(marginMode, "cross")))
        {
            response = await this.privateMarginGetV2MarginCrossedLiquidationHistory(this.extend(request, parameters));
        }
        //
        // isolated
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1698114119193,
        //         "data": {
        //             "resultList": [
        //                 {
        //                     "liqId": "123",
        //                     "symbol": "BTCUSDT",
        //                     "liqStartTime": "1653453245342",
        //                     "liqEndTime": "16312423423432",
        //                     "liqRiskRatio": "1.01",
        //                     "totalAssets": "1242.34",
        //                     "totalDebt": "1100",
        //                     "liqFee": "1.2",
        //                     "uTime": "1668134458717",
        //                     "cTime": "1653453245342"
        //                 }
        //             ],
        //             "maxId": "0",
        //             "minId": "0"
        //         }
        //     }
        //
        // cross
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1698114119193,
        //         "data": {
        //             "resultList": [
        //                 {
        //                     "liqId": "123",
        //                     "liqStartTime": "1653453245342",
        //                     "liqEndTime": "16312423423432",
        //                     "liqRiskRatio": "1.01",
        //                     "totalAssets": "1242.34",
        //                     "totalDebt": "1100",
        //                     "LiqFee": "1.2",
        //                     "uTime": "1668134458717",
        //                     "cTime": "1653453245342"
        //                 }
        //             ],
        //             "maxId": "0",
        //             "minId": "0"
        //         }
        //     }
        //
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        object liquidations = this.safeList(data, "resultList", new List<object>() {});
        return this.parseLiquidations(liquidations, market, since, limit);
    }

    public override object parseLiquidation(object liquidation, object market = null)
    {
        //
        // isolated
        //
        //     {
        //         "liqId": "123",
        //         "symbol": "BTCUSDT",
        //         "liqStartTime": "1653453245342",
        //         "liqEndTime": "16312423423432",
        //         "liqRiskRatio": "1.01",
        //         "totalAssets": "1242.34",
        //         "totalDebt": "1100",
        //         "liqFee": "1.2",
        //         "uTime": "1692690126000"
        //         "cTime": "1653453245342"
        //     }
        //
        // cross
        //
        //     {
        //         "liqId": "123",
        //         "liqStartTime": "1653453245342",
        //         "liqEndTime": "16312423423432",
        //         "liqRiskRatio": "1.01",
        //         "totalAssets": "1242.34",
        //         "totalDebt": "1100",
        //         "LiqFee": "1.2",
        //         "uTime": "1692690126000"
        //         "cTime": "1653453245342"
        //     }
        //
        object marketId = this.safeString(liquidation, "symbol");
        object timestamp = this.safeInteger(liquidation, "liqEndTime");
        object liquidationFee = this.safeString2(liquidation, "LiqFee", "liqFee");
        object totalDebt = this.safeString(liquidation, "totalDebt");
        object quoteValueString = Precise.stringAdd(liquidationFee, totalDebt);
        return this.safeLiquidation(new Dictionary<string, object>() {
            { "info", liquidation },
            { "symbol", this.safeSymbol(marketId, market) },
            { "contracts", null },
            { "contractSize", null },
            { "price", null },
            { "baseValue", null },
            { "quoteValue", this.parseNumber(quoteValueString) },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
        });
    }

    /**
     * @method
     * @name bitget#fetchIsolatedBorrowRate
     * @description fetch the rate of interest to borrow a currency for margin trading
     * @see https://www.bitget.com/api-doc/margin/isolated/account/Isolated-Margin-Interest-Rate-And-Max-Borrowable-Amount
     * @param {string} symbol unified market symbol
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} an [isolated borrow rate structure]{@link https://docs.ccxt.com/?id=isolated-borrow-rate-structure}
     */
    public async override Task<object> fetchIsolatedBorrowRate(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object response = await this.privateMarginGetV2MarginIsolatedInterestRateAndLimit(this.extend(request, parameters));
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1700878692567,
        //         "data": [
        //             {
        //                 "symbol": "BTCUSDT",
        //                 "leverage": "10",
        //                 "baseCoin": "BTC",
        //                 "baseTransferable": true,
        //                 "baseBorrowable": true,
        //                 "baseDailyInterestRate": "0.00007",
        //                 "baseAnnuallyInterestRate": "0.02555",
        //                 "baseMaxBorrowableAmount": "27",
        //                 "baseVipList": [
        //                     {"level":"0","dailyInterestRate":"0.00007","limit":"27","annuallyInterestRate":"0.02555","discountRate":"1"},
        //                     {"level":"1","dailyInterestRate":"0.0000679","limit":"27.81","annuallyInterestRate":"0.0247835","discountRate":"0.97"},
        //                     {"level":"2","dailyInterestRate":"0.0000644","limit":"29.16","annuallyInterestRate":"0.023506","discountRate":"0.92"},
        //                     {"level":"3","dailyInterestRate":"0.0000602","limit":"31.32","annuallyInterestRate":"0.021973","discountRate":"0.86"},
        //                     {"level":"4","dailyInterestRate":"0.0000525","limit":"35.91","annuallyInterestRate":"0.0191625","discountRate":"0.75"},
        //                     {"level":"5","dailyInterestRate":"0.000042","limit":"44.82","annuallyInterestRate":"0.01533","discountRate":"0.6"}
        //                 ],
        //                 "quoteCoin": "USDT",
        //                 "quoteTransferable": true,
        //                 "quoteBorrowable": true,
        //                 "quoteDailyInterestRate": "0.00041095",
        //                 "quoteAnnuallyInterestRate": "0.14999675",
        //                 "quoteMaxBorrowableAmount": "300000",
        //                 "quoteList": [
        //                     {"level":"0","dailyInterestRate":"0.00041095","limit":"300000","annuallyInterestRate":"0.14999675","discountRate":"1"},
        //                     {"level":"1","dailyInterestRate":"0.00039863","limit":"309000","annuallyInterestRate":"0.14549995","discountRate":"0.97"},
        //                     {"level":"2","dailyInterestRate":"0.00037808","limit":"324000","annuallyInterestRate":"0.1379992","discountRate":"0.92"},
        //                     {"level":"3","dailyInterestRate":"0.00035342","limit":"348000","annuallyInterestRate":"0.1289983","discountRate":"0.86"},
        //                     {"level":"4","dailyInterestRate":"0.00030822","limit":"399000","annuallyInterestRate":"0.1125003","discountRate":"0.75"},
        //                     {"level":"5","dailyInterestRate":"0.00024657","limit":"498000","annuallyInterestRate":"0.08999805","discountRate":"0.6"}
        //                 ]
        //             }
        //         ]
        //     }
        //
        object timestamp = this.safeInteger(response, "requestTime");
        object data = this.safeValue(response, "data", new List<object>() {});
        object first = this.safeValue(data, 0, new Dictionary<string, object>() {});
        ((IDictionary<string,object>)first)["timestamp"] = timestamp;
        return this.parseIsolatedBorrowRate(first, market);
    }

    public override object parseIsolatedBorrowRate(object info, object market = null)
    {
        //
        //     {
        //         "symbol": "BTCUSDT",
        //         "leverage": "10",
        //         "baseCoin": "BTC",
        //         "baseTransferable": true,
        //         "baseBorrowable": true,
        //         "baseDailyInterestRate": "0.00007",
        //         "baseAnnuallyInterestRate": "0.02555",
        //         "baseMaxBorrowableAmount": "27",
        //         "baseVipList": [
        //             {"level":"0","dailyInterestRate":"0.00007","limit":"27","annuallyInterestRate":"0.02555","discountRate":"1"},
        //             {"level":"1","dailyInterestRate":"0.0000679","limit":"27.81","annuallyInterestRate":"0.0247835","discountRate":"0.97"},
        //             {"level":"2","dailyInterestRate":"0.0000644","limit":"29.16","annuallyInterestRate":"0.023506","discountRate":"0.92"},
        //             {"level":"3","dailyInterestRate":"0.0000602","limit":"31.32","annuallyInterestRate":"0.021973","discountRate":"0.86"},
        //             {"level":"4","dailyInterestRate":"0.0000525","limit":"35.91","annuallyInterestRate":"0.0191625","discountRate":"0.75"},
        //             {"level":"5","dailyInterestRate":"0.000042","limit":"44.82","annuallyInterestRate":"0.01533","discountRate":"0.6"}
        //         ],
        //         "quoteCoin": "USDT",
        //         "quoteTransferable": true,
        //         "quoteBorrowable": true,
        //         "quoteDailyInterestRate": "0.00041095",
        //         "quoteAnnuallyInterestRate": "0.14999675",
        //         "quoteMaxBorrowableAmount": "300000",
        //         "quoteList": [
        //             {"level":"0","dailyInterestRate":"0.00041095","limit":"300000","annuallyInterestRate":"0.14999675","discountRate":"1"},
        //             {"level":"1","dailyInterestRate":"0.00039863","limit":"309000","annuallyInterestRate":"0.14549995","discountRate":"0.97"},
        //             {"level":"2","dailyInterestRate":"0.00037808","limit":"324000","annuallyInterestRate":"0.1379992","discountRate":"0.92"},
        //             {"level":"3","dailyInterestRate":"0.00035342","limit":"348000","annuallyInterestRate":"0.1289983","discountRate":"0.86"},
        //             {"level":"4","dailyInterestRate":"0.00030822","limit":"399000","annuallyInterestRate":"0.1125003","discountRate":"0.75"},
        //             {"level":"5","dailyInterestRate":"0.00024657","limit":"498000","annuallyInterestRate":"0.08999805","discountRate":"0.6"}
        //         ]
        //     }
        //
        object marketId = this.safeString(info, "symbol");
        object symbol = this.safeSymbol(marketId, market, null, "spot");
        object baseId = this.safeString(info, "baseCoin");
        object quoteId = this.safeString(info, "quoteCoin");
        object timestamp = this.safeInteger(info, "timestamp");
        return new Dictionary<string, object>() {
            { "symbol", symbol },
            { "base", this.safeCurrencyCode(baseId) },
            { "baseRate", this.safeNumber(info, "baseDailyInterestRate") },
            { "quote", this.safeCurrencyCode(quoteId) },
            { "quoteRate", this.safeNumber(info, "quoteDailyInterestRate") },
            { "period", 86400000 },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "info", info },
        };
    }

    /**
     * @method
     * @name bitget#fetchCrossBorrowRate
     * @description fetch the rate of interest to borrow a currency for margin trading
     * @see https://www.bitget.com/api-doc/margin/cross/account/Get-Cross-Margin-Interest-Rate-And-Borrowable
     * @see https://www.bitget.com/api-doc/uta/public/Get-Margin-Loans
     * @param {string} code unified currency code
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {boolean} [params.uta] set to true for the unified trading account (uta), defaults to false
     * @returns {object} a [borrow rate structure]{@link https://github.com/ccxt/ccxt/wiki/Manual#borrow-rate-structure}
     */
    public async override Task<object> fetchCrossBorrowRate(object code, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "coin", getValue(currency, "id") },
        };
        object uta = null;
        object response = null;
        object result = null;
        var utaparametersVariable = this.handleOptionAndParams(parameters, "fetchCrossBorrowRate", "uta", false);
        uta = ((IList<object>)utaparametersVariable)[0];
        parameters = ((IList<object>)utaparametersVariable)[1];
        if (isTrue(uta))
        {
            response = await this.publicUtaGetV3MarketMarginLoans(this.extend(request, parameters));
            //
            //     {
            //         "code": "00000",
            //         "msg": "success",
            //         "requestTime": 1752817798893,
            //         "data": {
            //             "dailyInterest": "0.00100008",
            //             "annualInterest": "0.3650292",
            //             "limit": "100"
            //         }
            //     }
            //
            result = this.safeDict(response, "data", new Dictionary<string, object>() {});
        } else
        {
            response = await this.privateMarginGetV2MarginCrossedInterestRateAndLimit(this.extend(request, parameters));
            //
            //     {
            //         "code": "00000",
            //         "msg": "success",
            //         "requestTime": 1700879047861,
            //         "data": [
            //             {
            //                 "coin": "BTC",
            //                 "leverage": "3",
            //                 "transferable": true,
            //                 "borrowable": true,
            //                 "dailyInterestRate": "0.00007",
            //                 "annualInterestRate": "0.02555",
            //                 "maxBorrowableAmount": "26",
            //                 "vipList": [
            //                     {"level":"0","limit":"26","dailyInterestRate":"0.00007","annualInterestRate":"0.02555","discountRate":"1"},
            //                     {"level":"1","limit":"26.78","dailyInterestRate":"0.0000679","annualInterestRate":"0.0247835","discountRate":"0.97"},
            //                     {"level":"2","limit":"28.08","dailyInterestRate":"0.0000644","annualInterestRate":"0.023506","discountRate":"0.92"},
            //                     {"level":"3","limit":"30.16","dailyInterestRate":"0.0000602","annualInterestRate":"0.021973","discountRate":"0.86"},
            //                     {"level":"4","limit":"34.58","dailyInterestRate":"0.0000525","annualInterestRate":"0.0191625","discountRate":"0.75"},
            //                     {"level":"5","limit":"43.16","dailyInterestRate":"0.000042","annualInterestRate":"0.01533","discountRate":"0.6"}
            //                 ]
            //             }
            //         ]
            //     }
            //
            object data = this.safeValue(response, "data", new List<object>() {});
            result = this.safeValue(data, 0, new Dictionary<string, object>() {});
        }
        object timestamp = this.safeInteger(response, "requestTime");
        ((IDictionary<string,object>)result)["timestamp"] = timestamp;
        return this.parseBorrowRate(result, currency);
    }

    public override object parseBorrowRate(object info, object currency = null)
    {
        //
        // default
        //
        //     {
        //         "coin": "BTC",
        //         "leverage": "3",
        //         "transferable": true,
        //         "borrowable": true,
        //         "dailyInterestRate": "0.00007",
        //         "annualInterestRate": "0.02555",
        //         "maxBorrowableAmount": "26",
        //         "vipList": [
        //             {"level":"0","limit":"26","dailyInterestRate":"0.00007","annualInterestRate":"0.02555","discountRate":"1"},
        //             {"level":"1","limit":"26.78","dailyInterestRate":"0.0000679","annualInterestRate":"0.0247835","discountRate":"0.97"},
        //             {"level":"2","limit":"28.08","dailyInterestRate":"0.0000644","annualInterestRate":"0.023506","discountRate":"0.92"},
        //             {"level":"3","limit":"30.16","dailyInterestRate":"0.0000602","annualInterestRate":"0.021973","discountRate":"0.86"},
        //             {"level":"4","limit":"34.58","dailyInterestRate":"0.0000525","annualInterestRate":"0.0191625","discountRate":"0.75"},
        //             {"level":"5","limit":"43.16","dailyInterestRate":"0.000042","annualInterestRate":"0.01533","discountRate":"0.6"}
        //         ]
        //     }
        //
        // uta
        //
        //     {
        //         "dailyInterest": "0.00100008",
        //         "annualInterest": "0.3650292",
        //         "limit": "100"
        //     }
        //
        object currencyId = this.safeString(info, "coin");
        object timestamp = this.safeInteger(info, "timestamp");
        return new Dictionary<string, object>() {
            { "currency", this.safeCurrencyCode(currencyId, currency) },
            { "rate", this.safeNumber2(info, "dailyInterestRate", "dailyInterest") },
            { "period", 86400000 },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "info", info },
        };
    }

    /**
     * @method
     * @name bitget#fetchBorrowInterest
     * @description fetch the interest owed by the user for borrowing currency for margin trading
     * @see https://www.bitget.com/api-doc/margin/cross/record/Get-Cross-Interest-Records
     * @see https://www.bitget.com/api-doc/margin/isolated/record/Get-Isolated-Interest-Records
     * @param {string} [code] unified currency code
     * @param {string} [symbol] unified market symbol when fetching interest in isolated markets
     * @param {int} [since] the earliest time in ms to fetch borrow interest for
     * @param {int} [limit] the maximum number of structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [available parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
     * @returns {object[]} a list of [borrow interest structures]{@link https://docs.ccxt.com/?id=borrow-interest-structure}
     */
    public async override Task<object> fetchBorrowInterest(object code = null, object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object paginate = false;
        var paginateparametersVariable = this.handleOptionAndParams(parameters, "fetchBorrowInterest", "paginate");
        paginate = ((IList<object>)paginateparametersVariable)[0];
        parameters = ((IList<object>)paginateparametersVariable)[1];
        if (isTrue(paginate))
        {
            return await this.fetchPaginatedCallCursor("fetchBorrowInterest", symbol, since, limit, parameters, "minId", "idLessThan");
        }
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
        }
        object request = new Dictionary<string, object>() {};
        object currency = null;
        if (isTrue(!isEqual(code, null)))
        {
            currency = this.currency(code);
            ((IDictionary<string,object>)request)["coin"] = getValue(currency, "id");
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["startTime"] = since;
        } else
        {
            ((IDictionary<string,object>)request)["startTime"] = subtract(this.milliseconds(), 7776000000);
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        object response = null;
        object marginMode = null;
        var marginModeparametersVariable = this.handleMarginModeAndParams("fetchBorrowInterest", parameters, "cross");
        marginMode = ((IList<object>)marginModeparametersVariable)[0];
        parameters = ((IList<object>)marginModeparametersVariable)[1];
        if (isTrue(isEqual(marginMode, "isolated")))
        {
            if (isTrue(isEqual(symbol, null)))
            {
                throw new ArgumentsRequired ((string)add(this.id, " fetchBorrowInterest() requires a symbol argument")) ;
            }
            ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
            response = await this.privateMarginGetV2MarginIsolatedInterestHistory(this.extend(request, parameters));
        } else if (isTrue(isEqual(marginMode, "cross")))
        {
            response = await this.privateMarginGetV2MarginCrossedInterestHistory(this.extend(request, parameters));
        }
        //
        // isolated
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1700879935189,
        //         "data": {
        //             "resultList": [
        //                 {
        //                     "interestId": "1112125304879067137",
        //                     "interestCoin": "USDT",
        //                     "dailyInterestRate": "0.00041095",
        //                     "loanCoin": "USDT",
        //                     "interestAmount": "0.0000685",
        //                     "interstType": "first",
        //                     "symbol": "BTCUSDT",
        //                     "cTime": "1700877255648",
        //                     "uTime": "1700877255648"
        //                 },
        //             ],
        //             "maxId": "1112125304879067137",
        //             "minId": "1100138015672119298"
        //         }
        //     }
        //
        // cross
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1700879597044,
        //         "data": {
        //             "resultList": [
        //                 {
        //                     "interestId": "1112122013642272769",
        //                     "interestCoin": "USDT",
        //                     "dailyInterestRate": "0.00041",
        //                     "loanCoin": "USDT",
        //                     "interestAmount": "0.00006834",
        //                     "interstType": "first",
        //                     "cTime": "1700876470957",
        //                     "uTime": "1700876470957"
        //                 },
        //             ],
        //             "maxId": "1112122013642272769",
        //             "minId": "1096917004629716993"
        //         }
        //     }
        //
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        object rows = this.safeValue(data, "resultList", new List<object>() {});
        object interest = this.parseBorrowInterests(rows, market);
        return this.filterByCurrencySinceLimit(interest, code, since, limit);
    }

    public override object parseBorrowInterest(object info, object market = null)
    {
        //
        // isolated
        //
        //     {
        //         "interestId": "1112125304879067137",
        //         "interestCoin": "USDT",
        //         "dailyInterestRate": "0.00041095",
        //         "loanCoin": "USDT",
        //         "interestAmount": "0.0000685",
        //         "interstType": "first",
        //         "symbol": "BTCUSDT",
        //         "cTime": "1700877255648",
        //         "uTime": "1700877255648"
        //     }
        //
        // cross
        //
        //     {
        //         "interestId": "1112122013642272769",
        //         "interestCoin": "USDT",
        //         "dailyInterestRate": "0.00041",
        //         "loanCoin": "USDT",
        //         "interestAmount": "0.00006834",
        //         "interstType": "first",
        //         "cTime": "1700876470957",
        //         "uTime": "1700876470957"
        //     }
        //
        object marketId = this.safeString(info, "symbol");
        market = this.safeMarket(marketId, market);
        object marginMode = ((bool) isTrue((!isEqual(marketId, null)))) ? "isolated" : "cross";
        object timestamp = this.safeInteger(info, "cTime");
        return new Dictionary<string, object>() {
            { "info", info },
            { "symbol", this.safeString(market, "symbol") },
            { "currency", this.safeCurrencyCode(this.safeString(info, "interestCoin")) },
            { "interest", this.safeNumber(info, "interestAmount") },
            { "interestRate", this.safeNumber(info, "dailyInterestRate") },
            { "amountBorrowed", null },
            { "marginMode", marginMode },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
        };
    }

    /**
     * @method
     * @name bitget#closePosition
     * @description closes an open position for a market
     * @see https://www.bitget.com/api-doc/contract/trade/Flash-Close-Position
     * @see https://www.bitget.com/api-doc/uta/trade/Close-All-Positions
     * @param {string} symbol unified CCXT market symbol
     * @param {string} [side] one-way mode: 'buy' or 'sell', hedge-mode: 'long' or 'short'
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {boolean} [params.uta] set to true for the unified trading account (uta), defaults to false
     * @returns {object} An [order structure]{@link https://docs.ccxt.com/?id=order-structure}
     */
    public async override Task<object> closePosition(object symbol, object side = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object productType = null;
        object uta = null;
        object response = null;
        var productTypeparametersVariable = this.handleProductTypeAndParams(market, parameters);
        productType = ((IList<object>)productTypeparametersVariable)[0];
        parameters = ((IList<object>)productTypeparametersVariable)[1];
        var utaparametersVariable = this.handleOptionAndParams(parameters, "closePosition", "uta", false);
        uta = ((IList<object>)utaparametersVariable)[0];
        parameters = ((IList<object>)utaparametersVariable)[1];
        if (isTrue(uta))
        {
            if (isTrue(!isEqual(side, null)))
            {
                ((IDictionary<string,object>)request)["posSide"] = side;
            }
            ((IDictionary<string,object>)request)["category"] = productType;
            response = await this.privateUtaPostV3TradeClosePositions(this.extend(request, parameters));
        } else
        {
            if (isTrue(!isEqual(side, null)))
            {
                ((IDictionary<string,object>)request)["holdSide"] = side;
            }
            ((IDictionary<string,object>)request)["productType"] = productType;
            response = await this.privateMixPostV2MixOrderClosePositions(this.extend(request, parameters));
        }
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        object order = this.safeList2(data, "successList", "list", new List<object>() {});
        return this.parseOrder(getValue(order, 0), market);
    }

    /**
     * @method
     * @name bitget#closeAllPositions
     * @description closes all open positions for a market type
     * @see https://www.bitget.com/api-doc/contract/trade/Flash-Close-Position
     * @see https://www.bitget.com/api-doc/uta/trade/Close-All-Positions
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.productType] 'USDT-FUTURES', 'USDC-FUTURES', 'COIN-FUTURES', 'SUSDT-FUTURES', 'SUSDC-FUTURES' or 'SCOIN-FUTURES'
     * @param {boolean} [params.uta] set to true for the unified trading account (uta), defaults to false
     * @returns {object[]} A list of [position structures]{@link https://docs.ccxt.com/?id=position-structure}
     */
    public async override Task<object> closeAllPositions(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object productType = null;
        object uta = null;
        object response = null;
        var productTypeparametersVariable = this.handleProductTypeAndParams(null, parameters);
        productType = ((IList<object>)productTypeparametersVariable)[0];
        parameters = ((IList<object>)productTypeparametersVariable)[1];
        var utaparametersVariable = this.handleOptionAndParams(parameters, "closeAllPositions", "uta", false);
        uta = ((IList<object>)utaparametersVariable)[0];
        parameters = ((IList<object>)utaparametersVariable)[1];
        if (isTrue(uta))
        {
            ((IDictionary<string,object>)request)["category"] = productType;
            response = await this.privateUtaPostV3TradeClosePositions(this.extend(request, parameters));
        } else
        {
            ((IDictionary<string,object>)request)["productType"] = productType;
            response = await this.privateMixPostV2MixOrderClosePositions(this.extend(request, parameters));
        }
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        object orderInfo = this.safeList2(data, "successList", "list", new List<object>() {});
        return this.parsePositions(orderInfo, null, parameters);
    }

    /**
     * @method
     * @name bitget#fetchMarginMode
     * @description fetches the margin mode of a trading pair
     * @see https://www.bitget.com/api-doc/contract/account/Get-Single-Account
     * @param {string} symbol unified symbol of the market to fetch the margin mode for
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [margin mode structure]{@link https://docs.ccxt.com/?id=margin-mode-structure}
     */
    public async override Task<object> fetchMarginMode(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object productType = null;
        var productTypeparametersVariable = this.handleProductTypeAndParams(market, parameters);
        productType = ((IList<object>)productTypeparametersVariable)[0];
        parameters = ((IList<object>)productTypeparametersVariable)[1];
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
            { "marginCoin", getValue(market, "settleId") },
            { "productType", productType },
        };
        object response = await this.privateMixGetV2MixAccountAccount(this.extend(request, parameters));
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1709791216652,
        //         "data": {
        //             "marginCoin": "USDT",
        //             "locked": "0",
        //             "available": "19.88811074",
        //             "crossedMaxAvailable": "19.88811074",
        //             "isolatedMaxAvailable": "19.88811074",
        //             "maxTransferOut": "19.88811074",
        //             "accountEquity": "19.88811074",
        //             "usdtEquity": "19.888110749166",
        //             "btcEquity": "0.000302183391",
        //             "crossedRiskRate": "0",
        //             "crossedMarginLeverage": 20,
        //             "isolatedLongLever": 20,
        //             "isolatedShortLever": 20,
        //             "marginMode": "crossed",
        //             "posMode": "hedge_mode",
        //             "unrealizedPL": "0",
        //             "coupon": "0",
        //             "crossedUnrealizedPL": "0",
        //             "isolatedUnrealizedPL": ""
        //         }
        //     }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        return this.parseMarginMode(data, market);
    }

    public override object parseMarginMode(object marginMode, object market = null)
    {
        object marginType = this.safeString(marginMode, "marginMode");
        marginType = ((bool) isTrue((isEqual(marginType, "crossed")))) ? "cross" : marginType;
        return new Dictionary<string, object>() {
            { "info", marginMode },
            { "symbol", getValue(market, "symbol") },
            { "marginMode", marginType },
        };
    }

    /**
     * @method
     * @name bitget#fetchPositionsHistory
     * @description fetches historical positions
     * @see https://www.bitget.com/api-doc/contract/position/Get-History-Position
     * @see https://www.bitget.com/api-doc/uta/trade/Get-Position-History
     * @param {string[]} [symbols] unified contract symbols
     * @param {int} [since] timestamp in ms of the earliest position to fetch, default=3 months ago, max range for params["until"] - since is 3 months
     * @param {int} [limit] the maximum amount of records to fetch, default=20, max=100
     * @param {object} params extra parameters specific to the exchange api endpoint
     * @param {int} [params.until] timestamp in ms of the latest position to fetch, max range for params["until"] - since is 3 months
     * @param {string} [params.productType] USDT-FUTURES (default), COIN-FUTURES, USDC-FUTURES, SUSDT-FUTURES, SCOIN-FUTURES, or SUSDC-FUTURES
     * @param {boolean} [params.uta] set to true for the unified trading account (uta), defaults to false
     * @returns {object[]} a list of [position structures]{@link https://docs.ccxt.com/?id=position-structure}
     */
    public async override Task<object> fetchPositionsHistory(object symbols = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object market = null;
        object productType = null;
        object uta = null;
        object response = null;
        if (isTrue(!isEqual(symbols, null)))
        {
            object symbolsLength = getArrayLength(symbols);
            if (isTrue(isGreaterThan(symbolsLength, 0)))
            {
                market = this.market(getValue(symbols, 0));
                ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
            }
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["startTime"] = since;
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        var requestparametersVariable = this.handleUntilOption("endTime", request, parameters);
        request = ((IList<object>)requestparametersVariable)[0];
        parameters = ((IList<object>)requestparametersVariable)[1];
        var productTypeparametersVariable = this.handleProductTypeAndParams(market, parameters);
        productType = ((IList<object>)productTypeparametersVariable)[0];
        parameters = ((IList<object>)productTypeparametersVariable)[1];
        var utaparametersVariable = this.handleOptionAndParams(parameters, "fetchPositionsHistory", "uta", false);
        uta = ((IList<object>)utaparametersVariable)[0];
        parameters = ((IList<object>)utaparametersVariable)[1];
        if (isTrue(uta))
        {
            ((IDictionary<string,object>)request)["category"] = productType;
            response = await this.privateUtaGetV3PositionHistoryPosition(this.extend(request, parameters));
        } else
        {
            response = await this.privateMixGetV2MixPositionHistoryPosition(this.extend(request, parameters));
        }
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        object responseList = this.safeList(data, "list", new List<object>() {});
        object positions = this.parsePositions(responseList, symbols, parameters);
        return this.filterBySinceLimit(positions, since, limit);
    }

    /**
     * @method
     * @name bitget#fetchConvertQuote
     * @description fetch a quote for converting from one currency to another
     * @see https://www.bitget.com/api-doc/common/convert/Get-Quoted-Price
     * @param {string} fromCode the currency that you want to sell and convert from
     * @param {string} toCode the currency that you want to buy and convert into
     * @param {float} [amount] how much you want to trade in units of the from currency
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [conversion structure]{@link https://docs.ccxt.com/?id=conversion-structure}
     */
    public async override Task<object> fetchConvertQuote(object fromCode, object toCode, object amount = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {
            { "fromCoin", fromCode },
            { "toCoin", toCode },
            { "fromCoinSize", this.numberToString(amount) },
        };
        object response = await this.privateConvertGetV2ConvertQuotedPrice(this.extend(request, parameters));
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1712121940158,
        //         "data": {
        //             "fromCoin": "USDT",
        //             "fromCoinSize": "5",
        //             "cnvtPrice": "0.9993007892377704",
        //             "toCoin": "USDC",
        //             "toCoinSize": "4.99650394",
        //             "traceId": "1159288930228187140",
        //             "fee": "0"
        //         }
        //     }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        object fromCurrencyId = this.safeString(data, "fromCoin", fromCode);
        object fromCurrency = this.currency(fromCurrencyId);
        object toCurrencyId = this.safeString(data, "toCoin", toCode);
        object toCurrency = this.currency(toCurrencyId);
        return this.parseConversion(data, fromCurrency, toCurrency);
    }

    /**
     * @method
     * @name bitget#createConvertTrade
     * @description convert from one currency to another
     * @see https://www.bitget.com/api-doc/common/convert/Trade
     * @param {string} id the id of the trade that you want to make
     * @param {string} fromCode the currency that you want to sell and convert from
     * @param {string} toCode the currency that you want to buy and convert into
     * @param {float} amount how much you want to trade in units of the from currency
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} params.price the price of the conversion, obtained from fetchConvertQuote()
     * @param {string} params.toAmount the amount you want to trade in units of the toCurrency, obtained from fetchConvertQuote()
     * @returns {object} a [conversion structure]{@link https://docs.ccxt.com/?id=conversion-structure}
     */
    public async override Task<object> createConvertTrade(object id, object fromCode, object toCode, object amount = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object price = this.safeString2(parameters, "price", "cnvtPrice");
        if (isTrue(isEqual(price, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " createConvertTrade() requires a price parameter")) ;
        }
        object toAmount = this.safeString2(parameters, "toAmount", "toCoinSize");
        if (isTrue(isEqual(toAmount, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " createConvertTrade() requires a toAmount parameter")) ;
        }
        parameters = this.omit(parameters, new List<object>() {"price", "toAmount"});
        object request = new Dictionary<string, object>() {
            { "traceId", id },
            { "fromCoin", fromCode },
            { "toCoin", toCode },
            { "fromCoinSize", this.numberToString(amount) },
            { "toCoinSize", toAmount },
            { "cnvtPrice", price },
        };
        object response = await this.privateConvertPostV2ConvertTrade(this.extend(request, parameters));
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1712123746203,
        //         "data": {
        //             "cnvtPrice": "0.99940076",
        //             "toCoin": "USDC",
        //             "toCoinSize": "4.99700379",
        //             "ts": "1712123746217"
        //         }
        //     }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        object toCurrencyId = this.safeString(data, "toCoin", toCode);
        object toCurrency = this.currency(toCurrencyId);
        return this.parseConversion(data, null, toCurrency);
    }

    /**
     * @method
     * @name bitget#fetchConvertTradeHistory
     * @description fetch the users history of conversion trades
     * @see https://www.bitget.com/api-doc/common/convert/Get-Convert-Record
     * @param {string} [code] the unified currency code
     * @param {int} [since] the earliest time in ms to fetch conversions for
     * @param {int} [limit] the maximum number of conversion structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} a list of [conversion structures]{@link https://docs.ccxt.com/?id=conversion-structure}
     */
    public async override Task<object> fetchConvertTradeHistory(object code = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object msInDay = 86400000;
        object now = this.milliseconds();
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["startTime"] = since;
        } else
        {
            ((IDictionary<string,object>)request)["startTime"] = subtract(now, msInDay);
        }
        object endTime = this.safeString2(parameters, "endTime", "until");
        if (isTrue(!isEqual(endTime, null)))
        {
            ((IDictionary<string,object>)request)["endTime"] = endTime;
        } else
        {
            ((IDictionary<string,object>)request)["endTime"] = now;
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        parameters = this.omit(parameters, "until");
        object response = await this.privateConvertGetV2ConvertConvertRecord(this.extend(request, parameters));
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1712124371799,
        //         "data": {
        //             "dataList": [
        //                 {
        //                     "id": "1159296505255219205",
        //                     "fromCoin": "USDT",
        //                     "fromCoinSize": "5",
        //                     "cnvtPrice": "0.99940076",
        //                     "toCoin": "USDC",
        //                     "toCoinSize": "4.99700379",
        //                     "ts": "1712123746217",
        //                     "fee": "0"
        //                 }
        //             ],
        //             "endId": "1159296505255219205"
        //         }
        //     }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        object dataList = this.safeList(data, "dataList", new List<object>() {});
        return this.parseConversions(dataList, code, "fromCoin", "toCoin", since, limit);
    }

    public override object parseConversion(object conversion, object fromCurrency = null, object toCurrency = null)
    {
        //
        // fetchConvertQuote
        //
        //     {
        //         "fromCoin": "USDT",
        //         "fromCoinSize": "5",
        //         "cnvtPrice": "0.9993007892377704",
        //         "toCoin": "USDC",
        //         "toCoinSize": "4.99650394",
        //         "traceId": "1159288930228187140",
        //         "fee": "0"
        //     }
        //
        // createConvertTrade
        //
        //     {
        //         "cnvtPrice": "0.99940076",
        //         "toCoin": "USDC",
        //         "toCoinSize": "4.99700379",
        //         "ts": "1712123746217"
        //     }
        //
        // fetchConvertTradeHistory
        //
        //     {
        //         "id": "1159296505255219205",
        //         "fromCoin": "USDT",
        //         "fromCoinSize": "5",
        //         "cnvtPrice": "0.99940076",
        //         "toCoin": "USDC",
        //         "toCoinSize": "4.99700379",
        //         "ts": "1712123746217",
        //         "fee": "0"
        //     }
        //
        object timestamp = this.safeInteger(conversion, "ts");
        object fromCoin = this.safeString(conversion, "fromCoin");
        object fromCode = this.safeCurrencyCode(fromCoin, fromCurrency);
        object to = this.safeString(conversion, "toCoin");
        object toCode = this.safeCurrencyCode(to, toCurrency);
        return new Dictionary<string, object>() {
            { "info", conversion },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "id", this.safeString2(conversion, "id", "traceId") },
            { "fromCurrency", fromCode },
            { "fromAmount", this.safeNumber(conversion, "fromCoinSize") },
            { "toCurrency", toCode },
            { "toAmount", this.safeNumber(conversion, "toCoinSize") },
            { "price", this.safeNumber(conversion, "cnvtPrice") },
            { "fee", this.safeNumber(conversion, "fee") },
        };
    }

    /**
     * @method
     * @name bitget#fetchConvertCurrencies
     * @description fetches all available currencies that can be converted
     * @see https://www.bitget.com/api-doc/common/convert/Get-Convert-Currencies
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} an associative dictionary of currencies
     */
    public async override Task<object> fetchConvertCurrencies(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.privateConvertGetV2ConvertCurrencies(parameters);
        //
        //     {
        //         "code": "00000",
        //         "msg": "success",
        //         "requestTime": 1712121755897,
        //         "data": [
        //             {
        //                 "coin": "BTC",
        //                 "available": "0.00009850",
        //                 "maxAmount": "0.756266",
        //                 "minAmount": "0.00001"
        //             },
        //         ]
        //     }
        //
        object result = new Dictionary<string, object>() {};
        object data = this.safeList(response, "data", new List<object>() {});
        for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
        {
            object entry = getValue(data, i);
            object id = this.safeString(entry, "coin");
            object code = this.safeCurrencyCode(id);
            ((IDictionary<string,object>)result)[(string)code] = new Dictionary<string, object>() {
                { "info", entry },
                { "id", id },
                { "code", code },
                { "networks", null },
                { "type", null },
                { "name", null },
                { "active", null },
                { "deposit", null },
                { "withdraw", this.safeNumber(entry, "available") },
                { "fee", null },
                { "precision", null },
                { "limits", new Dictionary<string, object>() {
                    { "amount", new Dictionary<string, object>() {
                        { "min", this.safeNumber(entry, "minAmount") },
                        { "max", this.safeNumber(entry, "maxAmount") },
                    } },
                    { "withdraw", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                    { "deposit", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                } },
                { "created", null },
            };
        }
        return result;
    }

    /**
     * @method
     * @name bitget#fetchFundingInterval
     * @description fetch the current funding rate interval
     * @see https://www.bitget.com/api-doc/contract/market/Get-Symbol-Next-Funding-Time
     * @see https://www.bitget.com/api-doc/uta/public/Get-Current-Funding-Rate
     * @param {string} symbol unified market symbol
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {boolean} [params.uta] set to true for the unified trading account (uta), defaults to false
     * @returns {object} a [funding rate structure]{@link https://docs.ccxt.com/?id=funding-rate-structure}
     */
    public async override Task<object> fetchFundingInterval(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object productType = null;
        var productTypeparametersVariable = this.handleProductTypeAndParams(market, parameters);
        productType = ((IList<object>)productTypeparametersVariable)[0];
        parameters = ((IList<object>)productTypeparametersVariable)[1];
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object response = null;
        object uta = null;
        var utaparametersVariable = this.handleOptionAndParams(parameters, "fetchFundingInterval", "uta", false);
        uta = ((IList<object>)utaparametersVariable)[0];
        parameters = ((IList<object>)utaparametersVariable)[1];
        if (isTrue(uta))
        {
            response = await this.publicUtaGetV3MarketCurrentFundRate(this.extend(request, parameters));
        } else
        {
            ((IDictionary<string,object>)request)["productType"] = productType;
            response = await this.publicMixGetV2MixMarketFundingTime(this.extend(request, parameters));
        }
        object data = this.safeList(response, "data", new List<object>() {});
        object first = this.safeDict(data, 0, new Dictionary<string, object>() {});
        return this.parseFundingRate(first, market);
    }

    /**
     * @method
     * @name bitget#fetchLongShortRatioHistory
     * @description fetches the long short ratio history for a unified market symbol
     * @see https://www.bitget.com/api-doc/common/apidata/Margin-Ls-Ratio
     * @see https://www.bitget.com/api-doc/common/apidata/Account-Long-Short
     * @param {string} symbol unified symbol of the market to fetch the long short ratio for
     * @param {string} [timeframe] the period for the ratio
     * @param {int} [since] the earliest time in ms to fetch ratios for
     * @param {int} [limit] the maximum number of long short ratio structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} an array of [long short ratio structures]{@link https://docs.ccxt.com/?id=long-short-ratio-structure}
     */
    public async override Task<object> fetchLongShortRatioHistory(object symbol = null, object timeframe = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        if (isTrue(!isEqual(timeframe, null)))
        {
            ((IDictionary<string,object>)request)["period"] = timeframe;
        }
        object response = null;
        if (isTrue(isTrue(getValue(market, "swap")) || isTrue(getValue(market, "future"))))
        {
            response = await this.publicMixGetV2MixMarketAccountLongShort(this.extend(request, parameters));
        } else
        {
            response = await this.publicMarginGetV2MarginMarketLongShortRatio(this.extend(request, parameters));
        }
        object data = this.safeList(response, "data", new List<object>() {});
        return this.parseLongShortRatioHistory(data, market);
    }

    public override object parseLongShortRatio(object info, object market = null)
    {
        object marketId = this.safeString(info, "symbol");
        object timestamp = this.safeIntegerOmitZero(info, "ts");
        return new Dictionary<string, object>() {
            { "info", info },
            { "symbol", this.safeSymbol(marketId, market, null, "contract") },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "timeframe", null },
            { "longShortRatio", this.safeNumber2(info, "longShortRatio", "longShortAccountRatio") },
        };
    }

    public override object handleErrors(object code, object reason, object url, object method, object headers, object body, object response, object requestHeaders, object requestBody)
    {
        if (!isTrue(response))
        {
            return null;  // fallback to default error handler
        }
        //
        // spot
        //
        //     {"code":"00000","msg":"success","requestTime":1713294492511,"data":[...]}"
        //
        //     {"status":"fail","err_code":"01001","err_msg":""}
        //     {"status":"error","ts":1595594160149,"err_code":"invalid-parameter","err_msg":"invalid size, valid range: [1,2000]"}
        //     {"status":"error","ts":1595684716042,"err_code":"invalid-parameter","err_msg":"illegal sign invalid"}
        //     {"status":"error","ts":1595700216275,"err_code":"bad-request","err_msg":"your balance is low!"}
        //     {"status":"error","ts":1595700344504,"err_code":"invalid-parameter","err_msg":"invalid type"}
        //     {"status":"error","ts":1595703343035,"err_code":"bad-request","err_msg":"order cancel fail"}
        //     {"status":"error","ts":1595704360508,"err_code":"invalid-parameter","err_msg":"accesskey not null"}
        //     {"status":"error","ts":1595704490084,"err_code":"invalid-parameter","err_msg":"permissions not right"}
        //     {"status":"error","ts":1595711862763,"err_code":"system exception","err_msg":"system exception"}
        //     {"status":"error","ts":1595730308979,"err_code":"bad-request","err_msg":"20003"}
        //
        // swap
        //
        //     {"code":"40015","msg":"","requestTime":1595698564931,"data":null}
        //     {"code":"40017","msg":"Order id must not be blank","requestTime":1595702477835,"data":null}
        //     {"code":"40017","msg":"Order Type must not be blank","requestTime":1595698516162,"data":null}
        //     {"code":"40301","msg":"","requestTime":1595667662503,"data":null}
        //     {"code":"40017","msg":"Contract code must not be blank","requestTime":1595703151651,"data":null}
        //     {"code":"40108","msg":"","requestTime":1595885064600,"data":null}
        //     {"order_id":"513468410013679613","client_oid":null,"symbol":"ethusd","result":false,"err_code":"order_no_exist_error","err_msg":""}
        //
        object message = this.safeString2(response, "err_msg", "msg");
        object feedback = add(add(this.id, " "), body);
        object nonEmptyMessage = (isTrue(isTrue((!isEqual(message, null))) && isTrue((!isEqual(message, "")))) && isTrue((!isEqual(message, "success"))));
        if (isTrue(nonEmptyMessage))
        {
            this.throwExactlyMatchedException(getValue(this.exceptions, "exact"), message, feedback);
            this.throwBroadlyMatchedException(getValue(this.exceptions, "broad"), message, feedback);
        }
        object errorCode = this.safeString2(response, "code", "err_code");
        object nonZeroErrorCode = isTrue((!isEqual(errorCode, null))) && isTrue((!isEqual(errorCode, "00000")));
        if (isTrue(nonZeroErrorCode))
        {
            this.throwExactlyMatchedException(getValue(this.exceptions, "exact"), errorCode, feedback);
        }
        if (isTrue(isTrue(nonZeroErrorCode) || isTrue(nonEmptyMessage)))
        {
            throw new ExchangeError ((string)feedback) ;
        }
        return null;
    }

    public override object nonce()
    {
        return subtract(this.milliseconds(), getValue(this.options, "timeDifference"));
    }

    public override object sign(object path, object api = null, object method = null, object parameters = null, object headers = null, object body = null)
    {
        api ??= new List<object>();
        method ??= "GET";
        parameters ??= new Dictionary<string, object>();
        object signed = isEqual(getValue(api, 0), "private");
        object endpoint = getValue(api, 1);
        object pathPart = "/api";
        object request = add("/", this.implodeParams(path, parameters));
        object payload = add(pathPart, request);
        object url = add(this.implodeHostname(getValue(getValue(this.urls, "api"), endpoint)), payload);
        object query = this.omit(parameters, this.extractParams(path));
        if (isTrue(!isTrue(signed) && isTrue((isEqual(method, "GET")))))
        {
            object keys = new List<object>(((IDictionary<string,object>)query).Keys);
            object keysLength = getArrayLength(keys);
            if (isTrue(isGreaterThan(keysLength, 0)))
            {
                url = add(add(url, "?"), this.urlencode(query));
            }
        }
        if (isTrue(signed))
        {
            this.checkRequiredCredentials();
            object timestamp = ((object)this.nonce()).ToString();
            object auth = add(add(timestamp, method), payload);
            if (isTrue(isEqual(method, "POST")))
            {
                body = this.json(parameters);
                auth = add(auth, body);
            } else
            {
                if (isTrue(getArrayLength(new List<object>(((IDictionary<string,object>)parameters).Keys))))
                {
                    object queryInner = add("?", this.urlencode(this.keysort(parameters)));
                    // check #21169 pr
                    if (isTrue(isGreaterThan(getIndexOf(queryInner, "%24"), -1)))
                    {
                        queryInner = ((string)queryInner).Replace((string)"%24", (string)"$");
                    }
                    url = add(url, queryInner);
                    auth = add(auth, queryInner);
                }
            }
            object signature = this.hmac(this.encode(auth), this.encode(this.secret), sha256, "base64");
            object broker = this.safeString(this.options, "broker");
            headers = new Dictionary<string, object>() {
                { "ACCESS-KEY", this.apiKey },
                { "ACCESS-SIGN", signature },
                { "ACCESS-TIMESTAMP", timestamp },
                { "ACCESS-PASSPHRASE", this.password },
                { "X-CHANNEL-API-CODE", broker },
            };
            if (isTrue(isEqual(method, "POST")))
            {
                ((IDictionary<string,object>)headers)["Content-Type"] = "application/json";
            }
        }
        object sandboxMode = this.safeBool2(this.options, "sandboxMode", "sandbox", false);
        if (isTrue(isTrue(isTrue(sandboxMode) && isTrue((!isEqual(path, "v2/public/time")))) && isTrue((!isEqual(path, "v3/market/current-fund-rate")))))
        {
            // https://github.com/ccxt/ccxt/issues/25252#issuecomment-2662742336
            if (isTrue(isEqual(headers, null)))
            {
                headers = new Dictionary<string, object>() {};
            }
            object productType = this.safeString(parameters, "productType");
            if (isTrue(isTrue(isTrue((!isEqual(productType, "SCOIN-FUTURES"))) && isTrue((!isEqual(productType, "SUSDT-FUTURES")))) && isTrue((!isEqual(productType, "SUSDC-FUTURES")))))
            {
                ((IDictionary<string,object>)headers)["PAPTRADING"] = "1";
            }
        }
        return new Dictionary<string, object>() {
            { "url", url },
            { "method", method },
            { "body", body },
            { "headers", headers },
        };
    }
}
