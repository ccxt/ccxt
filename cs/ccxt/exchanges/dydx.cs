namespace ccxt;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

public partial class dydx : Exchange
{
    public override object describe()
    {
        return this.deepExtend(base.describe(), new Dictionary<string, object>() {
            { "id", "dydx" },
            { "name", "dYdX" },
            { "countries", new List<object>() {"US"} },
            { "rateLimit", 100 },
            { "version", "v4" },
            { "certified", false },
            { "dex", true },
            { "pro", true },
            { "has", new Dictionary<string, object>() {
                { "CORS", null },
                { "spot", false },
                { "margin", false },
                { "swap", true },
                { "future", false },
                { "option", false },
                { "addMargin", false },
                { "cancelAllOrders", false },
                { "cancelAllOrdersAfter", false },
                { "cancelOrder", true },
                { "cancelOrders", true },
                { "cancelWithdraw", false },
                { "closeAllPositions", false },
                { "closePosition", false },
                { "createConvertTrade", false },
                { "createDepositAddress", false },
                { "createMarketBuyOrderWithCost", false },
                { "createMarketOrder", false },
                { "createMarketOrderWithCost", false },
                { "createMarketSellOrderWithCost", false },
                { "createOrder", true },
                { "createOrderWithTakeProfitAndStopLoss", false },
                { "createReduceOnlyOrder", false },
                { "createStopLimitOrder", false },
                { "createStopLossOrder", false },
                { "createStopMarketOrder", false },
                { "createStopOrder", false },
                { "createTakeProfitOrder", false },
                { "createTrailingAmountOrder", false },
                { "createTrailingPercentOrder", false },
                { "createTriggerOrder", false },
                { "fetchAccounts", true },
                { "fetchBalance", true },
                { "fetchCanceledOrders", false },
                { "fetchClosedOrder", false },
                { "fetchClosedOrders", true },
                { "fetchConvertCurrencies", false },
                { "fetchConvertQuote", false },
                { "fetchConvertTrade", false },
                { "fetchConvertTradeHistory", false },
                { "fetchCurrencies", false },
                { "fetchDepositAddress", false },
                { "fetchDepositAddresses", false },
                { "fetchDepositAddressesByNetwork", false },
                { "fetchDeposits", true },
                { "fetchDepositsWithdrawals", true },
                { "fetchFundingHistory", false },
                { "fetchFundingInterval", false },
                { "fetchFundingIntervals", false },
                { "fetchFundingRate", false },
                { "fetchFundingRateHistory", true },
                { "fetchFundingRates", false },
                { "fetchIndexOHLCV", false },
                { "fetchLedger", true },
                { "fetchLeverage", false },
                { "fetchMarginAdjustmentHistory", false },
                { "fetchMarginMode", false },
                { "fetchMarkets", true },
                { "fetchMarkOHLCV", false },
                { "fetchMyTrades", false },
                { "fetchOHLCV", true },
                { "fetchOpenInterestHistory", false },
                { "fetchOpenOrder", false },
                { "fetchOpenOrders", true },
                { "fetchOrder", true },
                { "fetchOrderBook", true },
                { "fetchOrders", true },
                { "fetchOrderTrades", false },
                { "fetchPosition", true },
                { "fetchPositionHistory", false },
                { "fetchPositionMode", false },
                { "fetchPositions", true },
                { "fetchPositionsHistory", false },
                { "fetchPremiumIndexOHLCV", false },
                { "fetchStatus", false },
                { "fetchTicker", false },
                { "fetchTickers", false },
                { "fetchTime", true },
                { "fetchTrades", true },
                { "fetchTradingFee", false },
                { "fetchTradingFees", false },
                { "fetchTransactions", false },
                { "fetchTransfers", true },
                { "fetchWithdrawals", true },
                { "reduceMargin", false },
                { "sandbox", false },
                { "setLeverage", false },
                { "setMargin", false },
                { "setPositionMode", false },
                { "transfer", true },
                { "withdraw", true },
            } },
            { "timeframes", new Dictionary<string, object>() {
                { "1m", "1MIN" },
                { "5m", "5MINS" },
                { "15m", "15MINS" },
                { "30m", "30MINS" },
                { "1h", "1HOUR" },
                { "4h", "4HOURS" },
                { "1d", "1DAY" },
            } },
            { "urls", new Dictionary<string, object>() {
                { "logo", "https://github.com/user-attachments/assets/617ea0c1-f05a-4d26-9fcb-a0d1d4091ae1" },
                { "api", new Dictionary<string, object>() {
                    { "indexer", "https://indexer.dydx.trade/v4" },
                    { "nodeRpc", "https://dydx-ops-rpc.kingnodes.com" },
                    { "nodeRest", "https://dydx-rest.publicnode.com" },
                } },
                { "test", new Dictionary<string, object>() {
                    { "indexer", "https://indexer.v4testnet.dydx.exchange/v4" },
                    { "nodeRpc", "https://test-dydx-rpc.kingnodes.com" },
                    { "nodeRest", "https://test-dydx-rest.kingnodes.com" },
                } },
                { "www", "https://www.dydx.xyz" },
                { "doc", new List<object>() {"https://docs.dydx.xyz"} },
                { "fees", new List<object>() {"https://docs.dydx.exchange/introduction-trading_fees"} },
                { "referral", "dydx.trade?ref=ccxt" },
            } },
            { "api", new Dictionary<string, object>() {
                { "indexer", new Dictionary<string, object>() {
                    { "get", new Dictionary<string, object>() {
                        { "addresses/{address}", 1 },
                        { "addresses/{address}/parentSubaccountNumber/{number}", 1 },
                        { "addresses/{address}/subaccountNumber/{subaccountNumber}", 1 },
                        { "assetPositions", 1 },
                        { "assetPositions/parentSubaccountNumber", 1 },
                        { "candles/perpetualMarkets/{market}", 1 },
                        { "compliance/screen/{address}", 1 },
                        { "fills", 1 },
                        { "fills/parentSubaccountNumber", 1 },
                        { "fundingPayments", 1 },
                        { "fundingPayments/parentSubaccount", 1 },
                        { "height", 0.1 },
                        { "historical-pnl", 1 },
                        { "historical-pnl/parentSubaccountNumber", 1 },
                        { "historicalBlockTradingRewards/{address}", 1 },
                        { "historicalFunding/{market}", 1 },
                        { "historicalTradingRewardAggregations/{address}", 1 },
                        { "orderbooks/perpetualMarket/{market}", 1 },
                        { "orders", 1 },
                        { "orders/parentSubaccountNumber", 1 },
                        { "orders/{orderId}", 1 },
                        { "perpetualMarkets", 1 },
                        { "perpetualPositions", 1 },
                        { "perpetualPositions/parentSubaccountNumber", 1 },
                        { "screen", 1 },
                        { "sparklines", 1 },
                        { "time", 1 },
                        { "trades/perpetualMarket/{market}", 1 },
                        { "transfers", 1 },
                        { "transfers/between", 1 },
                        { "transfers/parentSubaccountNumber", 1 },
                        { "vault/v1/megavault/historicalPnl", 1 },
                        { "vault/v1/megavault/positions", 1 },
                        { "vault/v1/vaults/historicalPnl", 1 },
                        { "perpetualMarketSparklines", 1 },
                        { "perpetualMarkets/{ticker}", 1 },
                        { "perpetualMarkets/{ticker}/orderbook", 1 },
                        { "trades/perpetualMarket/{ticker}", 1 },
                        { "historicalFunding/{ticker}", 1 },
                        { "candles/{ticker}/{resolution}", 1 },
                        { "addresses/{address}/subaccounts", 1 },
                        { "addresses/{address}/subaccountNumber/{subaccountNumber}/assetPositions", 1 },
                        { "addresses/{address}/subaccountNumber/{subaccountNumber}/perpetualPositions", 1 },
                        { "addresses/{address}/subaccountNumber/{subaccountNumber}/orders", 1 },
                        { "fills/parentSubaccount", 1 },
                        { "historical-pnl/parentSubaccount", 1 },
                    } },
                } },
                { "nodeRpc", new Dictionary<string, object>() {
                    { "get", new Dictionary<string, object>() {
                        { "abci_info", 1 },
                        { "block", 1 },
                        { "broadcast_tx_async", 1 },
                        { "broadcast_tx_sync", 1 },
                        { "tx", 1 },
                    } },
                } },
                { "nodeRest", new Dictionary<string, object>() {
                    { "get", new Dictionary<string, object>() {
                        { "cosmos/auth/v1beta1/account_info/{dydxAddress}", 1 },
                    } },
                    { "post", new Dictionary<string, object>() {
                        { "cosmos/tx/v1beta1/encode", 1 },
                        { "cosmos/tx/v1beta1/simulate", 1 },
                    } },
                } },
            } },
            { "fees", new Dictionary<string, object>() {
                { "trading", new Dictionary<string, object>() {
                    { "tierBased", true },
                    { "percentage", true },
                    { "maker", this.parseNumber("0.0001") },
                    { "taker", this.parseNumber("0.0005") },
                } },
            } },
            { "requiredCredentials", new Dictionary<string, object>() {
                { "apiKey", false },
                { "secret", false },
                { "privateKey", false },
            } },
            { "options", new Dictionary<string, object>() {
                { "mnemonic", null },
                { "chainName", "dydx-mainnet-1" },
                { "chainId", 1 },
                { "sandboxMode", false },
                { "defaultFeeDenom", "uusdc" },
                { "defaultFeeMultiplier", "1.6" },
                { "feeDenom", new Dictionary<string, object>() {
                    { "USDC_DENOM", "ibc/8E27BA2D5493AF5636760E354E46004562C46AB7EC0CC4C1CA14E9E20E2545B5" },
                    { "USDC_GAS_DENOM", "uusdc" },
                    { "USDC_DECIMALS", 6 },
                    { "USDC_GAS_PRICE", "0.025" },
                    { "CHAINTOKEN_DENOM", "adydx" },
                    { "CHAINTOKEN_DECIMALS", 18 },
                    { "CHAINTOKEN_GAS_PRICE", "25000000000" },
                } },
            } },
            { "features", new Dictionary<string, object>() {
                { "default", new Dictionary<string, object>() {
                    { "sandbox", true },
                    { "createOrder", new Dictionary<string, object>() {
                        { "marginMode", false },
                        { "triggerPrice", true },
                        { "triggerPriceType", new Dictionary<string, object>() {
                            { "last", true },
                            { "mark", true },
                            { "index", false },
                        } },
                        { "triggerDirection", false },
                        { "stopLossPrice", false },
                        { "takeProfitPrice", false },
                        { "attachedStopLossTakeProfit", null },
                        { "timeInForce", new Dictionary<string, object>() {
                            { "IOC", true },
                            { "FOK", true },
                            { "PO", true },
                            { "GTD", true },
                        } },
                        { "hedged", false },
                        { "trailing", false },
                        { "leverage", false },
                        { "marketBuyByCost", false },
                        { "marketBuyRequiresPrice", false },
                        { "selfTradePrevention", false },
                        { "iceberg", false },
                    } },
                    { "createOrders", null },
                    { "fetchMyTrades", new Dictionary<string, object>() {
                        { "marginMode", false },
                        { "limit", 500 },
                        { "daysBack", 90 },
                        { "untilDays", 10000 },
                        { "symbolRequired", false },
                    } },
                    { "fetchOrder", new Dictionary<string, object>() {
                        { "marginMode", false },
                        { "trigger", true },
                        { "trailing", false },
                        { "symbolRequired", false },
                    } },
                    { "fetchOpenOrders", new Dictionary<string, object>() {
                        { "marginMode", false },
                        { "limit", 500 },
                        { "trigger", true },
                        { "trailing", true },
                        { "symbolRequired", false },
                    } },
                    { "fetchOrders", new Dictionary<string, object>() {
                        { "marginMode", false },
                        { "limit", 500 },
                        { "daysBack", null },
                        { "untilDays", 100000 },
                        { "trigger", true },
                        { "trailing", true },
                        { "symbolRequired", false },
                    } },
                    { "fetchClosedOrders", new Dictionary<string, object>() {
                        { "marginMode", false },
                        { "limit", 500 },
                        { "daysBack", null },
                        { "daysBackCanceled", null },
                        { "untilDays", 100000 },
                        { "trigger", true },
                        { "trailing", true },
                        { "symbolRequired", false },
                    } },
                    { "fetchOHLCV", new Dictionary<string, object>() {
                        { "limit", 1000 },
                    } },
                } },
                { "forSwap", new Dictionary<string, object>() {
                    { "extends", "default" },
                    { "createOrder", new Dictionary<string, object>() {
                        { "hedged", true },
                    } },
                } },
                { "swap", new Dictionary<string, object>() {
                    { "linear", new Dictionary<string, object>() {
                        { "extends", "forSwap" },
                    } },
                    { "inverse", null },
                } },
                { "future", new Dictionary<string, object>() {
                    { "linear", null },
                    { "inverse", null },
                } },
            } },
            { "commonCurrencies", new Dictionary<string, object>() {} },
            { "exceptions", new Dictionary<string, object>() {
                { "exact", new Dictionary<string, object>() {
                    { "9", typeof(InvalidOrder) },
                    { "10", typeof(InvalidOrder) },
                    { "11", typeof(InvalidOrder) },
                    { "12", typeof(InvalidOrder) },
                    { "13", typeof(InvalidOrder) },
                    { "14", typeof(InvalidOrder) },
                    { "15", typeof(InvalidOrder) },
                    { "16", typeof(InvalidOrder) },
                    { "17", typeof(InvalidOrder) },
                    { "18", typeof(InvalidOrder) },
                    { "19", typeof(InvalidOrder) },
                    { "20", typeof(InvalidOrder) },
                    { "21", typeof(InvalidOrder) },
                    { "22", typeof(InvalidOrder) },
                    { "23", typeof(InvalidOrder) },
                    { "24", typeof(InvalidOrder) },
                    { "25", typeof(InvalidOrder) },
                    { "26", typeof(InvalidOrder) },
                    { "27", typeof(InvalidOrder) },
                    { "28", typeof(InvalidOrder) },
                    { "29", typeof(InvalidOrder) },
                    { "30", typeof(InvalidOrder) },
                    { "31", typeof(InvalidOrder) },
                    { "32", typeof(InvalidOrder) },
                    { "33", typeof(InvalidOrder) },
                    { "34", typeof(InvalidOrder) },
                    { "35", typeof(InvalidOrder) },
                    { "36", typeof(InvalidOrder) },
                    { "37", typeof(InvalidOrder) },
                    { "39", typeof(InvalidOrder) },
                    { "40", typeof(InvalidOrder) },
                    { "41", typeof(InvalidOrder) },
                    { "42", typeof(InvalidOrder) },
                    { "43", typeof(InvalidOrder) },
                    { "44", typeof(InvalidOrder) },
                    { "45", typeof(InvalidOrder) },
                    { "46", typeof(InvalidOrder) },
                    { "47", typeof(InvalidOrder) },
                    { "48", typeof(InvalidOrder) },
                    { "49", typeof(InvalidOrder) },
                    { "50", typeof(InvalidOrder) },
                    { "1000", typeof(BadRequest) },
                    { "1001", typeof(BadRequest) },
                    { "1002", typeof(BadRequest) },
                    { "1003", typeof(InvalidOrder) },
                    { "1004", typeof(InvalidOrder) },
                    { "1005", typeof(InvalidOrder) },
                    { "1006", typeof(InvalidOrder) },
                    { "1007", typeof(InvalidOrder) },
                    { "1008", typeof(InvalidOrder) },
                    { "1009", typeof(InvalidOrder) },
                    { "1010", typeof(InvalidOrder) },
                    { "1011", typeof(InvalidOrder) },
                    { "1012", typeof(InvalidOrder) },
                    { "1013", typeof(InvalidOrder) },
                    { "1014", typeof(InvalidOrder) },
                    { "1015", typeof(InvalidOrder) },
                    { "1017", typeof(InvalidOrder) },
                    { "1018", typeof(InvalidOrder) },
                    { "1019", typeof(InvalidOrder) },
                    { "1020", typeof(InvalidOrder) },
                    { "1021", typeof(InvalidOrder) },
                    { "1022", typeof(InvalidOrder) },
                    { "2000", typeof(InvalidOrder) },
                    { "2001", typeof(InvalidOrder) },
                    { "2002", typeof(InvalidOrder) },
                    { "2003", typeof(InvalidOrder) },
                    { "2004", typeof(InvalidOrder) },
                    { "2005", typeof(InvalidOrder) },
                    { "3000", typeof(InvalidOrder) },
                    { "3001", typeof(InvalidOrder) },
                    { "3002", typeof(InvalidOrder) },
                    { "3003", typeof(InvalidOrder) },
                    { "3004", typeof(InvalidOrder) },
                    { "3005", typeof(InvalidOrder) },
                    { "3006", typeof(InvalidOrder) },
                    { "3007", typeof(InvalidOrder) },
                    { "3008", typeof(InvalidOrder) },
                    { "3009", typeof(InvalidOrder) },
                    { "3010", typeof(InvalidOrder) },
                    { "4000", typeof(InvalidOrder) },
                    { "4001", typeof(InvalidOrder) },
                    { "4002", typeof(InvalidOrder) },
                    { "4003", typeof(InvalidOrder) },
                    { "4004", typeof(InvalidOrder) },
                    { "4005", typeof(InvalidOrder) },
                    { "4006", typeof(InvalidOrder) },
                    { "4007", typeof(InvalidOrder) },
                    { "4008", typeof(InvalidOrder) },
                    { "5000", typeof(InvalidOrder) },
                    { "5001", typeof(InvalidOrder) },
                    { "6000", typeof(InvalidOrder) },
                    { "6001", typeof(InvalidOrder) },
                    { "6002", typeof(InvalidOrder) },
                    { "9000", typeof(InvalidOrder) },
                    { "9001", typeof(InvalidOrder) },
                    { "9002", typeof(InvalidOrder) },
                    { "9003", typeof(InvalidOrder) },
                    { "10000", typeof(InvalidOrder) },
                    { "10001", typeof(InvalidOrder) },
                    { "11000", typeof(InvalidOrder) },
                } },
                { "broad", new Dictionary<string, object>() {
                    { "insufficient funds", typeof(InsufficientFunds) },
                } },
            } },
            { "precisionMode", TICK_SIZE },
        });
    }

    /**
     * @method
     * @name dydx#fetchTime
     * @description fetches the current integer timestamp in milliseconds from the exchange server
     * @see https://docs.dydx.xyz/indexer-client/http#get-time
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {int} the current integer timestamp in milliseconds from the exchange server
     */
    public async override Task<object> fetchTime(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object response = await this.indexerGetTime(parameters);
        //
        // {
        //     "iso": "2025-07-20T15:12:13.466Z",
        //     "epoch": 1753024333.466
        // }
        //
        return this.safeInteger(response, "epoch");
    }

    public override object parseMarket(object market)
    {
        //
        // {
        //     "clobPairId": "0",
        //     "ticker": "BTC-USD",
        //     "status": "ACTIVE",
        //     "oraclePrice": "118976.5376",
        //     "priceChange24H": "659.9736",
        //     "volume24H": "1292729.3605",
        //     "trades24H": 9387,
        //     "nextFundingRate": "0",
        //     "initialMarginFraction": "0.02",
        //     "maintenanceMarginFraction": "0.012",
        //     "openInterest": "52.0691",
        //     "atomicResolution": -10,
        //     "quantumConversionExponent": -9,
        //     "tickSize": "1",
        //     "stepSize": "0.0001",
        //     "stepBaseQuantums": 1000000,
        //     "subticksPerTick": 100000,
        //     "marketType": "CROSS",
        //     "openInterestLowerCap": "0",
        //     "openInterestUpperCap": "0",
        //     "baseOpenInterest": "50.3776",
        //     "defaultFundingRate1H": "0"
        // }
        //
        object quoteId = "USDC";
        object marketId = this.safeString(market, "ticker");
        object parts = ((string)marketId).Split(new [] {((string)"-")}, StringSplitOptions.None).ToList<object>();
        object baseName = this.safeString(parts, 0);
        object baseId = this.safeString(market, "baseId", baseName); // idk where 'baseId' comes from, but leaving as is
        object bs = this.safeCurrencyCode(baseId);
        object quote = this.safeCurrencyCode(quoteId);
        object settleId = "USDC";
        object settle = this.safeCurrencyCode(settleId);
        object symbol = add(add(add(add(bs, "/"), quote), ":"), settle);
        object contract = true;
        object swap = true;
        object amountPrecisionStr = this.safeString(market, "stepSize");
        object pricePrecisionStr = this.safeString(market, "tickSize");
        object status = this.safeString(market, "status");
        object active = true;
        if (isTrue(!isEqual(status, "ACTIVE")))
        {
            active = false;
        }
        return this.safeMarketStructure(new Dictionary<string, object>() {
            { "id", this.safeString(market, "ticker") },
            { "symbol", symbol },
            { "base", bs },
            { "quote", quote },
            { "settle", settle },
            { "baseId", baseId },
            { "baseName", baseName },
            { "quoteId", quoteId },
            { "settleId", settleId },
            { "type", "swap" },
            { "spot", false },
            { "margin", null },
            { "swap", swap },
            { "future", false },
            { "option", false },
            { "active", active },
            { "contract", contract },
            { "contractSize", this.parseNumber("1") },
            { "linear", true },
            { "inverse", false },
            { "taker", null },
            { "maker", null },
            { "expiry", null },
            { "expiryDatetime", null },
            { "strike", null },
            { "optionType", null },
            { "precision", new Dictionary<string, object>() {
                { "amount", this.parseNumber(amountPrecisionStr) },
                { "price", this.parseNumber(pricePrecisionStr) },
            } },
            { "limits", new Dictionary<string, object>() {
                { "leverage", new Dictionary<string, object>() {
                    { "min", null },
                    { "max", null },
                } },
                { "amount", new Dictionary<string, object>() {
                    { "min", null },
                    { "max", null },
                } },
                { "price", new Dictionary<string, object>() {
                    { "min", null },
                    { "max", null },
                } },
                { "cost", new Dictionary<string, object>() {
                    { "min", null },
                    { "max", null },
                } },
            } },
            { "created", null },
            { "info", market },
        });
    }

    /**
     * @method
     * @name dydx#fetchMarkets
     * @description retrieves data on all markets for hyperliquid
     * @see https://docs.dydx.xyz/indexer-client/http#get-perpetual-markets
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} an array of objects representing market data
     */
    public async override Task<object> fetchMarkets(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object request = new Dictionary<string, object>() {};
        object response = await this.indexerGetPerpetualMarkets(this.extend(request, parameters));
        //
        // {
        //     "markets": {
        //         "BTC-USD": {
        //             "clobPairId": "0",
        //             "ticker": "BTC-USD",
        //             "status": "ACTIVE",
        //             "oraclePrice": "118976.5376",
        //             "priceChange24H": "659.9736",
        //             "volume24H": "1292729.3605",
        //             "trades24H": 9387,
        //             "nextFundingRate": "0",
        //             "initialMarginFraction": "0.02",
        //             "maintenanceMarginFraction": "0.012",
        //             "openInterest": "52.0691",
        //             "atomicResolution": -10,
        //             "quantumConversionExponent": -9,
        //             "tickSize": "1",
        //             "stepSize": "0.0001",
        //             "stepBaseQuantums": 1000000,
        //             "subticksPerTick": 100000,
        //             "marketType": "CROSS",
        //             "openInterestLowerCap": "0",
        //             "openInterestUpperCap": "0",
        //             "baseOpenInterest": "50.3776",
        //             "defaultFundingRate1H": "0"
        //         }
        //     }
        // }
        //
        object data = this.safeDict(response, "markets", new Dictionary<string, object>() {});
        object markets = new List<object>(((IDictionary<string,object>)data).Values);
        return this.parseMarkets(markets);
    }

    public override object parseTrade(object trade, object market = null)
    {
        //
        // {
        //     "id": "02ac5b1f0000000200000002",
        //     "side": "BUY",
        //     "size": "0.0501",
        //     "price": "115732",
        //     "type": "LIMIT",
        //     "createdAt": "2025-07-25T05:11:09.800Z",
        //     "createdAtHeight": "44849951"
        // }
        //
        object timestamp = this.parse8601(this.safeString(trade, "createdAt"));
        object symbol = getValue(market, "symbol");
        object price = this.safeString(trade, "price");
        object amount = this.safeString(trade, "size");
        object side = this.safeStringLower(trade, "side");
        object id = this.safeString(trade, "id");
        return this.safeTrade(new Dictionary<string, object>() {
            { "id", id },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "symbol", symbol },
            { "side", side },
            { "price", price },
            { "amount", amount },
            { "cost", null },
            { "order", null },
            { "takerOrMaker", null },
            { "type", null },
            { "fee", null },
            { "info", trade },
        }, market);
    }

    /**
     * @method
     * @name dydx#fetchTrades
     * @description get the list of most recent trades for a particular symbol
     * @see https://developer.woox.io/api-reference/endpoint/public_data/marketTrades
     * @param {string} symbol unified symbol of the market to fetch trades for
     * @param {int} [since] timestamp in ms of the earliest trade to fetch
     * @param {int} [limit] the maximum amount of trades to fetch
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/?id=public-trades}
     */
    public async override Task<object> fetchTrades(object symbol, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "market", getValue(market, "id") },
        };
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        object response = await this.indexerGetTradesPerpetualMarketMarket(this.extend(request, parameters));
        //
        // {
        //     "trades": [
        //         {
        //             "id": "02ac5b1f0000000200000002",
        //             "side": "BUY",
        //             "size": "0.0501",
        //             "price": "115732",
        //             "type": "LIMIT",
        //             "createdAt": "2025-07-25T05:11:09.800Z",
        //             "createdAtHeight": "44849951"
        //         }
        //     ]
        // }
        //
        object rows = this.safeList(response, "trades", new List<object>() {});
        return this.parseTrades(rows, market, since, limit);
    }

    public override object parseOHLCV(object ohlcv, object market = null)
    {
        //
        // {
        //     "startedAt": "2025-07-25T09:47:00.000Z",
        //     "ticker": "BTC-USD",
        //     "resolution": "1MIN",
        //     "low": "116099",
        //     "high": "116099",
        //     "open": "116099",
        //     "close": "116099",
        //     "baseTokenVolume": "0",
        //     "usdVolume": "0",
        //     "trades": 0,
        //     "startingOpenInterest": "54.0594",
        //     "orderbookMidPriceOpen": "115845.5",
        //     "orderbookMidPriceClose": "115845.5"
        // }
        //
        return new List<object> {this.parse8601(this.safeString(ohlcv, "startedAt")), this.safeNumber(ohlcv, "open"), this.safeNumber(ohlcv, "high"), this.safeNumber(ohlcv, "low"), this.safeNumber(ohlcv, "close"), this.safeNumber(ohlcv, "baseTokenVolume")};
    }

    /**
     * @method
     * @name dydx#fetchOHLCV
     * @see https://docs.dydx.xyz/indexer-client/http#get-candles
     * @description fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
     * @param {string} symbol unified symbol of the market to fetch OHLCV data for
     * @param {string} timeframe the length of time each candle represents
     * @param {int} [since] timestamp in ms of the earliest candle to fetch
     * @param {int} [limit] the maximum amount of candles to fetch
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {int} [params.until] the latest time in ms to fetch entries for
     * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
     */
    public async override Task<object> fetchOHLCV(object symbol, object timeframe = null, object since = null, object limit = null, object parameters = null)
    {
        timeframe ??= "1m";
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "market", getValue(market, "id") },
            { "resolution", this.safeString(this.timeframes, timeframe, timeframe) },
        };
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = mathMin(limit, 1000);
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["fromIso"] = this.iso8601(since);
        }
        object until = this.safeInteger(parameters, "until");
        parameters = this.omit(parameters, "until");
        if (isTrue(!isEqual(until, null)))
        {
            ((IDictionary<string,object>)request)["toIso"] = this.iso8601(until);
        }
        object response = await this.indexerGetCandlesPerpetualMarketsMarket(this.extend(request, parameters));
        //
        // {
        //     "candles": [
        //         {
        //             "startedAt": "2025-07-25T09:47:00.000Z",
        //             "ticker": "BTC-USD",
        //             "resolution": "1MIN",
        //             "low": "116099",
        //             "high": "116099",
        //             "open": "116099",
        //             "close": "116099",
        //             "baseTokenVolume": "0",
        //             "usdVolume": "0",
        //             "trades": 0,
        //             "startingOpenInterest": "54.0594",
        //             "orderbookMidPriceOpen": "115845.5",
        //             "orderbookMidPriceClose": "115845.5"
        //         }
        //     ]
        // }
        //
        object rows = this.safeList(response, "candles", new List<object>() {});
        return this.parseOHLCVs(rows, market, timeframe, since, limit);
    }

    /**
     * @method
     * @name dydx#fetchFundingRateHistory
     * @description fetches historical funding rate prices
     * @see https://docs.dydx.xyz/indexer-client/http#get-historical-funding
     * @param {string} symbol unified symbol of the market to fetch the funding rate history for
     * @param {int} [since] timestamp in ms of the earliest funding rate to fetch
     * @param {int} [limit] the maximum amount of [funding rate structures]{@link https://docs.ccxt.com/?id=funding-rate-history-structure} to fetch
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {int} [params.until] timestamp in ms of the latest funding rate
     * @returns {object[]} a list of [funding rate structures]{@link https://docs.ccxt.com/?id=funding-rate-history-structure}
     */
    public async override Task<object> fetchFundingRateHistory(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchFundingRateHistory() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "market", getValue(market, "id") },
        };
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        object until = this.safeInteger(parameters, "until");
        if (isTrue(!isEqual(until, null)))
        {
            ((IDictionary<string,object>)request)["effectiveBeforeOrAt"] = this.iso8601(until);
        }
        object response = await this.indexerGetHistoricalFundingMarket(this.extend(request, parameters));
        //
        // {
        //     "historicalFunding": [
        //         {
        //             "ticker": "BTC-USD",
        //             "rate": "0",
        //             "price": "116302.62419",
        //             "effectiveAtHeight": "44865196",
        //             "effectiveAt": "2025-07-25T11:00:00.013Z"
        //         }
        //     ]
        // }
        //
        object rates = new List<object>() {};
        object rows = this.safeList(response, "historicalFunding", new List<object>() {});
        for (object i = 0; isLessThan(i, getArrayLength(rows)); postFixIncrement(ref i))
        {
            object entry = getValue(rows, i);
            object timestamp = this.parse8601(this.safeString(entry, "effectiveAt"));
            object marketId = this.safeString(entry, "ticker");
            ((IList<object>)rates).Add(new Dictionary<string, object>() {
                { "info", entry },
                { "symbol", this.safeSymbol(marketId, market) },
                { "fundingRate", this.safeNumber(entry, "rate") },
                { "timestamp", timestamp },
                { "datetime", this.iso8601(timestamp) },
            });
        }
        object sorted = this.sortBy(rates, "timestamp");
        return this.filterBySymbolSinceLimit(sorted, symbol, since, limit);
    }

    public virtual object handlePublicAddress(object methodName, object parameters)
    {
        object userAux = null;
        var userAuxparametersVariable = this.handleOptionAndParams(parameters, methodName, "user");
        userAux = ((IList<object>)userAuxparametersVariable)[0];
        parameters = ((IList<object>)userAuxparametersVariable)[1];
        object user = userAux;
        var userparametersVariable = this.handleOptionAndParams(parameters, methodName, "address", userAux);
        user = ((IList<object>)userparametersVariable)[0];
        parameters = ((IList<object>)userparametersVariable)[1];
        if (isTrue(isTrue((!isEqual(user, null))) && isTrue((!isEqual(user, "")))))
        {
            return new List<object>() {user, parameters};
        }
        if (isTrue(isTrue((!isEqual(this.walletAddress, null))) && isTrue((!isEqual(this.walletAddress, "")))))
        {
            return new List<object>() {this.walletAddress, parameters};
        }
        throw new ArgumentsRequired ((string)add(add(add(this.id, " "), methodName), "() requires a user parameter inside 'params' or the walletAddress set")) ;
    }

    public override object parseOrder(object order, object market = null)
    {
        //
        // {
        //     "id": "dad46410-3444-5566-a129-19a619300fb7",
        //     "subaccountId": "8586bcf6-1f58-5ec9-a0bc-e53db273e7b0",
        //     "clientId": "716238006",
        //     "clobPairId": "0",
        //     "side": "BUY",
        //     "size": "0.001",
        //     "totalFilled": "0.001",
        //     "price": "400000",
        //     "type": "LIMIT",
        //     "status": "FILLED",
        //     "timeInForce": "GTT",
        //     "reduceOnly": false,
        //     "orderFlags": "64",
        //     "goodTilBlockTime": "2025-07-28T12:07:33.000Z",
        //     "createdAtHeight": "45058325",
        //     "clientMetadata": "2",
        //     "updatedAt": "2025-07-28T12:06:35.330Z",
        //     "updatedAtHeight": "45058326",
        //     "postOnly": false,
        //     "ticker": "BTC-USD",
        //     "subaccountNumber": 0
        // }
        //
        object status = this.parseOrderStatus(this.safeStringUpper(order, "status"));
        object marketId = this.safeString(order, "ticker");
        object symbol = this.safeSymbol(marketId, market);
        object filled = this.safeString(order, "totalFilled");
        object timestamp = this.parse8601(this.safeString(order, "updatedAt"));
        object price = this.safeString(order, "price");
        object amount = this.safeString(order, "size");
        object type = this.parseOrderType(this.safeStringUpper(order, "type"));
        object side = this.safeStringLower(order, "side");
        object timeInForce = this.safeStringUpper(order, "timeInForce");
        return this.safeOrder(new Dictionary<string, object>() {
            { "info", order },
            { "id", this.safeString(order, "id") },
            { "clientOrderId", this.safeString(order, "clientId") },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "lastTradeTimestamp", null },
            { "lastUpdateTimestamp", timestamp },
            { "symbol", symbol },
            { "type", type },
            { "timeInForce", timeInForce },
            { "postOnly", this.safeBool(order, "postOnly") },
            { "reduceOnly", this.safeBool(order, "reduceOnly") },
            { "side", side },
            { "price", price },
            { "triggerPrice", null },
            { "amount", amount },
            { "cost", null },
            { "average", null },
            { "filled", filled },
            { "remaining", null },
            { "status", status },
            { "fee", null },
            { "trades", null },
        }, market);
    }

    public virtual object parseOrderStatus(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "UNTRIGGERED", "open" },
            { "OPEN", "open" },
            { "FILLED", "closed" },
            { "CANCELED", "canceled" },
            { "BEST_EFFORT_CANCELED", "canceling" },
        };
        return this.safeString(statuses, status, status);
    }

    public virtual object parseOrderType(object type)
    {
        object types = new Dictionary<string, object>() {
            { "LIMIT", "LIMIT" },
            { "STOP_LIMIT", "LIMIT" },
            { "TAKE_PROFIT_LIMIT", "LIMIT" },
            { "MARKET", "MARKET" },
            { "STOP_MARKET", "MARKET" },
            { "TAKE_PROFIT_MARKET", "MARKET" },
            { "TRAILING_STOP", "MARKET" },
        };
        return this.safeStringUpper(types, type, type);
    }

    /**
     * @method
     * @name dydx#fetchOrder
     * @description fetches information on an order made by the user
     * @see https://docs.dydx.xyz/indexer-client/http#get-order
     * @param {string} id the order id
     * @param {string} symbol unified symbol of the market the order was made in
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} An [order structure]{@link https://docs.ccxt.com/?id=order-structure}
     */
    public async override Task<object> fetchOrder(object id, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {
            { "orderId", id },
        };
        object order = await this.indexerGetOrdersOrderId(this.extend(request, parameters));
        return this.parseOrder(order);
    }

    /**
     * @method
     * @name dydx#fetchOrders
     * @description fetches information on multiple orders made by the user
     * @see https://docs.dydx.xyz/indexer-client/http#list-orders
     * @param {string} symbol unified market symbol of the market orders were made in
     * @param {int} [since] the earliest time in ms to fetch orders for
     * @param {int} [limit] the maximum number of order structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.address] wallet address that made trades
     * @param {string} [params.subAccountNumber] sub account number
     * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/?id=order-structure}
     */
    public async override Task<object> fetchOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object userAddress = null;
        object subAccountNumber = null;
        var userAddressparametersVariable = this.handlePublicAddress("fetchOrders", parameters);
        userAddress = ((IList<object>)userAddressparametersVariable)[0];
        parameters = ((IList<object>)userAddressparametersVariable)[1];
        var subAccountNumberparametersVariable = this.handleOptionAndParams(parameters, "fetchOrders", "subAccountNumber", "0");
        subAccountNumber = ((IList<object>)subAccountNumberparametersVariable)[0];
        parameters = ((IList<object>)subAccountNumberparametersVariable)[1];
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {
            { "address", userAddress },
            { "subaccountNumber", subAccountNumber },
        };
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            ((IDictionary<string,object>)request)["ticker"] = getValue(market, "id");
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        object response = await this.indexerGetOrders(this.extend(request, parameters));
        //
        // [
        //     {
        //         "id": "dad46410-3444-5566-a129-19a619300fb7",
        //         "subaccountId": "8586bcf6-1f58-5ec9-a0bc-e53db273e7b0",
        //         "clientId": "716238006",
        //         "clobPairId": "0",
        //         "side": "BUY",
        //         "size": "0.001",
        //         "totalFilled": "0.001",
        //         "price": "400000",
        //         "type": "LIMIT",
        //         "status": "FILLED",
        //         "timeInForce": "GTT",
        //         "reduceOnly": false,
        //         "orderFlags": "64",
        //         "goodTilBlockTime": "2025-07-28T12:07:33.000Z",
        //         "createdAtHeight": "45058325",
        //         "clientMetadata": "2",
        //         "updatedAt": "2025-07-28T12:06:35.330Z",
        //         "updatedAtHeight": "45058326",
        //         "postOnly": false,
        //         "ticker": "BTC-USD",
        //         "subaccountNumber": 0
        //     }
        // ]
        //
        return this.parseOrders(response, market, since, limit);
    }

    /**
     * @method
     * @name dydx#fetchOpenOrders
     * @description fetch all unfilled currently open orders
     * @see https://docs.dydx.xyz/indexer-client/http#list-orders
     * @param {string} symbol unified market symbol of the market orders were made in
     * @param {int} [since] the earliest time in ms to fetch orders for
     * @param {int} [limit] the maximum number of order structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.address] wallet address that made trades
     * @param {string} [params.subAccountNumber] sub account number
     * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/?id=order-structure}
     */
    public async override Task<object> fetchOpenOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object request = new Dictionary<string, object>() {
            { "status", "OPEN" },
        };
        return await this.fetchOrders(symbol, since, limit, this.extend(request, parameters));
    }

    /**
     * @method
     * @name dydx#fetchClosedOrders
     * @description fetches information on multiple closed orders made by the user
     * @see https://docs.dydx.xyz/indexer-client/http#list-orders
     * @param {string} symbol unified market symbol of the market orders were made in
     * @param {int} [since] the earliest time in ms to fetch orders for
     * @param {int} [limit] the maximum number of order structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.address] wallet address that made trades
     * @param {string} [params.subAccountNumber] sub account number
     * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/?id=order-structure}
     */
    public async override Task<object> fetchClosedOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object request = new Dictionary<string, object>() {
            { "status", "FILLED" },
        };
        return await this.fetchOrders(symbol, since, limit, this.extend(request, parameters));
    }

    public override object parsePosition(object position, object market = null)
    {
        //
        // {
        //     "market": "BTC-USD",
        //     "status": "OPEN",
        //     "side": "SHORT",
        //     "size": "-0.407",
        //     "maxSize": "-0.009",
        //     "entryPrice": "118692.04840909090909090909",
        //     "exitPrice": "119526.565625",
        //     "realizedPnl": "476.42665909090909090909088",
        //     "unrealizedPnl": "-57.26681734000000000000037",
        //     "createdAt": "2025-07-14T07:53:55.631Z",
        //     "createdAtHeight": "44140908",
        //     "closedAt": null,
        //     "sumOpen": "0.44",
        //     "sumClose": "0.032",
        //     "netFunding": "503.13121",
        //     "subaccountNumber": 0
        // }
        //
        object marketId = this.safeString(position, "market");
        market = this.safeMarket(marketId, market);
        object symbol = getValue(market, "symbol");
        object side = this.safeStringLower(position, "side");
        object quantity = this.safeString(position, "size");
        if (isTrue(!isEqual(side, "long")))
        {
            quantity = Precise.stringMul("-1", quantity);
        }
        object timestamp = this.parse8601(this.safeString(position, "createdAt"));
        return this.safePosition(new Dictionary<string, object>() {
            { "info", position },
            { "id", null },
            { "symbol", symbol },
            { "entryPrice", this.safeNumber(position, "entryPrice") },
            { "markPrice", null },
            { "notional", null },
            { "collateral", null },
            { "unrealizedPnl", this.safeNumber(position, "unrealizedPnl") },
            { "side", side },
            { "contracts", this.parseNumber(quantity) },
            { "contractSize", null },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "hedged", null },
            { "maintenanceMargin", null },
            { "maintenanceMarginPercentage", null },
            { "initialMargin", null },
            { "initialMarginPercentage", null },
            { "leverage", null },
            { "liquidationPrice", null },
            { "marginRatio", null },
            { "marginMode", null },
            { "percentage", null },
        });
    }

    /**
     * @method
     * @name dydx#fetchPosition
     * @description fetch data on an open position
     * @see https://docs.dydx.xyz/indexer-client/http#list-positions
     * @param {string} symbol unified market symbol of the market the position is held in
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.address] wallet address that made trades
     * @param {string} [params.subAccountNumber] sub account number
     * @returns {object} a [position structure]{@link https://docs.ccxt.com/?id=position-structure}
     */
    public async override Task<object> fetchPosition(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object positions = await this.fetchPositions(new List<object>() {symbol}, parameters);
        return this.safeDict(positions, 0, new Dictionary<string, object>() {});
    }

    /**
     * @method
     * @name dydx#fetchPositions
     * @description fetch all open positions
     * @see https://docs.dydx.xyz/indexer-client/http#list-positions
     * @param {string[]} [symbols] list of unified market symbols
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.address] wallet address that made trades
     * @param {string} [params.subAccountNumber] sub account number
     * @returns {object[]} a list of [position structure]{@link https://docs.ccxt.com/?id=position-structure}
     */
    public async override Task<object> fetchPositions(object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object userAddress = null;
        object subAccountNumber = null;
        var userAddressparametersVariable = this.handlePublicAddress("fetchPositions", parameters);
        userAddress = ((IList<object>)userAddressparametersVariable)[0];
        parameters = ((IList<object>)userAddressparametersVariable)[1];
        var subAccountNumberparametersVariable = this.handleOptionAndParams(parameters, "fetchOrders", "subAccountNumber", "0");
        subAccountNumber = ((IList<object>)subAccountNumberparametersVariable)[0];
        parameters = ((IList<object>)subAccountNumberparametersVariable)[1];
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {
            { "address", userAddress },
            { "subaccountNumber", subAccountNumber },
            { "status", "OPEN" },
        };
        object response = await this.indexerGetPerpetualPositions(this.extend(request, parameters));
        //
        // {
        //     "positions": [
        //         {
        //             "market": "BTC-USD",
        //             "status": "OPEN",
        //             "side": "SHORT",
        //             "size": "-0.407",
        //             "maxSize": "-0.009",
        //             "entryPrice": "118692.04840909090909090909",
        //             "exitPrice": "119526.565625",
        //             "realizedPnl": "476.42665909090909090909088",
        //             "unrealizedPnl": "-57.26681734000000000000037",
        //             "createdAt": "2025-07-14T07:53:55.631Z",
        //             "createdAtHeight": "44140908",
        //             "closedAt": null,
        //             "sumOpen": "0.44",
        //             "sumClose": "0.032",
        //             "netFunding": "503.13121",
        //             "subaccountNumber": 0
        //         }
        //     ]
        // }
        //
        object rows = this.safeList(response, "positions", new List<object>() {});
        return this.parsePositions(rows, symbols);
    }

    public virtual object hashMessage(object message)
    {
        return this.hash(message, keccak, "hex");
    }

    public virtual object signHash(object hash, object privateKey)
    {
        object signature = ecdsa(slice(hash, -64, null), slice(privateKey, -64, null), secp256k1, null);
        object r = getValue(signature, "r");
        object s = getValue(signature, "s");
        return new Dictionary<string, object>() {
            { "r", (r as String).PadLeft(Convert.ToInt32(64), Convert.ToChar("0")) },
            { "s", (s as String).PadLeft(Convert.ToInt32(64), Convert.ToChar("0")) },
            { "v", this.sum(27, getValue(signature, "v")) },
        };
    }

    public virtual object signMessage(object message, object privateKey)
    {
        return this.signHash(this.hashMessage(message), slice(privateKey, -64, null));
    }

    public virtual object signOnboardingAction()
    {
        object message = new Dictionary<string, object>() {
            { "action", "dYdX Chain Onboarding" },
        };
        object chainId = getValue(this.options, "chainId");
        object domain = new Dictionary<string, object>() {
            { "chainId", chainId },
            { "name", "dYdX Chain" },
        };
        object messageTypes = new Dictionary<string, object>() {
            { "dYdX", new List<object>() {new Dictionary<string, object>() {
    { "name", "action" },
    { "type", "string" },
}} },
        };
        object msg = this.ethEncodeStructuredData(domain, messageTypes, message);
        if (isTrue(isTrue(isEqual(this.privateKey, null)) || isTrue(isEqual(this.privateKey, ""))))
        {
            throw new ArgumentsRequired ((string)add(this.id, " signOnboardingAction() requires a privateKey to be set.")) ;
        }
        object signature = this.signMessage(msg, this.privateKey);
        return signature;
    }

    public virtual object signDydxTx(object privateKey, object message, object memo, object chainId, object account, object authenticators, object fee = null)
    {
        var encodedTxsignDocVariable = this.encodeDydxTxForSigning(message, memo, chainId, account, authenticators, fee);
        var encodedTx = ((IList<object>) encodedTxsignDocVariable)[0];
        var signDoc = ((IList<object>) encodedTxsignDocVariable)[1];
        object signature = this.signHash(encodedTx, privateKey);
        return this.encodeDydxTxRaw(signDoc, add(getValue(signature, "r"), getValue(signature, "s")));
    }

    public virtual object retrieveCredentials()
    {
        object credentials = this.safeDict(this.options, "dydxCredentials");
        if (isTrue(!isEqual(credentials, null)))
        {
            return credentials;
        }
        object entropy = this.safeString(this.options, "mnemonic");
        if (isTrue(isEqual(entropy, null)))
        {
            object signature = this.signOnboardingAction();
            entropy = this.hashMessage(this.base16ToBinary(add(getValue(signature, "r"), getValue(signature, "s"))));
        }
        credentials = this.retrieveDydxCredentials(entropy);
        ((IDictionary<string,object>)credentials)["privateKey"] = this.binaryToBase16(getValue(credentials, "privateKey"));
        ((IDictionary<string,object>)credentials)["publicKey"] = this.binaryToBase16(getValue(credentials, "publicKey"));
        ((IDictionary<string,object>)this.options)["dydxCredentials"] = credentials;
        return credentials;
    }

    public async virtual Task<object> fetchDydxAccount()
    {
        // required in js
        await this.loadDydxProtos();
        object dydxAccount = this.safeDict(this.options, "dydxAccount");
        if (isTrue(!isEqual(dydxAccount, null)))
        {
            return dydxAccount;
        }
        if (isTrue(isEqual(this.walletAddress, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchDydxAccount() requires the walletAddress to be set using the dydx chain address eg: dydx1cpb4tedmwq304c2kc9pwzjwq0sc6z2a4tasxrz")) ;
        }
        if (!isTrue(((string)this.walletAddress).StartsWith(((string)"dydx"))))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchDydxAccount() requires a valid dydx chain address, starting with dydx, not the l1 address.")) ;
        }
        object request = new Dictionary<string, object>() {
            { "dydxAddress", this.walletAddress },
        };
        //
        // {
        //     "info": {
        //         "address": "string",
        //         "pub_key": {
        //             "type_url": "string",
        //             "key": "string"
        //         },
        //         "account_number": "string",
        //         "sequence": "string"
        //     }
        // }
        //
        object response = await this.nodeRestGetCosmosAuthV1beta1AccountInfoDydxAddress(request);
        object account = this.safeDict(response, "info");
        ((IDictionary<string,object>)account)["pub_key"] = new Dictionary<string, object>() {
            { "key", getValue(getValue(account, "pub_key"), "key") },
        };
        ((IDictionary<string,object>)this.options)["dydxAccount"] = account;
        return account;
    }

    public virtual object pow(object n, object m)
    {
        object r = Precise.stringMul(n, "1");
        object c = this.parseToInt(m);
        // TODO: cap
        for (object i = 1; isLessThan(i, c); postFixIncrement(ref i))
        {
            r = Precise.stringMul(r, n);
        }
        return r;
    }

    public virtual object createOrderRequest(object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object reduceOnly = this.safeBool2(parameters, "reduceOnly", "reduce_only", false);
        object orderType = ((string)type).ToUpper();
        object market = this.market(symbol);
        object orderSide = ((string)side).ToUpper();
        object subaccountId = 0;
        var subaccountIdparametersVariable = this.handleOptionAndParams(parameters, "createOrder", "subAccountId", subaccountId);
        subaccountId = ((IList<object>)subaccountIdparametersVariable)[0];
        parameters = ((IList<object>)subaccountIdparametersVariable)[1];
        object triggerPrice = this.safeString2(parameters, "triggerPrice", "stopPrice");
        object stopLossPrice = this.safeValue(parameters, "stopLossPrice", triggerPrice);
        object takeProfitPrice = this.safeValue(parameters, "takeProfitPrice");
        object isConditional = isTrue(isTrue(!isEqual(triggerPrice, null)) || isTrue(!isEqual(stopLossPrice, null))) || isTrue(!isEqual(takeProfitPrice, null));
        object isMarket = isEqual(orderType, "MARKET");
        object timeInForce = this.safeStringUpper(parameters, "timeInForce", "GTT");
        object postOnly = this.isPostOnly(isMarket, null, parameters);
        object amountStr = this.amountToPrecision(symbol, amount);
        object priceStr = this.priceToPrecision(symbol, price);
        object marketInfo = this.safeDict(market, "info");
        object atomicResolution = getValue(marketInfo, "atomicResolution");
        object quantumScale = this.pow("10", Precise.stringNeg(atomicResolution));
        object quantums = Precise.stringMul(amountStr, quantumScale);
        object quantumConversionExponent = getValue(marketInfo, "quantumConversionExponent");
        object priceScale = this.pow("10", Precise.stringSub(Precise.stringSub(atomicResolution, quantumConversionExponent), "-6"));
        object subticks = Precise.stringMul(priceStr, priceScale);
        object clientMetadata = 0;
        object conditionalType = 0;
        object conditionalOrderTriggerSubticks = "0";
        object orderFlag = null;
        object timeInForceNumber = null;
        if (isTrue(isEqual(timeInForce, "FOK")))
        {
            throw new InvalidOrder ((string)add(this.id, " timeInForce fok has been deprecated")) ;
        }
        if (isTrue(isEqual(orderType, "MARKET")))
        {
            // short-term
            orderFlag = 0;
            clientMetadata = 1; // STOP_MARKET / TAKE_PROFIT_MARKET
            if (isTrue(!isEqual(timeInForce, null)))
            {
                // default is ioc
                timeInForceNumber = 1;
            }
        } else if (isTrue(isEqual(orderType, "LIMIT")))
        {
            if (isTrue(isEqual(timeInForce, "GTT")))
            {
                // long-term
                orderFlag = 64;
                if (isTrue(postOnly))
                {
                    timeInForceNumber = 2;
                } else
                {
                    timeInForceNumber = 0;
                }
            } else
            {
                orderFlag = 0;
                if (isTrue(isEqual(timeInForce, "IOC")))
                {
                    timeInForceNumber = 1;
                } else
                {
                    throw new InvalidOrder ((string)"unexpected code path: timeInForce") ;
                }
            }
        }
        if (isTrue(isConditional))
        {
            // conditional
            orderFlag = 32;
            if (isTrue(!isEqual(stopLossPrice, null)))
            {
                conditionalType = 1;
                conditionalOrderTriggerSubticks = this.priceToPrecision(symbol, stopLossPrice);
            } else if (isTrue(!isEqual(takeProfitPrice, null)))
            {
                conditionalType = 2;
                conditionalOrderTriggerSubticks = this.priceToPrecision(symbol, takeProfitPrice);
            }
            conditionalOrderTriggerSubticks = Precise.stringMul(conditionalOrderTriggerSubticks, priceScale);
        }
        object latestBlockHeight = this.safeInteger(parameters, "latestBlockHeight");
        object goodTillBlock = this.safeInteger(parameters, "goodTillBlock");
        object goodTillBlockTime = null;
        object goodTillBlockTimeInSeconds = 2592000;
        var goodTillBlockTimeInSecondsparametersVariable = this.handleOptionAndParams(parameters, "createOrder", "goodTillBlockTimeInSeconds", goodTillBlockTimeInSeconds);
        goodTillBlockTimeInSeconds = ((IList<object>)goodTillBlockTimeInSecondsparametersVariable)[0];
        parameters = ((IList<object>)goodTillBlockTimeInSecondsparametersVariable)[1]; // default is 30 days
        if (isTrue(isEqual(orderFlag, 0)))
        {
            if (isTrue(isEqual(goodTillBlock, null)))
            {
                // short term order
                goodTillBlock = add(latestBlockHeight, 20);
            }
        } else
        {
            if (isTrue(isEqual(goodTillBlockTimeInSeconds, null)))
            {
                throw new ArgumentsRequired ((string)"goodTillBlockTimeInSeconds is required.") ;
            }
            goodTillBlockTime = add(this.seconds(), goodTillBlockTimeInSeconds);
        }
        object sideNumber = ((bool) isTrue((isEqual(orderSide, "BUY")))) ? 1 : 2;
        object defaultClientOrderId = this.randNumber(9); // 2**32 - 1 is 10 digits, but it may overflow with 10
        object clientOrderId = this.safeInteger(parameters, "clientOrderId", defaultClientOrderId);
        object orderPayload = new Dictionary<string, object>() {
            { "order", new Dictionary<string, object>() {
                { "orderId", new Dictionary<string, object>() {
                    { "subaccountId", new Dictionary<string, object>() {
                        { "owner", this.getWalletAddress() },
                        { "number", subaccountId },
                    } },
                    { "clientId", clientOrderId },
                    { "orderFlags", orderFlag },
                    { "clobPairId", getValue(marketInfo, "clobPairId") },
                } },
                { "side", sideNumber },
                { "quantums", this.toDydxLong(quantums) },
                { "subticks", this.toDydxLong(subticks) },
                { "goodTilBlock", goodTillBlock },
                { "goodTilBlockTime", goodTillBlockTime },
                { "timeInForce", timeInForceNumber },
                { "reduceOnly", reduceOnly },
                { "clientMetadata", clientMetadata },
                { "conditionType", conditionalType },
                { "conditionalOrderTriggerSubticks", this.toDydxLong(conditionalOrderTriggerSubticks) },
                { "orderRouterAddress", this.safeString(this.options, "routerAddress", "dydx165sfn2k3vucvq7gklauy2r3agyjw4c3m60ascn") },
            } },
        };
        object signingPayload = new Dictionary<string, object>() {
            { "typeUrl", "/dydxprotocol.clob.MsgPlaceOrder" },
            { "value", orderPayload },
        };
        parameters = this.omit(parameters, new List<object>() {"reduceOnly", "reduce_only", "clientOrderId", "postOnly", "timeInForce", "stopPrice", "triggerPrice", "stopLoss", "takeProfit", "latestBlockHeight", "goodTillBlock", "goodTillBlockTimeInSeconds", "subaccountId"});
        object orderId = this.createOrderIdFromParts(this.getWalletAddress(), subaccountId, clientOrderId, orderFlag, getValue(marketInfo, "clobPairId"));
        return new List<object>() {orderId, this.extend(signingPayload, parameters)};
    }

    public virtual object createOrderIdFromParts(object address, object subAccountNumber, object clientOrderId, object orderFlags, object clobPairId)
    {
        object nameSp = this.safeString(this.options, "namespace", "0f9da948-a6fb-4c45-9edc-4685c3f3317d");
        object prefixAddress = add(add(address, "-"), ((object)subAccountNumber).ToString());
        object prefix = this.uuid5(nameSp, prefixAddress);
        object orderInfo = add(add(add(add(add(add(prefix, "-"), this.numberToString(clientOrderId)), "-"), this.numberToString(clobPairId)), "-"), this.numberToString(orderFlags));
        return this.uuid5(nameSp, orderInfo);
    }

    public async virtual Task<object> fetchLatestBlockHeight(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object response = await this.nodeRpcGetAbciInfo(parameters);
        //
        // {
        //     "jsonrpc": "2.0",
        //     "id": -1,
        //     "result": {
        //         "response": {
        //             "data": "dydxprotocol",
        //             "version": "9.1.0-rc0",
        //             "last_block_height": "49157714",
        //             "last_block_app_hash": "9LHAcDDI5zmWiC6bGiiGtxuWPlKJV+/fTBZk/WQ/Y4U="
        //         }
        //     }
        // }
        //
        object result = this.safeDict(response, "result");
        object info = this.safeDict(result, "response");
        return this.safeInteger(info, "last_block_height");
    }

    /**
     * @method
     * @name dydx#createOrder
     * @see https://docs.dydx.xyz/interaction/trading#place-an-order
     * @description create a trade order
     * @param {string} symbol unified symbol of the market to create an order in
     * @param {string} type 'market' or 'limit'
     * @param {string} side 'buy' or 'sell'
     * @param {float} amount how much of currency you want to trade in units of base currency
     * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.timeInForce] "GTT", "IOC", or "PO"
     * @param {float} [params.triggerPrice] The price a trigger order is triggered at
     * @param {float} [params.stopLossPrice] price for a stoploss order
     * @param {float} [params.takeProfitPrice] price for a takeprofit order
     * @param {string} [params.clientOrderId] a unique id for the order
     * @param {bool} [params.postOnly] true or false whether the order is post-only
     * @param {bool} [params.reduceOnly] true or false whether the order is reduce-only
     * @param {float} [params.goodTillBlock] expired block number for the order, required for market order and non limit GTT order, default value is latestBlockHeight + 20
     * @param {float} [params.goodTillBlockTimeInSeconds] expired time elapsed for the order, required for limit GTT order and conditional, default value is 30 days
     * @returns {object} an [order structure]{@link https://docs.ccxt.com/?id=order-structure}
     */
    public async override Task<object> createOrder(object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object credentials = this.retrieveCredentials();
        object account = await this.fetchDydxAccount();
        object lastBlockHeight = await this.fetchLatestBlockHeight();
        // params['latestBlockHeight'] = lastBlockHeight;
        object newParams = this.extend(parameters, new Dictionary<string, object>() {
            { "latestBlockHeight", lastBlockHeight },
        });
        object orderRequestRes = this.createOrderRequest(symbol, type, side, amount, price, newParams);
        object orderId = getValue(orderRequestRes, 0);
        object orderRequest = getValue(orderRequestRes, 1);
        object chainName = getValue(this.options, "chainName");
        object signedTx = this.signDydxTx(getValue(credentials, "privateKey"), orderRequest, "", chainName, account, null);
        object request = new Dictionary<string, object>() {
            { "tx", signedTx },
        };
        // nodeRpcGetBroadcastTxAsync
        object response = await this.nodeRpcGetBroadcastTxSync(request);
        //
        // {
        //     "jsonrpc": "2.0",
        //     "id": -1,
        //     "result": {
        //         "code": 0,
        //         "data": "",
        //         "log": "[]",
        //         "codespace": "",
        //         "hash": "CBEDB0603E57E5CE21FA6954770A9403D2A81BED02E608C860356152D0AA1A81"
        //     }
        // }
        //
        object result = this.safeDict(response, "result");
        return this.safeOrder(new Dictionary<string, object>() {
            { "info", result },
            { "id", orderId },
            { "clientOrderId", getValue(getValue(getValue(getValue(orderRequest, "value"), "order"), "orderId"), "clientId") },
        });
    }

    /**
     * @method
     * @name dydx#cancelOrder
     * @description cancels an open order
     * @see https://docs.dydx.xyz/interaction/trading/#cancel-an-order
     * @param {string} id it should be the clientOrderId in this case
     * @param {string} symbol unified symbol of the market the order was made in
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.clientOrderId] client order id used when creating the order
     * @param {boolean} [params.trigger] whether the order is a trigger/algo order
     * @param {float} [params.orderFlags] default is 64, orderFlags for the order, market order and non limit GTT order is 0, limit GTT order is 64 and conditional order is 32
     * @param {float} [params.goodTillBlock] expired block number for the order, required for market order and non limit GTT order (orderFlags = 0), default value is latestBlockHeight + 20
     * @param {float} [params.goodTillBlockTimeInSeconds] expired time elapsed for the order, required for limit GTT order and conditional (orderFlagss > 0), default value is 30 days
     * @param {int} [params.subAccountId] sub account id, default is 0
     * @returns {object} An [order structure]{@link https://docs.ccxt.com/?id=order-structure}
     */
    public async override Task<object> cancelOrder(object id, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object isTrigger = this.safeBool2(parameters, "trigger", "stop", false);
        parameters = this.omit(parameters, new List<object>() {"trigger", "stop"});
        if (isTrue(!isTrue(isTrigger) && isTrue((isEqual(symbol, null)))))
        {
            throw new ArgumentsRequired ((string)add(this.id, " cancelOrder() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object clientOrderId = this.safeString2(parameters, "clientOrderId", "clientId", id);
        if (isTrue(isEqual(clientOrderId, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " cancelOrder() requires a clientOrderId parameter, cancelling using id is not currently supported.")) ;
        }
        object idString = ((object)id).ToString();
        if (isTrue(isTrue(!isEqual(id, null)) && isTrue(isGreaterThan(getIndexOf(idString, "-"), -1))))
        {
            throw new NotSupported ((string)add(this.id, " cancelOrder() cancelling using id is not currently supported, please use provide the clientOrderId parameter.")) ;
        }
        object goodTillBlock = this.safeInteger(parameters, "goodTillBlock");
        object goodTillBlockTimeInSeconds = 2592000;
        var goodTillBlockTimeInSecondsparametersVariable = this.handleOptionAndParams(parameters, "cancelOrder", "goodTillBlockTimeInSeconds", goodTillBlockTimeInSeconds);
        goodTillBlockTimeInSeconds = ((IList<object>)goodTillBlockTimeInSecondsparametersVariable)[0];
        parameters = ((IList<object>)goodTillBlockTimeInSecondsparametersVariable)[1]; // default is 30 days
        object goodTillBlockTime = null;
        object defaultOrderFlags = ((bool) isTrue((isTrigger))) ? 32 : 64;
        object orderFlags = this.safeInteger(parameters, "orderFlags", defaultOrderFlags);
        object subAccountId = 0;
        var subAccountIdparametersVariable = this.handleOptionAndParams(parameters, "cancelOrder", "subAccountId", subAccountId);
        subAccountId = ((IList<object>)subAccountIdparametersVariable)[0];
        parameters = ((IList<object>)subAccountIdparametersVariable)[1];
        parameters = this.omit(parameters, new List<object>() {"clientOrderId", "orderFlags", "goodTillBlock", "goodTillBlockTime", "goodTillBlockTimeInSeconds", "subaccountId", "clientId"});
        if (isTrue(isTrue(isTrue(!isEqual(orderFlags, 0)) && isTrue(!isEqual(orderFlags, 64))) && isTrue(!isEqual(orderFlags, 32))))
        {
            throw new InvalidOrder ((string)add(this.id, " invalid orderFlags, allowed values are (0, 64, 32).")) ;
        }
        if (isTrue(isGreaterThan(orderFlags, 0)))
        {
            if (isTrue(isEqual(goodTillBlockTimeInSeconds, null)))
            {
                throw new ArgumentsRequired ((string)add(this.id, " goodTillBlockTimeInSeconds is required in params for long term or conditional order.")) ;
            }
            if (isTrue(isTrue(!isEqual(goodTillBlock, null)) && isTrue(isGreaterThan(goodTillBlock, 0))))
            {
                throw new InvalidOrder ((string)add(this.id, " goodTillBlock should be 0 for long term or conditional order.")) ;
            }
            goodTillBlockTime = add(this.seconds(), goodTillBlockTimeInSeconds);
        } else
        {
            if (isTrue(isEqual(goodTillBlock, null)))
            {
                object latestBlockHeight = await this.fetchLatestBlockHeight();
                goodTillBlock = add(latestBlockHeight, 20);
            }
        }
        object credentials = this.retrieveCredentials();
        object account = await this.fetchDydxAccount();
        object cancelPayload = new Dictionary<string, object>() {
            { "orderId", new Dictionary<string, object>() {
                { "subaccountId", new Dictionary<string, object>() {
                    { "owner", this.getWalletAddress() },
                    { "number", subAccountId },
                } },
                { "clientId", clientOrderId },
                { "orderFlags", orderFlags },
                { "clobPairId", getValue(getValue(market, "info"), "clobPairId") },
            } },
            { "goodTilBlock", goodTillBlock },
            { "goodTilBlockTime", goodTillBlockTime },
        };
        object signingPayload = new Dictionary<string, object>() {
            { "typeUrl", "/dydxprotocol.clob.MsgCancelOrder" },
            { "value", cancelPayload },
        };
        object chainName = getValue(this.options, "chainName");
        object signedTx = this.signDydxTx(getValue(credentials, "privateKey"), signingPayload, "", chainName, account, null);
        object request = new Dictionary<string, object>() {
            { "tx", signedTx },
        };
        // nodeRpcGetBroadcastTxAsync
        object response = await this.nodeRpcGetBroadcastTxSync(request);
        //
        // {
        //     "jsonrpc": "2.0",
        //     "id": -1,
        //     "result": {
        //         "code": 0,
        //         "data": "",
        //         "log": "[]",
        //         "codespace": "",
        //         "hash": "CBEDB0603E57E5CE21FA6954770A9403D2A81BED02E608C860356152D0AA1A81"
        //     }
        // }
        //
        object result = this.safeDict(response, "result");
        return this.safeOrder(new Dictionary<string, object>() {
            { "info", result },
        });
    }

    /**
     * @method
     * @name dydx#cancelOrders
     * @description cancel multiple orders
     * @param {string[]} ids order ids
     * @param {string} [symbol] unified market symbol
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string[]} [params.clientOrderIds] max length 10 e.g. ["my_id_1","my_id_2"], encode the double quotes. No space after comma
     * @param {int} [params.subAccountId] sub account id, default is 0
     * @returns {object} an list of [order structures]{@link https://docs.ccxt.com/?id=order-structure}
     */
    public async override Task<object> cancelOrders(object ids, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object clientOrderIds = this.safeList(parameters, "clientOrderIds");
        if (!isTrue(clientOrderIds))
        {
            throw new NotSupported ((string)add(this.id, " cancelOrders only support clientOrderIds.")) ;
        }
        object subAccountId = 0;
        var subAccountIdparametersVariable = this.handleOptionAndParams(parameters, "cancelOrders", "subAccountId", subAccountId);
        subAccountId = ((IList<object>)subAccountIdparametersVariable)[0];
        parameters = ((IList<object>)subAccountIdparametersVariable)[1];
        object goodTillBlock = this.safeInteger(parameters, "goodTillBlock");
        if (isTrue(isEqual(goodTillBlock, null)))
        {
            object latestBlockHeight = await this.fetchLatestBlockHeight();
            goodTillBlock = add(latestBlockHeight, 20);
        }
        parameters = this.omit(parameters, new List<object>() {"clientOrderIds", "goodTillBlock", "subaccountId"});
        object credentials = this.retrieveCredentials();
        object account = await this.fetchDydxAccount();
        object cancelOrders = new Dictionary<string, object>() {
            { "clientIds", clientOrderIds },
            { "clobPairId", getValue(getValue(market, "info"), "clobPairId") },
        };
        object cancelPayload = new Dictionary<string, object>() {
            { "subaccountId", new Dictionary<string, object>() {
                { "owner", this.getWalletAddress() },
                { "number", subAccountId },
            } },
            { "shortTermCancels", new List<object>() {cancelOrders} },
            { "goodTilBlock", goodTillBlock },
        };
        object signingPayload = new Dictionary<string, object>() {
            { "typeUrl", "/dydxprotocol.clob.MsgBatchCancel" },
            { "value", cancelPayload },
        };
        object chainName = getValue(this.options, "chainName");
        object signedTx = this.signDydxTx(getValue(credentials, "privateKey"), signingPayload, "", chainName, account, null);
        object request = new Dictionary<string, object>() {
            { "tx", signedTx },
        };
        // nodeRpcGetBroadcastTxAsync
        object response = await this.nodeRpcGetBroadcastTxSync(request);
        //
        // {
        //     "jsonrpc": "2.0",
        //     "id": -1,
        //     "result": {
        //         "code": 0,
        //         "data": "",
        //         "log": "[]",
        //         "codespace": "",
        //         "hash": "CBEDB0603E57E5CE21FA6954770A9403D2A81BED02E608C860356152D0AA1A81"
        //     }
        // }
        //
        object result = this.safeDict(response, "result");
        return new List<object> {this.safeOrder(new Dictionary<string, object>() {
    { "info", result },
})};
    }

    /**
     * @method
     * @name dydx#fetchOrderBook
     * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
     * @see https://docs.dydx.xyz/indexer-client/http#get-perpetual-market-orderbook
     * @param {string} symbol unified symbol of the market to fetch the order book for
     * @param {int} [limit] the maximum amount of order book entries to return
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/?id=order-book-structure} indexed by market symbols
     */
    public async override Task<object> fetchOrderBook(object symbol, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "market", getValue(market, "id") },
        };
        object response = await this.indexerGetOrderbooksPerpetualMarketMarket(this.extend(request, parameters));
        //
        // {
        //     "bids": [
        //         {
        //             "price": "118267",
        //             "size": "0.3182"
        //         }
        //     ],
        //     "asks": [
        //         {
        //             "price": "118485",
        //             "size": "0.0001"
        //         }
        //     ]
        // }
        //
        return this.parseOrderBook(response, getValue(market, "symbol"), null, "bids", "asks", "price", "size");
    }

    public override object parseLedgerEntry(object item, object currency = null)
    {
        //
        // {
        //     "id": "6a6075bc-7183-5fd9-bc9d-894e238aa527",
        //     "sender": {
        //         "address": "dydx14zzueazeh0hj67cghhf9jypslcf9sh2n5k6art",
        //         "subaccountNumber": 0
        //     },
        //     "recipient": {
        //         "address": "dydx1slanxj8x9ntk9knwa6cvfv2tzlsq5gk3dshml0",
        //         "subaccountNumber": 1
        //     },
        //     "size": "0.000001",
        //     "createdAt": "2025-07-29T09:43:02.105Z",
        //     "createdAtHeight": "45116125",
        //     "symbol": "USDC",
        //     "type": "TRANSFER_OUT",
        //     "transactionHash": "92B4744BA1B783CF37C79A50BEBC47FFD59C8D5197D62A8485D3DCCE9AF220AF"
        // }
        //
        object currencyId = this.safeString(item, "symbol");
        object code = this.safeCurrencyCode(currencyId, currency);
        currency = this.safeCurrency(currencyId, currency);
        object type = this.safeStringUpper(item, "type");
        object direction = null;
        if (isTrue(!isEqual(type, null)))
        {
            if (isTrue(isTrue(isEqual(type, "TRANSFER_IN")) || isTrue(isEqual(type, "DEPOSIT"))))
            {
                direction = "in";
            } else if (isTrue(isTrue(isEqual(type, "TRANSFER_OUT")) || isTrue(isEqual(type, "WITHDRAWAL"))))
            {
                direction = "out";
            }
        }
        object amount = this.safeString(item, "size");
        object timestamp = this.parse8601(this.safeString(item, "createdAt"));
        object sender = this.safeDict(item, "sender");
        object recipient = this.safeDict(item, "recipient");
        return this.safeLedgerEntry(new Dictionary<string, object>() {
            { "info", item },
            { "id", this.safeString(item, "id") },
            { "direction", direction },
            { "account", this.safeString(sender, "address") },
            { "referenceAccount", this.safeString(recipient, "address") },
            { "referenceId", this.safeString(item, "transactionHash") },
            { "type", this.parseLedgerEntryType(type) },
            { "currency", code },
            { "amount", this.parseNumber(amount) },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "before", null },
            { "after", null },
            { "status", null },
            { "fee", null },
        }, currency);
    }

    public virtual object parseLedgerEntryType(object type)
    {
        object ledgerType = new Dictionary<string, object>() {
            { "TRANSFER_IN", "transfer" },
            { "TRANSFER_OUT", "transfer" },
            { "DEPOSIT", "deposit" },
            { "WITHDRAWAL", "withdrawal" },
        };
        return this.safeString(ledgerType, type, type);
    }

    /**
     * @method
     * @name dydx#fetchLedger
     * @description fetch the history of changes, actions done by the user or operations that altered balance of the user
     * @see https://docs.dydx.xyz/indexer-client/http#get-transfers
     * @param {string} [code] unified currency code, default is undefined
     * @param {int} [since] timestamp in ms of the earliest ledger entry, default is undefined
     * @param {int} [limit] max number of ledger entries to return, default is undefined
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.address] wallet address that made trades
     * @param {string} [params.subAccountNumber] sub account number
     * @returns {object} a [ledger structure]{@link https://docs.ccxt.com/?id=ledger-entry-structure}
     */
    public async override Task<object> fetchLedger(object code = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = null;
        if (isTrue(!isEqual(code, null)))
        {
            currency = this.currency(code);
        }
        object response = await this.fetchTransactionsHelper(code, since, limit, this.extend(parameters, new Dictionary<string, object>() {
            { "methodName", "fetchLedger" },
        }));
        return this.parseLedger(response, currency, since, limit);
    }

    public async virtual Task<object> estimateTxFee(object message, object memo, object account)
    {
        object txBytes = this.encodeDydxTxForSimulation(message, memo, getValue(account, "sequence"), getValue(account, "pub_key"));
        object request = new Dictionary<string, object>() {
            { "txBytes", txBytes },
        };
        object response = await this.nodeRestPostCosmosTxV1beta1Simulate(request);
        //
        // {
        //     gas_info: { gas_wanted: '18446744073709551615', gas_used: '86055' },
        //     result: {
        //         ...
        //     }
        // }
        //
        object gasInfo = this.safeDict(response, "gas_info");
        if (isTrue(isEqual(gasInfo, null)))
        {
            throw new ExchangeError ((string)add(this.id, " failed to simulate transaction.")) ;
        }
        object gasUsed = this.safeString(gasInfo, "gas_used");
        if (isTrue(isEqual(gasUsed, null)))
        {
            throw new ExchangeError ((string)add(this.id, " failed to simulate transaction.")) ;
        }
        object defaultFeeDenom = this.safeString(this.options, "defaultFeeDenom");
        object defaultFeeMultiplier = this.safeString(this.options, "defaultFeeMultiplier");
        object feeDenom = this.safeDict(this.options, "feeDenom");
        object gasPrice = null;
        object denom = null;
        if (isTrue(isEqual(defaultFeeDenom, "uusdc")))
        {
            gasPrice = getValue(feeDenom, "USDC_GAS_PRICE");
            denom = getValue(feeDenom, "USDC_DENOM");
        } else
        {
            gasPrice = getValue(feeDenom, "CHAINTOKEN_GAS_PRICE");
            denom = getValue(feeDenom, "CHAINTOKEN_DENOM");
        }
        object gasLimit = Math.Ceiling(Convert.ToDouble(this.parseToNumeric(Precise.stringMul(gasUsed, defaultFeeMultiplier))));
        object feeAmount = Precise.stringMul(this.numberToString(gasLimit), gasPrice);
        if (isTrue(isGreaterThanOrEqual(getIndexOf(feeAmount, "."), 0)))
        {
            feeAmount = this.numberToString(Math.Ceiling(Convert.ToDouble(this.parseToNumeric(feeAmount))));
        }
        object feeObj = new Dictionary<string, object>() {
            { "amount", feeAmount },
            { "denom", denom },
        };
        return new Dictionary<string, object>() {
            { "amount", new List<object>() {feeObj} },
            { "gasLimit", gasLimit },
        };
    }

    /**
     * @method
     * @name dydx#transfer
     * @description transfer currency internally between wallets on the same account
     * @param {string} code unified currency code
     * @param {float} amount amount to transfer
     * @param {string} fromAccount account to transfer from *main, subaccount*
     * @param {string} toAccount account to transfer to *subaccount, address*
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.vaultAddress] the vault address for order
     * @returns {object} a [transfer structure]{@link https://docs.ccxt.com/?id=transfer-structure}
     */
    public async override Task<object> transfer(object code, object amount, object fromAccount, object toAccount, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (isTrue(!isEqual(code, "USDC")))
        {
            throw new NotSupported ((string)add(this.id, " transfer() only support USDC")) ;
        }
        await this.loadMarkets();
        object fromSubaccountId = this.safeInteger(parameters, "fromSubaccountId");
        object toSubaccountId = this.safeInteger(parameters, "toSubaccountId");
        if (isTrue(!isEqual(fromAccount, "main")))
        {
            // throw error if from subaccount id is undefind
            if (isTrue(isEqual(fromAccount, null)))
            {
                throw new NotSupported ((string)add(this.id, " transfer only support main > subaccount and subaccount <> subaccount.")) ;
            }
            if (isTrue(isTrue(isEqual(fromSubaccountId, null)) || isTrue(isEqual(toSubaccountId, null))))
            {
                throw new ArgumentsRequired ((string)add(this.id, " transfer requires fromSubaccountId and toSubaccountId.")) ;
            }
        }
        parameters = this.omit(parameters, new List<object>() {"fromSubaccountId", "toSubaccountId"});
        object credentials = this.retrieveCredentials();
        object account = await this.fetchDydxAccount();
        object usd = this.parseToInt(Precise.stringMul(this.numberToString(amount), "1000000"));
        object payload = null;
        object signingPayload = null;
        if (isTrue(isEqual(fromAccount, "main")))
        {
            // deposit to subaccount
            if (isTrue(isEqual(toSubaccountId, null)))
            {
                throw new ArgumentsRequired ((string)add(this.id, " transfer() requeire toSubaccoutnId.")) ;
            }
            payload = new Dictionary<string, object>() {
                { "sender", this.getWalletAddress() },
                { "recipient", new Dictionary<string, object>() {
                    { "owner", this.getWalletAddress() },
                    { "number", toSubaccountId },
                } },
                { "assetId", 0 },
                { "quantums", usd },
            };
            signingPayload = new Dictionary<string, object>() {
                { "typeUrl", "/dydxprotocol.sending.MsgDepositToSubaccount" },
                { "value", payload },
            };
        } else
        {
            payload = new Dictionary<string, object>() {
                { "transfer", new Dictionary<string, object>() {
                    { "sender", new Dictionary<string, object>() {
                        { "owner", fromAccount },
                        { "number", fromSubaccountId },
                    } },
                    { "recipient", new Dictionary<string, object>() {
                        { "owner", toAccount },
                        { "number", toSubaccountId },
                    } },
                    { "assetId", 0 },
                    { "amount", usd },
                } },
            };
            signingPayload = new Dictionary<string, object>() {
                { "typeUrl", "/dydxprotocol.sending.MsgCreateTransfer" },
                { "value", payload },
            };
        }
        object txFee = await this.estimateTxFee(signingPayload, "", account);
        object chainName = getValue(this.options, "chainName");
        object signedTx = this.signDydxTx(getValue(credentials, "privateKey"), signingPayload, "", chainName, account, null, txFee);
        object request = new Dictionary<string, object>() {
            { "tx", signedTx },
        };
        // nodeRpcGetBroadcastTxAsync
        object response = await this.nodeRpcGetBroadcastTxSync(request);
        //
        // {
        //     "jsonrpc": "2.0",
        //     "id": -1,
        //     "result": {
        //         "code": 0,
        //         "data": "",
        //         "log": "[]",
        //         "codespace": "",
        //         "hash": "CBEDB0603E57E5CE21FA6954770A9403D2A81BED02E608C860356152D0AA1A81"
        //     }
        // }
        //
        return this.parseTransfer(response);
    }

    public override object parseTransfer(object transfer, object currency = null)
    {
        //
        // {
        //     "id": "6a6075bc-7183-5fd9-bc9d-894e238aa527",
        //     "sender": {
        //         "address": "dydx14zzueazeh0hj67cghhf9jypslcf9sh2n5k6art",
        //         "subaccountNumber": 0
        //     },
        //     "recipient": {
        //         "address": "dydx1slanxj8x9ntk9knwa6cvfv2tzlsq5gk3dshml0",
        //         "subaccountNumber": 1
        //     },
        //     "size": "0.000001",
        //     "createdAt": "2025-07-29T09:43:02.105Z",
        //     "createdAtHeight": "45116125",
        //     "symbol": "USDC",
        //     "type": "TRANSFER_OUT",
        //     "transactionHash": "92B4744BA1B783CF37C79A50BEBC47FFD59C8D5197D62A8485D3DCCE9AF220AF"
        // }
        //
        object id = this.safeString(transfer, "id");
        object currencyId = this.safeString(transfer, "symbol");
        object code = this.safeCurrencyCode(currencyId, currency);
        object amount = this.safeNumber(transfer, "size");
        object sender = this.safeDict(transfer, "sender");
        object recipient = this.safeDict(transfer, "recipient");
        object fromAccount = this.safeString(sender, "address");
        object toAccount = this.safeString(recipient, "address");
        object timestamp = this.parse8601(this.safeString(transfer, "createdAt"));
        return new Dictionary<string, object>() {
            { "info", transfer },
            { "id", id },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "currency", code },
            { "amount", amount },
            { "fromAccount", fromAccount },
            { "toAccount", toAccount },
            { "status", null },
        };
    }

    /**
     * @method
     * @name dydx#fetchTransfers
     * @description fetch a history of internal transfers made on an account
     * @see https://docs.dydx.xyz/indexer-client/http#get-transfers
     * @param {string} code unified currency code of the currency transferred
     * @param {int} [since] the earliest time in ms to fetch transfers for
     * @param {int} [limit] the maximum number of transfers structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.address] wallet address that made trades
     * @param {string} [params.subAccountNumber] sub account number
     * @returns {object[]} a list of [transfer structures]{@link https://docs.ccxt.com/?id=transfer-structure}
     */
    public async override Task<object> fetchTransfers(object code = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = null;
        if (isTrue(!isEqual(code, null)))
        {
            currency = this.currency(code);
        }
        object response = await this.fetchTransactionsHelper(code, since, limit, this.extend(parameters, new Dictionary<string, object>() {
            { "methodName", "fetchTransfers" },
        }));
        object transferIn = this.filterBy(response, "type", "TRANSFER_IN");
        object transferOut = this.filterBy(response, "type", "TRANSFER_OUT");
        object rows = this.arrayConcat(transferIn, transferOut);
        return this.parseTransfers(rows, currency, since, limit);
    }

    public override object parseTransaction(object transaction, object currency = null)
    {
        //
        // {
        //     "id": "6a6075bc-7183-5fd9-bc9d-894e238aa527",
        //     "sender": {
        //         "address": "dydx14zzueazeh0hj67cghhf9jypslcf9sh2n5k6art",
        //         "subaccountNumber": 0
        //     },
        //     "recipient": {
        //         "address": "dydx1slanxj8x9ntk9knwa6cvfv2tzlsq5gk3dshml0",
        //         "subaccountNumber": 1
        //     },
        //     "size": "0.000001",
        //     "createdAt": "2025-07-29T09:43:02.105Z",
        //     "createdAtHeight": "45116125",
        //     "symbol": "USDC",
        //     "type": "TRANSFER_OUT",
        //     "transactionHash": "92B4744BA1B783CF37C79A50BEBC47FFD59C8D5197D62A8485D3DCCE9AF220AF"
        // }
        //
        object id = this.safeString(transaction, "id");
        object sender = this.safeDict(transaction, "sender");
        object recipient = this.safeDict(transaction, "recipient");
        object addressTo = this.safeString(recipient, "address");
        object addressFrom = this.safeString(sender, "address");
        object txid = this.safeString(transaction, "transactionHash");
        object currencyId = this.safeString(transaction, "symbol");
        object code = this.safeCurrencyCode(currencyId, currency);
        object timestamp = this.parse8601(this.safeString(transaction, "createdAt"));
        object amount = this.safeNumber(transaction, "size");
        return new Dictionary<string, object>() {
            { "info", transaction },
            { "id", id },
            { "txid", txid },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "network", null },
            { "address", addressTo },
            { "addressTo", addressTo },
            { "addressFrom", addressFrom },
            { "tag", null },
            { "tagTo", null },
            { "tagFrom", null },
            { "type", this.safeStringLower(transaction, "type") },
            { "amount", amount },
            { "currency", code },
            { "status", null },
            { "updated", null },
            { "internal", null },
            { "comment", null },
            { "fee", null },
        };
    }

    /**
     * @method
     * @name dydx#withdraw
     * @description make a withdrawal
     * @param {string} code unified currency code
     * @param {float} amount the amount to withdraw
     * @param {string} address the address to withdraw to
     * @param {string} tag
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/?id=transaction-structure}
     */
    public async override Task<object> withdraw(object code, object amount, object address, object tag = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (isTrue(!isEqual(code, "USDC")))
        {
            throw new NotSupported ((string)add(this.id, " withdraw() only support USDC")) ;
        }
        await this.loadMarkets();
        this.checkAddress(address);
        object subaccountId = this.safeInteger(parameters, "subaccountId");
        if (isTrue(isEqual(subaccountId, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " withdraw requires subaccountId.")) ;
        }
        parameters = this.omit(parameters, new List<object>() {"subaccountId"});
        object currency = this.currency(code);
        object credentials = this.retrieveCredentials();
        object account = await this.fetchDydxAccount();
        object usd = this.parseToInt(Precise.stringMul(this.numberToString(amount), "1000000"));
        object payload = new Dictionary<string, object>() {
            { "sender", new Dictionary<string, object>() {
                { "owner", this.getWalletAddress() },
                { "number", subaccountId },
            } },
            { "recipient", address },
            { "assetId", 0 },
            { "quantums", usd },
        };
        object signingPayload = new Dictionary<string, object>() {
            { "typeUrl", "/dydxprotocol.sending.MsgWithdrawFromSubaccount" },
            { "value", payload },
        };
        object txFee = await this.estimateTxFee(signingPayload, tag, account);
        object chainName = getValue(this.options, "chainName");
        object signedTx = this.signDydxTx(getValue(credentials, "privateKey"), signingPayload, tag, chainName, account, null, txFee);
        object request = new Dictionary<string, object>() {
            { "tx", signedTx },
        };
        // nodeRpcGetBroadcastTxAsync
        object response = await this.nodeRpcGetBroadcastTxSync(request);
        //
        // {
        //     "jsonrpc": "2.0",
        //     "id": -1,
        //     "result": {
        //         "code": 0,
        //         "data": "",
        //         "log": "[]",
        //         "codespace": "",
        //         "hash": "CBEDB0603E57E5CE21FA6954770A9403D2A81BED02E608C860356152D0AA1A81"
        //     }
        // }
        //
        object data = this.safeDict(response, "result", new Dictionary<string, object>() {});
        return this.parseTransaction(data, currency);
    }

    /**
     * @method
     * @name dydx#fetchWithdrawals
     * @description fetch all withdrawals made from an account
     * @see https://docs.dydx.xyz/indexer-client/http#get-transfers
     * @param {string} code unified currency code
     * @param {int} [since] the earliest time in ms to fetch withdrawals for
     * @param {int} [limit] the maximum number of withdrawals structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.address] wallet address that made trades
     * @param {string} [params.subAccountNumber] sub account number
     * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/?id=transaction-structure}
     */
    public async override Task<object> fetchWithdrawals(object code = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = null;
        if (isTrue(!isEqual(code, null)))
        {
            currency = this.currency(code);
        }
        object response = await this.fetchTransactionsHelper(code, since, limit, this.extend(parameters, new Dictionary<string, object>() {
            { "methodName", "fetchWithdrawals" },
        }));
        object rows = this.filterBy(response, "type", "WITHDRAWAL");
        return this.parseTransactions(rows, currency, since, limit);
    }

    /**
     * @method
     * @name dydx#fetchDeposits
     * @description fetch all deposits made to an account
     * @see https://docs.dydx.xyz/indexer-client/http#get-transfers
     * @param {string} code unified currency code
     * @param {int} [since] the earliest time in ms to fetch deposits for
     * @param {int} [limit] the maximum number of deposits structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.address] wallet address that made trades
     * @param {string} [params.subAccountNumber] sub account number
     * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/?id=transaction-structure}
     */
    public async override Task<object> fetchDeposits(object code = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = null;
        if (isTrue(!isEqual(code, null)))
        {
            currency = this.currency(code);
        }
        object response = await this.fetchTransactionsHelper(code, since, limit, this.extend(parameters, new Dictionary<string, object>() {
            { "methodName", "fetchDeposits" },
        }));
        object rows = this.filterBy(response, "type", "DEPOSIT");
        return this.parseTransactions(rows, currency, since, limit);
    }

    /**
     * @method
     * @name dydx#fetchDepositsWithdrawals
     * @description fetch history of deposits and withdrawals
     * @see https://docs.dydx.xyz/indexer-client/http#get-transfers
     * @param {string} [code] unified currency code for the currency of the deposit/withdrawals, default is undefined
     * @param {int} [since] timestamp in ms of the earliest deposit/withdrawal, default is undefined
     * @param {int} [limit] max number of deposit/withdrawals to return, default is undefined
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.address] wallet address that made trades
     * @param {string} [params.subAccountNumber] sub account number
     * @returns {object} a list of [transaction structure]{@link https://docs.ccxt.com/?id=transaction-structure}
     */
    public async override Task<object> fetchDepositsWithdrawals(object code = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = null;
        if (isTrue(!isEqual(code, null)))
        {
            currency = this.currency(code);
        }
        object response = await this.fetchTransactionsHelper(code, since, limit, this.extend(parameters, new Dictionary<string, object>() {
            { "methodName", "fetchDepositsWithdrawals" },
        }));
        object withdrawals = this.filterBy(response, "type", "WITHDRAWAL");
        object deposits = this.filterBy(response, "type", "DEPOSIT");
        object rows = this.arrayConcat(withdrawals, deposits);
        return this.parseTransactions(rows, currency, since, limit);
    }

    public async virtual Task<object> fetchTransactionsHelper(object code = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object methodName = this.safeString(parameters, "methodName");
        parameters = this.omit(parameters, "methodName");
        object userAddress = null;
        object subAccountNumber = null;
        var userAddressparametersVariable = this.handlePublicAddress(methodName, parameters);
        userAddress = ((IList<object>)userAddressparametersVariable)[0];
        parameters = ((IList<object>)userAddressparametersVariable)[1];
        var subAccountNumberparametersVariable = this.handleOptionAndParams(parameters, methodName, "subAccountNumber", "0");
        subAccountNumber = ((IList<object>)subAccountNumberparametersVariable)[0];
        parameters = ((IList<object>)subAccountNumberparametersVariable)[1];
        object request = new Dictionary<string, object>() {
            { "address", userAddress },
            { "subaccountNumber", subAccountNumber },
        };
        object response = await this.indexerGetTransfers(this.extend(request, parameters));
        //
        // {
        //     "transfers": [
        //         {
        //             "id": "6a6075bc-7183-5fd9-bc9d-894e238aa527",
        //             "sender": {
        //                 "address": "dydx14zzueazeh0hj67cghhf9jypslcf9sh2n5k6art",
        //                 "subaccountNumber": 0
        //             },
        //             "recipient": {
        //                 "address": "dydx1slanxj8x9ntk9knwa6cvfv2tzlsq5gk3dshml0",
        //                 "subaccountNumber": 1
        //             },
        //             "size": "0.000001",
        //             "createdAt": "2025-07-29T09:43:02.105Z",
        //             "createdAtHeight": "45116125",
        //             "symbol": "USDC",
        //             "type": "TRANSFER_OUT",
        //             "transactionHash": "92B4744BA1B783CF37C79A50BEBC47FFD59C8D5197D62A8485D3DCCE9AF220AF"
        //         }
        //     ]
        // }
        //
        return this.safeList(response, "transfers", new List<object>() {});
    }

    /**
     * @method
     * @name dydx#fetchAccounts
     * @description fetch all the accounts associated with a profile
     * @see https://docs.dydx.xyz/indexer-client/http#get-subaccounts
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.address] wallet address that made trades
     * @returns {object} a dictionary of [account structures]{@link https://docs.ccxt.com/?id=account-structure} indexed by the account type
     */
    public async override Task<object> fetchAccounts(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object userAddress = null;
        var userAddressparametersVariable = this.handlePublicAddress("fetchAccounts", parameters);
        userAddress = ((IList<object>)userAddressparametersVariable)[0];
        parameters = ((IList<object>)userAddressparametersVariable)[1];
        object request = new Dictionary<string, object>() {
            { "address", userAddress },
        };
        object response = await this.indexerGetAddressesAddress(this.extend(request, parameters));
        //
        // {
        //     "subaccounts": [
        //         {
        //             "address": "dydx14zzueazeh0hj67cghhf9jypslcf9sh2n5k6art",
        //             "subaccountNumber": 0,
        //             "equity": "25346.73993597",
        //             "freeCollateral": "24207.8530595294",
        //             "openPerpetualPositions": {
        //                 "BTC-USD": {
        //                     "market": "BTC-USD",
        //                     "status": "OPEN",
        //                     "side": "SHORT",
        //                     "size": "-0.491",
        //                     "maxSize": "-0.009",
        //                     "entryPrice": "118703.60811320754716981132",
        //                     "exitPrice": "119655.95",
        //                     "realizedPnl": "3075.17994830188679245283016",
        //                     "unrealizedPnl": "1339.12776155490566037735812",
        //                     "createdAt": "2025-07-14T07:53:55.631Z",
        //                     "createdAtHeight": "44140908",
        //                     "closedAt": null,
        //                     "sumOpen": "0.53",
        //                     "sumClose": "0.038",
        //                     "netFunding": "3111.36894",
        //                     "subaccountNumber": 0
        //                 }
        //             },
        //             "assetPositions": {
        //                 "USDC": {
        //                     "size": "82291.083758",
        //                     "symbol": "USDC",
        //                     "side": "LONG",
        //                     "assetId": "0",
        //                     "subaccountNumber": 0
        //                 }
        //             },
        //             "marginEnabled": true,
        //             "updatedAtHeight": "45234659",
        //             "latestProcessedBlockHeight": "45293477"
        //         }
        //     ]
        // }
        //
        object rows = this.safeList(response, "subaccounts", new List<object>() {});
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(rows)); postFixIncrement(ref i))
        {
            object account = getValue(rows, i);
            object accountId = this.safeString(account, "subaccountNumber");
            ((IList<object>)result).Add(new Dictionary<string, object>() {
                { "id", accountId },
                { "type", null },
                { "currency", null },
                { "info", account },
                { "code", null },
            });
        }
        return result;
    }

    /**
     * @method
     * @name dydx#fetchBalance
     * @description query for balance and get the amount of funds available for trading or funds locked in orders
     * @see https://docs.dydx.xyz/indexer-client/http#get-subaccount
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [balance structure]{@link https://docs.ccxt.com/?id=balance-structure}
     */
    public async override Task<object> fetchBalance(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object userAddress = null;
        var userAddressparametersVariable = this.handlePublicAddress("fetchAccounts", parameters);
        userAddress = ((IList<object>)userAddressparametersVariable)[0];
        parameters = ((IList<object>)userAddressparametersVariable)[1];
        object subaccountNumber = null;
        var subaccountNumberparametersVariable = this.handleOptionAndParams(parameters, "fetchAccounts", "subaccountNumber", 0);
        subaccountNumber = ((IList<object>)subaccountNumberparametersVariable)[0];
        parameters = ((IList<object>)subaccountNumberparametersVariable)[1];
        object request = new Dictionary<string, object>() {
            { "address", userAddress },
            { "subaccountNumber", subaccountNumber },
        };
        object response = await this.indexerGetAddressesAddressSubaccountNumberSubaccountNumber(this.extend(request, parameters));
        //
        // {
        //     "subaccount": {
        //         "address": "dydx14zzueazeh0hj67cghhf9jypslcf9sh2n5k6art",
        //         "subaccountNumber": 0,
        //         "equity": "161451.040416029",
        //         "freeCollateral": "152508.28819133578",
        //         "openPerpetualPositions": {
        //             "ETH-USD": {
        //                 "market": "ETH-USD",
        //                 "status": "OPEN",
        //                 "side": "LONG",
        //                 "size": "0.001",
        //                 "maxSize": "0.002",
        //                 "entryPrice": "3894.7",
        //                 "exitPrice": "3864.5",
        //                 "realizedPnl": "-0.034847",
        //                 "unrealizedPnl": "-0.044675155",
        //                 "createdAt": "2025-10-22T08:34:05.883Z",
        //                 "createdAtHeight": "52228825",
        //                 "closedAt": null,
        //                 "sumOpen": "0.002",
        //                 "sumClose": "0.001",
        //                 "netFunding": "-0.004647",
        //                 "subaccountNumber": 0
        //             },
        //             "BTC-USD": {
        //                 "market": "BTC-USD",
        //                 "status": "OPEN",
        //                 "side": "SHORT",
        //                 "size": "-4.1368",
        //                 "maxSize": "-0.009",
        //                 "entryPrice": "112196.87848803433219017636",
        //                 "exitPrice": "113885.21872652924977050823",
        //                 "realizedPnl": "-15180.426770788459736511679821",
        //                 "unrealizedPnl": "17002.285719484425404321566048",
        //                 "createdAt": "2025-07-14T07:53:55.631Z",
        //                 "createdAtHeight": "44140908",
        //                 "closedAt": null,
        //                 "sumOpen": "5.3361",
        //                 "sumClose": "1.1983",
        //                 "netFunding": "-13157.288663",
        //                 "subaccountNumber": 0
        //             }
        //         },
        //         "assetPositions": {
        //             "USDC": {
        //                 "size": "608580.951601",
        //                 "symbol": "USDC",
        //                 "side": "LONG",
        //                 "assetId": "0",
        //                 "subaccountNumber": 0
        //             }
        //         },
        //         "marginEnabled": true,
        //         "updatedAtHeight": "52228833",
        //         "latestProcessedBlockHeight": "52246761"
        //     }
        // }
        //
        object data = this.safeDict(response, "subaccount");
        return this.parseBalance(data);
    }

    public override object parseBalance(object response)
    {
        object account = this.account();
        ((IDictionary<string,object>)account)["free"] = this.safeString(response, "freeCollateral");
        object result = new Dictionary<string, object>() {
            { "info", response },
            { "USDC", account },
        };
        return this.safeBalance(result);
    }

    public override object nonce()
    {
        return subtract(this.milliseconds(), getValue(this.options, "timeDifference"));
    }

    public virtual object getWalletAddress()
    {
        if (isTrue(isTrue(!isEqual(this.walletAddress, null)) && isTrue(!isEqual(this.walletAddress, ""))))
        {
            return this.walletAddress;
        }
        object dydxAccount = this.safeDict(this.options, "dydxAccount");
        if (isTrue(!isEqual(dydxAccount, null)))
        {
            // return dydxAccount;
            object wallet = this.safeString(dydxAccount, "address");
            if (isTrue(!isEqual(wallet, null)))
            {
                return wallet;
            }
        }
        throw new ArgumentsRequired ((string)add(this.id, " getWalletAddress() requires a wallet address. Set `walletAddress` or `dydxAccount` in exchange options.")) ;
    }

    public override object sign(object path, object section = null, object method = null, object parameters = null, object headers = null, object body = null)
    {
        section ??= "public";
        method ??= "GET";
        parameters ??= new Dictionary<string, object>();
        object pathWithParams = this.implodeParams(path, parameters);
        object url = this.implodeHostname(getValue(getValue(this.urls, "api"), section));
        parameters = this.omit(parameters, this.extractParams(path));
        parameters = this.keysort(parameters);
        url = add(url, add("/", pathWithParams));
        if (isTrue(isEqual(method, "GET")))
        {
            if (isTrue(getArrayLength(new List<object>(((IDictionary<string,object>)parameters).Keys))))
            {
                url = add(url, add("?", this.urlencode(parameters)));
            }
        } else
        {
            body = this.json(parameters);
            headers = new Dictionary<string, object>() {
                { "Content-type", "application/json" },
            };
        }
        return new Dictionary<string, object>() {
            { "url", url },
            { "method", method },
            { "body", body },
            { "headers", headers },
        };
    }

    public override object handleErrors(object httpCode, object reason, object url, object method, object headers, object body, object response, object requestHeaders, object requestBody)
    {
        if (!isTrue(response))
        {
            return null;  // fallback to default error handler
        }
        //
        // abci response
        // { "result": { "code": 0 } }
        //
        // rest response
        // { "code": 123 }
        //
        object result = this.safeDict(response, "result");
        object errorCode = this.safeString(result, "code");
        if (!isTrue(errorCode))
        {
            errorCode = this.safeString(response, "code");
        }
        if (isTrue(errorCode))
        {
            object errorCodeNum = this.parseToNumeric(errorCode);
            if (isTrue(isGreaterThan(errorCodeNum, 0)))
            {
                object feedback = add(add(this.id, " "), this.json(response));
                this.throwExactlyMatchedException(getValue(this.exceptions, "exact"), errorCode, feedback);
                this.throwBroadlyMatchedException(getValue(this.exceptions, "broad"), body, feedback);
                throw new ExchangeError ((string)feedback) ;
            }
        }
        return null;
    }

    public override void setSandboxMode(object enable)
    {
        base.setSandboxMode(enable);
        // rewrite testnet parameters
        ((IDictionary<string,object>)this.options)["chainName"] = "dydx-testnet-4";
        ((IDictionary<string,object>)this.options)["chainId"] = 11155111;
        ((IDictionary<string,object>)getValue(this.options, "feeDenom"))["CHAINTOKEN_DENOM"] = "adv4tnt";
    }
}
