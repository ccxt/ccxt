namespace ccxt;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

public partial class bingx : Exchange
{
    public override object describe()
    {
        return this.deepExtend(base.describe(), new Dictionary<string, object>() {
            { "id", "bingx" },
            { "name", "BingX" },
            { "countries", new List<object>() {"US"} },
            { "rateLimit", 100 },
            { "version", "v1" },
            { "certified", true },
            { "pro", true },
            { "has", new Dictionary<string, object>() {
                { "CORS", null },
                { "spot", true },
                { "margin", false },
                { "swap", true },
                { "future", false },
                { "option", false },
                { "addMargin", true },
                { "cancelAllOrders", true },
                { "cancelAllOrdersAfter", true },
                { "cancelOrder", true },
                { "cancelOrders", true },
                { "closeAllPositions", true },
                { "closePosition", true },
                { "createMarketBuyOrderWithCost", true },
                { "createMarketOrderWithCost", true },
                { "createMarketSellOrderWithCost", true },
                { "createOrder", true },
                { "createOrders", true },
                { "createOrderWithTakeProfitAndStopLoss", true },
                { "createStopLossOrder", true },
                { "createTakeProfitOrder", true },
                { "createTrailingAmountOrder", true },
                { "createTrailingPercentOrder", true },
                { "createTriggerOrder", true },
                { "fetchBalance", true },
                { "fetchCanceledOrders", true },
                { "fetchClosedOrders", true },
                { "fetchCurrencies", true },
                { "fetchDepositAddress", true },
                { "fetchDepositAddresses", false },
                { "fetchDepositAddressesByNetwork", true },
                { "fetchDeposits", true },
                { "fetchDepositWithdrawFee", "emulated" },
                { "fetchDepositWithdrawFees", true },
                { "fetchFundingRate", true },
                { "fetchFundingRateHistory", true },
                { "fetchFundingRates", true },
                { "fetchLeverage", true },
                { "fetchLiquidations", false },
                { "fetchMarginAdjustmentHistory", false },
                { "fetchMarginMode", true },
                { "fetchMarkets", true },
                { "fetchMarkOHLCV", true },
                { "fetchMarkPrice", true },
                { "fetchMarkPrices", true },
                { "fetchMyLiquidations", true },
                { "fetchOHLCV", true },
                { "fetchOpenInterest", true },
                { "fetchOpenOrders", true },
                { "fetchOrder", true },
                { "fetchOrderBook", true },
                { "fetchOrders", true },
                { "fetchPosition", true },
                { "fetchPositionHistory", false },
                { "fetchPositionMode", true },
                { "fetchPositions", true },
                { "fetchPositionsHistory", false },
                { "fetchTicker", true },
                { "fetchTickers", true },
                { "fetchTime", true },
                { "fetchTrades", true },
                { "fetchTradingFee", true },
                { "fetchTransfers", true },
                { "fetchWithdrawals", true },
                { "reduceMargin", true },
                { "sandbox", true },
                { "setLeverage", true },
                { "setMargin", true },
                { "setMarginMode", true },
                { "setPositionMode", true },
                { "transfer", true },
            } },
            { "hostname", "bingx.com" },
            { "urls", new Dictionary<string, object>() {
                { "logo", "https://github-production-user-asset-6210df.s3.amazonaws.com/1294454/253675376-6983b72e-4999-4549-b177-33b374c195e3.jpg" },
                { "api", new Dictionary<string, object>() {
                    { "spot", "https://open-api.{hostname}/openApi" },
                    { "swap", "https://open-api.{hostname}/openApi" },
                    { "contract", "https://open-api.{hostname}/openApi" },
                    { "wallets", "https://open-api.{hostname}/openApi" },
                    { "user", "https://open-api.{hostname}/openApi" },
                    { "subAccount", "https://open-api.{hostname}/openApi" },
                    { "account", "https://open-api.{hostname}/openApi" },
                    { "copyTrading", "https://open-api.{hostname}/openApi" },
                    { "cswap", "https://open-api.{hostname}/openApi" },
                } },
                { "test", new Dictionary<string, object>() {
                    { "swap", "https://open-api-vst.{hostname}/openApi" },
                } },
                { "www", "https://bingx.com/" },
                { "doc", "https://bingx-api.github.io/docs/" },
                { "referral", "https://bingx.com/invite/OHETOM" },
            } },
            { "fees", new Dictionary<string, object>() {
                { "tierBased", true },
                { "spot", new Dictionary<string, object>() {
                    { "feeSide", "get" },
                    { "maker", this.parseNumber("0.001") },
                    { "taker", this.parseNumber("0.001") },
                } },
                { "swap", new Dictionary<string, object>() {
                    { "feeSide", "quote" },
                    { "maker", this.parseNumber("0.0002") },
                    { "taker", this.parseNumber("0.0005") },
                } },
            } },
            { "requiredCredentials", new Dictionary<string, object>() {
                { "apiKey", true },
                { "secret", true },
            } },
            { "api", new Dictionary<string, object>() {
                { "spot", new Dictionary<string, object>() {
                    { "v1", new Dictionary<string, object>() {
                        { "public", new Dictionary<string, object>() {
                            { "get", new Dictionary<string, object>() {
                                { "server/time", 1 },
                                { "common/symbols", 1 },
                                { "market/trades", 1 },
                                { "market/depth", 1 },
                                { "market/kline", 1 },
                                { "ticker/24hr", 1 },
                                { "ticker/price", 1 },
                                { "ticker/bookTicker", 1 },
                            } },
                        } },
                        { "private", new Dictionary<string, object>() {
                            { "get", new Dictionary<string, object>() {
                                { "trade/query", 1 },
                                { "trade/openOrders", 1 },
                                { "trade/historyOrders", 1 },
                                { "trade/myTrades", 2 },
                                { "user/commissionRate", 5 },
                                { "account/balance", 2 },
                            } },
                            { "post", new Dictionary<string, object>() {
                                { "trade/order", 2 },
                                { "trade/cancel", 2 },
                                { "trade/batchOrders", 5 },
                                { "trade/order/cancelReplace", 5 },
                                { "trade/cancelOrders", 5 },
                                { "trade/cancelOpenOrders", 5 },
                                { "trade/cancelAllAfter", 5 },
                            } },
                        } },
                    } },
                    { "v2", new Dictionary<string, object>() {
                        { "public", new Dictionary<string, object>() {
                            { "get", new Dictionary<string, object>() {
                                { "market/depth", 1 },
                                { "market/kline", 1 },
                            } },
                        } },
                    } },
                    { "v3", new Dictionary<string, object>() {
                        { "private", new Dictionary<string, object>() {
                            { "get", new Dictionary<string, object>() {
                                { "get/asset/transfer", 1 },
                                { "asset/transfer", 1 },
                                { "capital/deposit/hisrec", 1 },
                                { "capital/withdraw/history", 1 },
                            } },
                            { "post", new Dictionary<string, object>() {
                                { "post/asset/transfer", 5 },
                            } },
                        } },
                    } },
                } },
                { "swap", new Dictionary<string, object>() {
                    { "v1", new Dictionary<string, object>() {
                        { "public", new Dictionary<string, object>() {
                            { "get", new Dictionary<string, object>() {
                                { "ticker/price", 1 },
                                { "market/historicalTrades", 1 },
                            } },
                        } },
                        { "private", new Dictionary<string, object>() {
                            { "get", new Dictionary<string, object>() {
                                { "positionSide/dual", 5 },
                                { "market/markPriceKlines", 1 },
                                { "trade/batchCancelReplace", 5 },
                                { "trade/fullOrder", 2 },
                                { "positionMargin/history", 2 },
                            } },
                            { "post", new Dictionary<string, object>() {
                                { "trade/cancelReplace", 2 },
                                { "positionSide/dual", 5 },
                                { "trade/closePosition", 2 },
                            } },
                        } },
                    } },
                    { "v2", new Dictionary<string, object>() {
                        { "public", new Dictionary<string, object>() {
                            { "get", new Dictionary<string, object>() {
                                { "server/time", 1 },
                                { "quote/contracts", 1 },
                                { "quote/price", 1 },
                                { "quote/depth", 1 },
                                { "quote/trades", 1 },
                                { "quote/premiumIndex", 1 },
                                { "quote/fundingRate", 1 },
                                { "quote/klines", 1 },
                                { "quote/openInterest", 1 },
                                { "quote/ticker", 1 },
                                { "quote/bookTicker", 1 },
                            } },
                        } },
                        { "private", new Dictionary<string, object>() {
                            { "get", new Dictionary<string, object>() {
                                { "user/balance", 2 },
                                { "user/positions", 2 },
                                { "user/income", 2 },
                                { "trade/openOrders", 2 },
                                { "trade/openOrder", 2 },
                                { "trade/order", 2 },
                                { "trade/marginType", 5 },
                                { "trade/leverage", 2 },
                                { "trade/forceOrders", 1 },
                                { "trade/allOrders", 2 },
                                { "trade/allFillOrders", 2 },
                                { "user/income/export", 2 },
                                { "user/commissionRate", 2 },
                                { "quote/bookTicker", 1 },
                            } },
                            { "post", new Dictionary<string, object>() {
                                { "trade/order", 2 },
                                { "trade/batchOrders", 2 },
                                { "trade/closeAllPositions", 2 },
                                { "trade/cancelAllAfter", 5 },
                                { "trade/marginType", 5 },
                                { "trade/leverage", 5 },
                                { "trade/positionMargin", 5 },
                                { "trade/order/test", 2 },
                            } },
                            { "delete", new Dictionary<string, object>() {
                                { "trade/order", 2 },
                                { "trade/batchOrders", 2 },
                                { "trade/allOpenOrders", 2 },
                            } },
                        } },
                    } },
                    { "v3", new Dictionary<string, object>() {
                        { "public", new Dictionary<string, object>() {
                            { "get", new Dictionary<string, object>() {
                                { "quote/klines", 1 },
                            } },
                        } },
                    } },
                } },
                { "cswap", new Dictionary<string, object>() {
                    { "v1", new Dictionary<string, object>() {
                        { "public", new Dictionary<string, object>() {
                            { "get", new Dictionary<string, object>() {
                                { "market/contracts", 1 },
                                { "market/premiumIndex", 1 },
                                { "market/openInterest", 1 },
                                { "market/klines", 1 },
                                { "market/depth", 1 },
                                { "market/ticker", 1 },
                            } },
                        } },
                        { "private", new Dictionary<string, object>() {
                            { "get", new Dictionary<string, object>() {
                                { "trade/leverage", 2 },
                                { "trade/forceOrders", 2 },
                                { "trade/allFillOrders", 2 },
                                { "trade/openOrders", 2 },
                                { "trade/orderDetail", 2 },
                                { "trade/orderHistory", 2 },
                                { "trade/marginType", 2 },
                                { "user/commissionRate", 2 },
                                { "user/positions", 2 },
                                { "user/balance", 2 },
                            } },
                            { "post", new Dictionary<string, object>() {
                                { "trade/order", 2 },
                                { "trade/leverage", 2 },
                                { "trade/closeAllPositions", 2 },
                                { "trade/marginType", 2 },
                                { "trade/positionMargin", 2 },
                            } },
                            { "delete", new Dictionary<string, object>() {
                                { "trade/allOpenOrders", 2 },
                                { "trade/cancelOrder", 2 },
                            } },
                        } },
                    } },
                } },
                { "contract", new Dictionary<string, object>() {
                    { "v1", new Dictionary<string, object>() {
                        { "private", new Dictionary<string, object>() {
                            { "get", new Dictionary<string, object>() {
                                { "allPosition", 2 },
                                { "allOrders", 2 },
                                { "balance", 2 },
                            } },
                        } },
                    } },
                } },
                { "wallets", new Dictionary<string, object>() {
                    { "v1", new Dictionary<string, object>() {
                        { "private", new Dictionary<string, object>() {
                            { "get", new Dictionary<string, object>() {
                                { "capital/config/getall", 5 },
                                { "capital/deposit/address", 5 },
                                { "capital/innerTransfer/records", 1 },
                                { "capital/subAccount/deposit/address", 5 },
                                { "capital/deposit/subHisrec", 2 },
                                { "capital/subAccount/innerTransfer/records", 1 },
                                { "capital/deposit/riskRecords", 5 },
                            } },
                            { "post", new Dictionary<string, object>() {
                                { "capital/withdraw/apply", 5 },
                                { "capital/innerTransfer/apply", 5 },
                                { "capital/subAccountInnerTransfer/apply", 2 },
                                { "capital/deposit/createSubAddress", 2 },
                            } },
                        } },
                    } },
                } },
                { "subAccount", new Dictionary<string, object>() {
                    { "v1", new Dictionary<string, object>() {
                        { "private", new Dictionary<string, object>() {
                            { "get", new Dictionary<string, object>() {
                                { "list", 10 },
                                { "assets", 2 },
                            } },
                            { "post", new Dictionary<string, object>() {
                                { "create", 10 },
                                { "apiKey/create", 2 },
                                { "apiKey/edit", 2 },
                                { "apiKey/del", 2 },
                                { "updateStatus", 10 },
                            } },
                        } },
                    } },
                } },
                { "account", new Dictionary<string, object>() {
                    { "v1", new Dictionary<string, object>() {
                        { "private", new Dictionary<string, object>() {
                            { "get", new Dictionary<string, object>() {
                                { "uid", 1 },
                                { "apiKey/query", 2 },
                            } },
                            { "post", new Dictionary<string, object>() {
                                { "innerTransfer/authorizeSubAccount", 1 },
                            } },
                        } },
                    } },
                } },
                { "user", new Dictionary<string, object>() {
                    { "auth", new Dictionary<string, object>() {
                        { "private", new Dictionary<string, object>() {
                            { "post", new Dictionary<string, object>() {
                                { "userDataStream", 2 },
                            } },
                            { "put", new Dictionary<string, object>() {
                                { "userDataStream", 2 },
                            } },
                            { "delete", new Dictionary<string, object>() {
                                { "userDataStream", 2 },
                            } },
                        } },
                    } },
                } },
                { "copyTrading", new Dictionary<string, object>() {
                    { "v1", new Dictionary<string, object>() {
                        { "private", new Dictionary<string, object>() {
                            { "get", new Dictionary<string, object>() {
                                { "swap/trace/currentTrack", 2 },
                            } },
                            { "post", new Dictionary<string, object>() {
                                { "swap/trace/closeTrackOrder", 2 },
                                { "swap/trace/setTPSL", 2 },
                                { "spot/trader/sellOrder", 10 },
                            } },
                        } },
                    } },
                } },
                { "api", new Dictionary<string, object>() {
                    { "v3", new Dictionary<string, object>() {
                        { "private", new Dictionary<string, object>() {
                            { "get", new Dictionary<string, object>() {
                                { "asset/transfer", 1 },
                                { "capital/deposit/hisrec", 1 },
                                { "capital/withdraw/history", 1 },
                            } },
                            { "post", new Dictionary<string, object>() {
                                { "post/asset/transfer", 1 },
                            } },
                        } },
                    } },
                } },
            } },
            { "timeframes", new Dictionary<string, object>() {
                { "1m", "1m" },
                { "3m", "3m" },
                { "5m", "5m" },
                { "15m", "15m" },
                { "30m", "30m" },
                { "1h", "1h" },
                { "2h", "2h" },
                { "4h", "4h" },
                { "6h", "6h" },
                { "12h", "12h" },
                { "1d", "1d" },
                { "3d", "3d" },
                { "1w", "1w" },
                { "1M", "1M" },
            } },
            { "precisionMode", TICK_SIZE },
            { "exceptions", new Dictionary<string, object>() {
                { "exact", new Dictionary<string, object>() {
                    { "400", typeof(BadRequest) },
                    { "401", typeof(AuthenticationError) },
                    { "403", typeof(PermissionDenied) },
                    { "404", typeof(BadRequest) },
                    { "429", typeof(DDoSProtection) },
                    { "418", typeof(PermissionDenied) },
                    { "500", typeof(ExchangeError) },
                    { "504", typeof(ExchangeError) },
                    { "100001", typeof(AuthenticationError) },
                    { "100412", typeof(AuthenticationError) },
                    { "100202", typeof(InsufficientFunds) },
                    { "100204", typeof(BadRequest) },
                    { "100400", typeof(BadRequest) },
                    { "100410", typeof(OperationFailed) },
                    { "100421", typeof(BadSymbol) },
                    { "100440", typeof(ExchangeError) },
                    { "100500", typeof(OperationFailed) },
                    { "100503", typeof(ExchangeError) },
                    { "80001", typeof(BadRequest) },
                    { "80012", typeof(InsufficientFunds) },
                    { "80014", typeof(BadRequest) },
                    { "80016", typeof(OrderNotFound) },
                    { "80017", typeof(OrderNotFound) },
                    { "100414", typeof(AccountSuspended) },
                    { "100419", typeof(PermissionDenied) },
                    { "100437", typeof(BadRequest) },
                    { "101204", typeof(InsufficientFunds) },
                    { "110425", typeof(InvalidOrder) },
                } },
                { "broad", new Dictionary<string, object>() {} },
            } },
            { "commonCurrencies", new Dictionary<string, object>() {
                { "SNOW", "Snowman" },
                { "OMNI", "OmniCat" },
                { "NAP", "$NAP" },
            } },
            { "options", new Dictionary<string, object>() {
                { "defaultType", "spot" },
                { "accountsByType", new Dictionary<string, object>() {
                    { "spot", "FUND" },
                    { "swap", "PFUTURES" },
                    { "future", "SFUTURES" },
                } },
                { "accountsById", new Dictionary<string, object>() {
                    { "FUND", "spot" },
                    { "PFUTURES", "swap" },
                    { "SFUTURES", "future" },
                } },
                { "recvWindow", multiply(5, 1000) },
                { "broker", "CCXT" },
                { "defaultNetworks", new Dictionary<string, object>() {
                    { "ETH", "ETH" },
                    { "USDT", "ERC20" },
                    { "USDC", "ERC20" },
                    { "BTC", "BTC" },
                    { "LTC", "LTC" },
                } },
                { "networks", new Dictionary<string, object>() {
                    { "ARB", "ARBITRUM" },
                    { "MATIC", "POLYGON" },
                } },
            } },
        });
    }

    /**
     * @method
     * @name bingx#fetchTime
     * @description fetches the current integer timestamp in milliseconds from the bingx server
     * @see https://bingx-api.github.io/docs/#/swapV2/base-info.html#Get%20Server%20Time
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {int} the current integer timestamp in milliseconds from the bingx server
     */
    public async override Task<object> fetchTime(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object response = await this.swapV2PublicGetServerTime(parameters);
        //
        //    {
        //        "code": 0,
        //        "msg": "",
        //        "data": {
        //            "serverTime": 1675319535362
        //        }
        //    }
        //
        object data = this.safeDict(response, "data");
        return this.safeInteger(data, "serverTime");
    }

    /**
     * @method
     * @name bingx#fetchCurrencies
     * @description fetches all available currencies on an exchange
     * @see https://bingx-api.github.io/docs/#/common/account-api.html#All%20Coins
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} an associative dictionary of currencies
     */
    public async override Task<object> fetchCurrencies(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (!isTrue(this.checkRequiredCredentials(false)))
        {
            return null;
        }
        object isSandbox = this.safeBool(this.options, "sandboxMode", false);
        if (isTrue(isSandbox))
        {
            return null;
        }
        object response = await this.walletsV1PrivateGetCapitalConfigGetall(parameters);
        //
        //    {
        //      "code": 0,
        //      "timestamp": 1702623271477,
        //      "data": [
        //        {
        //          "coin": "BTC",
        //          "name": "BTC",
        //          "networkList": [
        //            {
        //              "name": "BTC",
        //              "network": "BTC",
        //              "isDefault": true,
        //              "minConfirm": 2,
        //              "withdrawEnable": true,
        //              "depositEnable": true,
        //              "withdrawFee": "0.0006",
        //              "withdrawMax": "1.17522",
        //              "withdrawMin": "0.0005",
        //              "depositMin": "0.0002"
        //            },
        //            {
        //              "name": "BTC",
        //              "network": "BEP20",
        //              "isDefault": false,
        //              "minConfirm": 15,
        //              "withdrawEnable": true,
        //              "depositEnable": true,
        //              "withdrawFee": "0.0000066",
        //              "withdrawMax": "1.17522",
        //              "withdrawMin": "0.0000066",
        //              "depositMin": "0.0002"
        //            }
        //          ]
        //        }
        //      ]
        //    }
        //
        object data = this.safeList(response, "data", new List<object>() {});
        object result = new Dictionary<string, object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
        {
            object entry = getValue(data, i);
            object currencyId = this.safeString(entry, "coin");
            object code = this.safeCurrencyCode(currencyId);
            object name = this.safeString(entry, "name");
            object networkList = this.safeList(entry, "networkList");
            object networks = new Dictionary<string, object>() {};
            object fee = null;
            object depositEnabled = false;
            object withdrawEnabled = false;
            object defaultLimits = new Dictionary<string, object>() {};
            for (object j = 0; isLessThan(j, getArrayLength(networkList)); postFixIncrement(ref j))
            {
                object rawNetwork = getValue(networkList, j);
                object network = this.safeString(rawNetwork, "network");
                object networkCode = this.networkIdToCode(network);
                object isDefault = this.safeBool(rawNetwork, "isDefault");
                object networkDepositEnabled = this.safeBool(rawNetwork, "depositEnable");
                if (isTrue(networkDepositEnabled))
                {
                    depositEnabled = true;
                }
                object networkWithdrawEnabled = this.safeBool(rawNetwork, "withdrawEnable");
                if (isTrue(networkWithdrawEnabled))
                {
                    withdrawEnabled = true;
                }
                object limits = new Dictionary<string, object>() {
                    { "withdraw", new Dictionary<string, object>() {
                        { "min", this.safeNumber(rawNetwork, "withdrawMin") },
                        { "max", this.safeNumber(rawNetwork, "withdrawMax") },
                    } },
                };
                fee = this.safeNumber(rawNetwork, "withdrawFee");
                if (isTrue(isDefault))
                {
                    defaultLimits = limits;
                }
                object precision = this.safeNumber(rawNetwork, "withdrawPrecision");
                object networkActive = isTrue(networkDepositEnabled) || isTrue(networkWithdrawEnabled);
                ((IDictionary<string,object>)networks)[(string)networkCode] = new Dictionary<string, object>() {
                    { "info", rawNetwork },
                    { "id", network },
                    { "network", networkCode },
                    { "fee", fee },
                    { "active", networkActive },
                    { "deposit", networkDepositEnabled },
                    { "withdraw", networkWithdrawEnabled },
                    { "precision", precision },
                    { "limits", limits },
                };
            }
            object active = isTrue(depositEnabled) || isTrue(withdrawEnabled);
            ((IDictionary<string,object>)result)[(string)code] = new Dictionary<string, object>() {
                { "info", entry },
                { "code", code },
                { "id", currencyId },
                { "precision", null },
                { "name", name },
                { "active", active },
                { "deposit", depositEnabled },
                { "withdraw", withdrawEnabled },
                { "networks", networks },
                { "fee", fee },
                { "limits", defaultLimits },
            };
        }
        return result;
    }

    public async virtual Task<object> fetchSpotMarkets(object parameters)
    {
        object response = await this.spotV1PublicGetCommonSymbols(parameters);
        //
        //    {
        //        "code": 0,
        //            "msg": "",
        //            "debugMsg": "",
        //            "data": {
        //              "symbols": [
        //                  {
        //                    "symbol": "GEAR-USDT",
        //                    "minQty": 735,
        //                    "maxQty": 2941177,
        //                    "minNotional": 5,
        //                    "maxNotional": 20000,
        //                    "status": 1,
        //                    "tickSize": 0.000001,
        //                    "stepSize": 1,
        //                    "apiStateSell": true,
        //                    "apiStateBuy": true,
        //                    "timeOnline": 0,
        //                    "offTime": 0,
        //                    "maintainTime": 0
        //                  },
        //                  ...
        //              ]
        //         }
        //    }
        //
        object data = this.safeDict(response, "data");
        object markets = this.safeList(data, "symbols", new List<object>() {});
        return this.parseMarkets(markets);
    }

    public async virtual Task<object> fetchSwapMarkets(object parameters)
    {
        object response = await this.swapV2PublicGetQuoteContracts(parameters);
        //
        //    {
        //        "code": 0,
        //        "msg": "",
        //        "data": [
        //            {
        //                "contractId": "100",
        //                "symbol": "BTC-USDT",
        //                "size": "0.0001",
        //                "quantityPrecision": "4",
        //                "pricePrecision": "1",
        //                "feeRate": "0.0005",
        //                "makerFeeRate": "0.0002",
        //                "takerFeeRate": "0.0005",
        //                "tradeMinLimit": "0",
        //                "tradeMinQuantity": "0.0001",
        //                "tradeMinUSDT": "2",
        //                "maxLongLeverage": "125",
        //                "maxShortLeverage": "125",
        //                "currency": "USDT",
        //                "asset": "BTC",
        //                "status": "1",
        //                "apiStateOpen": "true",
        //                "apiStateClose": "true",
        //                "ensureTrigger": true,
        //                "triggerFeeRate": "0.00020000"
        //            },
        //            ...
        //        ]
        //    }
        //
        object markets = this.safeList(response, "data", new List<object>() {});
        return this.parseMarkets(markets);
    }

    public async virtual Task<object> fetchInverseSwapMarkets(object parameters)
    {
        object response = await this.cswapV1PublicGetMarketContracts(parameters);
        //
        //     {
        //         "code": 0,
        //         "msg": "",
        //         "timestamp": 1720074487610,
        //         "data": [
        //             {
        //                 "symbol": "BNB-USD",
        //                 "pricePrecision": 2,
        //                 "minTickSize": "10",
        //                 "minTradeValue": "10",
        //                 "minQty": "1.00000000",
        //                 "status": 1,
        //                 "timeOnline": 1713175200000
        //             },
        //         ]
        //     }
        //
        object markets = this.safeList(response, "data", new List<object>() {});
        return this.parseMarkets(markets);
    }

    public override object parseMarket(object market)
    {
        object id = this.safeString(market, "symbol");
        object symbolParts = ((string)id).Split(new [] {((string)"-")}, StringSplitOptions.None).ToList<object>();
        object baseId = getValue(symbolParts, 0);
        object quoteId = getValue(symbolParts, 1);
        object bs = this.safeCurrencyCode(baseId);
        object quote = this.safeCurrencyCode(quoteId);
        object currency = this.safeString(market, "currency");
        object checkIsInverse = false;
        object checkIsLinear = true;
        object minTickSize = this.safeNumber(market, "minTickSize");
        if (isTrue(!isEqual(minTickSize, null)))
        {
            // inverse swap market
            currency = baseId;
            checkIsInverse = true;
            checkIsLinear = false;
        }
        object settle = this.safeCurrencyCode(currency);
        object pricePrecision = this.safeNumber(market, "tickSize");
        if (isTrue(isEqual(pricePrecision, null)))
        {
            pricePrecision = this.parseNumber(this.parsePrecision(this.safeString(market, "pricePrecision")));
        }
        object quantityPrecision = this.safeNumber(market, "stepSize");
        if (isTrue(isEqual(quantityPrecision, null)))
        {
            quantityPrecision = this.parseNumber(this.parsePrecision(this.safeString(market, "quantityPrecision")));
        }
        object type = ((bool) isTrue((!isEqual(settle, null)))) ? "swap" : "spot";
        object spot = isEqual(type, "spot");
        object swap = isEqual(type, "swap");
        object symbol = add(add(bs, "/"), quote);
        if (isTrue(!isEqual(settle, null)))
        {
            symbol = add(symbol, add(":", settle));
        }
        object fees = this.safeDict(this.fees, type, new Dictionary<string, object>() {});
        object contractSize = ((bool) isTrue((swap))) ? this.parseNumber("1") : null;
        object isActive = false;
        if (isTrue(isTrue((isEqual(this.safeString(market, "apiStateOpen"), "true"))) && isTrue((isEqual(this.safeString(market, "apiStateClose"), "true")))))
        {
            isActive = true; // swap active
        } else if (isTrue(isTrue(isTrue(this.safeBool(market, "apiStateSell")) && isTrue(this.safeBool(market, "apiStateBuy"))) && isTrue((isEqual(this.safeString(market, "status"), "1")))))
        {
            isActive = true; // spot active
        }
        object isInverse = ((bool) isTrue((spot))) ? null : checkIsInverse;
        object isLinear = ((bool) isTrue((spot))) ? null : checkIsLinear;
        object timeOnline = this.safeInteger(market, "timeOnline");
        if (isTrue(isEqual(timeOnline, 0)))
        {
            timeOnline = null;
        }
        return this.safeMarketStructure(new Dictionary<string, object>() {
            { "id", id },
            { "symbol", symbol },
            { "base", bs },
            { "quote", quote },
            { "settle", settle },
            { "baseId", baseId },
            { "quoteId", quoteId },
            { "settleId", currency },
            { "type", type },
            { "spot", spot },
            { "margin", false },
            { "swap", swap },
            { "future", false },
            { "option", false },
            { "active", isActive },
            { "contract", swap },
            { "linear", isLinear },
            { "inverse", isInverse },
            { "taker", this.safeNumber(fees, "taker") },
            { "maker", this.safeNumber(fees, "maker") },
            { "feeSide", this.safeString(fees, "feeSide") },
            { "contractSize", contractSize },
            { "expiry", null },
            { "expiryDatetime", null },
            { "strike", null },
            { "optionType", null },
            { "precision", new Dictionary<string, object>() {
                { "amount", quantityPrecision },
                { "price", pricePrecision },
            } },
            { "limits", new Dictionary<string, object>() {
                { "leverage", new Dictionary<string, object>() {
                    { "min", null },
                    { "max", null },
                } },
                { "amount", new Dictionary<string, object>() {
                    { "min", this.safeNumber2(market, "minQty", "tradeMinQuantity") },
                    { "max", this.safeNumber(market, "maxQty") },
                } },
                { "price", new Dictionary<string, object>() {
                    { "min", minTickSize },
                    { "max", null },
                } },
                { "cost", new Dictionary<string, object>() {
                    { "min", this.safeNumberN(market, new List<object>() {"minNotional", "tradeMinUSDT", "minTradeValue"}) },
                    { "max", this.safeNumber(market, "maxNotional") },
                } },
            } },
            { "created", timeOnline },
            { "info", market },
        });
    }

    /**
     * @method
     * @name bingx#fetchMarkets
     * @description retrieves data on all markets for bingx
     * @see https://bingx-api.github.io/docs/#/spot/market-api.html#Query%20Symbols
     * @see https://bingx-api.github.io/docs/#/swapV2/market-api.html#Contract%20Information
     * @see https://bingx-api.github.io/docs/#/en-us/cswap/market-api.html#Contract%20Information
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} an array of objects representing market data
     */
    public async override Task<object> fetchMarkets(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object requests = new List<object> {this.fetchSwapMarkets(parameters)};
        object isSandbox = this.safeBool(this.options, "sandboxMode", false);
        if (!isTrue(isSandbox))
        {
            ((IList<object>)requests).Add(this.fetchInverseSwapMarkets(parameters));
            ((IList<object>)requests).Add(this.fetchSpotMarkets(parameters)); // sandbox is swap only
        }
        object promises = await promiseAll(requests);
        object linearSwapMarkets = this.safeList(promises, 0, new List<object>() {});
        object inverseSwapMarkets = this.safeList(promises, 1, new List<object>() {});
        object spotMarkets = this.safeList(promises, 2, new List<object>() {});
        object swapMarkets = this.arrayConcat(linearSwapMarkets, inverseSwapMarkets);
        return this.arrayConcat(spotMarkets, swapMarkets);
    }

    /**
     * @method
     * @name bingx#fetchOHLCV
     * @description fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
     * @see https://bingx-api.github.io/docs/#/swapV2/market-api.html#K-Line%20Data
     * @see https://bingx-api.github.io/docs/#/spot/market-api.html#Candlestick%20chart%20data
     * @see https://bingx-api.github.io/docs/#/swapV2/market-api.html#%20K-Line%20Data
     * @see https://bingx-api.github.io/docs/#/en-us/swapV2/market-api.html#K-Line%20Data%20-%20Mark%20Price
     * @see https://bingx-api.github.io/docs/#/en-us/cswap/market-api.html#Get%20K-line%20Data
     * @param {string} symbol unified symbol of the market to fetch OHLCV data for
     * @param {string} timeframe the length of time each candle represents
     * @param {int} [since] timestamp in ms of the earliest candle to fetch
     * @param {int} [limit] the maximum amount of candles to fetch
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {int} [params.until] timestamp in ms of the latest candle to fetch
     * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [available parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
     * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
     */
    public async override Task<object> fetchOHLCV(object symbol, object timeframe = null, object since = null, object limit = null, object parameters = null)
    {
        timeframe ??= "1m";
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object paginate = false;
        var paginateparametersVariable = this.handleOptionAndParams(parameters, "fetchOHLCV", "paginate", false);
        paginate = ((IList<object>)paginateparametersVariable)[0];
        parameters = ((IList<object>)paginateparametersVariable)[1];
        if (isTrue(paginate))
        {
            return await this.fetchPaginatedCallDeterministic("fetchOHLCV", symbol, since, limit, timeframe, parameters, 1440);
        }
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        ((IDictionary<string,object>)request)["interval"] = this.safeString(this.timeframes, timeframe, timeframe);
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["startTime"] = since;
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        object until = this.safeInteger2(parameters, "until", "endTime");
        if (isTrue(!isEqual(until, null)))
        {
            parameters = this.omit(parameters, new List<object>() {"until"});
            ((IDictionary<string,object>)request)["endTime"] = until;
        }
        object response = null;
        if (isTrue(getValue(market, "spot")))
        {
            response = await this.spotV1PublicGetMarketKline(this.extend(request, parameters));
        } else
        {
            if (isTrue(getValue(market, "inverse")))
            {
                response = await this.cswapV1PublicGetMarketKlines(this.extend(request, parameters));
            } else
            {
                object price = this.safeString(parameters, "price");
                parameters = this.omit(parameters, "price");
                if (isTrue(isEqual(price, "mark")))
                {
                    response = await this.swapV1PrivateGetMarketMarkPriceKlines(this.extend(request, parameters));
                } else
                {
                    response = await this.swapV3PublicGetQuoteKlines(this.extend(request, parameters));
                }
            }
        }
        //
        //    {
        //        "code": 0,
        //        "msg": "",
        //        "data": [
        //          {
        //            "open": "19396.8",
        //            "close": "19394.4",
        //            "high": "19397.5",
        //            "low": "19385.7",
        //            "volume": "110.05",
        //            "time": 1666583700000
        //          },
        //          ...
        //        ]
        //    }
        //
        // fetchMarkOHLCV
        //
        //    {
        //        "code": 0,
        //        "msg": "",
        //        "data": [
        //            {
        //                "open": "42191.7",
        //                "close": "42189.5",
        //                "high": "42196.5",
        //                "low": "42189.5",
        //                "volume": "0.00",
        //                "openTime": 1706508840000,
        //                "closeTime": 1706508840000
        //            }
        //        ]
        //    }
        //
        object ohlcvs = this.safeValue(response, "data", new List<object>() {});
        if (!isTrue(((ohlcvs is IList<object>) || (ohlcvs.GetType().IsGenericType && ohlcvs.GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>))))))
        {
            ohlcvs = new List<object>() {ohlcvs};
        }
        return this.parseOHLCVs(ohlcvs, market, timeframe, since, limit);
    }

    public override object parseOHLCV(object ohlcv, object market = null)
    {
        //
        //    {
        //        "open": "19394.4",
        //        "close": "19379.0",
        //        "high": "19394.4",
        //        "low": "19368.3",
        //        "volume": "167.44",
        //        "time": 1666584000000
        //    }
        //
        // fetchMarkOHLCV
        //
        //    {
        //        "open": "42191.7",
        //        "close": "42189.5",
        //        "high": "42196.5",
        //        "low": "42189.5",
        //        "volume": "0.00",
        //        "openTime": 1706508840000,
        //        "closeTime": 1706508840000
        //    }
        // spot
        //    [
        //        1691402580000,
        //        29093.61,
        //        29093.93,
        //        29087.73,
        //        29093.24,
        //        0.59,
        //        1691402639999,
        //        17221.07
        //    ]
        //
        if (isTrue(((ohlcv is IList<object>) || (ohlcv.GetType().IsGenericType && ohlcv.GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>))))))
        {
            return new List<object> {this.safeInteger(ohlcv, 0), this.safeNumber(ohlcv, 1), this.safeNumber(ohlcv, 2), this.safeNumber(ohlcv, 3), this.safeNumber(ohlcv, 4), this.safeNumber(ohlcv, 5)};
        }
        return new List<object> {this.safeInteger2(ohlcv, "time", "closeTime"), this.safeNumber(ohlcv, "open"), this.safeNumber(ohlcv, "high"), this.safeNumber(ohlcv, "low"), this.safeNumber(ohlcv, "close"), this.safeNumber(ohlcv, "volume")};
    }

    /**
     * @method
     * @name bingx#fetchTrades
     * @description get the list of most recent trades for a particular symbol
     * @see https://bingx-api.github.io/docs/#/spot/market-api.html#Query%20transaction%20records
     * @see https://bingx-api.github.io/docs/#/swapV2/market-api.html#The%20latest%20Trade%20of%20a%20Trading%20Pair
     * @param {string} symbol unified symbol of the market to fetch trades for
     * @param {int} [since] timestamp in ms of the earliest trade to fetch
     * @param {int} [limit] the maximum amount of trades to fetch
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
     */
    public async override Task<object> fetchTrades(object symbol, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = mathMin(limit, 100); // avoid API exception "limit should less than 100"
        }
        object response = null;
        object marketType = null;
        var marketTypeparametersVariable = this.handleMarketTypeAndParams("fetchTrades", market, parameters);
        marketType = ((IList<object>)marketTypeparametersVariable)[0];
        parameters = ((IList<object>)marketTypeparametersVariable)[1];
        if (isTrue(isEqual(marketType, "spot")))
        {
            response = await this.spotV1PublicGetMarketTrades(this.extend(request, parameters));
        } else
        {
            response = await this.swapV2PublicGetQuoteTrades(this.extend(request, parameters));
        }
        //
        // spot
        //
        //    {
        //        "code": 0,
        //        "data": [
        //            {
        //                "id": 43148253,
        //                "price": 25714.71,
        //                "qty": 1.674571,
        //                "time": 1655085975589,
        //                "buyerMaker": false
        //            }
        //        ]
        //    }
        //
        // swap
        //
        //    {
        //      "code":0,
        //      "msg":"",
        //      "data":[
        //        {
        //          "time": 1672025549368,
        //          "isBuyerMaker": true,
        //          "price": "16885.0",
        //          "qty": "3.3002",
        //          "quoteQty": "55723.87"
        //        },
        //        ...
        //      ]
        //    }
        //
        object trades = this.safeList(response, "data", new List<object>() {});
        return this.parseTrades(trades, market, since, limit);
    }

    public override object parseTrade(object trade, object market = null)
    {
        //
        // spot fetchTrades
        //
        //    {
        //        "id": 43148253,
        //        "price": 25714.71,
        //        "qty": 1.674571,
        //        "time": 1655085975589,
        //        "buyerMaker": false
        //    }
        //
        // spot fetchMyTrades
        //
        //     {
        //         "symbol": "LTC-USDT",
        //         "id": 36237072,
        //         "orderId": 1674069326895775744,
        //         "price": "85.891",
        //         "qty": "0.0582",
        //         "quoteQty": "4.9988562000000005",
        //         "commission": -0.00005820000000000001,
        //         "commissionAsset": "LTC",
        //         "time": 1687964205000,
        //         "isBuyer": true,
        //         "isMaker": false
        //     }
        //
        // swap fetchTrades
        //
        //    {
        //        "time": 1672025549368,
        //        "isBuyerMaker": true,
        //        "price": "16885.0",
        //        "qty": "3.3002",
        //        "quoteQty": "55723.87"
        //    }
        //
        // swap fetchMyTrades
        //
        //    {
        //        "volume": "0.1",
        //        "price": "106.75",
        //        "amount": "10.6750",
        //        "commission": "-0.0053",
        //        "currency": "USDT",
        //        "orderId": "1676213270274379776",
        //        "liquidatedPrice": "0.00",
        //        "liquidatedMarginRatio": "0.00",
        //        "filledTime": "2023-07-04T20:56:01.000+0800"
        //    }
        //
        // ws spot
        //
        //    {
        //        "E": 1690214529432,
        //        "T": 1690214529386,
        //        "e": "trade",
        //        "m": true,
        //        "p": "29110.19",
        //        "q": "0.1868",
        //        "s": "BTC-USDT",
        //        "t": "57903921"
        //    }
        //
        // ws linear swap
        //
        //    {
        //        "q": "0.0421",
        //        "p": "29023.5",
        //        "T": 1690221401344,
        //        "m": false,
        //        "s": "BTC-USDT"
        //    }
        //
        // ws inverse swap
        //
        //     {
        //         "e": "trade",
        //         "E": 1722920589665,
        //         "s": "BTC-USD",
        //         "t": "39125001",
        //         "p": "55360.0",
        //         "q": "1",
        //         "T": 1722920589582,
        //         "m": false
        //     }
        //
        // inverse swap fetchMyTrades
        //
        //     {
        //         "orderId": "1817441228670648320",
        //         "symbol": "SOL-USD",
        //         "type": "MARKET",
        //         "side": "BUY",
        //         "positionSide": "LONG",
        //         "tradeId": "97244554",
        //         "volume": "2",
        //         "tradePrice": "182.652",
        //         "amount": "20.00000000",
        //         "realizedPnl": "0.00000000",
        //         "commission": "-0.00005475",
        //         "currency": "SOL",
        //         "buyer": true,
        //         "maker": false,
        //         "tradeTime": 1722146730000
        //     }
        //
        object time = this.safeIntegerN(trade, new List<object>() {"time", "filledTm", "T", "tradeTime"});
        object datetimeId = this.safeString(trade, "filledTm");
        if (isTrue(!isEqual(datetimeId, null)))
        {
            time = this.parse8601(datetimeId);
        }
        if (isTrue(isEqual(time, 0)))
        {
            time = null;
        }
        object cost = this.safeString(trade, "quoteQty");
        // const type = (cost === undefined) ? 'spot' : 'swap'; this is not reliable
        object currencyId = this.safeStringN(trade, new List<object>() {"currency", "N", "commissionAsset"});
        object currencyCode = this.safeCurrencyCode(currencyId);
        object m = this.safeBool(trade, "m");
        object marketId = this.safeString2(trade, "s", "symbol");
        object isBuyerMaker = this.safeBoolN(trade, new List<object>() {"buyerMaker", "isBuyerMaker", "maker"});
        object takeOrMaker = null;
        if (isTrue(isTrue((!isEqual(isBuyerMaker, null))) || isTrue((!isEqual(m, null)))))
        {
            takeOrMaker = ((bool) isTrue((isTrue(isBuyerMaker) || isTrue(m)))) ? "maker" : "taker";
        }
        object side = this.safeStringLower2(trade, "side", "S");
        if (isTrue(isEqual(side, null)))
        {
            if (isTrue(isTrue((!isEqual(isBuyerMaker, null))) || isTrue((!isEqual(m, null)))))
            {
                side = ((bool) isTrue((isTrue(isBuyerMaker) || isTrue(m)))) ? "sell" : "buy";
                takeOrMaker = "taker";
            }
        }
        object isBuyer = this.safeBool(trade, "isBuyer");
        if (isTrue(!isEqual(isBuyer, null)))
        {
            side = ((bool) isTrue(isBuyer)) ? "buy" : "sell";
        }
        object isMaker = this.safeBool(trade, "isMaker");
        if (isTrue(!isEqual(isMaker, null)))
        {
            takeOrMaker = ((bool) isTrue(isMaker)) ? "maker" : "taker";
        }
        object amount = this.safeStringN(trade, new List<object>() {"qty", "amount", "q"});
        if (isTrue(isTrue(isTrue((!isEqual(market, null))) && isTrue(getValue(market, "swap"))) && isTrue((inOp(trade, "volume")))))
        {
            // private trade returns num of contracts instead of base currency (as the order-related methods do)
            object contractSize = this.safeString(getValue(market, "info"), "tradeMinQuantity");
            object volume = this.safeString(trade, "volume");
            amount = Precise.stringMul(volume, contractSize);
        }
        return this.safeTrade(new Dictionary<string, object>() {
            { "id", this.safeStringN(trade, new List<object>() {"id", "t"}) },
            { "info", trade },
            { "timestamp", time },
            { "datetime", this.iso8601(time) },
            { "symbol", this.safeSymbol(marketId, market, "-") },
            { "order", this.safeString2(trade, "orderId", "i") },
            { "type", this.safeStringLower(trade, "o") },
            { "side", this.parseOrderSide(side) },
            { "takerOrMaker", takeOrMaker },
            { "price", this.safeStringN(trade, new List<object>() {"price", "p", "tradePrice"}) },
            { "amount", amount },
            { "cost", cost },
            { "fee", new Dictionary<string, object>() {
                { "cost", this.parseNumber(Precise.stringAbs(this.safeString2(trade, "commission", "n"))) },
                { "currency", currencyCode },
            } },
        }, market);
    }

    /**
     * @method
     * @name bingx#fetchOrderBook
     * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
     * @see https://bingx-api.github.io/docs/#/spot/market-api.html#Query%20depth%20information
     * @see https://bingx-api.github.io/docs/#/swapV2/market-api.html#Get%20Market%20Depth
     * @see https://bingx-api.github.io/docs/#/en-us/cswap/market-api.html#Query%20Depth%20Data
     * @param {string} symbol unified symbol of the market to fetch the order book for
     * @param {int} [limit] the maximum amount of order book entries to return
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
     */
    public async override Task<object> fetchOrderBook(object symbol, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        object response = null;
        object marketType = null;
        var marketTypeparametersVariable = this.handleMarketTypeAndParams("fetchOrderBook", market, parameters);
        marketType = ((IList<object>)marketTypeparametersVariable)[0];
        parameters = ((IList<object>)marketTypeparametersVariable)[1];
        if (isTrue(isEqual(marketType, "spot")))
        {
            response = await this.spotV1PublicGetMarketDepth(this.extend(request, parameters));
        } else
        {
            if (isTrue(getValue(market, "inverse")))
            {
                response = await this.cswapV1PublicGetMarketDepth(this.extend(request, parameters));
            } else
            {
                response = await this.swapV2PublicGetQuoteDepth(this.extend(request, parameters));
            }
        }
        //
        // spot
        //
        //     {
        //         "code": 0,
        //         "data": {
        //           "bids": [
        //             [
        //               "26324.73",
        //               "0.37655"
        //             ],
        //             [
        //               "26324.71",
        //               "0.31888"
        //             ],
        //         ],
        //         "asks": [
        //             [
        //               "26340.30",
        //               "6.45221"
        //             ],
        //             [
        //               "26340.15",
        //               "6.73261"
        //             ],
        //         ]}
        //     }
        //
        // swap
        //
        //     {
        //         "code": 0,
        //         "msg": "",
        //         "data": {
        //           "T": 1683914263304,
        //           "bids": [
        //             [
        //               "26300.90000000",
        //               "30408.00000000"
        //             ],
        //             [
        //               "26300.80000000",
        //               "50906.00000000"
        //             ],
        //         ],
        //         "asks": [
        //             [
        //               "26301.00000000",
        //               "43616.00000000"
        //             ],
        //             [
        //               "26301.10000000",
        //               "49402.00000000"
        //             ],
        //         ]}
        //     }
        //
        object orderbook = this.safeDict(response, "data", new Dictionary<string, object>() {});
        object timestamp = this.safeInteger2(orderbook, "T", "ts");
        return this.parseOrderBook(orderbook, getValue(market, "symbol"), timestamp, "bids", "asks", 0, 1);
    }

    /**
     * @method
     * @name bingx#fetchFundingRate
     * @description fetch the current funding rate
     * @see https://bingx-api.github.io/docs/#/swapV2/market-api.html#Current%20Funding%20Rate
     * @see https://bingx-api.github.io/docs/#/en-us/cswap/market-api.html#Price%20&%20Current%20Funding%20Rate
     * @param {string} symbol unified market symbol
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [funding rate structure]{@link https://docs.ccxt.com/#/?id=funding-rate-structure}
     */
    public async override Task<object> fetchFundingRate(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object response = null;
        if (isTrue(getValue(market, "inverse")))
        {
            response = await this.cswapV1PublicGetMarketPremiumIndex(this.extend(request, parameters));
        } else
        {
            response = await this.swapV2PublicGetQuotePremiumIndex(this.extend(request, parameters));
        }
        //
        //    {
        //        "code":0,
        //        "msg":"",
        //        "data":[
        //          {
        //            "symbol": "BTC-USDT",
        //            "markPrice": "16884.5",
        //            "indexPrice": "16886.9",
        //            "lastFundingRate": "0.0001",
        //            "nextFundingTime": 1672041600000
        //          },
        //          ...
        //        ]
        //    }
        //
        object data = this.safeList(response, "data", new List<object>() {});
        return this.parseFundingRate(data, market);
    }

    /**
     * @method
     * @name bingx#fetchFundingRates
     * @description fetch the current funding rate for multiple symbols
     * @see https://bingx-api.github.io/docs/#/swapV2/market-api.html#Current%20Funding%20Rate
     * @param {string[]} [symbols] list of unified market symbols
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} a list of [funding rate structures]{@link https://docs.ccxt.com/#/?id=funding-rate-structure}
     */
    public async override Task<object> fetchFundingRates(object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        symbols = this.marketSymbols(symbols, "swap", true);
        object response = await this.swapV2PublicGetQuotePremiumIndex(this.extend(parameters));
        object data = this.safeList(response, "data", new List<object>() {});
        object result = this.parseFundingRates(data);
        return this.filterByArray(result, "symbol", symbols);
    }

    public override object parseFundingRate(object contract, object market = null)
    {
        //
        //     {
        //         "symbol": "BTC-USDT",
        //         "markPrice": "16884.5",
        //         "indexPrice": "16886.9",
        //         "lastFundingRate": "0.0001",
        //         "nextFundingTime": 1672041600000
        //     }
        //
        object marketId = this.safeString(contract, "symbol");
        object nextFundingTimestamp = this.safeInteger(contract, "nextFundingTime");
        return new Dictionary<string, object>() {
            { "info", contract },
            { "symbol", this.safeSymbol(marketId, market, "-", "swap") },
            { "markPrice", this.safeNumber(contract, "markPrice") },
            { "indexPrice", this.safeNumber(contract, "indexPrice") },
            { "interestRate", null },
            { "estimatedSettlePrice", null },
            { "timestamp", null },
            { "datetime", null },
            { "fundingRate", this.safeNumber(contract, "lastFundingRate") },
            { "fundingTimestamp", null },
            { "fundingDatetime", null },
            { "nextFundingRate", null },
            { "nextFundingTimestamp", nextFundingTimestamp },
            { "nextFundingDatetime", this.iso8601(nextFundingTimestamp) },
            { "previousFundingRate", null },
            { "previousFundingTimestamp", null },
            { "previousFundingDatetime", null },
            { "interval", null },
        };
    }

    /**
     * @method
     * @name bingx#fetchFundingRateHistory
     * @description fetches historical funding rate prices
     * @see https://bingx-api.github.io/docs/#/swapV2/market-api.html#Funding%20Rate%20History
     * @param {string} symbol unified symbol of the market to fetch the funding rate history for
     * @param {int} [since] timestamp in ms of the earliest funding rate to fetch
     * @param {int} [limit] the maximum amount of [funding rate structures]{@link https://docs.ccxt.com/#/?id=funding-rate-history-structure} to fetch
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {int} [params.until] timestamp in ms of the latest funding rate to fetch
     * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [availble parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
     * @returns {object[]} a list of [funding rate structures]{@link https://docs.ccxt.com/#/?id=funding-rate-history-structure}
     */
    public async override Task<object> fetchFundingRateHistory(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchFundingRateHistory() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object paginate = false;
        var paginateparametersVariable = this.handleOptionAndParams(parameters, "fetchFundingRateHistory", "paginate");
        paginate = ((IList<object>)paginateparametersVariable)[0];
        parameters = ((IList<object>)paginateparametersVariable)[1];
        if (isTrue(paginate))
        {
            return await this.fetchPaginatedCallDeterministic("fetchFundingRateHistory", symbol, since, limit, "8h", parameters);
        }
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["startTime"] = since;
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        object until = this.safeInteger2(parameters, "until", "startTime");
        if (isTrue(!isEqual(until, null)))
        {
            parameters = this.omit(parameters, new List<object>() {"until"});
            ((IDictionary<string,object>)request)["startTime"] = until;
        }
        object response = await this.swapV2PublicGetQuoteFundingRate(this.extend(request, parameters));
        //
        //    {
        //        "code":0,
        //        "msg":"",
        //        "data":[
        //          {
        //            "symbol": "BTC-USDT",
        //            "fundingRate": "0.0001",
        //            "fundingTime": 1585684800000
        //          },
        //          ...
        //        ]
        //    }
        //
        object data = this.safeList(response, "data", new List<object>() {});
        object rates = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
        {
            object entry = getValue(data, i);
            object marketId = this.safeString(entry, "symbol");
            object symbolInner = this.safeSymbol(marketId, market, "-", "swap");
            object timestamp = this.safeInteger(entry, "fundingTime");
            ((IList<object>)rates).Add(new Dictionary<string, object>() {
                { "info", entry },
                { "symbol", symbolInner },
                { "fundingRate", this.safeNumber(entry, "fundingRate") },
                { "timestamp", timestamp },
                { "datetime", this.iso8601(timestamp) },
            });
        }
        object sorted = this.sortBy(rates, "timestamp");
        return this.filterBySymbolSinceLimit(sorted, getValue(market, "symbol"), since, limit);
    }

    /**
     * @method
     * @name bingx#fetchOpenInterest
     * @description retrieves the open interest of a trading pair
     * @see https://bingx-api.github.io/docs/#/swapV2/market-api.html#Get%20Swap%20Open%20Positions
     * @see https://bingx-api.github.io/docs/#/en-us/cswap/market-api.html#Get%20Swap%20Open%20Positions
     * @param {string} symbol unified CCXT market symbol
     * @param {object} [params] exchange specific parameters
     * @returns {object} an open interest structure{@link https://docs.ccxt.com/#/?id=open-interest-structure}
     */
    public async override Task<object> fetchOpenInterest(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object response = null;
        if (isTrue(getValue(market, "inverse")))
        {
            response = await this.cswapV1PublicGetMarketOpenInterest(this.extend(request, parameters));
        } else
        {
            response = await this.swapV2PublicGetQuoteOpenInterest(this.extend(request, parameters));
        }
        //
        // linear swap
        //
        //     {
        //         "code": 0,
        //         "msg": "",
        //         "data": {
        //           "openInterest": "3289641547.10",
        //           "symbol": "BTC-USDT",
        //           "time": 1672026617364
        //         }
        //     }
        //
        // inverse swap
        //
        //     {
        //         "code": 0,
        //         "msg": "",
        //         "timestamp": 1720328247986,
        //         "data": [
        //             {
        //                 "symbol": "BTC-USD",
        //                 "openInterest": "749.1160",
        //                 "timestamp": 1720310400000
        //             }
        //         ]
        //     }
        //
        object result = new Dictionary<string, object>() {};
        if (isTrue(getValue(market, "inverse")))
        {
            object data = this.safeList(response, "data", new List<object>() {});
            result = this.safeDict(data, 0, new Dictionary<string, object>() {});
        } else
        {
            result = this.safeDict(response, "data", new Dictionary<string, object>() {});
        }
        return this.parseOpenInterest(result, market);
    }

    public override object parseOpenInterest(object interest, object market = null)
    {
        //
        // linear swap
        //
        //     {
        //         "openInterest": "3289641547.10",
        //         "symbol": "BTC-USDT",
        //         "time": 1672026617364
        //     }
        //
        // inverse swap
        //
        //     {
        //         "symbol": "BTC-USD",
        //         "openInterest": "749.1160",
        //         "timestamp": 1720310400000
        //     }
        //
        object timestamp = this.safeInteger2(interest, "time", "timestamp");
        object id = this.safeString(interest, "symbol");
        object symbol = this.safeSymbol(id, market, "-", "swap");
        object openInterest = this.safeNumber(interest, "openInterest");
        return this.safeOpenInterest(new Dictionary<string, object>() {
            { "symbol", symbol },
            { "baseVolume", null },
            { "quoteVolume", null },
            { "openInterestAmount", null },
            { "openInterestValue", openInterest },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "info", interest },
        }, market);
    }

    /**
     * @method
     * @name bingx#fetchTicker
     * @description fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
     * @see https://bingx-api.github.io/docs/#/en-us/swapV2/market-api.html#Get%20Ticker
     * @see https://bingx-api.github.io/docs/#/en-us/spot/market-api.html#24-hour%20price%20changes
     * @see https://bingx-api.github.io/docs/#/en-us/cswap/market-api.html#Query%2024-Hour%20Price%20Change
     * @param {string} symbol unified symbol of the market to fetch the ticker for
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
     */
    public async override Task<object> fetchTicker(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object response = null;
        if (isTrue(getValue(market, "spot")))
        {
            response = await this.spotV1PublicGetTicker24hr(this.extend(request, parameters));
        } else
        {
            if (isTrue(getValue(market, "inverse")))
            {
                response = await this.cswapV1PublicGetMarketTicker(this.extend(request, parameters));
            } else
            {
                response = await this.swapV2PublicGetQuoteTicker(this.extend(request, parameters));
            }
        }
        //
        // spot and swap
        //
        //     {
        //         "code": 0,
        //         "msg": "",
        //         "timestamp": 1720647285296,
        //         "data": [
        //             {
        //                 "symbol": "SOL-USD",
        //                 "priceChange": "-2.418",
        //                 "priceChangePercent": "-1.6900%",
        //                 "lastPrice": "140.574",
        //                 "lastQty": "1",
        //                 "highPrice": "146.190",
        //                 "lowPrice": "138.586",
        //                 "volume": "1464648.00",
        //                 "quoteVolume": "102928.12",
        //                 "openPrice": "142.994",
        //                 "closeTime": "1720647284976",
        //                 "bidPrice": "140.573",
        //                 "bidQty": "372",
        //                 "askPrice": "140.577",
        //                 "askQty": "58"
        //             }
        //         ]
        //     }
        //
        object data = this.safeList(response, "data");
        if (isTrue(!isEqual(data, null)))
        {
            object first = this.safeDict(data, 0, new Dictionary<string, object>() {});
            return this.parseTicker(first, market);
        }
        object dataDict = this.safeDict(response, "data", new Dictionary<string, object>() {});
        return this.parseTicker(dataDict, market);
    }

    /**
     * @method
     * @name bingx#fetchTickers
     * @description fetches price tickers for multiple markets, statistical information calculated over the past 24 hours for each market
     * @see https://bingx-api.github.io/docs/#/en-us/swapV2/market-api.html#Get%20Ticker
     * @see https://bingx-api.github.io/docs/#/en-us/spot/market-api.html#24-hour%20price%20changes
     * @see https://bingx-api.github.io/docs/#/en-us/cswap/market-api.html#Query%2024-Hour%20Price%20Change
     * @param {string[]|undefined} symbols unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/#/?id=ticker-structure}
     */
    public async override Task<object> fetchTickers(object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = null;
        if (isTrue(!isEqual(symbols, null)))
        {
            symbols = this.marketSymbols(symbols);
            object firstSymbol = this.safeString(symbols, 0);
            if (isTrue(!isEqual(firstSymbol, null)))
            {
                market = this.market(firstSymbol);
            }
        }
        object type = null;
        var typeparametersVariable = this.handleMarketTypeAndParams("fetchTickers", market, parameters);
        type = ((IList<object>)typeparametersVariable)[0];
        parameters = ((IList<object>)typeparametersVariable)[1];
        object subType = null;
        var subTypeparametersVariable = this.handleSubTypeAndParams("fetchTickers", market, parameters);
        subType = ((IList<object>)subTypeparametersVariable)[0];
        parameters = ((IList<object>)subTypeparametersVariable)[1];
        object response = null;
        if (isTrue(isEqual(type, "spot")))
        {
            response = await this.spotV1PublicGetTicker24hr(parameters);
        } else
        {
            if (isTrue(isEqual(subType, "inverse")))
            {
                response = await this.cswapV1PublicGetMarketTicker(parameters);
            } else
            {
                response = await this.swapV2PublicGetQuoteTicker(parameters);
            }
        }
        //
        // spot and swap
        //
        //     {
        //         "code": 0,
        //         "msg": "",
        //         "timestamp": 1720647285296,
        //         "data": [
        //             {
        //                 "symbol": "SOL-USD",
        //                 "priceChange": "-2.418",
        //                 "priceChangePercent": "-1.6900%",
        //                 "lastPrice": "140.574",
        //                 "lastQty": "1",
        //                 "highPrice": "146.190",
        //                 "lowPrice": "138.586",
        //                 "volume": "1464648.00",
        //                 "quoteVolume": "102928.12",
        //                 "openPrice": "142.994",
        //                 "closeTime": "1720647284976",
        //                 "bidPrice": "140.573",
        //                 "bidQty": "372",
        //                 "askPrice": "140.577",
        //                 "askQty": "58"
        //             },
        //             ...
        //         ]
        //     }
        //
        object tickers = this.safeList(response, "data");
        return this.parseTickers(tickers, symbols);
    }

    /**
     * @method
     * @name bingx#fetchMarkPrice
     * @description fetches mark prices for the market
     * @see https://bingx-api.github.io/docs/#/en-us/swapV2/market-api.html#Mark%20Price%20and%20Funding%20Rate
     * @param {string} symbol unified symbol of the market to fetch the ticker for
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/#/?id=ticker-structure}
     */
    public async override Task<object> fetchMarkPrice(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object subType = null;
        var subTypeparametersVariable = this.handleSubTypeAndParams("fetchMarkPrice", market, parameters, "linear");
        subType = ((IList<object>)subTypeparametersVariable)[0];
        parameters = ((IList<object>)subTypeparametersVariable)[1];
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object response = null;
        if (isTrue(isEqual(subType, "inverse")))
        {
            response = await this.cswapV1PublicGetMarketPremiumIndex(this.extend(request, parameters));
        } else
        {
            response = await this.swapV2PublicGetQuotePremiumIndex(this.extend(request, parameters));
        }
        if (isTrue(((getValue(response, "data") is IList<object>) || (getValue(response, "data").GetType().IsGenericType && getValue(response, "data").GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>))))))
        {
            return this.parseTicker(this.safeDict(getValue(response, "data"), 0, new Dictionary<string, object>() {}), market);
        }
        return this.parseTicker(getValue(response, "data"), market);
    }

    /**
     * @method
     * @name bingx#fetchMarkPrices
     * @description fetches mark prices for multiple markets
     * @see https://bingx-api.github.io/docs/#/en-us/swapV2/market-api.html#Mark%20Price%20and%20Funding%20Rate
     * @param {string[]} [symbols] unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/#/?id=ticker-structure}
     */
    public async override Task<object> fetchMarkPrices(object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = null;
        if (isTrue(!isEqual(symbols, null)))
        {
            symbols = this.marketSymbols(symbols);
            object firstSymbol = this.safeString(symbols, 0);
            if (isTrue(!isEqual(firstSymbol, null)))
            {
                market = this.market(firstSymbol);
            }
        }
        object subType = null;
        var subTypeparametersVariable = this.handleSubTypeAndParams("fetchMarkPrices", market, parameters, "linear");
        subType = ((IList<object>)subTypeparametersVariable)[0];
        parameters = ((IList<object>)subTypeparametersVariable)[1];
        object response = null;
        if (isTrue(isEqual(subType, "inverse")))
        {
            response = await this.cswapV1PublicGetMarketPremiumIndex(parameters);
        } else
        {
            response = await this.swapV2PublicGetQuotePremiumIndex(parameters);
        }
        //
        // spot and swap
        //
        //     {
        //         "code": 0,
        //         "msg": "",
        //         "timestamp": 1720647285296,
        //         "data": [
        //             {
        //                 "symbol": "SOL-USD",
        //                 "priceChange": "-2.418",
        //                 "priceChangePercent": "-1.6900%",
        //                 "lastPrice": "140.574",
        //                 "lastQty": "1",
        //                 "highPrice": "146.190",
        //                 "lowPrice": "138.586",
        //                 "volume": "1464648.00",
        //                 "quoteVolume": "102928.12",
        //                 "openPrice": "142.994",
        //                 "closeTime": "1720647284976",
        //                 "bidPrice": "140.573",
        //                 "bidQty": "372",
        //                 "askPrice": "140.577",
        //                 "askQty": "58"
        //             },
        //             ...
        //         ]
        //     }
        //
        object tickers = this.safeList(response, "data");
        return this.parseTickers(tickers, symbols);
    }

    public override object parseTicker(object ticker, object market = null)
    {
        //
        // mark price
        // {
        //     "symbol": "string",
        //     "lastFundingRate": "string",
        //     "markPrice": "string",
        //     "indexPrice": "string",
        //     "nextFundingTime": "int64"
        // }
        //
        // spot
        //    {
        //        "symbol": "BTC-USDT",
        //        "openPrice": "26032.08",
        //        "highPrice": "26178.86",
        //        "lowPrice": "25968.18",
        //        "lastPrice": "26113.60",
        //        "volume": "1161.79",
        //        "quoteVolume": "30288466.44",
        //        "openTime": "1693081020762",
        //        "closeTime": "1693167420762",
        //  added 2023-11-10:
        //        "bidPrice": 16726.0,
        //        "bidQty": 0.05,
        //        "askPrice": 16726.0,
        //        "askQty": 0.05,
        //    }
        // swap
        //
        //    {
        //        "symbol": "BTC-USDT",
        //        "priceChange": "52.5",
        //        "priceChangePercent": "0.31%", // they started to add the percent sign in value
        //        "lastPrice": "16880.5",
        //        "lastQty": "2.2238",          // only present in swap!
        //        "highPrice": "16897.5",
        //        "lowPrice": "16726.0",
        //        "volume": "245870.1692",
        //        "quoteVolume": "4151395117.73",
        //        "openPrice": "16832.0",
        //        "openTime": 1672026667803,
        //        "closeTime": 1672026648425,
        //  added 2023-11-10:
        //        "bidPrice": 16726.0,
        //        "bidQty": 0.05,
        //        "askPrice": 16726.0,
        //        "askQty": 0.05,
        //    }
        //
        object marketId = this.safeString(ticker, "symbol");
        object lastQty = this.safeString(ticker, "lastQty");
        // in spot markets, lastQty is not present
        // it's (bad, but) the only way we can check the tickers origin
        object type = ((bool) isTrue((isEqual(lastQty, null)))) ? "spot" : "swap";
        market = this.safeMarket(marketId, market, null, type);
        object symbol = getValue(market, "symbol");
        object open = this.safeString(ticker, "openPrice");
        object high = this.safeString(ticker, "highPrice");
        object low = this.safeString(ticker, "lowPrice");
        object close = this.safeString(ticker, "lastPrice");
        object quoteVolume = this.safeString(ticker, "quoteVolume");
        object baseVolume = this.safeString(ticker, "volume");
        object percentage = this.safeString(ticker, "priceChangePercent");
        if (isTrue(!isEqual(percentage, null)))
        {
            percentage = ((string)percentage).Replace((string)"%", (string)"");
        }
        object change = this.safeString(ticker, "priceChange");
        object ts = this.safeInteger(ticker, "closeTime");
        if (isTrue(isEqual(ts, 0)))
        {
            ts = null;
        }
        object datetime = this.iso8601(ts);
        object bid = this.safeString(ticker, "bidPrice");
        object bidVolume = this.safeString(ticker, "bidQty");
        object ask = this.safeString(ticker, "askPrice");
        object askVolume = this.safeString(ticker, "askQty");
        return this.safeTicker(new Dictionary<string, object>() {
            { "symbol", symbol },
            { "timestamp", ts },
            { "datetime", datetime },
            { "high", high },
            { "low", low },
            { "bid", bid },
            { "bidVolume", bidVolume },
            { "ask", ask },
            { "askVolume", askVolume },
            { "vwap", null },
            { "open", open },
            { "close", close },
            { "last", null },
            { "previousClose", null },
            { "change", change },
            { "percentage", percentage },
            { "average", null },
            { "baseVolume", baseVolume },
            { "quoteVolume", quoteVolume },
            { "markPrice", this.safeString(ticker, "markPrice") },
            { "indexPrice", this.safeString(ticker, "indexPrice") },
            { "info", ticker },
        }, market);
    }

    /**
     * @method
     * @name bingx#fetchBalance
     * @description query for balance and get the amount of funds available for trading or funds locked in orders
     * @see https://bingx-api.github.io/docs/#/spot/trade-api.html#Query%20Assets
     * @see https://bingx-api.github.io/docs/#/swapV2/account-api.html#Get%20Perpetual%20Swap%20Account%20Asset%20Information
     * @see https://bingx-api.github.io/docs/#/standard/contract-interface.html#Query%20standard%20contract%20balance
     * @see https://bingx-api.github.io/docs/#/en-us/cswap/trade-api.html#Query%20Account%20Assets
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {boolean} [params.standard] whether to fetch standard contract balances
     * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
     */
    public async override Task<object> fetchBalance(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = null;
        object standard = null;
        var standardparametersVariable = this.handleOptionAndParams(parameters, "fetchBalance", "standard", false);
        standard = ((IList<object>)standardparametersVariable)[0];
        parameters = ((IList<object>)standardparametersVariable)[1];
        object subType = null;
        var subTypeparametersVariable = this.handleSubTypeAndParams("fetchBalance", null, parameters);
        subType = ((IList<object>)subTypeparametersVariable)[0];
        parameters = ((IList<object>)subTypeparametersVariable)[1];
        var marketTypemarketTypeQueryVariable = this.handleMarketTypeAndParams("fetchBalance", null, parameters);
        var marketType = ((IList<object>) marketTypemarketTypeQueryVariable)[0];
        var marketTypeQuery = ((IList<object>) marketTypemarketTypeQueryVariable)[1];
        if (isTrue(standard))
        {
            response = await this.contractV1PrivateGetBalance(marketTypeQuery);
        } else if (isTrue(isEqual(marketType, "spot")))
        {
            response = await this.spotV1PrivateGetAccountBalance(marketTypeQuery);
        } else
        {
            if (isTrue(isEqual(subType, "inverse")))
            {
                response = await this.cswapV1PrivateGetUserBalance(marketTypeQuery);
            } else
            {
                response = await this.swapV2PrivateGetUserBalance(marketTypeQuery);
            }
        }
        return this.parseBalance(response);
    }

    public override object parseBalance(object response)
    {
        //
        // standard
        //
        //     {
        //         "code": 0,
        //         "timestamp": 1721192833454,
        //         "data": [
        //             {
        //                 "asset": "USDT",
        //                 "balance": "4.72644300000000000000",
        //                 "crossWalletBalance": "4.72644300000000000000",
        //                 "crossUnPnl": "0",
        //                 "availableBalance": "4.72644300000000000000",
        //                 "maxWithdrawAmount": "4.72644300000000000000",
        //                 "marginAvailable": false,
        //                 "updateTime": 1721192833443
        //             },
        //         ]
        //     }
        //
        // spot
        //
        //     {
        //         "code": 0,
        //         "msg": "",
        //         "debugMsg": "",
        //         "data": {
        //             "balances": [
        //                 {
        //                     "asset": "USDT",
        //                     "free": "45.733046995800514",
        //                     "locked": "0"
        //                 },
        //             ]
        //         }
        //     }
        //
        // inverse swap
        //
        //     {
        //         "code": 0,
        //         "msg": "",
        //         "timestamp": 1721191833813,
        //         "data": [
        //             {
        //                 "asset": "SOL",
        //                 "balance": "0.35707951",
        //                 "equity": "0.35791051",
        //                 "unrealizedProfit": "0.00083099",
        //                 "availableMargin": "0.35160653",
        //                 "usedMargin": "0.00630397",
        //                 "freezedMargin": "0",
        //                 "shortUid": "12851936"
        //             }
        //         ]
        //     }
        //
        // linear swap
        //
        //     {
        //         "code": 0,
        //         "msg": "",
        //         "data": {
        //             "balance": {
        //                 "userId": "1177064765068660742",
        //                 "asset": "USDT",
        //                 "balance": "51.5198",
        //                 "equity": "50.5349",
        //                 "unrealizedProfit": "-0.9849",
        //                 "realisedProfit": "-0.2134",
        //                 "availableMargin": "49.1428",
        //                 "usedMargin": "1.3922",
        //                 "freezedMargin": "0.0000",
        //                 "shortUid": "12851936"
        //             }
        //         }
        //     }
        //
        object result = new Dictionary<string, object>() {
            { "info", response },
        };
        object standardAndInverseBalances = this.safeList(response, "data");
        object firstStandardOrInverse = this.safeDict(standardAndInverseBalances, 0);
        object isStandardOrInverse = !isEqual(firstStandardOrInverse, null);
        object spotData = this.safeDict(response, "data", new Dictionary<string, object>() {});
        object spotBalances = this.safeList(spotData, "balances");
        object firstSpot = this.safeDict(spotBalances, 0);
        object isSpot = !isEqual(firstSpot, null);
        if (isTrue(isStandardOrInverse))
        {
            for (object i = 0; isLessThan(i, getArrayLength(standardAndInverseBalances)); postFixIncrement(ref i))
            {
                object balance = getValue(standardAndInverseBalances, i);
                object currencyId = this.safeString(balance, "asset");
                object code = this.safeCurrencyCode(currencyId);
                object account = this.account();
                ((IDictionary<string,object>)account)["free"] = this.safeString2(balance, "availableMargin", "availableBalance");
                ((IDictionary<string,object>)account)["used"] = this.safeString(balance, "usedMargin");
                ((IDictionary<string,object>)account)["total"] = this.safeString(balance, "maxWithdrawAmount");
                ((IDictionary<string,object>)result)[(string)code] = account;
            }
        } else if (isTrue(isSpot))
        {
            for (object i = 0; isLessThan(i, getArrayLength(spotBalances)); postFixIncrement(ref i))
            {
                object balance = getValue(spotBalances, i);
                object currencyId = this.safeString(balance, "asset");
                object code = this.safeCurrencyCode(currencyId);
                object account = this.account();
                ((IDictionary<string,object>)account)["free"] = this.safeString(balance, "free");
                ((IDictionary<string,object>)account)["used"] = this.safeString(balance, "locked");
                ((IDictionary<string,object>)result)[(string)code] = account;
            }
        } else
        {
            object linearSwapData = this.safeDict(response, "data", new Dictionary<string, object>() {});
            object linearSwapBalance = this.safeDict(linearSwapData, "balance");
            object currencyId = this.safeString(linearSwapBalance, "asset");
            object code = this.safeCurrencyCode(currencyId);
            object account = this.account();
            ((IDictionary<string,object>)account)["free"] = this.safeString(linearSwapBalance, "availableMargin");
            ((IDictionary<string,object>)account)["used"] = this.safeString(linearSwapBalance, "usedMargin");
            ((IDictionary<string,object>)result)[(string)code] = account;
        }
        return this.safeBalance(result);
    }

    /**
     * @method
     * @name bingx#fetchPositions
     * @description fetch all open positions
     * @see https://bingx-api.github.io/docs/#/en-us/swapV2/account-api.html#Query%20position%20data
     * @see https://bingx-api.github.io/docs/#/en-us/standard/contract-interface.html#position
     * @see https://bingx-api.github.io/docs/#/en-us/cswap/trade-api.html#Query%20warehouse
     * @param {string[]|undefined} symbols list of unified market symbols
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {boolean} [params.standard] whether to fetch standard contract positions
     * @returns {object[]} a list of [position structures]{@link https://docs.ccxt.com/#/?id=position-structure}
     */
    public async override Task<object> fetchPositions(object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        symbols = this.marketSymbols(symbols);
        object standard = null;
        var standardparametersVariable = this.handleOptionAndParams(parameters, "fetchPositions", "standard", false);
        standard = ((IList<object>)standardparametersVariable)[0];
        parameters = ((IList<object>)standardparametersVariable)[1];
        object response = null;
        if (isTrue(standard))
        {
            response = await this.contractV1PrivateGetAllPosition(parameters);
        } else
        {
            object market = null;
            if (isTrue(!isEqual(symbols, null)))
            {
                symbols = this.marketSymbols(symbols);
                object firstSymbol = this.safeString(symbols, 0);
                if (isTrue(!isEqual(firstSymbol, null)))
                {
                    market = this.market(firstSymbol);
                }
            }
            object subType = null;
            var subTypeparametersVariable = this.handleSubTypeAndParams("fetchPositions", market, parameters);
            subType = ((IList<object>)subTypeparametersVariable)[0];
            parameters = ((IList<object>)subTypeparametersVariable)[1];
            if (isTrue(isEqual(subType, "inverse")))
            {
                response = await this.cswapV1PrivateGetUserPositions(parameters);
            } else
            {
                response = await this.swapV2PrivateGetUserPositions(parameters);
            }
        }
        object positions = this.safeList(response, "data", new List<object>() {});
        return this.parsePositions(positions, symbols);
    }

    /**
     * @method
     * @name bingx#fetchPosition
     * @description fetch data on a single open contract trade position
     * @see https://bingx-api.github.io/docs/#/en-us/swapV2/account-api.html#Query%20position%20data
     * @see https://bingx-api.github.io/docs/#/en-us/cswap/trade-api.html#Query%20warehouse
     * @param {string} symbol unified market symbol of the market the position is held in
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [position structure]{@link https://docs.ccxt.com/#/?id=position-structure}
     */
    public async override Task<object> fetchPosition(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        if (!isTrue(getValue(market, "swap")))
        {
            throw new BadRequest ((string)add(this.id, " fetchPosition() supports swap markets only")) ;
        }
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object response = null;
        if (isTrue(getValue(market, "inverse")))
        {
            response = await this.cswapV1PrivateGetUserPositions(this.extend(request, parameters));
        } else
        {
            response = await this.swapV2PrivateGetUserPositions(this.extend(request, parameters));
        }
        object data = this.safeList(response, "data", new List<object>() {});
        object first = this.safeDict(data, 0, new Dictionary<string, object>() {});
        return this.parsePosition(first, market);
    }

    public override object parsePosition(object position, object market = null)
    {
        //
        // inverse swap
        //
        //     {
        //         "symbol": "SOL-USD",
        //         "positionId": "1813080351385337856",
        //         "positionSide": "LONG",
        //         "isolated": false,
        //         "positionAmt": "1",
        //         "availableAmt": "1",
        //         "unrealizedProfit": "-0.00009074",
        //         "initialMargin": "0.00630398",
        //         "liquidationPrice": 23.968303426677032,
        //         "avgPrice": "158.63",
        //         "leverage": 10,
        //         "markPrice": "158.402",
        //         "riskRate": "0.00123783",
        //         "maxMarginReduction": "0",
        //         "updateTime": 1721107015848
        //     }
        //
        // linear swap
        //
        //     {
        //         "positionId": "1792480725958881280",
        //         "symbol": "LTC-USDT",
        //         "currency": "USDT",
        //         "positionAmt": "0.1",
        //         "availableAmt": "0.1",
        //         "positionSide": "LONG",
        //         "isolated": false,
        //         "avgPrice": "83.53",
        //         "initialMargin": "1.3922",
        //         "margin": "0.3528",
        //         "leverage": 6,
        //         "unrealizedProfit": "-1.0393",
        //         "realisedProfit": "-0.2119",
        //         "liquidationPrice": 0,
        //         "pnlRatio": "-0.7465",
        //         "maxMarginReduction": "0.0000",
        //         "riskRate": "0.0008",
        //         "markPrice": "73.14",
        //         "positionValue": "7.3136",
        //         "onlyOnePosition": true,
        //         "updateTime": 1721088016688
        //     }
        //
        // standard position
        //
        //     {
        //         "currentPrice": "82.91",
        //         "symbol": "LTC/USDT",
        //         "initialMargin": "5.00000000000000000000",
        //         "unrealizedProfit": "-0.26464500",
        //         "leverage": "20.000000000",
        //         "isolated": true,
        //         "entryPrice": "83.13",
        //         "positionSide": "LONG",
        //         "positionAmt": "1.20365912",
        //     }
        //
        object marketId = this.safeString(position, "symbol", "");
        marketId = ((string)marketId).Replace((string)"/", (string)"-"); // standard return different format
        object isolated = this.safeBool(position, "isolated");
        object marginMode = null;
        if (isTrue(!isEqual(isolated, null)))
        {
            marginMode = ((bool) isTrue(isolated)) ? "isolated" : "cross";
        }
        return this.safePosition(new Dictionary<string, object>() {
            { "info", position },
            { "id", this.safeString(position, "positionId") },
            { "symbol", this.safeSymbol(marketId, market, "-", "swap") },
            { "notional", this.safeNumber(position, "positionValue") },
            { "marginMode", marginMode },
            { "liquidationPrice", null },
            { "entryPrice", this.safeNumber2(position, "avgPrice", "entryPrice") },
            { "unrealizedPnl", this.safeNumber(position, "unrealizedProfit") },
            { "realizedPnl", this.safeNumber(position, "realisedProfit") },
            { "percentage", null },
            { "contracts", this.safeNumber(position, "positionAmt") },
            { "contractSize", null },
            { "markPrice", this.safeNumber(position, "markPrice") },
            { "lastPrice", null },
            { "side", this.safeStringLower(position, "positionSide") },
            { "hedged", null },
            { "timestamp", null },
            { "datetime", null },
            { "lastUpdateTimestamp", this.safeInteger(position, "updateTime") },
            { "maintenanceMargin", null },
            { "maintenanceMarginPercentage", null },
            { "collateral", null },
            { "initialMargin", this.safeNumber(position, "initialMargin") },
            { "initialMarginPercentage", null },
            { "leverage", this.safeNumber(position, "leverage") },
            { "marginRatio", null },
            { "stopLossPrice", null },
            { "takeProfitPrice", null },
        });
    }

    /**
     * @method
     * @name bingx#createMarketOrderWithCost
     * @description create a market order by providing the symbol, side and cost
     * @param {string} symbol unified symbol of the market to create an order in
     * @param {string} side 'buy' or 'sell'
     * @param {float} cost how much you want to trade in units of the quote currency
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> createMarketOrderWithCost(object symbol, object side, object cost, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        ((IDictionary<string,object>)parameters)["quoteOrderQty"] = cost;
        return await this.createOrder(symbol, "market", side, cost, null, parameters);
    }

    /**
     * @method
     * @name bingx#createMarketBuyOrderWithCost
     * @description create a market buy order by providing the symbol and cost
     * @param {string} symbol unified symbol of the market to create an order in
     * @param {float} cost how much you want to trade in units of the quote currency
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> createMarketBuyOrderWithCost(object symbol, object cost, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        ((IDictionary<string,object>)parameters)["quoteOrderQty"] = cost;
        return await this.createOrder(symbol, "market", "buy", cost, null, parameters);
    }

    /**
     * @method
     * @name bingx#createMarketSellOrderWithCost
     * @description create a market sell order by providing the symbol and cost
     * @param {string} symbol unified symbol of the market to create an order in
     * @param {float} cost how much you want to trade in units of the quote currency
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> createMarketSellOrderWithCost(object symbol, object cost, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        ((IDictionary<string,object>)parameters)["quoteOrderQty"] = cost;
        return await this.createOrder(symbol, "market", "sell", cost, null, parameters);
    }

    public virtual object createOrderRequest(object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        /**
        * @method
        * @ignore
        * @name bingx#createOrderRequest
        * @description helper function to build request
        * @param {string} symbol unified symbol of the market to create an order in
        * @param {string} type 'market' or 'limit'
        * @param {string} side 'buy' or 'sell'
        * @param {float} amount how much you want to trade in units of the base currency
        * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} request to be sent to the exchange
        */
        parameters ??= new Dictionary<string, object>();
        object market = this.market(symbol);
        object postOnly = null;
        object marketType = null;
        var marketTypeparametersVariable = this.handleMarketTypeAndParams("createOrder", market, parameters);
        marketType = ((IList<object>)marketTypeparametersVariable)[0];
        parameters = ((IList<object>)marketTypeparametersVariable)[1];
        type = ((string)type).ToUpper();
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
            { "type", type },
            { "side", ((string)side).ToUpper() },
        };
        object isMarketOrder = isEqual(type, "MARKET");
        object isSpot = isEqual(marketType, "spot");
        object stopLossPrice = this.safeString(parameters, "stopLossPrice");
        object takeProfitPrice = this.safeString(parameters, "takeProfitPrice");
        object triggerPrice = this.safeString2(parameters, "stopPrice", "triggerPrice");
        object isTriggerOrder = !isEqual(triggerPrice, null);
        object isStopLossPriceOrder = !isEqual(stopLossPrice, null);
        object isTakeProfitPriceOrder = !isEqual(takeProfitPrice, null);
        object exchangeClientOrderId = ((bool) isTrue(isSpot)) ? "newClientOrderId" : "clientOrderID";
        object clientOrderId = this.safeString2(parameters, exchangeClientOrderId, "clientOrderId");
        if (isTrue(!isEqual(clientOrderId, null)))
        {
            ((IDictionary<string,object>)request)[(string)exchangeClientOrderId] = clientOrderId;
        }
        object timeInForce = this.safeStringUpper(parameters, "timeInForce");
        var postOnlyparametersVariable = this.handlePostOnly(isMarketOrder, isEqual(timeInForce, "PostOnly"), parameters);
        postOnly = ((IList<object>)postOnlyparametersVariable)[0];
        parameters = ((IList<object>)postOnlyparametersVariable)[1];
        if (isTrue(isTrue(postOnly) || isTrue((isEqual(timeInForce, "PostOnly")))))
        {
            ((IDictionary<string,object>)request)["timeInForce"] = "PostOnly";
        } else if (isTrue(isEqual(timeInForce, "IOC")))
        {
            ((IDictionary<string,object>)request)["timeInForce"] = "IOC";
        } else if (isTrue(isEqual(timeInForce, "GTC")))
        {
            ((IDictionary<string,object>)request)["timeInForce"] = "GTC";
        }
        if (isTrue(isSpot))
        {
            object cost = this.safeString2(parameters, "cost", "quoteOrderQty");
            parameters = this.omit(parameters, "cost");
            if (isTrue(!isEqual(cost, null)))
            {
                ((IDictionary<string,object>)request)["quoteOrderQty"] = this.parseToNumeric(this.costToPrecision(symbol, cost));
            } else
            {
                if (isTrue(isTrue(isMarketOrder) && isTrue((!isEqual(price, null)))))
                {
                    // keep the legacy behavior, to avoid  breaking the old spot-market-buying code
                    object calculatedCost = Precise.stringMul(this.numberToString(amount), this.numberToString(price));
                    ((IDictionary<string,object>)request)["quoteOrderQty"] = this.parseToNumeric(calculatedCost);
                } else
                {
                    ((IDictionary<string,object>)request)["quantity"] = this.parseToNumeric(this.amountToPrecision(symbol, amount));
                }
            }
            if (!isTrue(isMarketOrder))
            {
                ((IDictionary<string,object>)request)["price"] = this.parseToNumeric(this.priceToPrecision(symbol, price));
            }
            if (isTrue(!isEqual(triggerPrice, null)))
            {
                if (isTrue(isTrue(isMarketOrder) && isTrue(isEqual(this.safeString(request, "quoteOrderQty"), null))))
                {
                    throw new ArgumentsRequired ((string)add(this.id, " createOrder() requires the cost parameter (or the amount + price) for placing spot market-buy trigger orders")) ;
                }
                ((IDictionary<string,object>)request)["stopPrice"] = this.priceToPrecision(symbol, triggerPrice);
                if (isTrue(isEqual(type, "LIMIT")))
                {
                    ((IDictionary<string,object>)request)["type"] = "TRIGGER_LIMIT";
                } else if (isTrue(isEqual(type, "MARKET")))
                {
                    ((IDictionary<string,object>)request)["type"] = "TRIGGER_MARKET";
                }
            } else if (isTrue(isTrue((!isEqual(stopLossPrice, null))) || isTrue((!isEqual(takeProfitPrice, null)))))
            {
                object stopTakePrice = ((bool) isTrue((!isEqual(stopLossPrice, null)))) ? stopLossPrice : takeProfitPrice;
                if (isTrue(isEqual(type, "LIMIT")))
                {
                    ((IDictionary<string,object>)request)["type"] = "TAKE_STOP_LIMIT";
                } else if (isTrue(isEqual(type, "MARKET")))
                {
                    ((IDictionary<string,object>)request)["type"] = "TAKE_STOP_MARKET";
                }
                ((IDictionary<string,object>)request)["stopPrice"] = this.parseToNumeric(this.priceToPrecision(symbol, stopTakePrice));
            }
        } else
        {
            if (isTrue(isEqual(timeInForce, "FOK")))
            {
                ((IDictionary<string,object>)request)["timeInForce"] = "FOK";
            }
            object trailingAmount = this.safeString(parameters, "trailingAmount");
            object trailingPercent = this.safeString2(parameters, "trailingPercent", "priceRate");
            object trailingType = this.safeString(parameters, "trailingType", "TRAILING_STOP_MARKET");
            object isTrailingAmountOrder = !isEqual(trailingAmount, null);
            object isTrailingPercentOrder = !isEqual(trailingPercent, null);
            object isTrailing = isTrue(isTrailingAmountOrder) || isTrue(isTrailingPercentOrder);
            object stopLoss = this.safeValue(parameters, "stopLoss");
            object takeProfit = this.safeValue(parameters, "takeProfit");
            object isStopLoss = !isEqual(stopLoss, null);
            object isTakeProfit = !isEqual(takeProfit, null);
            if (isTrue(isTrue((isTrue(isTrue(isTrue((isEqual(type, "LIMIT"))) || isTrue((isEqual(type, "TRIGGER_LIMIT")))) || isTrue((isEqual(type, "STOP")))) || isTrue((isEqual(type, "TAKE_PROFIT"))))) && !isTrue(isTrailing)))
            {
                ((IDictionary<string,object>)request)["price"] = this.parseToNumeric(this.priceToPrecision(symbol, price));
            }
            object reduceOnly = this.safeBool(parameters, "reduceOnly", false);
            if (isTrue(isTriggerOrder))
            {
                ((IDictionary<string,object>)request)["stopPrice"] = this.parseToNumeric(this.priceToPrecision(symbol, triggerPrice));
                if (isTrue(isTrue(isMarketOrder) || isTrue((isEqual(type, "TRIGGER_MARKET")))))
                {
                    ((IDictionary<string,object>)request)["type"] = "TRIGGER_MARKET";
                } else if (isTrue(isTrue((isEqual(type, "LIMIT"))) || isTrue((isEqual(type, "TRIGGER_LIMIT")))))
                {
                    ((IDictionary<string,object>)request)["type"] = "TRIGGER_LIMIT";
                }
            } else if (isTrue(isTrue(isStopLossPriceOrder) || isTrue(isTakeProfitPriceOrder)))
            {
                // This can be used to set the stop loss and take profit, but the position needs to be opened first
                reduceOnly = true;
                if (isTrue(isStopLossPriceOrder))
                {
                    ((IDictionary<string,object>)request)["stopPrice"] = this.parseToNumeric(this.priceToPrecision(symbol, stopLossPrice));
                    if (isTrue(isTrue(isMarketOrder) || isTrue((isEqual(type, "STOP_MARKET")))))
                    {
                        ((IDictionary<string,object>)request)["type"] = "STOP_MARKET";
                    } else if (isTrue(isTrue((isEqual(type, "LIMIT"))) || isTrue((isEqual(type, "STOP")))))
                    {
                        ((IDictionary<string,object>)request)["type"] = "STOP";
                    }
                } else if (isTrue(isTakeProfitPriceOrder))
                {
                    ((IDictionary<string,object>)request)["stopPrice"] = this.parseToNumeric(this.priceToPrecision(symbol, takeProfitPrice));
                    if (isTrue(isTrue(isMarketOrder) || isTrue((isEqual(type, "TAKE_PROFIT_MARKET")))))
                    {
                        ((IDictionary<string,object>)request)["type"] = "TAKE_PROFIT_MARKET";
                    } else if (isTrue(isTrue((isEqual(type, "LIMIT"))) || isTrue((isEqual(type, "TAKE_PROFIT")))))
                    {
                        ((IDictionary<string,object>)request)["type"] = "TAKE_PROFIT";
                    }
                }
            } else if (isTrue(isTrailing))
            {
                ((IDictionary<string,object>)request)["type"] = trailingType;
                if (isTrue(isTrailingAmountOrder))
                {
                    ((IDictionary<string,object>)request)["price"] = this.parseToNumeric(trailingAmount);
                } else if (isTrue(isTrailingPercentOrder))
                {
                    object requestTrailingPercent = Precise.stringDiv(trailingPercent, "100");
                    ((IDictionary<string,object>)request)["priceRate"] = this.parseToNumeric(requestTrailingPercent);
                }
            }
            if (isTrue(isTrue(isStopLoss) || isTrue(isTakeProfit)))
            {
                object stringifiedAmount = this.numberToString(amount);
                if (isTrue(isStopLoss))
                {
                    object slTriggerPrice = this.safeString2(stopLoss, "triggerPrice", "stopPrice", stopLoss);
                    object slWorkingType = this.safeString(stopLoss, "workingType", "MARK_PRICE");
                    object slType = this.safeString(stopLoss, "type", "STOP_MARKET");
                    object slRequest = new Dictionary<string, object>() {
                        { "stopPrice", this.parseToNumeric(this.priceToPrecision(symbol, slTriggerPrice)) },
                        { "workingType", slWorkingType },
                        { "type", slType },
                    };
                    object slPrice = this.safeString(stopLoss, "price");
                    if (isTrue(!isEqual(slPrice, null)))
                    {
                        ((IDictionary<string,object>)slRequest)["price"] = this.parseToNumeric(this.priceToPrecision(symbol, slPrice));
                    }
                    object slQuantity = this.safeString(stopLoss, "quantity", stringifiedAmount);
                    ((IDictionary<string,object>)slRequest)["quantity"] = this.parseToNumeric(this.amountToPrecision(symbol, slQuantity));
                    ((IDictionary<string,object>)request)["stopLoss"] = this.json(slRequest);
                }
                if (isTrue(isTakeProfit))
                {
                    object tkTriggerPrice = this.safeString2(takeProfit, "triggerPrice", "stopPrice", takeProfit);
                    object tkWorkingType = this.safeString(takeProfit, "workingType", "MARK_PRICE");
                    object tpType = this.safeString(takeProfit, "type", "TAKE_PROFIT_MARKET");
                    object tpRequest = new Dictionary<string, object>() {
                        { "stopPrice", this.parseToNumeric(this.priceToPrecision(symbol, tkTriggerPrice)) },
                        { "workingType", tkWorkingType },
                        { "type", tpType },
                    };
                    object slPrice = this.safeString(takeProfit, "price");
                    if (isTrue(!isEqual(slPrice, null)))
                    {
                        ((IDictionary<string,object>)tpRequest)["price"] = this.parseToNumeric(this.priceToPrecision(symbol, slPrice));
                    }
                    object tkQuantity = this.safeString(takeProfit, "quantity", stringifiedAmount);
                    ((IDictionary<string,object>)tpRequest)["quantity"] = this.parseToNumeric(this.amountToPrecision(symbol, tkQuantity));
                    ((IDictionary<string,object>)request)["takeProfit"] = this.json(tpRequest);
                }
            }
            object positionSide = null;
            object hedged = this.safeBool(parameters, "hedged", false);
            if (isTrue(hedged))
            {
                parameters = this.omit(parameters, "reduceOnly");
                if (isTrue(reduceOnly))
                {
                    positionSide = ((bool) isTrue((isEqual(side, "buy")))) ? "SHORT" : "LONG";
                } else
                {
                    positionSide = ((bool) isTrue((isEqual(side, "buy")))) ? "LONG" : "SHORT";
                }
            } else
            {
                positionSide = "BOTH";
            }
            ((IDictionary<string,object>)request)["positionSide"] = positionSide;
            ((IDictionary<string,object>)request)["quantity"] = ((bool) isTrue((getValue(market, "inverse")))) ? amount : this.parseToNumeric(this.amountToPrecision(symbol, amount)); // precision not available for inverse contracts
        }
        parameters = this.omit(parameters, new List<object>() {"hedged", "triggerPrice", "stopLossPrice", "takeProfitPrice", "trailingAmount", "trailingPercent", "trailingType", "takeProfit", "stopLoss", "clientOrderId"});
        return this.extend(request, parameters);
    }

    /**
     * @method
     * @name bingx#createOrder
     * @description create a trade order
     * @see https://bingx-api.github.io/docs/#/en-us/swapV2/trade-api.html#Trade%20order
     * @see https://bingx-api.github.io/docs/#/en-us/spot/trade-api.html#Create%20an%20Order
     * @see https://bingx-api.github.io/docs/#/en-us/cswap/trade-api.html#Trade%20order
     * @param {string} symbol unified symbol of the market to create an order in
     * @param {string} type 'market' or 'limit'
     * @param {string} side 'buy' or 'sell'
     * @param {float} amount how much you want to trade in units of the base currency
     * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.clientOrderId] a unique id for the order
     * @param {bool} [params.postOnly] true to place a post only order
     * @param {string} [params.timeInForce] spot supports 'PO', 'GTC' and 'IOC', swap supports 'PO', 'GTC', 'IOC' and 'FOK'
     * @param {bool} [params.reduceOnly] *swap only* true or false whether the order is reduce only
     * @param {float} [params.triggerPrice] triggerPrice at which the attached take profit / stop loss order will be triggered
     * @param {float} [params.stopLossPrice] stop loss trigger price
     * @param {float} [params.takeProfitPrice] take profit trigger price
     * @param {float} [params.cost] the quote quantity that can be used as an alternative for the amount
     * @param {float} [params.trailingAmount] *swap only* the quote amount to trail away from the current market price
     * @param {float} [params.trailingPercent] *swap only* the percent to trail away from the current market price
     * @param {object} [params.takeProfit] *takeProfit object in params* containing the triggerPrice at which the attached take profit order will be triggered
     * @param {float} [params.takeProfit.triggerPrice] take profit trigger price
     * @param {object} [params.stopLoss] *stopLoss object in params* containing the triggerPrice at which the attached stop loss order will be triggered
     * @param {float} [params.stopLoss.triggerPrice] stop loss trigger price
     * @param {boolean} [params.test] *swap only* whether to use the test endpoint or not, default is false
     * @param {string} [params.positionSide] *contracts only* "BOTH" for one way mode, "LONG" for buy side of hedged mode, "SHORT" for sell side of hedged mode
     * @param {boolean} [params.hedged] *swap only* whether the order is in hedged mode or one way mode
     * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> createOrder(object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object test = this.safeBool(parameters, "test", false);
        parameters = this.omit(parameters, "test");
        object request = this.createOrderRequest(symbol, type, side, amount, price, parameters);
        object response = null;
        if (isTrue(getValue(market, "swap")))
        {
            if (isTrue(test))
            {
                response = await this.swapV2PrivatePostTradeOrderTest(request);
            } else if (isTrue(getValue(market, "inverse")))
            {
                response = await this.cswapV1PrivatePostTradeOrder(request);
            } else
            {
                response = await this.swapV2PrivatePostTradeOrder(request);
            }
        } else
        {
            response = await this.spotV1PrivatePostTradeOrder(request);
        }
        //
        // spot
        //
        //    {
        //        "code": 0,
        //        "msg": "",
        //        "data": {
        //            "symbol": "XRP-USDT",
        //            "orderId": 1514090846268424192,
        //            "transactTime": 1649822362855,
        //            "price": "0.5",
        //            "origQty": "10",
        //            "executedQty": "0",
        //            "cummulativeQuoteQty": "0",
        //            "status": "PENDING",
        //            "type": "LIMIT",
        //            "side": "BUY"
        //        }
        //    }
        //
        // linear swap
        //
        //     {
        //         "code": 0,
        //         "msg": "",
        //         "data": {
        //             "order": {
        //                 "symbol": "BTC-USDT",
        //                 "orderId": 1709036527545438208,
        //                 "side": "BUY",
        //                 "positionSide": "LONG",
        //                 "type": "TRIGGER_LIMIT",
        //                 "clientOrderID": "",
        //                 "workingType": ""
        //             }
        //         }
        //     }
        //
        // inverse swap
        //
        //     {
        //         "orderId": 1809841379603398656,
        //         "symbol": "SOL-USD",
        //         "positionSide": "LONG",
        //         "side": "BUY",
        //         "type": "LIMIT",
        //         "price": 100,
        //         "quantity": 1,
        //         "stopPrice": 0,
        //         "workingType": "",
        //         "timeInForce": ""
        //     }
        //
        if (isTrue((response is string)))
        {
            // broken api engine : order-ids are too long numbers (i.e. 1742930526912864656)
            // and JSON.parse can not handle them in JS, so we have to use .parseJson
            // however, when order has an attached SL/TP, their value types need extra parsing
            response = this.fixStringifiedJsonMembers(response);
            response = this.parseJson(response);
        }
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        object result = new Dictionary<string, object>() {};
        if (isTrue(getValue(market, "swap")))
        {
            if (isTrue(getValue(market, "inverse")))
            {
                result = response;
            } else
            {
                result = this.safeDict(data, "order", new Dictionary<string, object>() {});
            }
        } else
        {
            result = data;
        }
        return this.parseOrder(result, market);
    }

    /**
     * @method
     * @name bingx#createOrders
     * @description create a list of trade orders
     * @see https://bingx-api.github.io/docs/#/spot/trade-api.html#Batch%20Placing%20Orders
     * @see https://bingx-api.github.io/docs/#/swapV2/trade-api.html#Bulk%20order
     * @param {Array} orders list of orders to create, each object should contain the parameters required by createOrder, namely symbol, type, side, amount, price and params
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {boolean} [params.sync] *spot only* if true, multiple orders are ordered serially and all orders do not require the same symbol/side/type
     * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> createOrders(object orders, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object ordersRequests = new List<object>() {};
        object marketIds = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(orders)); postFixIncrement(ref i))
        {
            object rawOrder = getValue(orders, i);
            object marketId = this.safeString(rawOrder, "symbol");
            object type = this.safeString(rawOrder, "type");
            ((IList<object>)marketIds).Add(marketId);
            object side = this.safeString(rawOrder, "side");
            object amount = this.safeNumber(rawOrder, "amount");
            object price = this.safeNumber(rawOrder, "price");
            object orderParams = this.safeDict(rawOrder, "params", new Dictionary<string, object>() {});
            object orderRequest = this.createOrderRequest(marketId, type, side, amount, price, orderParams);
            ((IList<object>)ordersRequests).Add(orderRequest);
        }
        object symbols = this.marketSymbols(marketIds, null, false, true, true);
        object symbolsLength = getArrayLength(symbols);
        object market = this.market(getValue(symbols, 0));
        object request = new Dictionary<string, object>() {};
        object response = null;
        if (isTrue(getValue(market, "swap")))
        {
            if (isTrue(isGreaterThan(symbolsLength, 5)))
            {
                throw new InvalidOrder ((string)add(this.id, " createOrders() can not create more than 5 orders at once for swap markets")) ;
            }
            ((IDictionary<string,object>)request)["batchOrders"] = this.json(ordersRequests);
            response = await this.swapV2PrivatePostTradeBatchOrders(request);
        } else
        {
            object sync = this.safeBool(parameters, "sync", false);
            if (isTrue(sync))
            {
                ((IDictionary<string,object>)request)["sync"] = true;
            }
            ((IDictionary<string,object>)request)["data"] = this.json(ordersRequests);
            response = await this.spotV1PrivatePostTradeBatchOrders(request);
        }
        //
        // spot
        //
        //     {
        //         "code": 0,
        //         "msg": "",
        //         "debugMsg": "",
        //         "data": {
        //             "orders": [
        //                 {
        //                     "symbol": "BTC-USDT",
        //                     "orderId": 1720661389564968960,
        //                     "transactTime": 1699072618272,
        //                     "price": "25000",
        //                     "origQty": "0.0002",
        //                     "executedQty": "0",
        //                     "cummulativeQuoteQty": "0",
        //                     "status": "PENDING",
        //                     "type": "LIMIT",
        //                     "side": "BUY"
        //                 },
        //             ]
        //         }
        //     }
        //
        // swap
        //
        //     {
        //         "code": 0,
        //         "msg": "",
        //         "data": {
        //             "orders": [
        //                 {
        //                     "symbol": "BTC-USDT",
        //                     "orderId": 1720657081994006528,
        //                     "side": "BUY",
        //                     "positionSide": "LONG",
        //                     "type": "LIMIT",
        //                     "clientOrderID": "",
        //                     "workingType": ""
        //                 },
        //             ]
        //         }
        //     }
        //
        if (isTrue((response is string)))
        {
            // broken api engine : order-ids are too long numbers (i.e. 1742930526912864656)
            // and JSON.parse can not handle them in JS, so we have to use .parseJson
            // however, when order has an attached SL/TP, their value types need extra parsing
            response = this.fixStringifiedJsonMembers(response);
            response = this.parseJson(response);
        }
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        object result = this.safeList(data, "orders", new List<object>() {});
        return this.parseOrders(result, market);
    }

    public virtual object parseOrderSide(object side)
    {
        object sides = new Dictionary<string, object>() {
            { "BUY", "buy" },
            { "SELL", "sell" },
            { "SHORT", "sell" },
            { "LONG", "buy" },
            { "ask", "sell" },
            { "bid", "buy" },
        };
        return this.safeString(sides, side, side);
    }

    public virtual object parseOrderType(object type)
    {
        object types = new Dictionary<string, object>() {
            { "trigger_market", "market" },
            { "trigger_limit", "limit" },
            { "stop_limit", "limit" },
            { "stop_market", "market" },
            { "take_profit_market", "market" },
            { "stop", "limit" },
        };
        return this.safeString(types, type, type);
    }

    public override object parseOrder(object order, object market = null)
    {
        //
        // spot
        // createOrder, createOrders, cancelOrder
        //
        //    {
        //        "symbol": "XRP-USDT",
        //        "orderId": 1514090846268424192,
        //        "transactTime": 1649822362855,
        //        "price": "0.5",
        //        "origQty": "10",
        //        "executedQty": "0",
        //        "cummulativeQuoteQty": "0",
        //        "status": "PENDING",
        //        "type": "LIMIT",
        //        "side": "BUY"
        //    }
        //
        // fetchOrder
        //
        //    {
        //        "symbol": "ETH-USDT",
        //        "orderId": "1660602123001266176",
        //        "price": "1700",
        //        "origQty": "0.003",
        //        "executedQty": "0",
        //        "cummulativeQuoteQty": "0",
        //        "status": "PENDING",
        //        "type": "LIMIT",
        //        "side": "BUY",
        //        "time": "1684753373276",
        //        "updateTime": "1684753373276",
        //        "origQuoteOrderQty": "0",
        //        "fee": "0",
        //        "feeAsset": "ETH"
        //    }
        //
        // fetchOpenOrders, fetchClosedOrders
        //
        //   {
        //       "symbol": "XRP-USDT",
        //       "orderId": 1514073325788200960,
        //       "price": "0.5",
        //       "StopPrice": "0",
        //       "origQty": "20",
        //       "executedQty": "10",
        //       "cummulativeQuoteQty": "5",
        //       "status": "PENDING",
        //       "type": "LIMIT",
        //       "side": "BUY",
        //       "time": 1649818185647,
        //       "updateTime": 1649818185647,
        //       "origQuoteOrderQty": "0"
        //       "fee": "-0.01"
        //   }
        //
        //
        // linear swap
        // createOrder, createOrders
        //
        //    {
        //      "symbol": "BTC-USDT",
        //      "orderId": 1590973236294713344,
        //      "side": "BUY",
        //      "positionSide": "LONG",
        //      "type": "LIMIT"
        //    }
        //
        // inverse swap createOrder
        //
        //     {
        //         "orderId": 1809841379603398656,
        //         "symbol": "SOL-USD",
        //         "positionSide": "LONG",
        //         "side": "BUY",
        //         "type": "LIMIT",
        //         "price": 100,
        //         "quantity": 1,
        //         "stopPrice": 0,
        //         "workingType": "",
        //         "timeInForce": ""
        //     }
        //
        // fetchOrder, fetchOpenOrders, fetchClosedOrders
        //
        //     {
        //         "symbol": "BTC-USDT",
        //         "orderId": 1709036527545438208,
        //         "side": "BUY",
        //         "positionSide": "LONG",
        //         "type": "TRIGGER_LIMIT",
        //         "origQty": "0.0010",
        //         "price": "22000.0",
        //         "executedQty": "0.0000",
        //         "avgPrice": "0.0",
        //         "cumQuote": "",
        //         "stopPrice": "23000.0",
        //         "profit": "",
        //         "commission": "",
        //         "status": "NEW",
        //         "time": 1696301035187,
        //         "updateTime": 1696301035187,
        //         "clientOrderId": "",
        //         "leverage": "",
        //         "takeProfit": "",
        //         "stopLoss": "",
        //         "advanceAttr": 0,
        //         "positionID": 0,
        //         "takeProfitEntrustPrice": 0,
        //         "stopLossEntrustPrice": 0,
        //         "orderType": "",
        //         "workingType": "MARK_PRICE"
        //     }
        // with tp and sl
        //    {
        //        orderId: 1741440894764281900,
        //        symbol: 'LTC-USDT',
        //        positionSide: 'LONG',
        //        side: 'BUY',
        //        type: 'MARKET',
        //        price: 0,
        //        quantity: 1,
        //        stopPrice: 0,
        //        workingType: 'MARK_PRICE',
        //        clientOrderID: '',
        //        timeInForce: 'GTC',
        //        priceRate: 0,
        //        stopLoss: '{"stopPrice":50,"workingType":"MARK_PRICE","type":"STOP_MARKET","quantity":1}',
        //        takeProfit: '{"stopPrice":150,"workingType":"MARK_PRICE","type":"TAKE_PROFIT_MARKET","quantity":1}',
        //        reduceOnly: false
        //    }
        //
        // editOrder (swap)
        //
        //    {
        //        cancelResult: 'true',
        //        cancelMsg: '',
        //        cancelResponse: {
        //            cancelClientOrderId: '',
        //            cancelOrderId: '1755336244265705472',
        //            symbol: 'SOL-USDT',
        //            orderId: '1755336244265705472',
        //            side: 'SELL',
        //            positionSide: 'SHORT',
        //            type: 'LIMIT',
        //            origQty: '1',
        //            price: '100.000',
        //            executedQty: '0',
        //            avgPrice: '0.000',
        //            cumQuote: '0',
        //            stopPrice: '',
        //            profit: '0.0000',
        //            commission: '0.000000',
        //            status: 'PENDING',
        //            time: '1707339747860',
        //            updateTime: '1707339747860',
        //            clientOrderId: '',
        //            leverage: '20X',
        //            workingType: 'MARK_PRICE',
        //            onlyOnePosition: false,
        //            reduceOnly: false
        //        },
        //        replaceResult: 'true',
        //        replaceMsg: '',
        //        newOrderResponse: {
        //            orderId: '1755338440612995072',
        //            symbol: 'SOL-USDT',
        //            positionSide: 'SHORT',
        //            side: 'SELL',
        //            type: 'LIMIT',
        //            price: '99',
        //            quantity: '2',
        //            stopPrice: '0',
        //            workingType: 'MARK_PRICE',
        //            clientOrderID: '',
        //            timeInForce: 'GTC',
        //            priceRate: '0',
        //            stopLoss: '',
        //            takeProfit: '',
        //            reduceOnly: false
        //        }
        //    }
        //
        // editOrder (spot)
        //
        //    {
        //        cancelResult: { code: '0', msg: '', result: true },
        //        openResult: { code: '0', msg: '', result: true },
        //        orderOpenResponse: {
        //            symbol: 'SOL-USDT',
        //            orderId: '1755334007697866752',
        //            transactTime: '1707339214620',
        //            price: '99',
        //            stopPrice: '0',
        //            origQty: '0.2',
        //            executedQty: '0',
        //            cummulativeQuoteQty: '0',
        //            status: 'PENDING',
        //            type: 'LIMIT',
        //            side: 'SELL',
        //            clientOrderID: ''
        //        },
        //        orderCancelResponse: {
        //            symbol: 'SOL-USDT',
        //            orderId: '1755117055251480576',
        //            price: '100',
        //            stopPrice: '0',
        //            origQty: '0.2',
        //            executedQty: '0',
        //            cummulativeQuoteQty: '0',
        //            status: 'CANCELED',
        //            type: 'LIMIT',
        //            side: 'SELL'
        //        }
        //    }
        //
        // stop loss order
        //
        //    {
        //        "symbol": "ETH-USDT",
        //        "orderId": "1792461744476422144",
        //        "price": "2775.65",
        //        "StopPrice": "2778.42",
        //        "origQty": "0.032359",
        //        "executedQty": "0",
        //        "cummulativeQuoteQty": "0",
        //        "status": "NEW",
        //        "type": "TAKE_STOP_LIMIT",
        //        "side": "SELL",
        //        "time": "1716191156868",
        //        "updateTime": "1716191156868",
        //        "origQuoteOrderQty": "0",
        //        "fee": "0",
        //        "feeAsset": "USDT",
        //        "clientOrderID": ""
        //    }
        //
        // inverse swap cancelAllOrders, cancelOrder, fetchOrder, fetchOpenOrders, fetchClosedOrders, fetchCanceledOrders
        //
        //     {
        //         "symbol": "SOL-USD",
        //         "orderId": "1809845251327672320",
        //         "side": "BUY",
        //         "positionSide": "LONG",
        //         "type": "LIMIT",
        //         "quantity": 1,
        //         "origQty": "0",
        //         "price": "90",
        //         "executedQty": "0",
        //         "avgPrice": "0",
        //         "cumQuote": "0",
        //         "stopPrice": "",
        //         "profit": "0.0000",
        //         "commission": "0.000000",
        //         "status": "CANCELLED",
        //         "time": 1720335707872,
        //         "updateTime": 1720335707912,
        //         "clientOrderId": "",
        //         "leverage": "",
        //         "takeProfit": {
        //             "type": "",
        //             "quantity": 0,
        //             "stopPrice": 0,
        //             "price": 0,
        //             "workingType": "",
        //             "stopGuaranteed": ""
        //         },
        //         "stopLoss": {
        //             "type": "",
        //             "quantity": 0,
        //             "stopPrice": 0,
        //             "price": 0,
        //             "workingType": "",
        //             "stopGuaranteed": ""
        //         },
        //         "advanceAttr": 0,
        //         "positionID": 0,
        //         "takeProfitEntrustPrice": 0,
        //         "stopLossEntrustPrice": 0,
        //         "orderType": "",
        //         "workingType": ""
        //     }
        //
        object info = order;
        object newOrder = this.safeDict2(order, "newOrderResponse", "orderOpenResponse");
        if (isTrue(!isEqual(newOrder, null)))
        {
            order = newOrder;
        }
        object positionSide = this.safeString2(order, "positionSide", "ps");
        object marketType = ((bool) isTrue((isEqual(positionSide, null)))) ? "spot" : "swap";
        object marketId = this.safeString2(order, "symbol", "s");
        if (isTrue(isEqual(market, null)))
        {
            market = this.safeMarket(marketId, null, null, marketType);
        }
        object side = this.safeStringLower2(order, "side", "S");
        object timestamp = this.safeIntegerN(order, new List<object>() {"time", "transactTime", "E"});
        object lastTradeTimestamp = this.safeInteger2(order, "updateTime", "T");
        object statusId = this.safeStringUpper2(order, "status", "X");
        object feeCurrencyCode = this.safeString2(order, "feeAsset", "N");
        object feeCost = this.safeStringN(order, new List<object>() {"fee", "commission", "n"});
        if (isTrue((isEqual(feeCurrencyCode, null))))
        {
            if (isTrue(getValue(market, "spot")))
            {
                if (isTrue(isEqual(side, "buy")))
                {
                    feeCurrencyCode = getValue(market, "base");
                } else
                {
                    feeCurrencyCode = getValue(market, "quote");
                }
            } else
            {
                feeCurrencyCode = getValue(market, "quote");
            }
        }
        object stopLoss = this.safeValue(order, "stopLoss");
        object stopLossPrice = null;
        if (isTrue(isTrue((!isEqual(stopLoss, null))) && isTrue((!isEqual(stopLoss, "")))))
        {
            stopLossPrice = this.omitZero(this.safeString(stopLoss, "stopLoss"));
        }
        if (isTrue(isTrue(isTrue((!isEqual(stopLoss, null))) && isTrue((!(stopLoss is Int64 || stopLoss is int || stopLoss is float || stopLoss is double)))) && isTrue((!isEqual(stopLoss, "")))))
        {
            //  stopLoss: '{"stopPrice":50,"workingType":"MARK_PRICE","type":"STOP_MARKET","quantity":1}',
            if (isTrue((stopLoss is string)))
            {
                stopLoss = this.parseJson(stopLoss);
            }
            stopLossPrice = this.omitZero(this.safeString(stopLoss, "stopPrice"));
        }
        object takeProfit = this.safeValue(order, "takeProfit");
        object takeProfitPrice = null;
        if (isTrue(isTrue(!isEqual(takeProfit, null)) && isTrue((!isEqual(takeProfit, "")))))
        {
            takeProfitPrice = this.omitZero(this.safeString(takeProfit, "takeProfit"));
        }
        if (isTrue(isTrue(isTrue((!isEqual(takeProfit, null))) && isTrue((!(takeProfit is Int64 || takeProfit is int || takeProfit is float || takeProfit is double)))) && isTrue((!isEqual(takeProfit, "")))))
        {
            //  takeProfit: '{"stopPrice":150,"workingType":"MARK_PRICE","type":"TAKE_PROFIT_MARKET","quantity":1}',
            if (isTrue((takeProfit is string)))
            {
                takeProfit = this.parseJson(takeProfit);
            }
            takeProfitPrice = this.omitZero(this.safeString(takeProfit, "stopPrice"));
        }
        object rawType = this.safeStringLower2(order, "type", "o");
        object stopPrice = this.omitZero(this.safeString2(order, "StopPrice", "stopPrice"));
        object triggerPrice = stopPrice;
        if (isTrue(!isEqual(stopPrice, null)))
        {
            if (isTrue(isTrue((isGreaterThan(getIndexOf(rawType, "stop"), -1))) && isTrue((isEqual(stopLossPrice, null)))))
            {
                stopLossPrice = stopPrice;
                triggerPrice = null;
            }
            if (isTrue(isTrue((isGreaterThan(getIndexOf(rawType, "take"), -1))) && isTrue((isEqual(takeProfitPrice, null)))))
            {
                takeProfitPrice = stopPrice;
                triggerPrice = null;
            }
        }
        return this.safeOrder(new Dictionary<string, object>() {
            { "info", info },
            { "id", this.safeString2(order, "orderId", "i") },
            { "clientOrderId", this.safeStringN(order, new List<object>() {"clientOrderID", "clientOrderId", "origClientOrderId", "c"}) },
            { "symbol", this.safeSymbol(marketId, market, "-", marketType) },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "lastTradeTimestamp", lastTradeTimestamp },
            { "lastUpdateTimestamp", this.safeInteger(order, "updateTime") },
            { "type", this.parseOrderType(rawType) },
            { "timeInForce", this.safeString(order, "timeInForce") },
            { "postOnly", null },
            { "side", this.parseOrderSide(side) },
            { "price", this.safeString2(order, "price", "p") },
            { "stopPrice", triggerPrice },
            { "triggerPrice", triggerPrice },
            { "stopLossPrice", stopLossPrice },
            { "takeProfitPrice", takeProfitPrice },
            { "average", this.safeString2(order, "avgPrice", "ap") },
            { "cost", this.safeString(order, "cummulativeQuoteQty") },
            { "amount", this.safeStringN(order, new List<object>() {"origQty", "q", "quantity"}) },
            { "filled", this.safeString2(order, "executedQty", "z") },
            { "remaining", null },
            { "status", this.parseOrderStatus(statusId) },
            { "fee", new Dictionary<string, object>() {
                { "currency", feeCurrencyCode },
                { "cost", Precise.stringAbs(feeCost) },
            } },
            { "trades", null },
            { "reduceOnly", this.safeBool2(order, "reduceOnly", "ro") },
        }, market);
    }

    public virtual object parseOrderStatus(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "NEW", "open" },
            { "PENDING", "open" },
            { "PARTIALLY_FILLED", "open" },
            { "FILLED", "closed" },
            { "CANCELED", "canceled" },
            { "CANCELLED", "canceled" },
            { "FAILED", "canceled" },
        };
        return this.safeString(statuses, status, status);
    }

    /**
     * @method
     * @name bingx#cancelOrder
     * @description cancels an open order
     * @see https://bingx-api.github.io/docs/#/en-us/spot/trade-api.html#Cancel%20Order
     * @see https://bingx-api.github.io/docs/#/en-us/swapV2/trade-api.html#Cancel%20Order
     * @see https://bingx-api.github.io/docs/#/en-us/cswap/trade-api.html#Cancel%20an%20Order
     * @param {string} id order id
     * @param {string} symbol unified symbol of the market the order was made in
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.clientOrderId] a unique id for the order
     * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> cancelOrder(object id, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " cancelOrder() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object clientOrderId = this.safeString2(parameters, "clientOrderId", "clientOrderID");
        parameters = this.omit(parameters, new List<object>() {"clientOrderId"});
        if (isTrue(!isEqual(clientOrderId, null)))
        {
            ((IDictionary<string,object>)request)["clientOrderID"] = clientOrderId;
        } else
        {
            ((IDictionary<string,object>)request)["orderId"] = id;
        }
        object response = null;
        object type = null;
        object subType = null;
        var typeparametersVariable = this.handleMarketTypeAndParams("cancelOrder", market, parameters);
        type = ((IList<object>)typeparametersVariable)[0];
        parameters = ((IList<object>)typeparametersVariable)[1];
        var subTypeparametersVariable = this.handleSubTypeAndParams("cancelOrder", market, parameters);
        subType = ((IList<object>)subTypeparametersVariable)[0];
        parameters = ((IList<object>)subTypeparametersVariable)[1];
        if (isTrue(isEqual(type, "spot")))
        {
            response = await this.spotV1PrivatePostTradeCancel(this.extend(request, parameters));
        } else
        {
            if (isTrue(isEqual(subType, "inverse")))
            {
                response = await this.cswapV1PrivateDeleteTradeCancelOrder(this.extend(request, parameters));
            } else
            {
                response = await this.swapV2PrivateDeleteTradeOrder(this.extend(request, parameters));
            }
        }
        //
        // spot
        //
        //   {
        //       "code": 0,
        //       "msg": "",
        //       "data": {
        //           "symbol": "XRP-USDT",
        //           "orderId": 1514090846268424192,
        //           "price": "0.5",
        //           "origQty": "10",
        //           "executedQty": "0",
        //           "cummulativeQuoteQty": "0",
        //           "status": "CANCELED",
        //           "type": "LIMIT",
        //           "side": "BUY"
        //       }
        //   }
        //
        // inverse swap
        //
        //     {
        //         "code": 0,
        //         "msg": "",
        //         "data": {
        //             "order": {
        //                 "symbol": "SOL-USD",
        //                 "orderId": "1816002957423951872",
        //                 "side": "BUY",
        //                 "positionSide": "Long",
        //                 "type": "Pending",
        //                 "quantity": 0,
        //                 "origQty": "0",
        //                 "price": "150",
        //                 "executedQty": "0",
        //                 "avgPrice": "0",
        //                 "cumQuote": "0",
        //                 "stopPrice": "",
        //                 "profit": "0.0000",
        //                 "commission": "0.000000",
        //                 "status": "CANCELLED",
        //                 "time": 1721803819410,
        //                 "updateTime": 1721803819427,
        //                 "clientOrderId": "",
        //                 "leverage": "",
        //                 "takeProfit": {
        //                     "type": "",
        //                     "quantity": 0,
        //                     "stopPrice": 0,
        //                     "price": 0,
        //                     "workingType": "",
        //                     "stopGuaranteed": ""
        //                 },
        //                 "stopLoss": {
        //                     "type": "",
        //                     "quantity": 0,
        //                     "stopPrice": 0,
        //                     "price": 0,
        //                     "workingType": "",
        //                     "stopGuaranteed": ""
        //                 },
        //                 "advanceAttr": 0,
        //                 "positionID": 0,
        //                 "takeProfitEntrustPrice": 0,
        //                 "stopLossEntrustPrice": 0,
        //                 "orderType": "",
        //                 "workingType": ""
        //             }
        //         }
        //     }
        //
        // linear swap
        //
        //    {
        //        "code": 0,
        //        "msg": "",
        //        "data": {
        //          "order": {
        //            "symbol": "LINK-USDT",
        //            "orderId": 1597783850786750464,
        //            "side": "BUY",
        //            "positionSide": "LONG",
        //            "type": "TRIGGER_MARKET",
        //            "origQty": "5.0",
        //            "price": "5.0000",
        //            "executedQty": "0.0",
        //            "avgPrice": "0.0000",
        //            "cumQuote": "0",
        //            "stopPrice": "5.0000",
        //            "profit": "",
        //            "commission": "",
        //            "status": "CANCELLED",
        //            "time": 1669776330000,
        //            "updateTime": 1669776330000
        //          }
        //        }
        //    }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        object order = this.safeDict(data, "order", data);
        return this.parseOrder(order, market);
    }

    /**
     * @method
     * @name bingx#cancelAllOrders
     * @description cancel all open orders
     * @see https://bingx-api.github.io/docs/#/en-us/spot/trade-api.html#Cancel%20orders%20by%20symbol
     * @see https://bingx-api.github.io/docs/#/swapV2/trade-api.html#Cancel%20All%20Orders
     * @see https://bingx-api.github.io/docs/#/en-us/cswap/trade-api.html#Cancel%20all%20orders
     * @param {string} [symbol] unified market symbol, only orders in the market of this symbol are cancelled when symbol is not undefined
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> cancelAllOrders(object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " cancelAllOrders() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object response = null;
        if (isTrue(getValue(market, "spot")))
        {
            response = await this.spotV1PrivatePostTradeCancelOpenOrders(this.extend(request, parameters));
        } else if (isTrue(getValue(market, "swap")))
        {
            if (isTrue(getValue(market, "inverse")))
            {
                response = await this.cswapV1PrivateDeleteTradeAllOpenOrders(this.extend(request, parameters));
            } else
            {
                response = await this.swapV2PrivateDeleteTradeAllOpenOrders(this.extend(request, parameters));
            }
        } else
        {
            throw new BadRequest ((string)add(this.id, " cancelAllOrders is only supported for spot and swap markets.")) ;
        }
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        object orders = this.safeList2(data, "success", "orders", new List<object>() {});
        return this.parseOrders(orders);
    }

    /**
     * @method
     * @name bingx#cancelOrders
     * @description cancel multiple orders
     * @see https://bingx-api.github.io/docs/#/swapV2/trade-api.html#Cancel%20a%20Batch%20of%20Orders
     * @see https://bingx-api.github.io/docs/#/spot/trade-api.html#Cancel%20a%20Batch%20of%20Orders
     * @param {string[]} ids order ids
     * @param {string} symbol unified market symbol, default is undefined
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string[]} [params.clientOrderIds] client order ids
     * @returns {object} an list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async virtual Task<object> cancelOrders(object ids, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " cancelOrders() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object clientOrderIds = this.safeValue(parameters, "clientOrderIds");
        parameters = this.omit(parameters, "clientOrderIds");
        object idsToParse = ids;
        object areClientOrderIds = (!isEqual(clientOrderIds, null));
        if (isTrue(areClientOrderIds))
        {
            idsToParse = clientOrderIds;
        }
        object parsedIds = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(idsToParse)); postFixIncrement(ref i))
        {
            object id = getValue(idsToParse, i);
            object stringId = ((object)id).ToString();
            ((IList<object>)parsedIds).Add(stringId);
        }
        object response = null;
        if (isTrue(getValue(market, "spot")))
        {
            object spotReqKey = ((bool) isTrue(areClientOrderIds)) ? "clientOrderIDs" : "orderIds";
            ((IDictionary<string,object>)request)[(string)spotReqKey] = String.Join(",", ((IList<object>)parsedIds).ToArray());
            response = await this.spotV1PrivatePostTradeCancelOrders(this.extend(request, parameters));
        } else
        {
            if (isTrue(areClientOrderIds))
            {
                ((IDictionary<string,object>)request)["clientOrderIDList"] = this.json(parsedIds);
            } else
            {
                ((IDictionary<string,object>)request)["orderIdList"] = parsedIds;
            }
            response = await this.swapV2PrivateDeleteTradeBatchOrders(this.extend(request, parameters));
        }
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        object success = this.safeList2(data, "success", "orders", new List<object>() {});
        return this.parseOrders(success);
    }

    /**
     * @method
     * @name bingx#cancelAllOrdersAfter
     * @description dead man's switch, cancel all orders after the given timeout
     * @see https://bingx-api.github.io/docs/#/en-us/spot/trade-api.html#Cancel%20all%20orders%20in%20countdown
     * @see https://bingx-api.github.io/docs/#/en-us/swapV2/trade-api.html#Cancel%20all%20orders%20in%20countdown
     * @param {number} timeout time in milliseconds, 0 represents cancel the timer
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.type] spot or swap market
     * @returns {object} the api result
     */
    public async override Task<object> cancelAllOrdersAfter(object timeout, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object isActive = (isGreaterThan(timeout, 0));
        object request = new Dictionary<string, object>() {
            { "type", ((bool) isTrue((isActive))) ? "ACTIVATE" : "CLOSE" },
            { "timeOut", ((bool) isTrue((isActive))) ? (this.parseToInt(divide(timeout, 1000))) : 0 },
        };
        object response = null;
        object type = null;
        var typeparametersVariable = this.handleMarketTypeAndParams("cancelAllOrdersAfter", null, parameters);
        type = ((IList<object>)typeparametersVariable)[0];
        parameters = ((IList<object>)typeparametersVariable)[1];
        if (isTrue(isEqual(type, "spot")))
        {
            response = await this.spotV1PrivatePostTradeCancelAllAfter(this.extend(request, parameters));
        } else if (isTrue(isEqual(type, "swap")))
        {
            response = await this.swapV2PrivatePostTradeCancelAllAfter(this.extend(request, parameters));
        } else
        {
            throw new NotSupported ((string)add(add(add(this.id, " cancelAllOrdersAfter() is not supported for "), type), " markets")) ;
        }
        //
        //     {
        //         code: '0',
        //         msg: '',
        //         data: {
        //             triggerTime: '1712645434',
        //             status: 'ACTIVATED',
        //             note: 'All your perpetual pending orders will be closed automatically at 2024-04-09 06:50:34 UTC(+0),before that you can cancel the timer, or extend triggerTime time by this request'
        //         }
        //     }
        //
        return response;
    }

    /**
     * @method
     * @name bingx#fetchOrder
     * @description fetches information on an order made by the user
     * @see https://bingx-api.github.io/docs/#/en-us/spot/trade-api.html#Query%20Order%20details
     * @see https://bingx-api.github.io/docs/#/en-us/swapV2/trade-api.html#Query%20Order%20details
     * @see https://bingx-api.github.io/docs/#/en-us/cswap/trade-api.html#Query%20Order
     * @param {string} id the order id
     * @param {string} symbol unified symbol of the market the order was made in
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> fetchOrder(object id, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchOrder() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
            { "orderId", id },
        };
        object type = null;
        object subType = null;
        object response = null;
        var typeparametersVariable = this.handleMarketTypeAndParams("fetchOrder", market, parameters);
        type = ((IList<object>)typeparametersVariable)[0];
        parameters = ((IList<object>)typeparametersVariable)[1];
        var subTypeparametersVariable = this.handleSubTypeAndParams("fetchOrder", market, parameters);
        subType = ((IList<object>)subTypeparametersVariable)[0];
        parameters = ((IList<object>)subTypeparametersVariable)[1];
        if (isTrue(isEqual(type, "spot")))
        {
            response = await this.spotV1PrivateGetTradeQuery(this.extend(request, parameters));
        } else
        {
            if (isTrue(isEqual(subType, "inverse")))
            {
                response = await this.cswapV1PrivateGetTradeOrderDetail(this.extend(request, parameters));
            } else
            {
                response = await this.swapV2PrivateGetTradeOrder(this.extend(request, parameters));
            }
        }
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        object order = this.safeDict(data, "order", data);
        return this.parseOrder(order, market);
    }

    /**
     * @method
     * @name bingx#fetchOrders
     * @description fetches information on multiple orders made by the user
     * @see https://bingx-api.github.io/docs/#/en-us/swapV2/trade-api.html#User's%20All%20Orders
     * @param {string} symbol unified market symbol of the market orders were made in
     * @param {int} [since] the earliest time in ms to fetch orders for
     * @param {int} [limit] the maximum number of order structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {int} [params.until] the latest time in ms to fetch entries for
     * @param {int} [params.orderId] Only return subsequent orders, and return the latest order by default
     * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> fetchOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
        }
        object type = null;
        var typeparametersVariable = this.handleMarketTypeAndParams("fetchOrders", market, parameters);
        type = ((IList<object>)typeparametersVariable)[0];
        parameters = ((IList<object>)typeparametersVariable)[1];
        if (isTrue(!isEqual(type, "swap")))
        {
            throw new NotSupported ((string)add(this.id, " fetchOrders() is only supported for swap markets")) ;
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["startTime"] = since;
        }
        object until = this.safeInteger(parameters, "until"); // unified in milliseconds
        object endTime = this.safeInteger(parameters, "endTime", until); // exchange-specific in milliseconds
        parameters = this.omit(parameters, new List<object>() {"endTime", "until"});
        if (isTrue(!isEqual(endTime, null)))
        {
            ((IDictionary<string,object>)request)["endTime"] = endTime;
        }
        object response = await this.swapV1PrivateGetTradeFullOrder(this.extend(request, parameters));
        //
        //     {
        //         "code": 0,
        //         "msg": "",
        //         "data": {
        //         "orders": [
        //           {
        //             "symbol": "PYTH-USDT",
        //             "orderId": 1736007506620112100,
        //             "side": "SELL",
        //             "positionSide": "SHORT",
        //             "type": "LIMIT",
        //             "origQty": "33",
        //             "price": "0.3916",
        //             "executedQty": "33",
        //             "avgPrice": "0.3916",
        //             "cumQuote": "13",
        //             "stopPrice": "",
        //             "profit": "0.0000",
        //             "commission": "-0.002585",
        //             "status": "FILLED",
        //             "time": 1702731418000,
        //             "updateTime": 1702731470000,
        //             "clientOrderId": "",
        //             "leverage": "15X",
        //             "takeProfit": {
        //                 "type": "TAKE_PROFIT",
        //                 "quantity": 0,
        //                 "stopPrice": 0,
        //                 "price": 0,
        //                 "workingType": ""
        //             },
        //             "stopLoss": {
        //                 "type": "STOP",
        //                 "quantity": 0,
        //                 "stopPrice": 0,
        //                 "price": 0,
        //                 "workingType": ""
        //             },
        //             "advanceAttr": 0,
        //             "positionID": 0,
        //             "takeProfitEntrustPrice": 0,
        //             "stopLossEntrustPrice": 0,
        //             "orderType": "",
        //             "workingType": "MARK_PRICE",
        //             "stopGuaranteed": false,
        //             "triggerOrderId": 1736012449498123500
        //           }
        //         ]
        //       }
        //     }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        object orders = this.safeList(data, "orders", new List<object>() {});
        return this.parseOrders(orders, market, since, limit);
    }

    /**
     * @method
     * @name bingx#fetchOpenOrders
     * @description fetch all unfilled currently open orders
     * @see https://bingx-api.github.io/docs/#/en-us/spot/trade-api.html#Current%20Open%20Orders
     * @see https://bingx-api.github.io/docs/#/en-us/swapV2/trade-api.html#Current%20All%20Open%20Orders
     * @see https://bingx-api.github.io/docs/#/en-us/cswap/trade-api.html#Query%20all%20current%20pending%20orders
     * @param {string} symbol unified market symbol
     * @param {int} [since] the earliest time in ms to fetch open orders for
     * @param {int} [limit] the maximum number of open order structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> fetchOpenOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = null;
        object request = new Dictionary<string, object>() {};
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
        }
        object type = null;
        object subType = null;
        object response = null;
        var typeparametersVariable = this.handleMarketTypeAndParams("fetchOpenOrders", market, parameters);
        type = ((IList<object>)typeparametersVariable)[0];
        parameters = ((IList<object>)typeparametersVariable)[1];
        var subTypeparametersVariable = this.handleSubTypeAndParams("fetchOpenOrders", market, parameters);
        subType = ((IList<object>)subTypeparametersVariable)[0];
        parameters = ((IList<object>)subTypeparametersVariable)[1];
        if (isTrue(isEqual(type, "spot")))
        {
            response = await this.spotV1PrivateGetTradeOpenOrders(this.extend(request, parameters));
        } else
        {
            if (isTrue(isEqual(subType, "inverse")))
            {
                response = await this.cswapV1PrivateGetTradeOpenOrders(this.extend(request, parameters));
            } else
            {
                response = await this.swapV2PrivateGetTradeOpenOrders(this.extend(request, parameters));
            }
        }
        //
        //  spot
        //
        //    {
        //        "code": 0,
        //        "msg": "",
        //        "data": {
        //            "orders": [
        //                {
        //                    "symbol": "XRP-USDT",
        //                    "orderId": 1514073325788200960,
        //                    "price": "0.5",
        //                    "origQty": "20",
        //                    "executedQty": "0",
        //                    "cummulativeQuoteQty": "0",
        //                    "status": "PENDING",
        //                    "type": "LIMIT",
        //                    "side": "BUY",
        //                    "time": 1649818185647,
        //                    "updateTime": 1649818185647,
        //                    "origQuoteOrderQty": "0"
        //                }
        //            ]
        //        }
        //    }
        //
        // inverse swap
        //
        //     {
        //         "code": 0,
        //         "msg": "",
        //         "data": {
        //             "orders": [
        //                 {
        //                     "symbol": "SOL-USD",
        //                     "orderId": "1816013900044320768",
        //                     "side": "BUY",
        //                     "positionSide": "Long",
        //                     "type": "LIMIT",
        //                     "quantity": 1,
        //                     "origQty": "",
        //                     "price": "150",
        //                     "executedQty": "0",
        //                     "avgPrice": "0.000",
        //                     "cumQuote": "",
        //                     "stopPrice": "",
        //                     "profit": "0.0000",
        //                     "commission": "0.0000",
        //                     "status": "Pending",
        //                     "time": 1721806428334,
        //                     "updateTime": 1721806428352,
        //                     "clientOrderId": "",
        //                     "leverage": "",
        //                     "takeProfit": {
        //                         "type": "TAKE_PROFIT",
        //                         "quantity": 0,
        //                         "stopPrice": 0,
        //                         "price": 0,
        //                         "workingType": "MARK_PRICE",
        //                         "stopGuaranteed": ""
        //                     },
        //                     "stopLoss": {
        //                         "type": "STOP",
        //                         "quantity": 0,
        //                         "stopPrice": 0,
        //                         "price": 0,
        //                         "workingType": "MARK_PRICE",
        //                         "stopGuaranteed": ""
        //                     },
        //                     "advanceAttr": 0,
        //                     "positionID": 0,
        //                     "takeProfitEntrustPrice": 0,
        //                     "stopLossEntrustPrice": 0,
        //                     "orderType": "",
        //                     "workingType": "MARK_PRICE"
        //                 }
        //             ]
        //         }
        //     }
        //
        // linear swap
        //
        //    {
        //        "code": 0,
        //        "msg": "",
        //        "data": {
        //          "orders": [
        //            {
        //              "symbol": "LINK-USDT",
        //              "orderId": 1585839271162413056,
        //              "side": "BUY",
        //              "positionSide": "LONG",
        //              "type": "TRIGGER_MARKET",
        //              "origQty": "5.0",
        //              "price": "9",
        //              "executedQty": "0.0",
        //              "avgPrice": "0",
        //              "cumQuote": "0",
        //              "stopPrice": "5",
        //              "profit": "0.0000",
        //              "commission": "0.000000",
        //              "status": "CANCELLED",
        //              "time": 1667631605000,
        //              "updateTime": 1667631605000
        //            },
        //          ]
        //        }
        //    }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        object orders = this.safeList(data, "orders", new List<object>() {});
        return this.parseOrders(orders, market, since, limit);
    }

    /**
     * @method
     * @name bingx#fetchClosedOrders
     * @description fetches information on multiple closed orders made by the user
     * @see https://bingx-api.github.io/docs/#/en-us/spot/trade-api.html#Query%20Order%20history
     * @see https://bingx-api.github.io/docs/#/en-us/swapV2/trade-api.html#Query%20Order%20history
     * @see https://bingx-api.github.io/docs/#/en-us/cswap/trade-api.html#User's%20History%20Orders
     * @see https://bingx-api.github.io/docs/#/standard/contract-interface.html#Historical%20order
     * @param {string} symbol unified market symbol of the closed orders
     * @param {int} [since] timestamp in ms of the earliest order
     * @param {int} [limit] the max number of closed orders to return
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {int} [params.until] the latest time in ms to fetch orders for
     * @param {boolean} [params.standard] whether to fetch standard contract orders
     * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> fetchClosedOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object orders = await this.fetchCanceledAndClosedOrders(symbol, since, limit, parameters);
        return this.filterBy(orders, "status", "closed");
    }

    /**
     * @method
     * @name bingx#fetchCanceledOrders
     * @description fetches information on multiple canceled orders made by the user
     * @see https://bingx-api.github.io/docs/#/en-us/spot/trade-api.html#Query%20Order%20history
     * @see https://bingx-api.github.io/docs/#/en-us/swapV2/trade-api.html#Query%20Order%20history
     * @see https://bingx-api.github.io/docs/#/en-us/cswap/trade-api.html#User's%20History%20Orders
     * @see https://bingx-api.github.io/docs/#/standard/contract-interface.html#Historical%20order
     * @param {string} symbol unified market symbol of the canceled orders
     * @param {int} [since] timestamp in ms of the earliest order
     * @param {int} [limit] the max number of canceled orders to return
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {int} [params.until] the latest time in ms to fetch orders for
     * @param {boolean} [params.standard] whether to fetch standard contract orders
     * @returns {object} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async virtual Task<object> fetchCanceledOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object orders = await this.fetchCanceledAndClosedOrders(symbol, since, limit, parameters);
        return this.filterBy(orders, "status", "canceled");
    }

    /**
     * @method
     * @name bingx#fetchCanceledAndClosedOrders
     * @description fetches information on multiple closed orders made by the user
     * @see https://bingx-api.github.io/docs/#/en-us/spot/trade-api.html#Query%20Order%20history
     * @see https://bingx-api.github.io/docs/#/en-us/swapV2/trade-api.html#Query%20Order%20history
     * @see https://bingx-api.github.io/docs/#/en-us/cswap/trade-api.html#User's%20History%20Orders
     * @see https://bingx-api.github.io/docs/#/standard/contract-interface.html#Historical%20order
     * @param {string} [symbol] unified market symbol of the market orders were made in
     * @param {int} [since] the earliest time in ms to fetch orders for
     * @param {int} [limit] the maximum number of order structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {int} [params.until] the latest time in ms to fetch orders for
     * @param {boolean} [params.standard] whether to fetch standard contract orders
     * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> fetchCanceledAndClosedOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchClosedOrders() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object type = null;
        object subType = null;
        object standard = null;
        object response = null;
        var typeparametersVariable = this.handleMarketTypeAndParams("fetchClosedOrders", market, parameters);
        type = ((IList<object>)typeparametersVariable)[0];
        parameters = ((IList<object>)typeparametersVariable)[1];
        var subTypeparametersVariable = this.handleSubTypeAndParams("fetchClosedOrders", market, parameters);
        subType = ((IList<object>)subTypeparametersVariable)[0];
        parameters = ((IList<object>)subTypeparametersVariable)[1];
        var standardparametersVariable = this.handleOptionAndParams(parameters, "fetchClosedOrders", "standard", false);
        standard = ((IList<object>)standardparametersVariable)[0];
        parameters = ((IList<object>)standardparametersVariable)[1];
        if (isTrue(standard))
        {
            response = await this.contractV1PrivateGetAllOrders(this.extend(request, parameters));
        } else if (isTrue(isEqual(type, "spot")))
        {
            response = await this.spotV1PrivateGetTradeHistoryOrders(this.extend(request, parameters));
        } else
        {
            if (isTrue(isEqual(subType, "inverse")))
            {
                response = await this.cswapV1PrivateGetTradeOrderHistory(this.extend(request, parameters));
            } else
            {
                response = await this.swapV2PrivateGetTradeAllOrders(this.extend(request, parameters));
            }
        }
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        object orders = this.safeList(data, "orders", new List<object>() {});
        return this.parseOrders(orders, market, since, limit);
    }

    /**
     * @method
     * @name bingx#transfer
     * @description transfer currency internally between wallets on the same account
     * @see https://bingx-api.github.io/docs/#/spot/account-api.html#User%20Universal%20Transfer
     * @param {string} code unified currency code
     * @param {float} amount amount to transfer
     * @param {string} fromAccount account to transfer from
     * @param {string} toAccount account to transfer to
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [transfer structure]{@link https://docs.ccxt.com/#/?id=transfer-structure}
     */
    public async override Task<object> transfer(object code, object amount, object fromAccount, object toAccount, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        object accountsByType = this.safeDict(this.options, "accountsByType", new Dictionary<string, object>() {});
        object fromId = this.safeString(accountsByType, fromAccount, fromAccount);
        object toId = this.safeString(accountsByType, toAccount, toAccount);
        object request = new Dictionary<string, object>() {
            { "asset", getValue(currency, "id") },
            { "amount", this.currencyToPrecision(code, amount) },
            { "type", add(add(fromId, "_"), toId) },
        };
        object response = await this.spotV3PrivateGetGetAssetTransfer(this.extend(request, parameters));
        //
        //    {
        //        "tranId":13526853623
        //    }
        //
        return new Dictionary<string, object>() {
            { "info", response },
            { "id", this.safeString(response, "tranId") },
            { "timestamp", null },
            { "datetime", null },
            { "currency", code },
            { "amount", amount },
            { "fromAccount", fromAccount },
            { "toAccount", toAccount },
            { "status", null },
        };
    }

    /**
     * @method
     * @name bingx#fetchTransfers
     * @description fetch a history of internal transfers made on an account
     * @see https://bingx-api.github.io/docs/#/spot/account-api.html#Query%20User%20Universal%20Transfer%20History%20(USER_DATA)
     * @param {string} [code] unified currency code of the currency transferred
     * @param {int} [since] the earliest time in ms to fetch transfers for
     * @param {int} [limit] the maximum number of transfers structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} a list of [transfer structures]{@link https://docs.ccxt.com/#/?id=transfer-structure}
     */
    public async override Task<object> fetchTransfers(object code = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = null;
        if (isTrue(!isEqual(code, null)))
        {
            currency = this.currency(code);
        }
        object accountsByType = this.safeDict(this.options, "accountsByType", new Dictionary<string, object>() {});
        object fromAccount = this.safeString(parameters, "fromAccount");
        object toAccount = this.safeString(parameters, "toAccount");
        object fromId = this.safeString(accountsByType, fromAccount, fromAccount);
        object toId = this.safeString(accountsByType, toAccount, toAccount);
        if (isTrue(isTrue(isEqual(fromId, null)) || isTrue(isEqual(toId, null))))
        {
            throw new ExchangeError ((string)add(this.id, " fromAccount & toAccount parameter are required")) ;
        }
        object request = new Dictionary<string, object>() {
            { "type", add(add(fromId, "_"), toId) },
        };
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["startTime"] = since;
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["size"] = limit;
        }
        object response = await this.spotV3PrivateGetAssetTransfer(this.extend(request, parameters));
        //
        //     {
        //         "total": 3,
        //         "rows": [
        //             {
        //                 "asset":"USDT",
        //                 "amount":"-100.00000000000000000000",
        //                 "type":"FUND_SFUTURES",
        //                 "status":"CONFIRMED",
        //                 "tranId":1067594500957016069,
        //                 "timestamp":1658388859000
        //             },
        //         ]
        //     }
        //
        object rows = this.safeList(response, "rows", new List<object>() {});
        return this.parseTransfers(rows, currency, since, limit);
    }

    public override object parseTransfer(object transfer, object currency = null)
    {
        object tranId = this.safeString(transfer, "tranId");
        object timestamp = this.safeInteger(transfer, "timestamp");
        object currencyCode = this.safeCurrencyCode(null, currency);
        object status = this.safeString(transfer, "status");
        object accountsById = this.safeDict(this.options, "accountsById", new Dictionary<string, object>() {});
        object typeId = this.safeString(transfer, "type");
        object typeIdSplit = ((string)typeId).Split(new [] {((string)"_")}, StringSplitOptions.None).ToList<object>();
        object fromId = this.safeString(typeIdSplit, 0);
        object toId = this.safeString(typeId, 1);
        object fromAccount = this.safeString(accountsById, fromId, fromId);
        object toAccount = this.safeString(accountsById, toId, toId);
        return new Dictionary<string, object>() {
            { "info", transfer },
            { "id", tranId },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "currency", currencyCode },
            { "amount", this.safeNumber(transfer, "amount") },
            { "fromAccount", fromAccount },
            { "toAccount", toAccount },
            { "status", status },
        };
    }

    /**
     * @method
     * @name bingx#fetchDepositAddressesByNetwork
     * @description fetch the deposit addresses for a currency associated with this account
     * @see https://bingx-api.github.io/docs/#/en-us/common/wallet-api.html#Query%20Main%20Account%20Deposit%20Address
     * @param {string} code unified currency code
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a dictionary [address structures]{@link https://docs.ccxt.com/#/?id=address-structure}, indexed by the network
     */
    public async override Task<object> fetchDepositAddressesByNetwork(object code, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        object defaultRecvWindow = this.safeInteger(this.options, "recvWindow");
        object recvWindow = this.safeInteger(this.parseParams, "recvWindow", defaultRecvWindow);
        object request = new Dictionary<string, object>() {
            { "coin", getValue(currency, "id") },
            { "offset", 0 },
            { "limit", 1000 },
            { "recvWindow", recvWindow },
        };
        object response = await this.walletsV1PrivateGetCapitalDepositAddress(this.extend(request, parameters));
        //
        //     {
        //         "code": "0",
        //         "timestamp": "1695200226859",
        //         "data": {
        //           "data": [
        //             {
        //               "coinId": "799",
        //               "coin": "USDT",
        //               "network": "BEP20",
        //               "address": "6a7eda2817462dabb6493277a2cfe0f5c3f2550b",
        //               "tag": ''
        //             }
        //           ],
        //           "total": "1"
        //         }
        //     }
        //
        object data = this.safeList(this.safeDict(response, "data"), "data");
        object parsed = this.parseDepositAddresses(data, new List<object>() {getValue(currency, "code")}, false);
        return this.indexBy(parsed, "network");
    }

    /**
     * @method
     * @name bingx#fetchDepositAddress
     * @description fetch the deposit address for a currency associated with this account
     * @see https://bingx-api.github.io/docs/#/en-us/common/wallet-api.html#Query%20Main%20Account%20Deposit%20Address
     * @param {string} code unified currency code
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.network] The chain of currency. This only apply for multi-chain currency, and there is no need for single chain currency
     * @returns {object} an [address structure]{@link https://docs.ccxt.com/#/?id=address-structure}
     */
    public async override Task<object> fetchDepositAddress(object code, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object network = this.safeString(parameters, "network");
        parameters = this.omit(parameters, new List<object>() {"network"});
        object addressStructures = await this.fetchDepositAddressesByNetwork(code, parameters);
        if (isTrue(!isEqual(network, null)))
        {
            return this.safeDict(addressStructures, network);
        } else
        {
            object options = this.safeDict(this.options, "defaultNetworks");
            object defaultNetworkForCurrency = this.safeString(options, code);
            if (isTrue(!isEqual(defaultNetworkForCurrency, null)))
            {
                return this.safeDict(addressStructures, defaultNetworkForCurrency);
            } else
            {
                object keys = new List<object>(((IDictionary<string,object>)addressStructures).Keys);
                object key = this.safeString(keys, 0);
                return this.safeDict(addressStructures, key);
            }
        }
    }

    public override object parseDepositAddress(object depositAddress, object currency = null)
    {
        //
        // {
        //     "coinId":"4",
        //     "coin":"USDT",
        //     "network":"OMNI",
        //     "address":"1HXyx8HVQRY7Nhqz63nwnRB7SpS9xQPzLN",
        //     "addressWithPrefix":"1HXyx8HVQRY7Nhqz63nwnRB7SpS9xQPzLN"
        // }
        //
        object tag = this.safeString(depositAddress, "tag");
        object currencyId = this.safeString(depositAddress, "coin");
        currency = this.safeCurrency(currencyId, currency);
        object code = getValue(currency, "code");
        object address = this.safeString(depositAddress, "addressWithPrefix");
        object networkdId = this.safeString(depositAddress, "network");
        object networkCode = this.networkIdToCode(networkdId, code);
        this.checkAddress(address);
        return new Dictionary<string, object>() {
            { "info", depositAddress },
            { "currency", code },
            { "network", networkCode },
            { "address", address },
            { "tag", tag },
        };
    }

    /**
     * @method
     * @name bingx#fetchDeposits
     * @description fetch all deposits made to an account
     * @see https://bingx-api.github.io/docs/#/spot/account-api.html#Deposit%20History(supporting%20network)
     * @param {string} [code] unified currency code
     * @param {int} [since] the earliest time in ms to fetch deposits for
     * @param {int} [limit] the maximum number of deposits structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
     */
    public async override Task<object> fetchDeposits(object code = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object currency = null;
        if (isTrue(!isEqual(code, null)))
        {
            currency = this.currency(code);
            ((IDictionary<string,object>)request)["coin"] = getValue(currency, "id");
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["startTime"] = since;
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit; // default 1000
        }
        object response = await this.spotV3PrivateGetCapitalDepositHisrec(this.extend(request, parameters));
        //
        //    [
        //        {
        //            "amount":"0.00999800",
        //            "coin":"PAXG",
        //            "network":"ETH",
        //            "status":1,
        //            "address":"0x788cabe9236ce061e5a892e1a59395a81fc8d62c",
        //            "addressTag":"",
        //            "txId":"0xaad4654a3234aa6118af9b4b335f5ae81c360b2394721c019b5d1e75328b09f3",
        //            "insertTime":1599621997000,
        //            "transferType":0,
        //            "unlockConfirm":"12/12", // confirm times for unlocking
        //            "confirmTimes":"12/12"
        //        },
        //    ]
        //
        return this.parseTransactions(response, currency, since, limit);
    }

    /**
     * @method
     * @name bingx#fetchWithdrawals
     * @description fetch all withdrawals made from an account
     * @see https://bingx-api.github.io/docs/#/spot/account-api.html#Withdraw%20History%20(supporting%20network)
     * @param {string} [code] unified currency code
     * @param {int} [since] the earliest time in ms to fetch withdrawals for
     * @param {int} [limit] the maximum number of withdrawals structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
     */
    public async override Task<object> fetchWithdrawals(object code = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object currency = null;
        if (isTrue(!isEqual(code, null)))
        {
            currency = this.currency(code);
            ((IDictionary<string,object>)request)["coin"] = getValue(currency, "id");
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["startTime"] = since;
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit; // default 1000
        }
        object response = await this.spotV3PrivateGetCapitalWithdrawHistory(this.extend(request, parameters));
        //
        //    [
        //        {
        //            "address": "0x94df8b352de7f46f64b01d3666bf6e936e44ce60",
        //            "amount": "8.91000000",
        //            "applyTime": "2019-10-12 11:12:02",
        //            "coin": "USDT",
        //            "id": "b6ae22b3aa844210a7041aee7589627c",
        //            "withdrawOrderId": "WITHDRAWtest123",
        //            "network": "ETH",
        //            "transferType": 0
        //            "status": 6,
        //            "transactionFee": "0.004",
        //            "confirmNo":3,
        //            "info": "The address is not valid. Please confirm with the recipient",
        //            "txId": "0xb5ef8c13b968a406cc62a93a8bd80f9e9a906ef1b3fcf20a2e48573c17659268"
        //        },
        //    ]
        //
        return this.parseTransactions(response, currency, since, limit);
    }

    public override object parseTransaction(object transaction, object currency = null)
    {
        //
        // fetchDeposits
        //
        //    {
        //        "amount":"0.00999800",
        //        "coin":"PAXG",
        //        "network":"ETH",
        //        "status":1,
        //        "address":"0x788cabe9236ce061e5a892e1a59395a81fc8d62c",
        //        "addressTag":"",
        //        "txId":"0xaad4654a3234aa6118af9b4b335f5ae81c360b2394721c019b5d1e75328b09f3",
        //        "insertTime":1599621997000,
        //        "transferType":0,
        //        "unlockConfirm":"12/12", // confirm times for unlocking
        //        "confirmTimes":"12/12"
        //    }
        //
        // fetchWithdrawals
        //
        //    {
        //        "address": "0x94df8b352de7f46f64b01d3666bf6e936e44ce60",
        //        "amount": "8.91000000",
        //        "applyTime": "2019-10-12 11:12:02",
        //        "coin": "USDT",
        //        "id": "b6ae22b3aa844210a7041aee7589627c",
        //        "withdrawOrderId": "WITHDRAWtest123",
        //        "network": "ETH",
        //        "transferType": 0
        //        "status": 6,
        //        "transactionFee": "0.004",
        //        "confirmNo":3,
        //        "info": "The address is not valid. Please confirm with the recipient",
        //        "txId": "0xb5ef8c13b968a406cc62a93a8bd80f9e9a906ef1b3fcf20a2e48573c17659268"
        //    }
        //
        // withdraw
        //
        //     {
        //         "code":0,
        //         "timestamp":1705274263621,
        //         "data":{
        //             "id":"1264246141278773252"
        //         }
        //     }
        //
        // parse withdraw-type output first...
        //
        object data = this.safeValue(transaction, "data");
        object dataId = ((bool) isTrue((isEqual(data, null)))) ? null : this.safeString(data, "id");
        object id = this.safeString(transaction, "id", dataId);
        object address = this.safeString(transaction, "address");
        object tag = this.safeString(transaction, "addressTag");
        object timestamp = this.safeInteger(transaction, "insertTime");
        object datetime = this.iso8601(timestamp);
        if (isTrue(isEqual(timestamp, null)))
        {
            datetime = this.safeString(transaction, "applyTime");
            timestamp = this.parse8601(datetime);
        }
        object network = this.safeString(transaction, "network");
        object currencyId = this.safeString(transaction, "coin");
        object code = this.safeCurrencyCode(currencyId, currency);
        if (isTrue(isTrue(isTrue((!isEqual(code, null))) && isTrue((!isEqual(code, network)))) && isTrue(isGreaterThanOrEqual(getIndexOf(code, network), 0))))
        {
            if (isTrue(!isEqual(network, null)))
            {
                code = ((string)code).Replace((string)network, (string)"");
            }
        }
        object rawType = this.safeString(transaction, "transferType");
        object type = ((bool) isTrue((isEqual(rawType, "0")))) ? "deposit" : "withdrawal";
        return new Dictionary<string, object>() {
            { "info", transaction },
            { "id", id },
            { "txid", this.safeString(transaction, "txId") },
            { "type", type },
            { "currency", code },
            { "network", this.networkIdToCode(network) },
            { "amount", this.safeNumber(transaction, "amount") },
            { "status", this.parseTransactionStatus(this.safeString(transaction, "status")) },
            { "timestamp", timestamp },
            { "datetime", datetime },
            { "address", address },
            { "addressFrom", null },
            { "addressTo", address },
            { "tag", tag },
            { "tagFrom", tag },
            { "tagTo", null },
            { "updated", null },
            { "comment", this.safeString(transaction, "info") },
            { "fee", new Dictionary<string, object>() {
                { "currency", code },
                { "cost", this.safeNumber(transaction, "transactionFee") },
                { "rate", null },
            } },
            { "internal", null },
        };
    }

    public virtual object parseTransactionStatus(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "0", "pending" },
            { "1", "ok" },
            { "10", "pending" },
            { "20", "rejected" },
            { "30", "ok" },
            { "40", "rejected" },
            { "50", "ok" },
            { "60", "pending" },
            { "70", "rejected" },
            { "2", "pending" },
            { "3", "rejected" },
            { "4", "pending" },
            { "5", "rejected" },
            { "6", "ok" },
        };
        return this.safeString(statuses, status, status);
    }

    /**
     * @method
     * @name bingx#setMarginMode
     * @description set margin mode to 'cross' or 'isolated'
     * @see https://bingx-api.github.io/docs/#/en-us/swapV2/trade-api.html#Change%20Margin%20Type
     * @see https://bingx-api.github.io/docs/#/en-us/cswap/trade-api.html#Set%20Margin%20Type
     * @param {string} marginMode 'cross' or 'isolated'
     * @param {string} symbol unified market symbol
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} response from the exchange
     */
    public async override Task<object> setMarginMode(object marginMode, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " setMarginMode() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        if (isTrue(!isEqual(getValue(market, "type"), "swap")))
        {
            throw new BadSymbol ((string)add(this.id, " setMarginMode() supports swap contracts only")) ;
        }
        marginMode = ((string)marginMode).ToUpper();
        if (isTrue(isEqual(marginMode, "CROSS")))
        {
            marginMode = "CROSSED";
        }
        if (isTrue(isTrue(!isEqual(marginMode, "ISOLATED")) && isTrue(!isEqual(marginMode, "CROSSED"))))
        {
            throw new BadRequest ((string)add(this.id, " setMarginMode() marginMode argument should be isolated or cross")) ;
        }
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
            { "marginType", marginMode },
        };
        object subType = null;
        var subTypeparametersVariable = this.handleSubTypeAndParams("setMarginMode", market, parameters);
        subType = ((IList<object>)subTypeparametersVariable)[0];
        parameters = ((IList<object>)subTypeparametersVariable)[1];
        if (isTrue(isEqual(subType, "inverse")))
        {
            return await this.cswapV1PrivatePostTradeMarginType(this.extend(request, parameters));
        } else
        {
            return await this.swapV2PrivatePostTradeMarginType(this.extend(request, parameters));
        }
    }

    public async override Task<object> addMargin(object symbol, object amount, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object request = new Dictionary<string, object>() {
            { "type", 1 },
        };
        return await this.setMargin(symbol, amount, this.extend(request, parameters));
    }

    public async override Task<object> reduceMargin(object symbol, object amount, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object request = new Dictionary<string, object>() {
            { "type", 2 },
        };
        return await this.setMargin(symbol, amount, this.extend(request, parameters));
    }

    /**
     * @method
     * @name bingx#setMargin
     * @description Either adds or reduces margin in an isolated position in order to set the margin to a specific value
     * @see https://bingx-api.github.io/docs/#/swapV2/trade-api.html#Adjust%20isolated%20margin
     * @param {string} symbol unified market symbol of the market to set margin in
     * @param {float} amount the amount to set the margin to
     * @param {object} [params] parameters specific to the bingx api endpoint
     * @returns {object} A [margin structure]{@link https://docs.ccxt.com/#/?id=add-margin-structure}
     */
    public async override Task<object> setMargin(object symbol, object amount, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object type = this.safeInteger(parameters, "type"); // 1 increase margin 2 decrease margin
        if (isTrue(isEqual(type, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " setMargin() requires a type parameter either 1 (increase margin) or 2 (decrease margin)")) ;
        }
        if (!isTrue(this.inArray(type, new List<object>() {1, 2})))
        {
            throw new ArgumentsRequired ((string)add(this.id, " setMargin() requires a type parameter either 1 (increase margin) or 2 (decrease margin)")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
            { "amount", this.amountToPrecision(getValue(market, "symbol"), amount) },
            { "type", type },
        };
        object response = await this.swapV2PrivatePostTradePositionMargin(this.extend(request, parameters));
        //
        //    {
        //        "code": 0,
        //        "msg": "",
        //        "amount": 1,
        //        "type": 1
        //    }
        //
        return this.parseMarginModification(response, market);
    }

    public override object parseMarginModification(object data, object market = null)
    {
        //
        //    {
        //        "code": 0,
        //        "msg": "",
        //        "amount": 1,
        //        "type": 1
        //    }
        //
        object type = this.safeString(data, "type");
        return new Dictionary<string, object>() {
            { "info", data },
            { "symbol", this.safeString(market, "symbol") },
            { "type", ((bool) isTrue((isEqual(type, "1")))) ? "add" : "reduce" },
            { "marginMode", "isolated" },
            { "amount", this.safeNumber(data, "amount") },
            { "total", this.safeNumber(data, "margin") },
            { "code", this.safeString(market, "settle") },
            { "status", null },
            { "timestamp", null },
            { "datetime", null },
        };
    }

    /**
     * @method
     * @name bingx#fetchLeverage
     * @description fetch the set leverage for a market
     * @see https://bingx-api.github.io/docs/#/swapV2/trade-api.html#Query%20Leverage
     * @see https://bingx-api.github.io/docs/#/en-us/cswap/trade-api.html#Query%20Leverage
     * @param {string} symbol unified market symbol
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [leverage structure]{@link https://docs.ccxt.com/#/?id=leverage-structure}
     */
    public async override Task<object> fetchLeverage(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object response = null;
        if (isTrue(getValue(market, "inverse")))
        {
            response = await this.cswapV1PrivateGetTradeLeverage(this.extend(request, parameters));
        } else
        {
            response = await this.swapV2PrivateGetTradeLeverage(this.extend(request, parameters));
        }
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        return this.parseLeverage(data, market);
    }

    public override object parseLeverage(object leverage, object market = null)
    {
        //
        // linear swap
        //
        //     {
        //         "longLeverage": 5,
        //         "shortLeverage": 5,
        //         "maxLongLeverage": 125,
        //         "maxShortLeverage": 125,
        //         "availableLongVol": "0.0000",
        //         "availableShortVol": "0.0000",
        //         "availableLongVal": "0.0",
        //         "availableShortVal": "0.0",
        //         "maxPositionLongVal": "0.0",
        //         "maxPositionShortVal": "0.0"
        //     }
        //
        // inverse swap
        //
        //     {
        //         "symbol": "SOL-USD",
        //         "longLeverage": 5,
        //         "shortLeverage": 5,
        //         "maxLongLeverage": 50,
        //         "maxShortLeverage": 50,
        //         "availableLongVol": "4000000",
        //         "availableShortVol": "4000000"
        //     }
        //
        object marketId = this.safeString(leverage, "symbol");
        return new Dictionary<string, object>() {
            { "info", leverage },
            { "symbol", this.safeSymbol(marketId, market) },
            { "marginMode", null },
            { "longLeverage", this.safeInteger(leverage, "longLeverage") },
            { "shortLeverage", this.safeInteger(leverage, "shortLeverage") },
        };
    }

    /**
     * @method
     * @name bingx#setLeverage
     * @description set the level of leverage for a market
     * @see https://bingx-api.github.io/docs/#/swapV2/trade-api.html#Switch%20Leverage
     * @see https://bingx-api.github.io/docs/#/en-us/cswap/trade-api.html#Modify%20Leverage
     * @param {float} leverage the rate of leverage
     * @param {string} symbol unified market symbol
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.side] hedged: ['long' or 'short']. one way: ['both']
     * @returns {object} response from the exchange
     */
    public async override Task<object> setLeverage(object leverage, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " setLeverage() requires a symbol argument")) ;
        }
        object side = this.safeStringUpper(parameters, "side");
        this.checkRequiredArgument("setLeverage", side, "side", new List<object>() {"LONG", "SHORT", "BOTH"});
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
            { "side", side },
            { "leverage", leverage },
        };
        if (isTrue(getValue(market, "inverse")))
        {
            return await this.cswapV1PrivatePostTradeLeverage(this.extend(request, parameters));
        } else
        {
            return await this.swapV2PrivatePostTradeLeverage(this.extend(request, parameters));
        }
    }

    /**
     * @method
     * @name bingx#fetchMyTrades
     * @description fetch all trades made by the user
     * @see https://bingx-api.github.io/docs/#/en-us/spot/trade-api.html#Query%20transaction%20details
     * @see https://bingx-api.github.io/docs/#/en-us/swapV2/trade-api.html#Query%20historical%20transaction%20orders
     * @see https://bingx-api.github.io/docs/#/en-us/cswap/trade-api.html#Query%20Order%20Trade%20Detail
     * @param {string} [symbol] unified market symbol
     * @param {int} [since] the earliest time in ms to fetch trades for
     * @param {int} [limit] the maximum number of trades structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {int} [params.until] timestamp in ms for the ending date filter, default is undefined
     * @param {string} params.trandingUnit COIN (directly represent assets such as BTC and ETH) or CONT (represents the number of contract sheets)
     * @param {string} params.orderId the order id required for inverse swap
     * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
     */
    public async override Task<object> fetchMyTrades(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchMyTrades() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {};
        object fills = null;
        object response = null;
        object subType = null;
        var subTypeparametersVariable = this.handleSubTypeAndParams("fetchMyTrades", market, parameters);
        subType = ((IList<object>)subTypeparametersVariable)[0];
        parameters = ((IList<object>)subTypeparametersVariable)[1];
        if (isTrue(isEqual(subType, "inverse")))
        {
            object orderId = this.safeString(parameters, "orderId");
            if (isTrue(isEqual(orderId, null)))
            {
                throw new ArgumentsRequired ((string)add(this.id, " fetchMyTrades() requires an orderId argument for inverse swap trades")) ;
            }
            response = await this.cswapV1PrivateGetTradeAllFillOrders(this.extend(request, parameters));
            fills = this.safeList(response, "data", new List<object>() {});
        } else
        {
            ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
            object now = this.milliseconds();
            if (isTrue(!isEqual(since, null)))
            {
                object startTimeReq = ((bool) isTrue(getValue(market, "spot"))) ? "startTime" : "startTs";
                ((IDictionary<string,object>)request)[(string)startTimeReq] = since;
            } else if (isTrue(getValue(market, "swap")))
            {
                ((IDictionary<string,object>)request)["startTs"] = subtract(now, 7776000000); // 90 days
            }
            object until = this.safeInteger(parameters, "until");
            parameters = this.omit(parameters, "until");
            if (isTrue(!isEqual(until, null)))
            {
                object endTimeReq = ((bool) isTrue(getValue(market, "spot"))) ? "endTime" : "endTs";
                ((IDictionary<string,object>)request)[(string)endTimeReq] = until;
            } else if (isTrue(getValue(market, "swap")))
            {
                ((IDictionary<string,object>)request)["endTs"] = now;
            }
            if (isTrue(getValue(market, "spot")))
            {
                response = await this.spotV1PrivateGetTradeMyTrades(this.extend(request, parameters));
                object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
                fills = this.safeList(data, "fills", new List<object>() {});
            } else
            {
                object tradingUnit = this.safeStringUpper(parameters, "tradingUnit", "CONT");
                parameters = this.omit(parameters, "tradingUnit");
                ((IDictionary<string,object>)request)["tradingUnit"] = tradingUnit;
                response = await this.swapV2PrivateGetTradeAllFillOrders(this.extend(request, parameters));
                object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
                fills = this.safeList(data, "fill_orders", new List<object>() {});
            }
        }
        return this.parseTrades(fills, market, since, limit, parameters);
    }

    public override object parseDepositWithdrawFee(object fee, object currency = null)
    {
        //
        //    {
        //        "coin": "BTC",
        //        "name": "BTC",
        //        "networkList": [
        //          {
        //            "name": "BTC",
        //            "network": "BTC",
        //            "isDefault": true,
        //            "minConfirm": "2",
        //            "withdrawEnable": true,
        //            "withdrawFee": "0.00035",
        //            "withdrawMax": "1.62842",
        //            "withdrawMin": "0.0005"
        //          },
        //          {
        //            "name": "BTC",
        //            "network": "BEP20",
        //            "isDefault": false,
        //            "minConfirm": "15",
        //            "withdrawEnable": true,
        //            "withdrawFee": "0.00001",
        //            "withdrawMax": "1.62734",
        //            "withdrawMin": "0.0001"
        //          }
        //        ]
        //    }
        //
        object networkList = this.safeList(fee, "networkList", new List<object>() {});
        object networkListLength = getArrayLength(networkList);
        object result = new Dictionary<string, object>() {
            { "info", fee },
            { "withdraw", new Dictionary<string, object>() {
                { "fee", null },
                { "percentage", null },
            } },
            { "deposit", new Dictionary<string, object>() {
                { "fee", null },
                { "percentage", null },
            } },
            { "networks", new Dictionary<string, object>() {} },
        };
        if (isTrue(!isEqual(networkListLength, 0)))
        {
            for (object i = 0; isLessThan(i, networkListLength); postFixIncrement(ref i))
            {
                object network = getValue(networkList, i);
                object networkId = this.safeString(network, "network");
                object isDefault = this.safeBool(network, "isDefault");
                object currencyCode = this.safeString(currency, "code");
                object networkCode = this.networkIdToCode(networkId, currencyCode);
                ((IDictionary<string,object>)getValue(result, "networks"))[(string)networkCode] = new Dictionary<string, object>() {
                    { "deposit", new Dictionary<string, object>() {
                        { "fee", null },
                        { "percentage", null },
                    } },
                    { "withdraw", new Dictionary<string, object>() {
                        { "fee", this.safeNumber(network, "withdrawFee") },
                        { "percentage", false },
                    } },
                };
                if (isTrue(isDefault))
                {
                    ((IDictionary<string,object>)getValue(result, "withdraw"))["fee"] = this.safeNumber(network, "withdrawFee");
                    ((IDictionary<string,object>)getValue(result, "withdraw"))["percentage"] = false;
                }
            }
        }
        return result;
    }

    /**
     * @method
     * @name bingx#fetchDepositWithdrawFees
     * @description fetch deposit and withdraw fees
     * @see https://bingx-api.github.io/docs/#/common/account-api.html#All%20Coins'%20Information
     * @param {string[]|undefined} codes list of unified currency codes
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a list of [fee structures]{@link https://docs.ccxt.com/#/?id=fee-structure}
     */
    public async override Task<object> fetchDepositWithdrawFees(object codes = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.walletsV1PrivateGetCapitalConfigGetall(parameters);
        object coins = this.safeList(response, "data");
        return this.parseDepositWithdrawFees(coins, codes, "coin");
    }

    /**
     * @method
     * @name bingx#withdraw
     * @description make a withdrawal
     * @see https://bingx-api.github.io/docs/#/en-us/spot/wallet-api.html#Withdraw
     * @param {string} code unified currency code
     * @param {float} amount the amount to withdraw
     * @param {string} address the address to withdraw to
     * @param {string} [tag]
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {int} [params.walletType] 1 fund account, 2 standard account, 3 perpetual account
     * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
     */
    public async override Task<object> withdraw(object code, object amount, object address, object tag = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        var tagparametersVariable = this.handleWithdrawTagAndParams(tag, parameters);
        tag = ((IList<object>)tagparametersVariable)[0];
        parameters = ((IList<object>)tagparametersVariable)[1];
        this.checkAddress(address);
        await this.loadMarkets();
        object currency = this.currency(code);
        object walletType = this.safeInteger(parameters, "walletType");
        if (isTrue(isEqual(walletType, null)))
        {
            walletType = 1;
        }
        if (!isTrue(this.inArray(walletType, new List<object>() {1, 2, 3})))
        {
            throw new BadRequest ((string)add(this.id, " withdraw() requires either 1 fund account, 2 standard futures account, 3 perpetual account for walletType")) ;
        }
        object request = new Dictionary<string, object>() {
            { "coin", getValue(currency, "id") },
            { "address", address },
            { "amount", this.numberToString(amount) },
            { "walletType", walletType },
        };
        object network = this.safeStringUpper(parameters, "network");
        if (isTrue(!isEqual(network, null)))
        {
            ((IDictionary<string,object>)request)["network"] = this.networkCodeToId(network);
        }
        if (isTrue(!isEqual(tag, null)))
        {
            ((IDictionary<string,object>)request)["addressTag"] = tag;
        }
        parameters = this.omit(parameters, new List<object>() {"walletType", "network"});
        object response = await this.walletsV1PrivatePostCapitalWithdrawApply(this.extend(request, parameters));
        object data = this.safeValue(response, "data");
        //    {
        //        "code":0,
        //        "timestamp":1689258953651,
        //        "data":{
        //           "id":"1197073063359000577"
        //        }
        //    }
        return this.parseTransaction(data);
    }

    public virtual object parseParams(object parameters)
    {
        object sortedParams = this.keysort(parameters);
        object keys = new List<object>(((IDictionary<string,object>)sortedParams).Keys);
        for (object i = 0; isLessThan(i, getArrayLength(keys)); postFixIncrement(ref i))
        {
            object key = getValue(keys, i);
            object value = getValue(sortedParams, key);
            if (isTrue(((value is IList<object>) || (value.GetType().IsGenericType && value.GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>))))))
            {
                object arrStr = "[";
                for (object j = 0; isLessThan(j, getArrayLength(value)); postFixIncrement(ref j))
                {
                    object arrayElement = getValue(value, j);
                    if (isTrue(isGreaterThan(j, 0)))
                    {
                        arrStr = add(arrStr, ",");
                    }
                    arrStr = add(arrStr, ((object)arrayElement).ToString());
                }
                arrStr = add(arrStr, "]");
                ((IDictionary<string,object>)sortedParams)[(string)key] = arrStr;
            }
        }
        return sortedParams;
    }

    /**
     * @method
     * @name bingx#fetchMyLiquidations
     * @description retrieves the users liquidated positions
     * @see https://bingx-api.github.io/docs/#/swapV2/trade-api.html#User's%20Force%20Orders
     * @see https://bingx-api.github.io/docs/#/en-us/cswap/trade-api.html#Query%20force%20orders
     * @param {string} [symbol] unified CCXT market symbol
     * @param {int} [since] the earliest time in ms to fetch liquidations for
     * @param {int} [limit] the maximum number of liquidation structures to retrieve
     * @param {object} [params] exchange specific parameters for the bingx api endpoint
     * @param {int} [params.until] timestamp in ms of the latest liquidation
     * @returns {object} an array of [liquidation structures]{@link https://docs.ccxt.com/#/?id=liquidation-structure}
     */
    public async override Task<object> fetchMyLiquidations(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {
            { "autoCloseType", "LIQUIDATION" },
        };
        var requestparametersVariable = this.handleUntilOption("endTime", request, parameters);
        request = ((IList<object>)requestparametersVariable)[0];
        parameters = ((IList<object>)requestparametersVariable)[1];
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["startTime"] = since;
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        object subType = null;
        var subTypeparametersVariable = this.handleSubTypeAndParams("fetchMyLiquidations", market, parameters);
        subType = ((IList<object>)subTypeparametersVariable)[0];
        parameters = ((IList<object>)subTypeparametersVariable)[1];
        object response = null;
        object liquidations = null;
        if (isTrue(isEqual(subType, "inverse")))
        {
            response = await this.cswapV1PrivateGetTradeForceOrders(this.extend(request, parameters));
            //
            //     {
            //         "code": 0,
            //         "msg": "",
            //         "timestamp": 1721280071678,
            //         "data": [
            //             {
            //                 "orderId": "string",
            //                 "symbol": "string",
            //                 "type": "string",
            //                 "side": "string",
            //                 "positionSide": "string",
            //                 "price": "string",
            //                 "quantity": "float64",
            //                 "stopPrice": "string",
            //                 "workingType": "string",
            //                 "status": "string",
            //                 "time": "int64",
            //                 "avgPrice": "string",
            //                 "executedQty": "string",
            //                 "profit": "string",
            //                 "commission": "string",
            //                 "updateTime": "string"
            //             }
            //         ]
            //     }
            //
            liquidations = this.safeList(response, "data", new List<object>() {});
        } else
        {
            response = await this.swapV2PrivateGetTradeForceOrders(this.extend(request, parameters));
            //
            //     {
            //         "code": 0,
            //         "msg": "",
            //         "data": {
            //             "orders": [
            //                 {
            //                     "time": "int64",
            //                     "symbol": "string",
            //                     "side": "string",
            //                     "type": "string",
            //                     "positionSide": "string",
            //                     "cumQuote": "string",
            //                     "status": "string",
            //                     "stopPrice": "string",
            //                     "price": "string",
            //                     "origQty": "string",
            //                     "avgPrice": "string",
            //                     "executedQty": "string",
            //                     "orderId": "int64",
            //                     "profit": "string",
            //                     "commission": "string",
            //                     "workingType": "string",
            //                     "updateTime": "int64"
            //                 },
            //             ]
            //         }
            //     }
            //
            object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
            liquidations = this.safeList(data, "orders", new List<object>() {});
        }
        return this.parseLiquidations(liquidations, market, since, limit);
    }

    public override object parseLiquidation(object liquidation, object market = null)
    {
        //
        //     {
        //         "time": "int64",
        //         "symbol": "string",
        //         "side": "string",
        //         "type": "string",
        //         "positionSide": "string",
        //         "cumQuote": "string",
        //         "status": "string",
        //         "stopPrice": "string",
        //         "price": "string",
        //         "origQty": "string",
        //         "avgPrice": "string",
        //         "executedQty": "string",
        //         "orderId": "int64",
        //         "profit": "string",
        //         "commission": "string",
        //         "workingType": "string",
        //         "updateTime": "int64"
        //     }
        //
        object marketId = this.safeString(liquidation, "symbol");
        object timestamp = this.safeInteger(liquidation, "time");
        object contractsString = this.safeString(liquidation, "executedQty");
        object contractSizeString = this.safeString(market, "contractSize");
        object priceString = this.safeString(liquidation, "avgPrice");
        object baseValueString = Precise.stringMul(contractsString, contractSizeString);
        object quoteValueString = Precise.stringMul(baseValueString, priceString);
        return this.safeLiquidation(new Dictionary<string, object>() {
            { "info", liquidation },
            { "symbol", this.safeSymbol(marketId, market) },
            { "contracts", this.parseNumber(contractsString) },
            { "contractSize", this.parseNumber(contractSizeString) },
            { "price", this.parseNumber(priceString) },
            { "baseValue", this.parseNumber(baseValueString) },
            { "quoteValue", this.parseNumber(quoteValueString) },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
        });
    }

    /**
     * @method
     * @name bingx#closePosition
     * @description closes open positions for a market
     * @see https://bingx-api.github.io/docs/#/en-us/swapV2/trade-api.html#One-Click%20Close%20All%20Positions
     * @see https://bingx-api.github.io/docs/#/en-us/cswap/trade-api.html#Close%20all%20positions%20in%20bulk
     * @param {string} symbol Unified CCXT market symbol
     * @param {string} [side] not used by bingx
     * @param {object} [params] extra parameters specific to the bingx api endpoint
     * @param {string|undefined} [params.positionId] the id of the position you would like to close
     * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> closePosition(object symbol, object side = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object positionId = this.safeString(parameters, "positionId");
        object request = new Dictionary<string, object>() {};
        object response = null;
        if (isTrue(!isEqual(positionId, null)))
        {
            response = await this.swapV1PrivatePostTradeClosePosition(this.extend(request, parameters));
        } else
        {
            ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
            if (isTrue(getValue(market, "inverse")))
            {
                response = await this.cswapV1PrivatePostTradeCloseAllPositions(this.extend(request, parameters));
            } else
            {
                response = await this.swapV2PrivatePostTradeCloseAllPositions(this.extend(request, parameters));
            }
        }
        object data = this.safeDict(response, "data");
        return this.parseOrder(data, market);
    }

    /**
     * @method
     * @name bitget#closePositions
     * @description closes open positions for a market
     * @see https://bingx-api.github.io/docs/#/en-us/swapV2/trade-api.html#One-Click%20Close%20All%20Positions
     * @see https://bingx-api.github.io/docs/#/en-us/cswap/trade-api.html#Close%20all%20positions%20in%20bulk
     * @param {object} [params] extra parameters specific to the bingx api endpoint
     * @param {string} [params.recvWindow] request valid time window value
     * @returns {object[]} [a list of position structures]{@link https://docs.ccxt.com/#/?id=position-structure}
     */
    public async override Task<object> closeAllPositions(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object defaultRecvWindow = this.safeInteger(this.options, "recvWindow");
        object recvWindow = this.safeInteger(this.parseParams, "recvWindow", defaultRecvWindow);
        object marketType = null;
        var marketTypeparametersVariable = this.handleMarketTypeAndParams("closeAllPositions", null, parameters);
        marketType = ((IList<object>)marketTypeparametersVariable)[0];
        parameters = ((IList<object>)marketTypeparametersVariable)[1];
        object subType = null;
        var subTypeparametersVariable = this.handleSubTypeAndParams("closeAllPositions", null, parameters);
        subType = ((IList<object>)subTypeparametersVariable)[0];
        parameters = ((IList<object>)subTypeparametersVariable)[1];
        if (isTrue(isEqual(marketType, "margin")))
        {
            throw new BadRequest ((string)add(add(add(this.id, " closePositions () cannot be used for "), marketType), " markets")) ;
        }
        object request = new Dictionary<string, object>() {
            { "recvWindow", recvWindow },
        };
        object response = null;
        if (isTrue(isEqual(subType, "inverse")))
        {
            response = await this.cswapV1PrivatePostTradeCloseAllPositions(this.extend(request, parameters));
        } else
        {
            response = await this.swapV2PrivatePostTradeCloseAllPositions(this.extend(request, parameters));
        }
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        object success = this.safeList(data, "success", new List<object>() {});
        object positions = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(success)); postFixIncrement(ref i))
        {
            object position = this.parsePosition(new Dictionary<string, object>() {
                { "positionId", getValue(success, i) },
            });
            ((IList<object>)positions).Add(position);
        }
        return positions;
    }

    /**
     * @method
     * @name bingx#fetchPositionMode
     * @description fetchs the position mode, hedged or one way, hedged for binance is set identically for all linear markets or all inverse markets
     * @see https://bingx-api.github.io/docs/#/en-us/swapV2/trade-api.html#Get%20Position%20Mode
     * @param {string} symbol unified symbol of the market to fetch the order book for
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} an object detailing whether the market is in hedged or one-way mode
     */
    public async virtual Task<object> fetchPositionMode(object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object response = await this.swapV1PrivateGetPositionSideDual(parameters);
        //
        //     {
        //         "code": "0",
        //         "msg": "",
        //         "timeStamp": "1709002057516",
        //         "data": {
        //             "dualSidePosition": "false"
        //         }
        //     }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        object dualSidePosition = this.safeString(data, "dualSidePosition");
        return new Dictionary<string, object>() {
            { "info", response },
            { "hedged", (isEqual(dualSidePosition, "true")) },
        };
    }

    /**
     * @method
     * @name bingx#setPositionMode
     * @description set hedged to true or false for a market
     * @see https://bingx-api.github.io/docs/#/en-us/swapV2/trade-api.html#Set%20Position%20Mode
     * @param {bool} hedged set to true to use dualSidePosition
     * @param {string} symbol not used by bingx setPositionMode ()
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} response from the exchange
     */
    public async override Task<object> setPositionMode(object hedged, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object dualSidePosition = null;
        if (isTrue(hedged))
        {
            dualSidePosition = "true";
        } else
        {
            dualSidePosition = "false";
        }
        object request = new Dictionary<string, object>() {
            { "dualSidePosition", dualSidePosition },
        };
        //
        //     {
        //         code: '0',
        //         msg: '',
        //         timeStamp: '1703327432734',
        //         data: { dualSidePosition: 'false' }
        //     }
        //
        return await this.swapV1PrivatePostPositionSideDual(this.extend(request, parameters));
    }

    /**
     * @method
     * @name bingx#editOrder
     * @description cancels an order and places a new order
     * @see https://bingx-api.github.io/docs/#/en-us/spot/trade-api.html#Cancel%20order%20and%20place%20a%20new%20order  // spot
     * @see https://bingx-api.github.io/docs/#/en-us/swapV2/trade-api.html#Cancel%20an%20order%20and%20then%20Place%20a%20new%20order  // swap
     * @param {string} id order id
     * @param {string} symbol unified symbol of the market to create an order in
     * @param {string} type 'market' or 'limit'
     * @param {string} side 'buy' or 'sell'
     * @param {float} amount how much of the currency you want to trade in units of the base currency
     * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.stopPrice] Trigger price used for TAKE_STOP_LIMIT, TAKE_STOP_MARKET, TRIGGER_LIMIT, TRIGGER_MARKET order types.
     * @param {object} [params.takeProfit] *takeProfit object in params* containing the triggerPrice at which the attached take profit order will be triggered
     * @param {float} [params.takeProfit.triggerPrice] take profit trigger price
     * @param {object} [params.stopLoss] *stopLoss object in params* containing the triggerPrice at which the attached stop loss order will be triggered
     * @param {float} [params.stopLoss.triggerPrice] stop loss trigger price
     *
     * EXCHANGE SPECIFIC PARAMETERS
     * @param {string} [params.cancelClientOrderID] the user-defined id of the order to be canceled, 1-40 characters, different orders cannot use the same clientOrderID, only supports a query range of 2 hours
     * @param {string} [params.cancelRestrictions] cancel orders with specified status, NEW: New order, PENDING: Pending order, PARTIALLY_FILLED: Partially filled
     * @param {string} [params.cancelReplaceMode] STOP_ON_FAILURE - if the cancel order fails, it will not continue to place a new order, ALLOW_FAILURE - regardless of whether the cancel order succeeds or fails, it will continue to place a new order
     * @param {float} [params.quoteOrderQty] order amount
     * @param {string} [params.newClientOrderId] custom order id consisting of letters, numbers, and _, 1-40 characters, different orders cannot use the same newClientOrderId.
     * @param {string} [params.positionSide] *contract only* position direction, required for single position as BOTH, for both long and short positions only LONG or SHORT can be chosen, defaults to LONG if empty
     * @param {string} [params.reduceOnly] *contract only* true or false, default=false for single position mode. this parameter is not accepted for both long and short positions mode
     * @param {float} [params.priceRate] *contract only* for type TRAILING_STOP_Market or TRAILING_TP_SL, Max = 1
     * @param {string} [params.workingType] *contract only* StopPrice trigger price types, MARK_PRICE (default), CONTRACT_PRICE, or INDEX_PRICE
     * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> editOrder(object id, object symbol, object type, object side, object amount = null, object price = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = this.createOrderRequest(symbol, type, side, amount, price, parameters);
        ((IDictionary<string,object>)request)["cancelOrderId"] = id;
        ((IDictionary<string,object>)request)["cancelReplaceMode"] = "STOP_ON_FAILURE";
        object response = null;
        if (isTrue(getValue(market, "swap")))
        {
            response = await this.swapV1PrivatePostTradeCancelReplace(this.extend(request, parameters));
        } else
        {
            response = await this.spotV1PrivatePostTradeOrderCancelReplace(this.extend(request, parameters));
        }
        object data = this.safeDict(response, "data");
        return this.parseOrder(data, market);
    }

    /**
     * @method
     * @name bingx#fetchMarginMode
     * @description fetches the margin mode of the trading pair
     * @see https://bingx-api.github.io/docs/#/en-us/swapV2/trade-api.html#Query%20Margin%20Type
     * @see https://bingx-api.github.io/docs/#/en-us/cswap/trade-api.html#Query%20Margin%20Type
     * @param {string} symbol unified symbol of the market to fetch the margin mode for
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [margin mode structure]{@link https://docs.ccxt.com/#/?id=margin-mode-structure}
     */
    public async override Task<object> fetchMarginMode(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object subType = null;
        object response = null;
        var subTypeparametersVariable = this.handleSubTypeAndParams("fetchMarginMode", market, parameters);
        subType = ((IList<object>)subTypeparametersVariable)[0];
        parameters = ((IList<object>)subTypeparametersVariable)[1];
        if (isTrue(isEqual(subType, "inverse")))
        {
            response = await this.cswapV1PrivateGetTradeMarginType(this.extend(request, parameters));
        } else
        {
            response = await this.swapV2PrivateGetTradeMarginType(this.extend(request, parameters));
        }
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        return this.parseMarginMode(data, market);
    }

    public override object parseMarginMode(object marginMode, object market = null)
    {
        object marketId = this.safeString(marginMode, "symbol");
        object marginType = this.safeStringLower(marginMode, "marginType");
        marginType = ((bool) isTrue((isEqual(marginType, "crossed")))) ? "cross" : marginType;
        return new Dictionary<string, object>() {
            { "info", marginMode },
            { "symbol", this.safeSymbol(marketId, market, "-", "swap") },
            { "marginMode", marginType },
        };
    }

    /**
     * @method
     * @name bingx#fetchTradingFee
     * @description fetch the trading fees for a market
     * @see https://bingx-api.github.io/docs/#/en-us/spot/trade-api.html#Query%20Trading%20Commission%20Rate
     * @see https://bingx-api.github.io/docs/#/en-us/swapV2/account-api.html#Query%20Trading%20Commission%20Rate
     * @see https://bingx-api.github.io/docs/#/en-us/cswap/trade-api.html#Query%20Trade%20Commission%20Rate
     * @param {string} symbol unified market symbol
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [fee structure]{@link https://docs.ccxt.com/#/?id=fee-structure}
     */
    public async override Task<object> fetchTradingFee(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object response = null;
        object commission = new Dictionary<string, object>() {};
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        if (isTrue(getValue(market, "spot")))
        {
            response = await this.spotV1PrivateGetUserCommissionRate(this.extend(request, parameters));
            //
            //     {
            //         "code": 0,
            //         "msg": "",
            //         "debugMsg": "",
            //         "data": {
            //             "takerCommissionRate": 0.001,
            //             "makerCommissionRate": 0.001
            //         }
            //     }
            //
            commission = data;
        } else
        {
            if (isTrue(getValue(market, "inverse")))
            {
                response = await this.cswapV1PrivateGetUserCommissionRate(parameters);
                //
                //     {
                //         "code": 0,
                //         "msg": "",
                //         "timestamp": 1721365261438,
                //         "data": {
                //             "takerCommissionRate": "0.0005",
                //             "makerCommissionRate": "0.0002"
                //         }
                //     }
                //
                commission = data;
            } else
            {
                response = await this.swapV2PrivateGetUserCommissionRate(parameters);
                //
                //     {
                //         "code": 0,
                //         "msg": "",
                //         "data": {
                //             "commission": {
                //                 "takerCommissionRate": 0.0005,
                //                 "makerCommissionRate": 0.0002
                //             }
                //         }
                //     }
                //
                commission = this.safeDict(data, "commission", new Dictionary<string, object>() {});
            }
        }
        return this.parseTradingFee(commission, market);
    }

    public virtual object parseTradingFee(object fee, object market = null)
    {
        //
        //     {
        //         "takerCommissionRate": 0.001,
        //         "makerCommissionRate": 0.001
        //     }
        //
        object symbol = ((bool) isTrue((!isEqual(market, null)))) ? getValue(market, "symbol") : null;
        return new Dictionary<string, object>() {
            { "info", fee },
            { "symbol", symbol },
            { "maker", this.safeNumber(fee, "makerCommissionRate") },
            { "taker", this.safeNumber(fee, "takerCommissionRate") },
            { "percentage", false },
            { "tierBased", false },
        };
    }

    public override object sign(object path, object section = null, object method = null, object parameters = null, object headers = null, object body = null)
    {
        section ??= "public";
        method ??= "GET";
        parameters ??= new Dictionary<string, object>();
        object type = getValue(section, 0);
        object version = getValue(section, 1);
        object access = getValue(section, 2);
        object isSandbox = this.safeBool(this.options, "sandboxMode", false);
        if (isTrue(isTrue(isSandbox) && isTrue((!isEqual(type, "swap")))))
        {
            throw new NotSupported ((string)add(add(add(this.id, " does not have a testnet/sandbox URL for "), type), " endpoints")) ;
        }
        object url = this.implodeHostname(getValue(getValue(this.urls, "api"), type));
        if (isTrue(isTrue(isEqual(type, "spot")) && isTrue(isEqual(version, "v3"))))
        {
            url = add(url, "/api");
        } else
        {
            url = add(url, add("/", type));
        }
        url = add(url, add(add("/", version), "/"));
        path = this.implodeParams(path, parameters);
        url = add(url, path);
        parameters = this.omit(parameters, this.extractParams(path));
        parameters = this.keysort(parameters);
        if (isTrue(isEqual(access, "public")))
        {
            ((IDictionary<string,object>)parameters)["timestamp"] = this.nonce();
            if (isTrue(getArrayLength(new List<object>(((IDictionary<string,object>)parameters).Keys))))
            {
                url = add(url, add("?", this.urlencode(parameters)));
            }
        } else if (isTrue(isEqual(access, "private")))
        {
            this.checkRequiredCredentials();
            ((IDictionary<string,object>)parameters)["timestamp"] = this.nonce();
            object parsedParams = this.parseParams(parameters);
            object query = this.urlencode(parsedParams);
            object signature = this.hmac(this.encode(this.rawencode(parsedParams)), this.encode(this.secret), sha256);
            if (isTrue(getArrayLength(new List<object>(((IDictionary<string,object>)parameters).Keys))))
            {
                query = add(add("?", query), "&");
            } else
            {
                query = add(query, "?");
            }
            query = add(query, add("signature=", signature));
            headers = new Dictionary<string, object>() {
                { "X-BX-APIKEY", this.apiKey },
                { "X-SOURCE-KEY", this.safeString(this.options, "broker", "CCXT") },
            };
            url = add(url, query);
        }
        return new Dictionary<string, object>() {
            { "url", url },
            { "method", method },
            { "body", body },
            { "headers", headers },
        };
    }

    public override object nonce()
    {
        return this.milliseconds();
    }

    public override void setSandboxMode(object enable)
    {
        base.setSandboxMode(enable);
        ((IDictionary<string,object>)this.options)["sandboxMode"] = enable;
    }

    public override object handleErrors(object httpCode, object reason, object url, object method, object headers, object body, object response, object requestHeaders, object requestBody)
    {
        if (isTrue(isEqual(response, null)))
        {
            return null;  // fallback to default error handler
        }
        //
        //    {
        //        "code": 80014,
        //        "msg": "Invalid parameters, err:Key: 'GetTickerRequest.Symbol' Error:Field validation for "Symbol" failed on the "len=0|endswith=-USDT" tag",
        //        "data": {
        //        }
        //    }
        //
        object code = this.safeString(response, "code");
        object message = this.safeString(response, "msg");
        if (isTrue(isTrue(!isEqual(code, null)) && isTrue(!isEqual(code, "0"))))
        {
            object feedback = add(add(this.id, " "), body);
            this.throwExactlyMatchedException(getValue(this.exceptions, "exact"), message, feedback);
            this.throwExactlyMatchedException(getValue(this.exceptions, "exact"), code, feedback);
            this.throwBroadlyMatchedException(getValue(this.exceptions, "broad"), message, feedback);
            throw new ExchangeError ((string)feedback) ;
        }
        return null;
    }
}
