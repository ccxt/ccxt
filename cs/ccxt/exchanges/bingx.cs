namespace ccxt;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

public partial class bingx : Exchange
{
    public override object describe()
    {
        return this.deepExtend(base.describe(), new Dictionary<string, object>() {
            { "id", "bingx" },
            { "name", "BingX" },
            { "countries", new List<object>() {"US"} },
            { "rateLimit", 1000 },
            { "version", "v1" },
            { "certified", true },
            { "pro", true },
            { "has", new Dictionary<string, object>() {
                { "CORS", null },
                { "spot", true },
                { "margin", false },
                { "swap", true },
                { "future", false },
                { "option", false },
                { "cancelAllOrders", true },
                { "cancelOrder", true },
                { "cancelOrders", true },
                { "closeAllPositions", true },
                { "closePosition", true },
                { "createMarketBuyOrderWithCost", true },
                { "createMarketOrderWithCost", true },
                { "createMarketSellOrderWithCost", true },
                { "createOrder", true },
                { "createOrders", true },
                { "createOrderWithTakeProfitAndStopLoss", true },
                { "createStopLossOrder", true },
                { "createTakeProfitOrder", true },
                { "createTrailingAmountOrder", true },
                { "createTrailingPercentOrder", true },
                { "createTriggerOrder", true },
                { "fetchBalance", true },
                { "fetchClosedOrders", true },
                { "fetchCurrencies", true },
                { "fetchDepositAddress", true },
                { "fetchDepositAddressesByNetwork", true },
                { "fetchDeposits", true },
                { "fetchDepositWithdrawFee", "emulated" },
                { "fetchDepositWithdrawFees", true },
                { "fetchFundingRate", true },
                { "fetchFundingRateHistory", true },
                { "fetchFundingRates", true },
                { "fetchLeverage", true },
                { "fetchLiquidations", false },
                { "fetchMarginMode", true },
                { "fetchMarkets", true },
                { "fetchMarkOHLCV", true },
                { "fetchMyLiquidations", true },
                { "fetchOHLCV", true },
                { "fetchOpenInterest", true },
                { "fetchOpenOrders", true },
                { "fetchOrder", true },
                { "fetchOrderBook", true },
                { "fetchPositionMode", true },
                { "fetchPositions", true },
                { "fetchTicker", true },
                { "fetchTickers", true },
                { "fetchTime", true },
                { "fetchTrades", true },
                { "fetchTransfers", true },
                { "fetchWithdrawals", true },
                { "setLeverage", true },
                { "setMargin", true },
                { "setMarginMode", true },
                { "setPositionMode", true },
                { "transfer", true },
            } },
            { "hostname", "bingx.com" },
            { "urls", new Dictionary<string, object>() {
                { "logo", "https://github-production-user-asset-6210df.s3.amazonaws.com/1294454/253675376-6983b72e-4999-4549-b177-33b374c195e3.jpg" },
                { "api", new Dictionary<string, object>() {
                    { "spot", "https://open-api.{hostname}/openApi" },
                    { "swap", "https://open-api.{hostname}/openApi" },
                    { "contract", "https://open-api.{hostname}/openApi" },
                    { "wallets", "https://open-api.{hostname}/openApi" },
                    { "user", "https://open-api.{hostname}/openApi" },
                    { "subAccount", "https://open-api.{hostname}/openApi" },
                    { "account", "https://open-api.{hostname}/openApi" },
                    { "copyTrading", "https://open-api.{hostname}/openApi" },
                } },
                { "test", new Dictionary<string, object>() {
                    { "swap", "https://open-api-vst.{hostname}/openApi" },
                } },
                { "www", "https://bingx.com/" },
                { "doc", "https://bingx-api.github.io/docs/" },
                { "referral", "https://bingx.com/invite/OHETOM" },
            } },
            { "fees", new Dictionary<string, object>() {
                { "tierBased", true },
                { "spot", new Dictionary<string, object>() {
                    { "feeSide", "get" },
                    { "maker", this.parseNumber("0.001") },
                    { "taker", this.parseNumber("0.001") },
                } },
                { "swap", new Dictionary<string, object>() {
                    { "feeSide", "quote" },
                    { "maker", this.parseNumber("0.0002") },
                    { "taker", this.parseNumber("0.0005") },
                } },
            } },
            { "requiredCredentials", new Dictionary<string, object>() {
                { "apiKey", true },
                { "secret", true },
            } },
            { "api", new Dictionary<string, object>() {
                { "spot", new Dictionary<string, object>() {
                    { "v1", new Dictionary<string, object>() {
                        { "public", new Dictionary<string, object>() {
                            { "get", new Dictionary<string, object>() {
                                { "common/symbols", 3 },
                                { "market/trades", 3 },
                                { "market/depth", 3 },
                                { "market/kline", 3 },
                                { "ticker/24hr", 1 },
                            } },
                        } },
                        { "private", new Dictionary<string, object>() {
                            { "get", new Dictionary<string, object>() {
                                { "trade/query", 3 },
                                { "trade/openOrders", 3 },
                                { "trade/historyOrders", 3 },
                                { "trade/myTrades", 3 },
                                { "user/commissionRate", 3 },
                                { "account/balance", 3 },
                            } },
                            { "post", new Dictionary<string, object>() {
                                { "trade/order", 3 },
                                { "trade/cancel", 3 },
                                { "trade/batchOrders", 3 },
                                { "trade/order/cancelReplace", 3 },
                                { "trade/cancelOrders", 3 },
                                { "trade/cancelOpenOrders", 3 },
                            } },
                        } },
                    } },
                    { "v3", new Dictionary<string, object>() {
                        { "private", new Dictionary<string, object>() {
                            { "get", new Dictionary<string, object>() {
                                { "get/asset/transfer", 3 },
                                { "asset/transfer", 3 },
                                { "capital/deposit/hisrec", 3 },
                                { "capital/withdraw/history", 3 },
                            } },
                            { "post", new Dictionary<string, object>() {
                                { "post/asset/transfer", 3 },
                            } },
                        } },
                    } },
                } },
                { "swap", new Dictionary<string, object>() {
                    { "v1", new Dictionary<string, object>() {
                        { "public", new Dictionary<string, object>() {
                            { "get", new Dictionary<string, object>() {
                                { "ticker/price", 1 },
                            } },
                        } },
                        { "private", new Dictionary<string, object>() {
                            { "get", new Dictionary<string, object>() {
                                { "positionSide/dual", 1 },
                                { "market/markPriceKlines", 1 },
                                { "trade/batchCancelReplace", 1 },
                            } },
                            { "post", new Dictionary<string, object>() {
                                { "trade/cancelReplace", 1 },
                                { "positionSide/dual", 1 },
                            } },
                        } },
                    } },
                    { "v2", new Dictionary<string, object>() {
                        { "public", new Dictionary<string, object>() {
                            { "get", new Dictionary<string, object>() {
                                { "server/time", 3 },
                                { "quote/contracts", 1 },
                                { "quote/price", 1 },
                                { "quote/depth", 1 },
                                { "quote/trades", 1 },
                                { "quote/premiumIndex", 1 },
                                { "quote/fundingRate", 1 },
                                { "quote/klines", 1 },
                                { "quote/openInterest", 1 },
                                { "quote/ticker", 1 },
                                { "quote/bookTicker", 1 },
                            } },
                        } },
                        { "private", new Dictionary<string, object>() {
                            { "get", new Dictionary<string, object>() {
                                { "user/balance", 3 },
                                { "user/positions", 3 },
                                { "user/income", 3 },
                                { "trade/openOrders", 3 },
                                { "trade/openOrder", 3 },
                                { "trade/order", 3 },
                                { "trade/marginType", 3 },
                                { "trade/leverage", 3 },
                                { "trade/forceOrders", 3 },
                                { "trade/allOrders", 3 },
                                { "trade/allFillOrders", 3 },
                                { "user/income/export", 3 },
                                { "user/commissionRate", 3 },
                                { "quote/bookTicker", 3 },
                            } },
                            { "post", new Dictionary<string, object>() {
                                { "trade/order", 3 },
                                { "trade/batchOrders", 3 },
                                { "trade/closeAllPositions", 3 },
                                { "trade/marginType", 3 },
                                { "trade/leverage", 3 },
                                { "trade/positionMargin", 3 },
                                { "trade/order/test", 3 },
                            } },
                            { "delete", new Dictionary<string, object>() {
                                { "trade/order", 3 },
                                { "trade/batchOrders", 3 },
                                { "trade/allOpenOrders", 3 },
                            } },
                        } },
                    } },
                    { "v3", new Dictionary<string, object>() {
                        { "public", new Dictionary<string, object>() {
                            { "get", new Dictionary<string, object>() {
                                { "quote/klines", 1 },
                            } },
                        } },
                    } },
                } },
                { "contract", new Dictionary<string, object>() {
                    { "v1", new Dictionary<string, object>() {
                        { "private", new Dictionary<string, object>() {
                            { "get", new Dictionary<string, object>() {
                                { "allPosition", 3 },
                                { "allOrders", 3 },
                                { "balance", 3 },
                            } },
                        } },
                    } },
                } },
                { "wallets", new Dictionary<string, object>() {
                    { "v1", new Dictionary<string, object>() {
                        { "private", new Dictionary<string, object>() {
                            { "get", new Dictionary<string, object>() {
                                { "capital/config/getall", 3 },
                                { "capital/deposit/address", 1 },
                                { "capital/innerTransfer/records", 1 },
                                { "capital/subAccount/deposit/address", 1 },
                                { "capital/deposit/subHisrec", 1 },
                                { "capital/subAccount/innerTransfer/records", 1 },
                            } },
                            { "post", new Dictionary<string, object>() {
                                { "capital/withdraw/apply", 3 },
                                { "capital/innerTransfer/apply", 3 },
                                { "capital/subAccountInnerTransfer/apply", 3 },
                                { "capital/deposit/createSubAddress", 1 },
                            } },
                        } },
                    } },
                } },
                { "subAccount", new Dictionary<string, object>() {
                    { "v1", new Dictionary<string, object>() {
                        { "private", new Dictionary<string, object>() {
                            { "get", new Dictionary<string, object>() {
                                { "list", 3 },
                                { "assets", 3 },
                                { "apiKey/query", 1 },
                            } },
                            { "post", new Dictionary<string, object>() {
                                { "create", 3 },
                                { "apiKey/create", 3 },
                                { "apiKey/edit", 3 },
                                { "apiKey/del", 3 },
                                { "updateStatus", 3 },
                            } },
                        } },
                    } },
                } },
                { "account", new Dictionary<string, object>() {
                    { "v1", new Dictionary<string, object>() {
                        { "private", new Dictionary<string, object>() {
                            { "get", new Dictionary<string, object>() {
                                { "uid", 1 },
                            } },
                            { "post", new Dictionary<string, object>() {
                                { "innerTransfer/authorizeSubAccount", 3 },
                            } },
                        } },
                    } },
                } },
                { "user", new Dictionary<string, object>() {
                    { "auth", new Dictionary<string, object>() {
                        { "private", new Dictionary<string, object>() {
                            { "post", new Dictionary<string, object>() {
                                { "userDataStream", 1 },
                            } },
                            { "put", new Dictionary<string, object>() {
                                { "userDataStream", 1 },
                            } },
                        } },
                    } },
                } },
                { "copyTrading", new Dictionary<string, object>() {
                    { "v1", new Dictionary<string, object>() {
                        { "private", new Dictionary<string, object>() {
                            { "get", new Dictionary<string, object>() {
                                { "swap/trace/currentTrack", 1 },
                            } },
                            { "post", new Dictionary<string, object>() {
                                { "swap/trace/closeTrackOrder", 1 },
                                { "swap/trace/setTPSL", 1 },
                            } },
                        } },
                    } },
                } },
                { "api", new Dictionary<string, object>() {
                    { "v3", new Dictionary<string, object>() {
                        { "private", new Dictionary<string, object>() {
                            { "get", new Dictionary<string, object>() {
                                { "asset/transfer", 1 },
                                { "capital/deposit/hisrec", 1 },
                                { "capital/withdraw/history", 1 },
                            } },
                            { "post", new Dictionary<string, object>() {
                                { "post/asset/transfer", 1 },
                            } },
                        } },
                    } },
                } },
            } },
            { "timeframes", new Dictionary<string, object>() {
                { "1m", "1m" },
                { "3m", "3m" },
                { "5m", "5m" },
                { "15m", "15m" },
                { "30m", "30m" },
                { "1h", "1h" },
                { "2h", "2h" },
                { "4h", "4h" },
                { "6h", "6h" },
                { "12h", "12h" },
                { "1d", "1d" },
                { "3d", "3d" },
                { "1w", "1w" },
                { "1M", "1M" },
            } },
            { "precisionMode", DECIMAL_PLACES },
            { "exceptions", new Dictionary<string, object>() {
                { "exact", new Dictionary<string, object>() {
                    { "400", typeof(BadRequest) },
                    { "401", typeof(AuthenticationError) },
                    { "403", typeof(PermissionDenied) },
                    { "404", typeof(BadRequest) },
                    { "429", typeof(DDoSProtection) },
                    { "418", typeof(PermissionDenied) },
                    { "500", typeof(ExchangeError) },
                    { "504", typeof(ExchangeError) },
                    { "100001", typeof(AuthenticationError) },
                    { "100412", typeof(AuthenticationError) },
                    { "100202", typeof(InsufficientFunds) },
                    { "100204", typeof(BadRequest) },
                    { "100400", typeof(BadRequest) },
                    { "100421", typeof(BadSymbol) },
                    { "100440", typeof(ExchangeError) },
                    { "100500", typeof(ExchangeError) },
                    { "100503", typeof(ExchangeError) },
                    { "80001", typeof(BadRequest) },
                    { "80012", typeof(InsufficientFunds) },
                    { "80014", typeof(BadRequest) },
                    { "80016", typeof(OrderNotFound) },
                    { "80017", typeof(OrderNotFound) },
                    { "100414", typeof(AccountSuspended) },
                    { "100419", typeof(PermissionDenied) },
                    { "100437", typeof(BadRequest) },
                    { "101204", typeof(InsufficientFunds) },
                } },
                { "broad", new Dictionary<string, object>() {} },
            } },
            { "commonCurrencies", new Dictionary<string, object>() {
                { "SNOW", "Snowman" },
            } },
            { "options", new Dictionary<string, object>() {
                { "defaultType", "spot" },
                { "accountsByType", new Dictionary<string, object>() {
                    { "spot", "FUND" },
                    { "swap", "PFUTURES" },
                    { "future", "SFUTURES" },
                } },
                { "accountsById", new Dictionary<string, object>() {
                    { "FUND", "spot" },
                    { "PFUTURES", "swap" },
                    { "SFUTURES", "future" },
                } },
                { "recvWindow", multiply(5, 1000) },
                { "broker", "CCXT" },
                { "defaultNetworks", new Dictionary<string, object>() {
                    { "ETH", "ETH" },
                    { "USDT", "ERC20" },
                    { "USDC", "ERC20" },
                    { "BTC", "BTC" },
                    { "LTC", "LTC" },
                } },
            } },
        });
    }

    public async override Task<object> fetchTime(object parameters = null)
    {
        /**
        * @method
        * @name bingx#fetchTime
        * @description fetches the current integer timestamp in milliseconds from the bingx server
        * @see https://bingx-api.github.io/docs/#/swapV2/base-info.html#Get%20Server%20Time
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {int} the current integer timestamp in milliseconds from the bingx server
        */
        parameters ??= new Dictionary<string, object>();
        object response = await this.swapV2PublicGetServerTime(parameters);
        //
        //    {
        //        "code": 0,
        //        "msg": "",
        //        "data": {
        //            "serverTime": 1675319535362
        //        }
        //    }
        //
        object data = this.safeValue(response, "data");
        return this.safeInteger(data, "serverTime");
    }

    public async override Task<object> fetchCurrencies(object parameters = null)
    {
        /**
        * @method
        * @name bingx#fetchCurrencies
        * @description fetches all available currencies on an exchange
        * @see https://bingx-api.github.io/docs/#/common/account-api.html#All%20Coins
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} an associative dictionary of currencies
        */
        parameters ??= new Dictionary<string, object>();
        if (!isTrue(this.checkRequiredCredentials(false)))
        {
            return null;
        }
        object isSandbox = this.safeBool(this.options, "sandboxMode", false);
        if (isTrue(isSandbox))
        {
            return null;
        }
        object response = await this.walletsV1PrivateGetCapitalConfigGetall(parameters);
        //
        //    {
        //        "code": 0,
        //        "timestamp": 1688045966616,
        //        "data": [
        //            {
        //              "coin": "BTC",
        //              "name": "BTC",
        //              "networkList": [
        //                {
        //                  "name": "BTC",
        //                  "network": "BTC",
        //                  "isDefault": true,
        //                  "minConfirm": "2",
        //                  "withdrawEnable": true,
        //                  "withdrawFee": "0.00035",
        //                  "withdrawMax": "1.62842",
        //                  "withdrawMin": "0.0005"
        //                },
        //                {
        //                  "name": "BTC",
        //                  "network": "BEP20",
        //                  "isDefault": false,
        //                  "minConfirm": "15",
        //                  "withdrawEnable": true,
        //                  "withdrawFee": "0.00001",
        //                  "withdrawMax": "1.62734",
        //                  "withdrawMin": "0.0001"
        //                }
        //              ]
        //          },
        //          ...
        //        ],
        //    }
        //
        object data = this.safeValue(response, "data", new List<object>() {});
        object result = new Dictionary<string, object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
        {
            object entry = getValue(data, i);
            object currencyId = this.safeString(entry, "coin");
            object code = this.safeCurrencyCode(currencyId);
            object name = this.safeString(entry, "name");
            object networkList = this.safeValue(entry, "networkList");
            object networks = new Dictionary<string, object>() {};
            object fee = null;
            object active = null;
            object withdrawEnabled = null;
            object defaultLimits = new Dictionary<string, object>() {};
            for (object j = 0; isLessThan(j, getArrayLength(networkList)); postFixIncrement(ref j))
            {
                object rawNetwork = getValue(networkList, j);
                object network = this.safeString(rawNetwork, "network");
                object networkCode = this.networkIdToCode(network);
                object isDefault = this.safeValue(rawNetwork, "isDefault");
                withdrawEnabled = this.safeValue(rawNetwork, "withdrawEnable");
                object limits = new Dictionary<string, object>() {
                    { "amounts", new Dictionary<string, object>() {
                        { "min", this.safeNumber(rawNetwork, "withdrawMin") },
                        { "max", this.safeNumber(rawNetwork, "withdrawMax") },
                    } },
                };
                if (isTrue(isDefault))
                {
                    fee = this.safeNumber(rawNetwork, "withdrawFee");
                    active = withdrawEnabled;
                    defaultLimits = limits;
                }
                ((IDictionary<string,object>)networks)[(string)networkCode] = new Dictionary<string, object>() {
                    { "info", rawNetwork },
                    { "id", network },
                    { "network", networkCode },
                    { "fee", fee },
                    { "active", active },
                    { "deposit", null },
                    { "withdraw", withdrawEnabled },
                    { "precision", null },
                    { "limits", limits },
                };
            }
            ((IDictionary<string,object>)result)[(string)code] = new Dictionary<string, object>() {
                { "info", entry },
                { "code", code },
                { "id", currencyId },
                { "precision", null },
                { "name", name },
                { "active", active },
                { "deposit", null },
                { "withdraw", withdrawEnabled },
                { "networks", networks },
                { "fee", fee },
                { "limits", defaultLimits },
            };
        }
        return result;
    }

    public async virtual Task<object> fetchSpotMarkets(object parameters)
    {
        object response = await this.spotV1PublicGetCommonSymbols(parameters);
        //
        //    {
        //        "code": 0,
        //            "msg": "",
        //            "debugMsg": "",
        //            "data": {
        //              "symbols": [
        //                  {
        //                    "symbol": "GEAR-USDT",
        //                    "minQty": 735,
        //                    "maxQty": 2941177,
        //                    "minNotional": 5,
        //                    "maxNotional": 20000,
        //                    "status": 1,
        //                    "tickSize": 0.000001,
        //                    "stepSize": 1
        //                  },
        //                  ...
        //              ]
        //         }
        //    }
        //
        object data = this.safeValue(response, "data");
        object markets = this.safeValue(data, "symbols", new List<object>() {});
        return this.parseMarkets(markets);
    }

    public async virtual Task<object> fetchSwapMarkets(object parameters)
    {
        object response = await this.swapV2PublicGetQuoteContracts(parameters);
        //
        //    {
        //        "code": 0,
        //        "msg": "",
        //        "data": [
        //            {
        //              "contractId": "100",
        //              "symbol": "BTC-USDT",
        //              "size": "0.0001",
        //              "quantityPrecision": 4,
        //              "pricePrecision": 1,
        //              "feeRate": 0.0005,
        //              "tradeMinLimit": 1,
        //              "maxLongLeverage": 150,
        //              "maxShortLeverage": 150,
        //              "currency": "USDT",
        //              "asset": "BTC",
        //              "status": 1
        //            },
        //            ...
        //        ]
        //    }
        //
        object markets = this.safeValue(response, "data", new List<object>() {});
        return this.parseMarkets(markets);
    }

    public override object parseMarket(object market)
    {
        object id = this.safeString(market, "symbol");
        object symbolParts = ((string)id).Split(new [] {((string)"-")}, StringSplitOptions.None).ToList<object>();
        object baseId = getValue(symbolParts, 0);
        object quoteId = getValue(symbolParts, 1);
        object bs = this.safeCurrencyCode(baseId);
        object quote = this.safeCurrencyCode(quoteId);
        object currency = this.safeString(market, "currency");
        object settle = this.safeCurrencyCode(currency);
        object pricePrecision = this.safeInteger(market, "pricePrecision");
        if (isTrue(isEqual(pricePrecision, null)))
        {
            pricePrecision = this.precisionFromString(this.safeString(market, "tickSize"));
        }
        object quantityPrecision = this.safeInteger(market, "quantityPrecision");
        if (isTrue(isEqual(quantityPrecision, null)))
        {
            quantityPrecision = this.precisionFromString(this.safeString(market, "stepSize"));
        }
        object type = ((bool) isTrue((!isEqual(settle, null)))) ? "swap" : "spot";
        object spot = isEqual(type, "spot");
        object swap = isEqual(type, "swap");
        object symbol = add(add(bs, "/"), quote);
        if (isTrue(!isEqual(settle, null)))
        {
            symbol = add(symbol, add(":", settle));
        }
        object fees = this.safeValue(this.fees, type, new Dictionary<string, object>() {});
        object contractSize = this.safeNumber(market, "size");
        object isActive = isEqual(this.safeString(market, "status"), "1");
        object isInverse = ((bool) isTrue((spot))) ? null : false;
        object isLinear = ((bool) isTrue((spot))) ? null : swap;
        return this.safeMarketStructure(new Dictionary<string, object>() {
            { "id", id },
            { "symbol", symbol },
            { "base", bs },
            { "quote", quote },
            { "settle", settle },
            { "baseId", baseId },
            { "quoteId", quoteId },
            { "settleId", currency },
            { "type", type },
            { "spot", spot },
            { "margin", false },
            { "swap", swap },
            { "future", false },
            { "option", false },
            { "active", isActive },
            { "contract", swap },
            { "linear", isLinear },
            { "inverse", isInverse },
            { "taker", this.safeNumber(fees, "taker") },
            { "maker", this.safeNumber(fees, "maker") },
            { "feeSide", this.safeString(fees, "feeSide") },
            { "contractSize", contractSize },
            { "expiry", null },
            { "expiryDatetime", null },
            { "strike", null },
            { "optionType", null },
            { "precision", new Dictionary<string, object>() {
                { "amount", quantityPrecision },
                { "price", pricePrecision },
            } },
            { "limits", new Dictionary<string, object>() {
                { "leverage", new Dictionary<string, object>() {
                    { "min", null },
                    { "max", this.safeInteger(market, "maxLongLeverage") },
                } },
                { "amount", new Dictionary<string, object>() {
                    { "min", this.safeNumber(market, "minQty") },
                    { "max", this.safeNumber(market, "maxQty") },
                } },
                { "price", new Dictionary<string, object>() {
                    { "min", null },
                    { "max", null },
                } },
                { "cost", new Dictionary<string, object>() {
                    { "min", this.safeNumber(market, "minNotional") },
                    { "max", this.safeNumber(market, "maxNotional") },
                } },
            } },
            { "created", null },
            { "info", market },
        });
    }

    public async override Task<object> fetchMarkets(object parameters = null)
    {
        /**
        * @method
        * @name bingx#fetchMarkets
        * @description retrieves data on all markets for bingx
        * @see https://bingx-api.github.io/docs/#/spot/market-api.html#Query%20Symbols
        * @see https://bingx-api.github.io/docs/#/swapV2/market-api.html#Contract%20Information
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} an array of objects representing market data
        */
        parameters ??= new Dictionary<string, object>();
        object requests = new List<object> {this.fetchSwapMarkets(parameters)};
        object isSandbox = this.safeBool(this.options, "sandboxMode", false);
        if (!isTrue(isSandbox))
        {
            ((IList<object>)requests).Add(this.fetchSpotMarkets(parameters)); // sandbox is swap only
        }
        object promises = await promiseAll(requests);
        object spotMarkets = this.safeValue(promises, 0, new List<object>() {});
        object swapMarkets = this.safeValue(promises, 1, new List<object>() {});
        return this.arrayConcat(spotMarkets, swapMarkets);
    }

    public async override Task<object> fetchOHLCV(object symbol, object timeframe = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bingx#fetchOHLCV
        * @description fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
        * @see https://bingx-api.github.io/docs/#/swapV2/market-api.html#K-Line%20Data
        * @see https://bingx-api.github.io/docs/#/spot/market-api.html#Candlestick%20chart%20data
        * @see https://bingx-api.github.io/docs/#/swapV2/market-api.html#%20K-Line%20Data
        * @see https://bingx-api.github.io/docs/#/en-us/swapV2/market-api.html#K-Line%20Data%20-%20Mark%20Price
        * @param {string} symbol unified symbol of the market to fetch OHLCV data for
        * @param {string} timeframe the length of time each candle represents
        * @param {int} [since] timestamp in ms of the earliest candle to fetch
        * @param {int} [limit] the maximum amount of candles to fetch
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {int} [params.until] timestamp in ms of the latest candle to fetch
        * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [availble parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
        * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
        */
        timeframe ??= "1m";
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object paginate = false;
        var paginateparametersVariable = this.handleOptionAndParams(parameters, "fetchOHLCV", "paginate", false);
        paginate = ((IList<object>)paginateparametersVariable)[0];
        parameters = ((IList<object>)paginateparametersVariable)[1];
        if (isTrue(paginate))
        {
            return await this.fetchPaginatedCallDeterministic("fetchOHLCV", symbol, since, limit, timeframe, parameters, 1440);
        }
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        ((IDictionary<string,object>)request)["interval"] = this.safeString(this.timeframes, timeframe, timeframe);
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["startTime"] = since;
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        object until = this.safeInteger2(parameters, "until", "endTime");
        if (isTrue(!isEqual(until, null)))
        {
            parameters = this.omit(parameters, new List<object>() {"until"});
            ((IDictionary<string,object>)request)["endTime"] = until;
        }
        object response = null;
        if (isTrue(getValue(market, "spot")))
        {
            response = await this.spotV1PublicGetMarketKline(this.extend(request, parameters));
        } else
        {
            object price = this.safeString(parameters, "price");
            parameters = this.omit(parameters, "price");
            if (isTrue(isEqual(price, "mark")))
            {
                response = await this.swapV1PrivateGetMarketMarkPriceKlines(this.extend(request, parameters));
            } else
            {
                response = await this.swapV3PublicGetQuoteKlines(this.extend(request, parameters));
            }
        }
        //
        //    {
        //        "code": 0,
        //        "msg": "",
        //        "data": [
        //          {
        //            "open": "19396.8",
        //            "close": "19394.4",
        //            "high": "19397.5",
        //            "low": "19385.7",
        //            "volume": "110.05",
        //            "time": 1666583700000
        //          },
        //          ...
        //        ]
        //    }
        //
        // fetchMarkOHLCV
        //
        //    {
        //        "code": 0,
        //        "msg": "",
        //        "data": [
        //            {
        //                "open": "42191.7",
        //                "close": "42189.5",
        //                "high": "42196.5",
        //                "low": "42189.5",
        //                "volume": "0.00",
        //                "openTime": 1706508840000,
        //                "closeTime": 1706508840000
        //            }
        //        ]
        //    }
        //
        object ohlcvs = this.safeValue(response, "data", new List<object>() {});
        if (!isTrue(((ohlcvs is IList<object>) || (ohlcvs.GetType().IsGenericType && ohlcvs.GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>))))))
        {
            ohlcvs = new List<object>() {ohlcvs};
        }
        return this.parseOHLCVs(ohlcvs, market, timeframe, since, limit);
    }

    public override object parseOHLCV(object ohlcv, object market = null)
    {
        //
        //    {
        //        "open": "19394.4",
        //        "close": "19379.0",
        //        "high": "19394.4",
        //        "low": "19368.3",
        //        "volume": "167.44",
        //        "time": 1666584000000
        //    }
        //
        // fetchMarkOHLCV
        //
        //    {
        //        "open": "42191.7",
        //        "close": "42189.5",
        //        "high": "42196.5",
        //        "low": "42189.5",
        //        "volume": "0.00",
        //        "openTime": 1706508840000,
        //        "closeTime": 1706508840000
        //    }
        // spot
        //    [
        //        1691402580000,
        //        29093.61,
        //        29093.93,
        //        29087.73,
        //        29093.24,
        //        0.59,
        //        1691402639999,
        //        17221.07
        //    ]
        //
        if (isTrue(((ohlcv is IList<object>) || (ohlcv.GetType().IsGenericType && ohlcv.GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>))))))
        {
            return new List<object> {this.safeInteger(ohlcv, 0), this.safeNumber(ohlcv, 1), this.safeNumber(ohlcv, 2), this.safeNumber(ohlcv, 3), this.safeNumber(ohlcv, 4), this.safeNumber(ohlcv, 5)};
        }
        return new List<object> {this.safeInteger2(ohlcv, "time", "closeTime"), this.safeNumber(ohlcv, "open"), this.safeNumber(ohlcv, "high"), this.safeNumber(ohlcv, "low"), this.safeNumber(ohlcv, "close"), this.safeNumber(ohlcv, "volume")};
    }

    public async override Task<object> fetchTrades(object symbol, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bingx#fetchTrades
        * @description get the list of most recent trades for a particular symbol
        * @see https://bingx-api.github.io/docs/#/spot/market-api.html#Query%20transaction%20records
        * @see https://bingx-api.github.io/docs/#/swapV2/market-api.html#The%20latest%20Trade%20of%20a%20Trading%20Pair
        * @param {string} symbol unified symbol of the market to fetch trades for
        * @param {int} [since] timestamp in ms of the earliest trade to fetch
        * @param {int} [limit] the maximum amount of trades to fetch
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = mathMin(limit, 100); // avoid API exception "limit should less than 100"
        }
        object response = null;
        object marketType = null;
        var marketTypeparametersVariable = this.handleMarketTypeAndParams("fetchTrades", market, parameters);
        marketType = ((IList<object>)marketTypeparametersVariable)[0];
        parameters = ((IList<object>)marketTypeparametersVariable)[1];
        if (isTrue(isEqual(marketType, "spot")))
        {
            response = await this.spotV1PublicGetMarketTrades(this.extend(request, parameters));
        } else
        {
            response = await this.swapV2PublicGetQuoteTrades(this.extend(request, parameters));
        }
        //
        // spot
        //
        //    {
        //        "code": 0,
        //        "data": [
        //            {
        //                "id": 43148253,
        //                "price": 25714.71,
        //                "qty": 1.674571,
        //                "time": 1655085975589,
        //                "buyerMaker": false
        //            }
        //        ]
        //    }
        //
        // swap
        //
        //    {
        //      "code":0,
        //      "msg":"",
        //      "data":[
        //        {
        //          "time": 1672025549368,
        //          "isBuyerMaker": true,
        //          "price": "16885.0",
        //          "qty": "3.3002",
        //          "quoteQty": "55723.87"
        //        },
        //        ...
        //      ]
        //    }
        //
        object trades = this.safeValue(response, "data", new List<object>() {});
        return this.parseTrades(trades, market, since, limit);
    }

    public override object parseTrade(object trade, object market = null)
    {
        //
        // spot
        // fetchTrades
        //
        //    {
        //        "id": 43148253,
        //        "price": 25714.71,
        //        "qty": 1.674571,
        //        "time": 1655085975589,
        //        "buyerMaker": false
        //    }
        //
        // spot
        // fetchMyTrades
        //     {
        //         "symbol": "LTC-USDT",
        //         "id": 36237072,
        //         "orderId": 1674069326895775744,
        //         "price": "85.891",
        //         "qty": "0.0582",
        //         "quoteQty": "4.9988562000000005",
        //         "commission": -0.00005820000000000001,
        //         "commissionAsset": "LTC",
        //         "time": 1687964205000,
        //         "isBuyer": true,
        //         "isMaker": false
        //     }
        //
        // swap
        // fetchTrades
        //
        //    {
        //        "time": 1672025549368,
        //        "isBuyerMaker": true,
        //        "price": "16885.0",
        //        "qty": "3.3002",
        //        "quoteQty": "55723.87"
        //    }
        //
        // swap
        // fetchMyTrades
        //
        //    {
        //        "volume": "0.1",
        //        "price": "106.75",
        //        "amount": "10.6750",
        //        "commission": "-0.0053",
        //        "currency": "USDT",
        //        "orderId": "1676213270274379776",
        //        "liquidatedPrice": "0.00",
        //        "liquidatedMarginRatio": "0.00",
        //        "filledTime": "2023-07-04T20:56:01.000+0800"
        //    }
        //
        //
        // ws
        //
        // spot
        //
        //    {
        //        "E": 1690214529432,
        //        "T": 1690214529386,
        //        "e": "trade",
        //        "m": true,
        //        "p": "29110.19",
        //        "q": "0.1868",
        //        "s": "BTC-USDT",
        //        "t": "57903921"
        //    }
        //
        // swap
        //
        //    {
        //        "q": "0.0421",
        //        "p": "29023.5",
        //        "T": 1690221401344,
        //        "m": false,
        //        "s": "BTC-USDT"
        //    }
        //
        object time = this.safeIntegerN(trade, new List<object>() {"time", "filledTm", "T"});
        object datetimeId = this.safeString(trade, "filledTm");
        if (isTrue(!isEqual(datetimeId, null)))
        {
            time = this.parse8601(datetimeId);
        }
        if (isTrue(isEqual(time, 0)))
        {
            time = null;
        }
        object cost = this.safeString(trade, "quoteQty");
        object type = ((bool) isTrue((isEqual(cost, null)))) ? "spot" : "swap";
        object currencyId = this.safeStringN(trade, new List<object>() {"currency", "N", "commissionAsset"});
        object currencyCode = this.safeCurrencyCode(currencyId);
        object m = this.safeValue(trade, "m");
        object marketId = this.safeString(trade, "s");
        object isBuyerMaker = this.safeValue2(trade, "buyerMaker", "isBuyerMaker");
        object takeOrMaker = null;
        if (isTrue(isTrue((!isEqual(isBuyerMaker, null))) || isTrue((!isEqual(m, null)))))
        {
            takeOrMaker = ((bool) isTrue((isTrue(isBuyerMaker) || isTrue(m)))) ? "maker" : "taker";
        }
        object side = this.safeStringLower2(trade, "side", "S");
        if (isTrue(isEqual(side, null)))
        {
            if (isTrue(isTrue((!isEqual(isBuyerMaker, null))) || isTrue((!isEqual(m, null)))))
            {
                side = ((bool) isTrue((isTrue(isBuyerMaker) || isTrue(m)))) ? "sell" : "buy";
                takeOrMaker = "taker";
            }
        }
        object isBuyer = this.safeValue(trade, "isBuyer");
        if (isTrue(!isEqual(isBuyer, null)))
        {
            side = ((bool) isTrue(isBuyer)) ? "buy" : "sell";
        }
        object isMaker = this.safeValue(trade, "isMaker");
        if (isTrue(!isEqual(isMaker, null)))
        {
            takeOrMaker = ((bool) isTrue(isMaker)) ? "maker" : "taker";
        }
        return this.safeTrade(new Dictionary<string, object>() {
            { "id", this.safeStringN(trade, new List<object>() {"id", "t"}) },
            { "info", trade },
            { "timestamp", time },
            { "datetime", this.iso8601(time) },
            { "symbol", this.safeSymbol(marketId, market, "-", type) },
            { "order", this.safeString2(trade, "orderId", "i") },
            { "type", this.safeStringLower(trade, "o") },
            { "side", this.parseOrderSide(side) },
            { "takerOrMaker", takeOrMaker },
            { "price", this.safeString2(trade, "price", "p") },
            { "amount", this.safeStringN(trade, new List<object>() {"qty", "volume", "amount", "q"}) },
            { "cost", cost },
            { "fee", new Dictionary<string, object>() {
                { "cost", this.parseNumber(Precise.stringAbs(this.safeString2(trade, "commission", "n"))) },
                { "currency", currencyCode },
                { "rate", null },
            } },
        }, market);
    }

    public async override Task<object> fetchOrderBook(object symbol, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bingx#fetchOrderBook
        * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
        * @see https://bingx-api.github.io/docs/#/spot/market-api.html#Query%20depth%20information
        * @see https://bingx-api.github.io/docs/#/swapV2/market-api.html#Get%20Market%20Depth
        * @param {string} symbol unified symbol of the market to fetch the order book for
        * @param {int} [limit] the maximum amount of order book entries to return
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        object response = null;
        object marketType = null;
        var marketTypeparametersVariable = this.handleMarketTypeAndParams("fetchOrderBook", market, parameters);
        marketType = ((IList<object>)marketTypeparametersVariable)[0];
        parameters = ((IList<object>)marketTypeparametersVariable)[1];
        if (isTrue(isEqual(marketType, "spot")))
        {
            response = await this.spotV1PublicGetMarketDepth(this.extend(request, parameters));
        } else
        {
            response = await this.swapV2PublicGetQuoteDepth(this.extend(request, parameters));
        }
        //
        // spot
        //
        //     {
        //         "code": 0,
        //         "data": {
        //           "bids": [
        //             [
        //               "26324.73",
        //               "0.37655"
        //             ],
        //             [
        //               "26324.71",
        //               "0.31888"
        //             ],
        //         ],
        //         "asks": [
        //             [
        //               "26340.30",
        //               "6.45221"
        //             ],
        //             [
        //               "26340.15",
        //               "6.73261"
        //             ],
        //         ]}
        //     }
        //
        // swap
        //
        //     {
        //         "code": 0,
        //         "msg": "",
        //         "data": {
        //           "T": 1683914263304,
        //           "bids": [
        //             [
        //               "26300.90000000",
        //               "30408.00000000"
        //             ],
        //             [
        //               "26300.80000000",
        //               "50906.00000000"
        //             ],
        //         ],
        //         "asks": [
        //             [
        //               "26301.00000000",
        //               "43616.00000000"
        //             ],
        //             [
        //               "26301.10000000",
        //               "49402.00000000"
        //             ],
        //         ]}
        //     }
        //
        object orderbook = this.safeValue(response, "data", new Dictionary<string, object>() {});
        object timestamp = this.safeInteger2(orderbook, "T", "ts");
        return this.parseOrderBook(orderbook, getValue(market, "symbol"), timestamp, "bids", "asks", 0, 1);
    }

    public async override Task<object> fetchFundingRate(object symbol, object parameters = null)
    {
        /**
        * @method
        * @name bingx#fetchFundingRate
        * @description fetch the current funding rate
        * @see https://bingx-api.github.io/docs/#/swapV2/market-api.html#Current%20Funding%20Rate
        * @param {string} symbol unified market symbol
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [funding rate structure]{@link https://docs.ccxt.com/#/?id=funding-rate-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object response = await this.swapV2PublicGetQuotePremiumIndex(this.extend(request, parameters));
        //
        //    {
        //        "code":0,
        //        "msg":"",
        //        "data":[
        //          {
        //            "symbol": "BTC-USDT",
        //            "markPrice": "16884.5",
        //            "indexPrice": "16886.9",
        //            "lastFundingRate": "0.0001",
        //            "nextFundingTime": 1672041600000
        //          },
        //          ...
        //        ]
        //    }
        //
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        return this.parseFundingRate(data, market);
    }

    public async override Task<object> fetchFundingRates(object symbols = null, object parameters = null)
    {
        /**
        * @method
        * @name bingx#fetchFundingRate
        * @description fetch the current funding rate
        * @see https://bingx-api.github.io/docs/#/swapV2/market-api.html#Current%20Funding%20Rate
        * @param {string[]} [symbols] list of unified market symbols
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [funding rate structure]{@link https://docs.ccxt.com/#/?id=funding-rate-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        symbols = this.marketSymbols(symbols, "swap", true);
        object response = await this.swapV2PublicGetQuotePremiumIndex(this.extend(parameters));
        object data = this.safeValue(response, "data", new List<object>() {});
        object filteredResponse = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
        {
            object item = getValue(data, i);
            object marketId = this.safeString(item, "symbol");
            object market = this.safeMarket(marketId, null, null, "swap");
            if (isTrue(isTrue((isEqual(symbols, null))) || isTrue(this.inArray(getValue(market, "symbol"), symbols))))
            {
                ((IList<object>)filteredResponse).Add(this.parseFundingRate(item, market));
            }
        }
        return filteredResponse;
    }

    public override object parseFundingRate(object contract, object market = null)
    {
        //
        //     {
        //         "symbol": "BTC-USDT",
        //         "markPrice": "16884.5",
        //         "indexPrice": "16886.9",
        //         "lastFundingRate": "0.0001",
        //         "nextFundingTime": 1672041600000
        //     }
        //
        object marketId = this.safeString(contract, "symbol");
        object nextFundingTimestamp = this.safeInteger(contract, "nextFundingTime");
        return new Dictionary<string, object>() {
            { "info", contract },
            { "symbol", this.safeSymbol(marketId, market, "-", "swap") },
            { "markPrice", this.safeNumber(contract, "markPrice") },
            { "indexPrice", this.safeNumber(contract, "indexPrice") },
            { "interestRate", null },
            { "estimatedSettlePrice", null },
            { "timestamp", null },
            { "datetime", null },
            { "fundingRate", this.safeNumber(contract, "lastFundingRate") },
            { "fundingTimestamp", null },
            { "fundingDatetime", null },
            { "nextFundingRate", null },
            { "nextFundingTimestamp", nextFundingTimestamp },
            { "nextFundingDatetime", this.iso8601(nextFundingTimestamp) },
            { "previousFundingRate", null },
            { "previousFundingTimestamp", null },
            { "previousFundingDatetime", null },
        };
    }

    public async override Task<object> fetchFundingRateHistory(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bingx#fetchFundingRateHistory
        * @description fetches historical funding rate prices
        * @see https://bingx-api.github.io/docs/#/swapV2/market-api.html#Funding%20Rate%20History
        * @param {string} symbol unified symbol of the market to fetch the funding rate history for
        * @param {int} [since] timestamp in ms of the earliest funding rate to fetch
        * @param {int} [limit] the maximum amount of [funding rate structures]{@link https://docs.ccxt.com/#/?id=funding-rate-history-structure} to fetch
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {int} [params.until] timestamp in ms of the latest funding rate to fetch
        * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [availble parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
        * @returns {object[]} a list of [funding rate structures]{@link https://docs.ccxt.com/#/?id=funding-rate-history-structure}
        */
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchFundingRateHistory() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object paginate = false;
        var paginateparametersVariable = this.handleOptionAndParams(parameters, "fetchFundingRateHistory", "paginate");
        paginate = ((IList<object>)paginateparametersVariable)[0];
        parameters = ((IList<object>)paginateparametersVariable)[1];
        if (isTrue(paginate))
        {
            return await this.fetchPaginatedCallDeterministic("fetchFundingRateHistory", symbol, since, limit, "8h", parameters);
        }
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["startTime"] = since;
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        object until = this.safeInteger2(parameters, "until", "startTime");
        if (isTrue(!isEqual(until, null)))
        {
            parameters = this.omit(parameters, new List<object>() {"until"});
            ((IDictionary<string,object>)request)["startTime"] = until;
        }
        object response = await this.swapV2PublicGetQuoteFundingRate(this.extend(request, parameters));
        //
        //    {
        //        "code":0,
        //        "msg":"",
        //        "data":[
        //          {
        //            "symbol": "BTC-USDT",
        //            "fundingRate": "0.0001",
        //            "fundingTime": 1585684800000
        //          },
        //          ...
        //        ]
        //    }
        //
        object data = this.safeValue(response, "data", new List<object>() {});
        object rates = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
        {
            object entry = getValue(data, i);
            object marketId = this.safeString(entry, "symbol");
            object symbolInner = this.safeSymbol(marketId, market, "-", "swap");
            object timestamp = this.safeInteger(entry, "fundingTime");
            ((IList<object>)rates).Add(new Dictionary<string, object>() {
                { "info", entry },
                { "symbol", symbolInner },
                { "fundingRate", this.safeNumber(entry, "fundingRate") },
                { "timestamp", timestamp },
                { "datetime", this.iso8601(timestamp) },
            });
        }
        object sorted = this.sortBy(rates, "timestamp");
        return this.filterBySymbolSinceLimit(sorted, getValue(market, "symbol"), since, limit);
    }

    public async override Task<object> fetchOpenInterest(object symbol, object parameters = null)
    {
        /**
        * @method
        * @name bingx#fetchOpenInterest
        * @description Retrieves the open interest of a currency
        * @see https://bingx-api.github.io/docs/#/swapV2/market-api.html#Get%20Swap%20Open%20Positions
        * @param {string} symbol Unified CCXT market symbol
        * @param {object} [params] exchange specific parameters
        * @returns {object} an open interest structure{@link https://docs.ccxt.com/#/?id=open-interest-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object response = await this.swapV2PublicGetQuoteOpenInterest(this.extend(request, parameters));
        //
        //     {
        //         "code": 0,
        //         "msg": "",
        //         "data": {
        //           "openInterest": "3289641547.10",
        //           "symbol": "BTC-USDT",
        //           "time": 1672026617364
        //         }
        //     }
        //
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        return this.parseOpenInterest(data, market);
    }

    public override object parseOpenInterest(object interest, object market = null)
    {
        //
        //    {
        //        "openInterest": "3289641547.10",
        //        "symbol": "BTC-USDT",
        //        "time": 1672026617364
        //    }
        //
        object timestamp = this.safeInteger(interest, "time");
        object id = this.safeString(interest, "symbol");
        object symbol = this.safeSymbol(id, market, "-", "swap");
        object openInterest = this.safeNumber(interest, "openInterest");
        return this.safeOpenInterest(new Dictionary<string, object>() {
            { "symbol", symbol },
            { "baseVolume", null },
            { "quoteVolume", null },
            { "openInterestAmount", null },
            { "openInterestValue", openInterest },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "info", interest },
        }, market);
    }

    public async override Task<object> fetchTicker(object symbol, object parameters = null)
    {
        /**
        * @method
        * @name bingx#fetchTicker
        * @description fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
        * @see https://bingx-api.github.io/docs/#/swapV2/market-api.html#Get%20Ticker
        * @see https://bingx-api.github.io/docs/#/spot/market-api.html#24%E5%B0%8F%E6%97%B6%E4%BB%B7%E6%A0%BC%E5%8F%98%E5%8A%A8%E6%83%85%E5%86%B5
        * @param {string} symbol unified symbol of the market to fetch the ticker for
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object response = null;
        if (isTrue(getValue(market, "spot")))
        {
            response = await this.spotV1PublicGetTicker24hr(this.extend(request, parameters));
        } else
        {
            response = await this.swapV2PublicGetQuoteTicker(this.extend(request, parameters));
        }
        object data = this.safeValue(response, "data");
        object ticker = this.safeValue(data, 0, data);
        return this.parseTicker(ticker, market);
    }

    public async override Task<object> fetchTickers(object symbols = null, object parameters = null)
    {
        /**
        * @method
        * @name bingx#fetchTickers
        * @description fetches price tickers for multiple markets, statistical information calculated over the past 24 hours for each market
        * @see https://bingx-api.github.io/docs/#/swapV2/market-api.html#Get%20Ticker
        * @param {string[]|undefined} symbols unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/#/?id=ticker-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = null;
        if (isTrue(!isEqual(symbols, null)))
        {
            symbols = this.marketSymbols(symbols);
            object firstSymbol = this.safeString(symbols, 0);
            if (isTrue(!isEqual(firstSymbol, null)))
            {
                market = this.market(firstSymbol);
            }
        }
        object type = null;
        var typeparametersVariable = this.handleMarketTypeAndParams("fetchTickers", market, parameters);
        type = ((IList<object>)typeparametersVariable)[0];
        parameters = ((IList<object>)typeparametersVariable)[1];
        object response = null;
        if (isTrue(isEqual(type, "spot")))
        {
            response = await this.spotV1PublicGetTicker24hr(parameters);
        } else
        {
            response = await this.swapV2PublicGetQuoteTicker(parameters);
        }
        object tickers = this.safeValue(response, "data");
        return this.parseTickers(tickers, symbols);
    }

    public override object parseTicker(object ticker, object market = null)
    {
        //
        // spot
        //    {
        //        "symbol": "BTC-USDT",
        //        "openPrice": "26032.08",
        //        "highPrice": "26178.86",
        //        "lowPrice": "25968.18",
        //        "lastPrice": "26113.60",
        //        "volume": "1161.79",
        //        "quoteVolume": "30288466.44",
        //        "openTime": "1693081020762",
        //        "closeTime": "1693167420762",
        //  added 2023-11-10:
        //        "bidPrice": 16726.0,
        //        "bidQty": 0.05,
        //        "askPrice": 16726.0,
        //        "askQty": 0.05,
        //    }
        // swap
        //
        //    {
        //        "symbol": "BTC-USDT",
        //        "priceChange": "52.5",
        //        "priceChangePercent": "0.31%", // they started to add the percent sign in value
        //        "lastPrice": "16880.5",
        //        "lastQty": "2.2238",          // only present in swap!
        //        "highPrice": "16897.5",
        //        "lowPrice": "16726.0",
        //        "volume": "245870.1692",
        //        "quoteVolume": "4151395117.73",
        //        "openPrice": "16832.0",
        //        "openTime": 1672026667803,
        //        "closeTime": 1672026648425,
        //  added 2023-11-10:
        //        "bidPrice": 16726.0,
        //        "bidQty": 0.05,
        //        "askPrice": 16726.0,
        //        "askQty": 0.05,
        //    }
        //
        object marketId = this.safeString(ticker, "symbol");
        object lastQty = this.safeString(ticker, "lastQty");
        // in spot markets, lastQty is not present
        // it's (bad, but) the only way we can check the tickers origin
        object type = ((bool) isTrue((isEqual(lastQty, null)))) ? "spot" : "swap";
        market = this.safeMarket(marketId, market, null, type);
        object symbol = getValue(market, "symbol");
        object open = this.safeString(ticker, "openPrice");
        object high = this.safeString(ticker, "highPrice");
        object low = this.safeString(ticker, "lowPrice");
        object close = this.safeString(ticker, "lastPrice");
        object quoteVolume = this.safeString(ticker, "quoteVolume");
        object baseVolume = this.safeString(ticker, "volume");
        object percentage = this.safeString(ticker, "priceChangePercent");
        if (isTrue(!isEqual(percentage, null)))
        {
            percentage = ((string)percentage).Replace((string)"%", (string)"");
        }
        object change = this.safeString(ticker, "priceChange");
        object ts = this.safeInteger(ticker, "closeTime");
        object datetime = this.iso8601(ts);
        object bid = this.safeString(ticker, "bidPrice");
        object bidVolume = this.safeString(ticker, "bidQty");
        object ask = this.safeString(ticker, "askPrice");
        object askVolume = this.safeString(ticker, "askQty");
        return this.safeTicker(new Dictionary<string, object>() {
            { "symbol", symbol },
            { "timestamp", ts },
            { "datetime", datetime },
            { "high", high },
            { "low", low },
            { "bid", bid },
            { "bidVolume", bidVolume },
            { "ask", ask },
            { "askVolume", askVolume },
            { "vwap", null },
            { "open", open },
            { "close", close },
            { "last", null },
            { "previousClose", null },
            { "change", change },
            { "percentage", percentage },
            { "average", null },
            { "baseVolume", baseVolume },
            { "quoteVolume", quoteVolume },
            { "info", ticker },
        }, market);
    }

    public async override Task<object> fetchBalance(object parameters = null)
    {
        /**
        * @method
        * @name bingx#fetchBalance
        * @description query for balance and get the amount of funds available for trading or funds locked in orders
        * @see https://bingx-api.github.io/docs/#/spot/trade-api.html#Query%20Assets
        * @see https://bingx-api.github.io/docs/#/swapV2/account-api.html#Get%20Perpetual%20Swap%20Account%20Asset%20Information
        * @see https://bingx-api.github.io/docs/#/standard/contract-interface.html#Query%20standard%20contract%20balance
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {boolean} [params.standard] whether to fetch standard contract balances
        * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = null;
        object standard = null;
        var standardparametersVariable = this.handleOptionAndParams(parameters, "fetchBalance", "standard", false);
        standard = ((IList<object>)standardparametersVariable)[0];
        parameters = ((IList<object>)standardparametersVariable)[1];
        var marketTypemarketTypeQueryVariable = this.handleMarketTypeAndParams("fetchBalance", null, parameters);
        var marketType = ((IList<object>) marketTypemarketTypeQueryVariable)[0];
        var marketTypeQuery = ((IList<object>) marketTypemarketTypeQueryVariable)[1];
        if (isTrue(standard))
        {
            response = await this.contractV1PrivateGetBalance(marketTypeQuery);
        } else if (isTrue(isEqual(marketType, "spot")))
        {
            response = await this.spotV1PrivateGetAccountBalance(marketTypeQuery);
        } else
        {
            response = await this.swapV2PrivateGetUserBalance(marketTypeQuery);
        }
        //
        // spot
        //
        //    {
        //        "code": 0,
        //        "msg": "",
        //        "ttl": 1,
        //        "data": {
        //            "balances": [
        //                {
        //                    "asset": "USDT",
        //                    "free": "16.73971130673954",
        //                    "locked": "0"
        //                }
        //            ]
        //        }
        //    }
        //
        // swap
        //
        //    {
        //        "code": 0,
        //        "msg": "",
        //        "data": {
        //          "balance": {
        //            "asset": "USDT",
        //            "balance": "15.6128",
        //            "equity": "15.6128",
        //            "unrealizedProfit": "0.0000",
        //            "realisedProfit": "0.0000",
        //            "availableMargin": "15.6128",
        //            "usedMargin": "0.0000",
        //            "freezedMargin": "0.0000"
        //          }
        //        }
        //    }
        // standard futures
        //    {
        //        "code":"0",
        //        "timestamp":"1691148990942",
        //        "data":[
        //           {
        //              "asset":"VST",
        //              "balance":"100000.00000000000000000000",
        //              "crossWalletBalance":"100000.00000000000000000000",
        //              "crossUnPnl":"0",
        //              "availableBalance":"100000.00000000000000000000",
        //              "maxWithdrawAmount":"100000.00000000000000000000",
        //              "marginAvailable":false,
        //              "updateTime":"1691148990902"
        //           },
        //           {
        //              "asset":"USDT",
        //              "balance":"0",
        //              "crossWalletBalance":"0",
        //              "crossUnPnl":"0",
        //              "availableBalance":"0",
        //              "maxWithdrawAmount":"0",
        //              "marginAvailable":false,
        //              "updateTime":"1691148990902"
        //           },
        //        ]
        //     }
        //
        return this.parseBalance(response);
    }

    public override object parseBalance(object response)
    {
        object data = this.safeValue(response, "data");
        object balances = this.safeValue2(data, "balance", "balances", data);
        object result = new Dictionary<string, object>() {
            { "info", response },
        };
        if (isTrue(((balances is IList<object>) || (balances.GetType().IsGenericType && balances.GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>))))))
        {
            for (object i = 0; isLessThan(i, getArrayLength(balances)); postFixIncrement(ref i))
            {
                object balance = getValue(balances, i);
                object currencyId = this.safeString(balance, "asset");
                object code = this.safeCurrencyCode(currencyId);
                object account = this.account();
                ((IDictionary<string,object>)account)["free"] = this.safeString2(balance, "free", "availableBalance");
                ((IDictionary<string,object>)account)["used"] = this.safeString(balance, "locked");
                ((IDictionary<string,object>)account)["total"] = this.safeString(balance, "balance");
                ((IDictionary<string,object>)result)[(string)code] = account;
            }
        } else
        {
            object currencyId = this.safeString(balances, "asset");
            object code = this.safeCurrencyCode(currencyId);
            object account = this.account();
            ((IDictionary<string,object>)account)["free"] = this.safeString(balances, "availableMargin");
            ((IDictionary<string,object>)account)["used"] = this.safeString(balances, "usedMargin");
            ((IDictionary<string,object>)result)[(string)code] = account;
        }
        return this.safeBalance(result);
    }

    public async override Task<object> fetchPositions(object symbols = null, object parameters = null)
    {
        /**
        * @method
        * @name bingx#fetchPositions
        * @description fetch all open positions
        * @see https://bingx-api.github.io/docs/#/swapV2/account-api.html#Perpetual%20Swap%20Positions
        * @see https://bingx-api.github.io/docs/#/standard/contract-interface.html#Query%20standard%20contract%20balance
        * @param {string[]|undefined} symbols list of unified market symbols
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {boolean} [params.standard] whether to fetch standard contract positions
        * @returns {object[]} a list of [position structure]{@link https://docs.ccxt.com/#/?id=position-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        symbols = this.marketSymbols(symbols);
        object standard = null;
        var standardparametersVariable = this.handleOptionAndParams(parameters, "fetchPositions", "standard", false);
        standard = ((IList<object>)standardparametersVariable)[0];
        parameters = ((IList<object>)standardparametersVariable)[1];
        object response = null;
        if (isTrue(standard))
        {
            response = await this.contractV1PrivateGetAllPosition(parameters);
        } else
        {
            response = await this.swapV2PrivateGetUserPositions(parameters);
        }
        //
        //    {
        //        "code": 0,
        //            "msg": "",
        //            "data": [
        //            {
        //                "symbol": "BTC-USDT",
        //                "positionId": "12345678",
        //                "positionSide": "LONG",
        //                "isolated": true,
        //                "positionAmt": "123.33",
        //                "availableAmt": "128.99",
        //                "unrealizedProfit": "1.22",
        //                "realisedProfit": "8.1",
        //                "initialMargin": "123.33",
        //                "avgPrice": "2.2",
        //                "leverage": 10,
        //            }
        //        ]
        //    }
        //
        object positions = this.safeValue(response, "data", new List<object>() {});
        return this.parsePositions(positions, symbols);
    }

    public override object parsePosition(object position, object market = null)
    {
        //
        //     {
        //         "symbol": "BTC-USDT",
        //         "positionId": "12345678",
        //         "positionSide": "LONG",
        //         "isolated": true,
        //         "positionAmt": "123.33",
        //         "availableAmt": "128.99",
        //         "unrealizedProfit": "1.22",
        //         "realisedProfit": "8.1",
        //         "initialMargin": "123.33",
        //         "avgPrice": "2.2",
        //         "leverage": 10,
        //     }
        //
        // standard position
        //
        //     {
        //         "currentPrice": "82.91",
        //         "symbol": "LTC/USDT",
        //         "initialMargin": "5.00000000000000000000",
        //         "unrealizedProfit": "-0.26464500",
        //         "leverage": "20.000000000",
        //         "isolated": true,
        //         "entryPrice": "83.13",
        //         "positionSide": "LONG",
        //         "positionAmt": "1.20365912",
        //     }
        //
        object marketId = this.safeString(position, "symbol", "");
        marketId = ((string)marketId).Replace((string)"/", (string)"-"); // standard return different format
        object isolated = this.safeValue(position, "isolated");
        object marginMode = null;
        if (isTrue(!isEqual(isolated, null)))
        {
            marginMode = ((bool) isTrue(isolated)) ? "isolated" : "cross";
        }
        return this.safePosition(new Dictionary<string, object>() {
            { "info", position },
            { "id", this.safeString(position, "positionId") },
            { "symbol", this.safeSymbol(marketId, market, "-", "swap") },
            { "notional", this.safeNumber(position, "positionAmt") },
            { "marginMode", marginMode },
            { "liquidationPrice", null },
            { "entryPrice", this.safeNumber2(position, "avgPrice", "entryPrice") },
            { "unrealizedPnl", this.safeNumber(position, "unrealizedProfit") },
            { "realizedPnl", this.safeNumber(position, "realisedProfit") },
            { "percentage", null },
            { "contracts", this.safeNumber(position, "positionAmt") },
            { "contractSize", null },
            { "markPrice", null },
            { "lastPrice", null },
            { "side", this.safeStringLower(position, "positionSide") },
            { "hedged", null },
            { "timestamp", null },
            { "datetime", null },
            { "lastUpdateTimestamp", null },
            { "maintenanceMargin", null },
            { "maintenanceMarginPercentage", null },
            { "collateral", this.safeNumber(position, "positionAmt") },
            { "initialMargin", this.safeNumber(position, "initialMargin") },
            { "initialMarginPercentage", null },
            { "leverage", this.safeNumber(position, "leverage") },
            { "marginRatio", null },
            { "stopLossPrice", null },
            { "takeProfitPrice", null },
        });
    }

    public async override Task<object> createMarketOrderWithCost(object symbol, object side, object cost, object parameters = null)
    {
        /**
        * @method
        * @name bingx#createMarketOrderWithCost
        * @description create a market order by providing the symbol, side and cost
        * @param {string} symbol unified symbol of the market to create an order in
        * @param {string} side 'buy' or 'sell'
        * @param {float} cost how much you want to trade in units of the quote currency
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        ((IDictionary<string,object>)parameters)["quoteOrderQty"] = cost;
        return await this.createOrder(symbol, "market", side, cost, null, parameters);
    }

    public async override Task<object> createMarketBuyOrderWithCost(object symbol, object cost, object parameters = null)
    {
        /**
        * @method
        * @name bingx#createMarketBuyOrderWithCost
        * @description create a market buy order by providing the symbol and cost
        * @param {string} symbol unified symbol of the market to create an order in
        * @param {float} cost how much you want to trade in units of the quote currency
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        ((IDictionary<string,object>)parameters)["quoteOrderQty"] = cost;
        return await this.createOrder(symbol, "market", "buy", cost, null, parameters);
    }

    public async override Task<object> createMarketSellOrderWithCost(object symbol, object cost, object parameters = null)
    {
        /**
        * @method
        * @name bingx#createMarketSellOrderWithCost
        * @description create a market sell order by providing the symbol and cost
        * @param {string} symbol unified symbol of the market to create an order in
        * @param {float} cost how much you want to trade in units of the quote currency
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        ((IDictionary<string,object>)parameters)["quoteOrderQty"] = cost;
        return await this.createOrder(symbol, "market", "sell", cost, null, parameters);
    }

    public virtual object createOrderRequest(object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        /**
        * @method
        * @ignore
        * @name bingx#createOrderRequest
        * @description helper function to build request
        * @param {string} symbol unified symbol of the market to create an order in
        * @param {string} type 'market' or 'limit'
        * @param {string} side 'buy' or 'sell'
        * @param {float} amount how much you want to trade in units of the base currency
        * @param {float} [price] the price at which the order is to be fullfilled, in units of the quote currency, ignored in market orders
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} request to be sent to the exchange
        */
        parameters ??= new Dictionary<string, object>();
        object market = this.market(symbol);
        object postOnly = null;
        object marketType = null;
        var marketTypeparametersVariable = this.handleMarketTypeAndParams("createOrder", market, parameters);
        marketType = ((IList<object>)marketTypeparametersVariable)[0];
        parameters = ((IList<object>)marketTypeparametersVariable)[1];
        type = ((string)type).ToUpper();
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
            { "type", type },
            { "side", ((string)side).ToUpper() },
        };
        object isMarketOrder = isEqual(type, "MARKET");
        object isSpot = isEqual(marketType, "spot");
        object exchangeClientOrderId = ((bool) isTrue(isSpot)) ? "newClientOrderId" : "clientOrderID";
        object clientOrderId = this.safeString2(parameters, exchangeClientOrderId, "clientOrderId");
        if (isTrue(!isEqual(clientOrderId, null)))
        {
            ((IDictionary<string,object>)request)[(string)exchangeClientOrderId] = clientOrderId;
        }
        object timeInForce = this.safeStringUpper(parameters, "timeInForce");
        if (isTrue(isEqual(timeInForce, "IOC")))
        {
            ((IDictionary<string,object>)request)["timeInForce"] = "IOC";
        }
        object triggerPrice = this.safeString2(parameters, "stopPrice", "triggerPrice");
        if (isTrue(isSpot))
        {
            var postOnlyparametersVariable = this.handlePostOnly(isMarketOrder, isEqual(timeInForce, "POC"), parameters);
            postOnly = ((IList<object>)postOnlyparametersVariable)[0];
            parameters = ((IList<object>)postOnlyparametersVariable)[1];
            if (isTrue(isTrue(postOnly) || isTrue((isEqual(timeInForce, "POC")))))
            {
                ((IDictionary<string,object>)request)["timeInForce"] = "POC";
            }
            object cost = this.safeNumber2(parameters, "cost", "quoteOrderQty");
            parameters = this.omit(parameters, "cost");
            if (isTrue(!isEqual(cost, null)))
            {
                ((IDictionary<string,object>)request)["quoteOrderQty"] = this.parseToNumeric(this.costToPrecision(symbol, cost));
            } else
            {
                if (isTrue(isTrue(isMarketOrder) && isTrue((!isEqual(price, null)))))
                {
                    // keep the legacy behavior, to avoid  breaking the old spot-market-buying code
                    object calculatedCost = Precise.stringMul(this.numberToString(amount), this.numberToString(price));
                    ((IDictionary<string,object>)request)["quoteOrderQty"] = this.parseToNumeric(calculatedCost);
                } else
                {
                    ((IDictionary<string,object>)request)["quantity"] = this.parseToNumeric(this.amountToPrecision(symbol, amount));
                }
            }
            if (!isTrue(isMarketOrder))
            {
                ((IDictionary<string,object>)request)["price"] = this.parseToNumeric(this.priceToPrecision(symbol, price));
            }
            if (isTrue(!isEqual(triggerPrice, null)))
            {
                if (isTrue(isTrue(isMarketOrder) && isTrue(isEqual(this.safeString(request, "quoteOrderQty"), null))))
                {
                    throw new ArgumentsRequired ((string)add(this.id, " createOrder() requires the cost parameter (or the amount + price) for placing spot market-buy trigger orders")) ;
                }
                ((IDictionary<string,object>)request)["stopPrice"] = this.priceToPrecision(symbol, triggerPrice);
                if (isTrue(isEqual(type, "LIMIT")))
                {
                    ((IDictionary<string,object>)request)["type"] = "TRIGGER_LIMIT";
                } else if (isTrue(isEqual(type, "MARKET")))
                {
                    ((IDictionary<string,object>)request)["type"] = "TRIGGER_MARKET";
                }
            }
        } else
        {
            var postOnlyparametersVariable = this.handlePostOnly(isMarketOrder, isEqual(timeInForce, "PostOnly"), parameters);
            postOnly = ((IList<object>)postOnlyparametersVariable)[0];
            parameters = ((IList<object>)postOnlyparametersVariable)[1];
            if (isTrue(isTrue(postOnly) || isTrue((isEqual(timeInForce, "PostOnly")))))
            {
                ((IDictionary<string,object>)request)["timeInForce"] = "PostOnly";
            } else if (isTrue(isEqual(timeInForce, "GTC")))
            {
                ((IDictionary<string,object>)request)["timeInForce"] = "GTC";
            } else if (isTrue(isEqual(timeInForce, "FOK")))
            {
                ((IDictionary<string,object>)request)["timeInForce"] = "FOK";
            }
            object stopLossPrice = this.safeString(parameters, "stopLossPrice");
            object takeProfitPrice = this.safeString(parameters, "takeProfitPrice");
            object trailingAmount = this.safeString(parameters, "trailingAmount");
            object trailingPercent = this.safeString2(parameters, "trailingPercent", "priceRate");
            object isTriggerOrder = !isEqual(triggerPrice, null);
            object isStopLossPriceOrder = !isEqual(stopLossPrice, null);
            object isTakeProfitPriceOrder = !isEqual(takeProfitPrice, null);
            object isTrailingAmountOrder = !isEqual(trailingAmount, null);
            object isTrailingPercentOrder = !isEqual(trailingPercent, null);
            object isTrailing = isTrue(isTrailingAmountOrder) || isTrue(isTrailingPercentOrder);
            object stopLoss = this.safeValue(parameters, "stopLoss");
            object takeProfit = this.safeValue(parameters, "takeProfit");
            object isStopLoss = !isEqual(stopLoss, null);
            object isTakeProfit = !isEqual(takeProfit, null);
            if (isTrue(isTrue((isTrue(isTrue(isTrue((isEqual(type, "LIMIT"))) || isTrue((isEqual(type, "TRIGGER_LIMIT")))) || isTrue((isEqual(type, "STOP")))) || isTrue((isEqual(type, "TAKE_PROFIT"))))) && !isTrue(isTrailing)))
            {
                ((IDictionary<string,object>)request)["price"] = this.parseToNumeric(this.priceToPrecision(symbol, price));
            }
            object reduceOnly = this.safeBool(parameters, "reduceOnly", false);
            if (isTrue(isTriggerOrder))
            {
                ((IDictionary<string,object>)request)["stopPrice"] = this.parseToNumeric(this.priceToPrecision(symbol, triggerPrice));
                if (isTrue(isTrue(isMarketOrder) || isTrue((isEqual(type, "TRIGGER_MARKET")))))
                {
                    ((IDictionary<string,object>)request)["type"] = "TRIGGER_MARKET";
                } else if (isTrue(isTrue((isEqual(type, "LIMIT"))) || isTrue((isEqual(type, "TRIGGER_LIMIT")))))
                {
                    ((IDictionary<string,object>)request)["type"] = "TRIGGER_LIMIT";
                }
            } else if (isTrue(isTrue(isStopLossPriceOrder) || isTrue(isTakeProfitPriceOrder)))
            {
                // This can be used to set the stop loss and take profit, but the position needs to be opened first
                reduceOnly = true;
                if (isTrue(isStopLossPriceOrder))
                {
                    ((IDictionary<string,object>)request)["stopPrice"] = this.parseToNumeric(this.priceToPrecision(symbol, stopLossPrice));
                    if (isTrue(isTrue(isMarketOrder) || isTrue((isEqual(type, "STOP_MARKET")))))
                    {
                        ((IDictionary<string,object>)request)["type"] = "STOP_MARKET";
                    } else if (isTrue(isTrue((isEqual(type, "LIMIT"))) || isTrue((isEqual(type, "STOP")))))
                    {
                        ((IDictionary<string,object>)request)["type"] = "STOP";
                    }
                } else if (isTrue(isTakeProfitPriceOrder))
                {
                    ((IDictionary<string,object>)request)["stopPrice"] = this.parseToNumeric(this.priceToPrecision(symbol, takeProfitPrice));
                    if (isTrue(isTrue(isMarketOrder) || isTrue((isEqual(type, "TAKE_PROFIT_MARKET")))))
                    {
                        ((IDictionary<string,object>)request)["type"] = "TAKE_PROFIT_MARKET";
                    } else if (isTrue(isTrue((isEqual(type, "LIMIT"))) || isTrue((isEqual(type, "TAKE_PROFIT")))))
                    {
                        ((IDictionary<string,object>)request)["type"] = "TAKE_PROFIT";
                    }
                }
            } else if (isTrue(isTrailing))
            {
                ((IDictionary<string,object>)request)["type"] = "TRAILING_STOP_MARKET";
                if (isTrue(isTrailingAmountOrder))
                {
                    ((IDictionary<string,object>)request)["price"] = this.parseToNumeric(trailingAmount);
                } else if (isTrue(isTrailingPercentOrder))
                {
                    object requestTrailingPercent = Precise.stringDiv(trailingPercent, "100");
                    ((IDictionary<string,object>)request)["priceRate"] = this.parseToNumeric(requestTrailingPercent);
                }
            }
            if (isTrue(isTrue(isStopLoss) || isTrue(isTakeProfit)))
            {
                object stringifiedAmount = this.numberToString(amount);
                if (isTrue(isStopLoss))
                {
                    object slTriggerPrice = this.safeString2(stopLoss, "triggerPrice", "stopPrice", stopLoss);
                    object slWorkingType = this.safeString(stopLoss, "workingType", "MARK_PRICE");
                    object slType = this.safeString(stopLoss, "type", "STOP_MARKET");
                    object slRequest = new Dictionary<string, object>() {
                        { "stopPrice", this.parseToNumeric(this.priceToPrecision(symbol, slTriggerPrice)) },
                        { "workingType", slWorkingType },
                        { "type", slType },
                    };
                    object slPrice = this.safeString(stopLoss, "price");
                    if (isTrue(!isEqual(slPrice, null)))
                    {
                        ((IDictionary<string,object>)slRequest)["price"] = this.parseToNumeric(this.priceToPrecision(symbol, slPrice));
                    }
                    object slQuantity = this.safeString(stopLoss, "quantity", stringifiedAmount);
                    ((IDictionary<string,object>)slRequest)["quantity"] = this.parseToNumeric(this.amountToPrecision(symbol, slQuantity));
                    ((IDictionary<string,object>)request)["stopLoss"] = this.json(slRequest);
                }
                if (isTrue(isTakeProfit))
                {
                    object tkTriggerPrice = this.safeString2(takeProfit, "triggerPrice", "stopPrice", takeProfit);
                    object tkWorkingType = this.safeString(takeProfit, "workingType", "MARK_PRICE");
                    object tpType = this.safeString(takeProfit, "type", "TAKE_PROFIT_MARKET");
                    object tpRequest = new Dictionary<string, object>() {
                        { "stopPrice", this.parseToNumeric(this.priceToPrecision(symbol, tkTriggerPrice)) },
                        { "workingType", tkWorkingType },
                        { "type", tpType },
                    };
                    object slPrice = this.safeString(takeProfit, "price");
                    if (isTrue(!isEqual(slPrice, null)))
                    {
                        ((IDictionary<string,object>)tpRequest)["price"] = this.parseToNumeric(this.priceToPrecision(symbol, slPrice));
                    }
                    object tkQuantity = this.safeString(takeProfit, "quantity", stringifiedAmount);
                    ((IDictionary<string,object>)tpRequest)["quantity"] = this.parseToNumeric(this.amountToPrecision(symbol, tkQuantity));
                    ((IDictionary<string,object>)request)["takeProfit"] = this.json(tpRequest);
                }
            }
            object positionSide = null;
            if (isTrue(reduceOnly))
            {
                positionSide = ((bool) isTrue((isEqual(side, "buy")))) ? "SHORT" : "LONG";
            } else
            {
                positionSide = ((bool) isTrue((isEqual(side, "buy")))) ? "LONG" : "SHORT";
            }
            ((IDictionary<string,object>)request)["positionSide"] = positionSide;
            ((IDictionary<string,object>)request)["quantity"] = this.parseToNumeric(this.amountToPrecision(symbol, amount));
            parameters = this.omit(parameters, new List<object>() {"reduceOnly", "triggerPrice", "stopLossPrice", "takeProfitPrice", "trailingAmount", "trailingPercent", "takeProfit", "stopLoss", "clientOrderId"});
        }
        return this.extend(request, parameters);
    }

    public async override Task<object> createOrder(object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        /**
        * @method
        * @name bingx#createOrder
        * @description create a trade order
        * @see https://bingx-api.github.io/docs/#/en-us/swapV2/trade-api.html#Trade%20order
        * @see https://bingx-api.github.io/docs/#/en-us/spot/trade-api.html#Create%20an%20Order
        * @param {string} symbol unified symbol of the market to create an order in
        * @param {string} type 'market' or 'limit'
        * @param {string} side 'buy' or 'sell'
        * @param {float} amount how much you want to trade in units of the base currency
        * @param {float} [price] the price at which the order is to be fullfilled, in units of the quote currency, ignored in market orders
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {string} [params.clientOrderId] a unique id for the order
        * @param {bool} [params.postOnly] true to place a post only order
        * @param {string} [params.timeInForce] spot supports 'PO' and 'IOC', swap supports 'PO', 'GTC', 'IOC' and 'FOK'
        * @param {bool} [params.reduceOnly] *swap only* true or false whether the order is reduce only
        * @param {float} [params.triggerPrice] *swap only* triggerPrice at which the attached take profit / stop loss order will be triggered
        * @param {float} [params.stopLossPrice] *swap only* stop loss trigger price
        * @param {float} [params.takeProfitPrice] *swap only* take profit trigger price
        * @param {float} [params.cost] the quote quantity that can be used as an alternative for the amount
        * @param {float} [params.trailingAmount] *swap only* the quote amount to trail away from the current market price
        * @param {float} [params.trailingPercent] *swap only* the percent to trail away from the current market price
        * @param {object} [params.takeProfit] *takeProfit object in params* containing the triggerPrice at which the attached take profit order will be triggered
        * @param {float} [params.takeProfit.triggerPrice] take profit trigger price
        * @param {object} [params.stopLoss] *stopLoss object in params* containing the triggerPrice at which the attached stop loss order will be triggered
        * @param {float} [params.stopLoss.triggerPrice] stop loss trigger price
        * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = this.createOrderRequest(symbol, type, side, amount, price, parameters);
        object response = null;
        if (isTrue(getValue(market, "swap")))
        {
            response = await this.swapV2PrivatePostTradeOrder(request);
        } else
        {
            response = await this.spotV1PrivatePostTradeOrder(request);
        }
        //
        // spot
        //
        //    {
        //        "code": 0,
        //        "msg": "",
        //        "data": {
        //            "symbol": "XRP-USDT",
        //            "orderId": 1514090846268424192,
        //            "transactTime": 1649822362855,
        //            "price": "0.5",
        //            "origQty": "10",
        //            "executedQty": "0",
        //            "cummulativeQuoteQty": "0",
        //            "status": "PENDING",
        //            "type": "LIMIT",
        //            "side": "BUY"
        //        }
        //    }
        //
        // swap
        //
        //     {
        //         "code": 0,
        //         "msg": "",
        //         "data": {
        //             "order": {
        //                 "symbol": "BTC-USDT",
        //                 "orderId": 1709036527545438208,
        //                 "side": "BUY",
        //                 "positionSide": "LONG",
        //                 "type": "TRIGGER_LIMIT",
        //                 "clientOrderID": "",
        //                 "workingType": ""
        //             }
        //         }
        //     }
        //
        if (isTrue((response is string)))
        {
            // broken api engine : order-ids are too long numbers (i.e. 1742930526912864656)
            // and JSON.parse can not handle them in JS, so we have to use .parseJson
            // however, when order has an attached SL/TP, their value types need extra parsing
            response = this.fixStringifiedJsonMembers(response);
            response = this.parseJson(response);
        }
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        object order = this.safeValue(data, "order", data);
        return this.parseOrder(order, market);
    }

    public async override Task<object> createOrders(object orders, object parameters = null)
    {
        /**
        * @method
        * @name bingx#createOrders
        * @description create a list of trade orders
        * @see https://bingx-api.github.io/docs/#/spot/trade-api.html#Batch%20Placing%20Orders
        * @see https://bingx-api.github.io/docs/#/swapV2/trade-api.html#Bulk%20order
        * @param {Array} orders list of orders to create, each object should contain the parameters required by createOrder, namely symbol, type, side, amount, price and params
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object ordersRequests = new List<object>() {};
        object symbol = null;
        for (object i = 0; isLessThan(i, getArrayLength(orders)); postFixIncrement(ref i))
        {
            object rawOrder = getValue(orders, i);
            object marketId = this.safeString(rawOrder, "symbol");
            if (isTrue(isEqual(symbol, null)))
            {
                symbol = marketId;
            } else
            {
                if (isTrue(!isEqual(symbol, marketId)))
                {
                    throw new BadRequest ((string)add(this.id, " createOrders() requires all orders to have the same symbol")) ;
                }
            }
            object type = this.safeString(rawOrder, "type");
            object side = this.safeString(rawOrder, "side");
            object amount = this.safeNumber(rawOrder, "amount");
            object price = this.safeNumber(rawOrder, "price");
            object orderParams = this.safeValue(rawOrder, "params", new Dictionary<string, object>() {});
            object orderRequest = this.createOrderRequest(marketId, type, side, amount, price, orderParams);
            ((IList<object>)ordersRequests).Add(orderRequest);
        }
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {};
        object response = null;
        if (isTrue(getValue(market, "swap")))
        {
            ((IDictionary<string,object>)request)["batchOrders"] = this.json(ordersRequests);
            response = await this.swapV2PrivatePostTradeBatchOrders(request);
        } else
        {
            ((IDictionary<string,object>)request)["data"] = this.json(ordersRequests);
            response = await this.spotV1PrivatePostTradeBatchOrders(request);
        }
        //
        // spot
        //
        //     {
        //         "code": 0,
        //         "msg": "",
        //         "debugMsg": "",
        //         "data": {
        //             "orders": [
        //                 {
        //                     "symbol": "BTC-USDT",
        //                     "orderId": 1720661389564968960,
        //                     "transactTime": 1699072618272,
        //                     "price": "25000",
        //                     "origQty": "0.0002",
        //                     "executedQty": "0",
        //                     "cummulativeQuoteQty": "0",
        //                     "status": "PENDING",
        //                     "type": "LIMIT",
        //                     "side": "BUY"
        //                 },
        //             ]
        //         }
        //     }
        //
        // swap
        //
        //     {
        //         "code": 0,
        //         "msg": "",
        //         "data": {
        //             "orders": [
        //                 {
        //                     "symbol": "BTC-USDT",
        //                     "orderId": 1720657081994006528,
        //                     "side": "BUY",
        //                     "positionSide": "LONG",
        //                     "type": "LIMIT",
        //                     "clientOrderID": "",
        //                     "workingType": ""
        //                 },
        //             ]
        //         }
        //     }
        //
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        object result = this.safeValue(data, "orders", new List<object>() {});
        return this.parseOrders(result, market);
    }

    public virtual object parseOrderSide(object side)
    {
        object sides = new Dictionary<string, object>() {
            { "BUY", "buy" },
            { "SELL", "sell" },
            { "SHORT", "sell" },
            { "LONG", "buy" },
        };
        return this.safeString(sides, side, side);
    }

    public virtual object parseOrderType(object type)
    {
        object types = new Dictionary<string, object>() {
            { "trigger_market", "market" },
            { "trigger_limit", "limit" },
        };
        return this.safeString(types, type, type);
    }

    public override object parseOrder(object order, object market = null)
    {
        //
        // spot
        // createOrder, createOrders, cancelOrder
        //
        //    {
        //        "symbol": "XRP-USDT",
        //        "orderId": 1514090846268424192,
        //        "transactTime": 1649822362855,
        //        "price": "0.5",
        //        "origQty": "10",
        //        "executedQty": "0",
        //        "cummulativeQuoteQty": "0",
        //        "status": "PENDING",
        //        "type": "LIMIT",
        //        "side": "BUY"
        //    }
        //
        // fetchOrder
        //
        //    {
        //        "symbol": "ETH-USDT",
        //        "orderId": "1660602123001266176",
        //        "price": "1700",
        //        "origQty": "0.003",
        //        "executedQty": "0",
        //        "cummulativeQuoteQty": "0",
        //        "status": "PENDING",
        //        "type": "LIMIT",
        //        "side": "BUY",
        //        "time": "1684753373276",
        //        "updateTime": "1684753373276",
        //        "origQuoteOrderQty": "0",
        //        "fee": "0",
        //        "feeAsset": "ETH"
        //    }
        //
        // fetchOpenOrders, fetchClosedOrders
        //
        //   {
        //       "symbol": "XRP-USDT",
        //       "orderId": 1514073325788200960,
        //       "price": "0.5",
        //       "StopPrice": "0",
        //       "origQty": "20",
        //       "executedQty": "10",
        //       "cummulativeQuoteQty": "5",
        //       "status": "PENDING",
        //       "type": "LIMIT",
        //       "side": "BUY",
        //       "time": 1649818185647,
        //       "updateTime": 1649818185647,
        //       "origQuoteOrderQty": "0"
        //       "fee": "-0.01"
        //   }
        //
        //
        // swap
        // createOrder, createOrders
        //
        //    {
        //      "symbol": "BTC-USDT",
        //      "orderId": 1590973236294713344,
        //      "side": "BUY",
        //      "positionSide": "LONG",
        //      "type": "LIMIT"
        //    }
        //
        // fetchOrder, fetchOpenOrders, fetchClosedOrders
        //
        //     {
        //         "symbol": "BTC-USDT",
        //         "orderId": 1709036527545438208,
        //         "side": "BUY",
        //         "positionSide": "LONG",
        //         "type": "TRIGGER_LIMIT",
        //         "origQty": "0.0010",
        //         "price": "22000.0",
        //         "executedQty": "0.0000",
        //         "avgPrice": "0.0",
        //         "cumQuote": "",
        //         "stopPrice": "23000.0",
        //         "profit": "",
        //         "commission": "",
        //         "status": "NEW",
        //         "time": 1696301035187,
        //         "updateTime": 1696301035187,
        //         "clientOrderId": "",
        //         "leverage": "",
        //         "takeProfit": "",
        //         "stopLoss": "",
        //         "advanceAttr": 0,
        //         "positionID": 0,
        //         "takeProfitEntrustPrice": 0,
        //         "stopLossEntrustPrice": 0,
        //         "orderType": "",
        //         "workingType": "MARK_PRICE"
        //     }
        // with tp and sl
        //    {
        //        orderId: 1741440894764281900,
        //        symbol: 'LTC-USDT',
        //        positionSide: 'LONG',
        //        side: 'BUY',
        //        type: 'MARKET',
        //        price: 0,
        //        quantity: 1,
        //        stopPrice: 0,
        //        workingType: 'MARK_PRICE',
        //        clientOrderID: '',
        //        timeInForce: 'GTC',
        //        priceRate: 0,
        //        stopLoss: '{"stopPrice":50,"workingType":"MARK_PRICE","type":"STOP_MARKET","quantity":1}',
        //        takeProfit: '{"stopPrice":150,"workingType":"MARK_PRICE","type":"TAKE_PROFIT_MARKET","quantity":1}',
        //        reduceOnly: false
        //    }
        //
        // editOrder (swap)
        //
        //    {
        //        cancelResult: 'true',
        //        cancelMsg: '',
        //        cancelResponse: {
        //            cancelClientOrderId: '',
        //            cancelOrderId: '1755336244265705472',
        //            symbol: 'SOL-USDT',
        //            orderId: '1755336244265705472',
        //            side: 'SELL',
        //            positionSide: 'SHORT',
        //            type: 'LIMIT',
        //            origQty: '1',
        //            price: '100.000',
        //            executedQty: '0',
        //            avgPrice: '0.000',
        //            cumQuote: '0',
        //            stopPrice: '',
        //            profit: '0.0000',
        //            commission: '0.000000',
        //            status: 'PENDING',
        //            time: '1707339747860',
        //            updateTime: '1707339747860',
        //            clientOrderId: '',
        //            leverage: '20X',
        //            workingType: 'MARK_PRICE',
        //            onlyOnePosition: false,
        //            reduceOnly: false
        //        },
        //        replaceResult: 'true',
        //        replaceMsg: '',
        //        newOrderResponse: {
        //            orderId: '1755338440612995072',
        //            symbol: 'SOL-USDT',
        //            positionSide: 'SHORT',
        //            side: 'SELL',
        //            type: 'LIMIT',
        //            price: '99',
        //            quantity: '2',
        //            stopPrice: '0',
        //            workingType: 'MARK_PRICE',
        //            clientOrderID: '',
        //            timeInForce: 'GTC',
        //            priceRate: '0',
        //            stopLoss: '',
        //            takeProfit: '',
        //            reduceOnly: false
        //        }
        //    }
        //
        // editOrder (spot)
        //
        //    {
        //        cancelResult: { code: '0', msg: '', result: true },
        //        openResult: { code: '0', msg: '', result: true },
        //        orderOpenResponse: {
        //            symbol: 'SOL-USDT',
        //            orderId: '1755334007697866752',
        //            transactTime: '1707339214620',
        //            price: '99',
        //            stopPrice: '0',
        //            origQty: '0.2',
        //            executedQty: '0',
        //            cummulativeQuoteQty: '0',
        //            status: 'PENDING',
        //            type: 'LIMIT',
        //            side: 'SELL',
        //            clientOrderID: ''
        //        },
        //        orderCancelResponse: {
        //            symbol: 'SOL-USDT',
        //            orderId: '1755117055251480576',
        //            price: '100',
        //            stopPrice: '0',
        //            origQty: '0.2',
        //            executedQty: '0',
        //            cummulativeQuoteQty: '0',
        //            status: 'CANCELED',
        //            type: 'LIMIT',
        //            side: 'SELL'
        //        }
        //    }
        //
        object info = order;
        object newOrder = this.safeDict2(order, "newOrderResponse", "orderOpenResponse");
        if (isTrue(!isEqual(newOrder, null)))
        {
            order = newOrder;
        }
        object positionSide = this.safeString2(order, "positionSide", "ps");
        object marketType = ((bool) isTrue((isEqual(positionSide, null)))) ? "spot" : "swap";
        object marketId = this.safeString2(order, "symbol", "s");
        if (isTrue(isEqual(market, null)))
        {
            market = this.safeMarket(marketId, null, null, marketType);
        }
        object side = this.safeStringLower2(order, "side", "S");
        object timestamp = this.safeIntegerN(order, new List<object>() {"time", "transactTime", "E"});
        object lastTradeTimestamp = this.safeInteger2(order, "updateTime", "T");
        object statusId = this.safeString2(order, "status", "X");
        object feeCurrencyCode = this.safeString2(order, "feeAsset", "N");
        object feeCost = this.safeStringN(order, new List<object>() {"fee", "commission", "n"});
        if (isTrue((isEqual(feeCurrencyCode, null))))
        {
            if (isTrue(getValue(market, "spot")))
            {
                if (isTrue(isEqual(side, "buy")))
                {
                    feeCurrencyCode = getValue(market, "base");
                } else
                {
                    feeCurrencyCode = getValue(market, "quote");
                }
            } else
            {
                feeCurrencyCode = getValue(market, "quote");
            }
        }
        object stopLoss = this.safeValue(order, "stopLoss");
        object stopLossPrice = null;
        if (isTrue(isTrue((!isEqual(stopLoss, null))) && isTrue((!isEqual(stopLoss, "")))))
        {
            stopLossPrice = this.safeNumber(stopLoss, "stopLoss");
        }
        if (isTrue(isTrue(isTrue((!isEqual(stopLoss, null))) && isTrue((!(stopLoss is Int64 || stopLoss is int || stopLoss is float || stopLoss is double)))) && isTrue((!isEqual(stopLoss, "")))))
        {
            //  stopLoss: '{"stopPrice":50,"workingType":"MARK_PRICE","type":"STOP_MARKET","quantity":1}',
            if (isTrue((stopLoss is string)))
            {
                stopLoss = this.parseJson(stopLoss);
            }
            stopLossPrice = this.safeNumber(stopLoss, "stopPrice");
        }
        object takeProfit = this.safeValue(order, "takeProfit");
        object takeProfitPrice = null;
        if (isTrue(isTrue(!isEqual(takeProfit, null)) && isTrue((!isEqual(takeProfit, "")))))
        {
            takeProfitPrice = this.safeNumber(takeProfit, "takeProfit");
        }
        if (isTrue(isTrue(isTrue((!isEqual(takeProfit, null))) && isTrue((!(takeProfit is Int64 || takeProfit is int || takeProfit is float || takeProfit is double)))) && isTrue((!isEqual(takeProfit, "")))))
        {
            //  takeProfit: '{"stopPrice":150,"workingType":"MARK_PRICE","type":"TAKE_PROFIT_MARKET","quantity":1}',
            if (isTrue((takeProfit is string)))
            {
                takeProfit = this.parseJson(takeProfit);
            }
            takeProfitPrice = this.safeNumber(takeProfit, "stopPrice");
        }
        return this.safeOrder(new Dictionary<string, object>() {
            { "info", info },
            { "id", this.safeString2(order, "orderId", "i") },
            { "clientOrderId", this.safeStringN(order, new List<object>() {"clientOrderID", "origClientOrderId", "c"}) },
            { "symbol", this.safeSymbol(marketId, market, "-", marketType) },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "lastTradeTimestamp", lastTradeTimestamp },
            { "lastUpdateTimestamp", this.safeInteger(order, "updateTime") },
            { "type", this.parseOrderType(this.safeStringLower2(order, "type", "o")) },
            { "timeInForce", this.safeString(order, "timeInForce") },
            { "postOnly", null },
            { "side", this.parseOrderSide(side) },
            { "price", this.safeString2(order, "price", "p") },
            { "stopPrice", this.safeNumber(order, "stopPrice") },
            { "triggerPrice", this.safeNumber(order, "stopPrice") },
            { "stopLossPrice", stopLossPrice },
            { "takeProfitPrice", takeProfitPrice },
            { "average", this.safeString2(order, "avgPrice", "ap") },
            { "cost", null },
            { "amount", this.safeStringN(order, new List<object>() {"origQty", "q", "quantity"}) },
            { "filled", this.safeString2(order, "executedQty", "z") },
            { "remaining", null },
            { "status", this.parseOrderStatus(statusId) },
            { "fee", new Dictionary<string, object>() {
                { "currency", feeCurrencyCode },
                { "cost", Precise.stringAbs(feeCost) },
            } },
            { "trades", null },
            { "reduceOnly", this.safeBool(order, "reduceOnly") },
        }, market);
    }

    public virtual object parseOrderStatus(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "NEW", "open" },
            { "PENDING", "open" },
            { "PARTIALLY_FILLED", "open" },
            { "FILLED", "closed" },
            { "CANCELED", "canceled" },
            { "CANCELLED", "canceled" },
            { "FAILED", "failed" },
        };
        return this.safeString(statuses, status, status);
    }

    public async override Task<object> cancelOrder(object id, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name bingx#cancelOrder
        * @description cancels an open order
        * @see https://bingx-api.github.io/docs/#/spot/trade-api.html#Cancel%20an%20Order
        * @see https://bingx-api.github.io/docs/#/swapV2/trade-api.html#Cancel%20an%20Order
        * @param {string} id order id
        * @param {string} symbol unified symbol of the market the order was made in
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {string} [params.clientOrderId] a unique id for the order
        * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " cancelOrder() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object clientOrderId = this.safeString2(parameters, "clientOrderId", "clientOrderID");
        parameters = this.omit(parameters, new List<object>() {"clientOrderId"});
        if (isTrue(!isEqual(clientOrderId, null)))
        {
            ((IDictionary<string,object>)request)["clientOrderID"] = clientOrderId;
        } else
        {
            ((IDictionary<string,object>)request)["orderId"] = id;
        }
        object response = null;
        var marketTypequeryVariable = this.handleMarketTypeAndParams("cancelOrder", market, parameters);
        var marketType = ((IList<object>) marketTypequeryVariable)[0];
        var query = ((IList<object>) marketTypequeryVariable)[1];
        if (isTrue(isEqual(marketType, "spot")))
        {
            response = await this.spotV1PrivatePostTradeCancel(this.extend(request, query));
        } else
        {
            response = await this.swapV2PrivateDeleteTradeOrder(this.extend(request, query));
        }
        //
        // spot
        //
        //   {
        //       "code": 0,
        //       "msg": "",
        //       "data": {
        //           "symbol": "XRP-USDT",
        //           "orderId": 1514090846268424192,
        //           "price": "0.5",
        //           "origQty": "10",
        //           "executedQty": "0",
        //           "cummulativeQuoteQty": "0",
        //           "status": "CANCELED",
        //           "type": "LIMIT",
        //           "side": "BUY"
        //       }
        //   }
        //
        // swap
        //
        //    {
        //        "code": 0,
        //        "msg": "",
        //        "data": {
        //          "order": {
        //            "symbol": "LINK-USDT",
        //            "orderId": 1597783850786750464,
        //            "side": "BUY",
        //            "positionSide": "LONG",
        //            "type": "TRIGGER_MARKET",
        //            "origQty": "5.0",
        //            "price": "5.0000",
        //            "executedQty": "0.0",
        //            "avgPrice": "0.0000",
        //            "cumQuote": "0",
        //            "stopPrice": "5.0000",
        //            "profit": "",
        //            "commission": "",
        //            "status": "CANCELLED",
        //            "time": 1669776330000,
        //            "updateTime": 1669776330000
        //          }
        //        }
        //    }
        //
        object data = this.safeValue(response, "data");
        object first = this.safeValue(data, "order", data);
        return this.parseOrder(first, market);
    }

    public async override Task<object> cancelAllOrders(object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name bingx#cancelAllOrders
        * @description cancel all open orders
        * @see https://bingx-api.github.io/docs/#/en-us/spot/trade-api.html#Cancel%20orders%20by%20symbol
        * @see https://bingx-api.github.io/docs/#/swapV2/trade-api.html#Cancel%20All%20Orders
        * @param {string} [symbol] unified market symbol, only orders in the market of this symbol are cancelled when symbol is not undefined
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " cancelAllOrders() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object response = null;
        if (isTrue(getValue(market, "spot")))
        {
            response = await this.spotV1PrivatePostTradeCancelOpenOrders(this.extend(request, parameters));
        } else if (isTrue(getValue(market, "swap")))
        {
            response = await this.swapV2PrivateDeleteTradeAllOpenOrders(this.extend(request, parameters));
        } else
        {
            throw new BadRequest ((string)add(this.id, " cancelAllOrders is only supported for spot and swap markets.")) ;
        }
        return response;
    }

    public async virtual Task<object> cancelOrders(object ids, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name bingx#cancelOrders
        * @description cancel multiple orders
        * @see https://bingx-api.github.io/docs/#/swapV2/trade-api.html#Cancel%20a%20Batch%20of%20Orders
        * @see https://bingx-api.github.io/docs/#/spot/trade-api.html#Cancel%20a%20Batch%20of%20Orders
        * @param {string[]} ids order ids
        * @param {string} symbol unified market symbol, default is undefined
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {string[]} [params.clientOrderIds] client order ids
        * @returns {object} an list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " cancelOrders() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object clientOrderIds = this.safeValue(parameters, "clientOrderIds");
        parameters = this.omit(parameters, "clientOrderIds");
        object idsToParse = ids;
        object areClientOrderIds = (!isEqual(clientOrderIds, null));
        if (isTrue(areClientOrderIds))
        {
            idsToParse = clientOrderIds;
        }
        object parsedIds = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(idsToParse)); postFixIncrement(ref i))
        {
            object id = getValue(idsToParse, i);
            object stringId = ((object)id).ToString();
            ((IList<object>)parsedIds).Add(stringId);
        }
        object response = null;
        if (isTrue(getValue(market, "spot")))
        {
            object spotReqKey = ((bool) isTrue(areClientOrderIds)) ? "clientOrderIDs" : "orderIds";
            ((IDictionary<string,object>)request)[(string)spotReqKey] = String.Join(",", ((IList<object>)parsedIds).ToArray());
            response = await this.spotV1PrivatePostTradeCancelOrders(this.extend(request, parameters));
        } else
        {
            if (isTrue(areClientOrderIds))
            {
                ((IDictionary<string,object>)request)["clientOrderIDList"] = this.json(parsedIds);
            } else
            {
                ((IDictionary<string,object>)request)["orderIdList"] = parsedIds;
            }
            response = await this.swapV2PrivateDeleteTradeBatchOrders(this.extend(request, parameters));
        }
        //
        //    {
        //        "code": 0,
        //        "msg": "",
        //        "data": {
        //          "success": [
        //            {
        //              "symbol": "LINK-USDT",
        //              "orderId": 1597783850786750464,
        //              "side": "BUY",
        //              "positionSide": "LONG",
        //              "type": "TRIGGER_MARKET",
        //              "origQty": "5.0",
        //              "price": "5.5710",
        //              "executedQty": "0.0",
        //              "avgPrice": "0.0000",
        //              "cumQuote": "0",
        //              "stopPrice": "5.0000",
        //              "profit": "0.0000",
        //              "commission": "0.000000",
        //              "status": "CANCELLED",
        //              "time": 1669776330000,
        //              "updateTime": 1672370837000
        //            }
        //          ],
        //          "failed": null
        //        }
        //    }
        //
        return response;
    }

    public async override Task<object> fetchOrder(object id, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name bingx#fetchOrder
        * @description fetches information on an order made by the user
        * @see https://bingx-api.github.io/docs/#/spot/trade-api.html#Query%20Orders
        * @see https://bingx-api.github.io/docs/#/swapV2/trade-api.html#Query%20Order
        * @param {string} symbol unified symbol of the market the order was made in
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchOrders() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
            { "orderId", id },
        };
        object response = null;
        var marketTypequeryVariable = this.handleMarketTypeAndParams("fetchOrder", market, parameters);
        var marketType = ((IList<object>) marketTypequeryVariable)[0];
        var query = ((IList<object>) marketTypequeryVariable)[1];
        if (isTrue(isEqual(marketType, "spot")))
        {
            response = await this.spotV1PrivateGetTradeQuery(this.extend(request, query));
        } else
        {
            response = await this.swapV2PrivateGetTradeOrder(this.extend(request, query));
        }
        //
        // spot
        //
        //     {
        //         "code": 0,
        //         "msg": "",
        //         "data": {
        //             "symbol": "XRP-USDT",
        //             "orderId": 1514087361158316032,
        //             "price": "0.5",
        //             "origQty": "10",
        //             "executedQty": "0",
        //             "cummulativeQuoteQty": "0",
        //             "status": "CANCELED",
        //             "type": "LIMIT",
        //             "side": "BUY",
        //             "time": 1649821532000,
        //             "updateTime": 1649821543000,
        //             "origQuoteOrderQty": "0",
        //             "fee": "0",
        //             "feeAsset": "XRP"
        //         }
        //     }
        //
        // swap
        //
        //      {
        //          "code": 0,
        //          "msg": "",
        //          "data": {
        //            "order": {
        //              "symbol": "BTC-USDT",
        //              "orderId": 1597597642269917184,
        //              "side": "SELL",
        //              "positionSide": "LONG",
        //              "type": "TAKE_PROFIT_MARKET",
        //              "origQty": "1.0000",
        //              "price": "0.0",
        //              "executedQty": "0.0000",
        //              "avgPrice": "0.0",
        //              "cumQuote": "",
        //              "stopPrice": "16494.0",
        //              "profit": "",
        //              "commission": "",
        //              "status": "FILLED",
        //              "time": 1669731935000,
        //              "updateTime": 1669752524000
        //            }
        //          }
        //      }
        //
        object data = this.safeValue(response, "data");
        object first = this.safeValue(data, "order", data);
        return this.parseOrder(first, market);
    }

    public async override Task<object> fetchOpenOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bingx#fetchOpenOrders
        * @see https://bingx-api.github.io/docs/#/spot/trade-api.html#Query%20Open%20Orders
        * @see https://bingx-api.github.io/docs/#/swapV2/trade-api.html#Query%20all%20current%20pending%20orders
        * @description fetch all unfilled currently open orders
        * @param {string} symbol unified market symbol
        * @param {int} [since] the earliest time in ms to fetch open orders for
        * @param {int} [limit] the maximum number of open order structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = null;
        object request = new Dictionary<string, object>() {};
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
        }
        object response = null;
        var marketTypequeryVariable = this.handleMarketTypeAndParams("fetchOpenOrders", market, parameters);
        var marketType = ((IList<object>) marketTypequeryVariable)[0];
        var query = ((IList<object>) marketTypequeryVariable)[1];
        if (isTrue(isEqual(marketType, "spot")))
        {
            response = await this.spotV1PrivateGetTradeOpenOrders(this.extend(request, query));
        } else
        {
            response = await this.swapV2PrivateGetTradeOpenOrders(this.extend(request, query));
        }
        //
        //  spot
        //
        //    {
        //        "code": 0,
        //        "msg": "",
        //        "data": {
        //            "orders": [
        //                {
        //                    "symbol": "XRP-USDT",
        //                    "orderId": 1514073325788200960,
        //                    "price": "0.5",
        //                    "origQty": "20",
        //                    "executedQty": "0",
        //                    "cummulativeQuoteQty": "0",
        //                    "status": "PENDING",
        //                    "type": "LIMIT",
        //                    "side": "BUY",
        //                    "time": 1649818185647,
        //                    "updateTime": 1649818185647,
        //                    "origQuoteOrderQty": "0"
        //                }
        //            ]
        //        }
        //    }
        //
        // swap
        //
        //    {
        //        "code": 0,
        //        "msg": "",
        //        "data": {
        //          "orders": [
        //            {
        //              "symbol": "LINK-USDT",
        //              "orderId": 1585839271162413056,
        //              "side": "BUY",
        //              "positionSide": "LONG",
        //              "type": "TRIGGER_MARKET",
        //              "origQty": "5.0",
        //              "price": "9",
        //              "executedQty": "0.0",
        //              "avgPrice": "0",
        //              "cumQuote": "0",
        //              "stopPrice": "5",
        //              "profit": "0.0000",
        //              "commission": "0.000000",
        //              "status": "CANCELLED",
        //              "time": 1667631605000,
        //              "updateTime": 1667631605000
        //            },
        //          ]
        //        }
        //    }
        //
        object data = this.safeValue(response, "data", new List<object>() {});
        object orders = this.safeValue(data, "orders", new List<object>() {});
        return this.parseOrders(orders, market, since, limit);
    }

    public async override Task<object> fetchClosedOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bingx#fetchClosedOrders
        * @description fetches information on multiple closed orders made by the user
        * @see https://bingx-api.github.io/docs/#/spot/trade-api.html#Query%20Order%20History
        * @see https://bingx-api.github.io/docs/#/swapV2/trade-api.html#User's%20Force%20Orders
        * @see https://bingx-api.github.io/docs/#/standard/contract-interface.html#Historical%20order
        * @param {string} [symbol] unified market symbol of the market orders were made in
        * @param {int} [since] the earliest time in ms to fetch orders for
        * @param {int} [limit] the maximum number of order structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {int} [params.until] the latest time in ms to fetch orders for
        * @param {boolean} [params.standard] whether to fetch standard contract orders
        * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchClosedOrders() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object response = null;
        object standard = null;
        var standardparametersVariable = this.handleOptionAndParams(parameters, "fetchClosedOrders", "standard", false);
        standard = ((IList<object>)standardparametersVariable)[0];
        parameters = ((IList<object>)standardparametersVariable)[1];
        var marketTypequeryVariable = this.handleMarketTypeAndParams("fetchClosedOrders", market, parameters);
        var marketType = ((IList<object>) marketTypequeryVariable)[0];
        var query = ((IList<object>) marketTypequeryVariable)[1];
        if (isTrue(standard))
        {
            response = await this.contractV1PrivateGetAllOrders(this.extend(request, query));
        } else if (isTrue(isEqual(marketType, "spot")))
        {
            response = await this.spotV1PrivateGetTradeHistoryOrders(this.extend(request, query));
        } else
        {
            response = await this.swapV2PrivateGetTradeAllOrders(this.extend(request, query));
        }
        //
        //  spot
        //
        //    {
        //        "code": 0,
        //        "msg": "",
        //        "data": {
        //            "orders": [
        //                {
        //                    "symbol": "XRP-USDT",
        //                    "orderId": 1514073325788200960,
        //                    "price": "0.5",
        //                    "origQty": "20",
        //                    "executedQty": "0",
        //                    "cummulativeQuoteQty": "0",
        //                    "status": "PENDING",
        //                    "type": "LIMIT",
        //                    "side": "BUY",
        //                    "time": 1649818185647,
        //                    "updateTime": 1649818185647,
        //                    "origQuoteOrderQty": "0"
        //                }
        //            ]
        //        }
        //    }
        //
        // swap
        //
        //    {
        //        "code": 0,
        //        "msg": "",
        //        "data": {
        //          "orders": [
        //            {
        //              "symbol": "LINK-USDT",
        //              "orderId": 1585839271162413056,
        //              "side": "BUY",
        //              "positionSide": "LONG",
        //              "type": "TRIGGER_MARKET",
        //              "origQty": "5.0",
        //              "price": "9",
        //              "executedQty": "0.0",
        //              "avgPrice": "0",
        //              "cumQuote": "0",
        //              "stopPrice": "5",
        //              "profit": "0.0000",
        //              "commission": "0.000000",
        //              "status": "CANCELLED",
        //              "time": 1667631605000,
        //              "updateTime": 1667631605000
        //            },
        //          ]
        //        }
        //    }
        //
        object data = this.safeValue(response, "data", new List<object>() {});
        object orders = this.safeValue(data, "orders", new List<object>() {});
        return this.parseOrders(orders, market, since, limit);
    }

    public async override Task<object> transfer(object code, object amount, object fromAccount, object toAccount, object parameters = null)
    {
        /**
        * @method
        * @name bingx#transfer
        * @description transfer currency internally between wallets on the same account
        * @see https://bingx-api.github.io/docs/#/spot/account-api.html#User%20Universal%20Transfer
        * @param {string} code unified currency code
        * @param {float} amount amount to transfer
        * @param {string} fromAccount account to transfer from
        * @param {string} toAccount account to transfer to
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [transfer structure]{@link https://docs.ccxt.com/#/?id=transfer-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        object accountsByType = this.safeValue(this.options, "accountsByType", new Dictionary<string, object>() {});
        object fromId = this.safeString(accountsByType, fromAccount, fromAccount);
        object toId = this.safeString(accountsByType, toAccount, toAccount);
        object request = new Dictionary<string, object>() {
            { "asset", getValue(currency, "id") },
            { "amount", this.currencyToPrecision(code, amount) },
            { "type", add(add(fromId, "_"), toId) },
        };
        object response = await this.spotV3PrivateGetGetAssetTransfer(this.extend(request, parameters));
        //
        //    {
        //        "tranId":13526853623
        //    }
        //
        return new Dictionary<string, object>() {
            { "info", response },
            { "id", this.safeString(response, "tranId") },
            { "timestamp", null },
            { "datetime", null },
            { "currency", code },
            { "amount", amount },
            { "fromAccount", fromAccount },
            { "toAccount", toAccount },
            { "status", null },
        };
    }

    public async virtual Task<object> fetchTransfers(object code = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bingx#fetchTransfers
        * @description fetch a history of internal transfers made on an account
        * @see https://bingx-api.github.io/docs/#/spot/account-api.html#Query%20User%20Universal%20Transfer%20History%20(USER_DATA)
        * @param {string} [code] unified currency code of the currency transferred
        * @param {int} [since] the earliest time in ms to fetch transfers for
        * @param {int} [limit] the maximum number of transfers structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} a list of [transfer structures]{@link https://docs.ccxt.com/#/?id=transfer-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = null;
        if (isTrue(!isEqual(code, null)))
        {
            currency = this.currency(code);
        }
        object accountsByType = this.safeValue(this.options, "accountsByType", new Dictionary<string, object>() {});
        object fromAccount = this.safeString(parameters, "fromAccount");
        object toAccount = this.safeString(parameters, "toAccount");
        object fromId = this.safeString(accountsByType, fromAccount, fromAccount);
        object toId = this.safeString(accountsByType, toAccount, toAccount);
        if (isTrue(isTrue(isEqual(fromId, null)) || isTrue(isEqual(toId, null))))
        {
            throw new ExchangeError ((string)add(this.id, " fromAccount & toAccount parameter are required")) ;
        }
        object request = new Dictionary<string, object>() {
            { "type", add(add(fromId, "_"), toId) },
        };
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["startTime"] = since;
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["size"] = limit;
        }
        object response = await this.spotV3PrivateGetAssetTransfer(this.extend(request, parameters));
        //
        //     {
        //         "total": 3,
        //         "rows": [
        //             {
        //                 "asset":"USDT",
        //                 "amount":"-100.00000000000000000000",
        //                 "type":"FUND_SFUTURES",
        //                 "status":"CONFIRMED",
        //                 "tranId":1067594500957016069,
        //                 "timestamp":1658388859000
        //             },
        //         ]
        //     }
        //
        object rows = this.safeValue(response, "rows", new List<object>() {});
        return this.parseTransfers(rows, currency, since, limit);
    }

    public override object parseTransfer(object transfer, object currency = null)
    {
        object tranId = this.safeString(transfer, "tranId");
        object timestamp = this.safeInteger(transfer, "timestamp");
        object currencyCode = this.safeCurrencyCode(null, currency);
        object status = this.safeString(transfer, "status");
        object accountsById = this.safeValue(this.options, "accountsById", new Dictionary<string, object>() {});
        object typeId = this.safeString(transfer, "type");
        object typeIdSplit = ((string)typeId).Split(new [] {((string)"_")}, StringSplitOptions.None).ToList<object>();
        object fromId = this.safeString(typeIdSplit, 0);
        object toId = this.safeString(typeId, 1);
        object fromAccount = this.safeString(accountsById, fromId, fromId);
        object toAccount = this.safeString(accountsById, toId, toId);
        return new Dictionary<string, object>() {
            { "info", transfer },
            { "id", tranId },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "currency", currencyCode },
            { "amount", this.safeNumber(transfer, "amount") },
            { "fromAccount", fromAccount },
            { "toAccount", toAccount },
            { "status", status },
        };
    }

    public async override Task<object> fetchDepositAddressesByNetwork(object code, object parameters = null)
    {
        /**
        * @method
        * @name bingx#fetchDepositAddressesByNetwork
        * @description fetch the deposit addresses for a currency associated with this account
        * @see https://bingx-api.github.io/docs/#/en-us/common/wallet-api.html#Query%20Main%20Account%20Deposit%20Address
        * @param {string} code unified currency code
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a dictionary [address structures]{@link https://docs.ccxt.com/#/?id=address-structure}, indexed by the network
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        object defaultRecvWindow = this.safeInteger(this.options, "recvWindow");
        object recvWindow = this.safeInteger(this.parseParams, "recvWindow", defaultRecvWindow);
        object request = new Dictionary<string, object>() {
            { "coin", getValue(currency, "id") },
            { "offset", 0 },
            { "limit", 1000 },
            { "recvWindow", recvWindow },
        };
        object response = await this.walletsV1PrivateGetCapitalDepositAddress(this.extend(request, parameters));
        //
        //     {
        //         "code": "0",
        //         "timestamp": "1695200226859",
        //         "data": {
        //           "data": [
        //             {
        //               "coinId": "799",
        //               "coin": "USDT",
        //               "network": "BEP20",
        //               "address": "6a7eda2817462dabb6493277a2cfe0f5c3f2550b",
        //               "tag": ''
        //             }
        //           ],
        //           "total": "1"
        //         }
        //     }
        //
        object data = this.safeValue(this.safeValue(response, "data"), "data");
        object parsed = this.parseDepositAddresses(data, new List<object>() {getValue(currency, "code")}, false);
        return this.indexBy(parsed, "network");
    }

    public async override Task<object> fetchDepositAddress(object code, object parameters = null)
    {
        /**
        * @method
        * @name bingx#fetchDepositAddress
        * @description fetch the deposit address for a currency associated with this account
        * @see https://bingx-api.github.io/docs/#/en-us/common/wallet-api.html#Query%20Main%20Account%20Deposit%20Address
        * @param {string} code unified currency code
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {string} [params.network] The chain of currency. This only apply for multi-chain currency, and there is no need for single chain currency
        * @returns {object} an [address structure]{@link https://docs.ccxt.com/#/?id=address-structure}
        */
        parameters ??= new Dictionary<string, object>();
        object network = this.safeString(parameters, "network");
        parameters = this.omit(parameters, new List<object>() {"network"});
        object addressStructures = await this.fetchDepositAddressesByNetwork(code, parameters);
        if (isTrue(!isEqual(network, null)))
        {
            return this.safeDict(addressStructures, network);
        } else
        {
            object options = this.safeDict(this.options, "defaultNetworks");
            object defaultNetworkForCurrency = this.safeString(options, code);
            if (isTrue(!isEqual(defaultNetworkForCurrency, null)))
            {
                return this.safeDict(addressStructures, defaultNetworkForCurrency);
            } else
            {
                object keys = new List<object>(((IDictionary<string,object>)addressStructures).Keys);
                object key = this.safeString(keys, 0);
                return this.safeDict(addressStructures, key);
            }
        }
    }

    public override object parseDepositAddress(object depositAddress, object currency = null)
    {
        //
        //     {
        //         "coinId": "799",
        //         "coin": "USDT",
        //         "network": "BEP20",
        //         "address": "6a7eda2817462dabb6493277a2cfe0f5c3f2550b",
        //         "tag": ''
        //     }
        //
        object address = this.safeString(depositAddress, "address");
        object tag = this.safeString(depositAddress, "tag");
        object currencyId = this.safeString(depositAddress, "coin");
        currency = this.safeCurrency(currencyId, currency);
        object code = getValue(currency, "code");
        object network = this.safeString(depositAddress, "network");
        this.checkAddress(address);
        return new Dictionary<string, object>() {
            { "currency", code },
            { "address", address },
            { "tag", tag },
            { "network", network },
            { "info", depositAddress },
        };
    }

    public async override Task<object> fetchDeposits(object code = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bingx#fetchDeposits
        * @description fetch all deposits made to an account
        * @see https://bingx-api.github.io/docs/#/spot/account-api.html#Deposit%20History(supporting%20network)
        * @param {string} [code] unified currency code
        * @param {int} [since] the earliest time in ms to fetch deposits for
        * @param {int} [limit] the maximum number of deposits structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object currency = null;
        if (isTrue(!isEqual(code, null)))
        {
            currency = this.currency(code);
            ((IDictionary<string,object>)request)["coin"] = getValue(currency, "id");
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["startTime"] = since;
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit; // default 1000
        }
        object response = await this.spotV3PrivateGetCapitalDepositHisrec(this.extend(request, parameters));
        //
        //    [
        //        {
        //            "amount":"0.00999800",
        //            "coin":"PAXG",
        //            "network":"ETH",
        //            "status":1,
        //            "address":"0x788cabe9236ce061e5a892e1a59395a81fc8d62c",
        //            "addressTag":"",
        //            "txId":"0xaad4654a3234aa6118af9b4b335f5ae81c360b2394721c019b5d1e75328b09f3",
        //            "insertTime":1599621997000,
        //            "transferType":0,
        //            "unlockConfirm":"12/12", // confirm times for unlocking
        //            "confirmTimes":"12/12"
        //        },
        //    ]
        //
        return this.parseTransactions(response, currency, since, limit);
    }

    public async override Task<object> fetchWithdrawals(object code = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bingx#fetchWithdrawals
        * @description fetch all withdrawals made from an account
        * @see https://bingx-api.github.io/docs/#/spot/account-api.html#Withdraw%20History%20(supporting%20network)
        * @param {string} [code] unified currency code
        * @param {int} [since] the earliest time in ms to fetch withdrawals for
        * @param {int} [limit] the maximum number of withdrawals structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object currency = null;
        if (isTrue(!isEqual(code, null)))
        {
            currency = this.currency(code);
            ((IDictionary<string,object>)request)["coin"] = getValue(currency, "id");
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["startTime"] = since;
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit; // default 1000
        }
        object response = await this.spotV3PrivateGetCapitalWithdrawHistory(this.extend(request, parameters));
        //
        //    [
        //        {
        //            "address": "0x94df8b352de7f46f64b01d3666bf6e936e44ce60",
        //            "amount": "8.91000000",
        //            "applyTime": "2019-10-12 11:12:02",
        //            "coin": "USDT",
        //            "id": "b6ae22b3aa844210a7041aee7589627c",
        //            "withdrawOrderId": "WITHDRAWtest123",
        //            "network": "ETH",
        //            "transferType": 0
        //            "status": 6,
        //            "transactionFee": "0.004",
        //            "confirmNo":3,
        //            "info": "The address is not valid. Please confirm with the recipient",
        //            "txId": "0xb5ef8c13b968a406cc62a93a8bd80f9e9a906ef1b3fcf20a2e48573c17659268"
        //        },
        //    ]
        //
        return this.parseTransactions(response, currency, since, limit);
    }

    public override object parseTransaction(object transaction, object currency = null)
    {
        //
        // fetchDeposits
        //
        //    {
        //        "amount":"0.00999800",
        //        "coin":"PAXG",
        //        "network":"ETH",
        //        "status":1,
        //        "address":"0x788cabe9236ce061e5a892e1a59395a81fc8d62c",
        //        "addressTag":"",
        //        "txId":"0xaad4654a3234aa6118af9b4b335f5ae81c360b2394721c019b5d1e75328b09f3",
        //        "insertTime":1599621997000,
        //        "transferType":0,
        //        "unlockConfirm":"12/12", // confirm times for unlocking
        //        "confirmTimes":"12/12"
        //    }
        //
        // fetchWithdrawals
        //
        //    {
        //        "address": "0x94df8b352de7f46f64b01d3666bf6e936e44ce60",
        //        "amount": "8.91000000",
        //        "applyTime": "2019-10-12 11:12:02",
        //        "coin": "USDT",
        //        "id": "b6ae22b3aa844210a7041aee7589627c",
        //        "withdrawOrderId": "WITHDRAWtest123",
        //        "network": "ETH",
        //        "transferType": 0
        //        "status": 6,
        //        "transactionFee": "0.004",
        //        "confirmNo":3,
        //        "info": "The address is not valid. Please confirm with the recipient",
        //        "txId": "0xb5ef8c13b968a406cc62a93a8bd80f9e9a906ef1b3fcf20a2e48573c17659268"
        //    }
        //
        // withdraw
        //
        //     {
        //         "code":0,
        //         "timestamp":1705274263621,
        //         "data":{
        //             "id":"1264246141278773252"
        //         }
        //     }
        //
        // parse withdraw-type output first...
        //
        object data = this.safeValue(transaction, "data");
        object dataId = ((bool) isTrue((isEqual(data, null)))) ? null : this.safeString(data, "id");
        object id = this.safeString(transaction, "id", dataId);
        object address = this.safeString(transaction, "address");
        object tag = this.safeString(transaction, "addressTag");
        object timestamp = this.safeInteger(transaction, "insertTime");
        object datetime = this.iso8601(timestamp);
        if (isTrue(isEqual(timestamp, null)))
        {
            datetime = this.safeString(transaction, "applyTime");
            timestamp = this.parse8601(datetime);
        }
        object network = this.safeString(transaction, "network");
        object currencyId = this.safeString(transaction, "coin");
        object code = this.safeCurrencyCode(currencyId, currency);
        if (isTrue(isTrue(isTrue((!isEqual(code, null))) && isTrue((!isEqual(code, network)))) && isTrue(isGreaterThanOrEqual(getIndexOf(code, network), 0))))
        {
            if (isTrue(!isEqual(network, null)))
            {
                code = ((string)code).Replace((string)network, (string)"");
            }
        }
        object rawType = this.safeString(transaction, "transferType");
        object type = ((bool) isTrue((isEqual(rawType, "0")))) ? "deposit" : "withdrawal";
        return new Dictionary<string, object>() {
            { "info", transaction },
            { "id", id },
            { "txid", this.safeString(transaction, "txId") },
            { "type", type },
            { "currency", code },
            { "network", this.networkIdToCode(network) },
            { "amount", this.safeNumber(transaction, "amount") },
            { "status", this.parseTransactionStatus(this.safeString(transaction, "status")) },
            { "timestamp", timestamp },
            { "datetime", datetime },
            { "address", address },
            { "addressFrom", null },
            { "addressTo", address },
            { "tag", tag },
            { "tagFrom", tag },
            { "tagTo", null },
            { "updated", null },
            { "comment", this.safeString(transaction, "info") },
            { "fee", new Dictionary<string, object>() {
                { "currency", code },
                { "cost", this.safeNumber(transaction, "transactionFee") },
                { "rate", null },
            } },
            { "internal", null },
        };
    }

    public virtual object parseTransactionStatus(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "0", "pending" },
            { "1", "ok" },
            { "10", "pending" },
            { "20", "rejected" },
            { "30", "ok" },
            { "40", "rejected" },
            { "50", "ok" },
            { "60", "pending" },
            { "70", "rejected" },
            { "2", "pending" },
            { "3", "rejected" },
            { "4", "pending" },
            { "5", "rejected" },
            { "6", "ok" },
        };
        return this.safeString(statuses, status, status);
    }

    public async override Task<object> setMarginMode(object marginMode, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name bingx#setMarginMode
        * @description set margin mode to 'cross' or 'isolated'
        * @see https://bingx-api.github.io/docs/#/swapV2/trade-api.html#Switch%20Margin%20Mode
        * @param {string} marginMode 'cross' or 'isolated'
        * @param {string} symbol unified market symbol
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} response from the exchange
        */
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " setMarginMode() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        if (isTrue(!isEqual(getValue(market, "type"), "swap")))
        {
            throw new BadSymbol ((string)add(this.id, " setMarginMode() supports swap contracts only")) ;
        }
        marginMode = ((string)marginMode).ToUpper();
        if (isTrue(isEqual(marginMode, "CROSS")))
        {
            marginMode = "CROSSED";
        }
        if (isTrue(isTrue(!isEqual(marginMode, "ISOLATED")) && isTrue(!isEqual(marginMode, "CROSSED"))))
        {
            throw new BadRequest ((string)add(this.id, " setMarginMode() marginMode argument should be isolated or cross")) ;
        }
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
            { "marginType", marginMode },
        };
        return await this.swapV2PrivatePostTradeMarginType(this.extend(request, parameters));
    }

    public async override Task<object> setMargin(object symbol, object amount, object parameters = null)
    {
        /**
        * @method
        * @name bingx#setMargin
        * @description Either adds or reduces margin in an isolated position in order to set the margin to a specific value
        * @see https://bingx-api.github.io/docs/#/swapV2/trade-api.html#Adjust%20isolated%20margin
        * @param {string} symbol unified market symbol of the market to set margin in
        * @param {float} amount the amount to set the margin to
        * @param {object} [params] parameters specific to the bingx api endpoint
        * @returns {object} A [margin structure]{@link https://docs.ccxt.com/#/?id=add-margin-structure}
        */
        parameters ??= new Dictionary<string, object>();
        object type = this.safeInteger(parameters, "type"); // 1 increase margin 2 decrease margin
        if (isTrue(isEqual(type, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " setMargin() requires a type parameter either 1 (increase margin) or 2 (decrease margin)")) ;
        }
        if (!isTrue(this.inArray(type, new List<object>() {1, 2})))
        {
            throw new ArgumentsRequired ((string)add(this.id, " setMargin() requires a type parameter either 1 (increase margin) or 2 (decrease margin)")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
            { "amount", this.amountToPrecision(getValue(market, "symbol"), amount) },
            { "type", type },
        };
        object response = await this.swapV2PrivatePostTradePositionMargin(this.extend(request, parameters));
        //
        //    {
        //        "code": 0,
        //        "msg": "",
        //        "amount": 1,
        //        "type": 1
        //    }
        //
        return response;
    }

    public async override Task<object> fetchLeverage(object symbol, object parameters = null)
    {
        /**
        * @method
        * @name bingx#fetchLeverage
        * @description fetch the set leverage for a market
        * @see https://bingx-api.github.io/docs/#/swapV2/trade-api.html#Query%20Leverage
        * @param {string} symbol unified market symbol
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [leverage structure]{@link https://docs.ccxt.com/#/?id=leverage-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object response = await this.swapV2PrivateGetTradeLeverage(this.extend(request, parameters));
        //
        //    {
        //        "code": 0,
        //        "msg": "",
        //        "data": {
        //            "longLeverage": 6,
        //            "shortLeverage": 6
        //        }
        //    }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        return this.parseLeverage(data, market);
    }

    public override object parseLeverage(object leverage, object market = null)
    {
        object marketId = this.safeString(leverage, "symbol");
        return new Dictionary<string, object>() {
            { "info", leverage },
            { "symbol", this.safeSymbol(marketId, market) },
            { "marginMode", null },
            { "longLeverage", this.safeInteger(leverage, "longLeverage") },
            { "shortLeverage", this.safeInteger(leverage, "shortLeverage") },
        };
    }

    public async override Task<object> setLeverage(object leverage, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name bingx#setLeverage
        * @description set the level of leverage for a market
        * @see https://bingx-api.github.io/docs/#/swapV2/trade-api.html#Switch%20Leverage
        * @param {float} leverage the rate of leverage
        * @param {string} symbol unified market symbol
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {string} [params.side] hedged: ['long' or 'short']. one way: ['both']
        * @returns {object} response from the exchange
        */
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " setLeverage() requires a symbol argument")) ;
        }
        object side = this.safeStringUpper(parameters, "side");
        this.checkRequiredArgument("setLeverage", side, "side", new List<object>() {"LONG", "SHORT", "BOTH"});
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
            { "side", side },
            { "leverage", leverage },
        };
        //
        //    {
        //        "code": 0,
        //        "msg": "",
        //        "data": {
        //            "leverage": 6,
        //            "symbol": "BTC-USDT"
        //        }
        //    }
        //
        return await this.swapV2PrivatePostTradeLeverage(this.extend(request, parameters));
    }

    public async override Task<object> fetchMyTrades(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bingx#fetchMyTrades
        * @description fetch all trades made by the user
        * @see https://bingx-api.github.io/docs/#/en-us/spot/trade-api.html#Query%20Order%20History
        * @see https://bingx-api.github.io/docs/#/swapV2/trade-api.html#Query%20historical%20transaction%20orders
        * @param {string} [symbol] unified market symbol
        * @param {int} [since] the earliest time in ms to fetch trades for
        * @param {int} [limit] the maximum number of trades structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {int} [params.until] timestamp in ms for the ending date filter, default is undefined
        * @param {string} params.trandingUnit COIN (directly represent assets such as BTC and ETH) or CONT (represents the number of contract sheets)
        * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
        */
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchMyTrades() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object now = this.milliseconds();
        object response = null;
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        if (isTrue(!isEqual(since, null)))
        {
            object startTimeReq = ((bool) isTrue(getValue(market, "spot"))) ? "startTime" : "startTs";
            ((IDictionary<string,object>)request)[(string)startTimeReq] = since;
        } else if (isTrue(getValue(market, "swap")))
        {
            ((IDictionary<string,object>)request)["startTs"] = subtract(now, 7776000000); // 90 days
        }
        object until = this.safeInteger(parameters, "until");
        parameters = this.omit(parameters, "until");
        if (isTrue(!isEqual(until, null)))
        {
            object endTimeReq = ((bool) isTrue(getValue(market, "spot"))) ? "endTime" : "endTs";
            ((IDictionary<string,object>)request)[(string)endTimeReq] = until;
        } else if (isTrue(getValue(market, "swap")))
        {
            ((IDictionary<string,object>)request)["endTs"] = now;
        }
        object fills = null;
        if (isTrue(getValue(market, "spot")))
        {
            response = await this.spotV1PrivateGetTradeMyTrades(this.extend(request, parameters));
            object data = this.safeValue(response, "data", new List<object>() {});
            fills = this.safeValue(data, "fills", new List<object>() {});
        } else
        {
            object tradingUnit = this.safeStringUpper(parameters, "tradingUnit", "CONT");
            parameters = this.omit(parameters, "tradingUnit");
            ((IDictionary<string,object>)request)["tradingUnit"] = tradingUnit;
            response = await this.swapV2PrivateGetTradeAllFillOrders(this.extend(request, parameters));
            object data = this.safeValue(response, "data", new List<object>() {});
            fills = this.safeValue(data, "fill_orders", new List<object>() {});
        }
        return this.parseTrades(fills, market, since, limit, parameters);
    }

    public override object parseDepositWithdrawFee(object fee, object currency = null)
    {
        //
        //    {
        //        "coin": "BTC",
        //        "name": "BTC",
        //        "networkList": [
        //          {
        //            "name": "BTC",
        //            "network": "BTC",
        //            "isDefault": true,
        //            "minConfirm": "2",
        //            "withdrawEnable": true,
        //            "withdrawFee": "0.00035",
        //            "withdrawMax": "1.62842",
        //            "withdrawMin": "0.0005"
        //          },
        //          {
        //            "name": "BTC",
        //            "network": "BEP20",
        //            "isDefault": false,
        //            "minConfirm": "15",
        //            "withdrawEnable": true,
        //            "withdrawFee": "0.00001",
        //            "withdrawMax": "1.62734",
        //            "withdrawMin": "0.0001"
        //          }
        //        ]
        //    }
        //
        object networkList = this.safeValue(fee, "networkList", new List<object>() {});
        object networkListLength = getArrayLength(networkList);
        object result = new Dictionary<string, object>() {
            { "info", fee },
            { "withdraw", new Dictionary<string, object>() {
                { "fee", null },
                { "percentage", null },
            } },
            { "deposit", new Dictionary<string, object>() {
                { "fee", null },
                { "percentage", null },
            } },
            { "networks", new Dictionary<string, object>() {} },
        };
        if (isTrue(!isEqual(networkListLength, 0)))
        {
            for (object i = 0; isLessThan(i, networkListLength); postFixIncrement(ref i))
            {
                object network = getValue(networkList, i);
                object networkId = this.safeString(network, "network");
                object isDefault = this.safeValue(network, "isDefault");
                object currencyCode = this.safeString(currency, "code");
                object networkCode = this.networkIdToCode(networkId, currencyCode);
                ((IDictionary<string,object>)getValue(result, "networks"))[(string)networkCode] = new Dictionary<string, object>() {
                    { "deposit", new Dictionary<string, object>() {
                        { "fee", null },
                        { "percentage", null },
                    } },
                    { "withdraw", new Dictionary<string, object>() {
                        { "fee", this.safeNumber(network, "withdrawFee") },
                        { "percentage", false },
                    } },
                };
                if (isTrue(isDefault))
                {
                    ((IDictionary<string,object>)getValue(result, "withdraw"))["fee"] = this.safeNumber(network, "withdrawFee");
                    ((IDictionary<string,object>)getValue(result, "withdraw"))["percentage"] = false;
                }
            }
        }
        return result;
    }

    public async override Task<object> fetchDepositWithdrawFees(object codes = null, object parameters = null)
    {
        /**
        * @method
        * @name bingx#fetchDepositWithdrawFees
        * @description fetch deposit and withdraw fees
        * @see https://bingx-api.github.io/docs/#/common/account-api.html#All%20Coins'%20Information
        * @param {string[]|undefined} codes list of unified currency codes
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a list of [fee structures]{@link https://docs.ccxt.com/#/?id=fee-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.walletsV1PrivateGetCapitalConfigGetall(parameters);
        object coins = this.safeValue(response, "data");
        return this.parseDepositWithdrawFees(coins, codes, "coin");
    }

    public async override Task<object> withdraw(object code, object amount, object address, object tag = null, object parameters = null)
    {
        /**
        * @method
        * @name bingx#withdraw
        * @description make a withdrawal
        * @see https://bingx-api.github.io/docs/#/common/account-api.html#Withdraw
        * @param {string} code unified currency code
        * @param {float} amount the amount to withdraw
        * @param {string} address the address to withdraw to
        * @param {string} [tag]
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {int} [params.walletType] 1 fund account, 2 standard account, 3 perpetual account
        * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        object walletType = this.safeInteger(parameters, "walletType");
        if (isTrue(isEqual(walletType, null)))
        {
            walletType = 1;
        }
        if (!isTrue(this.inArray(walletType, new List<object>() {1, 2, 3})))
        {
            throw new BadRequest ((string)add(this.id, " withdraw() requires either 1 fund account, 2 standard futures account, 3 perpetual account for walletType")) ;
        }
        object request = new Dictionary<string, object>() {
            { "coin", getValue(currency, "id") },
            { "address", address },
            { "amount", this.numberToString(amount) },
            { "walletType", walletType },
        };
        object network = this.safeStringUpper(parameters, "network");
        if (isTrue(!isEqual(network, null)))
        {
            ((IDictionary<string,object>)request)["network"] = this.networkCodeToId(network);
        }
        parameters = this.omit(parameters, new List<object>() {"walletType", "network"});
        object response = await this.walletsV1PrivatePostCapitalWithdrawApply(this.extend(request, parameters));
        object data = this.safeValue(response, "data");
        //    {
        //        "code":0,
        //        "timestamp":1689258953651,
        //        "data":{
        //           "id":"1197073063359000577"
        //        }
        //    }
        return this.parseTransaction(data);
    }

    public virtual object parseParams(object parameters)
    {
        object sortedParams = this.keysort(parameters);
        object keys = new List<object>(((IDictionary<string,object>)sortedParams).Keys);
        for (object i = 0; isLessThan(i, getArrayLength(keys)); postFixIncrement(ref i))
        {
            object key = getValue(keys, i);
            object value = getValue(sortedParams, key);
            if (isTrue(((value is IList<object>) || (value.GetType().IsGenericType && value.GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>))))))
            {
                object arrStr = "[";
                for (object j = 0; isLessThan(j, getArrayLength(value)); postFixIncrement(ref j))
                {
                    object arrayElement = getValue(value, j);
                    if (isTrue(isGreaterThan(j, 0)))
                    {
                        arrStr = add(arrStr, ",");
                    }
                    arrStr = add(arrStr, ((object)arrayElement).ToString());
                }
                arrStr = add(arrStr, "]");
                ((IDictionary<string,object>)sortedParams)[(string)key] = arrStr;
            }
        }
        return sortedParams;
    }

    public async override Task<object> fetchMyLiquidations(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bingx#fetchMyLiquidations
        * @description retrieves the users liquidated positions
        * @see https://bingx-api.github.io/docs/#/swapV2/trade-api.html#User's%20Force%20Orders
        * @param {string} [symbol] unified CCXT market symbol
        * @param {int} [since] the earliest time in ms to fetch liquidations for
        * @param {int} [limit] the maximum number of liquidation structures to retrieve
        * @param {object} [params] exchange specific parameters for the bingx api endpoint
        * @param {int} [params.until] timestamp in ms of the latest liquidation
        * @returns {object} an array of [liquidation structures]{@link https://docs.ccxt.com/#/?id=liquidation-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {
            { "autoCloseType", "LIQUIDATION" },
        };
        var requestparametersVariable = this.handleUntilOption("endTime", request, parameters);
        request = ((IList<object>)requestparametersVariable)[0];
        parameters = ((IList<object>)requestparametersVariable)[1];
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            ((IDictionary<string,object>)request)["symbol"] = symbol;
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["startTime"] = since;
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        object response = await this.swapV2PrivateGetTradeForceOrders(this.extend(request, parameters));
        //
        //     {
        //         "code": 0,
        //         "msg": "",
        //         "data": {
        //             "orders": [
        //                 {
        //                     "time": "int64",
        //                     "symbol": "string",
        //                     "side": "string",
        //                      "type": "string",
        //                     "positionSide": "string",
        //                     "cumQuote": "string",
        //                     "status": "string",
        //                     "stopPrice": "string",
        //                     "price": "string",
        //                     "origQty": "string",
        //                     "avgPrice": "string",
        //                     "executedQty": "string",
        //                     "orderId": "int64",
        //                     "profit": "string",
        //                     "commission": "string",
        //                     "workingType": "string",
        //                     "updateTime": "int64"
        //                 },
        //             ]
        //         }
        //     }
        //
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        object liquidations = this.safeValue(data, "orders", new List<object>() {});
        return this.parseLiquidations(liquidations, market, since, limit);
    }

    public override object parseLiquidation(object liquidation, object market = null)
    {
        //
        //     {
        //         "time": "int64",
        //         "symbol": "string",
        //         "side": "string",
        //         "type": "string",
        //         "positionSide": "string",
        //         "cumQuote": "string",
        //         "status": "string",
        //         "stopPrice": "string",
        //         "price": "string",
        //         "origQty": "string",
        //         "avgPrice": "string",
        //         "executedQty": "string",
        //         "orderId": "int64",
        //         "profit": "string",
        //         "commission": "string",
        //         "workingType": "string",
        //         "updateTime": "int64"
        //     }
        //
        object marketId = this.safeString(liquidation, "symbol");
        object timestamp = this.safeInteger(liquidation, "time");
        object contractsString = this.safeString(liquidation, "executedQty");
        object contractSizeString = this.safeString(market, "contractSize");
        object priceString = this.safeString(liquidation, "avgPrice");
        object baseValueString = Precise.stringMul(contractsString, contractSizeString);
        object quoteValueString = Precise.stringMul(baseValueString, priceString);
        return this.safeLiquidation(new Dictionary<string, object>() {
            { "info", liquidation },
            { "symbol", this.safeSymbol(marketId, market) },
            { "contracts", this.parseNumber(contractsString) },
            { "contractSize", this.parseNumber(contractSizeString) },
            { "price", this.parseNumber(priceString) },
            { "baseValue", this.parseNumber(baseValueString) },
            { "quoteValue", this.parseNumber(quoteValueString) },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
        });
    }

    public async override Task<object> closePosition(object symbol, object side = null, object parameters = null)
    {
        /**
        * @method
        * @name bingx#closePosition
        * @description closes open positions for a market
        * @see https://bingx-api.github.io/docs/#/en-us/swapV2/trade-api.html#One-Click%20Close%20All%20Positions
        * @param {string} symbol Unified CCXT market symbol
        * @param {string} [side] not used by bingx
        * @param {object} [params] extra parameters specific to the bingx api endpoint
        * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object response = await this.swapV2PrivatePostTradeCloseAllPositions(this.extend(request, parameters));
        //
        //    {
        //        "code": 0,
        //        "msg": "",
        //        "data": {
        //            "success": [
        //                1727686766700486656,
        //            ],
        //            "failed": null
        //        }
        //    }
        //
        object data = this.safeValue(response, "data");
        return this.parseOrder(data);
    }

    public async override Task<object> closeAllPositions(object parameters = null)
    {
        /**
        * @method
        * @name bitget#closePositions
        * @description closes open positions for a market
        * @see https://bingx-api.github.io/docs/#/en-us/swapV2/trade-api.html#One-Click%20Close%20All%20Positions
        * @param {object} [params] extra parameters specific to the okx api endpoint
        * @param {string} [params.recvWindow] request valid time window value
        * @returns {object[]} [A list of position structures]{@link https://docs.ccxt.com/#/?id=position-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object defaultRecvWindow = this.safeInteger(this.options, "recvWindow");
        object recvWindow = this.safeInteger(this.parseParams, "recvWindow", defaultRecvWindow);
        object marketType = null;
        var marketTypeparametersVariable = this.handleMarketTypeAndParams("closeAllPositions", null, parameters);
        marketType = ((IList<object>)marketTypeparametersVariable)[0];
        parameters = ((IList<object>)marketTypeparametersVariable)[1];
        if (isTrue(isEqual(marketType, "margin")))
        {
            throw new BadRequest ((string)add(add(add(this.id, " closePositions () cannot be used for "), marketType), " markets")) ;
        }
        object request = new Dictionary<string, object>() {
            { "recvWindow", recvWindow },
        };
        object response = await this.swapV2PrivatePostTradeCloseAllPositions(this.extend(request, parameters));
        //
        //    {
        //        "code": 0,
        //        "msg": "",
        //        "data": {
        //            "success": [
        //                1727686766700486656,
        //                1727686767048613888
        //            ],
        //            "failed": null
        //        }
        //    }
        //
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        object success = this.safeValue(data, "success", new List<object>() {});
        object positions = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(success)); postFixIncrement(ref i))
        {
            object position = this.parsePosition(new Dictionary<string, object>() {
                { "positionId", getValue(success, i) },
            });
            ((IList<object>)positions).Add(position);
        }
        return positions;
    }

    public async virtual Task<object> fetchPositionMode(object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name bingx#fetchPositionMode
        * @description fetchs the position mode, hedged or one way, hedged for binance is set identically for all linear markets or all inverse markets
        * @see https://bingx-api.github.io/docs/#/en-us/swapV2/trade-api.html#Get%20Position%20Mode
        * @param {string} symbol unified symbol of the market to fetch the order book for
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} an object detailing whether the market is in hedged or one-way mode
        */
        parameters ??= new Dictionary<string, object>();
        object response = await this.swapV1PrivateGetPositionSideDual(parameters);
        //
        //     {
        //         "code": "0",
        //         "msg": "",
        //         "timeStamp": "1709002057516",
        //         "data": {
        //             "dualSidePosition": "false"
        //         }
        //     }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        object dualSidePosition = this.safeString(data, "dualSidePosition");
        return new Dictionary<string, object>() {
            { "info", response },
            { "hedged", (isEqual(dualSidePosition, "true")) },
        };
    }

    public async override Task<object> setPositionMode(object hedged, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name bingx#setPositionMode
        * @description set hedged to true or false for a market
        * @see https://bingx-api.github.io/docs/#/en-us/swapV2/trade-api.html#Set%20Position%20Mode
        * @param {bool} hedged set to true to use dualSidePosition
        * @param {string} symbol not used by bingx setPositionMode ()
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} response from the exchange
        */
        parameters ??= new Dictionary<string, object>();
        object dualSidePosition = null;
        if (isTrue(hedged))
        {
            dualSidePosition = "true";
        } else
        {
            dualSidePosition = "false";
        }
        object request = new Dictionary<string, object>() {
            { "dualSidePosition", dualSidePosition },
        };
        //
        //     {
        //         code: '0',
        //         msg: '',
        //         timeStamp: '1703327432734',
        //         data: { dualSidePosition: 'false' }
        //     }
        //
        return await this.swapV1PrivatePostPositionSideDual(this.extend(request, parameters));
    }

    public async override Task<object> editOrder(object id, object symbol, object type, object side, object amount = null, object price = null, object parameters = null)
    {
        /**
        * @method
        * @name bingx#editOrder
        * @description cancels an order and places a new order
        * @see https://bingx-api.github.io/docs/#/en-us/spot/trade-api.html#Cancel%20order%20and%20place%20a%20new%20order  // spot
        * @see https://bingx-api.github.io/docs/#/en-us/swapV2/trade-api.html#Cancel%20an%20order%20and%20then%20Place%20a%20new%20order  // swap
        * @param {string} id order id
        * @param {string} symbol unified symbol of the market to create an order in
        * @param {string} type 'market' or 'limit'
        * @param {string} side 'buy' or 'sell'
        * @param {float} amount how much of the currency you want to trade in units of the base currency
        * @param {float} [price] the price at which the order is to be fullfilled, in units of the quote currency, ignored in market orders
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {string} [params.stopPrice] Trigger price used for TAKE_STOP_LIMIT, TAKE_STOP_MARKET, TRIGGER_LIMIT, TRIGGER_MARKET order types.
        * @param {object} [params.takeProfit] *takeProfit object in params* containing the triggerPrice at which the attached take profit order will be triggered
        * @param {float} [params.takeProfit.triggerPrice] take profit trigger price
        * @param {object} [params.stopLoss] *stopLoss object in params* containing the triggerPrice at which the attached stop loss order will be triggered
        * @param {float} [params.stopLoss.triggerPrice] stop loss trigger price
        *
        * EXCHANGE SPECIFIC PARAMETERS
        * @param {string} [params.cancelClientOrderID] the user-defined id of the order to be canceled, 1-40 characters, different orders cannot use the same clientOrderID, only supports a query range of 2 hours
        * @param {string} [params.cancelRestrictions] cancel orders with specified status, NEW: New order, PENDING: Pending order, PARTIALLY_FILLED: Partially filled
        * @param {string} [params.cancelReplaceMode] STOP_ON_FAILURE - if the cancel order fails, it will not continue to place a new order, ALLOW_FAILURE - regardless of whether the cancel order succeeds or fails, it will continue to place a new order
        * @param {float} [params.quoteOrderQty] order amount
        * @param {string} [params.newClientOrderId] custom order id consisting of letters, numbers, and _, 1-40 characters, different orders cannot use the same newClientOrderId.
        * @param {string} [params.positionSide] *contract only* position direction, required for single position as BOTH, for both long and short positions only LONG or SHORT can be chosen, defaults to LONG if empty
        * @param {string} [params.reduceOnly] *contract only* true or false, default=false for single position mode. this parameter is not accepted for both long and short positions mode
        * @param {float} [params.priceRate] *contract only* for type TRAILING_STOP_Market, Max = 1
        * @param {string} [params.workingType] *contract only* StopPrice trigger price types, MARK_PRICE (default), CONTRACT_PRICE, or INDEX_PRICE
        * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = this.createOrderRequest(symbol, type, side, amount, price, parameters);
        ((IDictionary<string,object>)request)["cancelOrderId"] = id;
        ((IDictionary<string,object>)request)["cancelReplaceMode"] = "STOP_ON_FAILURE";
        object response = null;
        if (isTrue(getValue(market, "swap")))
        {
            response = await this.swapV1PrivatePostTradeCancelReplace(this.extend(request, parameters));
        } else
        {
            response = await this.spotV1PrivatePostTradeOrderCancelReplace(this.extend(request, parameters));
        }
        object data = this.safeDict(response, "data");
        return this.parseOrder(data, market);
    }

    public async override Task<object> fetchMarginMode(object symbol, object parameters = null)
    {
        /**
        * @method
        * @name bingx#fetchMarginMode
        * @description fetches the margin mode of the trading pair
        * @see https://bingx-api.github.io/docs/#/en-us/swapV2/trade-api.html#Query%20Margin%20Mode
        * @param {string} symbol unified symbol of the market to fetch the margin mode for
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} Struct of MarginMode
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object response = await this.swapV2PrivateGetTradeMarginType(this.extend(request, parameters));
        //
        //     {
        //         "code": 0,
        //         "msg": "",
        //         "data": {
        //             "marginType": "CROSSED"
        //         }
        //     }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        return this.parseMarginMode(data, market);
    }

    public override object parseMarginMode(object marginMode, object market = null)
    {
        object marginType = this.safeStringLower(marginMode, "marginType");
        marginType = ((bool) isTrue((isEqual(marginType, "crossed")))) ? "cross" : marginType;
        return new Dictionary<string, object>() {
            { "info", marginMode },
            { "symbol", getValue(market, "symbol") },
            { "marginMode", marginType },
        };
    }

    public override object sign(object path, object section = null, object method = null, object parameters = null, object headers = null, object body = null)
    {
        section ??= "public";
        method ??= "GET";
        parameters ??= new Dictionary<string, object>();
        object type = getValue(section, 0);
        object version = getValue(section, 1);
        object access = getValue(section, 2);
        object isSandbox = this.safeBool(this.options, "sandboxMode", false);
        if (isTrue(isTrue(isSandbox) && isTrue((!isEqual(type, "swap")))))
        {
            throw new NotSupported ((string)add(add(add(this.id, " does not have a testnet/sandbox URL for "), type), " endpoints")) ;
        }
        object url = this.implodeHostname(getValue(getValue(this.urls, "api"), type));
        if (isTrue(isTrue(isEqual(type, "spot")) && isTrue(isEqual(version, "v3"))))
        {
            url = add(url, "/api");
        } else
        {
            url = add(url, add("/", type));
        }
        url = add(url, add(add("/", version), "/"));
        path = this.implodeParams(path, parameters);
        url = add(url, path);
        parameters = this.omit(parameters, this.extractParams(path));
        parameters = this.keysort(parameters);
        if (isTrue(isEqual(access, "public")))
        {
            ((IDictionary<string,object>)parameters)["timestamp"] = this.nonce();
            if (isTrue(getArrayLength(new List<object>(((IDictionary<string,object>)parameters).Keys))))
            {
                url = add(url, add("?", this.urlencode(parameters)));
            }
        } else if (isTrue(isEqual(access, "private")))
        {
            this.checkRequiredCredentials();
            ((IDictionary<string,object>)parameters)["timestamp"] = this.nonce();
            object parsedParams = this.parseParams(parameters);
            object query = this.urlencode(parsedParams);
            object signature = this.hmac(this.encode(this.rawencode(parsedParams)), this.encode(this.secret), sha256);
            if (isTrue(getArrayLength(new List<object>(((IDictionary<string,object>)parameters).Keys))))
            {
                query = add(add("?", query), "&");
            } else
            {
                query = add(query, "?");
            }
            query = add(query, add("signature=", signature));
            headers = new Dictionary<string, object>() {
                { "X-BX-APIKEY", this.apiKey },
                { "X-SOURCE-KEY", this.safeString(this.options, "broker", "CCXT") },
            };
            url = add(url, query);
        }
        return new Dictionary<string, object>() {
            { "url", url },
            { "method", method },
            { "body", body },
            { "headers", headers },
        };
    }

    public override object nonce()
    {
        return this.milliseconds();
    }

    public override void setSandboxMode(object enable)
    {
        base.setSandboxMode(enable);
        ((IDictionary<string,object>)this.options)["sandboxMode"] = enable;
    }

    public override object handleErrors(object httpCode, object reason, object url, object method, object headers, object body, object response, object requestHeaders, object requestBody)
    {
        if (isTrue(isEqual(response, null)))
        {
            return null;  // fallback to default error handler
        }
        //
        //    {
        //        "code": 80014,
        //        "msg": "Invalid parameters, err:Key: 'GetTickerRequest.Symbol' Error:Field validation for "Symbol" failed on the "len=0|endswith=-USDT" tag",
        //        "data": {
        //        }
        //    }
        //
        object code = this.safeString(response, "code");
        object message = this.safeString(response, "msg");
        if (isTrue(isTrue(!isEqual(code, null)) && isTrue(!isEqual(code, "0"))))
        {
            object feedback = add(add(this.id, " "), body);
            this.throwExactlyMatchedException(getValue(this.exceptions, "exact"), message, feedback);
            this.throwExactlyMatchedException(getValue(this.exceptions, "exact"), code, feedback);
            this.throwBroadlyMatchedException(getValue(this.exceptions, "broad"), message, feedback);
            throw new ExchangeError ((string)feedback) ;
        }
        return null;
    }
}
