namespace ccxt;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

public partial class onetrading : Exchange
{
    public override object describe()
    {
        return this.deepExtend(base.describe(), new Dictionary<string, object>() {
            { "id", "onetrading" },
            { "name", "One Trading" },
            { "countries", new List<object>() {"AT"} },
            { "rateLimit", 300 },
            { "version", "v1" },
            { "pro", true },
            { "has", new Dictionary<string, object>() {
                { "CORS", null },
                { "spot", true },
                { "margin", false },
                { "swap", false },
                { "future", false },
                { "option", false },
                { "addMargin", false },
                { "cancelAllOrders", true },
                { "cancelOrder", true },
                { "cancelOrders", true },
                { "closeAllPositions", false },
                { "closePosition", false },
                { "createDepositAddress", false },
                { "createOrder", true },
                { "createReduceOnlyOrder", false },
                { "createStopLimitOrder", true },
                { "createStopMarketOrder", false },
                { "createStopOrder", true },
                { "fetchAccounts", false },
                { "fetchBalance", true },
                { "fetchBorrowRateHistories", false },
                { "fetchBorrowRateHistory", false },
                { "fetchClosedOrders", true },
                { "fetchCrossBorrowRate", false },
                { "fetchCrossBorrowRates", false },
                { "fetchCurrencies", true },
                { "fetchDeposit", false },
                { "fetchDepositAddress", false },
                { "fetchDepositAddresses", false },
                { "fetchDepositAddressesByNetwork", false },
                { "fetchDeposits", false },
                { "fetchDepositsWithdrawals", false },
                { "fetchFundingHistory", false },
                { "fetchFundingRate", false },
                { "fetchFundingRateHistory", false },
                { "fetchFundingRates", false },
                { "fetchIndexOHLCV", false },
                { "fetchIsolatedBorrowRate", false },
                { "fetchIsolatedBorrowRates", false },
                { "fetchLedger", false },
                { "fetchLeverage", false },
                { "fetchMarginMode", false },
                { "fetchMarkets", true },
                { "fetchMarkOHLCV", false },
                { "fetchMyTrades", true },
                { "fetchOHLCV", true },
                { "fetchOpenInterestHistory", false },
                { "fetchOpenOrders", true },
                { "fetchOrder", true },
                { "fetchOrderBook", true },
                { "fetchOrders", false },
                { "fetchOrderTrades", true },
                { "fetchPosition", false },
                { "fetchPositionHistory", false },
                { "fetchPositionMode", false },
                { "fetchPositions", false },
                { "fetchPositionsForSymbol", false },
                { "fetchPositionsHistory", false },
                { "fetchPositionsRisk", false },
                { "fetchPremiumIndexOHLCV", false },
                { "fetchTicker", true },
                { "fetchTickers", true },
                { "fetchTime", true },
                { "fetchTrades", false },
                { "fetchTradingFee", false },
                { "fetchTradingFees", true },
                { "fetchTransactionFee", false },
                { "fetchTransactionFees", false },
                { "fetchTransactions", false },
                { "fetchTransfer", false },
                { "fetchTransfers", false },
                { "fetchWithdrawal", false },
                { "fetchWithdrawals", false },
                { "reduceMargin", false },
                { "setLeverage", false },
                { "setMargin", false },
                { "setMarginMode", false },
                { "setPositionMode", false },
                { "transfer", false },
                { "withdraw", false },
            } },
            { "timeframes", new Dictionary<string, object>() {
                { "1m", "1/MINUTES" },
                { "5m", "5/MINUTES" },
                { "15m", "15/MINUTES" },
                { "30m", "30/MINUTES" },
                { "1h", "1/HOURS" },
                { "4h", "4/HOURS" },
                { "1d", "1/DAYS" },
                { "1w", "1/WEEKS" },
                { "1M", "1/MONTHS" },
            } },
            { "urls", new Dictionary<string, object>() {
                { "logo", "https://github.com/ccxt/ccxt/assets/43336371/bdbc26fd-02f2-4ca7-9f1e-17333690bb1c" },
                { "api", new Dictionary<string, object>() {
                    { "public", "https://api.onetrading.com/fast" },
                    { "private", "https://api.onetrading.com/fast" },
                } },
                { "www", "https://onetrading.com/" },
                { "doc", new List<object>() {"https://docs.onetrading.com"} },
                { "fees", "https://onetrading.com/fees" },
            } },
            { "api", new Dictionary<string, object>() {
                { "public", new Dictionary<string, object>() {
                    { "get", new List<object>() {"currencies", "candlesticks/{instrument_code}", "fees", "instruments", "order-book/{instrument_code}", "market-ticker", "market-ticker/{instrument_code}", "time"} },
                } },
                { "private", new Dictionary<string, object>() {
                    { "get", new List<object>() {"account/balances", "account/fees", "account/orders", "account/orders/{order_id}", "account/orders/{order_id}/trades", "account/trades", "account/trades/{trade_id}"} },
                    { "post", new List<object>() {"account/orders"} },
                    { "delete", new List<object>() {"account/orders", "account/orders/{order_id}", "account/orders/client/{client_id}"} },
                } },
            } },
            { "fees", new Dictionary<string, object>() {
                { "trading", new Dictionary<string, object>() {
                    { "tierBased", true },
                    { "percentage", true },
                    { "taker", this.parseNumber("0.0015") },
                    { "maker", this.parseNumber("0.001") },
                    { "tiers", new List<object>() {new Dictionary<string, object>() {
    { "taker", new List<object>() {new List<object> {this.parseNumber("0"), this.parseNumber("0.0015")}, new List<object> {this.parseNumber("100"), this.parseNumber("0.0013")}, new List<object> {this.parseNumber("250"), this.parseNumber("0.0013")}, new List<object> {this.parseNumber("1000"), this.parseNumber("0.001")}, new List<object> {this.parseNumber("5000"), this.parseNumber("0.0009")}, new List<object> {this.parseNumber("10000"), this.parseNumber("0.00075")}, new List<object> {this.parseNumber("20000"), this.parseNumber("0.00065")}} },
    { "maker", new List<object>() {new List<object> {this.parseNumber("0"), this.parseNumber("0.001")}, new List<object> {this.parseNumber("100"), this.parseNumber("0.001")}, new List<object> {this.parseNumber("250"), this.parseNumber("0.0009")}, new List<object> {this.parseNumber("1000"), this.parseNumber("0.00075")}, new List<object> {this.parseNumber("5000"), this.parseNumber("0.0006")}, new List<object> {this.parseNumber("10000"), this.parseNumber("0.0005")}, new List<object> {this.parseNumber("20000"), this.parseNumber("0.0005")}} },
}} },
                } },
            } },
            { "requiredCredentials", new Dictionary<string, object>() {
                { "apiKey", true },
                { "secret", false },
            } },
            { "precisionMode", TICK_SIZE },
            { "exceptions", new Dictionary<string, object>() {
                { "exact", new Dictionary<string, object>() {
                    { "INVALID_CLIENT_UUID", typeof(InvalidOrder) },
                    { "ORDER_NOT_FOUND", typeof(OrderNotFound) },
                    { "ONLY_ONE_ERC20_ADDRESS_ALLOWED", typeof(InvalidAddress) },
                    { "DEPOSIT_ADDRESS_NOT_USED", typeof(InvalidAddress) },
                    { "INVALID_CREDENTIALS", typeof(AuthenticationError) },
                    { "MISSING_CREDENTIALS", typeof(AuthenticationError) },
                    { "INVALID_APIKEY", typeof(AuthenticationError) },
                    { "INVALID_SCOPES", typeof(AuthenticationError) },
                    { "INVALID_SUBJECT", typeof(AuthenticationError) },
                    { "INVALID_ISSUER", typeof(AuthenticationError) },
                    { "INVALID_AUDIENCE", typeof(AuthenticationError) },
                    { "INVALID_DEVICE_ID", typeof(AuthenticationError) },
                    { "INVALID_IP_RESTRICTION", typeof(AuthenticationError) },
                    { "APIKEY_REVOKED", typeof(AuthenticationError) },
                    { "APIKEY_EXPIRED", typeof(AuthenticationError) },
                    { "SYNCHRONIZER_TOKEN_MISMATCH", typeof(AuthenticationError) },
                    { "SESSION_EXPIRED", typeof(AuthenticationError) },
                    { "INTERNAL_ERROR", typeof(AuthenticationError) },
                    { "CLIENT_IP_BLOCKED", typeof(PermissionDenied) },
                    { "MISSING_PERMISSION", typeof(PermissionDenied) },
                    { "ILLEGAL_CHARS", typeof(BadRequest) },
                    { "UNSUPPORTED_MEDIA_TYPE", typeof(BadRequest) },
                    { "ACCOUNT_HISTORY_TIME_RANGE_TOO_BIG", typeof(BadRequest) },
                    { "CANDLESTICKS_TIME_RANGE_TOO_BIG", typeof(BadRequest) },
                    { "INVALID_INSTRUMENT_CODE", typeof(BadRequest) },
                    { "INVALID_ORDER_TYPE", typeof(BadRequest) },
                    { "INVALID_UNIT", typeof(BadRequest) },
                    { "INVALID_PERIOD", typeof(BadRequest) },
                    { "INVALID_TIME", typeof(BadRequest) },
                    { "INVALID_DATE", typeof(BadRequest) },
                    { "INVALID_CURRENCY", typeof(BadRequest) },
                    { "INVALID_AMOUNT", typeof(BadRequest) },
                    { "INVALID_PRICE", typeof(BadRequest) },
                    { "INVALID_LIMIT", typeof(BadRequest) },
                    { "INVALID_QUERY", typeof(BadRequest) },
                    { "INVALID_CURSOR", typeof(BadRequest) },
                    { "INVALID_ACCOUNT_ID", typeof(BadRequest) },
                    { "INVALID_SIDE", typeof(InvalidOrder) },
                    { "INVALID_ACCOUNT_HISTORY_FROM_TIME", typeof(BadRequest) },
                    { "INVALID_ACCOUNT_HISTORY_MAX_PAGE_SIZE", typeof(BadRequest) },
                    { "INVALID_ACCOUNT_HISTORY_TIME_PERIOD", typeof(BadRequest) },
                    { "INVALID_ACCOUNT_HISTORY_TO_TIME", typeof(BadRequest) },
                    { "INVALID_CANDLESTICKS_GRANULARITY", typeof(BadRequest) },
                    { "INVALID_CANDLESTICKS_UNIT", typeof(BadRequest) },
                    { "INVALID_ORDER_BOOK_DEPTH", typeof(BadRequest) },
                    { "INVALID_ORDER_BOOK_LEVEL", typeof(BadRequest) },
                    { "INVALID_PAGE_CURSOR", typeof(BadRequest) },
                    { "INVALID_TIME_RANGE", typeof(BadRequest) },
                    { "INVALID_TRADE_ID", typeof(BadRequest) },
                    { "INVALID_UI_ACCOUNT_SETTINGS", typeof(BadRequest) },
                    { "NEGATIVE_AMOUNT", typeof(InvalidOrder) },
                    { "NEGATIVE_PRICE", typeof(InvalidOrder) },
                    { "MIN_SIZE_NOT_SATISFIED", typeof(InvalidOrder) },
                    { "BAD_AMOUNT_PRECISION", typeof(InvalidOrder) },
                    { "BAD_PRICE_PRECISION", typeof(InvalidOrder) },
                    { "BAD_TRIGGER_PRICE_PRECISION", typeof(InvalidOrder) },
                    { "MAX_OPEN_ORDERS_EXCEEDED", typeof(BadRequest) },
                    { "MISSING_PRICE", typeof(InvalidOrder) },
                    { "MISSING_ORDER_TYPE", typeof(InvalidOrder) },
                    { "MISSING_SIDE", typeof(InvalidOrder) },
                    { "MISSING_CANDLESTICKS_PERIOD_PARAM", typeof(ArgumentsRequired) },
                    { "MISSING_CANDLESTICKS_UNIT_PARAM", typeof(ArgumentsRequired) },
                    { "MISSING_FROM_PARAM", typeof(ArgumentsRequired) },
                    { "MISSING_INSTRUMENT_CODE", typeof(ArgumentsRequired) },
                    { "MISSING_ORDER_ID", typeof(InvalidOrder) },
                    { "MISSING_TO_PARAM", typeof(ArgumentsRequired) },
                    { "MISSING_TRADE_ID", typeof(ArgumentsRequired) },
                    { "INVALID_ORDER_ID", typeof(OrderNotFound) },
                    { "NOT_FOUND", typeof(OrderNotFound) },
                    { "INSUFFICIENT_LIQUIDITY", typeof(InsufficientFunds) },
                    { "INSUFFICIENT_FUNDS", typeof(InsufficientFunds) },
                    { "NO_TRADING", typeof(ExchangeNotAvailable) },
                    { "SERVICE_UNAVAILABLE", typeof(ExchangeNotAvailable) },
                    { "GATEWAY_TIMEOUT", typeof(ExchangeNotAvailable) },
                    { "RATELIMIT", typeof(DDoSProtection) },
                    { "CF_RATELIMIT", typeof(DDoSProtection) },
                    { "INTERNAL_SERVER_ERROR", typeof(ExchangeError) },
                } },
                { "broad", new Dictionary<string, object>() {} },
            } },
            { "commonCurrencies", new Dictionary<string, object>() {
                { "MIOTA", "IOTA" },
            } },
            { "options", new Dictionary<string, object>() {
                { "fetchTradingFees", new Dictionary<string, object>() {
                    { "method", "fetchPrivateTradingFees" },
                } },
                { "fiat", new List<object>() {"EUR", "CHF"} },
            } },
        });
    }

    /**
     * @method
     * @name onetrading#fetchTime
     * @description fetches the current integer timestamp in milliseconds from the exchange server
     * @see https://docs.onetrading.com/#time
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {int} the current integer timestamp in milliseconds from the exchange server
     */
    public async override Task<object> fetchTime(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object response = await this.publicGetTime(parameters);
        //
        //     {
        //         "iso": "2020-07-10T05:17:26.716Z",
        //         "epoch_millis": 1594358246716,
        //     }
        //
        return this.safeInteger(response, "epoch_millis");
    }

    /**
     * @method
     * @name onetrading#fetchCurrencies
     * @description fetches all available currencies on an exchange
     * @see https://docs.onetrading.com/#currencies
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} an associative dictionary of currencies
     */
    public async override Task<object> fetchCurrencies(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object response = await this.publicGetCurrencies(parameters);
        //
        //     [
        //         {
        //             "code":"BEST",
        //             "precision":8
        //         }
        //     ]
        //
        object result = new Dictionary<string, object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(response)); postFixIncrement(ref i))
        {
            object currency = getValue(response, i);
            object id = this.safeString(currency, "code");
            object code = this.safeCurrencyCode(id);
            ((IDictionary<string,object>)result)[(string)code] = new Dictionary<string, object>() {
                { "id", id },
                { "code", code },
                { "name", null },
                { "info", currency },
                { "active", null },
                { "fee", null },
                { "precision", this.parseNumber(this.parsePrecision(this.safeString(currency, "precision"))) },
                { "withdraw", null },
                { "deposit", null },
                { "limits", new Dictionary<string, object>() {
                    { "amount", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                    { "withdraw", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                } },
                { "networks", new Dictionary<string, object>() {} },
            };
        }
        return result;
    }

    /**
     * @method
     * @name onetrading#fetchMarkets
     * @description retrieves data on all markets for onetrading
     * @see https://docs.onetrading.com/#instruments
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} an array of objects representing market data
     */
    public async override Task<object> fetchMarkets(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object response = await this.publicGetInstruments(parameters);
        //
        //     [
        //         {
        //             "state": "ACTIVE",
        //             "base": { code: "ETH", precision: 8 },
        //             "quote": { code: "CHF", precision: 2 },
        //             "amount_precision": 4,
        //             "market_precision": 2,
        //             "min_size": "10.0"
        //         }
        //     ]
        //
        return this.parseMarkets(response);
    }

    public override object parseMarket(object market)
    {
        object baseAsset = this.safeValue(market, "base", new Dictionary<string, object>() {});
        object quoteAsset = this.safeValue(market, "quote", new Dictionary<string, object>() {});
        object baseId = this.safeString(baseAsset, "code");
        object quoteId = this.safeString(quoteAsset, "code");
        object id = add(add(baseId, "_"), quoteId);
        object bs = this.safeCurrencyCode(baseId);
        object quote = this.safeCurrencyCode(quoteId);
        object state = this.safeString(market, "state");
        return new Dictionary<string, object>() {
            { "id", id },
            { "symbol", add(add(bs, "/"), quote) },
            { "base", bs },
            { "quote", quote },
            { "settle", null },
            { "baseId", baseId },
            { "quoteId", quoteId },
            { "settleId", null },
            { "type", "spot" },
            { "spot", true },
            { "margin", false },
            { "swap", false },
            { "future", false },
            { "option", false },
            { "active", (isEqual(state, "ACTIVE")) },
            { "contract", false },
            { "linear", null },
            { "inverse", null },
            { "contractSize", null },
            { "expiry", null },
            { "expiryDatetime", null },
            { "strike", null },
            { "optionType", null },
            { "precision", new Dictionary<string, object>() {
                { "amount", this.parseNumber(this.parsePrecision(this.safeString(market, "amount_precision"))) },
                { "price", this.parseNumber(this.parsePrecision(this.safeString(market, "market_precision"))) },
            } },
            { "limits", new Dictionary<string, object>() {
                { "leverage", new Dictionary<string, object>() {
                    { "min", null },
                    { "max", null },
                } },
                { "amount", new Dictionary<string, object>() {
                    { "min", null },
                    { "max", null },
                } },
                { "price", new Dictionary<string, object>() {
                    { "min", null },
                    { "max", null },
                } },
                { "cost", new Dictionary<string, object>() {
                    { "min", this.safeNumber(market, "min_size") },
                    { "max", null },
                } },
            } },
            { "created", null },
            { "info", market },
        };
    }

    /**
     * @method
     * @name onetrading#fetchTradingFees
     * @description fetch the trading fees for multiple markets
     * @see https://docs.onetrading.com/#fee-groups
     * @see https://docs.onetrading.com/#fees
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a dictionary of [fee structures]{@link https://docs.ccxt.com/#/?id=fee-structure} indexed by market symbols
     */
    public async override Task<object> fetchTradingFees(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object method = this.safeString(parameters, "method");
        parameters = this.omit(parameters, "method");
        if (isTrue(isEqual(method, null)))
        {
            object options = this.safeValue(this.options, "fetchTradingFees", new Dictionary<string, object>() {});
            method = this.safeString(options, "method", "fetchPrivateTradingFees");
        }
        if (isTrue(isEqual(method, "fetchPrivateTradingFees")))
        {
            return await this.fetchPrivateTradingFees(parameters);
        } else if (isTrue(isEqual(method, "fetchPublicTradingFees")))
        {
            return await this.fetchPublicTradingFees(parameters);
        } else
        {
            throw new NotSupported ((string)add(add(add(this.id, " fetchTradingFees() does not support "), method), ", fetchPrivateTradingFees and fetchPublicTradingFees are supported")) ;
        }
    }

    public async virtual Task<object> fetchPublicTradingFees(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.publicGetFees(parameters);
        //
        //     [
        //         {
        //             "fee_group_id":"default",
        //             "display_text":"The standard fee plan.",
        //             "fee_tiers":[
        //                 {"volume":"0.0","fee_group_id":"default","maker_fee":"0.1","taker_fee":"0.15"},
        //                 {"volume":"100.0","fee_group_id":"default","maker_fee":"0.1","taker_fee":"0.13"},
        //                 {"volume":"250.0","fee_group_id":"default","maker_fee":"0.09","taker_fee":"0.13"},
        //                 {"volume":"1000.0","fee_group_id":"default","maker_fee":"0.075","taker_fee":"0.1"},
        //                 {"volume":"5000.0","fee_group_id":"default","maker_fee":"0.06","taker_fee":"0.09"},
        //                 {"volume":"10000.0","fee_group_id":"default","maker_fee":"0.05","taker_fee":"0.075"},
        //                 {"volume":"20000.0","fee_group_id":"default","maker_fee":"0.05","taker_fee":"0.065"}
        //             ],
        //             "fee_discount_rate":"25.0",
        //             "minimum_price_value":"0.12"
        //         }
        //     ]
        //
        object first = this.safeValue(response, 0, new Dictionary<string, object>() {});
        object feeTiers = this.safeValue(first, "fee_tiers");
        object tiers = this.parseFeeTiers(feeTiers);
        object firstTier = this.safeValue(feeTiers, 0, new Dictionary<string, object>() {});
        object result = new Dictionary<string, object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(this.symbols)); postFixIncrement(ref i))
        {
            object symbol = getValue(this.symbols, i);
            ((IDictionary<string,object>)result)[(string)symbol] = new Dictionary<string, object>() {
                { "info", first },
                { "symbol", symbol },
                { "maker", this.safeNumber(firstTier, "maker_fee") },
                { "taker", this.safeNumber(firstTier, "taker_fee") },
                { "percentage", true },
                { "tierBased", true },
                { "tiers", tiers },
            };
        }
        return result;
    }

    public async virtual Task<object> fetchPrivateTradingFees(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.privateGetAccountFees(parameters);
        //
        //     {
        //         "account_id": "ed524d00-820a-11e9-8f1e-69602df16d85",
        //         "running_trading_volume": "0.0",
        //         "fee_group_id": "default",
        //         "collect_fees_in_best": false,
        //         "fee_discount_rate": "25.0",
        //         "minimum_price_value": "0.12",
        //         "fee_tiers": [
        //             { "volume": "0.0", "fee_group_id": "default", "maker_fee": "0.1", "taker_fee": "0.1" },
        //             { "volume": "100.0", "fee_group_id": "default", "maker_fee": "0.09", "taker_fee": "0.1" },
        //             { "volume": "250.0", "fee_group_id": "default", "maker_fee": "0.08", "taker_fee": "0.1" },
        //             { "volume": "1000.0", "fee_group_id": "default", "maker_fee": "0.07", "taker_fee": "0.09" },
        //             { "volume": "5000.0", "fee_group_id": "default", "maker_fee": "0.06", "taker_fee": "0.08" },
        //             { "volume": "10000.0", "fee_group_id": "default", "maker_fee": "0.05", "taker_fee": "0.07" },
        //             { "volume": "20000.0", "fee_group_id": "default", "maker_fee": "0.05", "taker_fee": "0.06" },
        //             { "volume": "50000.0", "fee_group_id": "default", "maker_fee": "0.05", "taker_fee": "0.05" }
        //         ],
        //         "active_fee_tier": { "volume": "0.0", "fee_group_id": "default", "maker_fee": "0.1", "taker_fee": "0.1" }
        //     }
        //
        object activeFeeTier = this.safeValue(response, "active_fee_tier", new Dictionary<string, object>() {});
        object makerFee = this.safeString(activeFeeTier, "maker_fee");
        object takerFee = this.safeString(activeFeeTier, "taker_fee");
        makerFee = Precise.stringDiv(makerFee, "100");
        takerFee = Precise.stringDiv(takerFee, "100");
        object feeTiers = this.safeValue(response, "fee_tiers");
        object result = new Dictionary<string, object>() {};
        object tiers = this.parseFeeTiers(feeTiers);
        for (object i = 0; isLessThan(i, getArrayLength(this.symbols)); postFixIncrement(ref i))
        {
            object symbol = getValue(this.symbols, i);
            ((IDictionary<string,object>)result)[(string)symbol] = new Dictionary<string, object>() {
                { "info", response },
                { "symbol", symbol },
                { "maker", this.parseNumber(makerFee) },
                { "taker", this.parseNumber(takerFee) },
                { "percentage", true },
                { "tierBased", true },
                { "tiers", tiers },
            };
        }
        return result;
    }

    public virtual object parseFeeTiers(object feeTiers, object market = null)
    {
        object takerFees = new List<object>() {};
        object makerFees = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(feeTiers)); postFixIncrement(ref i))
        {
            object tier = getValue(feeTiers, i);
            object volume = this.safeNumber(tier, "volume");
            object taker = this.safeString(tier, "taker_fee");
            object maker = this.safeString(tier, "maker_fee");
            maker = Precise.stringDiv(maker, "100");
            taker = Precise.stringDiv(taker, "100");
            ((IList<object>)makerFees).Add(new List<object>() {volume, this.parseNumber(maker)});
            ((IList<object>)takerFees).Add(new List<object>() {volume, this.parseNumber(taker)});
        }
        return new Dictionary<string, object>() {
            { "maker", makerFees },
            { "taker", takerFees },
        };
    }

    public override object parseTicker(object ticker, object market = null)
    {
        //
        // fetchTicker, fetchTickers
        //
        //     {
        //         "instrument_code":"BTC_EUR",
        //         "sequence":602562,
        //         "time":"2020-07-10T06:27:34.951Z",
        //         "state":"ACTIVE",
        //         "is_frozen":0,
        //         "quote_volume":"1695555.1783768",
        //         "base_volume":"205.67436",
        //         "last_price":"8143.91",
        //         "best_bid":"8143.71",
        //         "best_ask":"8156.9",
        //         "price_change":"-147.47",
        //         "price_change_percentage":"-1.78",
        //         "high":"8337.45",
        //         "low":"8110.0"
        //     }
        //
        object timestamp = this.parse8601(this.safeString(ticker, "time"));
        object marketId = this.safeString(ticker, "instrument_code");
        object symbol = this.safeSymbol(marketId, market, "_");
        object last = this.safeString(ticker, "last_price");
        object percentage = this.safeString(ticker, "price_change_percentage");
        object change = this.safeString(ticker, "price_change");
        object baseVolume = this.safeString(ticker, "base_volume");
        object quoteVolume = this.safeString(ticker, "quote_volume");
        return this.safeTicker(new Dictionary<string, object>() {
            { "symbol", symbol },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "high", this.safeString(ticker, "high") },
            { "low", this.safeString(ticker, "low") },
            { "bid", this.safeString(ticker, "best_bid") },
            { "bidVolume", null },
            { "ask", this.safeString(ticker, "best_ask") },
            { "askVolume", null },
            { "vwap", null },
            { "open", null },
            { "close", last },
            { "last", last },
            { "previousClose", null },
            { "change", change },
            { "percentage", percentage },
            { "average", null },
            { "baseVolume", baseVolume },
            { "quoteVolume", quoteVolume },
            { "info", ticker },
        }, market);
    }

    /**
     * @method
     * @name onetrading#fetchTicker
     * @description fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
     * @see https://docs.onetrading.com/#market-ticker-for-instrument
     * @param {string} symbol unified symbol of the market to fetch the ticker for
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
     */
    public async override Task<object> fetchTicker(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "instrument_code", getValue(market, "id") },
        };
        object response = await this.publicGetMarketTickerInstrumentCode(this.extend(request, parameters));
        //
        //     {
        //         "instrument_code":"BTC_EUR",
        //         "sequence":602562,
        //         "time":"2020-07-10T06:27:34.951Z",
        //         "state":"ACTIVE",
        //         "is_frozen":0,
        //         "quote_volume":"1695555.1783768",
        //         "base_volume":"205.67436",
        //         "last_price":"8143.91",
        //         "best_bid":"8143.71",
        //         "best_ask":"8156.9",
        //         "price_change":"-147.47",
        //         "price_change_percentage":"-1.78",
        //         "high":"8337.45",
        //         "low":"8110.0"
        //     }
        //
        return this.parseTicker(response, market);
    }

    /**
     * @method
     * @name onetrading#fetchTickers
     * @description fetches price tickers for multiple markets, statistical information calculated over the past 24 hours for each market
     * @see https://docs.onetrading.com/#market-ticker
     * @param {string[]} [symbols] unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/#/?id=ticker-structure}
     */
    public async override Task<object> fetchTickers(object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        symbols = this.marketSymbols(symbols);
        object response = await this.publicGetMarketTicker(parameters);
        //
        //     [
        //         {
        //             "instrument_code":"BTC_EUR",
        //             "sequence":602562,
        //             "time":"2020-07-10T06:27:34.951Z",
        //             "state":"ACTIVE",
        //             "is_frozen":0,
        //             "quote_volume":"1695555.1783768",
        //             "base_volume":"205.67436",
        //             "last_price":"8143.91",
        //             "best_bid":"8143.71",
        //             "best_ask":"8156.9",
        //             "price_change":"-147.47",
        //             "price_change_percentage":"-1.78",
        //             "high":"8337.45",
        //             "low":"8110.0"
        //         }
        //     ]
        //
        object result = new Dictionary<string, object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(response)); postFixIncrement(ref i))
        {
            object ticker = this.parseTicker(getValue(response, i));
            object symbol = getValue(ticker, "symbol");
            ((IDictionary<string,object>)result)[(string)symbol] = ticker;
        }
        return this.filterByArrayTickers(result, "symbol", symbols);
    }

    /**
     * @method
     * @name onetrading#fetchOrderBook
     * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
     * @see https://docs.onetrading.com/#order-book
     * @param {string} symbol unified symbol of the market to fetch the order book for
     * @param {int} [limit] the maximum amount of order book entries to return
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
     */
    public async override Task<object> fetchOrderBook(object symbol, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "instrument_code", getValue(market, "id") },
        };
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["depth"] = limit;
        }
        object response = await this.publicGetOrderBookInstrumentCode(this.extend(request, parameters));
        //
        // level 1
        //
        //     {
        //         "instrument_code":"BTC_EUR",
        //         "time":"2020-07-10T07:39:06.343Z",
        //         "asks":{
        //             "value":{
        //                 "price":"8145.29",
        //                 "amount":"0.96538",
        //                 "number_of_orders":1
        //             }
        //         },
        //         "bids":{
        //             "value":{
        //                 "price":"8134.0",
        //                 "amount":"1.5978",
        //                 "number_of_orders":5
        //             }
        //         }
        //     }
        //
        // level 2
        //
        //     {
        //         "instrument_code":"BTC_EUR","time":"2020-07-10T07:36:43.538Z",
        //         "asks":[
        //             {"price":"8146.59","amount":"0.89691","number_of_orders":1},
        //             {"price":"8146.89","amount":"1.92062","number_of_orders":1},
        //             {"price":"8169.5","amount":"0.0663","number_of_orders":1},
        //         ],
        //         "bids":[
        //             {"price":"8143.49","amount":"0.01329","number_of_orders":1},
        //             {"price":"8137.01","amount":"5.34748","number_of_orders":1},
        //             {"price":"8137.0","amount":"2.0","number_of_orders":1},
        //         ]
        //     }
        //
        // level 3
        //
        //     {
        //         "instrument_code":"BTC_EUR",
        //         "time":"2020-07-10T07:32:31.525Z",
        //         "bids":[
        //             {"price":"8146.79","amount":"0.01537","order_id":"5d717da1-a8f4-422d-afcc-03cb6ab66825"},
        //             {"price":"8139.32","amount":"3.66009","order_id":"d0715c68-f28d-4cf1-a450-d56cf650e11c"},
        //             {"price":"8137.51","amount":"2.61049","order_id":"085fd6f4-e835-4ca5-9449-a8f165772e60"},
        //         ],
        //         "asks":[
        //             {"price":"8153.49","amount":"0.93384","order_id":"755d3aa3-42b5-46fa-903d-98f42e9ae6c4"},
        //             {"price":"8153.79","amount":"1.80456","order_id":"62034cf3-b70d-45ff-b285-ba6307941e7c"},
        //             {"price":"8167.9","amount":"0.0018","order_id":"036354e0-71cd-492f-94f2-01f7d4b66422"},
        //         ]
        //     }
        //
        object timestamp = this.parse8601(this.safeString(response, "time"));
        return this.parseOrderBook(response, getValue(market, "symbol"), timestamp, "bids", "asks", "price", "amount");
    }

    public override object parseOHLCV(object ohlcv, object market = null)
    {
        //
        //     {
        //         "instrument_code":"BTC_EUR",
        //         "granularity":{"unit":"HOURS","period":1},
        //         "high":"9252.65",
        //         "low":"9115.27",
        //         "open":"9250.0",
        //         "close":"9132.35",
        //         "total_amount":"33.85924",
        //         "volume":"311958.9635744",
        //         "time":"2020-05-08T22:59:59.999Z",
        //         "last_sequence":461123
        //     }
        //
        object granularity = this.safeValue(ohlcv, "granularity");
        object unit = this.safeString(granularity, "unit");
        object period = this.safeString(granularity, "period");
        object units = new Dictionary<string, object>() {
            { "MINUTES", "m" },
            { "HOURS", "h" },
            { "DAYS", "d" },
            { "WEEKS", "w" },
            { "MONTHS", "M" },
        };
        object lowercaseUnit = this.safeString(units, unit);
        object timeframe = add(period, lowercaseUnit);
        object durationInSeconds = this.parseTimeframe(timeframe);
        object duration = multiply(durationInSeconds, 1000);
        object timestamp = this.parse8601(this.safeString(ohlcv, "time"));
        object alignedTimestamp = multiply(duration, this.parseToInt(divide(timestamp, duration)));
        object options = this.safeValue(this.options, "fetchOHLCV", new Dictionary<string, object>() {});
        object volumeField = this.safeString(options, "volume", "total_amount");
        return new List<object>() {alignedTimestamp, this.safeNumber(ohlcv, "open"), this.safeNumber(ohlcv, "high"), this.safeNumber(ohlcv, "low"), this.safeNumber(ohlcv, "close"), this.safeNumber(ohlcv, volumeField)};
    }

    /**
     * @method
     * @name onetrading#fetchOHLCV
     * @description fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
     * @see https://docs.onetrading.com/#candlesticks
     * @param {string} symbol unified symbol of the market to fetch OHLCV data for
     * @param {string} timeframe the length of time each candle represents
     * @param {int} [since] timestamp in ms of the earliest candle to fetch
     * @param {int} [limit] the maximum amount of candles to fetch
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
     */
    public async override Task<object> fetchOHLCV(object symbol, object timeframe = null, object since = null, object limit = null, object parameters = null)
    {
        timeframe ??= "1m";
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object periodUnit = this.safeString(this.timeframes, timeframe);
        var periodunitVariable = ((string)periodUnit).Split(new [] {((string)"/")}, StringSplitOptions.None).ToList<object>();
        var period = ((IList<object>) periodunitVariable)[0];
        var unit = ((IList<object>) periodunitVariable)[1];
        object durationInSeconds = this.parseTimeframe(timeframe);
        object duration = multiply(durationInSeconds, 1000);
        if (isTrue(isEqual(limit, null)))
        {
            limit = 1500;
        }
        object request = new Dictionary<string, object>() {
            { "instrument_code", getValue(market, "id") },
            { "period", period },
            { "unit", unit },
        };
        if (isTrue(isEqual(since, null)))
        {
            object now = this.milliseconds();
            ((IDictionary<string,object>)request)["to"] = this.iso8601(now);
            ((IDictionary<string,object>)request)["from"] = this.iso8601(subtract(now, multiply(limit, duration)));
        } else
        {
            ((IDictionary<string,object>)request)["from"] = this.iso8601(since);
            ((IDictionary<string,object>)request)["to"] = this.iso8601(this.sum(since, multiply(limit, duration)));
        }
        object response = await this.publicGetCandlesticksInstrumentCode(this.extend(request, parameters));
        //
        //     [
        //         {"instrument_code":"BTC_EUR","granularity":{"unit":"HOURS","period":1},"high":"9252.65","low":"9115.27","open":"9250.0","close":"9132.35","total_amount":"33.85924","volume":"311958.9635744","time":"2020-05-08T22:59:59.999Z","last_sequence":461123},
        //         {"instrument_code":"BTC_EUR","granularity":{"unit":"HOURS","period":1},"high":"9162.49","low":"9040.0","open":"9132.53","close":"9083.69","total_amount":"26.19685","volume":"238553.7812365","time":"2020-05-08T23:59:59.999Z","last_sequence":461376},
        //         {"instrument_code":"BTC_EUR","granularity":{"unit":"HOURS","period":1},"high":"9135.7","low":"9002.59","open":"9055.45","close":"9133.98","total_amount":"26.21919","volume":"238278.8724959","time":"2020-05-09T00:59:59.999Z","last_sequence":461521},
        //     ]
        //
        object ohlcv = this.safeList(response, "candlesticks");
        return this.parseOHLCVs(ohlcv, market, timeframe, since, limit);
    }

    public override object parseTrade(object trade, object market = null)
    {
        //
        // fetchTrades (public)
        //
        //     {
        //         "instrument_code":"BTC_EUR",
        //         "price":"8137.28",
        //         "amount":"0.22269",
        //         "taker_side":"BUY",
        //         "volume":"1812.0908832",
        //         "time":"2020-07-10T14:44:32.299Z",
        //         "trade_timestamp":1594392272299,
        //         "sequence":603047
        //     }
        //
        // fetchMyTrades, fetchOrder, fetchOpenOrders, fetchClosedOrders trades (private)
        //
        //     {
        //         "fee": {
        //             "fee_amount": "0.0014",
        //             "fee_currency": "BTC",
        //             "fee_percentage": "0.1",
        //             "fee_group_id": "default",
        //             "fee_type": "TAKER",
        //             "running_trading_volume": "0.0"
        //         },
        //         "trade": {
        //             "trade_id": "fdff2bcc-37d6-4a2d-92a5-46e09c868664",
        //             "order_id": "36bb2437-7402-4794-bf26-4bdf03526439",
        //             "account_id": "a4c699f6-338d-4a26-941f-8f9853bfc4b9",
        //             "amount": "1.4",
        //             "side": "BUY",
        //             "instrument_code": "BTC_EUR",
        //             "price": "7341.4",
        //             "time": "2019-09-27T15:05:32.564Z",
        //             "sequence": 48670
        //         }
        //     }
        //
        object feeInfo = this.safeValue(trade, "fee", new Dictionary<string, object>() {});
        trade = this.safeValue(trade, "trade", trade);
        object timestamp = this.safeInteger(trade, "trade_timestamp");
        if (isTrue(isEqual(timestamp, null)))
        {
            timestamp = this.parse8601(this.safeString(trade, "time"));
        }
        object side = this.safeStringLower2(trade, "side", "taker_side");
        object priceString = this.safeString(trade, "price");
        object amountString = this.safeString(trade, "amount");
        object costString = this.safeString(trade, "volume");
        object marketId = this.safeString(trade, "instrument_code");
        object symbol = this.safeSymbol(marketId, market, "_");
        object feeCostString = this.safeString(feeInfo, "fee_amount");
        object takerOrMaker = null;
        object fee = null;
        if (isTrue(!isEqual(feeCostString, null)))
        {
            object feeCurrencyId = this.safeString(feeInfo, "fee_currency");
            object feeCurrencyCode = this.safeCurrencyCode(feeCurrencyId);
            object feeRateString = this.safeString(feeInfo, "fee_percentage");
            fee = new Dictionary<string, object>() {
                { "cost", feeCostString },
                { "currency", feeCurrencyCode },
                { "rate", feeRateString },
            };
            takerOrMaker = this.safeStringLower(feeInfo, "fee_type");
        }
        return this.safeTrade(new Dictionary<string, object>() {
            { "id", this.safeString2(trade, "trade_id", "sequence") },
            { "order", this.safeString(trade, "order_id") },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "symbol", symbol },
            { "type", null },
            { "side", side },
            { "price", priceString },
            { "amount", amountString },
            { "cost", costString },
            { "takerOrMaker", takerOrMaker },
            { "fee", fee },
            { "info", trade },
        }, market);
    }

    public override object parseBalance(object response)
    {
        object balances = this.safeValue(response, "balances", new List<object>() {});
        object result = new Dictionary<string, object>() {
            { "info", response },
        };
        for (object i = 0; isLessThan(i, getArrayLength(balances)); postFixIncrement(ref i))
        {
            object balance = getValue(balances, i);
            object currencyId = this.safeString(balance, "currency_code");
            object code = this.safeCurrencyCode(currencyId);
            object account = this.account();
            ((IDictionary<string,object>)account)["free"] = this.safeString(balance, "available");
            ((IDictionary<string,object>)account)["used"] = this.safeString(balance, "locked");
            ((IDictionary<string,object>)result)[(string)code] = account;
        }
        return this.safeBalance(result);
    }

    /**
     * @method
     * @name onetrading#fetchBalance
     * @description query for balance and get the amount of funds available for trading or funds locked in orders
     * @see https://docs.onetrading.com/#balances
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
     */
    public async override Task<object> fetchBalance(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.privateGetAccountBalances(parameters);
        //
        //     {
        //         "account_id":"4b95934f-55f1-460c-a525-bd5afc0cf071",
        //         "balances":[
        //             {
        //                 "account_id":"4b95934f-55f1-460c-a525-bd5afc0cf071",
        //                 "currency_code":"BTC",
        //                 "change":"10.0",
        //                 "available":"10.0",
        //                 "locked":"0.0",
        //                 "sequence":142135994,
        //                 "time":"2020-07-01T10:57:32.959Z"
        //             }
        //         ]
        //     }
        //
        return this.parseBalance(response);
    }

    public virtual object parseOrderStatus(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "FILLED", "open" },
            { "FILLED_FULLY", "closed" },
            { "FILLED_CLOSED", "canceled" },
            { "FILLED_REJECTED", "rejected" },
            { "OPEN", "open" },
            { "REJECTED", "rejected" },
            { "CLOSED", "canceled" },
            { "FAILED", "failed" },
            { "STOP_TRIGGERED", "triggered" },
        };
        return this.safeString(statuses, status, status);
    }

    public override object parseOrder(object order, object market = null)
    {
        //
        // createOrder
        //
        //     {
        //         "order_id": "d5492c24-2995-4c18-993a-5b8bf8fffc0d",
        //         "client_id": "d75fb03b-b599-49e9-b926-3f0b6d103206",
        //         "account_id": "a4c699f6-338d-4a26-941f-8f9853bfc4b9",
        //         "instrument_code": "BTC_EUR",
        //         "time": "2019-08-01T08:00:44.026Z",
        //         "side": "BUY",
        //         "price": "5000",
        //         "amount": "1",
        //         "filled_amount": "0.5",
        //         "type": "LIMIT",
        //         "time_in_force": "GOOD_TILL_CANCELLED"
        //     }
        //
        // fetchOrder, fetchOpenOrders, fetchClosedOrders
        //
        //     {
        //         "order": {
        //             "order_id": "66756a10-3e86-48f4-9678-b634c4b135b2",
        //             "account_id": "1eb2ad5d-55f1-40b5-bc92-7dc05869e905",
        //             "instrument_code": "BTC_EUR",
        //             "amount": "1234.5678",
        //             "filled_amount": "1234.5678",
        //             "side": "BUY",
        //             "type": "LIMIT",
        //             "status": "OPEN",
        //             "sequence": 123456789,
        //             "price": "1234.5678",
        //             "average_price": "1234.5678",
        //             "reason": "INSUFFICIENT_FUNDS",
        //             "time": "2019-08-24T14:15:22Z",
        //             "time_in_force": "GOOD_TILL_CANCELLED",
        //             "time_last_updated": "2019-08-24T14:15:22Z",
        //             "expire_after": "2019-08-24T14:15:22Z",
        //             "is_post_only": false,
        //             "time_triggered": "2019-08-24T14:15:22Z",
        //             "trigger_price": "1234.5678"
        //         },
        //         "trades": [
        //             {
        //                 "fee": {
        //                     "fee_amount": "0.0014",
        //                     "fee_currency": "BTC",
        //                     "fee_percentage": "0.1",
        //                     "fee_group_id": "default",
        //                     "fee_type": "TAKER",
        //                     "running_trading_volume": "0.0"
        //                 },
        //                 "trade": {
        //                     "trade_id": "fdff2bcc-37d6-4a2d-92a5-46e09c868664",
        //                     "order_id": "36bb2437-7402-4794-bf26-4bdf03526439",
        //                     "account_id": "a4c699f6-338d-4a26-941f-8f9853bfc4b9",
        //                     "amount": "1.4",
        //                     "side": "BUY",
        //                     "instrument_code": "BTC_EUR",
        //                     "price": "7341.4",
        //                     "time": "2019-09-27T15:05:32.564Z",
        //                     "sequence": 48670
        //                 }
        //             }
        //         ]
        //     }
        //
        object rawOrder = this.safeValue(order, "order", order);
        object id = this.safeString(rawOrder, "order_id");
        object clientOrderId = this.safeString(rawOrder, "client_id");
        object timestamp = this.parse8601(this.safeString(rawOrder, "time"));
        object rawStatus = this.parseOrderStatus(this.safeString(rawOrder, "status"));
        object status = this.parseOrderStatus(rawStatus);
        object marketId = this.safeString(rawOrder, "instrument_code");
        object symbol = this.safeSymbol(marketId, market, "_");
        object price = this.safeString(rawOrder, "price");
        object amount = this.safeString(rawOrder, "amount");
        object filled = this.safeString(rawOrder, "filled_amount");
        object side = this.safeStringLower(rawOrder, "side");
        object type = this.safeStringLower(rawOrder, "type");
        object timeInForce = this.parseTimeInForce(this.safeString(rawOrder, "time_in_force"));
        object postOnly = this.safeValue(rawOrder, "is_post_only");
        object rawTrades = this.safeValue(order, "trades", new List<object>() {});
        return this.safeOrder(new Dictionary<string, object>() {
            { "id", id },
            { "clientOrderId", clientOrderId },
            { "info", order },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "lastTradeTimestamp", null },
            { "symbol", symbol },
            { "type", type },
            { "timeInForce", timeInForce },
            { "postOnly", postOnly },
            { "side", side },
            { "price", price },
            { "triggerPrice", this.safeNumber(rawOrder, "trigger_price") },
            { "amount", amount },
            { "cost", null },
            { "average", null },
            { "filled", filled },
            { "remaining", null },
            { "status", status },
            { "trades", rawTrades },
        }, market);
    }

    public virtual object parseTimeInForce(object timeInForce)
    {
        object timeInForces = new Dictionary<string, object>() {
            { "GOOD_TILL_CANCELLED", "GTC" },
            { "GOOD_TILL_TIME", "GTT" },
            { "IMMEDIATE_OR_CANCELLED", "IOC" },
            { "FILL_OR_KILL", "FOK" },
        };
        return this.safeString(timeInForces, timeInForce, timeInForce);
    }

    /**
     * @method
     * @name onetrading#createOrder
     * @description create a trade order
     * @see https://docs.onetrading.com/#create-order
     * @param {string} symbol unified symbol of the market to create an order in
     * @param {string} type 'market' or 'limit'
     * @param {string} side 'buy' or 'sell'
     * @param {float} amount how much of currency you want to trade in units of base currency
     * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {float} [params.triggerPrice] onetrading only does stop limit orders and does not do stop market
     * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> createOrder(object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object uppercaseType = ((string)type).ToUpper();
        object request = new Dictionary<string, object>() {
            { "instrument_code", getValue(market, "id") },
            { "type", uppercaseType },
            { "side", ((string)side).ToUpper() },
            { "amount", this.amountToPrecision(symbol, amount) },
        };
        object priceIsRequired = false;
        if (isTrue(isTrue(isEqual(uppercaseType, "LIMIT")) || isTrue(isEqual(uppercaseType, "STOP"))))
        {
            priceIsRequired = true;
        }
        object triggerPrice = this.safeNumberN(parameters, new List<object>() {"triggerPrice", "trigger_price", "stopPrice"});
        if (isTrue(!isEqual(triggerPrice, null)))
        {
            if (isTrue(isEqual(uppercaseType, "MARKET")))
            {
                throw new BadRequest ((string)add(this.id, " createOrder() cannot place stop market orders, only stop limit")) ;
            }
            ((IDictionary<string,object>)request)["trigger_price"] = this.priceToPrecision(symbol, triggerPrice);
            ((IDictionary<string,object>)request)["type"] = "STOP";
            parameters = this.omit(parameters, new List<object>() {"triggerPrice", "trigger_price", "stopPrice"});
        } else if (isTrue(isEqual(uppercaseType, "STOP")))
        {
            throw new ArgumentsRequired ((string)add(add(add(this.id, " createOrder() requires a triggerPrice param for "), type), " orders")) ;
        }
        if (isTrue(priceIsRequired))
        {
            ((IDictionary<string,object>)request)["price"] = this.priceToPrecision(symbol, price);
        }
        object clientOrderId = this.safeString2(parameters, "clientOrderId", "client_id");
        if (isTrue(!isEqual(clientOrderId, null)))
        {
            ((IDictionary<string,object>)request)["client_id"] = clientOrderId;
            parameters = this.omit(parameters, new List<object>() {"clientOrderId", "client_id"});
        }
        object response = await this.privatePostAccountOrders(this.extend(request, parameters));
        //
        //     {
        //         "order_id": "d5492c24-2995-4c18-993a-5b8bf8fffc0d",
        //         "client_id": "d75fb03b-b599-49e9-b926-3f0b6d103206",
        //         "account_id": "a4c699f6-338d-4a26-941f-8f9853bfc4b9",
        //         "instrument_code": "BTC_EUR",
        //         "time": "2019-08-01T08:00:44.026Z",
        //         "side": "BUY",
        //         "price": "5000",
        //         "amount": "1",
        //         "filled_amount": "0.5",
        //         "type": "LIMIT",
        //         "time_in_force": "GOOD_TILL_CANCELLED"
        //     }
        //
        return this.parseOrder(response, market);
    }

    /**
     * @method
     * @name onetrading#cancelOrder
     * @description cancels an open order
     * @see https://docs.onetrading.com/#close-order-by-order-id
     * @param {string} id order id
     * @param {string} symbol not used by bitmex cancelOrder ()
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> cancelOrder(object id, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object clientOrderId = this.safeString2(parameters, "clientOrderId", "client_id");
        parameters = this.omit(parameters, new List<object>() {"clientOrderId", "client_id"});
        object method = "privateDeleteAccountOrdersOrderId";
        object request = new Dictionary<string, object>() {};
        if (isTrue(!isEqual(clientOrderId, null)))
        {
            method = "privateDeleteAccountOrdersClientClientId";
            ((IDictionary<string,object>)request)["client_id"] = clientOrderId;
        } else
        {
            ((IDictionary<string,object>)request)["order_id"] = id;
        }
        object response = await ((Task<object>)callDynamically(this, method, new object[] { this.extend(request, parameters) }));
        //
        // responds with an empty body
        //
        return response;
    }

    /**
     * @method
     * @name onetrading#cancelAllOrders
     * @description cancel all open orders
     * @see https://docs.onetrading.com/#close-all-orders
     * @param {string} symbol unified market symbol, only orders in the market of this symbol are cancelled when symbol is not undefined
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> cancelAllOrders(object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        if (isTrue(!isEqual(symbol, null)))
        {
            object market = this.market(symbol);
            ((IDictionary<string,object>)request)["instrument_code"] = getValue(market, "id");
        }
        object response = await this.privateDeleteAccountOrders(this.extend(request, parameters));
        //
        //     [
        //         "a10e9bd1-8f72-4cfe-9f1b-7f1c8a9bd8ee"
        //     ]
        //
        return response;
    }

    /**
     * @method
     * @name onetrading#cancelOrders
     * @description cancel multiple orders
     * @see https://docs.onetrading.com/#close-all-orders
     * @param {string[]} ids order ids
     * @param {string} symbol unified market symbol, default is undefined
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} an list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async virtual Task<object> cancelOrders(object ids, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {
            { "ids", String.Join(",", ((IList<object>)ids).ToArray()) },
        };
        object response = await this.privateDeleteAccountOrders(this.extend(request, parameters));
        //
        //     [
        //         "a10e9bd1-8f72-4cfe-9f1b-7f1c8a9bd8ee"
        //     ]
        //
        return response;
    }

    /**
     * @method
     * @name onetrading#fetchOrder
     * @description fetches information on an order made by the user
     * @see https://docs.onetrading.com/#get-order
     * @param {string} id the order id
     * @param {string} symbol not used by onetrading fetchOrder
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> fetchOrder(object id, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {
            { "order_id", id },
        };
        object response = await this.privateGetAccountOrdersOrderId(this.extend(request, parameters));
        //
        //     {
        //         "order": {
        //             "order_id": "36bb2437-7402-4794-bf26-4bdf03526439",
        //             "account_id": "a4c699f6-338d-4a26-941f-8f9853bfc4b9",
        //             "time_last_updated": "2019-09-27T15:05:35.096Z",
        //             "sequence": 48782,
        //             "price": "7349.2",
        //             "filled_amount": "100.0",
        //             "status": "FILLED_FULLY",
        //             "amount": "100.0",
        //             "instrument_code": "BTC_EUR",
        //             "side": "BUY",
        //             "time": "2019-09-27T15:05:32.063Z",
        //             "type": "MARKET"
        //         },
        //         "trades": [
        //             {
        //                 "fee": {
        //                     "fee_amount": "0.0014",
        //                     "fee_currency": "BTC",
        //                     "fee_percentage": "0.1",
        //                     "fee_group_id": "default",
        //                     "fee_type": "TAKER",
        //                     "running_trading_volume": "0.0"
        //                 },
        //                 "trade": {
        //                     "trade_id": "fdff2bcc-37d6-4a2d-92a5-46e09c868664",
        //                     "order_id": "36bb2437-7402-4794-bf26-4bdf03526439",
        //                     "account_id": "a4c699f6-338d-4a26-941f-8f9853bfc4b9",
        //                     "amount": "1.4",
        //                     "side": "BUY",
        //                     "instrument_code": "BTC_EUR",
        //                     "price": "7341.4",
        //                     "time": "2019-09-27T15:05:32.564Z",
        //                     "sequence": 48670
        //                 }
        //             }
        //         ]
        //     }
        //
        return this.parseOrder(response);
    }

    /**
     * @method
     * @name onetrading#fetchOpenOrders
     * @description fetch all unfilled currently open orders
     * @see https://docs.onetrading.com/#get-orders
     * @param {string} symbol unified market symbol
     * @param {int} [since] the earliest time in ms to fetch open orders for
     * @param {int} [limit] the maximum number of  open orders structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> fetchOpenOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            ((IDictionary<string,object>)request)["instrument_code"] = getValue(market, "id");
        }
        if (isTrue(!isEqual(since, null)))
        {
            object to = this.safeString(parameters, "to");
            if (isTrue(isEqual(to, null)))
            {
                throw new ArgumentsRequired ((string)add(this.id, " fetchOpenOrders() requires a \"to\" iso8601 string param with the since argument is specified, max range is 100 days")) ;
            }
            ((IDictionary<string,object>)request)["from"] = this.iso8601(since);
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["max_page_size"] = limit;
        }
        object response = await this.privateGetAccountOrders(this.extend(request, parameters));
        //
        //     {
        //         "order_history": [
        //             {
        //                 "order": {
        //                     "trigger_price": "12089.88",
        //                     "order_id": "d453ca12-c650-46dd-9dee-66910d96bfc0",
        //                     "account_id": "ef3a5f4c-cfcd-415e-ba89-5a9abf47b28a",
        //                     "instrument_code": "BTC_USDT",
        //                     "time": "2019-08-23T10:02:31.663Z",
        //                     "side": "SELL",
        //                     "price": "10159.76",
        //                     "average_price": "10159.76",
        //                     "amount": "0.2",
        //                     "filled_amount": "0.2",
        //                     "type": "STOP",
        //                     "sequence": 8,
        //                     "status": "FILLED_FULLY"
        //                 },
        //                 "trades": [
        //                     {
        //                         "fee": {
        //                             "fee_amount": "0.4188869",
        //                             "fee_currency": "USDT",
        //                             "fee_percentage": "0.1",
        //                             "fee_group_id": "default",
        //                             "fee_type": "TAKER",
        //                             "running_trading_volume": "0.0"
        //                         },
        //                         "trade": {
        //                             "trade_id": "ec82896f-fd1b-4cbb-89df-a9da85ccbb4b",
        //                             "order_id": "d453ca12-c650-46dd-9dee-66910d96bfc0",
        //                             "account_id": "ef3a5f4c-cfcd-415e-ba89-5a9abf47b28a",
        //                             "amount": "0.2",
        //                             "side": "SELL",
        //                             "instrument_code": "BTC_USDT",
        //                             "price": "10159.76",
        //                             "time": "2019-08-23T10:02:32.663Z",
        //                             "sequence": 9
        //                         }
        //                     }
        //                 ]
        //             },
        //             {
        //                 "order": {
        //                     "order_id": "5151a99e-f414-418f-8cf1-2568d0a63ea5",
        //                     "account_id": "ef3a5f4c-cfcd-415e-ba89-5a9abf47b28a",
        //                     "instrument_code": "BTC_USDT",
        //                     "time": "2019-08-23T10:01:36.773Z",
        //                     "side": "SELL",
        //                     "price": "12289.88",
        //                     "amount": "0.5",
        //                     "filled_amount": "0.0",
        //                     "type": "LIMIT",
        //                     "sequence": 7,
        //                     "status": "OPEN"
        //                 },
        //                 "trades": []
        //             },
        //             {
        //                 "order": {
        //                     "order_id": "ac80d857-75e1-4733-9070-fd4288395fdc",
        //                     "account_id": "ef3a5f4c-cfcd-415e-ba89-5a9abf47b28a",
        //                     "instrument_code": "BTC_USDT",
        //                     "time": "2019-08-23T10:01:25.031Z",
        //                     "side": "SELL",
        //                     "price": "11089.88",
        //                     "amount": "0.1",
        //                     "filled_amount": "0.0",
        //                     "type": "LIMIT",
        //                     "sequence": 6,
        //                     "status": "OPEN"
        //                 },
        //                 "trades": []
        //             }
        //         ],
        //         "max_page_size": 100
        //     }
        //
        object orderHistory = this.safeList(response, "order_history", new List<object>() {});
        return this.parseOrders(orderHistory, market, since, limit);
    }

    /**
     * @method
     * @name onetrading#fetchClosedOrders
     * @description fetches information on multiple closed orders made by the user
     * @see https://docs.onetrading.com/#get-orders
     * @param {string} symbol unified market symbol of the market orders were made in
     * @param {int} [since] the earliest time in ms to fetch orders for
     * @param {int} [limit] the maximum number of order structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> fetchClosedOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object request = new Dictionary<string, object>() {
            { "with_cancelled_and_rejected", true },
        };
        return await this.fetchOpenOrders(symbol, since, limit, this.extend(request, parameters));
    }

    /**
     * @method
     * @name onetrading#fetchOrderTrades
     * @description fetch all the trades made from a single order
     * @see https://docs.onetrading.com/#trades-for-order
     * @param {string} id order id
     * @param {string} symbol unified market symbol
     * @param {int} [since] the earliest time in ms to fetch trades for
     * @param {int} [limit] the maximum number of trades to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
     */
    public async override Task<object> fetchOrderTrades(object id, object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {
            { "order_id", id },
        };
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["max_page_size"] = limit;
        }
        object response = await this.privateGetAccountOrdersOrderIdTrades(this.extend(request, parameters));
        //
        //     {
        //         "trade_history": [
        //             {
        //                 "trade": {
        //                     "trade_id": "2b42efcd-d5b7-4a56-8e12-b69ffd68c5ef",
        //                     "order_id": "66756a10-3e86-48f4-9678-b634c4b135b2",
        //                     "account_id": "c2d0076a-c20d-41f8-9e9a-1a1d028b2b58",
        //                     "amount": "1234.5678",
        //                     "side": "BUY",
        //                     "instrument_code": "BTC_EUR",
        //                     "price": "1234.5678",
        //                     "time": "2019-08-24T14:15:22Z",
        //                     "price_tick_sequence": 0,
        //                     "sequence": 123456789
        //                 },
        //                 "fee": {
        //                     "fee_amount": "1234.5678",
        //                     "fee_percentage": "1234.5678",
        //                     "fee_group_id": "default",
        //                     "running_trading_volume": "1234.5678",
        //                     "fee_currency": "BTC",
        //                     "fee_type": "TAKER"
        //                 }
        //             }
        //         ],
        //         "max_page_size": 0,
        //         "cursor": "string"
        //     }
        //
        object tradeHistory = this.safeValue(response, "trade_history", new List<object>() {});
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
        }
        return this.parseTrades(tradeHistory, market, since, limit);
    }

    /**
     * @method
     * @name onetrading#fetchMyTrades
     * @description fetch all trades made by the user
     * @see https://docs.onetrading.com/#all-trades
     * @param {string} symbol unified market symbol
     * @param {int} [since] the earliest time in ms to fetch trades for
     * @param {int} [limit] the maximum number of trades structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
     */
    public async override Task<object> fetchMyTrades(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            ((IDictionary<string,object>)request)["instrument_code"] = getValue(market, "id");
        }
        if (isTrue(!isEqual(since, null)))
        {
            object to = this.safeString(parameters, "to");
            if (isTrue(isEqual(to, null)))
            {
                throw new ArgumentsRequired ((string)add(this.id, " fetchMyTrades() requires a \"to\" iso8601 string param with the since argument is specified, max range is 100 days")) ;
            }
            ((IDictionary<string,object>)request)["from"] = this.iso8601(since);
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["max_page_size"] = limit;
        }
        object response = await this.privateGetAccountTrades(this.extend(request, parameters));
        //
        //     {
        //         "trade_history": [
        //             {
        //                 "trade": {
        //                     "trade_id": "2b42efcd-d5b7-4a56-8e12-b69ffd68c5ef",
        //                     "order_id": "66756a10-3e86-48f4-9678-b634c4b135b2",
        //                     "account_id": "c2d0076a-c20d-41f8-9e9a-1a1d028b2b58",
        //                     "amount": "1234.5678",
        //                     "side": "BUY",
        //                     "instrument_code": "BTC_EUR",
        //                     "price": "1234.5678",
        //                     "time": "2019-08-24T14:15:22Z",
        //                     "price_tick_sequence": 0,
        //                     "sequence": 123456789
        //                 },
        //                 "fee": {
        //                     "fee_amount": "1234.5678",
        //                     "fee_percentage": "1234.5678",
        //                     "fee_group_id": "default",
        //                     "running_trading_volume": "1234.5678",
        //                     "fee_currency": "BTC",
        //                     "fee_type": "TAKER"
        //                 }
        //             }
        //         ],
        //         "max_page_size": 0,
        //         "cursor": "string"
        //     }
        //
        object tradeHistory = this.safeList(response, "trade_history", new List<object>() {});
        return this.parseTrades(tradeHistory, market, since, limit);
    }

    public override object sign(object path, object api = null, object method = null, object parameters = null, object headers = null, object body = null)
    {
        api ??= "public";
        method ??= "GET";
        parameters ??= new Dictionary<string, object>();
        object url = add(add(add(add(getValue(getValue(this.urls, "api"), api), "/"), this.version), "/"), this.implodeParams(path, parameters));
        object query = this.omit(parameters, this.extractParams(path));
        if (isTrue(isEqual(api, "public")))
        {
            if (isTrue(getArrayLength(new List<object>(((IDictionary<string,object>)query).Keys))))
            {
                url = add(url, add("?", this.urlencode(query)));
            }
        } else if (isTrue(isEqual(api, "private")))
        {
            this.checkRequiredCredentials();
            headers = new Dictionary<string, object>() {
                { "Accept", "application/json" },
                { "Authorization", add("Bearer ", this.apiKey) },
            };
            if (isTrue(isEqual(method, "POST")))
            {
                body = this.json(query);
                ((IDictionary<string,object>)headers)["Content-Type"] = "application/json";
            } else
            {
                if (isTrue(getArrayLength(new List<object>(((IDictionary<string,object>)query).Keys))))
                {
                    url = add(url, add("?", this.urlencode(query)));
                }
            }
        }
        return new Dictionary<string, object>() {
            { "url", url },
            { "method", method },
            { "body", body },
            { "headers", headers },
        };
    }

    public override object handleErrors(object code, object reason, object url, object method, object headers, object body, object response, object requestHeaders, object requestBody)
    {
        if (isTrue(isEqual(response, null)))
        {
            return null;
        }
        //
        //     {"error":"MISSING_FROM_PARAM"}
        //     {"error":"MISSING_TO_PARAM"}
        //     {"error":"CANDLESTICKS_TIME_RANGE_TOO_BIG"}
        //
        object message = this.safeString(response, "error");
        if (isTrue(!isEqual(message, null)))
        {
            object feedback = add(add(this.id, " "), body);
            this.throwExactlyMatchedException(getValue(this.exceptions, "exact"), message, feedback);
            this.throwBroadlyMatchedException(getValue(this.exceptions, "broad"), message, feedback);
            throw new ExchangeError ((string)feedback) ;
        }
        return null;
    }
}
