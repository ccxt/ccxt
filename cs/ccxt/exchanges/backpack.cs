namespace ccxt;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

public partial class backpack : Exchange
{
    public override object describe()
    {
        return this.deepExtend(base.describe(), new Dictionary<string, object>() {
            { "id", "backpack" },
            { "name", "Backpack" },
            { "countries", new List<object>() {"JP"} },
            { "rateLimit", 50 },
            { "version", "v1" },
            { "certified", false },
            { "pro", true },
            { "has", new Dictionary<string, object>() {
                { "CORS", null },
                { "spot", true },
                { "margin", true },
                { "swap", true },
                { "future", false },
                { "option", false },
                { "addMargin", false },
                { "cancelAllOrders", true },
                { "cancelAllOrdersAfter", false },
                { "cancelOrder", true },
                { "cancelOrders", false },
                { "cancelWithdraw", false },
                { "closePosition", false },
                { "createConvertTrade", false },
                { "createDepositAddress", false },
                { "createLimitBuyOrder", true },
                { "createLimitOrder", true },
                { "createLimitSellOrder", true },
                { "createMarketBuyOrder", true },
                { "createMarketBuyOrderWithCost", true },
                { "createMarketOrder", true },
                { "createMarketOrderWithCost", true },
                { "createMarketSellOrder", true },
                { "createMarketSellOrderWithCost", true },
                { "createOrder", true },
                { "createOrders", true },
                { "createOrderWithTakeProfitAndStopLoss", true },
                { "createPostOnlyOrder", true },
                { "createReduceOnlyOrder", true },
                { "createStopLossOrder", false },
                { "createTakeProfitOrder", false },
                { "createTrailingAmountOrder", false },
                { "createTrailingPercentOrder", false },
                { "createTriggerOrder", true },
                { "fetchAccounts", false },
                { "fetchBalance", true },
                { "fetchCanceledAndClosedOrders", false },
                { "fetchCanceledOrders", false },
                { "fetchClosedOrder", false },
                { "fetchClosedOrders", false },
                { "fetchConvertCurrencies", false },
                { "fetchConvertQuote", false },
                { "fetchConvertTrade", false },
                { "fetchConvertTradeHistory", false },
                { "fetchCurrencies", true },
                { "fetchDepositAddress", true },
                { "fetchDeposits", true },
                { "fetchDepositsWithdrawals", false },
                { "fetchDepositWithdrawFees", false },
                { "fetchFundingHistory", true },
                { "fetchFundingRate", true },
                { "fetchFundingRateHistory", true },
                { "fetchFundingRates", false },
                { "fetchIndexOHLCV", true },
                { "fetchLedger", false },
                { "fetchLeverage", false },
                { "fetchLeverageTiers", false },
                { "fetchMarginAdjustmentHistory", false },
                { "fetchMarginMode", false },
                { "fetchMarkets", true },
                { "fetchMarkOHLCV", true },
                { "fetchMyTrades", true },
                { "fetchOHLCV", true },
                { "fetchOpenInterest", true },
                { "fetchOpenInterestHistory", true },
                { "fetchOpenOrder", true },
                { "fetchOpenOrders", true },
                { "fetchOrder", false },
                { "fetchOrderBook", true },
                { "fetchOrders", true },
                { "fetchOrderTrades", false },
                { "fetchPosition", false },
                { "fetchPositionHistory", false },
                { "fetchPositionMode", false },
                { "fetchPositions", true },
                { "fetchPositionsForSymbol", false },
                { "fetchPositionsHistory", false },
                { "fetchPremiumIndexOHLCV", false },
                { "fetchStatus", true },
                { "fetchTicker", true },
                { "fetchTickers", true },
                { "fetchTime", true },
                { "fetchTrades", true },
                { "fetchTradingFee", false },
                { "fetchTradingFees", false },
                { "fetchTransactions", false },
                { "fetchTransfers", false },
                { "fetchWithdrawals", true },
                { "reduceMargin", false },
                { "sandbox", false },
                { "setLeverage", false },
                { "setMargin", false },
                { "setMarginMode", false },
                { "setPositionMode", false },
                { "transfer", false },
                { "withdraw", true },
            } },
            { "timeframes", new Dictionary<string, object>() {
                { "1m", "1m" },
                { "3m", "3m" },
                { "5m", "5m" },
                { "15", "15m" },
                { "30", "30m" },
                { "1h", "1h" },
                { "2h", "2h" },
                { "4h", "4h" },
                { "6h", "6h" },
                { "8h", "8h" },
                { "12h", "12h" },
                { "1d", "1d" },
                { "3d", "3d" },
                { "1w", "1w" },
                { "1M", "1month" },
            } },
            { "urls", new Dictionary<string, object>() {
                { "logo", "https://github.com/user-attachments/assets/cc04c278-679f-4554-9f72-930dd632b80f" },
                { "api", new Dictionary<string, object>() {
                    { "public", "https://api.backpack.exchange" },
                    { "private", "https://api.backpack.exchange" },
                } },
                { "www", "https://backpack.exchange/" },
                { "doc", "https://docs.backpack.exchange/" },
                { "referral", "https://backpack.exchange/join/ib8qxwyl" },
            } },
            { "api", new Dictionary<string, object>() {
                { "public", new Dictionary<string, object>() {
                    { "get", new Dictionary<string, object>() {
                        { "api/v1/assets", 1 },
                        { "api/v1/collateral", 1 },
                        { "api/v1/borrowLend/markets", 1 },
                        { "api/v1/borrowLend/markets/history", 1 },
                        { "api/v1/markets", 1 },
                        { "api/v1/market", 1 },
                        { "api/v1/ticker", 1 },
                        { "api/v1/tickers", 1 },
                        { "api/v1/depth", 1 },
                        { "api/v1/klines", 1 },
                        { "api/v1/markPrices", 1 },
                        { "api/v1/openInterest", 1 },
                        { "api/v1/fundingRates", 1 },
                        { "api/v1/status", 1 },
                        { "api/v1/ping", 1 },
                        { "api/v1/time", 1 },
                        { "api/v1/wallets", 1 },
                        { "api/v1/trades", 1 },
                        { "api/v1/trades/history", 1 },
                    } },
                } },
                { "private", new Dictionary<string, object>() {
                    { "get", new Dictionary<string, object>() {
                        { "api/v1/account", 1 },
                        { "api/v1/account/limits/borrow", 1 },
                        { "api/v1/account/limits/order", 1 },
                        { "api/v1/account/limits/withdrawal", 1 },
                        { "api/v1/borrowLend/positions", 1 },
                        { "api/v1/capital", 1 },
                        { "api/v1/capital/collateral", 1 },
                        { "wapi/v1/capital/deposits", 1 },
                        { "wapi/v1/capital/deposit/address", 1 },
                        { "wapi/v1/capital/withdrawals", 1 },
                        { "api/v1/position", 1 },
                        { "wapi/v1/history/borrowLend", 1 },
                        { "wapi/v1/history/interest", 1 },
                        { "wapi/v1/history/borrowLend/positions", 1 },
                        { "wapi/v1/history/dust", 1 },
                        { "wapi/v1/history/fills", 1 },
                        { "wapi/v1/history/funding", 1 },
                        { "wapi/v1/history/orders", 1 },
                        { "wapi/v1/history/rfq", 1 },
                        { "wapi/v1/history/quote", 1 },
                        { "wapi/v1/history/settlement", 1 },
                        { "wapi/v1/history/strategies", 1 },
                        { "api/v1/order", 1 },
                        { "api/v1/orders", 1 },
                    } },
                    { "post", new Dictionary<string, object>() {
                        { "api/v1/account/convertDust", 1 },
                        { "api/v1/borrowLend", 1 },
                        { "wapi/v1/capital/withdrawals", 1 },
                        { "api/v1/order", 1 },
                        { "api/v1/orders", 1 },
                        { "api/v1/rfq", 1 },
                        { "api/v1/rfq/accept", 1 },
                        { "api/v1/rfq/refresh", 1 },
                        { "api/v1/rfq/cancel", 1 },
                        { "api/v1/rfq/quote", 1 },
                    } },
                    { "delete", new Dictionary<string, object>() {
                        { "api/v1/order", 1 },
                        { "api/v1/orders", 1 },
                    } },
                    { "patch", new Dictionary<string, object>() {
                        { "api/v1/account", 1 },
                    } },
                } },
            } },
            { "features", new Dictionary<string, object>() {
                { "default", new Dictionary<string, object>() {
                    { "sandbox", false },
                    { "createOrder", new Dictionary<string, object>() {
                        { "marginMode", false },
                        { "triggerPrice", true },
                        { "triggerPriceType", null },
                        { "triggerDirection", false },
                        { "stopLossPrice", true },
                        { "takeProfitPrice", true },
                        { "attachedStopLossTakeProfit", null },
                        { "timeInForce", new Dictionary<string, object>() {
                            { "GTC", true },
                            { "IOC", true },
                            { "FOK", true },
                            { "PO", true },
                            { "GTD", false },
                        } },
                        { "hedged", false },
                        { "trailing", false },
                        { "leverage", false },
                        { "marketBuyByCost", true },
                        { "marketBuyRequiresPrice", true },
                        { "selfTradePrevention", false },
                        { "iceberg", false },
                    } },
                    { "createOrders", new Dictionary<string, object>() {
                        { "max", 20 },
                    } },
                    { "fetchMyTrades", new Dictionary<string, object>() {
                        { "marginMode", false },
                        { "limit", 1000 },
                        { "daysBack", null },
                        { "untilDays", null },
                        { "symbolRequired", false },
                    } },
                    { "fetchOrder", null },
                    { "fetchOpenOrders", new Dictionary<string, object>() {
                        { "marginMode", false },
                        { "limit", 1000 },
                        { "trigger", true },
                        { "trailing", false },
                        { "symbolRequired", false },
                    } },
                    { "fetchOrders", new Dictionary<string, object>() {
                        { "marginMode", false },
                        { "limit", 1000 },
                        { "daysBack", null },
                        { "untilDays", null },
                        { "trigger", true },
                        { "trailing", false },
                        { "symbolRequired", true },
                    } },
                    { "fetchClosedOrders", null },
                    { "fetchOHLCV", new Dictionary<string, object>() {
                        { "paginate", false },
                        { "limit", 1000 },
                    } },
                } },
                { "spot", new Dictionary<string, object>() {
                    { "extends", "default" },
                } },
                { "swap", new Dictionary<string, object>() {
                    { "linear", null },
                    { "inverse", null },
                } },
                { "future", new Dictionary<string, object>() {
                    { "linear", null },
                    { "inverse", null },
                } },
            } },
            { "requiredCredentials", new Dictionary<string, object>() {
                { "apiKey", true },
                { "secret", true },
            } },
            { "precisionMode", TICK_SIZE },
            { "options", new Dictionary<string, object>() {
                { "instructions", new Dictionary<string, object>() {
                    { "api/v1/account", new Dictionary<string, object>() {
                        { "GET", "accountQuery" },
                        { "PATCH", "accountUpdate" },
                    } },
                    { "api/v1/capital", new Dictionary<string, object>() {
                        { "GET", "balanceQuery" },
                    } },
                    { "api/v1/account/limits/borrow", new Dictionary<string, object>() {
                        { "GET", "maxBorrowQuantity" },
                    } },
                    { "api/v1/account/limits/order", new Dictionary<string, object>() {
                        { "GET", "maxOrderQuantity" },
                    } },
                    { "api/v1/account/limits/withdrawal", new Dictionary<string, object>() {
                        { "GET", "maxWithdrawalQuantity" },
                    } },
                    { "api/v1/borrowLend/positions", new Dictionary<string, object>() {
                        { "GET", "borrowLendPositionQuery" },
                    } },
                    { "api/v1/borrowLend", new Dictionary<string, object>() {
                        { "POST", "borrowLendExecute" },
                    } },
                    { "wapi/v1/history/borrowLend/positions", new Dictionary<string, object>() {
                        { "GET", "borrowPositionHistoryQueryAll" },
                    } },
                    { "wapi/v1/history/borrowLend", new Dictionary<string, object>() {
                        { "GET", "borrowHistoryQueryAll" },
                    } },
                    { "wapi/v1/history/dust", new Dictionary<string, object>() {
                        { "GET", "dustHistoryQueryAll" },
                    } },
                    { "api/v1/capital/collateral", new Dictionary<string, object>() {
                        { "GET", "collateralQuery" },
                    } },
                    { "wapi/v1/capital/deposit/address", new Dictionary<string, object>() {
                        { "GET", "depositAddressQuery" },
                    } },
                    { "wapi/v1/capital/deposits", new Dictionary<string, object>() {
                        { "GET", "depositQueryAll" },
                    } },
                    { "wapi/v1/history/fills", new Dictionary<string, object>() {
                        { "GET", "fillHistoryQueryAll" },
                    } },
                    { "wapi/v1/history/funding", new Dictionary<string, object>() {
                        { "GET", "fundingHistoryQueryAll" },
                    } },
                    { "wapi/v1/history/interest", new Dictionary<string, object>() {
                        { "GET", "interestHistoryQueryAll" },
                    } },
                    { "api/v1/order", new Dictionary<string, object>() {
                        { "GET", "orderQuery" },
                        { "POST", "orderExecute" },
                        { "DELETE", "orderCancel" },
                    } },
                    { "api/v1/orders", new Dictionary<string, object>() {
                        { "GET", "orderQueryAll" },
                        { "POST", "orderExecute" },
                        { "DELETE", "orderCancelAll" },
                    } },
                    { "wapi/v1/history/orders", new Dictionary<string, object>() {
                        { "GET", "orderHistoryQueryAll" },
                    } },
                    { "wapi/v1/history/pnl", new Dictionary<string, object>() {
                        { "GET", "pnlHistoryQueryAll" },
                    } },
                    { "wapi/v1/history/rfq", new Dictionary<string, object>() {
                        { "GET", "rfqHistoryQueryAll" },
                    } },
                    { "wapi/v1/history/quote", new Dictionary<string, object>() {
                        { "GET", "quoteHistoryQueryAll" },
                    } },
                    { "wapi/v1/history/settlement", new Dictionary<string, object>() {
                        { "GET", "settlementHistoryQueryAll" },
                    } },
                    { "api/v1/position", new Dictionary<string, object>() {
                        { "GET", "positionQuery" },
                    } },
                    { "api/v1/rfq/quote", new Dictionary<string, object>() {
                        { "POST", "quoteSubmit" },
                    } },
                    { "wapi/v1/history/strategies", new Dictionary<string, object>() {
                        { "GET", "strategyHistoryQueryAll" },
                    } },
                    { "wapi/v1/capital/withdrawals", new Dictionary<string, object>() {
                        { "GET", "withdrawalQueryAll" },
                        { "POST", "withdraw" },
                    } },
                } },
                { "recvWindow", 5000 },
                { "brokerId", "" },
                { "currencyIdsListForParseMarket", null },
                { "broker", "" },
                { "timeDifference", 0 },
                { "adjustForTimeDifference", false },
                { "networks", new Dictionary<string, object>() {
                    { "APT", "Aptos" },
                    { "ARB", "Arbitrum" },
                    { "AVAX", "Avalanche" },
                    { "BASE", "Base" },
                    { "BERA", "Berachain" },
                    { "BTC", "Bitcoin" },
                    { "BCH", "BitcoinCash" },
                    { "BSC", "Bsc" },
                    { "ADA", "Cardano" },
                    { "DOGE", "Dogecoin" },
                    { "ECLIPSE", "Eclipse" },
                    { "EQUALSMONEY", "EqualsMoney" },
                    { "ERC20", "Ethereum" },
                    { "HYP", "Hyperliquid" },
                    { "LTC", "Litecoin" },
                    { "OPTIMISM", "Optimism" },
                    { "MATIC", "Polygon" },
                    { "SEI", "Sei" },
                    { "SUI", "Sui" },
                    { "SOL", "Solana" },
                    { "STORY", "Story" },
                    { "TRC20", "Tron" },
                    { "XRP", "XRP" },
                } },
                { "networksById", new Dictionary<string, object>() {
                    { "aptos", "APT" },
                    { "arbitrum", "ARB" },
                    { "avalanche", "AVAX" },
                    { "base", "BASE" },
                    { "berachain", "BERA" },
                    { "bitcoin", "BTC" },
                    { "bitcoincash", "BCH" },
                    { "bsc", "BSC" },
                    { "cardano", "ADA" },
                    { "dogecoin", "DOGE" },
                    { "eclipse", "ECLIPSE" },
                    { "equalsmoney", "EQUALSMONEY" },
                    { "ethereum", "ERC20" },
                    { "hyperliquid", "HYP" },
                    { "litecoin", "LTC" },
                    { "optimism", "OPTIMISM" },
                    { "polygon", "MATIC" },
                    { "sei", "SEI" },
                    { "sui", "SUI" },
                    { "solana", "SOL" },
                    { "story", "STORY" },
                    { "tron", "TRC20" },
                    { "xrp", "XRP" },
                } },
            } },
            { "commonCurrencies", new Dictionary<string, object>() {} },
            { "exceptions", new Dictionary<string, object>() {
                { "exact", new Dictionary<string, object>() {
                    { "INVALID_CLIENT_REQUEST", typeof(BadRequest) },
                    { "INVALID_ORDER", typeof(InvalidOrder) },
                    { "ACCOUNT_LIQUIDATING", typeof(BadRequest) },
                    { "BORROW_LIMIT", typeof(BadRequest) },
                    { "BORROW_REQUIRES_LEND_REDEEM", typeof(BadRequest) },
                    { "FORBIDDEN", typeof(OperationRejected) },
                    { "INSUFFICIENT_FUNDS", typeof(InsufficientFunds) },
                    { "INSUFFICIENT_MARGIN", typeof(InsufficientFunds) },
                    { "INSUFFICIENT_SUPPLY", typeof(InsufficientFunds) },
                    { "INVALID_ASSET", typeof(BadRequest) },
                    { "INVALID_MARKET", typeof(BadSymbol) },
                    { "INVALID_PRICE", typeof(BadRequest) },
                    { "INVALID_POSITION_ID", typeof(BadRequest) },
                    { "INVALID_QUANTITY", typeof(BadRequest) },
                    { "INVALID_RANGE", typeof(BadRequest) },
                    { "INVALID_SIGNATURE", typeof(AuthenticationError) },
                    { "INVALID_SOURCE", typeof(BadRequest) },
                    { "INVALID_SYMBOL", typeof(BadSymbol) },
                    { "INVALID_TWO_FACTOR_CODE", typeof(BadRequest) },
                    { "LEND_LIMIT", typeof(BadRequest) },
                    { "LEND_REQUIRES_BORROW_REPAY", typeof(BadRequest) },
                    { "MAINTENANCE", typeof(ExchangeError) },
                    { "MAX_LEVERAGE_REACHED", typeof(InsufficientFunds) },
                    { "NOT_IMPLEMENTED", typeof(OperationFailed) },
                    { "ORDER_LIMIT", typeof(OperationRejected) },
                    { "POSITION_LIMIT", typeof(OperationRejected) },
                    { "PRECONDITION_FAILED", typeof(OperationFailed) },
                    { "RESOURCE_NOT_FOUND", typeof(ExchangeNotAvailable) },
                    { "SERVER_ERROR", typeof(NetworkError) },
                    { "TIMEOUT", typeof(RequestTimeout) },
                    { "TOO_MANY_REQUESTS", typeof(RateLimitExceeded) },
                    { "TRADING_PAUSED", typeof(ExchangeNotAvailable) },
                    { "UNAUTHORIZED", typeof(AuthenticationError) },
                } },
                { "broad", new Dictionary<string, object>() {} },
            } },
        });
    }

    /**
     * @method
     * @name backpack#fetchCurrencies
     * @description fetches all available currencies on an exchange
     * @see https://docs.backpack.exchange/#tag/Assets
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} an associative dictionary of currencies
     */
    public async override Task<object> fetchCurrencies(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object response = await this.publicGetApiV1Assets(parameters);
        //
        //     [
        //         {
        //             "coingeckoId": "jito-governance-token",
        //             "displayName": "Jito",
        //             "symbol": "JTO",
        //             "tokens": [
        //                 {
        //                     "blockchain": "Solana",
        //                     "contractAddress": "jtojtomepa8beP8AuQc6eXt5FriJwfFMwQx2v2f9mCL",
        //                     "depositEnabled": true,
        //                     "displayName": "Jito",
        //                     "maximumWithdrawal": null,
        //                     "minimumDeposit": "0.29",
        //                     "minimumWithdrawal": "0.58",
        //                     "withdrawEnabled": true,
        //                     "withdrawalFee": "0.29"
        //                 }
        //             ]
        //         }
        //         ...
        //     ]
        //
        object result = new Dictionary<string, object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(response)); postFixIncrement(ref i))
        {
            object currecy = getValue(response, i);
            object currencyId = this.safeString(currecy, "symbol");
            object code = this.safeCurrencyCode(currencyId);
            object networks = this.safeList(currecy, "tokens", new List<object>() {});
            object parsedNetworks = new Dictionary<string, object>() {};
            for (object j = 0; isLessThan(j, getArrayLength(networks)); postFixIncrement(ref j))
            {
                object network = getValue(networks, j);
                object networkId = this.safeString(network, "blockchain");
                object networkIdLowerCase = this.safeStringLower(network, "blockchain");
                object networkCode = this.networkIdToCode(networkIdLowerCase);
                ((IDictionary<string,object>)parsedNetworks)[(string)networkCode] = new Dictionary<string, object>() {
                    { "id", networkId },
                    { "network", networkCode },
                    { "limits", new Dictionary<string, object>() {
                        { "withdraw", new Dictionary<string, object>() {
                            { "min", this.safeNumber(network, "minimumWithdrawal") },
                            { "max", this.parseNumber(this.omitZero(this.safeString(network, "maximumWithdrawal"))) },
                        } },
                        { "deposit", new Dictionary<string, object>() {
                            { "min", this.safeNumber(network, "minimumDeposit") },
                            { "max", null },
                        } },
                    } },
                    { "active", null },
                    { "deposit", this.safeBool(network, "depositEnabled") },
                    { "withdraw", this.safeBool(network, "withdrawEnabled") },
                    { "fee", this.safeNumber(network, "withdrawalFee") },
                    { "precision", null },
                    { "info", network },
                };
            }
            object active = null;
            object deposit = null;
            object withdraw = null;
            if (isTrue(this.isEmpty(parsedNetworks)))
            {
                active = false;
                deposit = false;
                withdraw = false;
            }
            ((IDictionary<string,object>)result)[(string)code] = this.safeCurrencyStructure(new Dictionary<string, object>() {
                { "id", currencyId },
                { "code", code },
                { "precision", null },
                { "type", "crypto" },
                { "name", this.safeString(currecy, "displayName") },
                { "active", active },
                { "deposit", deposit },
                { "withdraw", withdraw },
                { "fee", null },
                { "limits", new Dictionary<string, object>() {
                    { "deposit", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                    { "withdraw", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                } },
                { "networks", parsedNetworks },
                { "info", currecy },
            });
        }
        return result;
    }

    /**
     * @method
     * @name backpack#fetchMarkets
     * @description retrieves data on all markets for bitbank
     * @see https://docs.backpack.exchange/#tag/Markets/operation/get_markets
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} an array of objects representing market data
     */
    public async override Task<object> fetchMarkets(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (isTrue(getValue(this.options, "adjustForTimeDifference")))
        {
            await this.loadTimeDifference();
        }
        object response = await this.publicGetApiV1Markets(parameters);
        return this.parseMarkets(response);
    }

    public override object parseMarket(object market)
    {
        //
        //     [
        //         {
        //             "baseSymbol": "SOL",
        //             "createdAt": "2025-01-21T06:34:54.691858",
        //             "filters": {
        //                 "price": {
        //                     "borrowmarketFeeMaxMultiplier": null,
        //                     "borrowmarketFeeMinMultiplier": null,
        //                     "maxImpactMultiplier": "1.03",
        //                     "maxMultiplier": "1.25",
        //                     "maxPrice": null,
        //                     "meanMarkPriceBand": {
        //                         "maxMultiplier": "1.15",
        //                         "minMultiplier": "0.9"
        //                     },
        //                     "meanPremiumBand": null,
        //                     "minImpactMultiplier": "0.97",
        //                     "minMultiplier": "0.75",
        //                     "minPrice": "0.01",
        //                     "tickSize": "0.01"
        //                 },
        //                 "quantity": {
        //                     "maxQuantity": null,
        //                     "minQuantity": "0.01",
        //                     "stepSize": "0.01"
        //                 }
        //             },
        //             "fundingInterval": 28800000,
        //             "fundingRateLowerBound": null,
        //             "fundingRateUpperBound": null,
        //             "imfFunction": null,
        //             "marketType": "SPOT",
        //             "mmfFunction": null,
        //             "openInterestLimit": "0",
        //             "orderBookState": "Open",
        //             "quoteSymbol": "USDC",
        //             "symbol": "SOL_USDC"
        //         },
        //         {
        //             "baseSymbol": "SOL",
        //             "createdAt": "2025-01-21T06:34:54.691858",
        //             "filters": {
        //                 "price": {
        //                     "borrowEntryFeeMaxMultiplier": null,
        //                     "borrowEntryFeeMinMultiplier": null,
        //                     "maxImpactMultiplier": "1.03",
        //                     "maxMultiplier": "1.25",
        //                     "maxPrice": "1000",
        //                     "meanMarkPriceBand": {
        //                         "maxMultiplier": "1.1",
        //                         "minMultiplier": "0.9"
        //                     },
        //                     "meanPremiumBand": {
        //                         "tolerancePct": "0.05"
        //                     },
        //                     "minImpactMultiplier": "0.97",
        //                     "minMultiplier": "0.75",
        //                     "minPrice": "0.01",
        //                     "tickSize": "0.01"
        //                 },
        //                 "quantity": {
        //                     "maxQuantity": null,
        //                     "minQuantity": "0.01",
        //                     "stepSize": "0.01"
        //                 }
        //             },
        //             "fundingInterval": "28800000",
        //             "fundingRateLowerBound": "-100",
        //             "fundingRateUpperBound": "100",
        //             "imfFunction": {
        //                 "base": "0.02",
        //                 "factor": "0.0001275",
        //                 "type": "sqrt"
        //             },
        //             "marketType": "PERP",
        //             "mmfFunction": {
        //                 "base": "0.0125",
        //                 "factor": "0.0000765",
        //                 "type": "sqrt"
        //             },
        //             "openInterestLimit": "4000000",
        //             "orderBookState": "Open",
        //             "quoteSymbol": "USDC",
        //             "symbol": "SOL_USDC_PERP"
        //         }
        //     ]
        //
        object id = this.safeString(market, "symbol");
        object baseId = this.safeString(market, "baseSymbol");
        object quoteId = this.safeString(market, "quoteSymbol");
        object bs = this.safeCurrencyCode(baseId);
        object quote = this.safeCurrencyCode(quoteId);
        object symbol = add(add(bs, "/"), quote);
        object filters = this.safeDict(market, "filters", new Dictionary<string, object>() {});
        object priceFilter = this.safeDict(filters, "price", new Dictionary<string, object>() {});
        object maxPrice = this.safeNumber(priceFilter, "maxPrice");
        object minPrice = this.safeNumber(priceFilter, "minPrice");
        object pricePrecision = this.safeNumber(priceFilter, "tickSize");
        object quantityFilter = this.safeDict(filters, "quantity", new Dictionary<string, object>() {});
        object maxQuantity = this.safeNumber(quantityFilter, "maxQuantity");
        object minQuantity = this.safeNumber(quantityFilter, "minQuantity");
        object amountPrecision = this.safeNumber(quantityFilter, "stepSize");
        object type = null;
        object typeOfMarket = this.parseMarketType(this.safeString(market, "marketType"));
        object linear = null;
        object inverse = null;
        object settle = null;
        object settleId = null;
        object contractSize = null;
        if (isTrue(isEqual(typeOfMarket, "spot")))
        {
            type = "spot";
        } else if (isTrue(isEqual(typeOfMarket, "swap")))
        {
            type = "swap";
            linear = true;
            inverse = false;
            settleId = this.safeString(market, "quoteSymbol");
            settle = this.safeCurrencyCode(settleId);
            symbol = add(symbol, add(":", settle));
            contractSize = 1;
        }
        object orderBookState = this.safeString(market, "orderBookState");
        return this.safeMarketStructure(new Dictionary<string, object>() {
            { "id", id },
            { "symbol", symbol },
            { "base", bs },
            { "quote", quote },
            { "settle", settle },
            { "baseId", baseId },
            { "quoteId", quoteId },
            { "settleId", settleId },
            { "type", type },
            { "spot", isEqual(type, "spot") },
            { "margin", isEqual(type, "spot") },
            { "swap", isEqual(type, "swap") },
            { "future", false },
            { "option", false },
            { "active", isEqual(orderBookState, "Open") },
            { "contract", !isEqual(type, "spot") },
            { "linear", linear },
            { "inverse", inverse },
            { "taker", null },
            { "maker", null },
            { "contractSize", contractSize },
            { "expiry", null },
            { "expiryDatetime", null },
            { "strike", null },
            { "optionType", null },
            { "precision", new Dictionary<string, object>() {
                { "amount", amountPrecision },
                { "price", pricePrecision },
            } },
            { "limits", new Dictionary<string, object>() {
                { "leverage", new Dictionary<string, object>() {
                    { "min", null },
                    { "max", null },
                } },
                { "amount", new Dictionary<string, object>() {
                    { "min", minQuantity },
                    { "max", maxQuantity },
                } },
                { "price", new Dictionary<string, object>() {
                    { "min", minPrice },
                    { "max", maxPrice },
                } },
                { "cost", new Dictionary<string, object>() {
                    { "min", null },
                    { "max", null },
                } },
            } },
            { "created", this.parse8601(this.safeString(market, "createdAt")) },
            { "info", market },
        });
    }

    public virtual object parseMarketType(object type)
    {
        object types = new Dictionary<string, object>() {
            { "SPOT", "spot" },
            { "PERP", "swap" },
        };
        return this.safeString(types, type, type);
    }

    /**
     * @method
     * @name backpack#fetchTickers
     * @see https://docs.backpack.exchange/#tag/Markets/operation/get_tickers
     * @description fetches price tickers for multiple markets, statistical information calculated over the past 24 hours for each market
     * @param {string[]|undefined} symbols unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/#/?id=ticker-structure}
     */
    public async override Task<object> fetchTickers(object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object response = await this.publicGetApiV1Tickers(this.extend(request, parameters));
        object tickers = this.parseTickers(response);
        return this.filterByArrayTickers(tickers, "symbol", symbols);
    }

    /**
     * @method
     * @name backpack#fetchTicker
     * @description fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
     * @see https://docs.backpack.exchange/#tag/Markets/operation/get_ticker
     * @param {string} symbol unified symbol of the market to fetch the ticker for
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
     */
    public async override Task<object> fetchTicker(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object response = await this.publicGetApiV1Ticker(this.extend(request, parameters));
        return this.parseTicker(response, market);
    }

    public override object parseTicker(object ticker, object market = null)
    {
        //
        // fetchTicker/fetchTickers
        //
        //     {
        //         "firstPrice": "327.38",
        //         "high": "337.99",
        //         "lastPrice": "317.14",
        //         "low": "300.01",
        //         "priceChange": "-10.24",
        //         "priceChangePercent": "-0.031279",
        //         "quoteVolume": "21584.32278",
        //         "symbol": "AAVE_USDC",
        //         "trades": "245",
        //         "volume": "65.823"
        //     }, ...
        //
        object marketId = this.safeString(ticker, "symbol");
        market = this.safeMarket(marketId, market);
        object symbol = this.safeSymbol(marketId, market);
        object open = this.safeString(ticker, "firstPrice");
        object last = this.safeString(ticker, "lastPrice");
        object high = this.safeString(ticker, "high");
        object low = this.safeString(ticker, "low");
        object baseVolume = this.safeString(ticker, "volume");
        object quoteVolume = this.safeString(ticker, "quoteVolume");
        object percentage = this.safeString(ticker, "priceChangePercent");
        object change = this.safeString(ticker, "priceChange");
        return this.safeTicker(new Dictionary<string, object>() {
            { "symbol", symbol },
            { "timestamp", null },
            { "datetime", null },
            { "high", high },
            { "low", low },
            { "bid", null },
            { "bidVolume", null },
            { "ask", null },
            { "askVolume", null },
            { "vwap", null },
            { "open", open },
            { "close", last },
            { "last", last },
            { "previousClose", null },
            { "change", change },
            { "percentage", percentage },
            { "average", null },
            { "baseVolume", baseVolume },
            { "quoteVolume", quoteVolume },
            { "markPrice", null },
            { "indexPrice", null },
            { "info", ticker },
        }, market);
    }

    /**
     * @method
     * @name backpack#fetchOrderBook
     * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
     * @see https://docs.backpack.exchange/#tag/Markets/operation/get_depth
     * @param {string} symbol unified symbol of the market to fetch the order book for
     * @param {int} [limit] the maximum amount of order book entries to return (default 100, max 200)
     * @param {object} [params] extra parameters specific to the bitteam api endpoint
     * @returns {object} A dictionary of [order book structures]{@link https://github.com/ccxt/ccxt/wiki/Manual#order-book-structure} indexed by market symbols
     */
    public async override Task<object> fetchOrderBook(object symbol, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object response = await this.publicGetApiV1Depth(this.extend(request, parameters));
        //
        //     {
        //         "asks": [
        //             ["118318.3","0.00633"],
        //             ["118567.2","0.08450"]
        //         ],
        //         "bids": [
        //             ["1.0","0.38647"],
        //             ["12.9","1.00000"]
        //         ],
        //         "lastUpdateId":"1504999670",
        //         "timestamp":1753102447307501
        //     }
        //
        object microseconds = this.safeInteger(response, "timestamp");
        object timestamp = this.parseToInt(divide(microseconds, 1000));
        object orderbook = this.parseOrderBook(response, symbol, timestamp);
        ((IDictionary<string,object>)orderbook)["nonce"] = this.safeInteger(response, "lastUpdateId");
        return orderbook;
    }

    /**
     * @method
     * @name backpack#fetchOHLCV
     * @description fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
     * @see https://docs.backpack.exchange/#tag/Markets/operation/get_klines
     * @param {string} symbol unified symbol of the market to fetch OHLCV data for
     * @param {string} timeframe the length of time each candle represents
     * @param {int} [since] timestamp in seconds of the earliest candle to fetch
     * @param {int} [limit] the maximum amount of candles to fetch (default 100)
     * @param {object} [params] extra parameters specific to the bitteam api endpoint
     * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
     */
    public async override Task<object> fetchOHLCV(object symbol, object timeframe = null, object since = null, object limit = null, object parameters = null)
    {
        timeframe ??= "1m";
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object interval = this.safeString(this.timeframes, timeframe, timeframe);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
            { "interval", interval },
        };
        object until = null;
        var untilparametersVariable = this.handleOptionAndParams(parameters, "fetchOHLCV", "until");
        until = ((IList<object>)untilparametersVariable)[0];
        parameters = ((IList<object>)untilparametersVariable)[1];
        if (isTrue(!isEqual(until, null)))
        {
            ((IDictionary<string,object>)request)["endTime"] = this.parseToInt(divide(until, 1000)); // convert milliseconds to seconds
        }
        object defaultLimit = 100;
        if (isTrue(isEqual(since, null)))
        {
            if (isTrue(isEqual(limit, null)))
            {
                limit = defaultLimit;
            }
            object duration = this.parseTimeframe(timeframe);
            object endTime = ((bool) isTrue(until)) ? this.parseToInt(divide(until, 1000)) : this.seconds();
            object startTime = subtract(endTime, (multiply(limit, duration)));
            ((IDictionary<string,object>)request)["startTime"] = startTime;
        } else
        {
            ((IDictionary<string,object>)request)["startTime"] = this.parseToInt(divide(since, 1000)); // convert milliseconds to seconds
        }
        object price = this.safeString(parameters, "price");
        if (isTrue(!isEqual(price, null)))
        {
            ((IDictionary<string,object>)request)["priceType"] = this.capitalize(price);
            parameters = this.omit(parameters, "price");
        }
        object response = await this.publicGetApiV1Klines(this.extend(request, parameters));
        return this.parseOHLCVs(response, market, timeframe, since, limit);
    }

    public override object parseOHLCV(object ohlcv, object market = null)
    {
        //
        //     [
        //         {
        //             "close": "118294.6",
        //             "end": "2025-07-19 13:12:00",
        //             "high": "118297.6",
        //             "low": "118237.5",
        //             "open": "118238",
        //             "quoteVolume": "4106.558156",
        //             "start": "2025-07-19 13:09:00",
        //             "trades": "12",
        //             "volume": "0.03473"
        //         },
        //         ...
        //     ]
        //
        return new List<object> {this.parse8601(this.safeString(ohlcv, "start")), this.safeNumber(ohlcv, "open"), this.safeNumber(ohlcv, "high"), this.safeNumber(ohlcv, "low"), this.safeNumber(ohlcv, "close"), this.safeNumber(ohlcv, "volume")};
    }

    /**
     * @method
     * @name backpack#fetchFundingRate
     * @description fetch the current funding rate
     * @see https://docs.backpack.exchange/#tag/Markets/operation/get_mark_prices
     * @param {string} symbol unified market symbol
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [funding rate structure]{@link https://docs.ccxt.com/#/?id=funding-rate-structure}
     */
    public async override Task<object> fetchFundingRate(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        if (isTrue(getValue(market, "spot")))
        {
            throw new BadRequest ((string)add(add(this.id, " fetchFundingRate() symbol does not support market "), symbol)) ;
        }
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object response = await this.publicGetApiV1MarkPrices(this.extend(request, parameters));
        object data = this.safeDict(response, 0, new Dictionary<string, object>() {});
        return this.parseFundingRate(data, market);
    }

    public override object parseFundingRate(object contract, object market = null)
    {
        //
        //     {
        //         "fundingRate": "0.0001",
        //         "indexPrice": "118333.18643195",
        //         "markPrice": "118343.51853741",
        //         "nextFundingTimestamp": 1753113600000,
        //         "symbol": "BTC_USDC_PERP"
        //     }
        //
        object marketId = this.safeString(contract, "symbol");
        market = this.safeMarket(marketId, market);
        object symbol = this.safeSymbol(marketId, market);
        object nextFundingTimestamp = this.safeInteger(contract, "nextFundingTimestamp");
        return new Dictionary<string, object>() {
            { "info", contract },
            { "symbol", symbol },
            { "markPrice", this.safeNumber(contract, "markPrice") },
            { "indexPrice", this.safeNumber(contract, "indexPrice") },
            { "interestRate", null },
            { "estimatedSettlePrice", null },
            { "timestamp", null },
            { "datetime", null },
            { "fundingRate", this.safeNumber(contract, "fundingRate") },
            { "fundingTimestamp", null },
            { "fundingDatetime", null },
            { "nextFundingRate", null },
            { "nextFundingTimestamp", nextFundingTimestamp },
            { "nextFundingDatetime", this.iso8601(nextFundingTimestamp) },
            { "previousFundingRate", null },
            { "previousFundingTimestamp", null },
            { "previousFundingDatetime", null },
            { "interval", "1h" },
        };
    }

    /**
     * @method
     * @name backpack#fetchOpenInterest
     * @description Retrieves the open interest of a derivative trading pair
     * @see https://docs.backpack.exchange/#tag/Markets/operation/get_open_interest
     * @param {string} symbol Unified CCXT market symbol
     * @param {object} [params] exchange specific parameters
     * @returns {object} an open interest structure{@link https://docs.ccxt.com/#/?id=interest-history-structure}
     */
    public async override Task<object> fetchOpenInterest(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        if (isTrue(getValue(market, "spot")))
        {
            throw new BadRequest ((string)add(add(this.id, " fetchOpenInterest() symbol does not support market "), symbol)) ;
        }
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object response = await this.publicGetApiV1OpenInterest(this.extend(request, parameters));
        object interest = this.safeDict(response, 0, new Dictionary<string, object>() {});
        return this.parseOpenInterest(interest, market);
    }

    public override object parseOpenInterest(object interest, object market = null)
    {
        //
        //     [
        //         {
        //             "openInterest": "1273.85214",
        //             "symbol": "BTC_USDC_PERP",
        //             "timestamp":1753105735301
        //         }
        //     ]
        //
        object timestamp = this.safeInteger(interest, "timestamp");
        object openInterest = this.safeNumber(interest, "openInterest");
        return this.safeOpenInterest(new Dictionary<string, object>() {
            { "symbol", getValue(market, "symbol") },
            { "openInterestAmount", null },
            { "openInterestValue", openInterest },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "info", interest },
        }, market);
    }

    /**
     * @method
     * @name backpack#fetchFundingRateHistory
     * @description fetches historical funding rate prices
     * @see https://docs.backpack.exchange/#tag/Markets/operation/get_funding_interval_rates
     * @param {string} symbol unified symbol of the market to fetch the funding rate history for
     * @param {int} [since] timestamp in ms of the earliest funding rate to fetch
     * @param {int} [limit] the maximum amount of funding rate structures
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} a list of [funding rate structures]{@link https://docs.ccxt.com/#/?id=funding-rate-history-structure}
     */
    public async override Task<object> fetchFundingRateHistory(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchFundingRateHistory() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = mathMin(limit, 1000); // api maximum 1000
        }
        object response = await this.publicGetApiV1FundingRates(this.extend(request, parameters));
        //
        //     [
        //         {
        //             "fundingRate": "0.0001",
        //             "intervalEndTimestamp": "2025-07-22T00:00:00",
        //             "symbol": "BTC_USDC_PERP"
        //         }
        //     ]
        //
        object rates = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(response)); postFixIncrement(ref i))
        {
            object rate = getValue(response, i);
            object datetime = this.safeString(rate, "intervalEndTimestamp");
            object timestamp = this.parse8601(datetime);
            ((IList<object>)rates).Add(new Dictionary<string, object>() {
                { "info", rate },
                { "symbol", getValue(market, "symbol") },
                { "fundingRate", this.safeNumber(rate, "fundingRate") },
                { "timestamp", timestamp },
                { "datetime", datetime },
            });
        }
        object sorted = this.sortBy(rates, "timestamp");
        return this.filterBySymbolSinceLimit(sorted, getValue(market, "symbol"), since, limit);
    }

    /**
     * @method
     * @name backpack#fetchTrades
     * @description get the list of most recent trades for a particular symbol
     * @see https://docs.backpack.exchange/#tag/Trades/operation/get_recent_trades
     * @see https://docs.backpack.exchange/#tag/Trades/operation/get_historical_trades
     * @param {string} symbol unified symbol of the market to fetch trades for
     * @param {int} [since] timestamp in ms of the earliest trade to fetch
     * @param {int} [limit] the maximum amount of trades to fetch
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {int} [params.offset] the number of trades to skip, default is 0
     * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
     */
    public async override Task<object> fetchTrades(object symbol, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = mathMin(limit, 1000); // api maximum 1000
        }
        object response = null;
        object offset = this.safeInteger(parameters, "offset");
        if (isTrue(!isEqual(offset, null)))
        {
            response = await this.publicGetApiV1TradesHistory(this.extend(request, parameters));
        } else
        {
            response = await this.publicGetApiV1Trades(this.extend(request, parameters));
        }
        return this.parseTrades(response, market, since, limit);
    }

    /**
     * @method
     * @name backpack#fetchMyTrades
     * @description fetch all trades made by the user
     * @see https://docs.backpack.exchange/#tag/History/operation/get_fills
     * @param {string} symbol unified market symbol
     * @param {int} [since] the earliest time in ms to fetch trades for
     * @param {int} [limit] the maximum number of trades structures to retrieve (default 100, max 1000)
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {int} [params.until] the latest time in ms to fetch trades for
     * @param {string} [params.fillType] 'User' (default) 'BookLiquidation' or 'Adl' or 'Backstop' or 'Liquidation' or 'AllLiquidation' or 'CollateralConversion' or 'CollateralConversionAndSpotLiquidation'
     * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
     */
    public async override Task<object> fetchMyTrades(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["from"] = since;
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        object until = this.safeInteger(parameters, "until");
        if (isTrue(!isEqual(until, null)))
        {
            parameters = this.omit(parameters, new List<object>() {"until"});
            ((IDictionary<string,object>)request)["to"] = until;
        }
        object fillType = this.safeString(parameters, "fillType");
        if (isTrue(isEqual(fillType, null)))
        {
            ((IDictionary<string,object>)request)["fillType"] = "User"; // default
        }
        object response = await this.privateGetWapiV1HistoryFills(this.extend(request, parameters));
        return this.parseTrades(response, market, since, limit);
    }

    public override object parseTrade(object trade, object market = null)
    {
        //
        // fetchTrades
        //     {
        //         "id": 8721564,
        //         "isBuyerMaker": false,
        //         "price": "117427.6",
        //         "quantity": "0.00016",
        //         "quoteQuantity": "18.788416",
        //         "timestamp": 1753123916818
        //     }
        //
        // fetchMyTrades
        //     {
        //         "clientId": null,
        //         "fee": "0.004974",
        //         "feeSymbol": "USDC",
        //         "isMaker": false,
        //         "orderId": "4238907375",
        //         "price": "3826.15",
        //         "quantity": "0.0026",
        //         "side": "Bid",
        //         "symbol": "ETH_USDC_PERP",
        //         "systemOrderType": null,
        //         "timestamp": "2025-07-27T17:39:00.092",
        //         "tradeId": 9748827
        //     }
        //
        object id = this.safeString2(trade, "id", "tradeId");
        object marketId = this.safeString(trade, "symbol");
        market = this.safeMarket(marketId, market);
        object price = this.safeString(trade, "price");
        object amount = this.safeString(trade, "quantity");
        object isMaker = this.safeBool(trade, "isMaker");
        object takerOrMaker = ((bool) isTrue(isMaker)) ? "maker" : "taker";
        object orderId = this.safeString(trade, "orderId");
        object side = this.parseOrderSide(this.safeString(trade, "side"));
        object fee = null;
        object feeAmount = this.safeString(trade, "fee");
        object timestamp = this.safeInteger(trade, "timestamp");
        if (isTrue(!isEqual(feeAmount, null)))
        {
            // if fetchMyTrades
            object datetime = this.safeString(trade, "timestamp");
            timestamp = this.parse8601(datetime);
        }
        object feeSymbol = this.safeCurrencyCode(this.safeString(trade, "feeSymbol"));
        if (isTrue(!isEqual(feeAmount, null)))
        {
            fee = new Dictionary<string, object>() {
                { "cost", feeAmount },
                { "currency", feeSymbol },
                { "rate", null },
            };
        }
        return this.safeTrade(new Dictionary<string, object>() {
            { "info", trade },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "symbol", getValue(market, "symbol") },
            { "id", id },
            { "order", orderId },
            { "type", null },
            { "side", side },
            { "takerOrMaker", takerOrMaker },
            { "price", price },
            { "amount", amount },
            { "cost", null },
            { "fee", fee },
        }, market);
    }

    /**
     * @method
     * @name backpack#fetchStatus
     * @description the latest known information on the availability of the exchange API
     * @see https://docs.backpack.exchange/#tag/System/operation/get_status
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [status structure]{@link https://docs.ccxt.com/#/?id=exchange-status-structure}
     */
    public async override Task<object> fetchStatus(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object response = await this.publicGetApiV1Status(parameters);
        //
        //     {
        //         "message":null,
        //         "status":"Ok"
        //     }
        //
        object status = this.safeString(response, "status");
        return new Dictionary<string, object>() {
            { "status", ((string)status).ToLower() },
            { "updated", null },
            { "eta", null },
            { "url", null },
            { "info", response },
        };
    }

    /**
     * @method
     * @name backpack#fetchTime
     * @description fetches the current integer timestamp in milliseconds from the exchange server
     * @see https://developer-pro.bitmart.com/en/spot/#get-system-time
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {int} the current integer timestamp in milliseconds from the exchange server
     */
    public async override Task<object> fetchTime(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object response = await this.publicGetApiV1Time(parameters);
        //
        //     1753131712992
        //
        return this.safeInteger(response, 0, this.milliseconds());
    }

    /**
     * @method
     * @name backpack#fetchBalance
     * @description query for balance and get the amount of funds available for trading or funds locked in orders
     * @see https://docs.backpack.exchange/#tag/Capital/operation/get_balances
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
     */
    public async override Task<object> fetchBalance(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.privateGetApiV1Capital(parameters);
        return this.parseBalance(response);
    }

    public override object parseBalance(object response)
    {
        //
        //     {
        //         "USDC": {
        //             "available": "120",
        //             "locked": "0",
        //             "staked": "0"
        //         }
        //     }
        //
        object balanceKeys = new List<object>(((IDictionary<string,object>)response).Keys);
        object result = new Dictionary<string, object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(balanceKeys)); postFixIncrement(ref i))
        {
            object id = getValue(balanceKeys, i);
            object code = this.safeCurrencyCode(id);
            object balance = getValue(response, id);
            object account = this.account();
            object locked = this.safeString(balance, "locked");
            object staked = this.safeString(balance, "staked");
            object used = Precise.stringAdd(locked, staked);
            ((IDictionary<string,object>)account)["free"] = this.safeString(balance, "available");
            ((IDictionary<string,object>)account)["used"] = used;
            ((IDictionary<string,object>)result)[(string)code] = account;
        }
        return this.safeBalance(result);
    }

    /**
     * @method
     * @name backpack#fetchDeposits
     * @description fetch all deposits made to an account
     * @see https://docs.backpack.exchange/#tag/Capital/operation/get_deposits
     * @param {string} code unified currency code
     * @param {int} [since] the earliest time in ms to fetch deposits for
     * @param {int} [limit] the maximum number of deposits structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {int} [params.until] the latest time in ms to fetch entries for
     * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
     */
    public async override Task<object> fetchDeposits(object code = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object currency = null;
        if (isTrue(!isEqual(code, null)))
        {
            currency = this.currency(code);
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["from"] = since;
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit; // default 100, max 1000
        }
        object until = null;
        var untilparametersVariable = this.handleOptionAndParams(parameters, "fetchDeposits", "until");
        until = ((IList<object>)untilparametersVariable)[0];
        parameters = ((IList<object>)untilparametersVariable)[1];
        if (isTrue(!isEqual(until, null)))
        {
            ((IDictionary<string,object>)request)["endTime"] = until;
        }
        object response = await this.privateGetWapiV1CapitalDeposits(this.extend(request, parameters));
        return this.parseTransactions(response, currency, since, limit);
    }

    /**
     * @method
     * @name backpack#fetchWithdrawals
     * @description fetch all withdrawals made from an account
     * @see https://docs.backpack.exchange/#tag/Capital/operation/get_withdrawals
     * @param {string} code unified currency code of the currency transferred
     * @param {int} [since] the earliest time in ms to fetch transfers for (default 24 hours ago)
     * @param {int} [limit] the maximum number of transfer structures to retrieve (default 50, max 200)
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {int} [params.until] the latest time in ms to fetch transfers for (default time now)
     * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
     */
    public async override Task<object> fetchWithdrawals(object code = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object currency = null;
        if (isTrue(!isEqual(code, null)))
        {
            currency = this.currency(code);
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["from"] = since;
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        object until = null;
        var untilparametersVariable = this.handleOptionAndParams(parameters, "fetchWithdrawals", "until");
        until = ((IList<object>)untilparametersVariable)[0];
        parameters = ((IList<object>)untilparametersVariable)[1];
        if (isTrue(!isEqual(until, null)))
        {
            ((IDictionary<string,object>)request)["to"] = until;
        }
        object response = await this.privateGetWapiV1CapitalWithdrawals(this.extend(request, parameters));
        return this.parseTransactions(response, currency, since, limit);
    }

    /**
     * @method
     * @name backpack#withdraw
     * @description make a withdrawal
     * @see https://docs.backpack.exchange/#tag/Capital/operation/request_withdrawal
     * @param {string} code unified currency code
     * @param {float} amount the amount to withdraw
     * @param {string} address the address to withdraw to
     * @param {string} tag
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.network] the network to withdraw on (mandatory)
     * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
     */
    public async override Task<object> withdraw(object code, object amount, object address, object tag = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(currency, "id") },
            { "amount", this.numberToString(amount) },
            { "address", address },
        };
        if (isTrue(!isEqual(tag, null)))
        {
            ((IDictionary<string,object>)request)["clientId"] = tag; // memo or tag
        }
        var networkCodequeryVariable = this.handleNetworkCodeAndParams(parameters);
        var networkCode = ((IList<object>) networkCodequeryVariable)[0];
        var query = ((IList<object>) networkCodequeryVariable)[1];
        object networkId = this.networkCodeToId(networkCode);
        if (isTrue(isEqual(networkId, null)))
        {
            throw new BadRequest ((string)add(this.id, " withdraw() requires a network parameter")) ;
        }
        ((IDictionary<string,object>)request)["blockchain"] = networkId;
        object response = await this.privatePostWapiV1CapitalWithdrawals(this.extend(request, query));
        return this.parseTransaction(response, currency);
    }

    public override object parseTransaction(object transaction, object currency = null)
    {
        //
        // fetchDeposits
        //     [
        //         {
        //             "createdAt": "2025-07-23T13:55:54.267",
        //             "fiatAmount": null,
        //             "fiatCurrency": null,
        //             "fromAddress": "0x2e3ab3e88a7dbdc763aadf5b28c18fb085af420a",
        //             "id": 6695353,
        //             "institutionBic": null,
        //             "platformMemo": null,
        //             "quantity": "120",
        //             "source": "ethereum",
        //             "status": "confirmed",
        //             "symbol": "USDC",
        //             "toAddress": "0xfBe7CbfCde93c8a4204a4be6B56732Eb32690170",
        //             "transactionHash": "0x58edaac415398d617b34c6673fffcaf0024990d5700565030119db5cbf3765d1"
        //         }
        //     ]
        //
        // withdraw
        //     {
        //         "accountIdentifier": null,
        //         "bankIdentifier": null,
        //         "bankName": null,
        //         "blockchain": "Ethereum",
        //         "clientId": null,
        //         "createdAt": "2025-08-13T19:27:13.817",
        //         "fee": "3",
        //         "fiatFee": null,
        //         "fiatState": null,
        //         "fiatSymbol": null,
        //         "id": 5479929,
        //         "identifier": null,
        //         "isInternal": false,
        //         "providerId": null,
        //         "quantity": "10",
        //         "status": "pending",
        //         "subaccountId": null,
        //         "symbol": "USDC",
        //         "toAddress": "0x0ad42b8e602c2d3d475ae52d678cf63d84ab2749",
        //         "transactionHash": null,
        //         "triggerAt": null
        //     }
        //
        // fetchWithdrawals
        //     [
        //         {
        //             "accountIdentifier": null,
        //             "bankIdentifier": null,
        //             "bankName": null,
        //             "blockchain": "Ethereum",
        //             "clientId": null,
        //             "createdAt": "2025-08-13T19:27:13.817",
        //             "fee": "3",
        //             "fiatFee": null,
        //             "fiatState": null,
        //             "fiatSymbol": null,
        //             "id": 5479929,
        //             "identifier": null,
        //             "isInternal": false,
        //             "providerId": null,
        //             "quantity": "10",
        //             "status": "confirmed",
        //             "subaccountId": null,
        //             "symbol": "USDC",
        //             "toAddress": "0x0ad42b8e602c2d3d475ae52d678cf63d84ab2749",
        //             "transactionHash": "0x658b6d082af4afa0d3cf85caf344ff7c19d980117726bf193b00d8850f8746a1",
        //             "triggerAt": null
        //         }
        //     ]
        //
        object status = this.parseTransactionStatus(this.safeString(transaction, "status"));
        object id = this.safeString(transaction, "id");
        object txid = this.safeString(transaction, "transactionHash");
        object coin = this.safeString(transaction, "symbol");
        object code = this.safeCurrencyCode(coin, currency);
        object timestamp = this.parse8601(this.safeString(transaction, "createdAt"));
        object amount = this.safeNumber(transaction, "quantity");
        object networkId = this.safeStringLower2(transaction, "source", "blockchain");
        object network = this.networkIdToCode(networkId);
        object addressTo = this.safeString(transaction, "toAddress");
        object addressFrom = this.safeString(transaction, "fromAddress");
        object tag = this.safeString(transaction, "platformMemo");
        object feeCost = this.safeNumber(transaction, "fee");
        object intern = this.safeBool(transaction, "isInternal", false);
        object fee = null;
        if (isTrue(!isEqual(feeCost, null)))
        {
            fee = new Dictionary<string, object>() {
                { "cost", feeCost },
                { "currency", code },
            };
        }
        return new Dictionary<string, object>() {
            { "info", transaction },
            { "id", id },
            { "txid", txid },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "network", network },
            { "address", null },
            { "addressTo", addressTo },
            { "addressFrom", addressFrom },
            { "tag", tag },
            { "tagTo", null },
            { "tagFrom", null },
            { "type", null },
            { "amount", amount },
            { "currency", code },
            { "status", status },
            { "updated", null },
            { "internal", intern },
            { "comment", null },
            { "fee", fee },
        };
    }

    public virtual object parseTransactionStatus(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "cancelled", "cancelled" },
            { "confirmed", "ok" },
            { "declined", "declined" },
            { "expired", "expired" },
            { "initiated", "initiated" },
            { "pending", "pending" },
            { "refunded", "refunded" },
            { "information required", "pending" },
        };
        return this.safeString(statuses, status, status);
    }

    /**
     * @method
     * @name backpack#fetchDepositAddress
     * @description fetch the deposit address for a currency associated with this account
     * @see https://docs.backpack.exchange/#tag/Capital/operation/get_deposit_address
     * @param {string} code unified currency code
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.networkCode] the network to fetch the deposit address (mandatory)
     * @returns {object} an [address structure]{@link https://docs.ccxt.com/#/?id=address-structure}
     */
    public async override Task<object> fetchDepositAddress(object code, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object networkCode = null;
        var networkCodeparametersVariable = this.handleNetworkCodeAndParams(parameters);
        networkCode = ((IList<object>)networkCodeparametersVariable)[0];
        parameters = ((IList<object>)networkCodeparametersVariable)[1];
        if (isTrue(isEqual(networkCode, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchDepositAddress() requires a network parameter, see https://docs.ccxt.com/#/?id=network-codes")) ;
        }
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "blockchain", this.networkCodeToId(networkCode) },
        };
        object response = await this.privateGetWapiV1CapitalDepositAddress(this.extend(request, parameters));
        return this.parseDepositAddress(response, currency);
    }

    public override object parseDepositAddress(object depositAddress, object currency = null)
    {
        //
        //     {
        //         "address": "0xfBe7CbfCde93c8a4204a4be6B56732Eb32690170"
        //     }
        //
        object address = this.safeString(depositAddress, "address");
        object currencyId = this.safeString(depositAddress, "currency");
        currency = this.safeCurrency(currencyId, currency);
        return new Dictionary<string, object>() {
            { "info", depositAddress },
            { "currency", getValue(currency, "code") },
            { "network", null },
            { "address", address },
            { "tag", null },
        };
    }

    /**
     * @method
     * @name backpack#createOrder
     * @description create a trade order
     * @see https://docs.backpack.exchange/#tag/Order/operation/execute_order
     * @param {string} symbol unified symbol of the market to create an order in
     * @param {string} type 'market' or 'limit'
     * @param {string} side 'buy' or 'sell'
     * @param {float} amount how much of currency you want to trade in units of base currency
     * @param {float} [price] the price at which the order is to be fullfilled, in units of the quote currency, ignored in market orders
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {float} [params.cost] *market orders only* the cost of the order in units of the quote currency (could be used instead of amount)
     * @param {int} [params.clientOrderId] a unique id for the order
     * @param {boolean} [params.postOnly] true to place a post only order
     * @param {string} [params.timeInForce] 'GTC', 'IOC', 'FOK' or 'PO'
     * @param {bool} [params.reduceOnly] *contract only* Indicates if this order is to reduce the size of a position
     * @param {string} [params.selfTradePrevention] 'RejectTaker', 'RejectMaker' or 'RejectBoth'
     * @param {bool} [params.autoLend] *spot margin only* if true then the order can lend
     * @param {bool} [params.autoLendRedeem] *spot margin only* if true then the order can redeem a lend if required
     * @param {bool} [params.autoBorrow] *spot margin only* if true then the order can borrow
     * @param {bool} [params.autoBorrowRepay] *spot margin only* if true then the order can repay a borrow
     * @param {float} [params.triggerPrice] the price that a trigger order is triggered at
     * @param {object} [params.takeProfit] *swap markets only - takeProfit object in params* containing the triggerPrice at which the attached take profit order will be triggered
     * @param {float} [params.takeProfit.triggerPrice] take profit trigger price
     * @param {float} [params.takeProfit.price] take profit order price (if not provided the order will be a market order)
     * @param {object} [params.stopLoss] *swap markets only - stopLoss object in params* containing the triggerPrice at which the attached stop loss order will be triggered
     * @param {float} [params.stopLoss.triggerPrice] stop loss trigger price
     * @param {float} [params.stopLoss.price] stop loss order price (if not provided the order will be a market order)
     * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> createOrder(object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object orderRequest = this.createOrderRequest(symbol, type, side, amount, price, parameters);
        object response = await this.privatePostApiV1Order(orderRequest);
        return this.parseOrder(response, market);
    }

    /**
     * @method
     * @name backpack#createOrders
     * @description create a list of trade orders
     * @see https://docs.backpack.exchange/#tag/Order/operation/execute_order_batch
     * @param {Array} orders list of orders to create, each object should contain the parameters required by createOrder, namely symbol, type, side, amount, price and params
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> createOrders(object orders, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object ordersRequests = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(orders)); postFixIncrement(ref i))
        {
            object rawOrder = getValue(orders, i);
            object marketId = this.safeString(rawOrder, "symbol");
            object type = this.safeString(rawOrder, "type");
            object side = this.safeString(rawOrder, "side");
            object amount = this.safeNumber(rawOrder, "amount");
            object price = this.safeNumber(rawOrder, "price");
            object orderParams = this.safeDict(rawOrder, "params", new Dictionary<string, object>() {});
            object extendedParams = this.extend(orderParams, parameters); // the request does not accept extra params since it's a list, so we're extending each order with the common params
            object orderRequest = this.createOrderRequest(marketId, type, side, amount, price, extendedParams);
            ((IList<object>)ordersRequests).Add(orderRequest);
        }
        object response = await this.privatePostApiV1Orders(ordersRequests);
        return this.parseOrders(response);
    }

    public virtual object createOrderRequest(object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
            { "side", this.encodeOrderSide(side) },
            { "orderType", this.capitalize(type) },
        };
        object triggerPrice = this.safeString(parameters, "triggerPrice");
        object isTriggerOrder = !isEqual(triggerPrice, null);
        object quantityKey = ((bool) isTrue(isTriggerOrder)) ? "triggerQuantity" : "quantity";
        // handle basic limit/market order types
        if (isTrue(isEqual(type, "limit")))
        {
            ((IDictionary<string,object>)request)["price"] = this.priceToPrecision(symbol, price);
            ((IDictionary<string,object>)request)[(string)quantityKey] = this.amountToPrecision(symbol, amount);
        } else if (isTrue(isEqual(type, "market")))
        {
            object cost = this.safeString2(parameters, "cost", "quoteQuantity");
            if (isTrue(!isEqual(cost, null)))
            {
                ((IDictionary<string,object>)request)["quoteQuantity"] = this.costToPrecision(symbol, cost);
                parameters = this.omit(parameters, new List<object>() {"cost", "quoteQuantity"});
            } else
            {
                ((IDictionary<string,object>)request)[(string)quantityKey] = this.amountToPrecision(symbol, amount);
            }
        }
        // trigger orders
        if (isTrue(isTriggerOrder))
        {
            ((IDictionary<string,object>)request)["triggerPrice"] = this.priceToPrecision(symbol, triggerPrice);
            parameters = this.omit(parameters, "triggerPrice");
        }
        object clientOrderId = this.safeInteger(parameters, "clientOrderId"); // the exchange requires uint
        if (isTrue(!isEqual(clientOrderId, null)))
        {
            ((IDictionary<string,object>)request)["clientId"] = clientOrderId;
            parameters = this.omit(parameters, "clientOrderId");
        }
        object postOnly = false;
        var postOnlyparametersVariable = this.handlePostOnly(isEqual(type, "market"), false, parameters);
        postOnly = ((IList<object>)postOnlyparametersVariable)[0];
        parameters = ((IList<object>)postOnlyparametersVariable)[1];
        if (isTrue(postOnly))
        {
            ((IDictionary<string,object>)parameters)["postOnly"] = true;
        }
        object takeProfit = this.safeDict(parameters, "takeProfit");
        if (isTrue(!isEqual(takeProfit, null)))
        {
            object takeProfitTriggerPrice = this.safeString(takeProfit, "triggerPrice");
            if (isTrue(!isEqual(takeProfitTriggerPrice, null)))
            {
                ((IDictionary<string,object>)request)["takeProfitTriggerPrice"] = this.priceToPrecision(symbol, takeProfitTriggerPrice);
            }
            object takeProfitPrice = this.safeString(takeProfit, "price");
            if (isTrue(!isEqual(takeProfitPrice, null)))
            {
                ((IDictionary<string,object>)request)["takeProfitLimitPrice"] = this.priceToPrecision(symbol, takeProfitPrice);
            }
            parameters = this.omit(parameters, "takeProfit");
        }
        object stopLoss = this.safeDict(parameters, "stopLoss");
        if (isTrue(!isEqual(stopLoss, null)))
        {
            object stopLossTriggerPrice = this.safeString(stopLoss, "triggerPrice");
            if (isTrue(!isEqual(stopLossTriggerPrice, null)))
            {
                ((IDictionary<string,object>)request)["stopLossTriggerPrice"] = this.priceToPrecision(symbol, stopLossTriggerPrice);
            }
            object stopLossPrice = this.safeString(stopLoss, "price");
            if (isTrue(!isEqual(stopLossPrice, null)))
            {
                ((IDictionary<string,object>)request)["stopLossLimitPrice"] = this.priceToPrecision(symbol, stopLossPrice);
            }
            parameters = this.omit(parameters, "stopLoss");
        }
        return this.extend(request, parameters);
    }

    public virtual object encodeOrderSide(object side)
    {
        object sides = new Dictionary<string, object>() {
            { "buy", "Bid" },
            { "sell", "Ask" },
        };
        return this.safeString(sides, side, side);
    }

    /**
     * @method
     * @name backpack#fetchOpenOrders
     * @description fetch all unfilled currently open orders
     * @see https://docs.backpack.exchange/#tag/Order/operation/get_open_orders
     * @param {string} symbol unified market symbol
     * @param {int} [since] the earliest time in ms to fetch open orders for
     * @param {int} [limit] the maximum number of open orders structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> fetchOpenOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
        }
        object response = await this.privateGetApiV1Orders(this.extend(request, parameters));
        return this.parseOrders(response, market, since, limit);
    }

    /**
     * @method
     * @name backpack#fetchOpenOrder
     * @description fetch an open order by it's id
     * @see https://docs.backpack.exchange/#tag/Order/operation/get_order
     * @param {string} id order id
     * @param {string} symbol not used by hollaex fetchOpenOrder ()
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async virtual Task<object> fetchOpenOrder(object id, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchOpenOrder() requires a symbol argument")) ;
        }
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
            { "orderId", id },
        };
        object response = await this.privateGetApiV1Order(this.extend(request, parameters));
        return this.parseOrder(response);
    }

    /**
     * @method
     * @name backpack#cancelOrder
     * @description cancels an open order
     * @see https://docs.backpack.exchange/#tag/Order/operation/cancel_order
     * @param {string} id order id
     * @param {string} symbol unified symbol of the market the order was made in
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> cancelOrder(object id, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " cancelOrder() requires a symbol argument")) ;
        }
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "orderId", id },
            { "symbol", getValue(market, "id") },
        };
        object response = await this.privateDeleteApiV1Order(this.extend(request, parameters));
        return this.parseOrder(response);
    }

    /**
     * @method
     * @name backpack#cancelAllOrders
     * @description cancel all open orders
     * @see https://docs.backpack.exchange/#tag/Order/operation/cancel_open_orders
     * @param {string} symbol unified market symbol, only orders in the market of this symbol are cancelled when symbol is not undefined
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> cancelAllOrders(object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " cancelOrder() requires a symbol argument")) ;
        }
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object response = await this.privateDeleteApiV1Orders(this.extend(request, parameters));
        return this.parseOrders(response, market);
    }

    /**
     * @method
     * @name backpack#fetchOrders
     * @description fetches information on multiple orders made by the user
     * @see https://docs.backpack.exchange/#tag/History/operation/get_order_history
     * @param {string} symbol unified market symbol of the market orders were made in
     * @param {int} [since] the earliest time in ms to fetch orders for
     * @param {int} [limit] the maximum number of  orde structures to retrieve (default 100, max 1000)
     * @param {object} [params] extra parameters specific to the bitteam api endpoint
     * @returns {Order[]} a list of [order structures]{@link https://github.com/ccxt/ccxt/wiki/Manual#order-structure}
     */
    public async override Task<object> fetchOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        object response = await this.privateGetWapiV1HistoryOrders(this.extend(request, parameters));
        return this.parseOrders(response, market, since, limit);
    }

    public override object parseOrder(object order, object market = null)
    {
        //
        //     {
        //         "clientId": null,
        //         "createdAt": 1753624283415,
        //         "executedQuantity": "0.001",
        //         "executedQuoteQuantity": "3.81428",
        //         "id": "4227701917",
        //         "orderType": "Market",
        //         "quantity": "0.001",
        //         "quoteQuantity": "3.82",
        //         "reduceOnly": null,
        //         "relatedOrderId": null,
        //         "selfTradePrevention": "RejectTaker",
        //         "side": "Bid",
        //         "status": "Filled",
        //         "stopLossLimitPrice": null,
        //         "stopLossTriggerBy": null,
        //         "stopLossTriggerPrice": null,
        //         "strategyId": null,
        //         "symbol": "ETH_USDC",
        //         "takeProfitLimitPrice": null,
        //         "takeProfitTriggerBy": null,
        //         "takeProfitTriggerPrice": null,
        //         "timeInForce": "GTC",
        //         "triggerBy": null,
        //         "triggerPrice": null,
        //         "triggerQuantity": null,
        //         "triggeredAt": null
        //     }
        //
        // fetchOpenOrders
        //     {
        //         "clientId": 123456789,
        //         "createdAt": 1753626206762,
        //         "executedQuantity": "0",
        //         "executedQuoteQuantity": "0",
        //         "id": "4228978331",
        //         "orderType": "Limit",
        //         "postOnly": true,
        //         "price": "3000",
        //         "quantity": "0.001",
        //         "reduceOnly": null,
        //         "relatedOrderId": null,
        //         "selfTradePrevention": "RejectTaker",
        //         "side": "Bid",
        //         "status": "New",
        //         "stopLossLimitPrice": null,
        //         "stopLossTriggerBy": null,
        //         "stopLossTriggerPrice": null,
        //         "strategyId": null,
        //         "symbol": "ETH_USDC",
        //         "takeProfitLimitPrice": null,
        //         "takeProfitTriggerBy": null,
        //         "takeProfitTriggerPrice": null,
        //         "timeInForce": "GTC",
        //         "triggerBy": null,
        //         "triggerPrice": null,
        //         "triggerQuantity": null,
        //         "triggeredAt": null
        //     }
        //
        // fetchOrders
        //     {
        //         "clientId": null,
        //         "createdAt": "2025-07-27T18:05:40.897",
        //         "executedQuantity": "0",
        //         "executedQuoteQuantity": "0",
        //         "expiryReason": null,
        //         "id": "4239996998",
        //         "orderType": "Limit",
        //         "postOnly": false,
        //         "price": "4500",
        //         "quantity": null,
        //         "quoteQuantity": null,
        //         "selfTradePrevention": "RejectTaker",
        //         "side": "Ask",
        //         "status": "Cancelled",
        //         "stopLossLimitPrice": null,
        //         "stopLossTriggerBy": null,
        //         "stopLossTriggerPrice": null,
        //         "strategyId": null,
        //         "symbol": "ETH_USDC",
        //         "systemOrderType": null,
        //         "takeProfitLimitPrice": null,
        //         "takeProfitTriggerBy": null,
        //         "takeProfitTriggerPrice": null,
        //         "timeInForce": "GTC",
        //         "triggerBy": null,
        //         "triggerPrice": "4300",
        //         "triggerQuantity": "0.001"
        //     }
        //
        object timestamp = this.safeInteger(order, "createdAt");
        object timestamp2 = this.parse8601(this.safeString(order, "createdAt"));
        if (isTrue(!isEqual(timestamp2, null)))
        {
            timestamp = timestamp2;
        }
        object id = this.safeString(order, "id");
        object clientOrderId = this.safeString(order, "clientId");
        object symbol = this.safeSymbol(this.safeString(order, "symbol"), market);
        object type = this.safeStringLower(order, "orderType");
        object timeInForce = this.safeString(order, "timeInForce");
        object side = this.parseOrderSide(this.safeString(order, "side"));
        object amount = this.safeString2(order, "quantity", "triggerQuantity");
        object price = this.safeString(order, "price");
        object cost = this.safeString(order, "executedQuoteQuantity");
        object status = this.parseOrderStatus(this.safeString(order, "status"));
        object triggerPrice = this.safeString(order, "triggerPrice");
        object filled = this.safeString(order, "executedQuantity");
        object reduceOnly = this.safeBool(order, "reduceOnly");
        object postOnly = this.safeBool(order, "postOnly");
        object stopLossPrice = this.safeString2(order, "stopLossLimitPrice", "stopLossTriggerPrice");
        object takeProfitPrice = this.safeString2(order, "takeProfitLimitPrice", "takeProfitTriggerPrice");
        return this.safeOrder(new Dictionary<string, object>() {
            { "info", order },
            { "id", id },
            { "clientOrderId", clientOrderId },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "lastTradeTimestamp", null },
            { "symbol", symbol },
            { "type", type },
            { "timeInForce", timeInForce },
            { "postOnly", postOnly },
            { "reduceOnly", reduceOnly },
            { "side", side },
            { "price", price },
            { "triggerPrice", triggerPrice },
            { "stopLossPrice", stopLossPrice },
            { "takeProfitPrice", takeProfitPrice },
            { "amount", amount },
            { "cost", cost },
            { "average", null },
            { "filled", filled },
            { "remaining", null },
            { "status", status },
            { "fee", null },
            { "trades", null },
        }, market);
    }

    public virtual object parseOrderStatus(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "New", "open" },
            { "Filled", "closed" },
            { "Cancelled", "canceled" },
            { "Expired", "canceled" },
            { "PartiallyFilled", "open" },
            { "TriggerPending", "open" },
            { "TriggerFailed", "rejected" },
        };
        return this.safeString(statuses, status, status);
    }

    public virtual object parseOrderSide(object side)
    {
        object sides = new Dictionary<string, object>() {
            { "Bid", "buy" },
            { "Ask", "sell" },
        };
        return this.safeString(sides, side, side);
    }

    /**
     * @method
     * @name backpack#fetchPositions
     * @description fetch all open positions
     * @see https://docs.backpack.exchange/#tag/Futures/operation/get_positions
     * @param {string[]|undefined} symbols list of unified market symbols
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} a list of [position structure]{@link https://docs.ccxt.com/#/?id=position-structure}
     */
    public async override Task<object> fetchPositions(object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.privateGetApiV1Position(parameters);
        object positions = this.parsePositions(response);
        if (isTrue(this.isEmpty(symbols)))
        {
            return positions;
        }
        symbols = this.marketSymbols(symbols);
        return this.filterByArrayPositions(positions, "symbol", symbols, false);
    }

    public override object parsePosition(object position, object market = null)
    {
        //
        // fetchPositions
        //     {
        //         "breakEvenPrice": "3831.3630555555555555555555556",
        //         "cumulativeFundingPayment": "-0.009218",
        //         "cumulativeInterest": "0",
        //         "entryPrice": "3826.8888888888888888888888889",
        //         "estLiquidationPrice": "0",
        //         "imf": "0.02",
        //         "imfFunction": {
        //             "base": "0.02",
        //             "factor": "0.0000935",
        //             "type": "sqrt"
        //         },
        //         "markPrice": "3787.46813304",
        //         "mmf": "0.0125",
        //         "mmfFunction": {
        //             "base": "0.0125",
        //             "factor": "0.0000561",
        //             "type": "sqrt"
        //         },
        //         "netCost": "13.7768",
        //         "netExposureNotional": "13.634885278944",
        //         "netExposureQuantity": "0.0036",
        //         "netQuantity": "0.0036",
        //         "pnlRealized": "0",
        //         "pnlUnrealized": "-0.141914",
        //         "positionId": "4238420454",
        //         "subaccountId": null,
        //         "symbol": "ETH_USDC_PERP",
        //         "userId":1813870
        //     }
        //
        //
        object id = this.safeString(position, "positionId");
        object marketId = this.safeString(position, "symbol");
        market = this.safeMarket(marketId, market);
        object symbol = getValue(market, "symbol");
        object entryPrice = this.safeString(position, "entryPrice");
        object markPrice = this.safeString(position, "markPrice");
        object netCost = this.safeString(position, "netCost");
        object hedged = false;
        object side = "long";
        if (isTrue(Precise.stringLt(netCost, "0")))
        {
            side = "short";
        }
        if (isTrue(isEqual(netCost, null)))
        {
            hedged = null;
            side = null;
        }
        object unrealizedPnl = this.safeString(position, "pnlUnrealized");
        object realizedPnl = this.safeString(position, "pnlRealized");
        object liquidationPrice = this.safeString(position, "estLiquidationPrice");
        return this.safePosition(new Dictionary<string, object>() {
            { "info", position },
            { "id", id },
            { "symbol", symbol },
            { "timestamp", this.parse8601(this.safeString(position, "timestamp")) },
            { "datetime", this.iso8601(this.parse8601(this.safeString(position, "timestamp"))) },
            { "lastUpdateTimestamp", null },
            { "hedged", hedged },
            { "side", side },
            { "contracts", this.safeString(position, "netExposureQuantity") },
            { "contractSize", null },
            { "entryPrice", entryPrice },
            { "markPrice", markPrice },
            { "lastPrice", null },
            { "notional", Precise.stringAbs(netCost) },
            { "leverage", null },
            { "collateral", null },
            { "initialMargin", null },
            { "initialMarginPercentage", this.safeString(position, "imf") },
            { "maintenanceMargin", null },
            { "maintenanceMarginPercentage", this.safeString(position, "mmf") },
            { "realizedPnl", realizedPnl },
            { "unrealizedPnl", unrealizedPnl },
            { "liquidationPrice", liquidationPrice },
            { "marginMode", null },
            { "marginRatio", null },
            { "percentage", null },
            { "stopLossPrice", null },
            { "takeProfitPrice", null },
        });
    }

    /**
     * @method
     * @name backpack#fetchFundingHistory
     * @description fetches the history of funding payments
     * @see https://docs.backpack.exchange/#tag/History/operation/get_funding_payments
     * @param {string} symbol unified symbol of the market to fetch trades for
     * @param {int} [since] timestamp in ms of the earliest trade to fetch (default 24 hours ago)
     * @param {int} [limit] the maximum amount of trades to fetch (default 200, max 500)
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {int} [params.until] timestamp in ms of the latest trade to fetch (default now)
     * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
     */
    public async override Task<object> fetchFundingHistory(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        object response = await this.privateGetWapiV1HistoryFunding(this.extend(request, parameters));
        return this.parseIncomes(response, market, since, limit);
    }

    public override object parseIncome(object income, object market = null)
    {
        //
        //     {
        //         "fundingRate": "0.0001",
        //         "intervalEndTimestamp": "2025-08-01T16:00:00",
        //         "quantity": "-0.001301",
        //         "subaccountId": 0,
        //         "symbol": "ETH_USDC_PERP",
        //         "userId": 1813870
        //     }
        //
        object marketId = this.safeString(income, "symbol");
        object symbol = this.safeSymbol(marketId, market);
        object amount = this.safeNumber(income, "quantity");
        object id = this.safeString(income, "userId");
        object timestamp = this.parse8601(this.safeString(income, "intervalEndTimestamp"));
        object rate = this.safeNumber(income, "fundingRate");
        return new Dictionary<string, object>() {
            { "info", income },
            { "symbol", symbol },
            { "code", null },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "id", id },
            { "amount", amount },
            { "rate", rate },
        };
    }

    public override object nonce()
    {
        return subtract(this.milliseconds(), getValue(this.options, "timeDifference"));
    }

    public override object sign(object path, object api = null, object method = null, object parameters = null, object headers = null, object body = null)
    {
        api ??= "public";
        method ??= "GET";
        parameters ??= new Dictionary<string, object>();
        object endpoint = add("/", path);
        object url = getValue(getValue(this.urls, "api"), api);
        object sortedParams = ((bool) isTrue(((parameters is IList<object>) || (parameters.GetType().IsGenericType && parameters.GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>)))))) ? parameters : this.keysort(parameters);
        if (isTrue(isEqual(api, "private")))
        {
            this.checkRequiredCredentials();
            object ts = ((object)this.nonce()).ToString();
            object recvWindow = this.safeString2(this.options, "recvWindow", "X-Window", "5000");
            object optionInstructions = this.safeDict(this.options, "instructions", new Dictionary<string, object>() {});
            object optionPathInstructions = this.safeDict(optionInstructions, path, new Dictionary<string, object>() {});
            object instruction = this.safeString(optionPathInstructions, method, "");
            object payload = "";
            if (isTrue(isTrue((isEqual(path, "api/v1/orders"))) && isTrue((isEqual(method, "POST")))))
            {
                payload = this.generateBatchPayload(sortedParams, ts, recvWindow, instruction);
            } else
            {
                object queryString = this.urlencode(sortedParams);
                if (isTrue(isGreaterThan(getArrayLength(queryString), 0)))
                {
                    queryString = add(queryString, "&");
                }
                payload = add(add(add(add(add(add(add("instruction=", instruction), "&"), queryString), "timestamp="), ts), "&window="), recvWindow);
            }
            object secretBytes = this.base64ToBinary(this.secret);
            object seed = this.arraySlice(secretBytes, 0, 32);
            object signature = eddsa(this.encode(payload), seed, ed25519);
            headers = new Dictionary<string, object>() {
                { "X-Timestamp", ts },
                { "X-Window", recvWindow },
                { "X-API-Key", this.apiKey },
                { "X-Signature", signature },
                { "X-Broker-Id", "1400" },
            };
            if (isTrue(!isEqual(method, "GET")))
            {
                body = this.json(sortedParams);
                ((IDictionary<string,object>)headers)["Content-Type"] = "application/json";
            }
        }
        if (isTrue(isEqual(method, "GET")))
        {
            object query = this.urlencode(sortedParams);
            if (isTrue(!isEqual(getArrayLength(query), 0)))
            {
                endpoint = add(endpoint, add("?", query));
            }
        }
        url = add(url, endpoint);
        return new Dictionary<string, object>() {
            { "url", url },
            { "method", method },
            { "body", body },
            { "headers", headers },
        };
    }

    public virtual object generateBatchPayload(object parameters, object ts, object recvWindow, object instruction)
    {
        object payload = "";
        for (object i = 0; isLessThan(i, getArrayLength(parameters)); postFixIncrement(ref i))
        {
            object order = this.safeDict(parameters, i, new Dictionary<string, object>() {});
            object sortedOrder = this.keysort(order);
            object orderQuery = this.urlencode(sortedOrder);
            payload = add(payload, add(add(add(add("instruction=", instruction), "&"), orderQuery), "&"));
            if (isTrue(isEqual(i, (subtract(getArrayLength(parameters), 1)))))
            {
                payload = add(payload, add(add(add("timestamp=", ts), "&window="), recvWindow));
            }
        }
        return payload;
    }

    public override object handleErrors(object code, object reason, object url, object method, object headers, object body, object response, object requestHeaders, object requestBody)
    {
        if (isTrue(isEqual(response, null)))
        {
            return null;  // fallback to default error handler
        }
        //
        // {"code":"INVALID_ORDER","message":"Invalid order"}
        // {"code":"INVALID_CLIENT_REQUEST","message":"Must specify both `triggerPrice` and `triggerQuantity` or neither"}
        //
        object errorCode = this.safeString(response, "code");
        object message = this.safeString(response, "message");
        if (isTrue(!isEqual(errorCode, null)))
        {
            object feedback = add(add(this.id, " "), body);
            this.throwExactlyMatchedException(getValue(this.exceptions, "exact"), errorCode, feedback);
            this.throwExactlyMatchedException(getValue(this.exceptions, "exact"), message, feedback);
            this.throwBroadlyMatchedException(getValue(this.exceptions, "broad"), message, feedback);
            throw new ExchangeError ((string)feedback) ;
        }
        return null;
    }
}
