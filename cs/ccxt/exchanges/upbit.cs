namespace ccxt;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

public partial class upbit : Exchange
{
    public override object describe()
    {
        return this.deepExtend(base.describe(), new Dictionary<string, object>() {
            { "id", "upbit" },
            { "name", "Upbit" },
            { "countries", new List<object>() {"KR"} },
            { "version", "v1" },
            { "rateLimit", 50 },
            { "pro", true },
            { "has", new Dictionary<string, object>() {
                { "CORS", true },
                { "spot", true },
                { "margin", null },
                { "swap", false },
                { "future", false },
                { "option", false },
                { "cancelOrder", true },
                { "createDepositAddress", true },
                { "createMarketBuyOrderWithCost", true },
                { "createMarketOrder", true },
                { "createMarketOrderWithCost", false },
                { "createMarketSellOrderWithCost", false },
                { "createOrder", true },
                { "fetchBalance", true },
                { "fetchCanceledOrders", true },
                { "fetchClosedOrders", true },
                { "fetchDeposit", true },
                { "fetchDepositAddress", true },
                { "fetchDepositAddresses", true },
                { "fetchDepositAddressesByNetwork", false },
                { "fetchDeposits", true },
                { "fetchFundingHistory", false },
                { "fetchFundingRate", false },
                { "fetchFundingRateHistory", false },
                { "fetchFundingRates", false },
                { "fetchIndexOHLCV", false },
                { "fetchMarginMode", false },
                { "fetchMarkets", true },
                { "fetchMarkOHLCV", false },
                { "fetchMyTrades", false },
                { "fetchOHLCV", true },
                { "fetchOpenInterestHistory", false },
                { "fetchOpenOrders", true },
                { "fetchOrder", true },
                { "fetchOrderBook", true },
                { "fetchOrderBooks", true },
                { "fetchOrders", false },
                { "fetchPositionMode", false },
                { "fetchPremiumIndexOHLCV", false },
                { "fetchTicker", true },
                { "fetchTickers", true },
                { "fetchTrades", true },
                { "fetchTradingFee", true },
                { "fetchTradingFees", false },
                { "fetchTransactions", false },
                { "fetchWithdrawal", true },
                { "fetchWithdrawals", true },
                { "transfer", false },
                { "withdraw", true },
            } },
            { "timeframes", new Dictionary<string, object>() {
                { "1s", "seconds" },
                { "1m", "minutes" },
                { "3m", "minutes" },
                { "5m", "minutes" },
                { "10m", "minutes" },
                { "15m", "minutes" },
                { "30m", "minutes" },
                { "1h", "minutes" },
                { "4h", "minutes" },
                { "1d", "days" },
                { "1w", "weeks" },
                { "1M", "months" },
                { "1y", "years" },
            } },
            { "hostname", "api.upbit.com" },
            { "urls", new Dictionary<string, object>() {
                { "logo", "https://user-images.githubusercontent.com/1294454/49245610-eeaabe00-f423-11e8-9cba-4b0aed794799.jpg" },
                { "api", new Dictionary<string, object>() {
                    { "public", "https://{hostname}" },
                    { "private", "https://{hostname}" },
                } },
                { "www", "https://upbit.com" },
                { "doc", "https://docs.upbit.com/docs/%EC%9A%94%EC%B2%AD-%EC%88%98-%EC%A0%9C%ED%95%9C" },
                { "fees", "https://upbit.com/service_center/guide" },
            } },
            { "api", new Dictionary<string, object>() {
                { "public", new Dictionary<string, object>() {
                    { "get", new Dictionary<string, object>() {
                        { "market/all", 2 },
                        { "candles/{timeframe}", 2 },
                        { "candles/{timeframe}/{unit}", 2 },
                        { "candles/seconds", 2 },
                        { "candles/minutes/{unit}", 2 },
                        { "candles/minutes/1", 2 },
                        { "candles/minutes/3", 2 },
                        { "candles/minutes/5", 2 },
                        { "candles/minutes/10", 2 },
                        { "candles/minutes/15", 2 },
                        { "candles/minutes/30", 2 },
                        { "candles/minutes/60", 2 },
                        { "candles/minutes/240", 2 },
                        { "candles/days", 2 },
                        { "candles/weeks", 2 },
                        { "candles/months", 2 },
                        { "candles/years", 2 },
                        { "trades/ticks", 2 },
                        { "ticker", 2 },
                        { "ticker/all", 2 },
                        { "orderbook", 2 },
                        { "orderbook/supported_levels", 2 },
                    } },
                } },
                { "private", new Dictionary<string, object>() {
                    { "get", new Dictionary<string, object>() {
                        { "accounts", 0.67 },
                        { "orders/chance", 0.67 },
                        { "order", 0.67 },
                        { "orders/closed", 0.67 },
                        { "orders/open", 0.67 },
                        { "orders/uuids", 0.67 },
                        { "withdraws", 0.67 },
                        { "withdraw", 0.67 },
                        { "withdraws/chance", 0.67 },
                        { "withdraws/coin_addresses", 0.67 },
                        { "deposits", 0.67 },
                        { "deposits/chance/coin", 0.67 },
                        { "deposit", 0.67 },
                        { "deposits/coin_addresses", 0.67 },
                        { "deposits/coin_address", 0.67 },
                        { "travel_rule/vasps", 0.67 },
                        { "status/wallet", 0.67 },
                        { "api_keys", 0.67 },
                    } },
                    { "post", new Dictionary<string, object>() {
                        { "orders", 2.5 },
                        { "orders/cancel_and_new", 2.5 },
                        { "withdraws/coin", 0.67 },
                        { "withdraws/krw", 0.67 },
                        { "deposits/krw", 0.67 },
                        { "deposits/generate_coin_address", 0.67 },
                        { "travel_rule/deposit/uuid", 0.67 },
                        { "travel_rule/deposit/txid", 0.67 },
                    } },
                    { "delete", new Dictionary<string, object>() {
                        { "order", 0.67 },
                        { "orders/open", 40 },
                        { "orders/uuids", 0.67 },
                    } },
                } },
            } },
            { "fees", new Dictionary<string, object>() {
                { "trading", new Dictionary<string, object>() {
                    { "tierBased", false },
                    { "percentage", true },
                    { "maker", this.parseNumber("0.0025") },
                    { "taker", this.parseNumber("0.0025") },
                } },
                { "funding", new Dictionary<string, object>() {
                    { "tierBased", false },
                    { "percentage", false },
                    { "withdraw", new Dictionary<string, object>() {} },
                    { "deposit", new Dictionary<string, object>() {} },
                } },
            } },
            { "features", new Dictionary<string, object>() {
                { "spot", new Dictionary<string, object>() {
                    { "sandbox", false },
                    { "createOrder", new Dictionary<string, object>() {
                        { "marginMode", false },
                        { "triggerPrice", false },
                        { "triggerPriceType", null },
                        { "triggerDirection", false },
                        { "stopLossPrice", false },
                        { "takeProfitPrice", false },
                        { "attachedStopLossTakeProfit", null },
                        { "timeInForce", new Dictionary<string, object>() {
                            { "IOC", true },
                            { "FOK", true },
                            { "PO", false },
                            { "GTD", false },
                        } },
                        { "hedged", false },
                        { "leverage", false },
                        { "marketBuyByCost", false },
                        { "marketBuyRequiresPrice", false },
                        { "selfTradePrevention", false },
                        { "trailing", false },
                        { "iceberg", false },
                    } },
                    { "createOrders", null },
                    { "fetchMyTrades", null },
                    { "fetchOrder", new Dictionary<string, object>() {
                        { "marginMode", false },
                        { "trigger", false },
                        { "trailing", false },
                        { "symbolRequired", false },
                    } },
                    { "fetchOpenOrders", new Dictionary<string, object>() {
                        { "marginMode", true },
                        { "limit", 100 },
                        { "trigger", false },
                        { "trailing", false },
                        { "symbolRequired", false },
                    } },
                    { "fetchOrders", null },
                    { "fetchClosedOrders", new Dictionary<string, object>() {
                        { "marginMode", false },
                        { "limit", 1000 },
                        { "daysBack", 100000 },
                        { "daysBackCanceled", 1 },
                        { "untilDays", 7 },
                        { "trigger", false },
                        { "trailing", false },
                        { "symbolRequired", false },
                    } },
                    { "fetchOHLCV", new Dictionary<string, object>() {
                        { "limit", 200 },
                    } },
                } },
                { "swap", new Dictionary<string, object>() {
                    { "linear", null },
                    { "inverse", null },
                } },
                { "future", new Dictionary<string, object>() {
                    { "linear", null },
                    { "inverse", null },
                } },
            } },
            { "precisionMode", TICK_SIZE },
            { "exceptions", new Dictionary<string, object>() {
                { "exact", new Dictionary<string, object>() {
                    { "This key has expired.", typeof(AuthenticationError) },
                    { "Missing request parameter error. Check the required parameters!", typeof(BadRequest) },
                    { "side is missing, side does not have a valid value", typeof(InvalidOrder) },
                } },
                { "broad", new Dictionary<string, object>() {
                    { "thirdparty_agreement_required", typeof(PermissionDenied) },
                    { "out_of_scope", typeof(PermissionDenied) },
                    { "order_not_found", typeof(OrderNotFound) },
                    { "insufficient_funds", typeof(InsufficientFunds) },
                    { "invalid_access_key", typeof(AuthenticationError) },
                    { "jwt_verification", typeof(AuthenticationError) },
                    { "create_ask_error", typeof(ExchangeError) },
                    { "create_bid_error", typeof(ExchangeError) },
                    { "volume_too_large", typeof(InvalidOrder) },
                    { "invalid_funds", typeof(InvalidOrder) },
                } },
            } },
            { "options", new Dictionary<string, object>() {
                { "createMarketBuyOrderRequiresPrice", true },
                { "fetchTickersMaxLength", 4096 },
                { "fetchOrderBooksMaxLength", 4096 },
                { "tradingFeesByQuoteCurrency", new Dictionary<string, object>() {
                    { "KRW", 0.0005 },
                } },
            } },
            { "commonCurrencies", new Dictionary<string, object>() {
                { "TON", "Tokamak Network" },
            } },
        });
    }

    public async virtual Task<object> fetchCurrency(object code, object parameters = null)
    {
        // this method is for retrieving funding fees and limits per currency
        // it requires private access and API keys properly set up
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        return await this.fetchCurrencyById(getValue(currency, "id"), parameters);
    }

    public async virtual Task<object> fetchCurrencyById(object id, object parameters = null)
    {
        // this method is for retrieving funding fees and limits per currency
        // it requires private access and API keys properly set up
        parameters ??= new Dictionary<string, object>();
        object request = new Dictionary<string, object>() {
            { "currency", id },
        };
        object response = await this.privateGetWithdrawsChance(this.extend(request, parameters));
        //
        //     {
        //         "member_level": {
        //             "security_level": 3,
        //             "fee_level": 0,
        //             "email_verified": true,
        //             "identity_auth_verified": true,
        //             "bank_account_verified": true,
        //             "kakao_pay_auth_verified": false,
        //             "locked": false,
        //             "wallet_locked": false
        //         },
        //         "currency": {
        //             "code": "BTC",
        //             "withdraw_fee": "0.0005",
        //             "is_coin": true,
        //             "wallet_state": "working",
        //             "wallet_support": [ "deposit", "withdraw" ]
        //         },
        //         "account": {
        //             "currency": "BTC",
        //             "balance": "10.0",
        //             "locked": "0.0",
        //             "avg_krw_buy_price": "8042000",
        //             "modified": false
        //         },
        //         "withdraw_limit": {
        //             "currency": "BTC",
        //             "minimum": null,
        //             "onetime": null,
        //             "daily": "10.0",
        //             "remaining_daily": "10.0",
        //             "remaining_daily_krw": "0.0",
        //             "fixed": null,
        //             "can_withdraw": true
        //         }
        //     }
        //
        object memberInfo = this.safeValue(response, "member_level", new Dictionary<string, object>() {});
        object currencyInfo = this.safeValue(response, "currency", new Dictionary<string, object>() {});
        object withdrawLimits = this.safeValue(response, "withdraw_limit", new Dictionary<string, object>() {});
        object canWithdraw = this.safeValue(withdrawLimits, "can_withdraw");
        object walletState = this.safeString(currencyInfo, "wallet_state");
        object walletLocked = this.safeValue(memberInfo, "wallet_locked");
        object locked = this.safeValue(memberInfo, "locked");
        object active = true;
        if (isTrue(isTrue((!isEqual(canWithdraw, null))) && !isTrue(canWithdraw)))
        {
            active = false;
        } else if (isTrue(!isEqual(walletState, "working")))
        {
            active = false;
        } else if (isTrue(isTrue((!isEqual(walletLocked, null))) && isTrue(walletLocked)))
        {
            active = false;
        } else if (isTrue(isTrue((!isEqual(locked, null))) && isTrue(locked)))
        {
            active = false;
        }
        object maxOnetimeWithdrawal = this.safeString(withdrawLimits, "onetime");
        object maxDailyWithdrawal = this.safeString(withdrawLimits, "daily", maxOnetimeWithdrawal);
        object remainingDailyWithdrawal = this.safeString(withdrawLimits, "remaining_daily", maxDailyWithdrawal);
        object maxWithdrawLimit = null;
        if (isTrue(Precise.stringGt(remainingDailyWithdrawal, "0")))
        {
            maxWithdrawLimit = remainingDailyWithdrawal;
        } else
        {
            maxWithdrawLimit = maxDailyWithdrawal;
        }
        object currencyId = this.safeString(currencyInfo, "code");
        object code = this.safeCurrencyCode(currencyId);
        return new Dictionary<string, object>() {
            { "info", response },
            { "id", currencyId },
            { "code", code },
            { "name", code },
            { "active", active },
            { "fee", this.safeNumber(currencyInfo, "withdraw_fee") },
            { "precision", null },
            { "limits", new Dictionary<string, object>() {
                { "withdraw", new Dictionary<string, object>() {
                    { "min", this.safeNumber(withdrawLimits, "minimum") },
                    { "max", this.parseNumber(maxWithdrawLimit) },
                } },
            } },
        };
    }

    public async virtual Task<object> fetchMarket(object symbol, object parameters = null)
    {
        // this method is for retrieving trading fees and limits per market
        // it requires private access and API keys properly set up
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        return await this.fetchMarketById(getValue(market, "id"), parameters);
    }

    public async virtual Task<object> fetchMarketById(object id, object parameters = null)
    {
        // this method is for retrieving trading fees and limits per market
        // it requires private access and API keys properly set up
        parameters ??= new Dictionary<string, object>();
        object request = new Dictionary<string, object>() {
            { "market", id },
        };
        object response = await this.privateGetOrdersChance(this.extend(request, parameters));
        //
        //     {
        //         "bid_fee": "0.0015",
        //         "ask_fee": "0.0015",
        //         "market": {
        //             "id": "KRW-BTC",
        //             "name": "BTC/KRW",
        //             "order_types": [ "limit" ],
        //             "order_sides": [ "ask", "bid" ],
        //             "bid": { "currency": "KRW", "price_unit": null, "min_total": 1000 },
        //             "ask": { "currency": "BTC", "price_unit": null, "min_total": 1000 },
        //             "max_total": "100000000.0",
        //             "state": "active",
        //         },
        //         "bid_account": {
        //             "currency": "KRW",
        //             "balance": "0.0",
        //             "locked": "0.0",
        //             "avg_buy_price": "0",
        //             "avg_buy_price_modified": false,
        //             "unit_currency": "KRW",
        //         },
        //         "ask_account": {
        //             "currency": "BTC",
        //             "balance": "10.0",
        //             "locked": "0.0",
        //             "avg_buy_price": "8042000",
        //             "avg_buy_price_modified": false,
        //             "unit_currency": "KRW",
        //         }
        //     }
        //
        object marketInfo = this.safeValue(response, "market");
        object bid = this.safeValue(marketInfo, "bid");
        object ask = this.safeValue(marketInfo, "ask");
        object marketId = this.safeString(marketInfo, "id");
        object baseId = this.safeString(ask, "currency");
        object quoteId = this.safeString(bid, "currency");
        object bs = this.safeCurrencyCode(baseId);
        object quote = this.safeCurrencyCode(quoteId);
        object state = this.safeString(marketInfo, "state");
        object bidFee = this.safeString(response, "bid_fee");
        object askFee = this.safeString(response, "ask_fee");
        object fee = this.parseNumber(Precise.stringMax(bidFee, askFee));
        return this.safeMarketStructure(new Dictionary<string, object>() {
            { "id", marketId },
            { "symbol", add(add(bs, "/"), quote) },
            { "base", bs },
            { "quote", quote },
            { "settle", null },
            { "baseId", baseId },
            { "quoteId", quoteId },
            { "settleId", null },
            { "type", "spot" },
            { "spot", true },
            { "margin", false },
            { "swap", false },
            { "future", false },
            { "option", false },
            { "active", (isEqual(state, "active")) },
            { "contract", false },
            { "linear", null },
            { "inverse", null },
            { "taker", fee },
            { "maker", fee },
            { "contractSize", null },
            { "expiry", null },
            { "expiryDatetime", null },
            { "strike", null },
            { "optionType", null },
            { "precision", new Dictionary<string, object>() {
                { "amount", this.parseNumber("1e-8") },
                { "price", this.parseNumber("1e-8") },
            } },
            { "limits", new Dictionary<string, object>() {
                { "leverage", new Dictionary<string, object>() {
                    { "min", null },
                    { "max", null },
                } },
                { "amount", new Dictionary<string, object>() {
                    { "min", this.safeNumber(ask, "min_total") },
                    { "max", null },
                } },
                { "price", new Dictionary<string, object>() {
                    { "min", null },
                    { "max", null },
                } },
                { "cost", new Dictionary<string, object>() {
                    { "min", this.safeNumber(bid, "min_total") },
                    { "max", this.safeNumber(marketInfo, "max_total") },
                } },
                { "info", response },
            } },
        });
    }

    /**
     * @method
     * @name upbit#fetchMarkets
     * @see https://docs.upbit.com/reference/%EB%A7%88%EC%BC%93-%EC%BD%94%EB%93%9C-%EC%A1%B0%ED%9A%8C
     * @description retrieves data on all markets for upbit
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} an array of objects representing market data
     */
    public async override Task<object> fetchMarkets(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object response = await this.publicGetMarketAll(parameters);
        //
        //    [
        //        {
        //            "market": "KRW-BTC",
        //            "korean_name": "비트코인",
        //            "english_name": "Bitcoin"
        //        },
        //        ...,
        //    ]
        //
        return this.parseMarkets(response);
    }

    public override object parseMarket(object market)
    {
        object id = this.safeString(market, "market");
        var quoteIdbaseIdVariable = ((string)id).Split(new [] {((string)"-")}, StringSplitOptions.None).ToList<object>();
        var quoteId = ((IList<object>) quoteIdbaseIdVariable)[0];
        var baseId = ((IList<object>) quoteIdbaseIdVariable)[1];
        object bs = this.safeCurrencyCode(baseId);
        object quote = this.safeCurrencyCode(quoteId);
        return this.safeMarketStructure(new Dictionary<string, object>() {
            { "id", id },
            { "symbol", add(add(bs, "/"), quote) },
            { "base", bs },
            { "quote", quote },
            { "settle", null },
            { "baseId", baseId },
            { "quoteId", quoteId },
            { "settleId", null },
            { "type", "spot" },
            { "spot", true },
            { "margin", false },
            { "swap", false },
            { "future", false },
            { "option", false },
            { "active", true },
            { "contract", false },
            { "linear", null },
            { "inverse", null },
            { "taker", this.safeNumber(getValue(this.options, "tradingFeesByQuoteCurrency"), quote, getValue(getValue(this.fees, "trading"), "taker")) },
            { "maker", this.safeNumber(getValue(this.options, "tradingFeesByQuoteCurrency"), quote, getValue(getValue(this.fees, "trading"), "maker")) },
            { "contractSize", null },
            { "expiry", null },
            { "expiryDatetime", null },
            { "strike", null },
            { "optionType", null },
            { "precision", new Dictionary<string, object>() {
                { "price", this.parseNumber("1e-8") },
                { "amount", this.parseNumber("1e-8") },
            } },
            { "limits", new Dictionary<string, object>() {
                { "leverage", new Dictionary<string, object>() {
                    { "min", null },
                    { "max", null },
                } },
                { "amount", new Dictionary<string, object>() {
                    { "min", null },
                    { "max", null },
                } },
                { "price", new Dictionary<string, object>() {
                    { "min", null },
                    { "max", null },
                } },
                { "cost", new Dictionary<string, object>() {
                    { "min", null },
                    { "max", null },
                } },
            } },
            { "created", null },
            { "info", market },
        });
    }

    public override object parseBalance(object response)
    {
        object result = new Dictionary<string, object>() {
            { "info", response },
            { "timestamp", null },
            { "datetime", null },
        };
        for (object i = 0; isLessThan(i, getArrayLength(response)); postFixIncrement(ref i))
        {
            object balance = getValue(response, i);
            object currencyId = this.safeString(balance, "currency");
            object code = this.safeCurrencyCode(currencyId);
            object account = this.account();
            ((IDictionary<string,object>)account)["free"] = this.safeString(balance, "balance");
            ((IDictionary<string,object>)account)["used"] = this.safeString(balance, "locked");
            ((IDictionary<string,object>)result)[(string)code] = account;
        }
        return this.safeBalance(result);
    }

    /**
     * @method
     * @name upbit#fetchBalance
     * @see https://docs.upbit.com/reference/%EC%A0%84%EC%B2%B4-%EA%B3%84%EC%A2%8C-%EC%A1%B0%ED%9A%8C
     * @description query for balance and get the amount of funds available for trading or funds locked in orders
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
     */
    public async override Task<object> fetchBalance(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.privateGetAccounts(parameters);
        //
        //     [ {          currency: "BTC",
        //                   "balance": "0.005",
        //                    "locked": "0.0",
        //         "avg_krw_buy_price": "7446000",
        //                  "modified":  false     },
        //       {          currency: "ETH",
        //                   "balance": "0.1",
        //                    "locked": "0.0",
        //         "avg_krw_buy_price": "250000",
        //                  "modified":  false    }   ]
        //
        return this.parseBalance(response);
    }

    /**
     * @method
     * @name upbit#fetchOrderBooks
     * @see https://docs.upbit.com/reference/%ED%98%B8%EA%B0%80-%EC%A0%95%EB%B3%B4-%EC%A1%B0%ED%9A%8C
     * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data for multiple markets
     * @param {string[]|undefined} symbols list of unified market symbols, all symbols fetched if undefined, default is undefined
     * @param {int} [limit] not used by upbit fetchOrderBooks ()
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbol
     */
    public async override Task<object> fetchOrderBooks(object symbols = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object ids = null;
        if (isTrue(isEqual(symbols, null)))
        {
            ids = String.Join(",", ((IList<object>)this.ids).ToArray());
            // max URL length is 2083 symbols, including http schema, hostname, tld, etc...
            if (isTrue(isGreaterThan(getArrayLength(ids), getValue(this.options, "fetchOrderBooksMaxLength"))))
            {
                object numIds = getArrayLength(this.ids);
                throw new ExchangeError ((string)add(add(add(add(add(add(add(this.id, " fetchOrderBooks() has "), ((object)numIds).ToString()), " symbols ("), ((object)getArrayLength(ids)).ToString()), " characters) exceeding max URL length ("), ((object)getValue(this.options, "fetchOrderBooksMaxLength")).ToString()), " characters), you are required to specify a list of symbols in the first argument to fetchOrderBooks")) ;
            }
        } else
        {
            ids = this.marketIds(symbols);
            ids = String.Join(",", ((IList<object>)ids).ToArray());
        }
        object request = new Dictionary<string, object>() {
            { "markets", ids },
        };
        object response = await this.publicGetOrderbook(this.extend(request, parameters));
        //
        //     [ {          market:   "BTC-ETH",
        //               "timestamp":    1542899030043,
        //          "total_ask_size":    109.57065201,
        //          "total_bid_size":    125.74430631,
        //         "orderbook_units": [ { ask_price: 0.02926679,
        //                              "bid_price": 0.02919904,
        //                               "ask_size": 4.20293961,
        //                               "bid_size": 11.65043576 },
        //                            ...,
        //                            { ask_price: 0.02938209,
        //                              "bid_price": 0.0291231,
        //                               "ask_size": 0.05135782,
        //                               "bid_size": 13.5595     }   ] },
        //       {          market:   "KRW-BTC",
        //               "timestamp":    1542899034662,
        //          "total_ask_size":    12.89790974,
        //          "total_bid_size":    4.88395783,
        //         "orderbook_units": [ { ask_price: 5164000,
        //                              "bid_price": 5162000,
        //                               "ask_size": 2.57606495,
        //                               "bid_size": 0.214       },
        //                            ...,
        //                            { ask_price: 5176000,
        //                              "bid_price": 5152000,
        //                               "ask_size": 2.752,
        //                               "bid_size": 0.4650305 }    ] }   ]
        //
        object result = new Dictionary<string, object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(response)); postFixIncrement(ref i))
        {
            object orderbook = getValue(response, i);
            object marketId = this.safeString(orderbook, "market");
            object symbol = this.safeSymbol(marketId, null, "-");
            object timestamp = this.safeInteger(orderbook, "timestamp");
            ((IDictionary<string,object>)result)[(string)symbol] = new Dictionary<string, object>() {
                { "symbol", symbol },
                { "bids", this.sortBy(this.parseBidsAsks(getValue(orderbook, "orderbook_units"), "bid_price", "bid_size"), 0, true) },
                { "asks", this.sortBy(this.parseBidsAsks(getValue(orderbook, "orderbook_units"), "ask_price", "ask_size"), 0) },
                { "timestamp", timestamp },
                { "datetime", this.iso8601(timestamp) },
                { "nonce", null },
            };
        }
        return result;
    }

    /**
     * @method
     * @name upbit#fetchOrderBook
     * @see https://docs.upbit.com/reference/%ED%98%B8%EA%B0%80-%EC%A0%95%EB%B3%B4-%EC%A1%B0%ED%9A%8C
     * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
     * @param {string} symbol unified symbol of the market to fetch the order book for
     * @param {int} [limit] the maximum amount of order book entries to return
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
     */
    public async override Task<object> fetchOrderBook(object symbol, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object orderbooks = await this.fetchOrderBooks(new List<object>() {symbol}, limit, parameters);
        return this.safeValue(orderbooks, symbol);
    }

    public override object parseTicker(object ticker, object market = null)
    {
        //
        //       {                market: "BTC-ETH",
        //                    "trade_date": "20181122",
        //                    "trade_time": "104543",
        //                "trade_date_kst": "20181122",
        //                "trade_time_kst": "194543",
        //               "trade_timestamp":  1542883543096,
        //                 "opening_price":  0.02976455,
        //                    "high_price":  0.02992577,
        //                     "low_price":  0.02934283,
        //                   "trade_price":  0.02947773,
        //            "prev_closing_price":  0.02966,
        //                        "change": "FALL",
        //                  "change_price":  0.00018227,
        //                   "change_rate":  0.0061453136,
        //           "signed_change_price":  -0.00018227,
        //            "signed_change_rate":  -0.0061453136,
        //                  "trade_volume":  1.00000005,
        //               "acc_trade_price":  100.95825586,
        //           "acc_trade_price_24h":  289.58650166,
        //              "acc_trade_volume":  3409.85311036,
        //          "acc_trade_volume_24h":  9754.40510513,
        //         "highest_52_week_price":  0.12345678,
        //          "highest_52_week_date": "2018-02-01",
        //          "lowest_52_week_price":  0.023936,
        //           "lowest_52_week_date": "2017-12-08",
        //                     "timestamp":  1542883543813  }
        //
        object timestamp = this.safeInteger(ticker, "trade_timestamp");
        object marketId = this.safeString2(ticker, "market", "code");
        market = this.safeMarket(marketId, market, "-");
        object last = this.safeString(ticker, "trade_price");
        return this.safeTicker(new Dictionary<string, object>() {
            { "symbol", getValue(market, "symbol") },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "high", this.safeString(ticker, "high_price") },
            { "low", this.safeString(ticker, "low_price") },
            { "bid", null },
            { "bidVolume", null },
            { "ask", null },
            { "askVolume", null },
            { "vwap", null },
            { "open", this.safeString(ticker, "opening_price") },
            { "close", last },
            { "last", last },
            { "previousClose", this.safeString(ticker, "prev_closing_price") },
            { "change", this.safeString(ticker, "signed_change_price") },
            { "percentage", this.safeString(ticker, "signed_change_rate") },
            { "average", null },
            { "baseVolume", this.safeString(ticker, "acc_trade_volume_24h") },
            { "quoteVolume", this.safeString(ticker, "acc_trade_price_24h") },
            { "info", ticker },
        }, market);
    }

    /**
     * @method
     * @name upbit#fetchTickers
     * @see https://docs.upbit.com/reference/ticker%ED%98%84%EC%9E%AC%EA%B0%80-%EC%A0%95%EB%B3%B4
     * @description fetches price tickers for multiple markets, statistical information calculated over the past 24 hours for each market
     * @param {string[]|undefined} symbols unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/#/?id=ticker-structure}
     */
    public async override Task<object> fetchTickers(object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        symbols = this.marketSymbols(symbols);
        object ids = null;
        if (isTrue(isEqual(symbols, null)))
        {
            ids = String.Join(",", ((IList<object>)this.ids).ToArray());
            // max URL length is 2083 symbols, including http schema, hostname, tld, etc...
            if (isTrue(isGreaterThan(getArrayLength(ids), getValue(this.options, "fetchTickersMaxLength"))))
            {
                object numIds = getArrayLength(this.ids);
                throw new ExchangeError ((string)add(add(add(this.id, " fetchTickers() has "), ((object)numIds).ToString()), " symbols exceeding max URL length, you are required to specify a list of symbols in the first argument to fetchTickers")) ;
            }
        } else
        {
            ids = this.marketIds(symbols);
            ids = String.Join(",", ((IList<object>)ids).ToArray());
        }
        object request = new Dictionary<string, object>() {
            { "markets", ids },
        };
        object response = await this.publicGetTicker(this.extend(request, parameters));
        //
        //     [ {                market: "BTC-ETH",
        //                    "trade_date": "20181122",
        //                    "trade_time": "104543",
        //                "trade_date_kst": "20181122",
        //                "trade_time_kst": "194543",
        //               "trade_timestamp":  1542883543097,
        //                 "opening_price":  0.02976455,
        //                    "high_price":  0.02992577,
        //                     "low_price":  0.02934283,
        //                   "trade_price":  0.02947773,
        //            "prev_closing_price":  0.02966,
        //                        "change": "FALL",
        //                  "change_price":  0.00018227,
        //                   "change_rate":  0.0061453136,
        //           "signed_change_price":  -0.00018227,
        //            "signed_change_rate":  -0.0061453136,
        //                  "trade_volume":  1.00000005,
        //               "acc_trade_price":  100.95825586,
        //           "acc_trade_price_24h":  289.58650166,
        //              "acc_trade_volume":  3409.85311036,
        //          "acc_trade_volume_24h":  9754.40510513,
        //         "highest_52_week_price":  0.12345678,
        //          "highest_52_week_date": "2018-02-01",
        //          "lowest_52_week_price":  0.023936,
        //           "lowest_52_week_date": "2017-12-08",
        //                     "timestamp":  1542883543813  } ]
        //
        object result = new Dictionary<string, object>() {};
        for (object t = 0; isLessThan(t, getArrayLength(response)); postFixIncrement(ref t))
        {
            object ticker = this.parseTicker(getValue(response, t));
            object symbol = getValue(ticker, "symbol");
            ((IDictionary<string,object>)result)[(string)symbol] = ticker;
        }
        return this.filterByArrayTickers(result, "symbol", symbols);
    }

    /**
     * @method
     * @name upbit#fetchTicker
     * @see https://docs.upbit.com/reference/ticker%ED%98%84%EC%9E%AC%EA%B0%80-%EC%A0%95%EB%B3%B4
     * @description fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
     * @param {string} symbol unified symbol of the market to fetch the ticker for
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
     */
    public async override Task<object> fetchTicker(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object tickers = await this.fetchTickers(new List<object>() {symbol}, parameters);
        return this.safeValue(tickers, symbol);
    }

    public override object parseTrade(object trade, object market = null)
    {
        //
        // fetchTrades
        //
        //       {             market: "BTC-ETH",
        //             "trade_date_utc": "2018-11-22",
        //             "trade_time_utc": "13:55:24",
        //                  "timestamp":  1542894924397,
        //                "trade_price":  0.02914289,
        //               "trade_volume":  0.20074397,
        //         "prev_closing_price":  0.02966,
        //               "change_price":  -0.00051711,
        //                    "ask_bid": "ASK",
        //              "sequential_id":  15428949259430000 }
        //
        // fetchOrder trades
        //
        //         {
        //             "market": "KRW-BTC",
        //             "uuid": "78162304-1a4d-4524-b9e6-c9a9e14d76c3",
        //             "price": "101000.0",
        //             "volume": "0.77368323",
        //             "funds": "78142.00623",
        //             "ask_fee": "117.213009345",
        //             "bid_fee": "117.213009345",
        //             "created_at": "2018-04-05T14:09:15+09:00",
        //             "side": "bid",
        //         }
        //
        object id = this.safeString2(trade, "sequential_id", "uuid");
        object orderId = null;
        object timestamp = this.safeInteger(trade, "timestamp");
        if (isTrue(isEqual(timestamp, null)))
        {
            timestamp = this.parse8601(this.safeString(trade, "created_at"));
        }
        object side = null;
        object askOrBid = this.safeStringLower2(trade, "ask_bid", "side");
        if (isTrue(isEqual(askOrBid, "ask")))
        {
            side = "sell";
        } else if (isTrue(isEqual(askOrBid, "bid")))
        {
            side = "buy";
        }
        object cost = this.safeString(trade, "funds");
        object price = this.safeString2(trade, "trade_price", "price");
        object amount = this.safeString2(trade, "trade_volume", "volume");
        object marketId = this.safeString2(trade, "market", "code");
        market = this.safeMarket(marketId, market, "-");
        object fee = null;
        object feeCost = this.safeString(trade, add(askOrBid, "_fee"));
        if (isTrue(!isEqual(feeCost, null)))
        {
            fee = new Dictionary<string, object>() {
                { "currency", getValue(market, "quote") },
                { "cost", feeCost },
            };
        }
        return this.safeTrade(new Dictionary<string, object>() {
            { "id", id },
            { "info", trade },
            { "order", orderId },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "symbol", getValue(market, "symbol") },
            { "type", null },
            { "side", side },
            { "takerOrMaker", null },
            { "price", price },
            { "amount", amount },
            { "cost", cost },
            { "fee", fee },
        }, market);
    }

    /**
     * @method
     * @name upbit#fetchTrades
     * @see https://docs.upbit.com/reference/%EC%B5%9C%EA%B7%BC-%EC%B2%B4%EA%B2%B0-%EB%82%B4%EC%97%AD
     * @description get the list of most recent trades for a particular symbol
     * @param {string} symbol unified symbol of the market to fetch trades for
     * @param {int} [since] timestamp in ms of the earliest trade to fetch
     * @param {int} [limit] the maximum amount of trades to fetch
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
     */
    public async override Task<object> fetchTrades(object symbol, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        if (isTrue(isEqual(limit, null)))
        {
            limit = 200;
        }
        object request = new Dictionary<string, object>() {
            { "market", getValue(market, "id") },
            { "count", limit },
        };
        object response = await this.publicGetTradesTicks(this.extend(request, parameters));
        //
        //     [ {             market: "BTC-ETH",
        //             "trade_date_utc": "2018-11-22",
        //             "trade_time_utc": "13:55:24",
        //                  "timestamp":  1542894924397,
        //                "trade_price":  0.02914289,
        //               "trade_volume":  0.20074397,
        //         "prev_closing_price":  0.02966,
        //               "change_price":  -0.00051711,
        //                    "ask_bid": "ASK",
        //              "sequential_id":  15428949259430000 },
        //       {             market: "BTC-ETH",
        //             "trade_date_utc": "2018-11-22",
        //             "trade_time_utc": "13:03:10",
        //                  "timestamp":  1542891790123,
        //                "trade_price":  0.02917,
        //               "trade_volume":  7.392,
        //         "prev_closing_price":  0.02966,
        //               "change_price":  -0.00049,
        //                    "ask_bid": "ASK",
        //              "sequential_id":  15428917910540000 }  ]
        //
        return this.parseTrades(response, market, since, limit);
    }

    /**
     * @method
     * @name upbit#fetchTradingFee
     * @see https://docs.upbit.com/reference/%EC%A3%BC%EB%AC%B8-%EA%B0%80%EB%8A%A5-%EC%A0%95%EB%B3%B4
     * @description fetch the trading fees for a market
     * @param {string} symbol unified market symbol
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [fee structure]{@link https://docs.ccxt.com/#/?id=fee-structure}
     */
    public async override Task<object> fetchTradingFee(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "market", getValue(market, "id") },
        };
        object response = await this.privateGetOrdersChance(this.extend(request, parameters));
        //
        //     {
        //         "bid_fee": "0.0005",
        //         "ask_fee": "0.0005",
        //         "maker_bid_fee": "0.0005",
        //         "maker_ask_fee": "0.0005",
        //         "market": {
        //             "id": "KRW-BTC",
        //             "name": "BTC/KRW",
        //             "order_types": [ "limit" ],
        //             "order_sides": [ "ask", "bid" ],
        //             "bid": { "currency": "KRW", "price_unit": null, "min_total": 5000 },
        //             "ask": { "currency": "BTC", "price_unit": null, "min_total": 5000 },
        //             "max_total": "1000000000.0",
        //             "state": "active"
        //         },
        //         "bid_account": {
        //             "currency": "KRW",
        //             "balance": "0.34202414",
        //             "locked": "4999.99999922",
        //             "avg_buy_price": "0",
        //             "avg_buy_price_modified": true,
        //             "unit_currency": "KRW"
        //         },
        //         "ask_account": {
        //             "currency": "BTC",
        //             "balance": "0.00048",
        //             "locked": "0.0",
        //             "avg_buy_price": "20870000",
        //             "avg_buy_price_modified": false,
        //             "unit_currency": "KRW"
        //         }
        //     }
        //
        object askFee = this.safeString(response, "ask_fee");
        object bidFee = this.safeString(response, "bid_fee");
        object taker = Precise.stringMax(askFee, bidFee);
        object makerAskFee = this.safeString(response, "maker_ask_fee");
        object makerBidFee = this.safeString(response, "maker_bid_fee");
        object maker = Precise.stringMax(makerAskFee, makerBidFee);
        return new Dictionary<string, object>() {
            { "info", response },
            { "symbol", symbol },
            { "maker", this.parseNumber(maker) },
            { "taker", this.parseNumber(taker) },
            { "percentage", true },
            { "tierBased", false },
        };
    }

    public override object parseOHLCV(object ohlcv, object market = null)
    {
        //
        //     {
        //         "market": "BTC-ETH",
        //         "candle_date_time_utc": "2018-11-22T13:47:00",
        //         "candle_date_time_kst": "2018-11-22T22:47:00",
        //         "opening_price": 0.02915963,
        //         "high_price": 0.02915963,
        //         "low_price": 0.02915448,
        //         "trade_price": 0.02915448,
        //         "timestamp": 1542894473674,
        //         "candle_acc_trade_price": 0.0981629437535248,
        //         "candle_acc_trade_volume": 3.36693173,
        //         "unit": 1
        //     }
        //
        return new List<object> {this.parse8601(this.safeString(ohlcv, "candle_date_time_utc")), this.safeNumber(ohlcv, "opening_price"), this.safeNumber(ohlcv, "high_price"), this.safeNumber(ohlcv, "low_price"), this.safeNumber(ohlcv, "trade_price"), this.safeNumber(ohlcv, "candle_acc_trade_volume")};
    }

    /**
     * @method
     * @name upbit#fetchOHLCV
     * @see https://docs.upbit.com/reference/%EB%B6%84minute-%EC%BA%94%EB%93%A4-1
     * @description fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
     * @param {string} symbol unified symbol of the market to fetch OHLCV data for
     * @param {string} timeframe the length of time each candle represents
     * @param {int} [since] timestamp in ms of the earliest candle to fetch
     * @param {int} [limit] the maximum amount of candles to fetch
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
     */
    public async override Task<object> fetchOHLCV(object symbol, object timeframe = null, object since = null, object limit = null, object parameters = null)
    {
        timeframe ??= "1m";
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object timeframePeriod = this.parseTimeframe(timeframe);
        object timeframeValue = this.safeString(this.timeframes, timeframe, timeframe);
        if (isTrue(isEqual(limit, null)))
        {
            limit = 200;
        }
        object request = new Dictionary<string, object>() {
            { "market", getValue(market, "id") },
            { "timeframe", timeframeValue },
            { "count", limit },
        };
        object response = null;
        if (isTrue(!isEqual(since, null)))
        {
            // convert `since` to `to` value
            ((IDictionary<string,object>)request)["to"] = this.iso8601(this.sum(since, multiply(multiply(timeframePeriod, limit), 1000)));
        }
        if (isTrue(isEqual(timeframeValue, "minutes")))
        {
            object numMinutes = Math.Round(Convert.ToDouble(divide(timeframePeriod, 60)));
            ((IDictionary<string,object>)request)["unit"] = numMinutes;
            response = await this.publicGetCandlesTimeframeUnit(this.extend(request, parameters));
        } else
        {
            response = await this.publicGetCandlesTimeframe(this.extend(request, parameters));
        }
        //
        //     [
        //         {
        //             "market": "BTC-ETH",
        //             "candle_date_time_utc": "2018-11-22T13:47:00",
        //             "candle_date_time_kst": "2018-11-22T22:47:00",
        //             "opening_price": 0.02915963,
        //             "high_price": 0.02915963,
        //             "low_price": 0.02915448,
        //             "trade_price": 0.02915448,
        //             "timestamp": 1542894473674,
        //             "candle_acc_trade_price": 0.0981629437535248,
        //             "candle_acc_trade_volume": 3.36693173,
        //             "unit": 1
        //         },
        //         {
        //             "market": "BTC-ETH",
        //             "candle_date_time_utc": "2018-11-22T10:06:00",
        //             "candle_date_time_kst": "2018-11-22T19:06:00",
        //             "opening_price": 0.0294,
        //             "high_price": 0.02940882,
        //             "low_price": 0.02934283,
        //             "trade_price": 0.02937354,
        //             "timestamp": 1542881219276,
        //             "candle_acc_trade_price": 0.0762597110943884,
        //             "candle_acc_trade_volume": 2.5949617,
        //             "unit": 1
        //         }
        //     ]
        //
        return this.parseOHLCVs(response, market, timeframe, since, limit);
    }

    /**
     * @method
     * @name upbit#createOrder
     * @description create a trade order
     * @see https://docs.upbit.com/reference/%EC%A3%BC%EB%AC%B8%ED%95%98%EA%B8%B0
     * @see https://global-docs.upbit.com/reference/order
     * @param {string} symbol unified symbol of the market to create an order in
     * @param {string} type 'market' or 'limit'
     * @param {string} side 'buy' or 'sell'
     * @param {float} amount how much you want to trade in units of the base currency
     * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {float} [params.cost] for market buy orders, the quote quantity that can be used as an alternative for the amount
     * @param {string} [params.timeInForce] 'IOC' or 'FOK'
     * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> createOrder(object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object orderSide = null;
        if (isTrue(isEqual(side, "buy")))
        {
            orderSide = "bid";
        } else if (isTrue(isEqual(side, "sell")))
        {
            orderSide = "ask";
        } else
        {
            throw new InvalidOrder ((string)add(this.id, " createOrder() allows buy or sell side only!")) ;
        }
        object request = new Dictionary<string, object>() {
            { "market", getValue(market, "id") },
            { "side", orderSide },
        };
        if (isTrue(isEqual(type, "limit")))
        {
            ((IDictionary<string,object>)request)["price"] = this.priceToPrecision(symbol, price);
        }
        if (isTrue(isTrue((isEqual(type, "market"))) && isTrue((isEqual(side, "buy")))))
        {
            // for market buy it requires the amount of quote currency to spend
            object quoteAmount = null;
            object createMarketBuyOrderRequiresPrice = true;
            var createMarketBuyOrderRequiresPriceparametersVariable = this.handleOptionAndParams(parameters, "createOrder", "createMarketBuyOrderRequiresPrice", true);
            createMarketBuyOrderRequiresPrice = ((IList<object>)createMarketBuyOrderRequiresPriceparametersVariable)[0];
            parameters = ((IList<object>)createMarketBuyOrderRequiresPriceparametersVariable)[1];
            object cost = this.safeNumber(parameters, "cost");
            parameters = this.omit(parameters, "cost");
            if (isTrue(!isEqual(cost, null)))
            {
                quoteAmount = this.costToPrecision(symbol, cost);
            } else if (isTrue(createMarketBuyOrderRequiresPrice))
            {
                if (isTrue(isEqual(price, null)))
                {
                    throw new InvalidOrder ((string)add(this.id, " createOrder() requires the price argument for market buy orders to calculate the total cost to spend (amount * price), alternatively set the createMarketBuyOrderRequiresPrice option or param to false and pass the cost to spend (quote quantity) in the amount argument")) ;
                } else
                {
                    object amountString = this.numberToString(amount);
                    object priceString = this.numberToString(price);
                    object costRequest = Precise.stringMul(amountString, priceString);
                    quoteAmount = this.costToPrecision(symbol, costRequest);
                }
            } else
            {
                quoteAmount = this.costToPrecision(symbol, amount);
            }
            ((IDictionary<string,object>)request)["ord_type"] = "price";
            ((IDictionary<string,object>)request)["price"] = quoteAmount;
        } else
        {
            ((IDictionary<string,object>)request)["ord_type"] = type;
            ((IDictionary<string,object>)request)["volume"] = this.amountToPrecision(symbol, amount);
        }
        object clientOrderId = this.safeString2(parameters, "clientOrderId", "identifier");
        if (isTrue(!isEqual(clientOrderId, null)))
        {
            ((IDictionary<string,object>)request)["identifier"] = clientOrderId;
        }
        if (isTrue(!isEqual(type, "market")))
        {
            object timeInForce = this.safeStringLower2(parameters, "timeInForce", "time_in_force");
            parameters = this.omit(parameters, "timeInForce");
            if (isTrue(!isEqual(timeInForce, null)))
            {
                ((IDictionary<string,object>)request)["time_in_force"] = timeInForce;
            }
        }
        parameters = this.omit(parameters, new List<object>() {"clientOrderId", "identifier"});
        object response = await this.privatePostOrders(this.extend(request, parameters));
        //
        //     {
        //         "uuid": "cdd92199-2897-4e14-9448-f923320408ad",
        //         "side": "bid",
        //         "ord_type": "limit",
        //         "price": "100.0",
        //         "avg_price": "0.0",
        //         "state": "wait",
        //         "market": "KRW-BTC",
        //         "created_at": "2018-04-10T15:42:23+09:00",
        //         "volume": "0.01",
        //         "remaining_volume": "0.01",
        //         "reserved_fee": "0.0015",
        //         "remaining_fee": "0.0015",
        //         "paid_fee": "0.0",
        //         "locked": "1.0015",
        //         "executed_volume": "0.0",
        //         "trades_count": 0
        //     }
        //
        return this.parseOrder(response);
    }

    /**
     * @method
     * @name upbit#cancelOrder
     * @see https://docs.upbit.com/reference/%EC%A3%BC%EB%AC%B8-%EC%B7%A8%EC%86%8C
     * @description cancels an open order
     * @param {string} id order id
     * @param {string} symbol not used by upbit cancelOrder ()
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> cancelOrder(object id, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {
            { "uuid", id },
        };
        object response = await this.privateDeleteOrder(this.extend(request, parameters));
        //
        //     {
        //         "uuid": "cdd92199-2897-4e14-9448-f923320408ad",
        //         "side": "bid",
        //         "ord_type": "limit",
        //         "price": "100.0",
        //         "state": "wait",
        //         "market": "KRW-BTC",
        //         "created_at": "2018-04-10T15:42:23+09:00",
        //         "volume": "0.01",
        //         "remaining_volume": "0.01",
        //         "reserved_fee": "0.0015",
        //         "remaining_fee": "0.0015",
        //         "paid_fee": "0.0",
        //         "locked": "1.0015",
        //         "executed_volume": "0.0",
        //         "trades_count": 0
        //     }
        //
        return this.parseOrder(response);
    }

    /**
     * @method
     * @name upbit#fetchDeposits
     * @see https://docs.upbit.com/reference/%EC%9E%85%EA%B8%88-%EB%A6%AC%EC%8A%A4%ED%8A%B8-%EC%A1%B0%ED%9A%8C
     * @description fetch all deposits made to an account
     * @param {string} code unified currency code
     * @param {int} [since] the earliest time in ms to fetch deposits for
     * @param {int} [limit] the maximum number of deposits structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
     */
    public async override Task<object> fetchDeposits(object code = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object currency = null;
        if (isTrue(!isEqual(code, null)))
        {
            currency = this.currency(code);
            ((IDictionary<string,object>)request)["currency"] = getValue(currency, "id");
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit; // default is 100
        }
        object response = await this.privateGetDeposits(this.extend(request, parameters));
        //
        //     [
        //         {
        //             "type": "deposit",
        //             "uuid": "94332e99-3a87-4a35-ad98-28b0c969f830",
        //             "currency": "KRW",
        //             "txid": "9e37c537-6849-4c8b-a134-57313f5dfc5a",
        //             "state": "ACCEPTED",
        //             "created_at": "2017-12-08T15:38:02+09:00",
        //             "done_at": "2017-12-08T15:38:02+09:00",
        //             "amount": "100000.0",
        //             "fee": "0.0"
        //         },
        //         ...,
        //     ]
        //
        return this.parseTransactions(response, currency, since, limit);
    }

    /**
     * @method
     * @name upbit#fetchDeposit
     * @description fetch information on a deposit
     * @see https://global-docs.upbit.com/reference/individual-deposit-inquiry
     * @param {string} id the unique id for the deposit
     * @param {string} [code] unified currency code of the currency deposited
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.txid] withdrawal transaction id, the id argument is reserved for uuid
     * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
     */
    public async virtual Task<object> fetchDeposit(object id, object code = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {
            { "uuid", id },
        };
        object currency = null;
        if (isTrue(!isEqual(code, null)))
        {
            currency = this.currency(code);
            ((IDictionary<string,object>)request)["currency"] = getValue(currency, "id");
        }
        object response = await this.privateGetDeposit(this.extend(request, parameters));
        //
        //     {
        //         "type": "deposit",
        //         "uuid": "7f54527e-2eee-4268-860e-fd8b9d7fe3c7",
        //         "currency": "ADA",
        //         "net_type": "ADA",
        //         "txid": "99795bbfeca91eaa071068bb659b33eeb65d8aaff2551fdf7c78f345d188952b",
        //         "state": "ACCEPTED",
        //         "created_at": "2023-12-12T04:58:41Z",
        //         "done_at": "2023-12-12T05:31:50Z",
        //         "amount": "35.72344",
        //         "fee": "0.0",
        //         "transaction_type": "default"
        //     }
        //
        return this.parseTransaction(response, currency);
    }

    /**
     * @method
     * @name upbit#fetchWithdrawals
     * @see https://docs.upbit.com/reference/%EC%A0%84%EC%B2%B4-%EC%B6%9C%EA%B8%88-%EC%A1%B0%ED%9A%8C
     * @description fetch all withdrawals made from an account
     * @param {string} code unified currency code
     * @param {int} [since] the earliest time in ms to fetch withdrawals for
     * @param {int} [limit] the maximum number of withdrawals structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
     */
    public async override Task<object> fetchWithdrawals(object code = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object currency = null;
        if (isTrue(!isEqual(code, null)))
        {
            currency = this.currency(code);
            ((IDictionary<string,object>)request)["currency"] = getValue(currency, "id");
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit; // default is 100
        }
        object response = await this.privateGetWithdraws(this.extend(request, parameters));
        //
        //     [
        //         {
        //             "type": "withdraw",
        //             "uuid": "9f432943-54e0-40b7-825f-b6fec8b42b79",
        //             "currency": "BTC",
        //             "txid": null,
        //             "state": "processing",
        //             "created_at": "2018-04-13T11:24:01+09:00",
        //             "done_at": null,
        //             "amount": "0.01",
        //             "fee": "0.0",
        //             "krw_amount": "80420.0"
        //         },
        //         ...,
        //     ]
        //
        return this.parseTransactions(response, currency, since, limit);
    }

    /**
     * @method
     * @name upbit#fetchWithdrawal
     * @description fetch data on a currency withdrawal via the withdrawal id
     * @see https://global-docs.upbit.com/reference/individual-withdrawal-inquiry
     * @param {string} id the unique id for the withdrawal
     * @param {string} [code] unified currency code of the currency withdrawn
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.txid] withdrawal transaction id, the id argument is reserved for uuid
     * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
     */
    public async virtual Task<object> fetchWithdrawal(object id, object code = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {
            { "uuid", id },
        };
        object currency = null;
        if (isTrue(!isEqual(code, null)))
        {
            currency = this.currency(code);
            ((IDictionary<string,object>)request)["currency"] = getValue(currency, "id");
        }
        object response = await this.privateGetWithdraw(this.extend(request, parameters));
        //
        //     {
        //         "type": "withdraw",
        //         "uuid": "95ef274b-23a6-4de4-95b0-5cbef4ca658f",
        //         "currency": "ADA",
        //         "net_type": "ADA",
        //         "txid": "b1528f149297a71671b86636f731f8fdb0ff53da0f1d8c19093d59df96f34583",
        //         "state": "DONE",
        //         "created_at": "2023-12-14T02:46:52Z",
        //         "done_at": "2023-12-14T03:10:11Z",
        //         "amount": "35.22344",
        //         "fee": "0.5",
        //         "transaction_type": "default"
        //     }
        //
        return this.parseTransaction(response, currency);
    }

    public virtual object parseTransactionStatus(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "submitting", "pending" },
            { "submitted", "pending" },
            { "almost_accepted", "pending" },
            { "rejected", "failed" },
            { "accepted", "ok" },
            { "processing", "pending" },
            { "done", "ok" },
            { "canceled", "canceled" },
        };
        return this.safeString(statuses, status, status);
    }

    public override object parseTransaction(object transaction, object currency = null)
    {
        //
        // fetchDeposits, fetchDeposit
        //
        //     {
        //         "type": "deposit",
        //         "uuid": "94332e99-3a87-4a35-ad98-28b0c969f830",
        //         "currency": "KRW",
        //         "txid": "9e37c537-6849-4c8b-a134-57313f5dfc5a",
        //         "state": "ACCEPTED",
        //         "created_at": "2017-12-08T15:38:02+09:00",
        //         "done_at": "2017-12-08T15:38:02+09:00",
        //         "amount": "100000.0",
        //         "fee": "0.0"
        //     }
        //
        // fetchWithdrawals, fetchWithdrawal
        //
        //     {
        //         "type": "withdraw",
        //         "uuid": "9f432943-54e0-40b7-825f-b6fec8b42b79",
        //         "currency": "BTC",
        //         "txid": "cd81e9b45df8da29f936836e58c907a106057e454a45767a7b06fcb19b966bba",
        //         "state": "processing",
        //         "created_at": "2018-04-13T11:24:01+09:00",
        //         "done_at": null,
        //         "amount": "0.01",
        //         "fee": "0.0",
        //         "krw_amount": "80420.0"
        //     }
        //
        object address = null; // not present in the data structure received from the exchange
        object tag = null; // not present in the data structure received from the exchange
        object updatedRaw = this.safeString(transaction, "done_at");
        object timestamp = this.parse8601(this.safeString(transaction, "created_at", updatedRaw));
        object type = this.safeString(transaction, "type");
        if (isTrue(isEqual(type, "withdraw")))
        {
            type = "withdrawal";
        }
        object currencyId = this.safeString(transaction, "currency");
        object code = this.safeCurrencyCode(currencyId, currency);
        return new Dictionary<string, object>() {
            { "info", transaction },
            { "id", this.safeString(transaction, "uuid") },
            { "currency", code },
            { "amount", this.safeNumber(transaction, "amount") },
            { "network", null },
            { "address", address },
            { "addressTo", null },
            { "addressFrom", null },
            { "tag", tag },
            { "tagTo", null },
            { "tagFrom", null },
            { "status", this.parseTransactionStatus(this.safeStringLower(transaction, "state")) },
            { "type", type },
            { "updated", this.parse8601(updatedRaw) },
            { "txid", this.safeString(transaction, "txid") },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "internal", null },
            { "comment", null },
            { "fee", new Dictionary<string, object>() {
                { "currency", code },
                { "cost", this.safeNumber(transaction, "fee") },
            } },
        };
    }

    public virtual object parseOrderStatus(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "wait", "open" },
            { "done", "closed" },
            { "cancel", "canceled" },
        };
        return this.safeString(statuses, status, status);
    }

    public override object parseOrder(object order, object market = null)
    {
        //
        //     {
        //         "uuid": "a08f09b1-1718-42e2-9358-f0e5e083d3ee",
        //         "side": "bid",
        //         "ord_type": "limit",
        //         "price": "17417000.0",
        //         "state": "done",
        //         "market": "KRW-BTC",
        //         "created_at": "2018-04-05T14:09:14+09:00",
        //         "volume": "1.0",
        //         "remaining_volume": "0.0",
        //         "reserved_fee": "26125.5",
        //         "remaining_fee": "25974.0",
        //         "paid_fee": "151.5",
        //         "locked": "17341974.0",
        //         "executed_volume": "1.0",
        //         "trades_count": 2,
        //         "trades": [
        //             {
        //                 "market": "KRW-BTC",
        //                 "uuid": "78162304-1a4d-4524-b9e6-c9a9e14d76c3",
        //                 "price": "101000.0",
        //                 "volume": "0.77368323",
        //                 "funds": "78142.00623",
        //                 "ask_fee": "117.213009345",
        //                 "bid_fee": "117.213009345",
        //                 "created_at": "2018-04-05T14:09:15+09:00",
        //                 "side": "bid",
        //             },
        //             {
        //                 "market": "KRW-BTC",
        //                 "uuid": "f73da467-c42f-407d-92fa-e10d86450a20",
        //                 "price": "101000.0",
        //                 "volume": "0.22631677",
        //                 "funds": "22857.99377",
        //                 "ask_fee": "34.286990655", // missing in market orders
        //                 "bid_fee": "34.286990655", // missing in market orders
        //                 "created_at": "2018-04-05T14:09:15+09:00", // missing in market orders
        //                 "side": "bid",
        //             },
        //         ],
        //     }
        //
        // fetchOpenOrders, fetchClosedOrders, fetchCanceledOrders
        //
        //     {
        //         "uuid": "637fd66-d019-4d77-bee6-8e0cff28edd9",
        //         "side": "ask",
        //         "ord_type": "limit",
        //         "price": "1.5",
        //         "state": "wait",
        //         "market": "SGD-XRP",
        //         "created_at": "2024-06-05T09:37:10Z",
        //         "volume": "10",
        //         "remaining_volume": "10",
        //         "reserved_fee": "0",
        //         "remaining_fee": "0",
        //         "paid_fee": "0",
        //         "locked": "10",
        //         "executed_volume": "0",
        //         "executed_funds": "0",
        //         "trades_count": 0,
        //         "time_in_force": "ioc"
        //     }
        //
        object id = this.safeString(order, "uuid");
        object side = this.safeString(order, "side");
        if (isTrue(isEqual(side, "bid")))
        {
            side = "buy";
        } else
        {
            side = "sell";
        }
        object type = this.safeString(order, "ord_type");
        object timestamp = this.parse8601(this.safeString(order, "created_at"));
        object status = this.parseOrderStatus(this.safeString(order, "state"));
        object lastTradeTimestamp = null;
        object price = this.safeString(order, "price");
        object amount = this.safeString(order, "volume");
        object remaining = this.safeString(order, "remaining_volume");
        object filled = this.safeString(order, "executed_volume");
        object cost = null;
        if (isTrue(isEqual(type, "price")))
        {
            type = "market";
            cost = price;
            price = null;
        }
        object average = null;
        object fee = null;
        object feeCost = this.safeString(order, "paid_fee");
        object marketId = this.safeString(order, "market");
        market = this.safeMarket(marketId, market);
        object trades = this.safeValue(order, "trades", new List<object>() {});
        trades = this.parseTrades(trades, market, null, null, new Dictionary<string, object>() {
            { "order", id },
            { "type", type },
        });
        object numTrades = getArrayLength(trades);
        if (isTrue(isGreaterThan(numTrades, 0)))
        {
            // the timestamp in fetchOrder trades is missing
            lastTradeTimestamp = getValue(getValue(trades, subtract(numTrades, 1)), "timestamp");
            object getFeesFromTrades = false;
            if (isTrue(isEqual(feeCost, null)))
            {
                getFeesFromTrades = true;
                feeCost = "0";
            }
            cost = "0";
            for (object i = 0; isLessThan(i, numTrades); postFixIncrement(ref i))
            {
                object trade = getValue(trades, i);
                cost = Precise.stringAdd(cost, this.safeString(trade, "cost"));
                if (isTrue(getFeesFromTrades))
                {
                    object tradeFee = this.safeValue(getValue(trades, i), "fee", new Dictionary<string, object>() {});
                    object tradeFeeCost = this.safeString(tradeFee, "cost");
                    if (isTrue(!isEqual(tradeFeeCost, null)))
                    {
                        feeCost = Precise.stringAdd(feeCost, tradeFeeCost);
                    }
                }
            }
            average = Precise.stringDiv(cost, filled);
        }
        if (isTrue(!isEqual(feeCost, null)))
        {
            fee = new Dictionary<string, object>() {
                { "currency", getValue(market, "quote") },
                { "cost", feeCost },
            };
        }
        return this.safeOrder(new Dictionary<string, object>() {
            { "info", order },
            { "id", id },
            { "clientOrderId", null },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "lastTradeTimestamp", lastTradeTimestamp },
            { "symbol", getValue(market, "symbol") },
            { "type", type },
            { "timeInForce", this.safeStringUpper(order, "time_in_force") },
            { "postOnly", null },
            { "side", side },
            { "price", price },
            { "triggerPrice", null },
            { "cost", this.parseNumber(cost) },
            { "average", this.parseNumber(average) },
            { "amount", amount },
            { "filled", filled },
            { "remaining", remaining },
            { "status", status },
            { "fee", fee },
            { "trades", trades },
        });
    }

    /**
     * @method
     * @name upbit#fetchOpenOrders
     * @description fetch all unfilled currently open orders
     * @see https://global-docs.upbit.com/reference/open-order
     * @param {string} symbol unified market symbol
     * @param {int} [since] the earliest time in ms to fetch open orders for
     * @param {int} [limit] the maximum number of open order structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.state] default is 'wait', set to 'watch' for stop limit orders
     * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> fetchOpenOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            ((IDictionary<string,object>)request)["market"] = getValue(market, "id");
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        object response = await this.privateGetOrdersOpen(this.extend(request, parameters));
        //
        //     [
        //         {
        //             "uuid": "637fd66-d019-4d77-bee6-8e0cff28edd9",
        //             "side": "ask",
        //             "ord_type": "limit",
        //             "price": "1.5",
        //             "state": "wait",
        //             "market": "SGD-XRP",
        //             "created_at": "2024-06-05T09:37:10Z",
        //             "volume": "10",
        //             "remaining_volume": "10",
        //             "reserved_fee": "0",
        //             "remaining_fee": "0",
        //             "paid_fee": "0",
        //             "locked": "10",
        //             "executed_volume": "0",
        //             "executed_funds": "0",
        //             "trades_count": 0
        //         }
        //     ]
        //
        return this.parseOrders(response, market, since, limit);
    }

    /**
     * @method
     * @name upbit#fetchClosedOrders
     * @description fetches information on multiple closed orders made by the user
     * @see https://global-docs.upbit.com/reference/closed-order
     * @param {string} symbol unified market symbol of the market orders were made in
     * @param {int} [since] the earliest time in ms to fetch orders for
     * @param {int} [limit] the maximum number of order structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {int} [params.until] timestamp in ms of the latest order
     * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> fetchClosedOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {
            { "state", "done" },
        };
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            ((IDictionary<string,object>)request)["market"] = getValue(market, "id");
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["start_time"] = since;
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        var requestparametersVariable = this.handleUntilOption("end_time", request, parameters);
        request = ((IList<object>)requestparametersVariable)[0];
        parameters = ((IList<object>)requestparametersVariable)[1];
        object response = await this.privateGetOrdersClosed(this.extend(request, parameters));
        //
        //     [
        //         {
        //             "uuid": "637fd66-d019-4d77-bee6-8e0cff28edd9",
        //             "side": "ask",
        //             "ord_type": "limit",
        //             "price": "1.5",
        //             "state": "done",
        //             "market": "SGD-XRP",
        //             "created_at": "2024-06-05T09:37:10Z",
        //             "volume": "10",
        //             "remaining_volume": "10",
        //             "reserved_fee": "0",
        //             "remaining_fee": "0",
        //             "paid_fee": "0",
        //             "locked": "10",
        //             "executed_volume": "0",
        //             "executed_funds": "0",
        //             "trades_count": 0,
        //             "time_in_force": "ioc"
        //         }
        //     ]
        //
        return this.parseOrders(response, market, since, limit);
    }

    /**
     * @method
     * @name upbit#fetchCanceledOrders
     * @description fetches information on multiple canceled orders made by the user
     * @see https://global-docs.upbit.com/reference/closed-order
     * @param {string} symbol unified market symbol of the market orders were made in
     * @param {int} [since] timestamp in ms of the earliest order, default is undefined
     * @param {int} [limit] max number of orders to return, default is undefined
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {int} [params.until] timestamp in ms of the latest order
     * @returns {object} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async virtual Task<object> fetchCanceledOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {
            { "state", "cancel" },
        };
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            ((IDictionary<string,object>)request)["market"] = getValue(market, "id");
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["start_time"] = since;
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        var requestparametersVariable = this.handleUntilOption("end_time", request, parameters);
        request = ((IList<object>)requestparametersVariable)[0];
        parameters = ((IList<object>)requestparametersVariable)[1];
        object response = await this.privateGetOrdersClosed(this.extend(request, parameters));
        //
        //     [
        //         {
        //             "uuid": "637fd66-d019-4d77-bee6-8e0cff28edd9",
        //             "side": "ask",
        //             "ord_type": "limit",
        //             "price": "1.5",
        //             "state": "cancel",
        //             "market": "SGD-XRP",
        //             "created_at": "2024-06-05T09:37:10Z",
        //             "volume": "10",
        //             "remaining_volume": "10",
        //             "reserved_fee": "0",
        //             "remaining_fee": "0",
        //             "paid_fee": "0",
        //             "locked": "10",
        //             "executed_volume": "0",
        //             "executed_funds": "0",
        //             "trades_count": 0,
        //             "time_in_force": "ioc"
        //         }
        //     ]
        //
        return this.parseOrders(response, market, since, limit);
    }

    /**
     * @method
     * @name upbit#fetchOrder
     * @see https://docs.upbit.com/reference/%EA%B0%9C%EB%B3%84-%EC%A3%BC%EB%AC%B8-%EC%A1%B0%ED%9A%8C
     * @description fetches information on an order made by the user
     * @param {string} id order id
     * @param {string} symbol not used by upbit fetchOrder
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> fetchOrder(object id, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {
            { "uuid", id },
        };
        object response = await this.privateGetOrder(this.extend(request, parameters));
        //
        //     {
        //         "uuid": "a08f09b1-1718-42e2-9358-f0e5e083d3ee",
        //         "side": "bid",
        //         "ord_type": "limit",
        //         "price": "17417000.0",
        //         "state": "done",
        //         "market": "KRW-BTC",
        //         "created_at": "2018-04-05T14:09:14+09:00",
        //         "volume": "1.0",
        //         "remaining_volume": "0.0",
        //         "reserved_fee": "26125.5",
        //         "remaining_fee": "25974.0",
        //         "paid_fee": "151.5",
        //         "locked": "17341974.0",
        //         "executed_volume": "1.0",
        //         "trades_count": 2,
        //         "trades": [
        //             {
        //                 "market": "KRW-BTC",
        //                 "uuid": "78162304-1a4d-4524-b9e6-c9a9e14d76c3",
        //                 "price": "101000.0",
        //                 "volume": "0.77368323",
        //                 "funds": "78142.00623",
        //                 "ask_fee": "117.213009345",
        //                 "bid_fee": "117.213009345",
        //                 "created_at": "2018-04-05T14:09:15+09:00",
        //                 "side": "bid"
        //             },
        //             {
        //                 "market": "KRW-BTC",
        //                 "uuid": "f73da467-c42f-407d-92fa-e10d86450a20",
        //                 "price": "101000.0",
        //                 "volume": "0.22631677",
        //                 "funds": "22857.99377",
        //                 "ask_fee": "34.286990655",
        //                 "bid_fee": "34.286990655",
        //                 "created_at": "2018-04-05T14:09:15+09:00",
        //                 "side": "bid"
        //             }
        //         ]
        //     }
        //
        return this.parseOrder(response);
    }

    /**
     * @method
     * @name upbit#fetchDepositAddresses
     * @see https://docs.upbit.com/reference/%EC%A0%84%EC%B2%B4-%EC%9E%85%EA%B8%88-%EC%A3%BC%EC%86%8C-%EC%A1%B0%ED%9A%8C
     * @description fetch deposit addresses for multiple currencies and chain types
     * @param {string[]|undefined} codes list of unified currency codes, default is undefined
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a list of [address structures]{@link https://docs.ccxt.com/#/?id=address-structure}
     */
    public async override Task<object> fetchDepositAddresses(object codes = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.privateGetDepositsCoinAddresses(parameters);
        //
        //     [
        //         {
        //             "currency": "BTC",
        //             "deposit_address": "3EusRwybuZUhVDeHL7gh3HSLmbhLcy7NqD",
        //             "secondary_address": null
        //         },
        //         {
        //             "currency": "ETH",
        //             "deposit_address": "0x0d73e0a482b8cf568976d2e8688f4a899d29301c",
        //             "secondary_address": null
        //         },
        //         {
        //             "currency": "XRP",
        //             "deposit_address": "rN9qNpgnBaZwqCg8CvUZRPqCcPPY7wfWep",
        //             "secondary_address": "3057887915"
        //         }
        //     ]
        //
        return this.parseDepositAddresses(response, codes);
    }

    public override object parseDepositAddress(object depositAddress, object currency = null)
    {
        //
        //    {
        //        currency: 'XRP',
        //        net_type: 'XRP',
        //        deposit_address: 'raQwCVAJVqjrVm1Nj5SFRcX8i22BhdC9WA',
        //        secondary_address: '167029435'
        //    }
        //
        object address = this.safeString(depositAddress, "deposit_address");
        object tag = this.safeString(depositAddress, "secondary_address");
        object currencyId = this.safeString(depositAddress, "currency");
        object code = this.safeCurrencyCode(currencyId);
        object networkId = this.safeString(depositAddress, "net_type");
        this.checkAddress(address);
        return new Dictionary<string, object>() {
            { "info", depositAddress },
            { "currency", code },
            { "network", this.networkIdToCode(networkId) },
            { "address", address },
            { "tag", tag },
        };
    }

    /**
     * @method
     * @name upbit#fetchDepositAddress
     * @see https://docs.upbit.com/reference/%EC%A0%84%EC%B2%B4-%EC%9E%85%EA%B8%88-%EC%A3%BC%EC%86%8C-%EC%A1%B0%ED%9A%8C
     * @description fetch the deposit address for a currency associated with this account
     * @param {string} code unified currency code
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} params.network deposit chain, can view all chains via this.publicGetWalletAssets, default is eth, unless the currency has a default chain within this.options['networks']
     * @returns {object} an [address structure]{@link https://docs.ccxt.com/#/?id=address-structure}
     */
    public async override Task<object> fetchDepositAddress(object code, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        object networkCode = null;
        var networkCodeparametersVariable = this.handleNetworkCodeAndParams(parameters);
        networkCode = ((IList<object>)networkCodeparametersVariable)[0];
        parameters = ((IList<object>)networkCodeparametersVariable)[1];
        if (isTrue(isEqual(networkCode, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchDepositAddress requires params[\"network\"]")) ;
        }
        object response = await this.privateGetDepositsCoinAddress(this.extend(new Dictionary<string, object>() {
            { "currency", getValue(currency, "id") },
            { "net_type", this.networkCodeToId(networkCode, getValue(currency, "code")) },
        }, parameters));
        //
        //    {
        //        currency: 'XRP',
        //        net_type: 'XRP',
        //        deposit_address: 'raQwCVAJVqjrVm1Nj5SFRcX8i22BhdC9WA',
        //        secondary_address: '167029435'
        //    }
        //
        return this.parseDepositAddress(response);
    }

    /**
     * @method
     * @name upbit#createDepositAddress
     * @see https://docs.upbit.com/reference/%EC%9E%85%EA%B8%88-%EC%A3%BC%EC%86%8C-%EC%83%9D%EC%84%B1-%EC%9A%94%EC%B2%AD
     * @description create a currency deposit address
     * @param {string} code unified currency code of the currency for the deposit address
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} an [address structure]{@link https://docs.ccxt.com/#/?id=address-structure}
     */
    public async override Task<object> createDepositAddress(object code, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "currency", getValue(currency, "id") },
        };
        // https://github.com/ccxt/ccxt/issues/6452
        object response = await this.privatePostDepositsGenerateCoinAddress(this.extend(request, parameters));
        //
        // https://docs.upbit.com/v1.0/reference#%EC%9E%85%EA%B8%88-%EC%A3%BC%EC%86%8C-%EC%83%9D%EC%84%B1-%EC%9A%94%EC%B2%AD
        // can be any of the two responses:
        //
        //     {
        //         "success" : true,
        //         "message" : "Creating BTC deposit address."
        //     }
        //
        //     {
        //         "currency": "BTC",
        //         "deposit_address": "3EusRwybuZUhVDeHL7gh3HSLmbhLcy7NqD",
        //         "secondary_address": null
        //     }
        //
        object message = this.safeString(response, "message");
        if (isTrue(!isEqual(message, null)))
        {
            throw new AddressPending ((string)add(add(add(this.id, " is generating "), code), " deposit address, call fetchDepositAddress or createDepositAddress one more time later to retrieve the generated address")) ;
        }
        return this.parseDepositAddress(response);
    }

    /**
     * @method
     * @name upbit#withdraw
     * @see https://docs.upbit.com/reference/디지털자산-출금하기
     * @see https://docs.upbit.com/reference/%EC%9B%90%ED%99%94-%EC%B6%9C%EA%B8%88%ED%95%98%EA%B8%B0
     * @description make a withdrawal
     * @param {string} code unified currency code
     * @param {float} amount the amount to withdraw
     * @param {string} address the address to withdraw to
     * @param {string} tag
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
     */
    public async override Task<object> withdraw(object code, object amount, object address, object tag = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        var tagparametersVariable = this.handleWithdrawTagAndParams(tag, parameters);
        tag = ((IList<object>)tagparametersVariable)[0];
        parameters = ((IList<object>)tagparametersVariable)[1];
        await this.loadMarkets();
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "amount", amount },
        };
        object response = null;
        if (isTrue(!isEqual(code, "KRW")))
        {
            this.checkAddress(address);
            // 2023-05-23 Change to required parameters for digital assets
            object network = this.safeStringUpper2(parameters, "network", "net_type");
            if (isTrue(isEqual(network, null)))
            {
                throw new ArgumentsRequired ((string)add(this.id, " withdraw() requires a network argument")) ;
            }
            parameters = this.omit(parameters, new List<object>() {"network"});
            ((IDictionary<string,object>)request)["net_type"] = network;
            ((IDictionary<string,object>)request)["currency"] = getValue(currency, "id");
            ((IDictionary<string,object>)request)["address"] = address;
            if (isTrue(!isEqual(tag, null)))
            {
                ((IDictionary<string,object>)request)["secondary_address"] = tag;
            }
            parameters = this.omit(parameters, "network");
            response = await this.privatePostWithdrawsCoin(this.extend(request, parameters));
        } else
        {
            response = await this.privatePostWithdrawsKrw(this.extend(request, parameters));
        }
        //
        //     {
        //         "type": "withdraw",
        //         "uuid": "9f432943-54e0-40b7-825f-b6fec8b42b79",
        //         "currency": "BTC",
        //         "txid": "ebe6937b-130e-4066-8ac6-4b0e67f28adc",
        //         "state": "processing",
        //         "created_at": "2018-04-13T11:24:01+09:00",
        //         "done_at": null,
        //         "amount": "0.01",
        //         "fee": "0.0",
        //         "krw_amount": "80420.0"
        //     }
        //
        return this.parseTransaction(response);
    }

    public override object nonce()
    {
        return this.milliseconds();
    }

    public override object sign(object path, object api = null, object method = null, object parameters = null, object headers = null, object body = null)
    {
        api ??= "public";
        method ??= "GET";
        parameters ??= new Dictionary<string, object>();
        object url = this.implodeParams(getValue(getValue(this.urls, "api"), api), new Dictionary<string, object>() {
            { "hostname", this.hostname },
        });
        url = add(url, add(add(add("/", this.version), "/"), this.implodeParams(path, parameters)));
        object query = this.omit(parameters, this.extractParams(path));
        if (isTrue(!isEqual(method, "POST")))
        {
            if (isTrue(getArrayLength(new List<object>(((IDictionary<string,object>)query).Keys))))
            {
                url = add(url, add("?", this.urlencode(query)));
            }
        }
        if (isTrue(isEqual(api, "private")))
        {
            this.checkRequiredCredentials();
            headers = new Dictionary<string, object>() {};
            object nonce = this.uuid();
            object request = new Dictionary<string, object>() {
                { "access_key", this.apiKey },
                { "nonce", nonce },
            };
            object hasQuery = getArrayLength(new List<object>(((IDictionary<string,object>)query).Keys));
            object auth = null;
            if (isTrue(isTrue((!isEqual(method, "GET"))) && isTrue((!isEqual(method, "DELETE")))))
            {
                body = this.json(parameters);
                ((IDictionary<string,object>)headers)["Content-Type"] = "application/json";
            }
            if (isTrue(hasQuery))
            {
                auth = this.rawencode(query);
            }
            if (isTrue(!isEqual(auth, null)))
            {
                object hash = this.hash(this.encode(auth), sha512);
                ((IDictionary<string,object>)request)["query_hash"] = hash;
                ((IDictionary<string,object>)request)["query_hash_alg"] = "SHA512";
            }
            object token = jwt(request, this.encode(this.secret), sha256);
            ((IDictionary<string,object>)headers)["Authorization"] = add("Bearer ", token);
        }
        return new Dictionary<string, object>() {
            { "url", url },
            { "method", method },
            { "body", body },
            { "headers", headers },
        };
    }

    public override object handleErrors(object httpCode, object reason, object url, object method, object headers, object body, object response, object requestHeaders, object requestBody)
    {
        if (isTrue(isEqual(response, null)))
        {
            return null;  // fallback to default error handler
        }
        //
        //   { 'error': { 'message': "Missing request parameter error. Check the required parameters!", 'name': 400 } },
        //   { 'error': { 'message': "side is missing, side does not have a valid value", 'name': "validation_error" } },
        //   { 'error': { 'message': "개인정보 제 3자 제공 동의가 필요합니다.", 'name': "thirdparty_agreement_required" } },
        //   { 'error': { 'message': "권한이 부족합니다.", 'name': "out_of_scope" } },
        //   { 'error': { 'message': "주문을 찾지 못했습니다.", 'name': "order_not_found" } },
        //   { 'error': { 'message': "주문가능한 금액(ETH)이 부족합니다.", 'name': "insufficient_funds_ask" } },
        //   { 'error': { 'message': "주문가능한 금액(BTC)이 부족합니다.", 'name': "insufficient_funds_bid" } },
        //   { 'error': { 'message': "잘못된 엑세스 키입니다.", 'name': "invalid_access_key" } },
        //   { 'error': { 'message': "Jwt 토큰 검증에 실패했습니다.", 'name': "jwt_verification" } }
        //
        object error = this.safeValue(response, "error");
        if (isTrue(!isEqual(error, null)))
        {
            object message = this.safeString(error, "message");
            object name = this.safeString(error, "name");
            object feedback = add(add(this.id, " "), body);
            this.throwExactlyMatchedException(getValue(this.exceptions, "exact"), message, feedback);
            this.throwExactlyMatchedException(getValue(this.exceptions, "exact"), name, feedback);
            this.throwBroadlyMatchedException(getValue(this.exceptions, "broad"), message, feedback);
            this.throwBroadlyMatchedException(getValue(this.exceptions, "broad"), name, feedback);
            throw new ExchangeError ((string)feedback) ;
        }
        return null;
    }
}
