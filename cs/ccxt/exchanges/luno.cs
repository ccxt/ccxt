namespace ccxt;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

public partial class luno : Exchange
{
    public override object describe()
    {
        return this.deepExtend(base.describe(), new Dictionary<string, object>() {
            { "id", "luno" },
            { "name", "luno" },
            { "countries", new List<object>() {"GB", "SG", "ZA"} },
            { "rateLimit", 200 },
            { "version", "1" },
            { "pro", true },
            { "has", new Dictionary<string, object>() {
                { "CORS", null },
                { "spot", true },
                { "margin", false },
                { "swap", false },
                { "future", false },
                { "option", false },
                { "addMargin", false },
                { "borrowCrossMargin", false },
                { "borrowIsolatedMargin", false },
                { "borrowMargin", false },
                { "cancelOrder", true },
                { "closeAllPositions", false },
                { "closePosition", false },
                { "createDepositAddress", true },
                { "createOrder", true },
                { "createReduceOnlyOrder", false },
                { "fetchAccounts", true },
                { "fetchAllGreeks", false },
                { "fetchBalance", true },
                { "fetchBorrowInterest", false },
                { "fetchBorrowRate", false },
                { "fetchBorrowRateHistories", false },
                { "fetchBorrowRateHistory", false },
                { "fetchBorrowRates", false },
                { "fetchBorrowRatesPerSymbol", false },
                { "fetchClosedOrders", true },
                { "fetchCrossBorrowRate", false },
                { "fetchCrossBorrowRates", false },
                { "fetchCurrencies", true },
                { "fetchDepositAddress", true },
                { "fetchFundingHistory", false },
                { "fetchFundingInterval", false },
                { "fetchFundingIntervals", false },
                { "fetchFundingRate", false },
                { "fetchFundingRateHistory", false },
                { "fetchFundingRates", false },
                { "fetchGreeks", false },
                { "fetchIndexOHLCV", false },
                { "fetchIsolatedBorrowRate", false },
                { "fetchIsolatedBorrowRates", false },
                { "fetchIsolatedPositions", false },
                { "fetchLedger", true },
                { "fetchLeverage", false },
                { "fetchLeverages", false },
                { "fetchLeverageTiers", false },
                { "fetchLiquidations", false },
                { "fetchLongShortRatio", false },
                { "fetchLongShortRatioHistory", false },
                { "fetchMarginAdjustmentHistory", false },
                { "fetchMarginMode", false },
                { "fetchMarginModes", false },
                { "fetchMarketLeverageTiers", false },
                { "fetchMarkets", true },
                { "fetchMarkOHLCV", false },
                { "fetchMarkPrice", false },
                { "fetchMarkPrices", false },
                { "fetchMyLiquidations", false },
                { "fetchMySettlementHistory", false },
                { "fetchMyTrades", true },
                { "fetchOHLCV", true },
                { "fetchOpenInterest", false },
                { "fetchOpenInterestHistory", false },
                { "fetchOpenInterests", false },
                { "fetchOpenOrders", true },
                { "fetchOption", false },
                { "fetchOptionChain", false },
                { "fetchOrder", true },
                { "fetchOrderBook", true },
                { "fetchOrders", true },
                { "fetchPosition", false },
                { "fetchPositionForSymbolWs", false },
                { "fetchPositionHistory", false },
                { "fetchPositionMode", false },
                { "fetchPositions", false },
                { "fetchPositionsForSymbol", false },
                { "fetchPositionsForSymbolWs", false },
                { "fetchPositionsHistory", false },
                { "fetchPositionsRisk", false },
                { "fetchPremiumIndexOHLCV", false },
                { "fetchSettlementHistory", false },
                { "fetchTicker", true },
                { "fetchTickers", true },
                { "fetchTrades", true },
                { "fetchTradingFee", true },
                { "fetchTradingFees", false },
                { "fetchUnderlyingAssets", false },
                { "fetchVolatilityHistory", false },
                { "reduceMargin", false },
                { "repayCrossMargin", false },
                { "repayIsolatedMargin", false },
                { "setLeverage", false },
                { "setMargin", false },
                { "setMarginMode", false },
                { "setPositionMode", false },
            } },
            { "urls", new Dictionary<string, object>() {
                { "referral", "https://www.luno.com/invite/44893A" },
                { "logo", "https://user-images.githubusercontent.com/1294454/27766607-8c1a69d8-5ede-11e7-930c-540b5eb9be24.jpg" },
                { "api", new Dictionary<string, object>() {
                    { "public", "https://api.luno.com/api" },
                    { "private", "https://api.luno.com/api" },
                    { "exchange", "https://api.luno.com/api/exchange" },
                    { "exchangePrivate", "https://api.luno.com/api/exchange" },
                } },
                { "www", "https://www.luno.com" },
                { "doc", new List<object>() {"https://www.luno.com/en/api", "https://npmjs.org/package/bitx", "https://github.com/bausmeier/node-bitx"} },
            } },
            { "api", new Dictionary<string, object>() {
                { "exchange", new Dictionary<string, object>() {
                    { "get", new Dictionary<string, object>() {
                        { "markets", 1 },
                    } },
                } },
                { "exchangePrivate", new Dictionary<string, object>() {
                    { "get", new Dictionary<string, object>() {
                        { "candles", 1 },
                    } },
                } },
                { "public", new Dictionary<string, object>() {
                    { "get", new Dictionary<string, object>() {
                        { "orderbook", 1 },
                        { "orderbook_top", 1 },
                        { "ticker", 1 },
                        { "tickers", 1 },
                        { "trades", 1 },
                    } },
                } },
                { "private", new Dictionary<string, object>() {
                    { "get", new Dictionary<string, object>() {
                        { "accounts/{id}/pending", 1 },
                        { "accounts/{id}/transactions", 1 },
                        { "balance", 1 },
                        { "beneficiaries", 1 },
                        { "send/networks", 1 },
                        { "fee_info", 1 },
                        { "funding_address", 1 },
                        { "listorders", 1 },
                        { "listtrades", 1 },
                        { "send_fee", 1 },
                        { "orders/{id}", 1 },
                        { "withdrawals", 1 },
                        { "withdrawals/{id}", 1 },
                        { "transfers", 1 },
                    } },
                    { "post", new Dictionary<string, object>() {
                        { "accounts", 1 },
                        { "address/validate", 1 },
                        { "postorder", 1 },
                        { "marketorder", 1 },
                        { "stoporder", 1 },
                        { "funding_address", 1 },
                        { "withdrawals", 1 },
                        { "send", 1 },
                        { "oauth2/grant", 1 },
                        { "beneficiaries", 1 },
                    } },
                    { "put", new Dictionary<string, object>() {
                        { "accounts/{id}/name", 1 },
                    } },
                    { "delete", new Dictionary<string, object>() {
                        { "withdrawals/{id}", 1 },
                        { "beneficiaries/{id}", 1 },
                    } },
                } },
            } },
            { "timeframes", new Dictionary<string, object>() {
                { "1m", 60 },
                { "5m", 300 },
                { "15m", 900 },
                { "30m", 1800 },
                { "1h", 3600 },
                { "3h", 10800 },
                { "4h", 14400 },
                { "1d", 86400 },
                { "3d", 259200 },
                { "1w", 604800 },
            } },
            { "fees", new Dictionary<string, object>() {
                { "trading", new Dictionary<string, object>() {
                    { "tierBased", true },
                    { "percentage", true },
                    { "taker", this.parseNumber("0.001") },
                    { "maker", this.parseNumber("0") },
                } },
            } },
            { "precisionMode", TICK_SIZE },
            { "features", new Dictionary<string, object>() {
                { "spot", new Dictionary<string, object>() {
                    { "sandbox", false },
                    { "fetchCurrencies", new Dictionary<string, object>() {
                        { "private", true },
                    } },
                    { "createOrder", new Dictionary<string, object>() {
                        { "marginMode", false },
                        { "triggerPrice", true },
                        { "triggerPriceType", null },
                        { "triggerDirection", true },
                        { "stopLossPrice", false },
                        { "takeProfitPrice", false },
                        { "attachedStopLossTakeProfit", null },
                        { "timeInForce", new Dictionary<string, object>() {
                            { "IOC", true },
                            { "FOK", true },
                            { "PO", true },
                            { "GTD", false },
                        } },
                        { "hedged", false },
                        { "trailing", false },
                        { "leverage", false },
                        { "marketBuyByCost", true },
                        { "marketBuyRequiresPrice", false },
                        { "selfTradePrevention", false },
                        { "iceberg", false },
                    } },
                    { "createOrders", null },
                    { "fetchMyTrades", new Dictionary<string, object>() {
                        { "marginMode", false },
                        { "limit", 1000 },
                        { "daysBack", 100000 },
                        { "untilDays", 100000 },
                        { "symbolRequired", true },
                    } },
                    { "fetchOrder", new Dictionary<string, object>() {
                        { "marginMode", false },
                        { "trigger", false },
                        { "trailing", false },
                        { "symbolRequired", false },
                    } },
                    { "fetchOpenOrders", new Dictionary<string, object>() {
                        { "marginMode", false },
                        { "limit", 1000 },
                        { "trigger", false },
                        { "trailing", false },
                        { "symbolRequired", false },
                    } },
                    { "fetchOrders", new Dictionary<string, object>() {
                        { "marginMode", false },
                        { "limit", 1000 },
                        { "daysBack", 100000 },
                        { "untilDays", null },
                        { "trigger", false },
                        { "trailing", false },
                        { "symbolRequired", false },
                    } },
                    { "fetchClosedOrders", new Dictionary<string, object>() {
                        { "marginMode", false },
                        { "limit", 1000 },
                        { "daysBack", 100000 },
                        { "daysBackCanceled", 1 },
                        { "untilDays", null },
                        { "trigger", false },
                        { "trailing", false },
                        { "symbolRequired", false },
                    } },
                    { "fetchOHLCV", new Dictionary<string, object>() {
                        { "limit", null },
                    } },
                } },
                { "swap", new Dictionary<string, object>() {
                    { "linear", null },
                    { "inverse", null },
                } },
                { "future", new Dictionary<string, object>() {
                    { "linear", null },
                    { "inverse", null },
                } },
            } },
        });
    }

    /**
     * @method
     * @name luno#fetchCurrencies
     * @description fetches all available currencies on an exchange
     * @param {dict} [params] extra parameters specific to the exchange API endpoint
     * @returns {dict} an associative dictionary of currencies
     */
    public async override Task<object> fetchCurrencies(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (!isTrue(this.checkRequiredCredentials(false)))
        {
            return new Dictionary<string, object>() {};
        }
        object response = await this.privateGetSendNetworks(parameters);
        //
        //     {
        //         "networks": [
        //           {
        //             "id": 0,
        //             "name": "Ethereum",
        //             "native_currency": "ETH"
        //           },
        //           ...
        //         ]
        //     }
        //
        object currenciesData = this.safeList(response, "data", new List<object>() {});
        object result = new Dictionary<string, object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(currenciesData)); postFixIncrement(ref i))
        {
            object networkEntry = getValue(currenciesData, i);
            object id = this.safeString(networkEntry, "native_currency");
            object code = this.safeCurrencyCode(id);
            if (!isTrue((inOp(result, code))))
            {
                ((IDictionary<string,object>)result)[(string)code] = new Dictionary<string, object>() {
                    { "id", id },
                    { "code", code },
                    { "precision", null },
                    { "type", null },
                    { "name", null },
                    { "active", null },
                    { "deposit", null },
                    { "withdraw", null },
                    { "fee", null },
                    { "limits", new Dictionary<string, object>() {
                        { "withdraw", new Dictionary<string, object>() {
                            { "min", null },
                            { "max", null },
                        } },
                        { "deposit", new Dictionary<string, object>() {
                            { "min", null },
                            { "max", null },
                        } },
                    } },
                    { "networks", new Dictionary<string, object>() {} },
                    { "info", new Dictionary<string, object>() {} },
                };
            }
            object networkId = this.safeString(networkEntry, "name");
            object networkCode = this.networkIdToCode(networkId);
            ((IDictionary<string,object>)getValue(getValue(result, code), "networks"))[(string)networkCode] = new Dictionary<string, object>() {
                { "id", networkId },
                { "network", networkCode },
                { "limits", new Dictionary<string, object>() {
                    { "withdraw", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                    { "deposit", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                } },
                { "active", null },
                { "deposit", null },
                { "withdraw", null },
                { "fee", null },
                { "precision", null },
                { "info", networkEntry },
            };
            // add entry in info
            object info = this.safeList(getValue(result, code), "info", new List<object>() {});
            ((IList<object>)info).Add(networkEntry);
            ((IDictionary<string,object>)getValue(result, code))["info"] = info;
        }
        // only after all entries are formed in currencies, restructure each entry
        object allKeys = new List<object>(((IDictionary<string,object>)result).Keys);
        for (object i = 0; isLessThan(i, getArrayLength(allKeys)); postFixIncrement(ref i))
        {
            object code = getValue(allKeys, i);
            ((IDictionary<string,object>)result)[(string)code] = this.safeCurrencyStructure(getValue(result, code)); // this is needed after adding network entry
        }
        return result;
    }

    /**
     * @method
     * @name luno#fetchMarkets
     * @description retrieves data on all markets for luno
     * @see https://www.luno.com/en/developers/api#tag/Market/operation/Markets
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} an array of objects representing market data
     */
    public async override Task<object> fetchMarkets(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object response = await this.exchangeGetMarkets(parameters);
        //
        //     {
        //         "markets":[
        //             {
        //                 "market_id":"BCHXBT",
        //                 "trading_status":"ACTIVE",
        //                 "base_currency":"BCH",
        //                 "counter_currency":"XBT",
        //                 "min_volume":"0.01",
        //                 "max_volume":"100.00",
        //                 "volume_scale":2,
        //                 "min_price":"0.0001",
        //                 "max_price":"1.00",
        //                 "price_scale":6,
        //                 "fee_scale":8,
        //             },
        //         ]
        //     }
        //
        object result = new List<object>() {};
        object markets = this.safeValue(response, "markets", new List<object>() {});
        for (object i = 0; isLessThan(i, getArrayLength(markets)); postFixIncrement(ref i))
        {
            object market = getValue(markets, i);
            object id = this.safeString(market, "market_id");
            object baseId = this.safeString(market, "base_currency");
            object quoteId = this.safeString(market, "counter_currency");
            object bs = this.safeCurrencyCode(baseId);
            object quote = this.safeCurrencyCode(quoteId);
            object status = this.safeString(market, "trading_status");
            ((IList<object>)result).Add(new Dictionary<string, object>() {
                { "id", id },
                { "symbol", add(add(bs, "/"), quote) },
                { "base", bs },
                { "quote", quote },
                { "settle", null },
                { "baseId", baseId },
                { "quoteId", quoteId },
                { "settleId", null },
                { "type", "spot" },
                { "spot", true },
                { "margin", false },
                { "swap", false },
                { "future", false },
                { "option", false },
                { "active", (isEqual(status, "ACTIVE")) },
                { "contract", false },
                { "linear", null },
                { "inverse", null },
                { "contractSize", null },
                { "expiry", null },
                { "expiryDatetime", null },
                { "strike", null },
                { "optionType", null },
                { "precision", new Dictionary<string, object>() {
                    { "amount", this.parseNumber(this.parsePrecision(this.safeString(market, "volume_scale"))) },
                    { "price", this.parseNumber(this.parsePrecision(this.safeString(market, "price_scale"))) },
                } },
                { "limits", new Dictionary<string, object>() {
                    { "leverage", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                    { "amount", new Dictionary<string, object>() {
                        { "min", this.safeNumber(market, "min_volume") },
                        { "max", this.safeNumber(market, "max_volume") },
                    } },
                    { "price", new Dictionary<string, object>() {
                        { "min", this.safeNumber(market, "min_price") },
                        { "max", this.safeNumber(market, "max_price") },
                    } },
                    { "cost", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                } },
                { "created", null },
                { "info", market },
            });
        }
        return result;
    }

    /**
     * @method
     * @name luno#fetchAccounts
     * @description fetch all the accounts associated with a profile
     * @see https://www.luno.com/en/developers/api#tag/Accounts/operation/getBalances
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a dictionary of [account structures]{@link https://docs.ccxt.com/#/?id=account-structure} indexed by the account type
     */
    public async override Task<object> fetchAccounts(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object response = await this.privateGetBalance(parameters);
        object wallets = this.safeValue(response, "balance", new List<object>() {});
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(wallets)); postFixIncrement(ref i))
        {
            object account = getValue(wallets, i);
            object accountId = this.safeString(account, "account_id");
            object currencyId = this.safeString(account, "asset");
            object code = this.safeCurrencyCode(currencyId);
            ((IList<object>)result).Add(new Dictionary<string, object>() {
                { "id", accountId },
                { "type", null },
                { "currency", code },
                { "info", account },
            });
        }
        return result;
    }

    public override object parseBalance(object response)
    {
        object wallets = this.safeValue(response, "balance", new List<object>() {});
        object result = new Dictionary<string, object>() {
            { "info", response },
            { "timestamp", null },
            { "datetime", null },
        };
        for (object i = 0; isLessThan(i, getArrayLength(wallets)); postFixIncrement(ref i))
        {
            object wallet = getValue(wallets, i);
            object currencyId = this.safeString(wallet, "asset");
            object code = this.safeCurrencyCode(currencyId);
            object reserved = this.safeString(wallet, "reserved");
            object unconfirmed = this.safeString(wallet, "unconfirmed");
            object balance = this.safeString(wallet, "balance");
            object reservedUnconfirmed = Precise.stringAdd(reserved, unconfirmed);
            object balanceUnconfirmed = Precise.stringAdd(balance, unconfirmed);
            if (isTrue(inOp(result, code)))
            {
                ((IDictionary<string,object>)getValue(result, code))["used"] = Precise.stringAdd(getValue(getValue(result, code), "used"), reservedUnconfirmed);
                ((IDictionary<string,object>)getValue(result, code))["total"] = Precise.stringAdd(getValue(getValue(result, code), "total"), balanceUnconfirmed);
            } else
            {
                object account = this.account();
                ((IDictionary<string,object>)account)["used"] = reservedUnconfirmed;
                ((IDictionary<string,object>)account)["total"] = balanceUnconfirmed;
                ((IDictionary<string,object>)result)[(string)code] = account;
            }
        }
        return this.safeBalance(result);
    }

    /**
     * @method
     * @name luno#fetchBalance
     * @description query for balance and get the amount of funds available for trading or funds locked in orders
     * @see https://www.luno.com/en/developers/api#tag/Accounts/operation/getBalances
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
     */
    public async override Task<object> fetchBalance(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.privateGetBalance(parameters);
        //
        //     {
        //         "balance": [
        //             {'account_id': '119...1336','asset': 'XBT','balance': '0.00','reserved': '0.00',"unconfirmed": "0.00"},
        //             {'account_id': '66...289','asset': 'XBT','balance': '0.00','reserved': '0.00',"unconfirmed": "0.00"},
        //             {'account_id': '718...5300','asset': 'ETH','balance': '0.00','reserved': '0.00',"unconfirmed": "0.00"},
        //             {'account_id': '818...7072','asset': 'ZAR','balance': '0.001417','reserved': '0.00',"unconfirmed": "0.00"}]}
        //         ]
        //     }
        //
        return this.parseBalance(response);
    }

    /**
     * @method
     * @name luno#fetchOrderBook
     * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
     * @see https://www.luno.com/en/developers/api#tag/Market/operation/GetOrderBookFull
     * @see https://www.luno.com/en/developers/api#tag/Market/operation/GetOrderBook
     * @param {string} symbol unified symbol of the market to fetch the order book for
     * @param {int} [limit] the maximum amount of order book entries to return
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
     */
    public async override Task<object> fetchOrderBook(object symbol, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "pair", getValue(market, "id") },
        };
        object response = null;
        if (isTrue(isTrue(!isEqual(limit, null)) && isTrue(isLessThanOrEqual(limit, 100))))
        {
            response = await this.publicGetOrderbookTop(this.extend(request, parameters));
        } else
        {
            response = await this.publicGetOrderbook(this.extend(request, parameters));
        }
        object timestamp = this.safeInteger(response, "timestamp");
        return this.parseOrderBook(response, getValue(market, "symbol"), timestamp, "bids", "asks", "price", "volume");
    }

    public virtual object parseOrderStatus(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "PENDING", "open" },
        };
        return this.safeString(statuses, status, status);
    }

    public override object parseOrder(object order, object market = null)
    {
        //
        //     {
        //         "base": "string",
        //         "completed_timestamp": "string",
        //         "counter": "string",
        //         "creation_timestamp": "string",
        //         "expiration_timestamp": "string",
        //         "fee_base": "string",
        //         "fee_counter": "string",
        //         "limit_price": "string",
        //         "limit_volume": "string",
        //         "order_id": "string",
        //         "pair": "string",
        //         "state": "PENDING",
        //         "type": "BID"
        //     }
        //
        object timestamp = this.safeInteger(order, "creation_timestamp");
        object status = this.parseOrderStatus(this.safeString(order, "state"));
        status = ((bool) isTrue((isEqual(status, "open")))) ? status : status;
        object side = null;
        object orderType = this.safeString(order, "type");
        if (isTrue(isTrue((isEqual(orderType, "ASK"))) || isTrue((isEqual(orderType, "SELL")))))
        {
            side = "sell";
        } else if (isTrue(isTrue((isEqual(orderType, "BID"))) || isTrue((isEqual(orderType, "BUY")))))
        {
            side = "buy";
        }
        object marketId = this.safeString(order, "pair");
        market = this.safeMarket(marketId, market);
        object price = this.safeString(order, "limit_price");
        object amount = this.safeString(order, "limit_volume");
        object quoteFee = this.safeNumber(order, "fee_counter");
        object baseFee = this.safeNumber(order, "fee_base");
        object filled = this.safeString(order, "base");
        object cost = this.safeString(order, "counter");
        object fee = null;
        if (isTrue(!isEqual(quoteFee, null)))
        {
            fee = new Dictionary<string, object>() {
                { "cost", quoteFee },
                { "currency", getValue(market, "quote") },
            };
        } else if (isTrue(!isEqual(baseFee, null)))
        {
            fee = new Dictionary<string, object>() {
                { "cost", baseFee },
                { "currency", getValue(market, "base") },
            };
        }
        object id = this.safeString(order, "order_id");
        return this.safeOrder(new Dictionary<string, object>() {
            { "id", id },
            { "clientOrderId", null },
            { "datetime", this.iso8601(timestamp) },
            { "timestamp", timestamp },
            { "lastTradeTimestamp", null },
            { "status", status },
            { "symbol", getValue(market, "symbol") },
            { "type", null },
            { "timeInForce", null },
            { "postOnly", null },
            { "side", side },
            { "price", price },
            { "triggerPrice", null },
            { "amount", amount },
            { "filled", filled },
            { "cost", cost },
            { "remaining", null },
            { "trades", null },
            { "fee", fee },
            { "info", order },
            { "average", null },
        }, market);
    }

    /**
     * @method
     * @name luno#fetchOrder
     * @description fetches information on an order made by the user
     * @see https://www.luno.com/en/developers/api#tag/Orders/operation/GetOrder
     * @param {string} id order id
     * @param {string} symbol not used by luno fetchOrder
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> fetchOrder(object id, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {
            { "id", id },
        };
        object response = await this.privateGetOrdersId(this.extend(request, parameters));
        return this.parseOrder(response);
    }

    public async virtual Task<object> fetchOrdersByState(object state, object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object market = null;
        if (isTrue(!isEqual(state, null)))
        {
            ((IDictionary<string,object>)request)["state"] = state;
        }
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            ((IDictionary<string,object>)request)["pair"] = getValue(market, "id");
        }
        object response = await this.privateGetListorders(this.extend(request, parameters));
        object orders = this.safeList(response, "orders", new List<object>() {});
        return this.parseOrders(orders, market, since, limit);
    }

    /**
     * @method
     * @name luno#fetchOrders
     * @description fetches information on multiple orders made by the user
     * @see https://www.luno.com/en/developers/api#tag/Orders/operation/ListOrders
     * @param {string} symbol unified market symbol of the market orders were made in
     * @param {int} [since] the earliest time in ms to fetch orders for
     * @param {int} [limit] the maximum number of order structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> fetchOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        return await this.fetchOrdersByState(null, symbol, since, limit, parameters);
    }

    /**
     * @method
     * @name luno#fetchOpenOrders
     * @description fetch all unfilled currently open orders
     * @see https://www.luno.com/en/developers/api#tag/Orders/operation/ListOrders
     * @param {string} symbol unified market symbol
     * @param {int} [since] the earliest time in ms to fetch open orders for
     * @param {int} [limit] the maximum number of  open orders structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> fetchOpenOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        return await this.fetchOrdersByState("PENDING", symbol, since, limit, parameters);
    }

    /**
     * @method
     * @name luno#fetchClosedOrders
     * @description fetches information on multiple closed orders made by the user
     * @see https://www.luno.com/en/developers/api#tag/Orders/operation/ListOrders
     * @param {string} symbol unified market symbol of the market orders were made in
     * @param {int} [since] the earliest time in ms to fetch orders for
     * @param {int} [limit] the maximum number of order structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> fetchClosedOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        return await this.fetchOrdersByState("COMPLETE", symbol, since, limit, parameters);
    }

    public override object parseTicker(object ticker, object market = null)
    {
        // {
        //     "pair":"XBTAUD",
        //     "timestamp":1642201439301,
        //     "bid":"59972.30000000",
        //     "ask":"59997.99000000",
        //     "last_trade":"59997.99000000",
        //     "rolling_24_hour_volume":"1.89510000",
        //     "status":"ACTIVE"
        // }
        object timestamp = this.safeInteger(ticker, "timestamp");
        object marketId = this.safeString(ticker, "pair");
        object symbol = this.safeSymbol(marketId, market);
        object last = this.safeString(ticker, "last_trade");
        return this.safeTicker(new Dictionary<string, object>() {
            { "symbol", symbol },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "high", null },
            { "low", null },
            { "bid", this.safeString(ticker, "bid") },
            { "bidVolume", null },
            { "ask", this.safeString(ticker, "ask") },
            { "askVolume", null },
            { "vwap", null },
            { "open", null },
            { "close", last },
            { "last", last },
            { "previousClose", null },
            { "change", null },
            { "percentage", null },
            { "average", null },
            { "baseVolume", this.safeString(ticker, "rolling_24_hour_volume") },
            { "quoteVolume", null },
            { "info", ticker },
        }, market);
    }

    /**
     * @method
     * @name luno#fetchTickers
     * @description fetches price tickers for multiple markets, statistical information calculated over the past 24 hours for each market
     * @see https://www.luno.com/en/developers/api#tag/Market/operation/GetTickers
     * @param {string[]|undefined} symbols unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/#/?id=ticker-structure}
     */
    public async override Task<object> fetchTickers(object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        symbols = this.marketSymbols(symbols);
        object response = await this.publicGetTickers(parameters);
        object tickers = this.indexBy(getValue(response, "tickers"), "pair");
        object ids = new List<object>(((IDictionary<string,object>)tickers).Keys);
        object result = new Dictionary<string, object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(ids)); postFixIncrement(ref i))
        {
            object id = getValue(ids, i);
            object market = this.safeMarket(id);
            object symbol = getValue(market, "symbol");
            object ticker = getValue(tickers, id);
            ((IDictionary<string,object>)result)[(string)symbol] = this.parseTicker(ticker, market);
        }
        return this.filterByArrayTickers(result, "symbol", symbols);
    }

    /**
     * @method
     * @name luno#fetchTicker
     * @description fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
     * @see https://www.luno.com/en/developers/api#tag/Market/operation/GetTicker
     * @param {string} symbol unified symbol of the market to fetch the ticker for
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
     */
    public async override Task<object> fetchTicker(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "pair", getValue(market, "id") },
        };
        object response = await this.publicGetTicker(this.extend(request, parameters));
        // {
        //     "pair":"XBTAUD",
        //     "timestamp":1642201439301,
        //     "bid":"59972.30000000",
        //     "ask":"59997.99000000",
        //     "last_trade":"59997.99000000",
        //     "rolling_24_hour_volume":"1.89510000",
        //     "status":"ACTIVE"
        // }
        return this.parseTicker(response, market);
    }

    public override object parseTrade(object trade, object market = null)
    {
        //
        // fetchTrades (public)
        //
        //      {
        //          "sequence":276989,
        //          "timestamp":1648651276949,
        //          "price":"35773.20000000",
        //          "volume":"0.00300000",
        //          "is_buy":false
        //      }
        //
        // fetchMyTrades (private)
        //
        //      {
        //          "pair":"LTCXBT",
        //          "sequence":3256813,
        //          "order_id":"BXEX6XHHDT5EGW2",
        //          "type":"ASK",
        //          "timestamp":1648652135235,
        //          "price":"0.002786",
        //          "volume":"0.10",
        //          "base":"0.10",
        //          "counter":"0.0002786",
        //          "fee_base":"0.0001",
        //          "fee_counter":"0.00",
        //          "is_buy":false,
        //          "client_order_id":""
        //      }
        //
        // For public trade data (is_buy === True) indicates 'buy' side but for private trade data
        // is_buy indicates maker or taker. The value of "type" (ASK/BID) indicate sell/buy side.
        // Private trade data includes ID field which public trade data does not.
        object orderId = this.safeString(trade, "order_id");
        object id = this.safeString(trade, "sequence");
        object takerOrMaker = null;
        object side = null;
        if (isTrue(!isEqual(orderId, null)))
        {
            object type = this.safeString(trade, "type");
            if (isTrue(isTrue((isEqual(type, "ASK"))) || isTrue((isEqual(type, "SELL")))))
            {
                side = "sell";
            } else if (isTrue(isTrue((isEqual(type, "BID"))) || isTrue((isEqual(type, "BUY")))))
            {
                side = "buy";
            }
            if (isTrue(isTrue(isEqual(side, "sell")) && isTrue(getValue(trade, "is_buy"))))
            {
                takerOrMaker = "maker";
            } else if (isTrue(isTrue(isEqual(side, "buy")) && !isTrue(getValue(trade, "is_buy"))))
            {
                takerOrMaker = "maker";
            } else
            {
                takerOrMaker = "taker";
            }
        } else
        {
            side = ((bool) isTrue(getValue(trade, "is_buy"))) ? "buy" : "sell";
        }
        object feeBaseString = this.safeString(trade, "fee_base");
        object feeCounterString = this.safeString(trade, "fee_counter");
        object feeCurrency = null;
        object feeCost = null;
        if (isTrue(!isEqual(feeBaseString, null)))
        {
            if (!isTrue(Precise.stringEquals(feeBaseString, "0.0")))
            {
                feeCurrency = getValue(market, "base");
                feeCost = feeBaseString;
            }
        } else if (isTrue(!isEqual(feeCounterString, null)))
        {
            if (!isTrue(Precise.stringEquals(feeCounterString, "0.0")))
            {
                feeCurrency = getValue(market, "quote");
                feeCost = feeCounterString;
            }
        }
        object timestamp = this.safeInteger(trade, "timestamp");
        return this.safeTrade(new Dictionary<string, object>() {
            { "info", trade },
            { "id", id },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "symbol", getValue(market, "symbol") },
            { "order", orderId },
            { "type", null },
            { "side", side },
            { "takerOrMaker", takerOrMaker },
            { "price", this.safeString(trade, "price") },
            { "amount", this.safeString2(trade, "volume", "base") },
            { "cost", this.safeString(trade, "counter") },
            { "fee", new Dictionary<string, object>() {
                { "cost", feeCost },
                { "currency", feeCurrency },
            } },
        }, market);
    }

    /**
     * @method
     * @name luno#fetchTrades
     * @description get the list of most recent trades for a particular symbol
     * @see https://www.luno.com/en/developers/api#tag/Market/operation/ListTrades
     * @param {string} symbol unified symbol of the market to fetch trades for
     * @param {int} [since] timestamp in ms of the earliest trade to fetch
     * @param {int} [limit] the maximum amount of trades to fetch
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
     */
    public async override Task<object> fetchTrades(object symbol, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "pair", getValue(market, "id") },
        };
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["since"] = since;
        }
        object response = await this.publicGetTrades(this.extend(request, parameters));
        //
        //      {
        //          "trades":[
        //              {
        //                  "sequence":276989,
        //                  "timestamp":1648651276949,
        //                  "price":"35773.20000000",
        //                  "volume":"0.00300000",
        //                  "is_buy":false
        //              },...
        //          ]
        //      }
        //
        object trades = this.safeList(response, "trades", new List<object>() {});
        return this.parseTrades(trades, market, since, limit);
    }

    /**
     * @method
     * @name luno#fetchOHLCV
     * @see https://www.luno.com/en/developers/api#tag/Market/operation/GetCandles
     * @description fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
     * @param {string} symbol unified symbol of the market to fetch OHLCV data for
     * @param {string} timeframe the length of time each candle represents
     * @param {int} [since] timestamp in ms of the earliest candle to fetch
     * @param {int} [limit] the maximum amount of candles to fetch
     * @param {object} params extra parameters specific to the luno api endpoint
     * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
     */
    public async override Task<object> fetchOHLCV(object symbol, object timeframe = null, object since = null, object limit = null, object parameters = null)
    {
        timeframe ??= "1m";
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "duration", this.safeValue(this.timeframes, timeframe, timeframe) },
            { "pair", getValue(market, "id") },
        };
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["since"] = this.parseToInt(since);
        } else
        {
            object duration = multiply(multiply(1000, 1000), this.parseTimeframe(timeframe));
            ((IDictionary<string,object>)request)["since"] = subtract(this.milliseconds(), duration);
        }
        object response = await this.exchangePrivateGetCandles(this.extend(request, parameters));
        //
        //     {
        //          "candles": [
        //              {
        //                  "timestamp": 1664055240000,
        //                  "open": "19612.65",
        //                  "close": "19612.65",
        //                  "high": "19612.65",
        //                  "low": "19612.65",
        //                  "volume": "0.00"
        //              },...
        //          ],
        //          "duration": 60,
        //          "pair": "XBTEUR"
        //     }
        //
        object ohlcvs = this.safeList(response, "candles", new List<object>() {});
        return this.parseOHLCVs(ohlcvs, market, timeframe, since, limit);
    }

    public override object parseOHLCV(object ohlcv, object market = null)
    {
        // {
        //     "timestamp": 1664055240000,
        //     "open": "19612.65",
        //     "close": "19612.65",
        //     "high": "19612.65",
        //     "low": "19612.65",
        //     "volume": "0.00"
        // }
        return new List<object> {this.safeInteger(ohlcv, "timestamp"), this.safeNumber(ohlcv, "open"), this.safeNumber(ohlcv, "high"), this.safeNumber(ohlcv, "low"), this.safeNumber(ohlcv, "close"), this.safeNumber(ohlcv, "volume")};
    }

    /**
     * @method
     * @name luno#fetchMyTrades
     * @description fetch all trades made by the user
     * @see https://www.luno.com/en/developers/api#tag/Orders/operation/ListUserTrades
     * @param {string} symbol unified market symbol
     * @param {int} [since] the earliest time in ms to fetch trades for
     * @param {int} [limit] the maximum number of trades structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
     */
    public async override Task<object> fetchMyTrades(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchMyTrades() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "pair", getValue(market, "id") },
        };
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["since"] = since;
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        object response = await this.privateGetListtrades(this.extend(request, parameters));
        //
        //      {
        //          "trades":[
        //              {
        //                  "pair":"LTCXBT",
        //                  "sequence":3256813,
        //                  "order_id":"BXEX6XHHDT5EGW2",
        //                  "type":"ASK",
        //                  "timestamp":1648652135235,
        //                  "price":"0.002786",
        //                  "volume":"0.10",
        //                  "base":"0.10",
        //                  "counter":"0.0002786",
        //                  "fee_base":"0.0001",
        //                  "fee_counter":"0.00",
        //                  "is_buy":false,
        //                  "client_order_id":""
        //              },...
        //          ]
        //      }
        //
        object trades = this.safeList(response, "trades", new List<object>() {});
        return this.parseTrades(trades, market, since, limit);
    }

    /**
     * @method
     * @name luno#fetchTradingFee
     * @description fetch the trading fees for a market
     * @see https://www.luno.com/en/developers/api#tag/Orders/operation/getFeeInfo
     * @param {string} symbol unified market symbol
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [fee structure]{@link https://docs.ccxt.com/#/?id=fee-structure}
     */
    public async override Task<object> fetchTradingFee(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "pair", getValue(market, "id") },
        };
        object response = await this.privateGetFeeInfo(this.extend(request, parameters));
        //
        //     {
        //          "maker_fee": "0.00250000",
        //          "taker_fee": "0.00500000",
        //          "thirty_day_volume": "0"
        //     }
        //
        return new Dictionary<string, object>() {
            { "info", response },
            { "symbol", symbol },
            { "maker", this.safeNumber(response, "maker_fee") },
            { "taker", this.safeNumber(response, "taker_fee") },
            { "percentage", null },
            { "tierBased", null },
        };
    }

    /**
     * @method
     * @name luno#createOrder
     * @description create a trade order
     * @see https://www.luno.com/en/developers/api#tag/Orders/operation/PostMarketOrder
     * @see https://www.luno.com/en/developers/api#tag/Orders/operation/PostLimitOrder
     * @param {string} symbol unified symbol of the market to create an order in
     * @param {string} type 'market' or 'limit'
     * @param {string} side 'buy' or 'sell'
     * @param {float} amount how much of currency you want to trade in units of base currency
     * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> createOrder(object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "pair", getValue(market, "id") },
        };
        object response = null;
        if (isTrue(isEqual(type, "market")))
        {
            ((IDictionary<string,object>)request)["type"] = ((string)side).ToUpper();
            // todo add createMarketBuyOrderRequires price logic as it is implemented in the other exchanges
            if (isTrue(isEqual(side, "buy")))
            {
                ((IDictionary<string,object>)request)["counter_volume"] = this.amountToPrecision(getValue(market, "symbol"), amount);
            } else
            {
                ((IDictionary<string,object>)request)["base_volume"] = this.amountToPrecision(getValue(market, "symbol"), amount);
            }
            response = await this.privatePostMarketorder(this.extend(request, parameters));
        } else
        {
            ((IDictionary<string,object>)request)["volume"] = this.amountToPrecision(getValue(market, "symbol"), amount);
            ((IDictionary<string,object>)request)["price"] = this.priceToPrecision(getValue(market, "symbol"), price);
            ((IDictionary<string,object>)request)["type"] = ((bool) isTrue((isEqual(side, "buy")))) ? "BID" : "ASK";
            response = await this.privatePostPostorder(this.extend(request, parameters));
        }
        return this.safeOrder(new Dictionary<string, object>() {
            { "info", response },
            { "id", getValue(response, "order_id") },
        }, market);
    }

    /**
     * @method
     * @name luno#cancelOrder
     * @description cancels an open order
     * @see https://www.luno.com/en/developers/api#tag/Orders/operation/StopOrder
     * @param {string} id order id
     * @param {string} symbol unified symbol of the market the order was made in
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> cancelOrder(object id, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {
            { "order_id", id },
        };
        object response = await this.privatePostStoporder(this.extend(request, parameters));
        //
        //    {
        //        "success": true
        //    }
        //
        return this.safeOrder(new Dictionary<string, object>() {
            { "info", response },
        });
    }

    public async virtual Task<object> fetchLedgerByEntries(object code = null, object entry = null, object limit = null, object parameters = null)
    {
        // by default without entry number or limit number, return most recent entry
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(entry, null)))
        {
            entry = -1;
        }
        if (isTrue(isEqual(limit, null)))
        {
            limit = 1;
        }
        object since = null;
        object request = new Dictionary<string, object>() {
            { "min_row", entry },
            { "max_row", this.sum(entry, limit) },
        };
        return await this.fetchLedger(code, since, limit, this.extend(request, parameters));
    }

    /**
     * @method
     * @name luno#fetchLedger
     * @description fetch the history of changes, actions done by the user or operations that altered the balance of the user
     * @see https://www.luno.com/en/developers/api#tag/Accounts/operation/ListTransactions
     * @param {string} [code] unified currency code, default is undefined
     * @param {int} [since] timestamp in ms of the earliest ledger entry, default is undefined
     * @param {int} [limit] max number of ledger entries to return, default is undefined
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [ledger structure]{@link https://docs.ccxt.com/#/?id=ledger}
     */
    public async override Task<object> fetchLedger(object code = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        await this.loadAccounts();
        object currency = null;
        object id = this.safeString(parameters, "id"); // account id
        object min_row = this.safeValue(parameters, "min_row");
        object max_row = this.safeValue(parameters, "max_row");
        if (isTrue(isEqual(id, null)))
        {
            if (isTrue(isEqual(code, null)))
            {
                throw new ArgumentsRequired ((string)add(this.id, " fetchLedger() requires a currency code argument if no account id specified in params")) ;
            }
            currency = this.currency(code);
            object accountsByCurrencyCode = this.indexBy(this.accounts, "currency");
            object account = this.safeValue(accountsByCurrencyCode, code);
            if (isTrue(isEqual(account, null)))
            {
                throw new ExchangeError ((string)add(add(this.id, " fetchLedger() could not find account id for "), code)) ;
            }
            id = getValue(account, "id");
        }
        if (isTrue(isTrue(isEqual(min_row, null)) && isTrue(isEqual(max_row, null))))
        {
            max_row = 0; // Default to most recent transactions
            min_row = -1000; // Maximum number of records supported
        } else if (isTrue(isTrue(isEqual(min_row, null)) || isTrue(isEqual(max_row, null))))
        {
            throw new ExchangeError ((string)add(this.id, " fetchLedger() require both params 'max_row' and 'min_row' or neither to be defined")) ;
        }
        if (isTrue(isTrue(!isEqual(limit, null)) && isTrue(isGreaterThan(subtract(max_row, min_row), limit))))
        {
            if (isTrue(isLessThanOrEqual(max_row, 0)))
            {
                min_row = subtract(max_row, limit);
            } else if (isTrue(isGreaterThan(min_row, 0)))
            {
                max_row = add(min_row, limit);
            }
        }
        if (isTrue(isGreaterThan(subtract(max_row, min_row), 1000)))
        {
            throw new ExchangeError ((string)add(this.id, " fetchLedger() requires the params 'max_row' - 'min_row' <= 1000")) ;
        }
        object request = new Dictionary<string, object>() {
            { "id", id },
            { "min_row", min_row },
            { "max_row", max_row },
        };
        object response = await this.privateGetAccountsIdTransactions(this.extend(parameters, request));
        object entries = this.safeValue(response, "transactions", new List<object>() {});
        return this.parseLedger(entries, currency, since, limit);
    }

    public virtual object parseLedgerComment(object comment)
    {
        object words = ((string)comment).Split(new [] {((string)" ")}, StringSplitOptions.None).ToList<object>();
        object types = new Dictionary<string, object>() {
            { "Withdrawal", "fee" },
            { "Trading", "fee" },
            { "Payment", "transaction" },
            { "Sent", "transaction" },
            { "Deposit", "transaction" },
            { "Received", "transaction" },
            { "Released", "released" },
            { "Reserved", "reserved" },
            { "Sold", "trade" },
            { "Bought", "trade" },
            { "Failure", "failed" },
        };
        object referenceId = null;
        object firstWord = this.safeString(words, 0);
        object thirdWord = this.safeString(words, 2);
        object fourthWord = this.safeString(words, 3);
        object type = this.safeString(types, firstWord, null);
        if (isTrue(isTrue((isEqual(type, null))) && isTrue((isEqual(thirdWord, "fee")))))
        {
            type = "fee";
        }
        if (isTrue(isTrue((isEqual(type, "reserved"))) && isTrue((isEqual(fourthWord, "order")))))
        {
            referenceId = this.safeString(words, 4);
        }
        return new Dictionary<string, object>() {
            { "type", type },
            { "referenceId", referenceId },
        };
    }

    public override object parseLedgerEntry(object entry, object currency = null)
    {
        // const details = this.safeValue (entry, 'details', {});
        object id = this.safeString(entry, "row_index");
        object account_id = this.safeString(entry, "account_id");
        object timestamp = this.safeInteger(entry, "timestamp");
        object currencyId = this.safeString(entry, "currency");
        object code = this.safeCurrencyCode(currencyId, currency);
        currency = this.safeCurrency(currencyId, currency);
        object available_delta = this.safeString(entry, "available_delta");
        object balance_delta = this.safeString(entry, "balance_delta");
        object after = this.safeString(entry, "balance");
        object comment = this.safeString(entry, "description");
        object before = after;
        object amount = "0.0";
        object result = this.parseLedgerComment(comment);
        object type = getValue(result, "type");
        object referenceId = getValue(result, "referenceId");
        object direction = null;
        object status = null;
        if (!isTrue(Precise.stringEquals(balance_delta, "0.0")))
        {
            before = Precise.stringSub(after, balance_delta);
            status = "ok";
            amount = Precise.stringAbs(balance_delta);
        } else if (isTrue(Precise.stringLt(available_delta, "0.0")))
        {
            status = "pending";
            amount = Precise.stringAbs(available_delta);
        } else if (isTrue(Precise.stringGt(available_delta, "0.0")))
        {
            status = "canceled";
            amount = Precise.stringAbs(available_delta);
        }
        if (isTrue(isTrue(Precise.stringGt(balance_delta, "0")) || isTrue(Precise.stringGt(available_delta, "0"))))
        {
            direction = "in";
        } else if (isTrue(isTrue(Precise.stringLt(balance_delta, "0")) || isTrue(Precise.stringLt(available_delta, "0"))))
        {
            direction = "out";
        }
        return this.safeLedgerEntry(new Dictionary<string, object>() {
            { "info", entry },
            { "id", id },
            { "direction", direction },
            { "account", account_id },
            { "referenceId", referenceId },
            { "referenceAccount", null },
            { "type", type },
            { "currency", code },
            { "amount", this.parseToNumeric(amount) },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "before", this.parseToNumeric(before) },
            { "after", this.parseToNumeric(after) },
            { "status", status },
            { "fee", null },
        }, currency);
    }

    /**
     * @method
     * @name luno#createDepositAddress
     * @description create a currency deposit address
     * @see https://www.luno.com/en/developers/api#tag/Receive/operation/createFundingAddress
     * @param {string} code unified currency code of the currency for the deposit address
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.name] an optional name for the new address
     * @param {int} [params.account_id] an optional account id for the new address
     * @returns {object} an [address structure]{@link https://docs.ccxt.com/#/?id=address-structure}
     */
    public async override Task<object> createDepositAddress(object code, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "asset", getValue(currency, "id") },
        };
        object response = await this.privatePostFundingAddress(this.extend(request, parameters));
        //
        //     {
        //         "account_id": "string",
        //         "address": "string",
        //         "address_meta": [
        //             {
        //                 "label": "string",
        //                 "value": "string"
        //             }
        //         ],
        //         "asset": "string",
        //         "assigned_at": 0,
        //         "name": "string",
        //         "network": 0,
        //         "qr_code_uri": "string",
        //         "receive_fee": "string",
        //         "total_received": "string",
        //         "total_unconfirmed": "string"
        //     }
        //
        return this.parseDepositAddress(response, currency);
    }

    /**
     * @method
     * @name luno#fetchDepositAddress
     * @description fetch the deposit address for a currency associated with this account
     * @see https://www.luno.com/en/developers/api#tag/Receive/operation/getFundingAddress
     * @param {string} code unified currency code
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.address] a specific cryptocurrency address to retrieve
     * @returns {object} an [address structure]{@link https://docs.ccxt.com/#/?id=address-structure}
     */
    public async override Task<object> fetchDepositAddress(object code, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "asset", getValue(currency, "id") },
        };
        object response = await this.privateGetFundingAddress(this.extend(request, parameters));
        //
        //     {
        //         "account_id": "string",
        //         "address": "string",
        //         "address_meta": [
        //             {
        //                 "label": "string",
        //                 "value": "string"
        //             }
        //         ],
        //         "asset": "string",
        //         "assigned_at": 0,
        //         "name": "string",
        //         "network": 0,
        //         "qr_code_uri": "string",
        //         "receive_fee": "string",
        //         "total_received": "string",
        //         "total_unconfirmed": "string"
        //     }
        //
        return this.parseDepositAddress(response, currency);
    }

    public override object parseDepositAddress(object depositAddress, object currency = null)
    {
        //
        //     {
        //         "account_id": "string",
        //         "address": "string",
        //         "address_meta": [
        //             {
        //                 "label": "string",
        //                 "value": "string"
        //             }
        //         ],
        //         "asset": "string",
        //         "assigned_at": 0,
        //         "name": "string",
        //         "network": 0,
        //         "qr_code_uri": "string",
        //         "receive_fee": "string",
        //         "total_received": "string",
        //         "total_unconfirmed": "string"
        //     }
        //
        object currencyId = this.safeStringUpper(depositAddress, "currency");
        object code = this.safeCurrencyCode(currencyId, currency);
        return new Dictionary<string, object>() {
            { "info", depositAddress },
            { "currency", code },
            { "network", null },
            { "address", this.safeString(depositAddress, "address") },
            { "tag", this.safeString(depositAddress, "name") },
        };
    }

    public override object sign(object path, object api = null, object method = null, object parameters = null, object headers = null, object body = null)
    {
        api ??= "public";
        method ??= "GET";
        parameters ??= new Dictionary<string, object>();
        object url = add(add(add(add(getValue(getValue(this.urls, "api"), api), "/"), this.version), "/"), this.implodeParams(path, parameters));
        object query = this.omit(parameters, this.extractParams(path));
        if (isTrue(getArrayLength(new List<object>(((IDictionary<string,object>)query).Keys))))
        {
            url = add(url, add("?", this.urlencode(query)));
        }
        if (isTrue(isTrue((isEqual(api, "private"))) || isTrue((isEqual(api, "exchangePrivate")))))
        {
            this.checkRequiredCredentials();
            object auth = this.stringToBase64(add(add(this.apiKey, ":"), this.secret));
            headers = new Dictionary<string, object>() {
                { "Authorization", add("Basic ", auth) },
            };
        }
        return new Dictionary<string, object>() {
            { "url", url },
            { "method", method },
            { "body", body },
            { "headers", headers },
        };
    }

    public override object handleErrors(object httpCode, object reason, object url, object method, object headers, object body, object response, object requestHeaders, object requestBody)
    {
        if (isTrue(isEqual(response, null)))
        {
            return null;
        }
        object error = this.safeValue(response, "error");
        if (isTrue(!isEqual(error, null)))
        {
            throw new ExchangeError ((string)add(add(this.id, " "), this.json(response))) ;
        }
        return null;
    }
}
