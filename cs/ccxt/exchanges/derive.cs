namespace ccxt;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

public partial class derive : Exchange
{
    public override object describe()
    {
        return this.deepExtend(base.describe(), new Dictionary<string, object>() {
            { "id", "derive" },
            { "name", "derive" },
            { "countries", new List<object>() {} },
            { "version", "v1" },
            { "rateLimit", 50 },
            { "certified", false },
            { "pro", true },
            { "dex", true },
            { "has", new Dictionary<string, object>() {
                { "CORS", null },
                { "spot", false },
                { "margin", false },
                { "swap", false },
                { "future", false },
                { "option", false },
                { "addMargin", false },
                { "borrowCrossMargin", false },
                { "borrowIsolatedMargin", false },
                { "cancelAllOrders", true },
                { "cancelAllOrdersAfter", false },
                { "cancelOrder", true },
                { "cancelOrders", false },
                { "cancelOrdersForSymbols", false },
                { "closeAllPositions", false },
                { "closePosition", false },
                { "createMarketBuyOrderWithCost", false },
                { "createMarketOrderWithCost", false },
                { "createMarketSellOrderWithCost", false },
                { "createOrder", true },
                { "createOrders", false },
                { "createReduceOnlyOrder", false },
                { "createStopOrder", false },
                { "createTriggerOrder", false },
                { "editOrder", true },
                { "fetchAccounts", false },
                { "fetchBalance", true },
                { "fetchBorrowInterest", false },
                { "fetchBorrowRateHistories", false },
                { "fetchBorrowRateHistory", false },
                { "fetchCanceledAndClosedOrders", false },
                { "fetchCanceledOrders", true },
                { "fetchClosedOrders", true },
                { "fetchCrossBorrowRate", false },
                { "fetchCrossBorrowRates", false },
                { "fetchCurrencies", true },
                { "fetchDepositAddress", false },
                { "fetchDepositAddresses", false },
                { "fetchDeposits", true },
                { "fetchDepositWithdrawFee", "emulated" },
                { "fetchDepositWithdrawFees", false },
                { "fetchFundingHistory", true },
                { "fetchFundingRate", true },
                { "fetchFundingRateHistory", true },
                { "fetchFundingRates", false },
                { "fetchIndexOHLCV", false },
                { "fetchIsolatedBorrowRate", false },
                { "fetchIsolatedBorrowRates", false },
                { "fetchLedger", true },
                { "fetchLeverage", false },
                { "fetchLeverageTiers", false },
                { "fetchLiquidations", false },
                { "fetchMarginMode", null },
                { "fetchMarketLeverageTiers", false },
                { "fetchMarkets", true },
                { "fetchMarkOHLCV", false },
                { "fetchMyLiquidations", false },
                { "fetchMyTrades", true },
                { "fetchOHLCV", false },
                { "fetchOpenInterest", false },
                { "fetchOpenInterestHistory", false },
                { "fetchOpenInterests", false },
                { "fetchOpenOrders", true },
                { "fetchOrder", false },
                { "fetchOrderBook", false },
                { "fetchOrders", true },
                { "fetchOrderTrades", true },
                { "fetchPosition", false },
                { "fetchPositionMode", false },
                { "fetchPositions", true },
                { "fetchPositionsRisk", false },
                { "fetchPremiumIndexOHLCV", false },
                { "fetchTicker", true },
                { "fetchTickers", false },
                { "fetchTime", true },
                { "fetchTrades", true },
                { "fetchTradingFee", false },
                { "fetchTradingFees", false },
                { "fetchTransfer", false },
                { "fetchTransfers", false },
                { "fetchWithdrawal", false },
                { "fetchWithdrawals", true },
                { "reduceMargin", false },
                { "repayCrossMargin", false },
                { "repayIsolatedMargin", false },
                { "sandbox", true },
                { "setLeverage", false },
                { "setMarginMode", false },
                { "setPositionMode", false },
                { "transfer", false },
                { "withdraw", false },
            } },
            { "timeframes", new Dictionary<string, object>() {
                { "1m", "1m" },
                { "3m", "3m" },
                { "5m", "5m" },
                { "15m", "15m" },
                { "30m", "30m" },
                { "1h", "1h" },
                { "2h", "2h" },
                { "4h", "4h" },
                { "8h", "8h" },
                { "12h", "12h" },
                { "1d", "1d" },
                { "3d", "3d" },
                { "1w", "1w" },
                { "1M", "1M" },
            } },
            { "hostname", "derive.xyz" },
            { "urls", new Dictionary<string, object>() {
                { "logo", "https://github.com/user-attachments/assets/f835b95f-033a-43dd-b6bb-24e698fc498c" },
                { "api", new Dictionary<string, object>() {
                    { "public", "https://api.lyra.finance/public" },
                    { "private", "https://api.lyra.finance/private" },
                } },
                { "test", new Dictionary<string, object>() {
                    { "public", "https://api-demo.lyra.finance/public" },
                    { "private", "https://api-demo.lyra.finance/private" },
                } },
                { "www", "https://www.derive.xyz/" },
                { "doc", "https://docs.derive.xyz/docs/" },
                { "fees", "https://docs.derive.xyz/reference/fees-1/" },
                { "referral", "https://www.derive.xyz/invite/3VB0B" },
            } },
            { "api", new Dictionary<string, object>() {
                { "public", new Dictionary<string, object>() {
                    { "get", new List<object>() {"get_all_currencies"} },
                    { "post", new List<object>() {"build_register_session_key_tx", "register_session_key", "deregister_session_key", "login", "statistics", "get_all_currencies", "get_currency", "get_instrument", "get_all_instruments", "get_instruments", "get_ticker", "get_latest_signed_feeds", "get_option_settlement_prices", "get_spot_feed_history", "get_spot_feed_history_candles", "get_funding_rate_history", "get_trade_history", "get_option_settlement_history", "get_liquidation_history", "get_interest_rate_history", "get_transaction", "get_margin", "margin_watch", "validate_invite_code", "get_points", "get_all_points", "get_points_leaderboard", "get_descendant_tree", "get_tree_roots", "get_swell_percent_points", "get_vault_assets", "get_etherfi_effective_balances", "get_kelp_effective_balances", "get_bridge_balances", "get_ethena_participants", "get_vault_share", "get_vault_statistics", "get_vault_balances", "estimate_integrator_points", "create_subaccount_debug", "deposit_debug", "withdraw_debug", "send_quote_debug", "execute_quote_debug", "get_invite_code", "register_invite", "get_time", "get_live_incidents", "get_maker_programs", "get_maker_program_scores"} },
                } },
                { "private", new Dictionary<string, object>() {
                    { "post", new List<object>() {"get_account", "create_subaccount", "get_subaccount", "get_subaccounts", "get_all_portfolios", "change_subaccount_label", "get_notificationsv", "update_notifications", "deposit", "withdraw", "transfer_erc20", "transfer_position", "transfer_positions", "order", "replace", "order_debug", "get_order", "get_orders", "get_open_orders", "cancel", "cancel_by_label", "cancel_by_nonce", "cancel_by_instrument", "cancel_all", "cancel_trigger_order", "get_order_history", "get_trade_history", "get_deposit_history", "get_withdrawal_history", "send_rfq", "cancel_rfq", "cancel_batch_rfqs", "get_rfqs", "poll_rfqs", "send_quote", "cancel_quote", "cancel_batch_quotes", "get_quotes", "poll_quotes", "execute_quote", "rfq_get_best_quote", "get_margin", "get_collaterals", "get_positions", "get_option_settlement_history", "get_subaccount_value_history", "expired_and_cancelled_history", "get_funding_history", "get_interest_history", "get_erc20_transfer_history", "get_liquidation_history", "liquidate", "get_liquidator_history", "session_keys", "edit_session_key", "register_scoped_session_key", "get_mmp_config", "set_mmp_config", "reset_mmp", "set_cancel_on_disconnect", "get_invite_code", "register_invite"} },
                } },
            } },
            { "fees", new Dictionary<string, object>() {} },
            { "requiredCredentials", new Dictionary<string, object>() {
                { "apiKey", false },
                { "secret", false },
                { "walletAddress", true },
                { "privateKey", true },
            } },
            { "exceptions", new Dictionary<string, object>() {
                { "exact", new Dictionary<string, object>() {
                    { "-32000", typeof(RateLimitExceeded) },
                    { "-32100", typeof(RateLimitExceeded) },
                    { "-32700", typeof(BadRequest) },
                    { "-32600", typeof(BadRequest) },
                    { "-32601", typeof(BadRequest) },
                    { "-32602", typeof(InvalidOrder) },
                    { "-32603", typeof(InvalidOrder) },
                    { "9000", typeof(InvalidOrder) },
                    { "10000", typeof(BadRequest) },
                    { "10001", typeof(BadRequest) },
                    { "10002", typeof(BadRequest) },
                    { "10003", typeof(BadRequest) },
                    { "10004", typeof(InvalidOrder) },
                    { "10005", typeof(BadRequest) },
                    { "10006", typeof(BadRequest) },
                    { "10007", typeof(BadRequest) },
                    { "10008", typeof(BadRequest) },
                    { "10009", typeof(BadRequest) },
                    { "10010", typeof(InvalidOrder) },
                    { "10011", typeof(InsufficientFunds) },
                    { "10012", typeof(InsufficientFunds) },
                    { "10013", typeof(ExchangeError) },
                    { "10014", typeof(ExchangeError) },
                    { "11000", typeof(InsufficientFunds) },
                    { "11002", typeof(InvalidOrder) },
                    { "11003", typeof(InvalidOrder) },
                    { "11004", typeof(InvalidOrder) },
                    { "11005", typeof(InvalidOrder) },
                    { "11006", typeof(OrderNotFound) },
                    { "11007", typeof(InvalidOrder) },
                    { "11008", typeof(InvalidOrder) },
                    { "11009", typeof(InvalidOrder) },
                    { "11010", typeof(InvalidOrder) },
                    { "11011", typeof(InvalidOrder) },
                    { "11012", typeof(InvalidOrder) },
                    { "11013", typeof(InvalidOrder) },
                    { "11014", typeof(InvalidOrder) },
                    { "11015", typeof(InvalidOrder) },
                    { "11016", typeof(InvalidOrder) },
                    { "11017", typeof(InvalidOrder) },
                    { "11018", typeof(InvalidOrder) },
                    { "11019", typeof(InvalidOrder) },
                    { "11020", typeof(InsufficientFunds) },
                    { "11021", typeof(InvalidOrder) },
                    { "11022", typeof(InvalidOrder) },
                    { "11023", typeof(InvalidOrder) },
                    { "11024", typeof(InvalidOrder) },
                    { "11025", typeof(InvalidOrder) },
                    { "11026", typeof(BadRequest) },
                    { "11027", typeof(InvalidOrder) },
                    { "11028", typeof(InvalidOrder) },
                    { "11050", typeof(InvalidOrder) },
                    { "11051", typeof(InvalidOrder) },
                    { "11052", typeof(InvalidOrder) },
                    { "11053", typeof(InvalidOrder) },
                    { "11054", typeof(InvalidOrder) },
                    { "11055", typeof(InvalidOrder) },
                    { "11100", typeof(InvalidOrder) },
                    { "11101", typeof(InvalidOrder) },
                    { "11102", typeof(InvalidOrder) },
                    { "11103", typeof(InvalidOrder) },
                    { "11104", typeof(InvalidOrder) },
                    { "11105", typeof(InvalidOrder) },
                    { "11106", typeof(InvalidOrder) },
                    { "11107", typeof(InvalidOrder) },
                    { "11200", typeof(InvalidOrder) },
                    { "11201", typeof(InvalidOrder) },
                    { "11202", typeof(InvalidOrder) },
                    { "11203", typeof(InvalidOrder) },
                    { "12000", typeof(InvalidOrder) },
                    { "12001", typeof(InvalidOrder) },
                    { "12002", typeof(BadRequest) },
                    { "12003", typeof(BadRequest) },
                    { "13000", typeof(BadRequest) },
                    { "14000", typeof(BadRequest) },
                    { "14001", typeof(InvalidOrder) },
                    { "14002", typeof(BadRequest) },
                    { "14008", typeof(BadRequest) },
                    { "14009", typeof(BadRequest) },
                    { "14010", typeof(BadRequest) },
                    { "14011", typeof(BadRequest) },
                    { "14012", typeof(BadRequest) },
                    { "14013", typeof(BadRequest) },
                    { "14014", typeof(InvalidOrder) },
                    { "14015", typeof(BadRequest) },
                    { "14016", typeof(BadRequest) },
                    { "14017", typeof(BadRequest) },
                    { "14018", typeof(BadRequest) },
                    { "14019", typeof(BadRequest) },
                    { "14020", typeof(BadRequest) },
                    { "14021", typeof(BadRequest) },
                    { "14022", typeof(AuthenticationError) },
                    { "14023", typeof(InvalidOrder) },
                    { "14024", typeof(BadRequest) },
                    { "14025", typeof(BadRequest) },
                    { "14026", typeof(BadRequest) },
                    { "14027", typeof(AuthenticationError) },
                    { "14028", typeof(BadRequest) },
                    { "14029", typeof(AuthenticationError) },
                    { "14030", typeof(BadRequest) },
                    { "14031", typeof(AuthenticationError) },
                    { "14032", typeof(BadRequest) },
                    { "16000", typeof(AuthenticationError) },
                    { "16001", typeof(AuthenticationError) },
                    { "16100", typeof(AuthenticationError) },
                    { "17000", typeof(BadRequest) },
                    { "17001", typeof(BadRequest) },
                    { "17002", typeof(BadRequest) },
                    { "17003", typeof(BadRequest) },
                    { "17004", typeof(BadRequest) },
                    { "17005", typeof(BadRequest) },
                    { "17006", typeof(BadRequest) },
                    { "17007", typeof(BadRequest) },
                    { "18000", typeof(BadRequest) },
                    { "18001", typeof(BadRequest) },
                    { "18002", typeof(BadRequest) },
                    { "18003", typeof(BadRequest) },
                    { "18004", typeof(BadRequest) },
                    { "18005", typeof(BadRequest) },
                    { "18006", typeof(BadRequest) },
                    { "18007", typeof(BadRequest) },
                    { "19000", typeof(BadRequest) },
                } },
                { "broad", new Dictionary<string, object>() {} },
            } },
            { "precisionMode", TICK_SIZE },
            { "commonCurrencies", new Dictionary<string, object>() {} },
            { "options", new Dictionary<string, object>() {
                { "deriveWalletAddress", "" },
                { "id", "0x0ad42b8e602c2d3d475ae52d678cf63d84ab2749" },
            } },
        });
    }

    public override void setSandboxMode(object enable)
    {
        base.setSandboxMode(enable);
        ((IDictionary<string,object>)this.options)["sandboxMode"] = enable;
    }

    /**
     * @method
     * @name derive#fetchTime
     * @description fetches the current integer timestamp in milliseconds from the exchange server
     * @see https://docs.derive.xyz/reference/post_public-get-time
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {int} the current integer timestamp in milliseconds from the exchange server
     */
    public async override Task<object> fetchTime(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object response = await this.publicPostGetTime(parameters);
        //
        // {
        //     "result": 1735846536758,
        //     "id": "f1c03d21-f886-4c5a-9a9d-33dd06f180f0"
        // }
        //
        return this.safeInteger(response, "result");
    }

    /**
     * @method
     * @name derive#fetchCurrencies
     * @description fetches all available currencies on an exchange
     * @see https://docs.derive.xyz/reference/post_public-get-all-currencies
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} an associative dictionary of currencies
     */
    public async override Task<object> fetchCurrencies(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object result = new Dictionary<string, object>() {};
        object tokenResponse = await this.publicGetGetAllCurrencies(parameters);
        //
        // {
        //     "result": [
        //         {
        //             "currency": "USDC",
        //             "spot_price": "1.000066413299999872",
        //             "spot_price_24h": "1.000327785299999872"
        //         }
        //     ],
        //     "id": "7e07fe1d-0ab4-4d2b-9e22-b65ce9e232dc"
        // }
        //
        object currencies = this.safeList(tokenResponse, "result", new List<object>() {});
        for (object i = 0; isLessThan(i, getArrayLength(currencies)); postFixIncrement(ref i))
        {
            object currency = getValue(currencies, i);
            object currencyId = this.safeString(currency, "currency");
            object code = this.safeCurrencyCode(currencyId);
            ((IDictionary<string,object>)result)[(string)code] = new Dictionary<string, object>() {
                { "id", currencyId },
                { "name", null },
                { "code", code },
                { "precision", null },
                { "active", null },
                { "fee", null },
                { "networks", null },
                { "deposit", null },
                { "withdraw", null },
                { "limits", new Dictionary<string, object>() {
                    { "deposit", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                    { "withdraw", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                } },
                { "info", currency },
            };
        }
        return result;
    }

    /**
     * @method
     * @name derive#fetchMarkets
     * @description retrieves data on all markets for bybit
     * @see https://docs.derive.xyz/reference/post_public-get-all-instruments
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} an array of objects representing market data
     */
    public async override Task<object> fetchMarkets(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object spotMarketsPromise = this.fetchSpotMarkets(parameters);
        object swapMarketsPromise = this.fetchSwapMarkets(parameters);
        object optionMarketsPromise = this.fetchOptionMarkets(parameters);
        var spotMarketsswapMarketsoptionMarketsVariable = await promiseAll(new List<object>() {spotMarketsPromise, swapMarketsPromise, optionMarketsPromise});
        var spotMarkets = ((IList<object>) spotMarketsswapMarketsoptionMarketsVariable)[0];
        var swapMarkets = ((IList<object>) spotMarketsswapMarketsoptionMarketsVariable)[1];
        var optionMarkets = ((IList<object>) spotMarketsswapMarketsoptionMarketsVariable)[2];
        //
        // {
        //     "result": {
        //         "instruments": [
        //             {
        //                 "instrument_type": "perp",
        //                 "instrument_name": "BTC-PERP",
        //                 "scheduled_activation": 1701840228,
        //                 "scheduled_deactivation": 9223372036854776000,
        //                 "is_active": true,
        //                 "tick_size": "0.1",
        //                 "minimum_amount": "0.01",
        //                 "maximum_amount": "10000",
        //                 "amount_step": "0.001",
        //                 "mark_price_fee_rate_cap": "0",
        //                 "maker_fee_rate": "0.00005",
        //                 "taker_fee_rate": "0.0003",
        //                 "base_fee": "0.1",
        //                 "base_currency": "BTC",
        //                 "quote_currency": "USD",
        //                 "option_details": null,
        //                 "perp_details": {
        //                     "index": "BTC-USD",
        //                     "max_rate_per_hour": "0.004",
        //                     "min_rate_per_hour": "-0.004",
        //                     "static_interest_rate": "0.0000125",
        //                     "aggregate_funding": "10538.574363381759146829",
        //                     "funding_rate": "0.0000125"
        //                 },
        //                 "erc20_details": null,
        //                 "base_asset_address": "0xDBa83C0C654DB1cd914FA2710bA743e925B53086",
        //                 "base_asset_sub_id": "0",
        //                 "pro_rata_fraction": "0",
        //                 "fifo_min_allocation": "0",
        //                 "pro_rata_amount_step": "0.1"
        //             }
        //         ],
        //         "pagination": {
        //             "num_pages": 1,
        //             "count": 1
        //         }
        //     },
        //     "id": "a06bc0b2-8e78-4536-a21f-f785f225b5a5"
        // }
        //
        object result = this.arrayConcat(spotMarkets, swapMarkets);
        result = this.arrayConcat(result, optionMarkets);
        return result;
    }

    public async virtual Task<object> fetchSpotMarkets(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object request = new Dictionary<string, object>() {
            { "expired", false },
            { "instrument_type", "erc20" },
        };
        object response = await this.publicPostGetAllInstruments(this.extend(request, parameters));
        object result = this.safeDict(response, "result", new Dictionary<string, object>() {});
        object data = this.safeList(result, "instruments", new List<object>() {});
        return this.parseMarkets(data);
    }

    public async virtual Task<object> fetchSwapMarkets(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object request = new Dictionary<string, object>() {
            { "expired", false },
            { "instrument_type", "perp" },
        };
        object response = await this.publicPostGetAllInstruments(this.extend(request, parameters));
        object result = this.safeDict(response, "result", new Dictionary<string, object>() {});
        object data = this.safeList(result, "instruments", new List<object>() {});
        return this.parseMarkets(data);
    }

    public async virtual Task<object> fetchOptionMarkets(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object request = new Dictionary<string, object>() {
            { "expired", false },
            { "instrument_type", "option" },
        };
        object response = await this.publicPostGetAllInstruments(this.extend(request, parameters));
        object result = this.safeDict(response, "result", new Dictionary<string, object>() {});
        object data = this.safeList(result, "instruments", new List<object>() {});
        return this.parseMarkets(data);
    }

    public override object parseMarket(object market)
    {
        object type = this.safeString(market, "instrument_type");
        object marketType = null;
        object spot = false;
        object margin = true;
        object swap = false;
        object option = false;
        object linear = null;
        object baseId = this.safeString(market, "base_currency");
        object quoteId = this.safeString(market, "quote_currency");
        object bs = this.safeCurrencyCode(baseId);
        object quote = this.safeCurrencyCode(quoteId);
        object marketId = this.safeString(market, "instrument_name");
        object symbol = add(add(bs, "/"), quote);
        object settleId = null;
        object settle = null;
        object expiry = null;
        object strike = null;
        object optionType = null;
        object optionLetter = null;
        if (isTrue(isEqual(type, "erc20")))
        {
            spot = true;
            marketType = "spot";
        } else if (isTrue(isEqual(type, "perp")))
        {
            margin = false;
            settleId = "USDC";
            settle = this.safeCurrencyCode(settleId);
            symbol = add(add(add(add(bs, "/"), quote), ":"), settle);
            swap = true;
            linear = true;
            marketType = "swap";
        } else if (isTrue(isEqual(type, "option")))
        {
            settleId = "USDC";
            settle = this.safeCurrencyCode(settleId);
            margin = false;
            option = true;
            marketType = "option";
            object optionDetails = this.safeDict(market, "option_details");
            expiry = this.safeTimestamp(optionDetails, "expiry");
            strike = this.safeInteger(optionDetails, "strike");
            optionLetter = this.safeString(optionDetails, "option_type");
            symbol = add(add(add(add(add(add(add(add(add(add(bs, "/"), quote), ":"), settle), "-"), this.yymmdd(expiry)), "-"), this.numberToString(strike)), "-"), optionLetter);
            if (isTrue(isEqual(optionLetter, "P")))
            {
                optionType = "put";
            } else
            {
                optionType = "call";
            }
        }
        return this.safeMarketStructure(new Dictionary<string, object>() {
            { "id", marketId },
            { "symbol", symbol },
            { "base", bs },
            { "quote", quote },
            { "settle", settle },
            { "baseId", baseId },
            { "quoteId", quoteId },
            { "settleId", settleId },
            { "type", marketType },
            { "spot", spot },
            { "margin", margin },
            { "swap", swap },
            { "future", false },
            { "option", option },
            { "active", this.safeBool(market, "is_active") },
            { "contract", (isTrue(swap) || isTrue(option)) },
            { "linear", linear },
            { "inverse", null },
            { "contractSize", ((bool) isTrue((spot))) ? null : 1 },
            { "expiry", expiry },
            { "expiryDatetime", this.iso8601(expiry) },
            { "taker", this.safeNumber(market, "taker_fee_rate") },
            { "maker", this.safeNumber(market, "maker_fee_rate") },
            { "strike", strike },
            { "optionType", optionType },
            { "precision", new Dictionary<string, object>() {
                { "amount", this.safeNumber(market, "amount_step") },
                { "price", this.safeNumber(market, "tick_size") },
            } },
            { "limits", new Dictionary<string, object>() {
                { "leverage", new Dictionary<string, object>() {
                    { "min", null },
                    { "max", null },
                } },
                { "amount", new Dictionary<string, object>() {
                    { "min", this.safeNumber(market, "minimum_amount") },
                    { "max", this.safeNumber(market, "maximum_amount") },
                } },
                { "price", new Dictionary<string, object>() {
                    { "min", null },
                    { "max", null },
                } },
                { "cost", new Dictionary<string, object>() {
                    { "min", null },
                    { "max", null },
                } },
            } },
            { "created", null },
            { "info", market },
        });
    }

    /**
     * @method
     * @name derive#fetchTicker
     * @description fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
     * @see https://docs.derive.xyz/reference/post_public-get-ticker
     * @param {string} symbol unified symbol of the market to fetch the ticker for
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
     */
    public async override Task<object> fetchTicker(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "instrument_name", getValue(market, "id") },
        };
        object response = await this.publicPostGetTicker(this.extend(request, parameters));
        //
        // spot
        //
        // {
        //     "result": {
        //         "instrument_type": "perp",
        //         "instrument_name": "BTC-PERP",
        //         "scheduled_activation": 1701840228,
        //         "scheduled_deactivation": 9223372036854776000,
        //         "is_active": true,
        //         "tick_size": "0.1",
        //         "minimum_amount": "0.01",
        //         "maximum_amount": "10000",
        //         "amount_step": "0.001",
        //         "mark_price_fee_rate_cap": "0",
        //         "maker_fee_rate": "0.00005",
        //         "taker_fee_rate": "0.0003",
        //         "base_fee": "0.1",
        //         "base_currency": "BTC",
        //         "quote_currency": "USD",
        //         "option_details": null,
        //         "perp_details": {
        //             "index": "BTC-USD",
        //             "max_rate_per_hour": "0.004",
        //             "min_rate_per_hour": "-0.004",
        //             "static_interest_rate": "0.0000125",
        //             "aggregate_funding": "10512.580833189805742522",
        //             "funding_rate": "-0.000022223906766867"
        //         },
        //         "erc20_details": null,
        //         "base_asset_address": "0xDBa83C0C654DB1cd914FA2710bA743e925B53086",
        //         "base_asset_sub_id": "0",
        //         "pro_rata_fraction": "0",
        //         "fifo_min_allocation": "0",
        //         "pro_rata_amount_step": "0.1",
        //         "best_ask_amount": "0.012",
        //         "best_ask_price": "99567.9",
        //         "best_bid_amount": "0.129",
        //         "best_bid_price": "99554.5",
        //         "five_percent_bid_depth": "11.208",
        //         "five_percent_ask_depth": "11.42",
        //         "option_pricing": null,
        //         "index_price": "99577.2",
        //         "mark_price": "99543.642926357933902181684970855712890625",
        //         "stats": {
        //             "contract_volume": "464.712",
        //             "num_trades": "10681",
        //             "open_interest": "72.804739389481989861",
        //             "high": "99519.1",
        //             "low": "97254.1",
        //             "percent_change": "0.0128",
        //             "usd_change": "1258.1"
        //         },
        //         "timestamp": 1736140984000,
        //         "min_price": "97591.2",
        //         "max_price": "101535.1"
        //     },
        //     "id": "bbd7c271-c2be-48f7-b93a-26cf6d4cb79f"
        // }
        //
        object data = this.safeDict(response, "result", new Dictionary<string, object>() {});
        return this.parseTicker(data, market);
    }

    public override object parseTicker(object ticker, object market = null)
    {
        //
        // {
        //     "instrument_type": "perp",
        //     "instrument_name": "BTC-PERP",
        //     "scheduled_activation": 1701840228,
        //     "scheduled_deactivation": 9223372036854776000,
        //     "is_active": true,
        //     "tick_size": "0.1",
        //     "minimum_amount": "0.01",
        //     "maximum_amount": "10000",
        //     "amount_step": "0.001",
        //     "mark_price_fee_rate_cap": "0",
        //     "maker_fee_rate": "0.00005",
        //     "taker_fee_rate": "0.0003",
        //     "base_fee": "0.1",
        //     "base_currency": "BTC",
        //     "quote_currency": "USD",
        //     "option_details": null,
        //     "perp_details": {
        //         "index": "BTC-USD",
        //         "max_rate_per_hour": "0.004",
        //         "min_rate_per_hour": "-0.004",
        //         "static_interest_rate": "0.0000125",
        //         "aggregate_funding": "10512.580833189805742522",
        //         "funding_rate": "-0.000022223906766867"
        //     },
        //     "erc20_details": null,
        //     "base_asset_address": "0xDBa83C0C654DB1cd914FA2710bA743e925B53086",
        //     "base_asset_sub_id": "0",
        //     "pro_rata_fraction": "0",
        //     "fifo_min_allocation": "0",
        //     "pro_rata_amount_step": "0.1",
        //     "best_ask_amount": "0.012",
        //     "best_ask_price": "99567.9",
        //     "best_bid_amount": "0.129",
        //     "best_bid_price": "99554.5",
        //     "five_percent_bid_depth": "11.208",
        //     "five_percent_ask_depth": "11.42",
        //     "option_pricing": null,
        //     "index_price": "99577.2",
        //     "mark_price": "99543.642926357933902181684970855712890625",
        //     "stats": {
        //         "contract_volume": "464.712",
        //         "num_trades": "10681",
        //         "open_interest": "72.804739389481989861",
        //         "high": "99519.1",
        //         "low": "97254.1",
        //         "percent_change": "0.0128",
        //         "usd_change": "1258.1"
        //     },
        //     "timestamp": 1736140984000,
        //     "min_price": "97591.2",
        //     "max_price": "101535.1"
        // }
        //
        object marketId = this.safeString(ticker, "instrument_name");
        object timestamp = this.safeIntegerOmitZero(ticker, "timestamp");
        object symbol = this.safeSymbol(marketId, market);
        object stats = this.safeDict(ticker, "stats");
        object change = this.safeString(stats, "percent_change");
        return this.safeTicker(new Dictionary<string, object>() {
            { "symbol", symbol },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "high", this.safeString(stats, "high") },
            { "low", this.safeString(stats, "low") },
            { "bid", this.safeString(ticker, "best_bid_price") },
            { "bidVolume", this.safeString(ticker, "best_bid_amount") },
            { "ask", this.safeString(ticker, "best_ask_price") },
            { "askVolume", this.safeString(ticker, "best_ask_amount") },
            { "vwap", null },
            { "open", null },
            { "close", null },
            { "last", null },
            { "previousClose", null },
            { "change", change },
            { "percentage", Precise.stringMul(change, "100") },
            { "average", null },
            { "baseVolume", null },
            { "quoteVolume", null },
            { "indexPrice", this.safeString(ticker, "index_price") },
            { "markPrice", this.safeString(ticker, "mark_price") },
            { "info", ticker },
        }, market);
    }

    /**
     * @method
     * @name derive#fetchTrades
     * @description get the list of most recent trades for a particular symbol
     * @see https://docs.derive.xyz/reference/post_public-get-trade-history
     * @param {string} symbol unified symbol of the market to fetch trades for
     * @param {int} [since] timestamp in ms of the earliest trade to fetch
     * @param {int} [limit] the maximum amount of trades to fetch
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {int} [params.until] the latest time in ms to fetch trades for
     * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
     */
    public async override Task<object> fetchTrades(object symbol, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            ((IDictionary<string,object>)request)["instrument_name"] = getValue(market, "id");
        }
        if (isTrue(!isEqual(limit, null)))
        {
            if (isTrue(isGreaterThan(limit, 1000)))
            {
                limit = 1000;
            }
            ((IDictionary<string,object>)request)["page_size"] = limit; // default 100, max 1000
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["from_timestamp"] = since;
        }
        object until = this.safeInteger(parameters, "until");
        parameters = this.omit(parameters, new List<object>() {"until"});
        if (isTrue(!isEqual(until, null)))
        {
            ((IDictionary<string,object>)request)["to_timestamp"] = until;
        }
        object response = await this.publicPostGetTradeHistory(this.extend(request, parameters));
        //
        // {
        //     "result": {
        //         "trades": [
        //             {
        //                 "trade_id": "9dbc88b0-f0c4-4439-9cc1-4e6409d4eafb",
        //                 "instrument_name": "BTC-PERP",
        //                 "timestamp": 1736153910930,
        //                 "trade_price": "98995.3",
        //                 "trade_amount": "0.033",
        //                 "mark_price": "98990.875914388161618263",
        //                 "index_price": "99038.050611100001501184",
        //                 "direction": "sell",
        //                 "quote_id": null,
        //                 "wallet": "0x88B6BB87fbFac92a34F8155aaA35c87B5b166fA9",
        //                 "subaccount_id": 8250,
        //                 "tx_status": "settled",
        //                 "tx_hash": "0x020bd735b312f867f17f8cc254946d87cfe9f2c8ff3605035d8129082eb73723",
        //                 "trade_fee": "0.980476701049890015",
        //                 "liquidity_role": "taker",
        //                 "realized_pnl": "-2.92952402688793509",
        //                 "realized_pnl_excl_fees": "-1.949047325838045075"
        //             }
        //         ],
        //         "pagination": {
        //             "num_pages": 598196,
        //             "count": 598196
        //         }
        //     },
        //     "id": "b8539544-6975-4497-8163-5e51a38e4aa7"
        // }
        //
        object result = this.safeDict(response, "result", new Dictionary<string, object>() {});
        object data = this.safeList(result, "trades", new List<object>() {});
        return this.parseTrades(data, market, since, limit);
    }

    public override object parseTrade(object trade, object market = null)
    {
        //
        // {
        //     "subaccount_id": 130837,
        //     "order_id": "30c48194-8d48-43ac-ad00-0d5ba29eddc9",
        //     "instrument_name": "BTC-PERP",
        //     "direction": "sell",
        //     "label": "test1234",
        //     "quote_id": null,
        //     "trade_id": "f8a30740-488c-4c2d-905d-e17057bafde1",
        //     "timestamp": 1738065303708,
        //     "mark_price": "102740.137375457314192317",
        //     "index_price": "102741.553409299981533184",
        //     "trade_price": "102700.6",
        //     "trade_amount": "0.01",
        //     "liquidity_role": "taker",
        //     "realized_pnl": "0",
        //     "realized_pnl_excl_fees": "0",
        //     "is_transfer": false,
        //     "tx_status": "settled",
        //     "trade_fee": "1.127415534092999815",
        //     "tx_hash": "0xc55df1f07330faf86579bd8a6385391fbe9e73089301149d8550e9d29c9ead74",
        //     "transaction_id": "e18b9426-3fa5-41bb-99d3-8b54fb4d51bb"
        // }
        //
        object marketId = this.safeString(trade, "instrument_name");
        object symbol = this.safeSymbol(marketId, market);
        object timestamp = this.safeInteger(trade, "timestamp");
        object fee = new Dictionary<string, object>() {
            { "currency", "USDC" },
            { "cost", this.safeString(trade, "trade_fee") },
        };
        return this.safeTrade(new Dictionary<string, object>() {
            { "info", trade },
            { "id", this.safeString(trade, "trade_id") },
            { "order", this.safeString(trade, "order_id") },
            { "symbol", symbol },
            { "side", this.safeStringLower(trade, "direction") },
            { "type", null },
            { "takerOrMaker", this.safeString(trade, "liquidity_role") },
            { "price", this.safeString(trade, "trade_price") },
            { "amount", this.safeString(trade, "trade_amount") },
            { "cost", null },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "fee", fee },
        }, market);
    }

    /**
     * @method
     * @name derive#fetchFundingRateHistory
     * @description fetches historical funding rate prices
     * @see https://docs.derive.xyz/reference/post_public-get-funding-rate-history
     * @param {string} symbol unified symbol of the market to fetch the funding rate history for
     * @param {int} [since] timestamp in ms of the earliest funding rate to fetch
     * @param {int} [limit] the maximum amount of funding rate structures to fetch
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} a list of [funding rate structures]{@link https://docs.ccxt.com/#/?id=funding-rate-history-structure}
     */
    public async override Task<object> fetchFundingRateHistory(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "instrument_name", getValue(market, "id") },
        };
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["start_timestamp"] = since;
        }
        object until = this.safeInteger(parameters, "until");
        parameters = this.omit(parameters, new List<object>() {"until"});
        if (isTrue(!isEqual(until, null)))
        {
            ((IDictionary<string,object>)request)["to_timestamp"] = until;
        }
        object response = await this.publicPostGetFundingRateHistory(this.extend(request, parameters));
        //
        // {
        //     "result": {
        //         "funding_rate_history": [
        //             {
        //                 "timestamp": 1736215200000,
        //                 "funding_rate": "-0.000020014"
        //             }
        //         ]
        //     },
        //     "id": "3200ab8d-0080-42f0-8517-c13e3d9201d8"
        // }
        //
        object result = this.safeDict(response, "result", new Dictionary<string, object>() {});
        object data = this.safeList(result, "funding_rate_history", new List<object>() {});
        object rates = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
        {
            object entry = getValue(data, i);
            object timestamp = this.safeInteger(entry, "timestamp");
            ((IList<object>)rates).Add(new Dictionary<string, object>() {
                { "info", entry },
                { "symbol", getValue(market, "symbol") },
                { "fundingRate", this.safeNumber(entry, "funding_rate") },
                { "timestamp", timestamp },
                { "datetime", this.iso8601(timestamp) },
            });
        }
        object sorted = this.sortBy(rates, "timestamp");
        return this.filterBySymbolSinceLimit(sorted, getValue(market, "symbol"), since, limit);
    }

    /**
     * @method
     * @name derive#fetchFundingRate
     * @description fetch the current funding rate
     * @see https://docs.derive.xyz/reference/post_public-get-funding-rate-history
     * @param {string} symbol unified market symbol
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [funding rate structure]{@link https://docs.ccxt.com/#/?id=funding-rate-structure}
     */
    public async override Task<object> fetchFundingRate(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object response = await this.fetchFundingRateHistory(symbol, null, 1, parameters);
        //
        // [
        //     {
        //         "info": {
        //             "timestamp": 1736157600000,
        //             "funding_rate": "-0.000008872"
        //         },
        //         "symbol": "BTC/USD:USDC",
        //         "fundingRate": -0.000008872,
        //         "timestamp": 1736157600000,
        //         "datetime": "2025-01-06T10:00:00.000Z"
        //     }
        // ]
        //
        object data = this.safeDict(response, 0);
        return this.parseFundingRate(data);
    }

    public override object parseFundingRate(object contract, object market = null)
    {
        object symbol = this.safeString(contract, "symbol");
        object fundingTimestamp = this.safeInteger(contract, "timestamp");
        return new Dictionary<string, object>() {
            { "info", contract },
            { "symbol", symbol },
            { "markPrice", null },
            { "indexPrice", null },
            { "interestRate", null },
            { "estimatedSettlePrice", null },
            { "timestamp", null },
            { "datetime", null },
            { "fundingRate", this.safeNumber(contract, "fundingRate") },
            { "fundingTimestamp", fundingTimestamp },
            { "fundingDatetime", this.iso8601(fundingTimestamp) },
            { "nextFundingRate", null },
            { "nextFundingTimestamp", null },
            { "nextFundingDatetime", null },
            { "previousFundingRate", null },
            { "previousFundingTimestamp", null },
            { "previousFundingDatetime", null },
            { "interval", null },
        };
    }

    public virtual object hashOrderMessage(object order)
    {
        object accountHash = this.hash(this.ethAbiEncode(new List<object>() {"bytes32", "uint256", "uint256", "address", "bytes32", "uint256", "address", "address"}, order), keccak, "binary");
        object sandboxMode = this.safeBool(this.options, "sandboxMode", false);
        object DOMAIN_SEPARATOR = ((bool) isTrue((sandboxMode))) ? "9bcf4dc06df5d8bf23af818d5716491b995020f377d3b7b64c29ed14e3dd1105" : "d96e5f90797da7ec8dc4e276260c7f3f87fedf68775fbe1ef116e996fc60441b";
        object binaryDomainSeparator = this.base16ToBinary(DOMAIN_SEPARATOR);
        object prefix = this.base16ToBinary("1901");
        return this.hash(this.binaryConcat(prefix, binaryDomainSeparator, accountHash), keccak, "hex");
    }

    public virtual object signOrder(object order, object privateKey)
    {
        object hashOrder = this.hashOrderMessage(order);
        return this.signHash(slice(hashOrder, -64, null), slice(privateKey, -64, null));
    }

    public virtual object hashMessage(object message)
    {
        object binaryMessage = this.encode(message);
        object binaryMessageLength = this.binaryLength(binaryMessage);
        object x19 = this.base16ToBinary("19");
        object newline = this.base16ToBinary("0a");
        object prefix = this.binaryConcat(x19, this.encode("Ethereum Signed Message:"), newline, this.encode(this.numberToString(binaryMessageLength)));
        return add("0x", this.hash(this.binaryConcat(prefix, binaryMessage), keccak, "hex"));
    }

    public virtual object signHash(object hash, object privateKey)
    {
        this.checkRequiredCredentials();
        object signature = ecdsa(slice(hash, -64, null), slice(privateKey, -64, null), secp256k1, null);
        object r = getValue(signature, "r");
        object s = getValue(signature, "s");
        object v = this.intToBase16(this.sum(27, getValue(signature, "v")));
        return add(add(add("0x", (r as String).PadLeft(Convert.ToInt32(64), Convert.ToChar("0"))), (s as String).PadLeft(Convert.ToInt32(64), Convert.ToChar("0"))), v);
    }

    public virtual object signMessage(object message, object privateKey)
    {
        return this.signHash(this.hashMessage(message), slice(privateKey, -64, null));
    }

    public virtual object parseUnits(object num, object dec = null)
    {
        dec ??= "1000000000000000000";
        return Precise.stringMul(num, dec);
    }

    /**
     * @method
     * @name derive#createOrder
     * @description create a trade order
     * @see https://docs.derive.xyz/reference/post_private-order
     * @param {string} symbol unified symbol of the market to create an order in
     * @param {string} type 'market' or 'limit'
     * @param {string} side 'buy' or 'sell'
     * @param {float} amount how much of currency you want to trade in units of base currency
     * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.subaccount_id] *required* the subaccount id
     * @param {float} [params.triggerPrice] The price a trigger order is triggered at
     * @param {object} [params.takeProfit] *takeProfit object in params* containing the triggerPrice at which the attached take profit order will be triggered (perpetual swap markets only)
     * @param {float} [params.takeProfit.triggerPrice] take profit trigger price
     * @param {object} [params.stopLoss] *stopLoss object in params* containing the triggerPrice at which the attached stop loss order will be triggered (perpetual swap markets only)
     * @param {float} [params.stopLoss.triggerPrice] stop loss trigger price
     * @param {float} [params.max_fee] *required* the maximum fee you are willing to pay for the order
     * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> createOrder(object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        if (isTrue(isEqual(price, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " createOrder() requires a price argument")) ;
        }
        object subaccountId = null;
        var subaccountIdparametersVariable = this.handleDeriveSubaccountId("createOrder", parameters);
        subaccountId = ((IList<object>)subaccountIdparametersVariable)[0];
        parameters = ((IList<object>)subaccountIdparametersVariable)[1];
        object test = this.safeBool(parameters, "test", false);
        object reduceOnly = this.safeBool2(parameters, "reduceOnly", "reduce_only");
        object timeInForce = this.safeStringLower2(parameters, "timeInForce", "time_in_force");
        object postOnly = this.safeBool(parameters, "postOnly");
        object orderType = ((string)type).ToLower();
        object orderSide = ((string)side).ToLower();
        object nonce = this.milliseconds();
        // Order signature expiry must be between 2592000 and 7776000 sec from now
        object signatureExpiry = this.safeInteger(parameters, "signature_expiry_sec", add(this.seconds(), 7776000));
        object ACTION_TYPEHASH = this.base16ToBinary("4d7a9f27c403ff9c0f19bce61d76d82f9aa29f8d6d4b0c5474607d9770d1af17");
        object sandboxMode = this.safeBool(this.options, "sandboxMode", false);
        object TRADE_MODULE_ADDRESS = ((bool) isTrue((sandboxMode))) ? "0x87F2863866D85E3192a35A73b388BD625D83f2be" : "0xB8D20c2B7a1Ad2EE33Bc50eF10876eD3035b5e7b";
        object priceString = this.numberToString(price);
        object maxFee = null;
        var maxFeeparametersVariable = this.handleOptionAndParams(parameters, "createOrder", "max_fee");
        maxFee = ((IList<object>)maxFeeparametersVariable)[0];
        parameters = ((IList<object>)maxFeeparametersVariable)[1];
        if (isTrue(isEqual(maxFee, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " createOrder() requires a max_fee argument in params")) ;
        }
        object maxFeeString = this.numberToString(maxFee);
        object amountString = this.numberToString(amount);
        object tradeModuleDataHash = this.hash(this.ethAbiEncode(new List<object>() {"address", "uint", "int", "int", "uint", "uint", "bool"}, new List<object>() {getValue(getValue(market, "info"), "base_asset_address"), this.parseToNumeric(getValue(getValue(market, "info"), "base_asset_sub_id")), this.convertToBigInt(this.parseUnits(priceString)), this.convertToBigInt(this.parseUnits(this.amountToPrecision(symbol, amountString))), this.convertToBigInt(this.parseUnits(maxFeeString)), subaccountId, isEqual(orderSide, "buy")}), keccak, "binary");
        object deriveWalletAddress = null;
        var deriveWalletAddressparametersVariable = this.handleDeriveWalletAddress("createOrder", parameters);
        deriveWalletAddress = ((IList<object>)deriveWalletAddressparametersVariable)[0];
        parameters = ((IList<object>)deriveWalletAddressparametersVariable)[1];
        object signature = this.signOrder(new List<object>() {ACTION_TYPEHASH, subaccountId, nonce, TRADE_MODULE_ADDRESS, tradeModuleDataHash, signatureExpiry, deriveWalletAddress, this.walletAddress}, this.privateKey);
        object request = new Dictionary<string, object>() {
            { "instrument_name", getValue(market, "id") },
            { "direction", orderSide },
            { "order_type", orderType },
            { "nonce", nonce },
            { "amount", amountString },
            { "limit_price", priceString },
            { "max_fee", maxFeeString },
            { "subaccount_id", subaccountId },
            { "signature_expiry_sec", signatureExpiry },
            { "referral_code", this.safeString(this.options, "id", "0x0ad42b8e602c2d3d475ae52d678cf63d84ab2749") },
            { "signer", this.walletAddress },
        };
        if (isTrue(!isEqual(reduceOnly, null)))
        {
            ((IDictionary<string,object>)request)["reduce_only"] = reduceOnly;
            if (isTrue(isTrue(reduceOnly) && isTrue(postOnly)))
            {
                throw new InvalidOrder ((string)add(this.id, " cannot use reduce only with post only time in force")) ;
            }
        }
        if (isTrue(!isEqual(postOnly, null)))
        {
            ((IDictionary<string,object>)request)["time_in_force"] = "post_only";
        } else if (isTrue(!isEqual(timeInForce, null)))
        {
            ((IDictionary<string,object>)request)["time_in_force"] = timeInForce;
        }
        object stopLoss = this.safeValue(parameters, "stopLoss");
        object takeProfit = this.safeValue(parameters, "takeProfit");
        object triggerPriceType = this.safeString(parameters, "trigger_price_type", "mark");
        if (isTrue(!isEqual(stopLoss, null)))
        {
            object stopLossPrice = this.safeString(stopLoss, "triggerPrice", stopLoss);
            ((IDictionary<string,object>)request)["trigger_price"] = stopLossPrice;
            ((IDictionary<string,object>)request)["trigger_type"] = "stoploss";
            ((IDictionary<string,object>)request)["trigger_price_type"] = triggerPriceType;
        } else if (isTrue(!isEqual(takeProfit, null)))
        {
            object takeProfitPrice = this.safeString(takeProfit, "triggerPrice", takeProfit);
            ((IDictionary<string,object>)request)["trigger_price"] = takeProfitPrice;
            ((IDictionary<string,object>)request)["trigger_type"] = "takeprofit";
            ((IDictionary<string,object>)request)["trigger_price_type"] = triggerPriceType;
        }
        object clientOrderId = this.safeString(parameters, "clientOrderId");
        if (isTrue(!isEqual(clientOrderId, null)))
        {
            ((IDictionary<string,object>)request)["label"] = clientOrderId;
        }
        ((IDictionary<string,object>)request)["signature"] = signature;
        parameters = this.omit(parameters, new List<object>() {"reduceOnly", "reduce_only", "timeInForce", "time_in_force", "postOnly", "test", "clientOrderId", "stopPrice", "triggerPrice", "trigger_price", "stopLoss", "takeProfit", "trigger_price_type"});
        object response = null;
        if (isTrue(test))
        {
            response = await this.privatePostOrderDebug(this.extend(request, parameters));
        } else
        {
            response = await this.privatePostOrder(this.extend(request, parameters));
        }
        //
        // {
        //     "result": {
        //         "raw_data": {
        //             "subaccount_id": 130837,
        //             "nonce": 1736923517552,
        //             "module": "0x87F2863866D85E3192a35A73b388BD625D83f2be",
        //             "expiry": 86400,
        //             "owner": "0x108b9aF9279a525b8A8AeAbE7AC2bA925Bc50075",
        //             "signer": "0x108b9aF9279a525b8A8AeAbE7AC2bA925Bc50075",
        //             "signature": "0xaa4f42b2f3da33c668fa703ea872d4c3a6b55aca66025b5119e3bebb6679fe2e2794638db51dcace21fc39a498047835994f07eb59f311bb956ce057e66793d1c",
        //             "data": {
        //                 "asset": "0xAFB6Bb95cd70D5367e2C39e9dbEb422B9815339D",
        //                 "sub_id": 0,
        //                 "limit_price": "10000",
        //                 "desired_amount": "0.001",
        //                 "worst_fee": "0",
        //                 "recipient_id": 130837,
        //                 "is_bid": true,
        //                 "trade_id": ""
        //             }
        //         },
        //         "encoded_data": "0x000000000000000000000000afb6bb95cd70d5367e2c39e9dbeb422b9815339d000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000021e19e0c9bab240000000000000000000000000000000000000000000000000000000038d7ea4c680000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001ff150000000000000000000000000000000000000000000000000000000000000001",
        //         "encoded_data_hashed": "0xe88fb416bc54dba2d288988f1a82fee40fd792ed555b3471b5f6b4b810d279b4",
        //         "action_hash": "0x273a0befb3751fa991edc7ed73582456c3b50ae964d458c8f472e932fb6a0069",
        //         "typed_data_hash": "0x123e2d2f3d5b2473b4e260f51c6459d6bf904e5db8f042a3ea63be8d55329ce9"
        //     },
        //     "id": "f851c8c4-dddf-4b77-93cf-aeddd0966f29"
        // }
        // {
        //     "result": {
        //         "order": {
        //             "subaccount_id": 130837,
        //             "order_id": "96349ebb-7d46-43ae-81c7-7ab390444293",
        //             "instrument_name": "BTC-PERP",
        //             "direction": "buy",
        //             "label": "",
        //             "quote_id": null,
        //             "creation_timestamp": 1737467576257,
        //             "last_update_timestamp": 1737467576257,
        //             "limit_price": "10000",
        //             "amount": "0.01",
        //             "filled_amount": "0",
        //             "average_price": "0",
        //             "order_fee": "0",
        //             "order_type": "limit",
        //             "time_in_force": "gtc",
        //             "order_status": "open",
        //             "max_fee": "210",
        //             "signature_expiry_sec": 1737468175989,
        //             "nonce": 1737467575989,
        //             "signer": "0x30CB7B06AdD6749BbE146A6827502B8f2a79269A",
        //             "signature": "0xd1ca49df1fa06bd805bb59b132ff6c0de29bf973a3e01705abe0a01cc956e4945ed9eb99ab68f3df4c037908113cac5a5bfc3a954a0b7103cdab285962fa6a51c",
        //             "cancel_reason": "",
        //             "mmp": false,
        //             "is_transfer": false,
        //             "replaced_order_id": null,
        //             "trigger_type": null,
        //             "trigger_price_type": null,
        //             "trigger_price": null,
        //             "trigger_reject_message": null
        //         },
        //         "trades": []
        //     },
        //     "id": "397087fa-0125-42af-bfc3-f66166f9fb55"
        // }
        //
        object result = this.safeDict(response, "result");
        object rawOrder = this.safeDict(result, "raw_data");
        if (isTrue(isEqual(rawOrder, null)))
        {
            rawOrder = this.safeDict(result, "order");
        }
        object order = this.parseOrder(rawOrder, market);
        ((IDictionary<string,object>)order)["type"] = type;
        return order;
    }

    /**
     * @method
     * @name derive#editOrder
     * @description edit a trade order
     * @see https://docs.derive.xyz/reference/post_private-replace
     * @param {string} id order id
     * @param {string} symbol unified symbol of the market to create an order in
     * @param {string} type 'market' or 'limit'
     * @param {string} side 'buy' or 'sell'
     * @param {float} amount how much of currency you want to trade in units of base currency
     * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.subaccount_id] *required* the subaccount id
     * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> editOrder(object id, object symbol, object type, object side, object amount = null, object price = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object subaccountId = null;
        var subaccountIdparametersVariable = this.handleDeriveSubaccountId("editOrder", parameters);
        subaccountId = ((IList<object>)subaccountIdparametersVariable)[0];
        parameters = ((IList<object>)subaccountIdparametersVariable)[1];
        object reduceOnly = this.safeBool2(parameters, "reduceOnly", "reduce_only");
        object timeInForce = this.safeStringLower2(parameters, "timeInForce", "time_in_force");
        object postOnly = this.safeBool(parameters, "postOnly");
        object orderType = ((string)type).ToLower();
        object orderSide = ((string)side).ToLower();
        object nonce = this.milliseconds();
        object signatureExpiry = this.safeNumber(parameters, "signature_expiry_sec", add(this.seconds(), 7776000));
        // TODO: subaccount id / trade module address
        object ACTION_TYPEHASH = this.base16ToBinary("4d7a9f27c403ff9c0f19bce61d76d82f9aa29f8d6d4b0c5474607d9770d1af17");
        object sandboxMode = this.safeBool(this.options, "sandboxMode", false);
        object TRADE_MODULE_ADDRESS = ((bool) isTrue((sandboxMode))) ? "0x87F2863866D85E3192a35A73b388BD625D83f2be" : "0xB8D20c2B7a1Ad2EE33Bc50eF10876eD3035b5e7b";
        object priceString = this.numberToString(price);
        object maxFeeString = this.safeString(parameters, "max_fee", "0");
        object amountString = this.numberToString(amount);
        object tradeModuleDataHash = this.hash(this.ethAbiEncode(new List<object>() {"address", "uint", "int", "int", "uint", "uint", "bool"}, new List<object>() {getValue(getValue(market, "info"), "base_asset_address"), this.parseToNumeric(getValue(getValue(market, "info"), "base_asset_sub_id")), this.convertToBigInt(this.parseUnits(priceString)), this.convertToBigInt(this.parseUnits(this.amountToPrecision(symbol, amountString))), this.convertToBigInt(this.parseUnits(maxFeeString)), subaccountId, isEqual(orderSide, "buy")}), keccak, "binary");
        object deriveWalletAddress = null;
        var deriveWalletAddressparametersVariable = this.handleDeriveWalletAddress("editOrder", parameters);
        deriveWalletAddress = ((IList<object>)deriveWalletAddressparametersVariable)[0];
        parameters = ((IList<object>)deriveWalletAddressparametersVariable)[1];
        object signature = this.signOrder(new List<object>() {ACTION_TYPEHASH, subaccountId, nonce, TRADE_MODULE_ADDRESS, tradeModuleDataHash, signatureExpiry, deriveWalletAddress, this.walletAddress}, this.privateKey);
        object request = new Dictionary<string, object>() {
            { "instrument_name", getValue(market, "id") },
            { "order_id_to_cancel", id },
            { "direction", orderSide },
            { "order_type", orderType },
            { "nonce", nonce },
            { "amount", amountString },
            { "limit_price", priceString },
            { "max_fee", maxFeeString },
            { "subaccount_id", subaccountId },
            { "signature_expiry_sec", signatureExpiry },
            { "signer", this.walletAddress },
        };
        if (isTrue(!isEqual(reduceOnly, null)))
        {
            ((IDictionary<string,object>)request)["reduce_only"] = reduceOnly;
            if (isTrue(isTrue(reduceOnly) && isTrue(postOnly)))
            {
                throw new InvalidOrder ((string)add(this.id, " cannot use reduce only with post only time in force")) ;
            }
        }
        if (isTrue(!isEqual(postOnly, null)))
        {
            ((IDictionary<string,object>)request)["time_in_force"] = "post_only";
        } else if (isTrue(!isEqual(timeInForce, null)))
        {
            ((IDictionary<string,object>)request)["time_in_force"] = timeInForce;
        }
        object clientOrderId = this.safeString(parameters, "clientOrderId");
        if (isTrue(!isEqual(clientOrderId, null)))
        {
            ((IDictionary<string,object>)request)["label"] = clientOrderId;
        }
        ((IDictionary<string,object>)request)["signature"] = signature;
        parameters = this.omit(parameters, new List<object>() {"reduceOnly", "reduce_only", "timeInForce", "time_in_force", "postOnly", "clientOrderId"});
        object response = await this.privatePostReplace(this.extend(request, parameters));
        //
        //   {
        //     "result":
        //       {
        //         "cancelled_order":
        //           {
        //             "subaccount_id": 130837,
        //             "order_id": "c2337704-f1af-437d-91c8-dddb9d6bac59",
        //             "instrument_name": "BTC-PERP",
        //             "direction": "buy",
        //             "label": "test1234",
        //             "quote_id": null,
        //             "creation_timestamp": 1737539743959,
        //             "last_update_timestamp": 1737539764234,
        //             "limit_price": "10000",
        //             "amount": "0.01",
        //             "filled_amount": "0",
        //             "average_price": "0",
        //             "order_fee": "0",
        //             "order_type": "limit",
        //             "time_in_force": "post_only",
        //             "order_status": "cancelled",
        //             "max_fee": "211",
        //             "signature_expiry_sec": 1737540343631,
        //             "nonce": 1737539743631,
        //             "signer": "0x30CB7B06AdD6749BbE146A6827502B8f2a79269A",
        //             "signature": "0xdb669e18f407a3efa816b79c0dd3bac1c651d4dbf3caad4db67678ce9b81c76378d787a08143a30707eb0827ce4626640767c9f174358df1b90611bd6d1391711b",
        //             "cancel_reason": "user_request",
        //             "mmp": false,
        //             "is_transfer": false,
        //             "replaced_order_id": null,
        //             "trigger_type": null,
        //             "trigger_price_type": null,
        //             "trigger_price": null,
        //             "trigger_reject_message": null,
        //           },
        //         "order":
        //           {
        //             "subaccount_id": 130837,
        //             "order_id": "97af0902-813f-4892-a54b-797e5689db05",
        //             "instrument_name": "BTC-PERP",
        //             "direction": "buy",
        //             "label": "test1234",
        //             "quote_id": null,
        //             "creation_timestamp": 1737539764154,
        //             "last_update_timestamp": 1737539764154,
        //             "limit_price": "10000",
        //             "amount": "0.01",
        //             "filled_amount": "0",
        //             "average_price": "0",
        //             "order_fee": "0",
        //             "order_type": "limit",
        //             "time_in_force": "post_only",
        //             "order_status": "open",
        //             "max_fee": "211",
        //             "signature_expiry_sec": 1737540363890,
        //             "nonce": 1737539763890,
        //             "signer": "0x30CB7B06AdD6749BbE146A6827502B8f2a79269A",
        //             "signature": "0xef2c459ab4797cbbd7d97b47678ff172542af009bac912bf53e7879cf92eb1aa6b1a6cf40bf0928684f5394942fb424cc2db71eac0eaf7226a72480034332f291c",
        //             "cancel_reason": "",
        //             "mmp": false,
        //             "is_transfer": false,
        //             "replaced_order_id": "c2337704-f1af-437d-91c8-dddb9d6bac59",
        //             "trigger_type": null,
        //             "trigger_price_type": null,
        //             "trigger_price": null,
        //             "trigger_reject_message": null,
        //           },
        //         "trades": [],
        //         "create_order_error": null,
        //       },
        //     "id": "fb19e991-15f6-4c80-a20c-917e762a1a38",
        //   }
        //
        object result = this.safeDict(response, "result");
        object rawOrder = this.safeDict(result, "order");
        object order = this.parseOrder(rawOrder, market);
        return order;
    }

    /**
     * @method
     * @name derive#cancelOrder
     * @see https://docs.derive.xyz/reference/post_private-cancel
     * @description cancels an open order
     * @param {string} id order id
     * @param {string} symbol unified symbol of the market the order was made in
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {boolean} [params.trigger] whether the order is a trigger/algo order
     * @param {string} [params.subaccount_id] *required* the subaccount id
     * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> cancelOrder(object id, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " cancelOrder() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object isTrigger = this.safeBool2(parameters, "trigger", "stop", false);
        object subaccountId = null;
        var subaccountIdparametersVariable = this.handleDeriveSubaccountId("cancelOrder", parameters);
        subaccountId = ((IList<object>)subaccountIdparametersVariable)[0];
        parameters = ((IList<object>)subaccountIdparametersVariable)[1];
        parameters = this.omit(parameters, new List<object>() {"trigger", "stop"});
        object request = new Dictionary<string, object>() {
            { "instrument_name", getValue(market, "id") },
            { "subaccount_id", subaccountId },
        };
        object clientOrderIdUnified = this.safeString(parameters, "clientOrderId");
        object clientOrderIdExchangeSpecific = this.safeString(parameters, "label", clientOrderIdUnified);
        object isByClientOrder = !isEqual(clientOrderIdExchangeSpecific, null);
        object response = null;
        if (isTrue(isByClientOrder))
        {
            ((IDictionary<string,object>)request)["label"] = clientOrderIdExchangeSpecific;
            parameters = this.omit(parameters, new List<object>() {"clientOrderId", "label"});
            response = await this.privatePostCancelByLabel(this.extend(request, parameters));
        } else
        {
            ((IDictionary<string,object>)request)["order_id"] = id;
            if (isTrue(isTrigger))
            {
                response = await this.privatePostCancelTriggerOrder(this.extend(request, parameters));
            } else
            {
                response = await this.privatePostCancel(this.extend(request, parameters));
            }
        }
        //
        // {
        //     "result": {
        //         "subaccount_id": 130837,
        //         "order_id": "de4f30b6-0dcb-4df6-9222-c1a27f1ad80d",
        //         "instrument_name": "BTC-PERP",
        //         "direction": "buy",
        //         "label": "test1234",
        //         "quote_id": null,
        //         "creation_timestamp": 1737540100989,
        //         "last_update_timestamp": 1737540574696,
        //         "limit_price": "10000",
        //         "amount": "0.01",
        //         "filled_amount": "0",
        //         "average_price": "0",
        //         "order_fee": "0",
        //         "order_type": "limit",
        //         "time_in_force": "post_only",
        //         "order_status": "cancelled",
        //         "max_fee": "211",
        //         "signature_expiry_sec": 1737540700726,
        //         "nonce": 1737540100726,
        //         "signer": "0x30CB7B06AdD6749BbE146A6827502B8f2a79269A",
        //         "signature": "0x9cd1a6e32a0699929e4e090c08c548366b1353701ec56e02d5cdf37fc89bd19b7b29e00e57e8383bb6336d73019027a7e2a4364f40859e7a949115024c7f199a1b",
        //         "cancel_reason": "user_request",
        //         "mmp": false,
        //         "is_transfer": false,
        //         "replaced_order_id": "4ccc89ba-3c3d-4047-8900-0aa5fb4ef706",
        //         "trigger_type": null,
        //         "trigger_price_type": null,
        //         "trigger_price": null,
        //         "trigger_reject_message": null
        //     },
        //     "id": "cef61e2a-cb13-4779-8e6b-535361981fad"
        // }
        //
        // {
        //     "result": {
        //         "cancelled_orders": 1
        //     },
        //     "id": "674e075e-1e8a-4a47-99ff-75efbdd2370f"
        // }
        //
        object extendParams = new Dictionary<string, object>() {
            { "symbol", symbol },
        };
        object order = this.safeDict(response, "result");
        if (isTrue(isByClientOrder))
        {
            ((IDictionary<string,object>)extendParams)["client_order_id"] = clientOrderIdExchangeSpecific;
        }
        return this.extend(this.parseOrder(order, market), extendParams);
    }

    /**
     * @method
     * @name derive#cancelAllOrders
     * @see https://docs.derive.xyz/reference/post_private-cancel-by-instrument
     * @see https://docs.derive.xyz/reference/post_private-cancel-all
     * @description cancel all open orders in a market
     * @param {string} symbol unified market symbol
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.subaccount_id] *required* the subaccount id
     * @returns {object} an list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> cancelAllOrders(object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
        }
        object subaccountId = null;
        var subaccountIdparametersVariable = this.handleDeriveSubaccountId("cancelAllOrders", parameters);
        subaccountId = ((IList<object>)subaccountIdparametersVariable)[0];
        parameters = ((IList<object>)subaccountIdparametersVariable)[1];
        object request = new Dictionary<string, object>() {
            { "subaccount_id", subaccountId },
        };
        object response = null;
        if (isTrue(!isEqual(market, null)))
        {
            ((IDictionary<string,object>)request)["instrument_name"] = getValue(market, "id");
            response = await this.privatePostCancelByInstrument(this.extend(request, parameters));
        } else
        {
            response = await this.privatePostCancelAll(this.extend(request, parameters));
        }
        //
        // {
        //     "result": {
        //         "cancelled_orders": 0
        //     },
        //     "id": "9d633799-2098-4559-b547-605bb6f4d8f4"
        // }
        //
        // {
        //     "id": "45548646-c74f-4ca2-9de4-551e6de49afa",
        //     "result": "ok"
        // }
        //
        return response;
    }

    /**
     * @method
     * @name derive#fetchOrders
     * @description fetches information on multiple orders made by the user
     * @see https://docs.derive.xyz/reference/post_private-get-orders
     * @param {string} symbol unified market symbol of the market orders were made in
     * @param {int} [since] the earliest time in ms to fetch orders for
     * @param {int} [limit] the maximum number of order structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {boolean} [params.paginate] set to true if you want to fetch orders with pagination
     * @param {boolean} [params.trigger] whether the order is a trigger/algo order
     * @param {string} [params.subaccount_id] *required* the subaccount id
     * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> fetchOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object paginate = false;
        var paginateparametersVariable = this.handleOptionAndParams(parameters, "fetchOrders", "paginate");
        paginate = ((IList<object>)paginateparametersVariable)[0];
        parameters = ((IList<object>)paginateparametersVariable)[1];
        if (isTrue(paginate))
        {
            return await this.fetchPaginatedCallIncremental("fetchOrders", symbol, since, limit, parameters, "page", 500);
        }
        object isTrigger = this.safeBool2(parameters, "trigger", "stop", false);
        parameters = this.omit(parameters, new List<object>() {"trigger", "stop"});
        object subaccountId = null;
        var subaccountIdparametersVariable = this.handleDeriveSubaccountId("fetchOrders", parameters);
        subaccountId = ((IList<object>)subaccountIdparametersVariable)[0];
        parameters = ((IList<object>)subaccountIdparametersVariable)[1];
        object request = new Dictionary<string, object>() {
            { "subaccount_id", subaccountId },
        };
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            ((IDictionary<string,object>)request)["instrument_name"] = getValue(market, "id");
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["page_size"] = limit;
        } else
        {
            ((IDictionary<string,object>)request)["page_size"] = 500;
        }
        if (isTrue(isTrigger))
        {
            ((IDictionary<string,object>)request)["status"] = "untriggered";
        }
        object response = await this.privatePostGetOrders(this.extend(request, parameters));
        //
        // {
        //     "result": {
        //         "subaccount_id": 130837,
        //         "orders": [
        //             {
        //                 "subaccount_id": 130837,
        //                 "order_id": "63a80cb8-387b-472b-a838-71cd9513c365",
        //                 "instrument_name": "BTC-PERP",
        //                 "direction": "buy",
        //                 "label": "test1234",
        //                 "quote_id": null,
        //                 "creation_timestamp": 1737551053207,
        //                 "last_update_timestamp": 1737551053207,
        //                 "limit_price": "10000",
        //                 "amount": "0.01",
        //                 "filled_amount": "0",
        //                 "average_price": "0",
        //                 "order_fee": "0",
        //                 "order_type": "limit",
        //                 "time_in_force": "post_only",
        //                 "order_status": "open",
        //                 "max_fee": "211",
        //                 "signature_expiry_sec": 1737551652765,
        //                 "nonce": 1737551052765,
        //                 "signer": "0x30CB7B06AdD6749BbE146A6827502B8f2a79269A",
        //                 "signature": "0x35535ccb1bcad509ecc435c79e966174db6403fc9aeee1e237d08a941014c57b59279dfe4be39e081f9921a53eaad59cb2a151d9f52f2d05fc47e6280254952e1c",
        //                 "cancel_reason": "",
        //                 "mmp": false,
        //                 "is_transfer": false,
        //                 "replaced_order_id": null,
        //                 "trigger_type": null,
        //                 "trigger_price_type": null,
        //                 "trigger_price": null,
        //                 "trigger_reject_message": null
        //             }
        //         ],
        //         "pagination": {
        //             "num_pages": 1,
        //             "count": 1
        //         }
        //     },
        //     "id": "e5a88d4f-7ac7-40cd-aec9-e0e8152b8b92"
        // }
        //
        object data = this.safeValue(response, "result");
        object page = this.safeInteger(parameters, "page");
        if (isTrue(!isEqual(page, null)))
        {
            object pagination = this.safeDict(data, "pagination");
            object currentPage = this.safeInteger(pagination, "num_pages");
            if (isTrue(isGreaterThan(page, currentPage)))
            {
                return new List<object>() {};
            }
        }
        object orders = this.safeList(data, "orders");
        return this.parseOrders(orders, market, since, limit);
    }

    /**
     * @method
     * @name derive#fetchOpenOrders
     * @description fetches information on multiple orders made by the user
     * @see https://docs.derive.xyz/reference/post_private-get-orders
     * @param {string} symbol unified market symbol of the market orders were made in
     * @param {int} [since] the earliest time in ms to fetch orders for
     * @param {int} [limit] the maximum number of order structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {boolean} [params.paginate] set to true if you want to fetch orders with pagination
     * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> fetchOpenOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object extendedParams = this.extend(parameters, new Dictionary<string, object>() {
            { "status", "open" },
        });
        return await this.fetchOrders(symbol, since, limit, extendedParams);
    }

    /**
     * @method
     * @name derive#fetchClosedOrders
     * @description fetches information on multiple orders made by the user
     * @see https://docs.derive.xyz/reference/post_private-get-orders
     * @param {string} symbol unified market symbol of the market orders were made in
     * @param {int} [since] the earliest time in ms to fetch orders for
     * @param {int} [limit] the maximum number of order structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {boolean} [params.paginate] set to true if you want to fetch orders with pagination
     * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> fetchClosedOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object extendedParams = this.extend(parameters, new Dictionary<string, object>() {
            { "status", "filled" },
        });
        return await this.fetchOrders(symbol, since, limit, extendedParams);
    }

    /**
     * @method
     * @name derive#fetchCanceledOrders
     * @description fetches information on multiple canceled orders made by the user
     * @see https://docs.derive.xyz/reference/post_private-get-orders
     * @param {string} symbol unified market symbol of the market the orders were made in
     * @param {int} [since] the earliest time in ms to fetch orders for
     * @param {int} [limit] the maximum number of order structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [available parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
     * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async virtual Task<object> fetchCanceledOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object extendedParams = this.extend(parameters, new Dictionary<string, object>() {
            { "status", "cancelled" },
        });
        return await this.fetchOrders(symbol, since, limit, extendedParams);
    }

    public virtual object parseTimeInForce(object timeInForce)
    {
        object timeInForces = new Dictionary<string, object>() {
            { "ioc", "IOC" },
            { "fok", "FOK" },
            { "gtc", "GTC" },
            { "post_only", "PO" },
        };
        return this.safeString(timeInForces, timeInForce, null);
    }

    public virtual object parseOrderStatus(object status)
    {
        if (isTrue(!isEqual(status, null)))
        {
            object statuses = new Dictionary<string, object>() {
                { "open", "open" },
                { "untriggered", "open" },
                { "filled", "closed" },
                { "cancelled", "canceled" },
                { "expired", "rejected" },
            };
            return this.safeString(statuses, status, status);
        }
        return status;
    }

    public override object parseOrder(object rawOrder, object market = null)
    {
        //
        // {
        //     "subaccount_id": 130837,
        //     "nonce": 1736923517552,
        //     "module": "0x87F2863866D85E3192a35A73b388BD625D83f2be",
        //     "expiry": 86400,
        //     "owner": "0x108b9aF9279a525b8A8AeAbE7AC2bA925Bc50075",
        //     "signer": "0x108b9aF9279a525b8A8AeAbE7AC2bA925Bc50075",
        //     "signature": "0xaa4f42b2f3da33c668fa703ea872d4c3a6b55aca66025b5119e3bebb6679fe2e2794638db51dcace21fc39a498047835994f07eb59f311bb956ce057e66793d1c",
        //     "data": {
        //         "asset": "0xAFB6Bb95cd70D5367e2C39e9dbEb422B9815339D",
        //         "sub_id": 0,
        //         "limit_price": "10000",
        //         "desired_amount": "0.001",
        //         "worst_fee": "0",
        //         "recipient_id": 130837,
        //         "is_bid": true,
        //         "trade_id": ""
        //     }
        // }
        // {
        //     "subaccount_id": 130837,
        //     "order_id": "96349ebb-7d46-43ae-81c7-7ab390444293",
        //     "instrument_name": "BTC-PERP",
        //     "direction": "buy",
        //     "label": "",
        //     "quote_id": null,
        //     "creation_timestamp": 1737467576257,
        //     "last_update_timestamp": 1737467576257,
        //     "limit_price": "10000",
        //     "amount": "0.01",
        //     "filled_amount": "0",
        //     "average_price": "0",
        //     "order_fee": "0",
        //     "order_type": "limit",
        //     "time_in_force": "gtc",
        //     "order_status": "open",
        //     "max_fee": "210",
        //     "signature_expiry_sec": 1737468175989,
        //     "nonce": 1737467575989,
        //     "signer": "0x30CB7B06AdD6749BbE146A6827502B8f2a79269A",
        //     "signature": "0xd1ca49df1fa06bd805bb59b132ff6c0de29bf973a3e01705abe0a01cc956e4945ed9eb99ab68f3df4c037908113cac5a5bfc3a954a0b7103cdab285962fa6a51c",
        //     "cancel_reason": "",
        //     "mmp": false,
        //     "is_transfer": false,
        //     "replaced_order_id": null,
        //     "trigger_type": null,
        //     "trigger_price_type": null,
        //     "trigger_price": null,
        //     "trigger_reject_message": null
        // }
        object order = this.safeDict(rawOrder, "data");
        if (isTrue(isEqual(order, null)))
        {
            order = rawOrder;
        }
        object timestamp = this.safeInteger(rawOrder, "nonce");
        object orderId = this.safeString(order, "order_id");
        object marketId = this.safeString(order, "instrument_name");
        if (isTrue(!isEqual(marketId, null)))
        {
            market = this.safeMarket(marketId, market);
        }
        object symbol = getValue(market, "symbol");
        object price = this.safeString(order, "limit_price");
        object average = this.safeString(order, "average_price");
        object amount = this.safeString(order, "desired_amount");
        object filled = this.safeString(order, "filled_amount");
        object fee = this.safeString(order, "order_fee");
        object orderType = this.safeStringLower(order, "order_type");
        object isBid = this.safeBool(order, "is_bid");
        object side = this.safeString(order, "direction");
        if (isTrue(isEqual(side, null)))
        {
            if (isTrue(isBid))
            {
                side = "buy";
            } else
            {
                side = "sell";
            }
        }
        object triggerType = this.safeString(order, "trigger_type");
        object stopLossPrice = null;
        object takeProfitPrice = null;
        object triggerPrice = null;
        if (isTrue(!isEqual(triggerType, null)))
        {
            triggerPrice = this.safeString(order, "trigger_price");
            if (isTrue(isEqual(triggerType, "stoploss")))
            {
                stopLossPrice = triggerPrice;
            } else
            {
                takeProfitPrice = triggerPrice;
            }
        }
        object lastUpdateTimestamp = this.safeInteger(rawOrder, "last_update_timestamp");
        object status = this.safeString(order, "order_status");
        object timeInForce = this.safeString(order, "time_in_force");
        return this.safeOrder(new Dictionary<string, object>() {
            { "id", orderId },
            { "clientOrderId", this.safeString(order, "label") },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "lastTradeTimestamp", null },
            { "lastUpdateTimestamp", lastUpdateTimestamp },
            { "status", this.parseOrderStatus(status) },
            { "symbol", symbol },
            { "type", orderType },
            { "timeInForce", this.parseTimeInForce(timeInForce) },
            { "postOnly", null },
            { "reduceOnly", this.safeBool(order, "reduce_only") },
            { "side", side },
            { "price", price },
            { "triggerPrice", triggerPrice },
            { "takeProfitPrice", takeProfitPrice },
            { "stopLossPrice", stopLossPrice },
            { "average", average },
            { "amount", amount },
            { "filled", filled },
            { "remaining", null },
            { "cost", null },
            { "trades", null },
            { "fee", new Dictionary<string, object>() {
                { "cost", fee },
                { "currency", "USDC" },
            } },
            { "info", order },
        }, market);
    }

    /**
     * @method
     * @name derive#fetchOrderTrades
     * @description fetch all the trades made from a single order
     * @see https://docs.derive.xyz/reference/post_private-get-trade-history
     * @param {string} id order id
     * @param {string} symbol unified market symbol
     * @param {int} [since] the earliest time in ms to fetch trades for
     * @param {int} [limit] the maximum number of trades to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.subaccount_id] *required* the subaccount id
     * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
     */
    public async override Task<object> fetchOrderTrades(object id, object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object subaccountId = null;
        var subaccountIdparametersVariable = this.handleDeriveSubaccountId("fetchOrderTrades", parameters);
        subaccountId = ((IList<object>)subaccountIdparametersVariable)[0];
        parameters = ((IList<object>)subaccountIdparametersVariable)[1];
        object request = new Dictionary<string, object>() {
            { "order_id", id },
            { "subaccount_id", subaccountId },
        };
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            ((IDictionary<string,object>)request)["instrument_name"] = getValue(market, "id");
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["page_size"] = limit;
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["from_timestamp"] = since;
        }
        object response = await this.privatePostGetTradeHistory(this.extend(request, parameters));
        //
        // {
        //     "result": {
        //         "subaccount_id": 130837,
        //         "trades": [
        //             {
        //                 "subaccount_id": 130837,
        //                 "order_id": "30c48194-8d48-43ac-ad00-0d5ba29eddc9",
        //                 "instrument_name": "BTC-PERP",
        //                 "direction": "sell",
        //                 "label": "test1234",
        //                 "quote_id": null,
        //                 "trade_id": "f8a30740-488c-4c2d-905d-e17057bafde1",
        //                 "timestamp": 1738065303708,
        //                 "mark_price": "102740.137375457314192317",
        //                 "index_price": "102741.553409299981533184",
        //                 "trade_price": "102700.6",
        //                 "trade_amount": "0.01",
        //                 "liquidity_role": "taker",
        //                 "realized_pnl": "0",
        //                 "realized_pnl_excl_fees": "0",
        //                 "is_transfer": false,
        //                 "tx_status": "settled",
        //                 "trade_fee": "1.127415534092999815",
        //                 "tx_hash": "0xc55df1f07330faf86579bd8a6385391fbe9e73089301149d8550e9d29c9ead74",
        //                 "transaction_id": "e18b9426-3fa5-41bb-99d3-8b54fb4d51bb"
        //             }
        //         ],
        //         "pagination": {
        //             "num_pages": 1,
        //             "count": 1
        //         }
        //     },
        //     "id": "a16f798c-a121-44e2-b77e-c38a063f8a99"
        // }
        //
        object result = this.safeDict(response, "result", new Dictionary<string, object>() {});
        object trades = this.safeList(result, "trades", new List<object>() {});
        return this.parseTrades(trades, market, since, limit, parameters);
    }

    /**
     * @method
     * @name derive#fetchMyTrades
     * @description fetch all trades made by the user
     * @see https://docs.derive.xyz/reference/post_private-get-trade-history
     * @param {string} symbol unified market symbol
     * @param {int} [since] the earliest time in ms to fetch trades for
     * @param {int} [limit] the maximum number of trades structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {boolean} [params.paginate] set to true if you want to fetch trades with pagination
     * @param {string} [params.subaccount_id] *required* the subaccount id
     * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
     */
    public async override Task<object> fetchMyTrades(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object paginate = false;
        var paginateparametersVariable = this.handleOptionAndParams(parameters, "fetchMyTrades", "paginate");
        paginate = ((IList<object>)paginateparametersVariable)[0];
        parameters = ((IList<object>)paginateparametersVariable)[1];
        if (isTrue(paginate))
        {
            return await this.fetchPaginatedCallIncremental("fetchMyTrades", symbol, since, limit, parameters, "page", 500);
        }
        object subaccountId = null;
        var subaccountIdparametersVariable = this.handleDeriveSubaccountId("fetchMyTrades", parameters);
        subaccountId = ((IList<object>)subaccountIdparametersVariable)[0];
        parameters = ((IList<object>)subaccountIdparametersVariable)[1];
        object request = new Dictionary<string, object>() {
            { "subaccount_id", subaccountId },
        };
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            ((IDictionary<string,object>)request)["instrument_name"] = getValue(market, "id");
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["page_size"] = limit;
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["from_timestamp"] = since;
        }
        object response = await this.privatePostGetTradeHistory(this.extend(request, parameters));
        //
        // {
        //     "result": {
        //         "subaccount_id": 130837,
        //         "trades": [
        //             {
        //                 "subaccount_id": 130837,
        //                 "order_id": "30c48194-8d48-43ac-ad00-0d5ba29eddc9",
        //                 "instrument_name": "BTC-PERP",
        //                 "direction": "sell",
        //                 "label": "test1234",
        //                 "quote_id": null,
        //                 "trade_id": "f8a30740-488c-4c2d-905d-e17057bafde1",
        //                 "timestamp": 1738065303708,
        //                 "mark_price": "102740.137375457314192317",
        //                 "index_price": "102741.553409299981533184",
        //                 "trade_price": "102700.6",
        //                 "trade_amount": "0.01",
        //                 "liquidity_role": "taker",
        //                 "realized_pnl": "0",
        //                 "realized_pnl_excl_fees": "0",
        //                 "is_transfer": false,
        //                 "tx_status": "settled",
        //                 "trade_fee": "1.127415534092999815",
        //                 "tx_hash": "0xc55df1f07330faf86579bd8a6385391fbe9e73089301149d8550e9d29c9ead74",
        //                 "transaction_id": "e18b9426-3fa5-41bb-99d3-8b54fb4d51bb"
        //             }
        //         ],
        //         "pagination": {
        //             "num_pages": 1,
        //             "count": 1
        //         }
        //     },
        //     "id": "a16f798c-a121-44e2-b77e-c38a063f8a99"
        // }
        //
        object result = this.safeDict(response, "result", new Dictionary<string, object>() {});
        object page = this.safeInteger(parameters, "page");
        if (isTrue(!isEqual(page, null)))
        {
            object pagination = this.safeDict(result, "pagination");
            object currentPage = this.safeInteger(pagination, "num_pages");
            if (isTrue(isGreaterThan(page, currentPage)))
            {
                return new List<object>() {};
            }
        }
        object trades = this.safeList(result, "trades", new List<object>() {});
        return this.parseTrades(trades, market, since, limit, parameters);
    }

    /**
     * @method
     * @name derive#fetchPositions
     * @description fetch all open positions
     * @see https://docs.derive.xyz/reference/post_private-get-positions
     * @param {string[]} [symbols] not used by kraken fetchPositions ()
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.subaccount_id] *required* the subaccount id
     * @returns {object[]} a list of [position structure]{@link https://docs.ccxt.com/#/?id=position-structure}
     */
    public async override Task<object> fetchPositions(object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object subaccountId = null;
        var subaccountIdparametersVariable = this.handleDeriveSubaccountId("fetchPositions", parameters);
        subaccountId = ((IList<object>)subaccountIdparametersVariable)[0];
        parameters = ((IList<object>)subaccountIdparametersVariable)[1];
        object request = new Dictionary<string, object>() {
            { "subaccount_id", subaccountId },
        };
        parameters = this.omit(parameters, new List<object>() {"subaccount_id"});
        object response = await this.privatePostGetPositions(this.extend(request, parameters));
        //
        // {
        //     "result": {
        //         "subaccount_id": 130837,
        //         "positions": [
        //             {
        //                 "instrument_type": "perp",
        //                 "instrument_name": "BTC-PERP",
        //                 "amount": "-0.02",
        //                 "average_price": "102632.9105389869500088",
        //                 "realized_pnl": "0",
        //                 "unrealized_pnl": "-2.6455959784245548835819950103759765625",
        //                 "total_fees": "2.255789220260999824",
        //                 "average_price_excl_fees": "102745.7",
        //                 "realized_pnl_excl_fees": "0",
        //                 "unrealized_pnl_excl_fees": "-0.3898067581635550595819950103759765625",
        //                 "net_settlements": "-4.032902047219498639",
        //                 "cumulative_funding": "-0.004677736347850093",
        //                 "pending_funding": "0",
        //                 "mark_price": "102765.190337908177752979099750518798828125",
        //                 "index_price": "102767.657193800017641472",
        //                 "delta": "1",
        //                 "gamma": "0",
        //                 "vega": "0",
        //                 "theta": "0",
        //                 "mark_value": "1.38730606879471451975405216217041015625",
        //                 "maintenance_margin": "-101.37788426911356509663164615631103515625",
        //                 "initial_margin": "-132.2074413704858670826070010662078857421875",
        //                 "open_orders_margin": "264.116085900726830004714429378509521484375",
        //                 "leverage": "8.6954476205089299495699106539379941746377322586618",
        //                 "liquidation_price": "109125.705451984322280623018741607666015625",
        //                 "creation_timestamp": 1738065303840
        //             }
        //         ]
        //     },
        //     "id": "167350f1-d9fc-41d4-9797-1c78f83fda8e"
        // }
        //
        object result = this.safeDict(response, "result", new Dictionary<string, object>() {});
        object positions = this.safeList(result, "positions", new List<object>() {});
        return this.parsePositions(positions, symbols);
    }

    public override object parsePosition(object position, object market = null)
    {
        //
        // {
        //     "instrument_type": "perp",
        //     "instrument_name": "BTC-PERP",
        //     "amount": "-0.02",
        //     "average_price": "102632.9105389869500088",
        //     "realized_pnl": "0",
        //     "unrealized_pnl": "-2.6455959784245548835819950103759765625",
        //     "total_fees": "2.255789220260999824",
        //     "average_price_excl_fees": "102745.7",
        //     "realized_pnl_excl_fees": "0",
        //     "unrealized_pnl_excl_fees": "-0.3898067581635550595819950103759765625",
        //     "net_settlements": "-4.032902047219498639",
        //     "cumulative_funding": "-0.004677736347850093",
        //     "pending_funding": "0",
        //     "mark_price": "102765.190337908177752979099750518798828125",
        //     "index_price": "102767.657193800017641472",
        //     "delta": "1",
        //     "gamma": "0",
        //     "vega": "0",
        //     "theta": "0",
        //     "mark_value": "1.38730606879471451975405216217041015625",
        //     "maintenance_margin": "-101.37788426911356509663164615631103515625",
        //     "initial_margin": "-132.2074413704858670826070010662078857421875",
        //     "open_orders_margin": "264.116085900726830004714429378509521484375",
        //     "leverage": "8.6954476205089299495699106539379941746377322586618",
        //     "liquidation_price": "109125.705451984322280623018741607666015625",
        //     "creation_timestamp": 1738065303840
        // }
        //
        object contract = this.safeString(position, "instrument_name");
        market = this.safeMarket(contract, market);
        object size = this.safeString(position, "amount");
        object side = null;
        if (isTrue(Precise.stringGt(size, "0")))
        {
            side = "long";
        } else
        {
            side = "short";
        }
        object contractSize = this.safeString(market, "contractSize");
        object markPrice = this.safeString(position, "mark_price");
        object timestamp = this.safeInteger(position, "creation_timestamp");
        object unrealisedPnl = this.safeString(position, "unrealized_pnl");
        size = Precise.stringAbs(size);
        object notional = Precise.stringMul(size, markPrice);
        return this.safePosition(new Dictionary<string, object>() {
            { "info", position },
            { "id", null },
            { "symbol", this.safeString(market, "symbol") },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "lastUpdateTimestamp", null },
            { "initialMargin", this.safeString(position, "initial_margin") },
            { "initialMarginPercentage", null },
            { "maintenanceMargin", this.safeString(position, "maintenance_margin") },
            { "maintenanceMarginPercentage", null },
            { "entryPrice", null },
            { "notional", this.parseNumber(notional) },
            { "leverage", this.safeNumber(position, "leverage") },
            { "unrealizedPnl", this.parseNumber(unrealisedPnl) },
            { "contracts", this.parseNumber(size) },
            { "contractSize", this.parseNumber(contractSize) },
            { "marginRatio", null },
            { "liquidationPrice", this.safeNumber(position, "liquidation_price") },
            { "markPrice", this.parseNumber(markPrice) },
            { "lastPrice", null },
            { "collateral", null },
            { "marginMode", null },
            { "side", side },
            { "percentage", null },
            { "hedged", null },
            { "stopLossPrice", null },
            { "takeProfitPrice", null },
        });
    }

    /**
     * @method
     * @name derive#fetchFundingHistory
     * @description fetch the history of funding payments paid and received on this account
     * @see https://docs.derive.xyz/reference/post_private-get-funding-history
     * @param {string} [symbol] unified market symbol
     * @param {int} [since] the earliest time in ms to fetch funding history for
     * @param {int} [limit] the maximum number of funding history structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [availble parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
     * @returns {object} a [funding history structure]{@link https://docs.ccxt.com/#/?id=funding-history-structure}
     */
    public async override Task<object> fetchFundingHistory(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object paginate = false;
        var paginateparametersVariable = this.handleOptionAndParams(parameters, "fetchFundingHistory", "paginate");
        paginate = ((IList<object>)paginateparametersVariable)[0];
        parameters = ((IList<object>)paginateparametersVariable)[1];
        if (isTrue(paginate))
        {
            return await this.fetchPaginatedCallIncremental("fetchFundingHistory", symbol, since, limit, parameters, "page", 500);
        }
        object subaccountId = null;
        var subaccountIdparametersVariable = this.handleDeriveSubaccountId("fetchFundingHistory", parameters);
        subaccountId = ((IList<object>)subaccountIdparametersVariable)[0];
        parameters = ((IList<object>)subaccountIdparametersVariable)[1];
        object request = new Dictionary<string, object>() {
            { "subaccount_id", subaccountId },
        };
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            ((IDictionary<string,object>)request)["instrument_name"] = getValue(market, "id");
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["start_timestamp"] = since;
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["page_size"] = limit;
        }
        object response = await this.privatePostGetFundingHistory(this.extend(request, parameters));
        //
        // {
        //     "result": {
        //         "events": [
        //             {
        //                 "instrument_name": "BTC-PERP",
        //                 "timestamp": 1738066618272,
        //                 "funding": "-0.004677736347850093",
        //                 "pnl": "-0.944081615774632967"
        //             },
        //             {
        //                 "instrument_name": "BTC-PERP",
        //                 "timestamp": 1738066617964,
        //                 "funding": "0",
        //                 "pnl": "-0.437556413479249408"
        //             },
        //             {
        //                 "instrument_name": "BTC-PERP",
        //                 "timestamp": 1738065307565,
        //                 "funding": "0",
        //                 "pnl": "-0.39547479770461644"
        //             }
        //         ],
        //         "pagination": {
        //             "num_pages": 1,
        //             "count": 3
        //         }
        //     },
        //     "id": "524b817f-2108-467f-8795-511066f4acec"
        // }
        //
        object result = this.safeDict(response, "result", new Dictionary<string, object>() {});
        object page = this.safeInteger(parameters, "page");
        if (isTrue(!isEqual(page, null)))
        {
            object pagination = this.safeDict(result, "pagination");
            object currentPage = this.safeInteger(pagination, "num_pages");
            if (isTrue(isGreaterThan(page, currentPage)))
            {
                return new List<object>() {};
            }
        }
        object events = this.safeList(result, "events", new List<object>() {});
        return this.parseIncomes(events, market, since, limit);
    }

    public override object parseIncome(object income, object market = null)
    {
        //
        // {
        //     "instrument_name": "BTC-PERP",
        //     "timestamp": 1738065307565,
        //     "funding": "0",
        //     "pnl": "-0.39547479770461644"
        // }
        //
        object marketId = this.safeString(income, "instrument_name");
        object symbol = this.safeSymbol(marketId, market);
        object rate = this.safeString(income, "funding");
        object code = this.safeCurrencyCode("USDC");
        object timestamp = this.safeInteger(income, "timestamp");
        return new Dictionary<string, object>() {
            { "info", income },
            { "symbol", symbol },
            { "code", code },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "id", null },
            { "amount", null },
            { "rate", rate },
        };
    }

    /**
     * @method
     * @name derive#fetchBalance
     * @description query for balance and get the amount of funds available for trading or funds locked in orders
     * @see https://docs.derive.xyz/reference/post_private-get-all-portfolios
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
     */
    public async override Task<object> fetchBalance(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object deriveWalletAddress = null;
        var deriveWalletAddressparametersVariable = this.handleDeriveWalletAddress("fetchBalance", parameters);
        deriveWalletAddress = ((IList<object>)deriveWalletAddressparametersVariable)[0];
        parameters = ((IList<object>)deriveWalletAddressparametersVariable)[1];
        object request = new Dictionary<string, object>() {
            { "wallet", deriveWalletAddress },
        };
        object response = await this.privatePostGetAllPortfolios(this.extend(request, parameters));
        //
        // {
        //     "result": [{
        //             "subaccount_id": 130837,
        //             "label": "",
        //             "currency": "all",
        //             "margin_type": "SM",
        //             "is_under_liquidation": false,
        //             "positions_value": "0",
        //             "collaterals_value": "318.0760325000001103035174310207366943359375",
        //             "subaccount_value": "318.0760325000001103035174310207366943359375",
        //             "positions_maintenance_margin": "0",
        //             "positions_initial_margin": "0",
        //             "collaterals_maintenance_margin": "238.557024375000082727638073265552520751953125",
        //             "collaterals_initial_margin": "190.845619500000083235136116854846477508544921875",
        //             "maintenance_margin": "238.557024375000082727638073265552520751953125",
        //             "initial_margin": "190.845619500000083235136116854846477508544921875",
        //             "open_orders_margin": "0",
        //             "projected_margin_change": "0",
        //             "open_orders": [],
        //             "positions": [],
        //             "collaterals": [
        //                 {
        //                     "asset_type": "erc20",
        //                     "asset_name": "ETH",
        //                     "currency": "ETH",
        //                     "amount": "0.1",
        //                     "mark_price": "3180.760325000000438272",
        //                     "mark_value": "318.0760325000001103035174310207366943359375",
        //                     "cumulative_interest": "0",
        //                     "pending_interest": "0",
        //                     "initial_margin": "190.845619500000083235136116854846477508544921875",
        //                     "maintenance_margin": "238.557024375000082727638073265552520751953125",
        //                     "realized_pnl": "0",
        //                     "average_price": "3184.891931",
        //                     "unrealized_pnl": "-0.413161",
        //                     "total_fees": "0",
        //                     "average_price_excl_fees": "3184.891931",
        //                     "realized_pnl_excl_fees": "0",
        //                     "unrealized_pnl_excl_fees": "-0.413161",
        //                     "open_orders_margin": "0",
        //                     "creation_timestamp": 1736860533493
        //                 }
        //             ]
        //     }],
        //     "id": "27b9a64e-3379-4ce6-a126-9fb941c4a970"
        // }
        //
        object result = this.safeList(response, "result");
        return this.parseBalance(result);
    }

    public override object parseBalance(object response)
    {
        object result = new Dictionary<string, object>() {
            { "info", response },
        };
        // TODO:
        // checked multiple subaccounts
        // checked balance after open orders / positions
        for (object i = 0; isLessThan(i, getArrayLength(response)); postFixIncrement(ref i))
        {
            object subaccount = getValue(response, i);
            object collaterals = this.safeList(subaccount, "collaterals", new List<object>() {});
            for (object j = 0; isLessThan(j, getArrayLength(collaterals)); postFixIncrement(ref j))
            {
                object balance = getValue(collaterals, j);
                object code = this.safeCurrencyCode(this.safeString(balance, "currency"));
                object account = this.account();
                ((IDictionary<string,object>)account)["total"] = this.safeString(balance, "amount");
                ((IDictionary<string,object>)result)[(string)code] = account;
            }
        }
        return this.safeBalance(result);
    }

    /**
     * @method
     * @name derive#fetchDeposits
     * @description fetch all deposits made to an account
     * @see https://docs.derive.xyz/reference/post_private-get-deposit-history
     * @param {string} code unified currency code
     * @param {int} [since] the earliest time in ms to fetch deposits for
     * @param {int} [limit] the maximum number of deposits structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.subaccount_id] *required* the subaccount id
     * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
     */
    public async override Task<object> fetchDeposits(object code = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object subaccountId = null;
        var subaccountIdparametersVariable = this.handleDeriveSubaccountId("fetchDeposits", parameters);
        subaccountId = ((IList<object>)subaccountIdparametersVariable)[0];
        parameters = ((IList<object>)subaccountIdparametersVariable)[1];
        object request = new Dictionary<string, object>() {
            { "subaccount_id", subaccountId },
        };
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["start_timestamp"] = since;
        }
        object response = await this.privatePostGetDepositHistory(this.extend(request, parameters));
        //
        // {
        //     "result": {
        //         "events": [
        //             {
        //                 "timestamp": 1736860533599,
        //                 "transaction_id": "f2069395-ec00-49f5-925a-87202a5d240f",
        //                 "asset": "ETH",
        //                 "amount": "0.1",
        //                 "tx_status": "settled",
        //                 "tx_hash": "0xeda21a315c59302a19c42049b4cef05a10b685302b6cc3edbaf49102d91166d4",
        //                 "error_log": {}
        //             }
        //         ]
        //     },
        //     "id": "ceebc730-22ab-40cd-9941-33ceb2a74389"
        // }
        //
        object currency = this.safeCurrency(code);
        object result = this.safeDict(response, "result", new Dictionary<string, object>() {});
        object events = this.safeList(result, "events");
        return this.parseTransactions(events, currency, since, limit, parameters);
    }

    /**
     * @method
     * @name derive#fetchWithdrawals
     * @description fetch all withdrawals made from an account
     * @see https://docs.derive.xyz/reference/post_private-get-withdrawal-history
     * @param {string} code unified currency code
     * @param {int} [since] the earliest time in ms to fetch withdrawals for
     * @param {int} [limit] the maximum number of withdrawals structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.subaccount_id] *required* the subaccount id
     * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
     */
    public async override Task<object> fetchWithdrawals(object code = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object subaccountId = null;
        var subaccountIdparametersVariable = this.handleDeriveSubaccountId("fetchWithdrawals", parameters);
        subaccountId = ((IList<object>)subaccountIdparametersVariable)[0];
        parameters = ((IList<object>)subaccountIdparametersVariable)[1];
        object request = new Dictionary<string, object>() {
            { "subaccount_id", subaccountId },
        };
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["start_timestamp"] = since;
        }
        object response = await this.privatePostGetWithdrawalHistory(this.extend(request, parameters));
        //
        // {
        //     "result": {
        //         "events": [
        //             {
        //                 "timestamp": 1736860533599,
        //                 "transaction_id": "f2069395-ec00-49f5-925a-87202a5d240f",
        //                 "asset": "ETH",
        //                 "amount": "0.1",
        //                 "tx_status": "settled",
        //                 "tx_hash": "0xeda21a315c59302a19c42049b4cef05a10b685302b6cc3edbaf49102d91166d4",
        //                 "error_log": {}
        //             }
        //         ]
        //     },
        //     "id": "ceebc730-22ab-40cd-9941-33ceb2a74389"
        // }
        //
        object currency = this.safeCurrency(code);
        object result = this.safeDict(response, "result", new Dictionary<string, object>() {});
        object events = this.safeList(result, "events");
        return this.parseTransactions(events, currency, since, limit, parameters);
    }

    public override object parseTransaction(object transaction, object currency = null)
    {
        //
        // {
        //     "timestamp": 1736860533599,
        //     "transaction_id": "f2069395-ec00-49f5-925a-87202a5d240f",
        //     "asset": "ETH",
        //     "amount": "0.1",
        //     "tx_status": "settled",
        //     "tx_hash": "0xeda21a315c59302a19c42049b4cef05a10b685302b6cc3edbaf49102d91166d4",
        //     "error_log": {}
        // }
        //
        object code = this.safeString(transaction, "asset");
        object timestamp = this.safeInteger(transaction, "timestamp");
        object txId = this.safeString(transaction, "tx_hash");
        if (isTrue(isEqual(txId, "0x0")))
        {
            txId = null;
        }
        return new Dictionary<string, object>() {
            { "info", transaction },
            { "id", null },
            { "txid", txId },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "address", null },
            { "addressFrom", null },
            { "addressTo", null },
            { "tag", null },
            { "tagFrom", null },
            { "tagTo", null },
            { "type", null },
            { "amount", this.safeNumber(transaction, "amount") },
            { "currency", code },
            { "status", this.parseTransactionStatus(this.safeString(transaction, "tx_status")) },
            { "updated", null },
            { "comment", null },
            { "internal", null },
            { "fee", null },
            { "network", null },
        };
    }

    public virtual object parseTransactionStatus(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "settled", "ok" },
            { "reverted", "failed" },
        };
        return this.safeString(statuses, status, status);
    }

    public virtual object handleDeriveSubaccountId(object methodName, object parameters)
    {
        object derivesubAccountId = null;
        var derivesubAccountIdparametersVariable = this.handleOptionAndParams(parameters, methodName, "subaccount_id");
        derivesubAccountId = ((IList<object>)derivesubAccountIdparametersVariable)[0];
        parameters = ((IList<object>)derivesubAccountIdparametersVariable)[1];
        if (isTrue(isTrue((!isEqual(derivesubAccountId, null))) && isTrue((!isEqual(derivesubAccountId, "")))))
        {
            ((IDictionary<string,object>)this.options)["subaccount_id"] = derivesubAccountId; // saving in options
            return new List<object>() {derivesubAccountId, parameters};
        }
        object optionsWallet = this.safeString(this.options, "subaccount_id");
        if (isTrue(!isEqual(optionsWallet, null)))
        {
            return new List<object>() {optionsWallet, parameters};
        }
        throw new ArgumentsRequired ((string)add(add(add(this.id, " "), methodName), "() requires a subaccount_id parameter inside 'params' or exchange.options['subaccount_id']=ID.")) ;
    }

    public virtual object handleDeriveWalletAddress(object methodName, object parameters)
    {
        object deriveWalletAddress = null;
        var deriveWalletAddressparametersVariable = this.handleOptionAndParams(parameters, methodName, "deriveWalletAddress");
        deriveWalletAddress = ((IList<object>)deriveWalletAddressparametersVariable)[0];
        parameters = ((IList<object>)deriveWalletAddressparametersVariable)[1];
        if (isTrue(isTrue((!isEqual(deriveWalletAddress, null))) && isTrue((!isEqual(deriveWalletAddress, "")))))
        {
            ((IDictionary<string,object>)this.options)["deriveWalletAddress"] = deriveWalletAddress; // saving in options
            return new List<object>() {deriveWalletAddress, parameters};
        }
        object optionsWallet = this.safeString(this.options, "deriveWalletAddress");
        if (isTrue(!isEqual(optionsWallet, null)))
        {
            return new List<object>() {optionsWallet, parameters};
        }
        throw new ArgumentsRequired ((string)add(add(add(this.id, " "), methodName), "() requires a deriveWalletAddress parameter inside 'params' or exchange.options['deriveWalletAddress'] = ADDRESS, the address can find in HOME => Developers tab.")) ;
    }

    public override object handleErrors(object httpCode, object reason, object url, object method, object headers, object body, object response, object requestHeaders, object requestBody)
    {
        if (!isTrue(response))
        {
            return null;  // fallback to default error handler
        }
        object error = this.safeDict(response, "error");
        if (isTrue(!isEqual(error, null)))
        {
            object errorCode = this.safeString(error, "code");
            object feedback = add(add(this.id, " "), this.json(response));
            this.throwBroadlyMatchedException(getValue(this.exceptions, "broad"), body, feedback);
            this.throwExactlyMatchedException(getValue(this.exceptions, "exact"), errorCode, feedback);
            throw new ExchangeError ((string)feedback) ;
        }
        return null;
    }

    public override object sign(object path, object api = null, object method = null, object parameters = null, object headers = null, object body = null)
    {
        api ??= "public";
        method ??= "GET";
        parameters ??= new Dictionary<string, object>();
        object url = add(add(getValue(getValue(this.urls, "api"), api), "/"), path);
        if (isTrue(isEqual(method, "POST")))
        {
            headers = new Dictionary<string, object>() {
                { "Content-Type", "application/json" },
            };
            if (isTrue(isEqual(api, "private")))
            {
                object now = ((object)this.milliseconds()).ToString();
                object signature = this.signMessage(now, this.privateKey);
                ((IDictionary<string,object>)headers)["X-LyraWallet"] = this.safeString(this.options, "deriveWalletAddress");
                ((IDictionary<string,object>)headers)["X-LyraTimestamp"] = now;
                ((IDictionary<string,object>)headers)["X-LyraSignature"] = signature;
            }
            body = this.json(parameters);
        }
        return new Dictionary<string, object>() {
            { "url", url },
            { "method", method },
            { "body", body },
            { "headers", headers },
        };
    }
}
