<?php
namespace ccxt;

// ----------------------------------------------------------------------------

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

// -----------------------------------------------------------------------------
use React\Async;
use React\Promise;
include_once PATH_TO_CCXT . '/test/exchange/base/test_ticker.php';

function test_fetch_tickers($exchange, $skipped_properties, $symbol) {
    return Async\async(function () use ($exchange, $skipped_properties, $symbol) {
        $without_symbol = test_fetch_tickers_helper($exchange, $skipped_properties, null);
        $with_symbol = test_fetch_tickers_helper($exchange, $skipped_properties, [$symbol]);
        $results = Async\await(Promise\all([$without_symbol, $with_symbol]));
        test_fetch_tickers_amounts($exchange, $skipped_properties, $results[0]);
        return $results;
    }) ();
}


function test_fetch_tickers_helper($exchange, $skipped_properties, $arg_symbols, $arg_params = array()) {
    return Async\async(function () use ($exchange, $skipped_properties, $arg_symbols, $arg_params) {
        $method = 'fetchTickers';
        $response = Async\await($exchange->fetch_tickers($arg_symbols, $arg_params));
        assert(is_array($response), $exchange->id . ' ' . $method . ' ' . $exchange->json($arg_symbols) . ' must return an object. ' . $exchange->json($response));
        $values = is_array($response) ? array_values($response) : array();
        $checked_symbol = null;
        if ($arg_symbols !== null && count($arg_symbols) === 1) {
            $checked_symbol = $arg_symbols[0];
        }
        assert_non_emtpy_array($exchange, $skipped_properties, $method, $values, $checked_symbol);
        for ($i = 0; $i < count($values); $i++) {
            // todo: symbol check here
            $ticker = $values[$i];
            test_ticker($exchange, $skipped_properties, $method, $ticker, $checked_symbol);
        }
        return $response;
    }) ();
}


function test_fetch_tickers_amounts($exchange, $skipped_properties, $tickers) {
    $tickers_values = is_array($tickers) ? array_values($tickers) : array();
    if (!(is_array($skipped_properties) && array_key_exists('checkActiveSymbols', $skipped_properties))) {
        //
        // ensure all "active" symbols have tickers
        //
        $non_inactive_markets = get_active_markets($exchange);
        $not_inactive_symbols_length = count($non_inactive_markets);
        $obtained_tickers_length = count($tickers_values);
        $min_ratio = 0.99; // 1.0 - 0.01 = 0.99, hardcoded to avoid C# transpiler type casting issues
        assert($obtained_tickers_length >= $not_inactive_symbols_length * $min_ratio, $exchange->id . ' ' . 'fetchTickers' . ' must return tickers for all active markets. but returned: ' . ((string) $obtained_tickers_length) . ' tickers, ' . ((string) $not_inactive_symbols_length) . ' active markets');
        //
        // ensure tickers length is less than markets length
        //
        $all_markets = $exchange->markets;
        $all_markets_length = count(is_array($all_markets) ? array_keys($all_markets) : array());
        assert($obtained_tickers_length <= $all_markets_length, $exchange->id . ' ' . 'fetchTickers' . ' must return <= than all markets, but returned: ' . ((string) $obtained_tickers_length) . ' tickers, ' . ((string) $all_markets_length) . ' markets');
    }
}
