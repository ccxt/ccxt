<?php

namespace ccxt;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

use Exception; // a common import
use ccxt\abstract\woo as Exchange;

class woo extends Exchange {

    public function describe() {
        return $this->deep_extend(parent::describe(), array(
            'id' => 'woo',
            'name' => 'WOO X',
            'countries' => array( 'KY' ), // Cayman Islands
            'rateLimit' => 100,
            'version' => 'v1',
            'certified' => true,
            'pro' => true,
            'hostname' => 'woo.org',
            'has' => array(
                'CORS' => null,
                'spot' => true,
                'margin' => true,
                'swap' => true,
                'future' => false,
                'option' => false,
                'addMargin' => false,
                'cancelAllOrders' => true,
                'cancelAllOrdersAfter' => true,
                'cancelOrder' => true,
                'cancelWithdraw' => false, // exchange have that endpoint disabled atm, but was once implemented in ccxt per old docs => https://kronosresearch.github.io/wootrade-documents/#cancel-withdraw-request
                'closeAllPositions' => false,
                'closePosition' => false,
                'createConvertTrade' => true,
                'createDepositAddress' => false,
                'createMarketBuyOrderWithCost' => true,
                'createMarketOrder' => false,
                'createMarketOrderWithCost' => false,
                'createMarketSellOrderWithCost' => false,
                'createOrder' => true,
                'createOrderWithTakeProfitAndStopLoss' => true,
                'createReduceOnlyOrder' => true,
                'createStopLimitOrder' => false,
                'createStopLossOrder' => true,
                'createStopMarketOrder' => false,
                'createStopOrder' => false,
                'createTakeProfitOrder' => true,
                'createTrailingAmountOrder' => true,
                'createTrailingPercentOrder' => true,
                'createTriggerOrder' => true,
                'fetchAccounts' => true,
                'fetchBalance' => true,
                'fetchCanceledOrders' => false,
                'fetchClosedOrder' => false,
                'fetchClosedOrders' => true,
                'fetchConvertCurrencies' => true,
                'fetchConvertQuote' => true,
                'fetchConvertTrade' => true,
                'fetchConvertTradeHistory' => true,
                'fetchCurrencies' => true,
                'fetchDepositAddress' => true,
                'fetchDeposits' => true,
                'fetchDepositsWithdrawals' => true,
                'fetchFundingHistory' => true,
                'fetchFundingRate' => true,
                'fetchFundingRateHistory' => true,
                'fetchFundingRates' => true,
                'fetchIndexOHLCV' => false,
                'fetchLedger' => true,
                'fetchLeverage' => true,
                'fetchMarginAdjustmentHistory' => false,
                'fetchMarginMode' => false,
                'fetchMarkets' => true,
                'fetchMarkOHLCV' => false,
                'fetchMyTrades' => true,
                'fetchOHLCV' => true,
                'fetchOpenInterestHistory' => false,
                'fetchOpenOrder' => false,
                'fetchOpenOrders' => true,
                'fetchOrder' => true,
                'fetchOrderBook' => true,
                'fetchOrders' => true,
                'fetchOrderTrades' => true,
                'fetchPosition' => true,
                'fetchPositionMode' => false,
                'fetchPositions' => true,
                'fetchPremiumIndexOHLCV' => false,
                'fetchStatus' => true,
                'fetchTicker' => false,
                'fetchTickers' => false,
                'fetchTime' => true,
                'fetchTrades' => true,
                'fetchTradingFee' => false,
                'fetchTradingFees' => true,
                'fetchTransactions' => 'emulated',
                'fetchTransfers' => true,
                'fetchWithdrawals' => true,
                'reduceMargin' => false,
                'setLeverage' => true,
                'setMargin' => false,
                'setPositionMode' => true,
                'transfer' => true,
                'withdraw' => true, // exchange have that endpoint disabled atm, but was once implemented in ccxt per old docs => https://kronosresearch.github.io/wootrade-documents/#token-withdraw
            ),
            'timeframes' => array(
                '1m' => '1m',
                '5m' => '5m',
                '15m' => '15m',
                '30m' => '30m',
                '1h' => '1h',
                '4h' => '4h',
                '12h' => '12h',
                '1d' => '1d',
                '1w' => '1w',
                '1M' => '1mon',
                '1y' => '1y',
            ),
            'urls' => array(
                'logo' => 'https://user-images.githubusercontent.com/1294454/150730761-1a00e5e0-d28c-480f-9e65-089ce3e6ef3b.jpg',
                'api' => array(
                    'pub' => 'https://api-pub.woo.org',
                    'public' => 'https://api.{hostname}',
                    'private' => 'https://api.{hostname}',
                ),
                'test' => array(
                    'pub' => 'https://api-pub.staging.woo.org',
                    'public' => 'https://api.staging.woo.org',
                    'private' => 'https://api.staging.woo.org',
                ),
                'www' => 'https://woo.org/',
                'doc' => array(
                    'https://docs.woo.org/',
                ),
                'fees' => array(
                    'https://support.woo.org/hc/en-001/articles/4404611795353--Trading-Fees',
                ),
                'referral' => array(
                    'url' => 'https://x.woo.org/register?ref=YWOWC96B',
                    'discount' => 0.35,
                ),
            ),
            'api' => array(
                'v1' => array(
                    'pub' => array(
                        'get' => array(
                            'hist/kline' => 10,
                            'hist/trades' => 1,
                        ),
                    ),
                    'public' => array(
                        'get' => array(
                            'info' => 1,
                            'info/{symbol}' => 1,
                            'system_info' => 1,
                            'market_trades' => 1,
                            'token' => 1,
                            'token_network' => 1,
                            'funding_rates' => 1,
                            'funding_rate/{symbol}' => 1,
                            'funding_rate_history' => 1,
                            'futures' => 1,
                            'futures/{symbol}' => 1,
                            'orderbook/{symbol}' => 1,
                            'kline' => 1,
                        ),
                    ),
                    'private' => array(
                        'get' => array(
                            'client/token' => 1,
                            'order/{oid}' => 1,
                            'client/order/{client_order_id}' => 1,
                            'orders' => 1,
                            'client/trade/{tid}' => 1,
                            'order/{oid}/trades' => 1,
                            'client/trades' => 1,
                            'client/hist_trades' => 1,
                            'staking/yield_history' => 1,
                            'client/holding' => 1,
                            'asset/deposit' => 10,
                            'asset/history' => 60,
                            'sub_account/all' => 60,
                            'sub_account/assets' => 60,
                            'sub_account/asset_detail' => 60,
                            'sub_account/ip_restriction' => 10,
                            'asset/main_sub_transfer_history' => 30,
                            'token_interest' => 60,
                            'token_interest/{token}' => 60,
                            'interest/history' => 60,
                            'interest/repay' => 60,
                            'funding_fee/history' => 30,
                            'positions' => 3.33, // 30 requests per 10 seconds
                            'position/{symbol}' => 3.33,
                            'client/transaction_history' => 60,
                        ),
                        'post' => array(
                            'order' => 5, // 2 requests per 1 second per symbol
                            'order/cancel_all_after' => 1,
                            'asset/main_sub_transfer' => 30, // 20 requests per 60 seconds
                            'asset/ltv' => 30,
                            'asset/withdraw' => 30,  // implemented in ccxt, disabled on the exchange side https://kronosresearch.github.io/wootrade-documents/#token-withdraw
                            'asset/internal_withdraw' => 30,
                            'interest/repay' => 60,
                            'client/account_mode' => 120,
                            'client/position_mode' => 5,
                            'client/leverage' => 120,
                        ),
                        'delete' => array(
                            'order' => 1,
                            'client/order' => 1,
                            'orders' => 1,
                            'asset/withdraw' => 120,  // implemented in ccxt, disabled on the exchange side https://kronosresearch.github.io/wootrade-documents/#cancel-withdraw-request
                        ),
                    ),
                ),
                'v2' => array(
                    'private' => array(
                        'get' => array(
                            'client/holding' => 1,
                        ),
                    ),
                ),
                'v3' => array(
                    'public' => array(
                        'get' => array(
                            'insuranceFund' => 3,
                        ),
                    ),
                    'private' => array(
                        'get' => array(
                            'algo/order/{oid}' => 1,
                            'algo/orders' => 1,
                            'balances' => 1,
                            'accountinfo' => 60,
                            'positions' => 3.33,
                            'buypower' => 1,
                            'referrals' => 60,
                            'referral_rewards' => 60,
                            'convert/exchangeInfo' => 1,
                            'convert/assetInfo' => 1,
                            'convert/rfq' => 60,
                            'convert/trade' => 1,
                            'convert/trades' => 1,
                        ),
                        'post' => array(
                            'algo/order' => 5,
                            'convert/rft' => 60,
                        ),
                        'put' => array(
                            'order/{oid}' => 2,
                            'order/client/{client_order_id}' => 2,
                            'algo/order/{oid}' => 2,
                            'algo/order/client/{client_order_id}' => 2,
                        ),
                        'delete' => array(
                            'algo/order/{order_id}' => 1,
                            'algo/orders/pending' => 1,
                            'algo/orders/pending/{symbol}' => 1,
                            'orders/pending' => 1,
                        ),
                    ),
                ),
            ),
            'fees' => array(
                'trading' => array(
                    'tierBased' => true,
                    'percentage' => true,
                    'maker' => $this->parse_number('0.0002'),
                    'taker' => $this->parse_number('0.0005'),
                ),
            ),
            'options' => array(
                'sandboxMode' => false,
                'createMarketBuyOrderRequiresPrice' => true,
                // these network aliases require manual mapping here
                'network-aliases-for-tokens' => array(
                    'HT' => 'ERC20',
                    'OMG' => 'ERC20',
                    'UATOM' => 'ATOM',
                    'ZRX' => 'ZRX',
                ),
                'networks' => array(
                    'TRX' => 'TRON',
                    'TRC20' => 'TRON',
                    'ERC20' => 'ETH',
                    'BEP20' => 'BSC',
                ),
                // override defaultNetworkCodePriorities for a specific currency
                'defaultNetworkCodeForCurrencies' => array(
                    // 'USDT' => 'TRC20',
                    // 'BTC' => 'BTC',
                ),
                'transfer' => array(
                    'fillResponseFromRequest' => true,
                ),
                'brokerId' => 'bc830de7-50f3-460b-9ee0-f430f83f9dad',
            ),
            'commonCurrencies' => array(),
            'exceptions' => array(
                'exact' => array(
                    '-1000' => '\\ccxt\\ExchangeError', // array( "code" => -1000,  "message" => "An unknown error occurred while processing the request" )
                    '-1001' => '\\ccxt\\AuthenticationError', // array( "code" => -1001,  "message" => "The api key or secret is in wrong format" )
                    '-1002' => '\\ccxt\\AuthenticationError', // array( "code" => -1002,  "message" => "API key or secret is invalid, it may because key have insufficient permission or the key is expired/revoked." )
                    '-1003' => '\\ccxt\\RateLimitExceeded', // array( "code" => -1003,  "message" => "Rate limit exceed." )
                    '-1004' => '\\ccxt\\BadRequest', // array( "code" => -1004,  "message" => "An unknown parameter was sent." )
                    '-1005' => '\\ccxt\\BadRequest', // array( "code" => -1005,  "message" => "Some parameters are in wrong format for api." )
                    '-1006' => '\\ccxt\\BadRequest', // array( "code" => -1006,  "message" => "The data is not found in server." )
                    '-1007' => '\\ccxt\\BadRequest', // array( "code" => -1007,  "message" => "The data is already exists or your request is duplicated." )
                    '-1008' => '\\ccxt\\InvalidOrder', // array( "code" => -1008,  "message" => "The quantity of settlement is too high than you can request." )
                    '-1009' => '\\ccxt\\BadRequest', // array( "code" => -1009,  "message" => "Can not request withdrawal settlement, you need to deposit other arrears first." )
                    '-1012' => '\\ccxt\\BadRequest', // array( "code" => -1012,  "message" => "Amount is required for buy market orders when margin disabled.")  The place/cancel order request is rejected by internal module, it may because the account is in liquidation or other internal errors. Please try again in a few seconds." }
                    '-1101' => '\\ccxt\\InvalidOrder', // array( "code" => -1101,  "message" => "The risk exposure for client is too high, it may cause by sending too big order or the leverage is too low. please refer to client info to check the current exposure." )
                    '-1102' => '\\ccxt\\InvalidOrder', // array( "code" => -1102,  "message" => "The order value (price * size) is too small." )
                    '-1103' => '\\ccxt\\InvalidOrder', // array( "code" => -1103,  "message" => "The order price is not following the tick size rule for the symbol." )
                    '-1104' => '\\ccxt\\InvalidOrder', // array( "code" => -1104,  "message" => "The order quantity is not following the step size rule for the symbol." )
                    '-1105' => '\\ccxt\\InvalidOrder', // array( "code" => -1105,  "message" => "Price is X% too high or X% too low from the mid price." )
                ),
                'broad' => array(
                    'Can not place' => '\\ccxt\\ExchangeError', // array( "code" => -1011,  "message" => "Can not place/cancel orders, it may because internal network error. Please try again in a few seconds." )
                    'maintenance' => '\\ccxt\\OnMaintenance', // array("code":"-1011","message":"The system is under maintenance.","success":false)
                    'symbol must not be blank' => '\\ccxt\\BadRequest', // when sending 'cancelOrder' without symbol [-1005]
                    'The token is not supported' => '\\ccxt\\BadRequest', // when getting incorrect token's deposit address [-1005]
                    'Your order and symbol are not valid or already canceled' => '\\ccxt\\BadRequest', // actual response whensending 'cancelOrder' for already canceled id [-1006]
                    'Insufficient WOO. Please enable margin trading for leverage trading' => '\\ccxt\\BadRequest', // when selling insufficent token [-1012]
                ),
            ),
            'precisionMode' => TICK_SIZE,
        ));
    }

    public function fetch_status($params = array ()) {
        /**
         * the latest known information on the availability of the exchange API
         * @see https://docs.woo.org/#get-system-maintenance-$status-public
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @return {array} a ~@link https://docs.ccxt.com/#/?id=exchange-$status-structure $status structure~
         */
        $response = $this->v1PublicGetSystemInfo ($params);
        //
        //     {
        //         "success" => true,
        //         "data" => array(
        //             "status" => "0",
        //             "msg" => "System is functioning properly."
        //         ),
        //         "timestamp" => "1709274106602"
        //     }
        //
        $data = $this->safe_dict($response, 'data', array());
        $status = $this->safe_string($data, 'status');
        if ($status === null) {
            $status = 'error';
        } elseif ($status === '0') {
            $status = 'ok';
        } else {
            $status = 'maintenance';
        }
        return array(
            'status' => $status,
            'updated' => null,
            'eta' => null,
            'url' => null,
            'info' => $response,
        );
    }

    public function fetch_time($params = array ()) {
        /**
         * fetches the current integer timestamp in milliseconds from the exchange server
         * @see https://docs.woo.org/#get-system-maintenance-status-public
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @return {int} the current integer timestamp in milliseconds from the exchange server
         */
        $response = $this->v1PublicGetSystemInfo ($params);
        //
        //     {
        //         "success" => true,
        //         "data" => array(
        //             "status" => "0",
        //             "msg" => "System is functioning properly."
        //         ),
        //         "timestamp" => "1709274106602"
        //     }
        //
        return $this->safe_integer($response, 'timestamp');
    }

    public function fetch_markets($params = array ()): array {
        /**
         * retrieves $data on all markets for woo
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @return {array[]} an array of objects representing market $data
         */
        $response = $this->v1PublicGetInfo ($params);
        //
        // {
        //     "rows" => [
        //         array(
        //             "symbol" => "SPOT_AAVE_USDT",
        //             "quote_min" => 0,
        //             "quote_max" => 100000,
        //             "quote_tick" => 0.01,
        //             "base_min" => 0.01,
        //             "base_max" => 7284,
        //             "base_tick" => 0.0001,
        //             "min_notional" => 10,
        //             "price_range" => 0.1,
        //             "created_time" => "0",
        //             "updated_time" => "1639107647.988",
        //             "is_stable" => 0
        //         ),
        //         ...
        //     "success" => true
        // }
        //
        $data = $this->safe_list($response, 'rows', array());
        return $this->parse_markets($data);
    }

    public function parse_market($market): array {
        $marketId = $this->safe_string($market, 'symbol');
        $parts = explode('_', $marketId);
        $first = $this->safe_string($parts, 0);
        $spot = false;
        $swap = false;
        if ($first === 'SPOT') {
            $spot = true;
            $marketType = 'spot';
        } elseif ($first === 'PERP') {
            $swap = true;
            $marketType = 'swap';
        }
        $baseId = $this->safe_string($parts, 1);
        $quoteId = $this->safe_string($parts, 2);
        $base = $this->safe_currency_code($baseId);
        $quote = $this->safe_currency_code($quoteId);
        $settleId = null;
        $settle = null;
        $symbol = $base . '/' . $quote;
        $contractSize = null;
        $linear = null;
        $margin = true;
        $contract = $swap;
        if ($contract) {
            $margin = false;
            $settleId = $this->safe_string($parts, 2);
            $settle = $this->safe_currency_code($settleId);
            $symbol = $base . '/' . $quote . ':' . $settle;
            $contractSize = $this->parse_number('1');
            $linear = true;
        }
        return array(
            'id' => $marketId,
            'symbol' => $symbol,
            'base' => $base,
            'quote' => $quote,
            'settle' => $settle,
            'baseId' => $baseId,
            'quoteId' => $quoteId,
            'settleId' => $settleId,
            'type' => $marketType,
            'spot' => $spot,
            'margin' => $margin,
            'swap' => $swap,
            'future' => false,
            'option' => false,
            'active' => null,
            'contract' => $contract,
            'linear' => $linear,
            'inverse' => null,
            'contractSize' => $contractSize,
            'expiry' => null,
            'expiryDatetime' => null,
            'strike' => null,
            'optionType' => null,
            'precision' => array(
                'amount' => $this->safe_number($market, 'base_tick'),
                'price' => $this->safe_number($market, 'quote_tick'),
            ),
            'limits' => array(
                'leverage' => array(
                    'min' => null,
                    'max' => null,
                ),
                'amount' => array(
                    'min' => $this->safe_number($market, 'base_min'),
                    'max' => $this->safe_number($market, 'base_max'),
                ),
                'price' => array(
                    'min' => $this->safe_number($market, 'quote_min'),
                    'max' => $this->safe_number($market, 'quote_max'),
                ),
                'cost' => array(
                    'min' => $this->safe_number($market, 'min_notional'),
                    'max' => null,
                ),
            ),
            'created' => $this->safe_timestamp($market, 'created_time'),
            'info' => $market,
        );
    }

    public function fetch_trades(string $symbol, ?int $since = null, ?int $limit = null, $params = array ()): array {
        /**
         * get the list of most recent trades for a particular $symbol
         * @param {string} $symbol unified $symbol of the $market to fetch trades for
         * @param {int} [$since] timestamp in ms of the earliest trade to fetch
         * @param {int} [$limit] the maximum amount of trades to fetch
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @return {Trade[]} a list of ~@link https://docs.ccxt.com/#/?id=public-trades trade structures~
         */
        $this->load_markets();
        $market = $this->market($symbol);
        $request = array(
            'symbol' => $market['id'],
        );
        if ($limit !== null) {
            $request['limit'] = $limit;
        }
        $response = $this->v1PublicGetMarketTrades (array_merge($request, $params));
        //
        // {
        //     "success" => true,
        //     "rows" => array(
        //         array(
        //             "symbol" => "SPOT_BTC_USDT",
        //             "side" => "SELL",
        //             "executed_price" => 46222.35,
        //             "executed_quantity" => 0.0012,
        //             "executed_timestamp" => "1641241162.329"
        //         ),
        //         array(
        //             "symbol" => "SPOT_BTC_USDT",
        //             "side" => "SELL",
        //             "executed_price" => 46222.35,
        //             "executed_quantity" => 0.0012,
        //             "executed_timestamp" => "1641241162.329"
        //         ),
        //         array(
        //             "symbol" => "SPOT_BTC_USDT",
        //             "side" => "BUY",
        //             "executed_price" => 46224.32,
        //             "executed_quantity" => 0.00039,
        //             "executed_timestamp" => "1641241162.287"
        //         ),
        //         ...
        //      )
        // }
        //
        $resultResponse = $this->safe_list($response, 'rows', array());
        return $this->parse_trades($resultResponse, $market, $since, $limit);
    }

    public function parse_trade($trade, ?array $market = null): array {
        //
        // public/market_trades
        //
        //     {
        //         "symbol" => "SPOT_BTC_USDT",
        //         "side" => "SELL",
        //         "executed_price" => 46222.35,
        //         "executed_quantity" => 0.0012,
        //         "executed_timestamp" => "1641241162.329"
        //     }
        //
        // fetchOrderTrades, fetchOrder
        //
        //     {
        //         "id" => "99119876",
        //         "symbol" => "SPOT_WOO_USDT",
        //         "fee" => "0.0024",
        //         "side" => "BUY",
        //         "executed_timestamp" => "1641481113.084",
        //         "order_id" => "87001234",
        //         "order_tag" => "default", <-- this param only in "fetchOrderTrades"
        //         "executed_price" => "1",
        //         "executed_quantity" => "12",
        //         "fee_asset" => "WOO",
        //         "is_maker" => "1"
        //     }
        //
        $isFromFetchOrder = (is_array($trade) && array_key_exists('id', $trade));
        $timestamp = $this->safe_timestamp($trade, 'executed_timestamp');
        $marketId = $this->safe_string($trade, 'symbol');
        $market = $this->safe_market($marketId, $market);
        $symbol = $market['symbol'];
        $price = $this->safe_string($trade, 'executed_price');
        $amount = $this->safe_string($trade, 'executed_quantity');
        $order_id = $this->safe_string($trade, 'order_id');
        $fee = $this->parse_token_and_fee_temp($trade, 'fee_asset', 'fee');
        $cost = Precise::string_mul($price, $amount);
        $side = $this->safe_string_lower($trade, 'side');
        $id = $this->safe_string($trade, 'id');
        $takerOrMaker = null;
        if ($isFromFetchOrder) {
            $isMaker = $this->safe_string($trade, 'is_maker') === '1';
            $takerOrMaker = $isMaker ? 'maker' : 'taker';
        }
        return $this->safe_trade(array(
            'id' => $id,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'symbol' => $symbol,
            'side' => $side,
            'price' => $price,
            'amount' => $amount,
            'cost' => $cost,
            'order' => $order_id,
            'takerOrMaker' => $takerOrMaker,
            'type' => null,
            'fee' => $fee,
            'info' => $trade,
        ), $market);
    }

    public function parse_token_and_fee_temp($item, $feeTokenKey, $feeAmountKey) {
        $feeCost = $this->safe_string($item, $feeAmountKey);
        $fee = null;
        if ($feeCost !== null) {
            $feeCurrencyId = $this->safe_string($item, $feeTokenKey);
            $feeCurrencyCode = $this->safe_currency_code($feeCurrencyId);
            $fee = array(
                'cost' => $feeCost,
                'currency' => $feeCurrencyCode,
            );
        }
        return $fee;
    }

    public function fetch_trading_fees($params = array ()): array {
        /**
         * fetch the trading fees for multiple markets
         * @see https://docs.woo.org/#get-account-information-new
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @return {array} a dictionary of ~@link https://docs.ccxt.com/#/?id=fee-structure fee structures~ indexed by market symbols
         */
        $this->load_markets();
        $response = $this->v3PrivateGetAccountinfo ($params);
        //
        //     {
        //         "success" => true,
        //         "data" => array(
        //             "applicationId" => "dsa",
        //             "account" => "dsa",
        //             "alias" => "haha",
        //             "accountMode" => "MARGIN",
        //             "leverage" => 1,
        //             "takerFeeRate" => 1,
        //             "makerFeeRate" => 1,
        //             "interestRate" => 1,
        //             "futuresTakerFeeRate" => 1,
        //             "futuresMakerFeeRate" => 1,
        //             "otpauth" => true,
        //             "marginRatio" => 1,
        //             "openMarginRatio" => 1,
        //             "initialMarginRatio" => 1,
        //             "maintenanceMarginRatio" => 1,
        //             "totalCollateral" => 1,
        //             "freeCollateral" => 1,
        //             "totalAccountValue" => 1,
        //             "totalVaultValue" => 1,
        //             "totalStakingValue" => 1
        //         ),
        //         "timestamp" => 1673323685109
        //     }
        //
        $data = $this->safe_dict($response, 'data', array());
        $maker = $this->safe_string($data, 'makerFeeRate');
        $taker = $this->safe_string($data, 'takerFeeRate');
        $result = array();
        for ($i = 0; $i < count($this->symbols); $i++) {
            $symbol = $this->symbols[$i];
            $result[$symbol] = array(
                'info' => $response,
                'symbol' => $symbol,
                'maker' => $this->parse_number(Precise::string_div($maker, '10000')),
                'taker' => $this->parse_number(Precise::string_div($taker, '10000')),
                'percentage' => true,
                'tierBased' => true,
            );
        }
        return $result;
    }

    public function fetch_currencies($params = array ()): ?array {
        /**
         * fetches all available currencies on an exchange
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @return {array} an associative dictionary of currencies
         */
        $result = array();
        $tokenResponse = $this->v1PublicGetToken ($params);
        //
        // {
        //     "rows" => array(
        //         array(
        //             "token" => "ETH_USDT",
        //             "fullname" => "Tether",
        //             "decimals" => 6,
        //             "balance_token" => "USDT",
        //             "created_time" => "0",
        //             "updated_time" => "0"
        //         ),
        //         array(
        //             "token" => "BSC_USDT",
        //             "fullname" => "Tether",
        //             "decimals" => 18,
        //             "balance_token" => "USDT",
        //             "created_time" => "0",
        //             "updated_time" => "0"
        //         ),
        //         array(
        //             "token" => "ZEC",
        //             "fullname" => "ZCash",
        //             "decimals" => 8,
        //             "balance_token" => "ZEC",
        //             "created_time" => "0",
        //             "updated_time" => "0"
        //         ),
        //         ...
        //     ),
        //     "success" => true
        // }
        //
        // only make one request for currrencies...
        // $tokenNetworkResponse = $this->v1PublicGetTokenNetwork ($params);
        //
        // {
        //     "rows" => array(
        //         array(
        //             "protocol" => "ERC20",
        //             "token" => "USDT",
        //             "name" => "Ethereum",
        //             "minimum_withdrawal" => 30,
        //             "withdrawal_fee" => 25,
        //             "allow_deposit" => 1,
        //             "allow_withdraw" => 1
        //         ),
        //         array(
        //             "protocol" => "TRC20",
        //             "token" => "USDT",
        //             "name" => "Tron",
        //             "minimum_withdrawal" => 30,
        //             "withdrawal_fee" => 1,
        //             "allow_deposit" => 1,
        //             "allow_withdraw" => 1
        //         ),
        //         ...
        //     ),
        //     "success" => true
        // }
        //
        $tokenRows = $this->safe_list($tokenResponse, 'rows', array());
        $networksByCurrencyId = $this->group_by($tokenRows, 'balance_token');
        $currencyIds = is_array($networksByCurrencyId) ? array_keys($networksByCurrencyId) : array();
        for ($i = 0; $i < count($currencyIds); $i++) {
            $currencyId = $currencyIds[$i];
            $networks = $networksByCurrencyId[$currencyId];
            $code = $this->safe_currency_code($currencyId);
            $name = null;
            $minPrecision = null;
            $resultingNetworks = array();
            for ($j = 0; $j < count($networks); $j++) {
                $network = $networks[$j];
                $name = $this->safe_string($network, 'fullname');
                $networkId = $this->safe_string($network, 'token');
                $splitted = explode('_', $networkId);
                $unifiedNetwork = $splitted[0];
                $precision = $this->parse_precision($this->safe_string($network, 'decimals'));
                if ($precision !== null) {
                    $minPrecision = ($minPrecision === null) ? $precision : Precise::string_min($precision, $minPrecision);
                }
                $resultingNetworks[$unifiedNetwork] = array(
                    'id' => $networkId,
                    'network' => $unifiedNetwork,
                    'limits' => array(
                        'withdraw' => array(
                            'min' => null,
                            'max' => null,
                        ),
                        'deposit' => array(
                            'min' => null,
                            'max' => null,
                        ),
                    ),
                    'active' => null,
                    'deposit' => null,
                    'withdraw' => null,
                    'fee' => null,
                    'precision' => $this->parse_number($precision),
                    'info' => $network,
                );
            }
            $result[$code] = array(
                'id' => $currencyId,
                'name' => $name,
                'code' => $code,
                'precision' => $this->parse_number($minPrecision),
                'active' => null,
                'fee' => null,
                'networks' => $resultingNetworks,
                'deposit' => null,
                'withdraw' => null,
                'limits' => array(
                    'deposit' => array(
                        'min' => null,
                        'max' => null,
                    ),
                    'withdraw' => array(
                        'min' => null,
                        'max' => null,
                    ),
                ),
                'info' => $networks,
            );
        }
        return $result;
    }

    public function create_market_buy_order_with_cost(string $symbol, float $cost, $params = array ()) {
        /**
         * create a $market buy order by providing the $symbol and $cost
         * @see https://docs.woo.org/#send-order
         * @param {string} $symbol unified $symbol of the $market to create an order in
         * @param {float} $cost how much you want to trade in units of the quote currency
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @return {array} an ~@link https://docs.ccxt.com/#/?id=order-structure order structure~
         */
        $this->load_markets();
        $market = $this->market($symbol);
        if (!$market['spot']) {
            throw new NotSupported($this->id . ' createMarketBuyOrderWithCost() supports spot orders only');
        }
        $params['createMarketBuyOrderRequiresPrice'] = false;
        return $this->create_order($symbol, 'market', 'buy', $cost, null, $params);
    }

    public function create_trailing_amount_order(string $symbol, string $type, string $side, float $amount, ?float $price = null, $trailingAmount = null, $trailingTriggerPrice = null, $params = array ()): array {
        /**
         * create a trailing order by providing the $symbol, $type, $side, $amount, $price and $trailingAmount
         * @param {string} $symbol unified $symbol of the market to create an order in
         * @param {string} $type 'market' or 'limit'
         * @param {string} $side 'buy' or 'sell'
         * @param {float} $amount how much you want to trade in units of the base currency, or number of contracts
         * @param {float} [$price] the $price for the order to be filled at, in units of the quote currency, ignored in market orders
         * @param {float} $trailingAmount the quote $amount to trail away from the current market $price
         * @param {float} $trailingTriggerPrice the $price to activate a trailing order, default uses the $price argument
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @return {array} an ~@link https://docs.ccxt.com/#/?id=order-structure order structure~
         */
        if ($trailingAmount === null) {
            throw new ArgumentsRequired($this->id . ' createTrailingAmountOrder() requires a $trailingAmount argument');
        }
        if ($trailingTriggerPrice === null) {
            throw new ArgumentsRequired($this->id . ' createTrailingAmountOrder() requires a $trailingTriggerPrice argument');
        }
        $params['trailingAmount'] = $trailingAmount;
        $params['trailingTriggerPrice'] = $trailingTriggerPrice;
        return $this->create_order($symbol, $type, $side, $amount, $price, $params);
    }

    public function create_trailing_percent_order(string $symbol, string $type, string $side, float $amount, ?float $price = null, $trailingPercent = null, $trailingTriggerPrice = null, $params = array ()): array {
        /**
         * create a trailing order by providing the $symbol, $type, $side, $amount, $price and $trailingPercent
         * @param {string} $symbol unified $symbol of the market to create an order in
         * @param {string} $type 'market' or 'limit'
         * @param {string} $side 'buy' or 'sell'
         * @param {float} $amount how much you want to trade in units of the base currency, or number of contracts
         * @param {float} [$price] the $price for the order to be filled at, in units of the quote currency, ignored in market orders
         * @param {float} $trailingPercent the percent to trail away from the current market $price
         * @param {float} $trailingTriggerPrice the $price to activate a trailing order, default uses the $price argument
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @return {array} an ~@link https://docs.ccxt.com/#/?id=order-structure order structure~
         */
        if ($trailingPercent === null) {
            throw new ArgumentsRequired($this->id . ' createTrailingPercentOrder() requires a $trailingPercent argument');
        }
        if ($trailingTriggerPrice === null) {
            throw new ArgumentsRequired($this->id . ' createTrailingPercentOrder() requires a $trailingTriggerPrice argument');
        }
        $params['trailingPercent'] = $trailingPercent;
        $params['trailingTriggerPrice'] = $trailingTriggerPrice;
        return $this->create_order($symbol, $type, $side, $amount, $price, $params);
    }

    public function create_order(string $symbol, string $type, string $side, float $amount, ?float $price = null, $params = array ()) {
        /**
         * create a trade $order
         * @see https://docs.woo.org/#send-$order
         * @see https://docs.woo.org/#send-algo-$order
         * @param {string} $symbol unified $symbol of the $market to create an $order in
         * @param {string} $type 'market' or 'limit'
         * @param {string} $side 'buy' or 'sell'
         * @param {float} $amount how much of currency you want to trade in units of base currency
         * @param {float} [$price] the $price at which the $order is to be fullfilled, in units of the quote currency, ignored in $market orders
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @param {float} [$params->triggerPrice] The $price a trigger $order is triggered at
         * @param {array} [$params->takeProfit] *$takeProfit object in $params* containing the triggerPrice at which the attached take profit $order will be triggered (perpetual swap markets only)
         * @param {float} [$params->takeProfit.triggerPrice] take profit trigger $price
         * @param {array} [$params->stopLoss] *$stopLoss object in $params* containing the triggerPrice at which the attached stop loss $order will be triggered (perpetual swap markets only)
         * @param {float} [$params->stopLoss.triggerPrice] stop loss trigger $price
         * @param {float} [$params->algoType] 'STOP'or 'TRAILING_STOP' or 'OCO' or 'CLOSE_POSITION'
         * @param {float} [$params->cost] *spot $market buy only* the quote quantity that can be used alternative for the $amount
         * @param {string} [$params->trailingAmount] the quote $amount to trail away from the current $market $price
         * @param {string} [$params->trailingPercent] the percent to trail away from the current $market $price
         * @param {string} [$params->trailingTriggerPrice] the $price to trigger a trailing $order, default uses the $price argument
         * @return {array} an ~@link https://docs.ccxt.com/#/?id=$order-structure $order structure~
         */
        $reduceOnly = $this->safe_bool_2($params, 'reduceOnly', 'reduce_only');
        $params = $this->omit($params, array( 'reduceOnly', 'reduce_only' ));
        $orderType = strtoupper($type);
        $this->load_markets();
        $market = $this->market($symbol);
        $orderSide = strtoupper($side);
        $request = array(
            'symbol' => $market['id'],
            'side' => $orderSide,
        );
        $stopPrice = $this->safe_number_2($params, 'triggerPrice', 'stopPrice');
        $stopLoss = $this->safe_value($params, 'stopLoss');
        $takeProfit = $this->safe_value($params, 'takeProfit');
        $algoType = $this->safe_string($params, 'algoType');
        $trailingTriggerPrice = $this->safe_string_2($params, 'trailingTriggerPrice', 'activatedPrice', $this->number_to_string($price));
        $trailingAmount = $this->safe_string_2($params, 'trailingAmount', 'callbackValue');
        $trailingPercent = $this->safe_string_2($params, 'trailingPercent', 'callbackRate');
        $isTrailingAmountOrder = $trailingAmount !== null;
        $isTrailingPercentOrder = $trailingPercent !== null;
        $isTrailing = $isTrailingAmountOrder || $isTrailingPercentOrder;
        $isStop = $isTrailing || $stopPrice !== null || $stopLoss !== null || $takeProfit !== null || ($this->safe_value($params, 'childOrders') !== null);
        $isMarket = $orderType === 'MARKET';
        $timeInForce = $this->safe_string_lower($params, 'timeInForce');
        $postOnly = $this->is_post_only($isMarket, null, $params);
        $reduceOnlyKey = $isStop ? 'reduceOnly' : 'reduce_only';
        $clientOrderIdKey = $isStop ? 'clientOrderId' : 'client_order_id';
        $orderQtyKey = $isStop ? 'quantity' : 'order_quantity';
        $priceKey = $isStop ? 'price' : 'order_price';
        $typeKey = $isStop ? 'type' : 'order_type';
        $request[$typeKey] = $orderType; // LIMIT/MARKET/IOC/FOK/POST_ONLY/ASK/BID
        if (!$isStop) {
            if ($postOnly) {
                $request['order_type'] = 'POST_ONLY';
            } elseif ($timeInForce === 'fok') {
                $request['order_type'] = 'FOK';
            } elseif ($timeInForce === 'ioc') {
                $request['order_type'] = 'IOC';
            }
        }
        if ($reduceOnly) {
            $request[$reduceOnlyKey] = $reduceOnly;
        }
        if ($price !== null) {
            $request[$priceKey] = $this->price_to_precision($symbol, $price);
        }
        if ($isMarket && !$isStop) {
            // for $market buy it requires the $amount of quote currency to spend
            if ($market['spot'] && $orderSide === 'BUY') {
                $quoteAmount = null;
                $createMarketBuyOrderRequiresPrice = true;
                list($createMarketBuyOrderRequiresPrice, $params) = $this->handle_option_and_params($params, 'createOrder', 'createMarketBuyOrderRequiresPrice', true);
                $cost = $this->safe_number_2($params, 'cost', 'order_amount');
                $params = $this->omit($params, array( 'cost', 'order_amount' ));
                if ($cost !== null) {
                    $quoteAmount = $this->cost_to_precision($symbol, $cost);
                } elseif ($createMarketBuyOrderRequiresPrice) {
                    if ($price === null) {
                        throw new InvalidOrder($this->id . ' createOrder() requires the $price argument for $market buy orders to calculate the total $cost to spend ($amount * $price), alternatively set the $createMarketBuyOrderRequiresPrice option or param to false and pass the $cost to spend (quote quantity) in the $amount argument');
                    } else {
                        $amountString = $this->number_to_string($amount);
                        $priceString = $this->number_to_string($price);
                        $costRequest = Precise::string_mul($amountString, $priceString);
                        $quoteAmount = $this->cost_to_precision($symbol, $costRequest);
                    }
                } else {
                    $quoteAmount = $this->cost_to_precision($symbol, $amount);
                }
                $request['order_amount'] = $quoteAmount;
            } else {
                $request['order_quantity'] = $this->amount_to_precision($symbol, $amount);
            }
        } elseif ($algoType !== 'POSITIONAL_TP_SL') {
            $request[$orderQtyKey] = $this->amount_to_precision($symbol, $amount);
        }
        $clientOrderId = $this->safe_string_n($params, array( 'clOrdID', 'clientOrderId', 'client_order_id' ));
        if ($clientOrderId !== null) {
            $request[$clientOrderIdKey] = $clientOrderId;
        }
        if ($isTrailing) {
            if ($trailingTriggerPrice === null) {
                throw new ArgumentsRequired($this->id . ' createOrder() requires a $trailingTriggerPrice parameter for trailing orders');
            }
            $request['activatedPrice'] = $this->price_to_precision($symbol, $trailingTriggerPrice);
            $request['algoType'] = 'TRAILING_STOP';
            if ($isTrailingAmountOrder) {
                $request['callbackValue'] = $trailingAmount;
            } elseif ($isTrailingPercentOrder) {
                $convertedTrailingPercent = Precise::string_div($trailingPercent, '100');
                $request['callbackRate'] = $convertedTrailingPercent;
            }
        } elseif ($stopPrice !== null) {
            if ($algoType !== 'TRAILING_STOP') {
                $request['triggerPrice'] = $this->price_to_precision($symbol, $stopPrice);
                $request['algoType'] = 'STOP';
            }
        } elseif (($stopLoss !== null) || ($takeProfit !== null)) {
            $request['algoType'] = 'BRACKET';
            $outterOrder = array(
                'symbol' => $market['id'],
                'reduceOnly' => false,
                'algoType' => 'POSITIONAL_TP_SL',
                'childOrders' => array(),
            );
            $closeSide = ($orderSide === 'BUY') ? 'SELL' : 'BUY';
            if ($stopLoss !== null) {
                $stopLossPrice = $this->safe_number_2($stopLoss, 'triggerPrice', 'price', $stopLoss);
                $stopLossOrder = array(
                    'side' => $closeSide,
                    'algoType' => 'STOP_LOSS',
                    'triggerPrice' => $this->price_to_precision($symbol, $stopLossPrice),
                    'type' => 'CLOSE_POSITION',
                    'reduceOnly' => true,
                );
                $outterOrder['childOrders'][] = $stopLossOrder;
            }
            if ($takeProfit !== null) {
                $takeProfitPrice = $this->safe_number_2($takeProfit, 'triggerPrice', 'price', $takeProfit);
                $takeProfitOrder = array(
                    'side' => $closeSide,
                    'algoType' => 'TAKE_PROFIT',
                    'triggerPrice' => $this->price_to_precision($symbol, $takeProfitPrice),
                    'type' => 'CLOSE_POSITION',
                    'reduceOnly' => true,
                );
                $outterOrder['childOrders'][] = $takeProfitOrder;
            }
            $request['childOrders'] = array( $outterOrder );
        }
        $params = $this->omit($params, array( 'clOrdID', 'clientOrderId', 'client_order_id', 'postOnly', 'timeInForce', 'stopPrice', 'triggerPrice', 'stopLoss', 'takeProfit', 'trailingPercent', 'trailingAmount', 'trailingTriggerPrice' ));
        $response = null;
        if ($isStop) {
            $response = $this->v3PrivatePostAlgoOrder (array_merge($request, $params));
        } else {
            $response = $this->v1PrivatePostOrder (array_merge($request, $params));
        }
        // {
        //     "success" => true,
        //     "timestamp" => "1641383206.489",
        //     "order_id" => "86980774",
        //     "order_type" => "LIMIT",
        //     "order_price" => "1", // null for "MARKET" $order
        //     "order_quantity" => "12", // null for "MARKET" $order
        //     "order_amount" => null, // NOT-null for "MARKET" $order
        //     "client_order_id" => "0"
        // }
        // stop orders
        // {
        //     "success" => true,
        //     "data" => {
        //       "rows" => array(
        //         array(
        //           "orderId" => "1578938",
        //           "clientOrderId" => "0",
        //           "algoType" => "STOP_LOSS",
        //           "quantity" => "0.1"
        //         }
        //       )
        //     ),
        //     "timestamp" => "1686149372216"
        // }
        $data = $this->safe_dict($response, 'data');
        if ($data !== null) {
            $rows = $this->safe_list($data, 'rows', array());
            return $this->parse_order($rows[0], $market);
        }
        $order = $this->parse_order($response, $market);
        $order['type'] = $type;
        return $order;
    }

    public function edit_order(string $id, string $symbol, string $type, string $side, ?float $amount = null, ?float $price = null, $params = array ()) {
        /**
         * edit a trade order
         * @see https://docs.woo.org/#edit-order
         * @see https://docs.woo.org/#edit-order-by-client_order_id
         * @see https://docs.woo.org/#edit-algo-order
         * @see https://docs.woo.org/#edit-algo-order-by-client_order_id
         * @param {string} $id order $id
         * @param {string} $symbol unified $symbol of the $market to create an order in
         * @param {string} $type 'market' or 'limit'
         * @param {string} $side 'buy' or 'sell'
         * @param {float} $amount how much of currency you want to trade in units of base currency
         * @param {float} [$price] the $price at which the order is to be fullfilled, in units of the quote currency, ignored in $market orders
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @param {float} [$params->triggerPrice] The $price a trigger order is triggered at
         * @param {float} [$params->stopLossPrice] $price to trigger stop-loss orders
         * @param {float} [$params->takeProfitPrice] $price to trigger take-profit orders
         * @param {string} [$params->trailingAmount] the quote $amount to trail away from the current $market $price
         * @param {string} [$params->trailingPercent] the percent to trail away from the current $market $price
         * @param {string} [$params->trailingTriggerPrice] the $price to trigger a trailing order, default uses the $price argument
         * @return {array} an ~@link https://docs.ccxt.com/#/?$id=order-structure order structure~
         */
        $this->load_markets();
        $market = $this->market($symbol);
        $request = array(
            // 'quantity' => $this->amount_to_precision($symbol, $amount),
            // 'price' => $this->price_to_precision($symbol, $price),
        );
        if ($price !== null) {
            $request['price'] = $this->price_to_precision($symbol, $price);
        }
        if ($amount !== null) {
            $request['quantity'] = $this->amount_to_precision($symbol, $amount);
        }
        $clientOrderIdUnified = $this->safe_string_2($params, 'clOrdID', 'clientOrderId');
        $clientOrderIdExchangeSpecific = $this->safe_string($params, 'client_order_id', $clientOrderIdUnified);
        $isByClientOrder = $clientOrderIdExchangeSpecific !== null;
        $stopPrice = $this->safe_number_n($params, array( 'triggerPrice', 'stopPrice', 'takeProfitPrice', 'stopLossPrice' ));
        if ($stopPrice !== null) {
            $request['triggerPrice'] = $this->price_to_precision($symbol, $stopPrice);
        }
        $trailingTriggerPrice = $this->safe_string_2($params, 'trailingTriggerPrice', 'activatedPrice', $this->number_to_string($price));
        $trailingAmount = $this->safe_string_2($params, 'trailingAmount', 'callbackValue');
        $trailingPercent = $this->safe_string_2($params, 'trailingPercent', 'callbackRate');
        $isTrailingAmountOrder = $trailingAmount !== null;
        $isTrailingPercentOrder = $trailingPercent !== null;
        $isTrailing = $isTrailingAmountOrder || $isTrailingPercentOrder;
        if ($isTrailing) {
            if ($trailingTriggerPrice !== null) {
                $request['activatedPrice'] = $this->price_to_precision($symbol, $trailingTriggerPrice);
            }
            if ($isTrailingAmountOrder) {
                $request['callbackValue'] = $trailingAmount;
            } elseif ($isTrailingPercentOrder) {
                $convertedTrailingPercent = Precise::string_div($trailingPercent, '100');
                $request['callbackRate'] = $convertedTrailingPercent;
            }
        }
        $params = $this->omit($params, array( 'clOrdID', 'clientOrderId', 'client_order_id', 'stopPrice', 'triggerPrice', 'takeProfitPrice', 'stopLossPrice', 'trailingTriggerPrice', 'trailingAmount', 'trailingPercent' ));
        $isStop = $isTrailing || ($stopPrice !== null) || ($this->safe_value($params, 'childOrders') !== null);
        $response = null;
        if ($isByClientOrder) {
            $request['client_order_id'] = $clientOrderIdExchangeSpecific;
            if ($isStop) {
                $response = $this->v3PrivatePutAlgoOrderClientClientOrderId (array_merge($request, $params));
            } else {
                $response = $this->v3PrivatePutOrderClientClientOrderId (array_merge($request, $params));
            }
        } else {
            $request['oid'] = $id;
            if ($isStop) {
                $response = $this->v3PrivatePutAlgoOrderOid (array_merge($request, $params));
            } else {
                $response = $this->v3PrivatePutOrderOid (array_merge($request, $params));
            }
        }
        //
        //     {
        //         "code" => 0,
        //         "data" => array(
        //             "status" => "string",
        //             "success" => true
        //         ),
        //         "message" => "string",
        //         "success" => true,
        //         "timestamp" => 0
        //     }
        //
        $data = $this->safe_dict($response, 'data', array());
        return $this->parse_order($data, $market);
    }

    public function cancel_order(string $id, ?string $symbol = null, $params = array ()) {
        /**
         * @see https://docs.woo.org/#cancel-algo-order
         * @see https://docs.woo.org/#cancel-order
         * @see https://docs.woo.org/#cancel-order-by-client_order_id
         * cancels an open order
         * @param {string} $id order $id
         * @param {string} $symbol unified $symbol of the $market the order was made in
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @param {boolean} [$params->stop] whether the order is a stop/algo order
         * @return {array} An ~@link https://docs.ccxt.com/#/?$id=order-structure order structure~
         */
        $stop = $this->safe_bool($params, 'stop', false);
        $params = $this->omit($params, 'stop');
        if (!$stop && ($symbol === null)) {
            throw new ArgumentsRequired($this->id . ' cancelOrder() requires a $symbol argument');
        }
        $this->load_markets();
        $market = null;
        if ($symbol !== null) {
            $market = $this->market($symbol);
        }
        $request = array();
        $clientOrderIdUnified = $this->safe_string_2($params, 'clOrdID', 'clientOrderId');
        $clientOrderIdExchangeSpecific = $this->safe_string($params, 'client_order_id', $clientOrderIdUnified);
        $isByClientOrder = $clientOrderIdExchangeSpecific !== null;
        $response = null;
        if ($stop) {
            $request['order_id'] = $id;
            $response = $this->v3PrivateDeleteAlgoOrderOrderId (array_merge($request, $params));
        } else {
            $request['symbol'] = $market['id'];
            if ($isByClientOrder) {
                $request['client_order_id'] = $clientOrderIdExchangeSpecific;
                $params = $this->omit($params, array( 'clOrdID', 'clientOrderId', 'client_order_id' ));
                $response = $this->v1PrivateDeleteClientOrder (array_merge($request, $params));
            } else {
                $request['order_id'] = $id;
                $response = $this->v1PrivateDeleteOrder (array_merge($request, $params));
            }
        }
        //
        // array( success => true, status => "CANCEL_SENT" )
        //
        $extendParams = array( 'symbol' => $symbol );
        if ($isByClientOrder) {
            $extendParams['client_order_id'] = $clientOrderIdExchangeSpecific;
        } else {
            $extendParams['id'] = $id;
        }
        return array_merge($this->parse_order($response), $extendParams);
    }

    public function cancel_all_orders(?string $symbol = null, $params = array ()) {
        /**
         * @see https://docs.woo.org/#cancel-all-pending-orders
         * @see https://docs.woo.org/#cancel-orders
         * @see https://docs.woo.org/#cancel-all-pending-algo-orders
         * cancel all open orders in a $market
         * @param {string} $symbol unified $market $symbol
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @param {boolean} [$params->stop] whether the order is a stop/algo order
         * @return {array} an list of ~@link https://docs.ccxt.com/#/?id=order-structure order structures~
         */
        $this->load_markets();
        $stop = $this->safe_bool_2($params, 'stop', 'trigger');
        $params = $this->omit($params, array( 'stop', 'trigger' ));
        if ($stop) {
            return $this->v3PrivateDeleteAlgoOrdersPending ($params);
        }
        if ($symbol === null) {
            throw new ArgumentsRequired($this->id . ' cancelOrders() requires a $symbol argument');
        }
        $market = $this->market($symbol);
        $request = array(
            'symbol' => $market['id'],
        );
        $response = $this->v1PrivateDeleteOrders (array_merge($request, $params));
        //
        //     {
        //         "success":true,
        //         "status":"CANCEL_ALL_SENT"
        //     }
        //
        return $response;
    }

    public function cancel_all_orders_after(?int $timeout, $params = array ()) {
        /**
         * dead man's switch, cancel all orders after the given $timeout
         * @see https://docs.woo.org/#cancel-all-after
         * @param {number} $timeout time in milliseconds, 0 represents cancel the timer
         * @param {boolean} activated countdown
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @return {array} the api result
         */
        $this->load_markets();
        $request = array(
            'trigger_after' => ($timeout > 0) ? $timeout : 0,
        );
        $response = $this->v1PrivatePostOrderCancelAllAfter (array_merge($request, $params));
        //
        //     {
        //         "success" => true,
        //         "data" => array(
        //             "expected_trigger_time" => 1711534302938
        //         ),
        //         "timestamp" => 1711534302943
        //     }
        //
        return $response;
    }

    public function fetch_order(string $id, ?string $symbol = null, $params = array ()) {
        /**
         * @see https://docs.woo.org/#get-algo-order
         * @see https://docs.woo.org/#get-order
         * fetches information on an order made by the user
         * @param {string} $symbol unified $symbol of the $market the order was made in
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @param {boolean} [$params->stop] whether the order is a stop/algo order
         * @return {array} An ~@link https://docs.ccxt.com/#/?$id=order-structure order structure~
         */
        $this->load_markets();
        $market = ($symbol !== null) ? $this->market($symbol) : null;
        $stop = $this->safe_bool_2($params, 'stop', 'trigger');
        $params = $this->omit($params, array( 'stop', 'trigger' ));
        $request = array();
        $clientOrderId = $this->safe_string_2($params, 'clOrdID', 'clientOrderId');
        $response = null;
        if ($stop) {
            $request['oid'] = $id;
            $response = $this->v3PrivateGetAlgoOrderOid (array_merge($request, $params));
        } elseif ($clientOrderId) {
            $request['client_order_id'] = $clientOrderId;
            $response = $this->v1PrivateGetClientOrderClientOrderId (array_merge($request, $params));
        } else {
            $request['oid'] = $id;
            $response = $this->v1PrivateGetOrderOid (array_merge($request, $params));
        }
        //
        // {
        //     "success" => true,
        //     "symbol" => "SPOT_WOO_USDT",
        //     "status" => "FILLED", // FILLED, NEW
        //     "side" => "BUY",
        //     "created_time" => "1641480933.000",
        //     "order_id" => "87541111",
        //     "order_tag" => "default",
        //     "price" => "1",
        //     "type" => "LIMIT",
        //     "quantity" => "12",
        //     "amount" => null,
        //     "visible" => "12",
        //     "executed" => "12", // or any partial amount
        //     "total_fee" => "0.0024",
        //     "fee_asset" => "WOO",
        //     "client_order_id" => null,
        //     "average_executed_price" => "1",
        //     "Transactions" => array(
        //       {
        //         "id" => "99111647",
        //         "symbol" => "SPOT_WOO_USDT",
        //         "fee" => "0.0024",
        //         "side" => "BUY",
        //         "executed_timestamp" => "1641482113.084",
        //         "order_id" => "87541111",
        //         "executed_price" => "1",
        //         "executed_quantity" => "12",
        //         "fee_asset" => "WOO",
        //         "is_maker" => "1"
        //       }
        //     )
        // }
        //
        $orders = $this->safe_dict($response, 'data', $response);
        return $this->parse_order($orders, $market);
    }

    public function fetch_orders(?string $symbol = null, ?int $since = null, ?int $limit = null, $params = array ()): array {
        /**
         * fetches information on multiple $orders made by the user
         * @see https://docs.woo.org/#get-$orders
         * @see https://docs.woo.org/#get-algo-$orders
         * @param {string} $symbol unified $market $symbol of the $market $orders were made in
         * @param {int} [$since] the earliest time in ms to fetch $orders for
         * @param {int} [$limit] the maximum number of order structures to retrieve
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @param {boolean} [$params->stop] whether the order is a stop/algo order
         * @param {boolean} [$params->isTriggered] whether the order has been triggered (false by default)
         * @param {string} [$params->side] 'buy' or 'sell'
         * @param {boolean} [$params->trailing] set to true if you want to fetch $trailing $orders
         * @param {boolean} [$params->paginate] set to true if you want to fetch $orders with pagination
         * @return {Order[]} a list of ~@link https://docs.ccxt.com/#/?id=order-structure order structures~
         */
        $this->load_markets();
        $paginate = false;
        list($paginate, $params) = $this->handle_option_and_params($params, 'fetchOrders', 'paginate');
        if ($paginate) {
            return $this->fetch_paginated_call_incremental('fetchOrders', $symbol, $since, $limit, $params, 'page', 500);
        }
        $request = array();
        $market = null;
        $stop = $this->safe_bool_2($params, 'stop', 'trigger');
        $trailing = $this->safe_bool($params, 'trailing', false);
        $params = $this->omit($params, array( 'stop', 'trailing', 'trigger' ));
        if ($symbol !== null) {
            $market = $this->market($symbol);
            $request['symbol'] = $market['id'];
        }
        if ($since !== null) {
            if ($stop || $trailing) {
                $request['createdTimeStart'] = $since;
            } else {
                $request['start_t'] = $since;
            }
        }
        if ($limit !== null) {
            $request['size'] = $limit;
        } else {
            $request['size'] = 500;
        }
        if ($stop) {
            $request['algoType'] = 'stop';
        } elseif ($trailing) {
            $request['algoType'] = 'TRAILING_STOP';
        }
        $response = null;
        if ($stop || $trailing) {
            $response = $this->v3PrivateGetAlgoOrders (array_merge($request, $params));
        } else {
            $response = $this->v1PrivateGetOrders (array_merge($request, $params));
        }
        //
        //     {
        //         "success":true,
        //         "meta":array(
        //             "total":1,
        //             "records_per_page":100,
        //             "current_page":1
        //         ),
        //         "rows":array(
        //             {
        //                 "symbol":"PERP_BTC_USDT",
        //                 "status":"FILLED",
        //                 "side":"SELL",
        //                 "created_time":"1611617776.000",
        //                 "updated_time":"1611617776.000",
        //                 "order_id":52121167,
        //                 "order_tag":"default",
        //                 "price":null,
        //                 "type":"MARKET",
        //                 "quantity":0.002,
        //                 "amount":null,
        //                 "visible":0,
        //                 "executed":0.002,
        //                 "total_fee":0.01732885,
        //                 "fee_asset":"USDT",
        //                 "client_order_id":null,
        //                 "average_executed_price":28881.41
        //             }
        //         )
        //     }
        //
        $data = $this->safe_value($response, 'data', $response);
        $orders = $this->safe_list($data, 'rows');
        return $this->parse_orders($orders, $market, $since, $limit);
    }

    public function fetch_open_orders(?string $symbol = null, ?int $since = null, ?int $limit = null, $params = array ()): array {
        /**
         * fetches information on multiple orders made by the user
         * @see https://docs.woo.org/#get-orders
         * @see https://docs.woo.org/#get-algo-orders
         * @param {string} $symbol unified market $symbol of the market orders were made in
         * @param {int} [$since] the earliest time in ms to fetch orders for
         * @param {int} [$limit] the maximum number of order structures to retrieve
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @param {boolean} [$params->stop] whether the order is a stop/algo order
         * @param {boolean} [$params->isTriggered] whether the order has been triggered (false by default)
         * @param {string} [$params->side] 'buy' or 'sell'
         * @param {boolean} [$params->trailing] set to true if you want to fetch trailing orders
         * @param {boolean} [$params->paginate] set to true if you want to fetch orders with pagination
         * @return {Order[]} a list of ~@link https://docs.ccxt.com/#/?id=order-structure order structures~
         */
        $this->load_markets();
        $extendedParams = array_merge($params, array( 'status' => 'INCOMPLETE' ));
        return $this->fetch_orders($symbol, $since, $limit, $extendedParams);
    }

    public function fetch_closed_orders(?string $symbol = null, ?int $since = null, ?int $limit = null, $params = array ()): array {
        /**
         * fetches information on multiple orders made by the user
         * @see https://docs.woo.org/#get-orders
         * @see https://docs.woo.org/#get-algo-orders
         * @param {string} $symbol unified market $symbol of the market orders were made in
         * @param {int} [$since] the earliest time in ms to fetch orders for
         * @param {int} [$limit] the maximum number of order structures to retrieve
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @param {boolean} [$params->stop] whether the order is a stop/algo order
         * @param {boolean} [$params->isTriggered] whether the order has been triggered (false by default)
         * @param {string} [$params->side] 'buy' or 'sell'
         * @param {boolean} [$params->trailing] set to true if you want to fetch trailing orders
         * @param {boolean} [$params->paginate] set to true if you want to fetch orders with pagination
         * @return {Order[]} a list of ~@link https://docs.ccxt.com/#/?id=order-structure order structures~
         */
        $this->load_markets();
        $extendedParams = array_merge($params, array( 'status' => 'COMPLETED' ));
        return $this->fetch_orders($symbol, $since, $limit, $extendedParams);
    }

    public function parse_time_in_force($timeInForce) {
        $timeInForces = array(
            'ioc' => 'IOC',
            'fok' => 'FOK',
            'post_only' => 'PO',
        );
        return $this->safe_string($timeInForces, $timeInForce, null);
    }

    public function parse_order($order, ?array $market = null): array {
        //
        // Possible input functions:
        // * createOrder
        // * cancelOrder
        // * fetchOrder
        // * fetchOrders
        // $isFromFetchOrder = (is_array($order) && array_key_exists('order_tag', $order)); TO_DO
        //
        // stop $order after creating it:
        //   {
        //     "orderId" => "1578938",
        //     "clientOrderId" => "0",
        //     "algoType" => "STOP_LOSS",
        //     "quantity" => "0.1"
        //   }
        // stop $order after fetching it:
        //   {
        //       "algoOrderId" => "1578958",
        //       "clientOrderId" => "0",
        //       "rootAlgoOrderId" => "1578958",
        //       "parentAlgoOrderId" => "0",
        //       "symbol" => "SPOT_LTC_USDT",
        //       "orderTag" => "default",
        //       "algoType" => "STOP_LOSS",
        //       "side" => "BUY",
        //       "quantity" => "0.1",
        //       "isTriggered" => false,
        //       "triggerPrice" => "100",
        //       "triggerStatus" => "USELESS",
        //       "type" => "LIMIT",
        //       "rootAlgoStatus" => "CANCELLED",
        //       "algoStatus" => "CANCELLED",
        //       "triggerPriceType" => "MARKET_PRICE",
        //       "price" => "75",
        //       "triggerTime" => "0",
        //       "totalExecutedQuantity" => "0",
        //       "averageExecutedPrice" => "0",
        //       "totalFee" => "0",
        //       "feeAsset" => '',
        //       "reduceOnly" => false,
        //       "createdTime" => "1686149609.744",
        //       "updatedTime" => "1686149903.362"
        //   }
        //
        $timestamp = $this->safe_timestamp_n($order, array( 'timestamp', 'created_time', 'createdTime' ));
        $orderId = $this->safe_string_n($order, array( 'order_id', 'orderId', 'algoOrderId' ));
        $clientOrderId = $this->omit_zero($this->safe_string_2($order, 'client_order_id', 'clientOrderId')); // Somehow, this always returns 0 for limit $order
        $marketId = $this->safe_string($order, 'symbol');
        $market = $this->safe_market($marketId, $market);
        $symbol = $market['symbol'];
        $price = $this->safe_string_2($order, 'order_price', 'price');
        $amount = $this->safe_string_2($order, 'order_quantity', 'quantity'); // This is base $amount
        $cost = $this->safe_string_2($order, 'order_amount', 'amount'); // This is quote $amount
        $orderType = $this->safe_string_lower_2($order, 'order_type', 'type');
        $status = $this->safe_value_2($order, 'status', 'algoStatus');
        $side = $this->safe_string_lower($order, 'side');
        $filled = $this->omit_zero($this->safe_value_2($order, 'executed', 'totalExecutedQuantity'));
        $average = $this->omit_zero($this->safe_string_2($order, 'average_executed_price', 'averageExecutedPrice'));
        $remaining = Precise::string_sub($cost, $filled);
        $fee = $this->safe_value_2($order, 'total_fee', 'totalFee');
        $feeCurrency = $this->safe_string_2($order, 'fee_asset', 'feeAsset');
        $transactions = $this->safe_value($order, 'Transactions');
        $stopPrice = $this->safe_number($order, 'triggerPrice');
        $takeProfitPrice = null;
        $stopLossPrice = null;
        $childOrders = $this->safe_value($order, 'childOrders');
        if ($childOrders !== null) {
            $first = $this->safe_value($childOrders, 0);
            $innerChildOrders = $this->safe_value($first, 'childOrders', array());
            $innerChildOrdersLength = count($innerChildOrders);
            if ($innerChildOrdersLength > 0) {
                $takeProfitOrder = $this->safe_value($innerChildOrders, 0);
                $stopLossOrder = $this->safe_value($innerChildOrders, 1);
                $takeProfitPrice = $this->safe_number($takeProfitOrder, 'triggerPrice');
                $stopLossPrice = $this->safe_number($stopLossOrder, 'triggerPrice');
            }
        }
        $lastUpdateTimestamp = $this->safe_timestamp_2($order, 'updatedTime', 'updated_time');
        return $this->safe_order(array(
            'id' => $orderId,
            'clientOrderId' => $clientOrderId,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'lastTradeTimestamp' => null,
            'lastUpdateTimestamp' => $lastUpdateTimestamp,
            'status' => $this->parse_order_status($status),
            'symbol' => $symbol,
            'type' => $orderType,
            'timeInForce' => $this->parse_time_in_force($orderType),
            'postOnly' => null, // TO_DO
            'reduceOnly' => $this->safe_bool($order, 'reduce_only'),
            'side' => $side,
            'price' => $price,
            'stopPrice' => $stopPrice,
            'triggerPrice' => $stopPrice,
            'takeProfitPrice' => $takeProfitPrice,
            'stopLossPrice' => $stopLossPrice,
            'average' => $average,
            'amount' => $amount,
            'filled' => $filled,
            'remaining' => $remaining, // TO_DO
            'cost' => $cost,
            'trades' => $transactions,
            'fee' => array(
                'cost' => $fee,
                'currency' => $feeCurrency,
            ),
            'info' => $order,
        ), $market);
    }

    public function parse_order_status($status) {
        if ($status !== null) {
            $statuses = array(
                'NEW' => 'open',
                'FILLED' => 'closed',
                'CANCEL_SENT' => 'canceled',
                'CANCEL_ALL_SENT' => 'canceled',
                'CANCELLED' => 'canceled',
                'PARTIAL_FILLED' => 'open',
                'REJECTED' => 'rejected',
                'INCOMPLETE' => 'open',
                'COMPLETED' => 'closed',
            );
            return $this->safe_string($statuses, $status, $status);
        }
        return $status;
    }

    public function fetch_order_book(string $symbol, ?int $limit = null, $params = array ()): array {
        /**
         * fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
         * @param {string} $symbol unified $symbol of the $market to fetch the order book for
         * @param {int} [$limit] the maximum amount of order book entries to return
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @return {array} A dictionary of ~@link https://docs.ccxt.com/#/?id=order-book-structure order book structures~ indexed by $market symbols
         */
        $this->load_markets();
        $market = $this->market($symbol);
        $request = array(
            'symbol' => $market['id'],
        );
        if ($limit !== null) {
            $limit = min ($limit, 1000);
            $request['max_level'] = $limit;
        }
        $response = $this->v1PublicGetOrderbookSymbol (array_merge($request, $params));
        //
        // {
        //   "success" => true,
        //   "timestamp" => "1641562961192",
        //   "asks" => array(
        //     array( price => '0.921', quantity => "76.01" ),
        //     array( price => '0.933', quantity => "477.10" ),
        //     ...
        //   ),
        //   "bids" => array(
        //     array( price => '0.940', quantity => "13502.47" ),
        //     array( price => '0.932', quantity => "43.91" ),
        //     ...
        //   )
        // }
        //
        $timestamp = $this->safe_integer($response, 'timestamp');
        return $this->parse_order_book($response, $symbol, $timestamp, 'bids', 'asks', 'price', 'quantity');
    }

    public function fetch_ohlcv(string $symbol, $timeframe = '1m', ?int $since = null, ?int $limit = null, $params = array ()): array {
        /**
         * @see https://docs.woo.org/#kline-public
         * @see https://docs.woo.org/#kline-historical-data-public
         * fetches historical candlestick data containing the open, high, low, and close price, and the volume of a $market
         * @param {string} $symbol unified $symbol of the $market to fetch OHLCV data for
         * @param {string} $timeframe the length of time each candle represents
         * @param {int} [$since] timestamp in ms of the earliest candle to fetch
         * @param {int} [$limit] max=1000, max=100 when $since is defined and is less than (now - (999 * (is_array(ms) && array_key_exists($timeframe, ms))))
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @return {int[][]} A list of candles ordered, open, high, low, close, volume
         */
        $this->load_markets();
        $market = $this->market($symbol);
        $request = array(
            'symbol' => $market['id'],
            'type' => $this->safe_string($this->timeframes, $timeframe, $timeframe),
        );
        $useHistEndpoint = $since !== null;
        if (($limit !== null) && ($since !== null)) {
            $oneThousandCandles = $this->parse_timeframe($timeframe) * 1000 * 999;  // 999 because there will be delay between this and the $request, causing the latest candle to be excluded sometimes
            $startWithLimit = $this->milliseconds() - $oneThousandCandles;
            $useHistEndpoint = $since < $startWithLimit;
        }
        if ($useHistEndpoint) {
            $request['start_time'] = $since;
        } elseif ($limit !== null) {  // the hist endpoint does not accept $limit
            $request['limit'] = min ($limit, 1000);
        }
        $response = null;
        if (!$useHistEndpoint) {
            $response = $this->v1PublicGetKline (array_merge($request, $params));
            //
            //    {
            //        "success" => true,
            //        "rows" => array(
            //            array(
            //                "open" => "0.94238",
            //                "close" => "0.94271",
            //                "low" => "0.94238",
            //                "high" => "0.94296",
            //                "volume" => "73.55",
            //                "amount" => "69.32040520",
            //                "symbol" => "SPOT_WOO_USDT",
            //                "type" => "1m",
            //                "start_timestamp" => "1641584700000",
            //                "end_timestamp" => "1641584760000"
            //            ),
            //            ...
            //        )
            //    }
            //
        } else {
            $response = $this->v1PubGetHistKline (array_merge($request, $params));
            $response = $this->safe_dict($response, 'data');
            //
            //    {
            //        "success" => true,
            //        "data" => {
            //            "rows" => array(
            //                array(
            //                    "symbol" => "SPOT_BTC_USDT",
            //                    "open" => 44181.40000000,
            //                    "close" => 44174.29000000,
            //                    "high" => 44193.44000000,
            //                    "low" => 44148.34000000,
            //                    "volume" => 110.11930100,
            //                    "amount" => 4863796.24318878,
            //                    "type" => "1m",
            //                    "start_timestamp" => 1704153600000,
            //                    "end_timestamp" => 1704153660000
            //                ),
            //                ...
            //            )
            //        }
            //    }
            //
        }
        $rows = $this->safe_list($response, 'rows', array());
        return $this->parse_ohlcvs($rows, $market, $timeframe, $since, $limit);
    }

    public function parse_ohlcv($ohlcv, ?array $market = null): array {
        // example response in fetchOHLCV
        return array(
            $this->safe_integer($ohlcv, 'start_timestamp'),
            $this->safe_number($ohlcv, 'open'),
            $this->safe_number($ohlcv, 'high'),
            $this->safe_number($ohlcv, 'low'),
            $this->safe_number($ohlcv, 'close'),
            $this->safe_number($ohlcv, 'volume'),
        );
    }

    public function fetch_order_trades(string $id, ?string $symbol = null, ?int $since = null, ?int $limit = null, $params = array ()) {
        /**
         * fetch all the $trades made from a single order
         * @param {string} $id order $id
         * @param {string} $symbol unified $market $symbol
         * @param {int} [$since] the earliest time in ms to fetch $trades for
         * @param {int} [$limit] the maximum number of $trades to retrieve
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @return {array[]} a list of ~@link https://docs.ccxt.com/#/?$id=trade-structure trade structures~
         */
        $this->load_markets();
        $market = null;
        if ($symbol !== null) {
            $market = $this->market($symbol);
        }
        $request = array(
            'oid' => $id,
        );
        $response = $this->v1PrivateGetOrderOidTrades (array_merge($request, $params));
        // {
        //     "success" => true,
        //     "rows" => array(
        //       {
        //         "id" => "99111647",
        //         "symbol" => "SPOT_WOO_USDT",
        //         "fee" => "0.0024",
        //         "side" => "BUY",
        //         "executed_timestamp" => "1641482113.084",
        //         "order_id" => "87541111",
        //         "order_tag" => "default",
        //         "executed_price" => "1",
        //         "executed_quantity" => "12",
        //         "fee_asset" => "WOO",
        //         "is_maker" => "1"
        //       }
        //     )
        // }
        $trades = $this->safe_list($response, 'rows', array());
        return $this->parse_trades($trades, $market, $since, $limit, $params);
    }

    public function fetch_my_trades(?string $symbol = null, ?int $since = null, ?int $limit = null, $params = array ()) {
        /**
         * @see https://docs.woo.org/#get-$trades
         * fetch all $trades made by the user
         * @param {string} $symbol unified $market $symbol
         * @param {int} [$since] the earliest time in ms to fetch $trades for
         * @param {int} [$limit] the maximum number of $trades structures to retrieve
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @param {boolean} [$params->paginate] set to true if you want to fetch $trades with pagination
         * @return {Trade[]} a list of ~@link https://docs.ccxt.com/#/?id=trade-structure trade structures~
         */
        $this->load_markets();
        $paginate = false;
        list($paginate, $params) = $this->handle_option_and_params($params, 'fetchMyTrades', 'paginate');
        if ($paginate) {
            return $this->fetch_paginated_call_incremental('fetchMyTrades', $symbol, $since, $limit, $params, 'page', 500);
        }
        $request = array();
        $market = null;
        if ($symbol !== null) {
            $market = $this->market($symbol);
            $request['symbol'] = $market['id'];
        }
        if ($since !== null) {
            $request['start_t'] = $since;
        }
        if ($limit !== null) {
            $request['size'] = $limit;
        } else {
            $request['size'] = 500;
        }
        $response = $this->v1PrivateGetClientTrades (array_merge($request, $params));
        // {
        //     "success" => true,
        //     "meta" => array(
        //         "records_per_page" => 25,
        //         "current_page" => 1
        //     ),
        //     "rows" => array(
        //         array(
        //             "id" => 5,
        //             "symbol" => "SPOT_BTC_USDT",
        //             "order_id" => 211,
        //             "order_tag" => "default",
        //             "executed_price" => 10892.84,
        //             "executed_quantity" => 0.002,
        //             "is_maker" => 0,
        //             "side" => "SELL",
        //             "fee" => 0,
        //             "fee_asset" => "USDT",
        //             "executed_timestamp" => "1566264290.250"
        //         ),
        //         ...
        //     )
        // }
        $trades = $this->safe_list($response, 'rows', array());
        return $this->parse_trades($trades, $market, $since, $limit, $params);
    }

    public function fetch_accounts($params = array ()): array {
        /**
         * fetch all the accounts associated with a profile
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @return {array} a dictionary of ~@link https://docs.ccxt.com/#/?id=account-structure account structures~ indexed by the account type
         */
        $response = $this->v1PrivateGetSubAccountAssets ($params);
        //
        //     {
        //         "rows" => [array(
        //                 "application_id" => "13e4fc34-e2ff-4cb7-b1e4-4c22fee7d365",
        //                 "account" => "Main",
        //                 "usdt_balance" => "4.0"
        //             ),
        //             {
        //                 "application_id" => "432952aa-a401-4e26-aff6-972920aebba3",
        //                 "account" => "subaccount",
        //                 "usdt_balance" => "1.0"
        //             }
        //         ],
        //         "success" => true
        //     }
        //
        $rows = $this->safe_list($response, 'rows', array());
        return $this->parse_accounts($rows, $params);
    }

    public function parse_account($account) {
        //
        //     {
        //         "application_id" => "336952aa-a401-4e26-aff6-972920aebba3",
        //         "account" => "subaccount",
        //         "usdt_balance" => "1.0",
        //     }
        //
        $accountId = $this->safe_string($account, 'account');
        return array(
            'info' => $account,
            'id' => $this->safe_string($account, 'application_id'),
            'name' => $accountId,
            'code' => null,
            'type' => $accountId === 'Main' ? 'main' : 'subaccount',
        );
    }

    public function fetch_balance($params = array ()): array {
        /**
         * query for balance and get the amount of funds available for trading or funds locked in orders
         * @see https://docs.woo.org/#get-current-holding-get-balance-new
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @return {array} a ~@link https://docs.ccxt.com/#/?id=balance-structure balance structure~
         */
        $this->load_markets();
        $response = $this->v3PrivateGetBalances ($params);
        //
        //     {
        //         "success" => true,
        //         "data" => {
        //             "holding" => array(
        //                 array(
        //                     "token" => "0_token",
        //                     "holding" => 1,
        //                     "frozen" => 0,
        //                     "staked" => 0,
        //                     "unbonding" => 0,
        //                     "vault" => 0,
        //                     "interest" => 0,
        //                     "pendingShortQty" => 0,
        //                     "pendingLongQty" => 0,
        //                     "availableBalance" => 0,
        //                     "updatedTime" => 312321.121
        //                 }
        //             )
        //         ),
        //         "timestamp" => 1673323746259
        //     }
        //
        $data = $this->safe_dict($response, 'data');
        return $this->parse_balance($data);
    }

    public function parse_balance($response): array {
        $result = array(
            'info' => $response,
        );
        $balances = $this->safe_list($response, 'holding', array());
        for ($i = 0; $i < count($balances); $i++) {
            $balance = $balances[$i];
            $code = $this->safe_currency_code($this->safe_string($balance, 'token'));
            $account = $this->account();
            $account['total'] = $this->safe_string($balance, 'holding');
            $account['free'] = $this->safe_string($balance, 'availableBalance');
            $result[$code] = $account;
        }
        return $this->safe_balance($result);
    }

    public function fetch_deposit_address(string $code, $params = array ()) {
        /**
         * fetch the deposit $address for a $currency associated with this account
         * @param {string} $code unified $currency $code
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @return {array} an ~@link https://docs.ccxt.com/#/?id=$address-structure $address structure~
         */
        // this method is TODO because of networks unification
        $this->load_markets();
        $currency = $this->currency($code);
        $networkCodeDefault = $this->default_network_code_for_currency($code);
        $networkCode = $this->safe_string($params, 'network', $networkCodeDefault);
        $params = $this->omit($params, 'network');
        $codeForExchange = $networkCode . '_' . $currency['code'];
        $request = array(
            'token' => $codeForExchange,
        );
        $response = $this->v1PrivateGetAssetDeposit (array_merge($request, $params));
        // {
        //     "success" => true,
        //     "address" => "3Jmtjx5544T4smrit9Eroe4PCrRkpDeKjP",
        //     "extra" => ''
        // }
        $tag = $this->safe_string($response, 'extra');
        $address = $this->safe_string($response, 'address');
        $this->check_address($address);
        return array(
            'currency' => $code,
            'address' => $address,
            'tag' => $tag,
            'network' => $networkCode,
            'info' => $response,
        );
    }

    public function get_asset_history_rows(?string $code = null, ?int $since = null, ?int $limit = null, $params = array ()) {
        $this->load_markets();
        $request = array( );
        $currency = null;
        if ($code !== null) {
            $currency = $this->currency($code);
            $request['balance_token'] = $currency['id'];
        }
        if ($since !== null) {
            $request['start_t'] = $since;
        }
        if ($limit !== null) {
            $request['pageSize'] = $limit;
        }
        $transactionType = $this->safe_string($params, 'type');
        $params = $this->omit($params, 'type');
        if ($transactionType !== null) {
            $request['type'] = $transactionType;
        }
        $response = $this->v1PrivateGetAssetHistory (array_merge($request, $params));
        // {
        //     "rows" => array(
        //       {
        //         "id" => "22010508193900165",
        //         "token" => "TRON_USDT",
        //         "extra" => '',
        //         "amount" => "13.75848500",
        //         "status" => "COMPLETED",
        //         "account" => null,
        //         "description" => null,
        //         "user_id" => "42222",
        //         "application_id" => "6ad2b303-f354-45c0-8105-9f5f19d0e335",
        //         "external_id" => "220105081900134",
        //         "target_address" => "TXnyFSnAYad3YCaqtwMw9jvXKkeU39NLnK",
        //         "source_address" => "TYDzsYUEpvnYmQk4zGP9sWWcTEd2MiAtW6",
        //         "type" => "BALANCE",
        //         "token_side" => "DEPOSIT",
        //         "tx_id" => "35b0004022f6b3ad07f39a0b7af199f6b258c2c3e2c7cdc93c67efa74fd625ee",
        //         "fee_token" => '',
        //         "fee_amount" => "0.00000000",
        //         "created_time" => "1641370779.442",
        //         "updated_time" => "1641370779.465",
        //         "is_new_target_address" => null,
        //         "confirmed_number" => "29",
        //         "confirming_threshold" => "27",
        //         "audit_tag" => "1",
        //         "audit_result" => "0",
        //         "balance_token" => null, // TODO -write to support, that this seems broken. here should be the token id
        //         "network_name" => null // TODO -write to support, that this seems broken. here should be the network id
        //       }
        //     ),
        //     "meta" => array( total => '1', records_per_page => "25", current_page => "1" ),
        //     "success" => true
        // }
        return array( $currency, $this->safe_value($response, 'rows', array()) );
    }

    public function fetch_ledger(?string $code = null, ?int $since = null, ?int $limit = null, $params = array ()) {
        /**
         * fetch the history of changes, actions done by the user or operations that altered balance of the user
         * @param {string} $code unified $currency $code, default is null
         * @param {int} [$since] timestamp in ms of the earliest ledger entry, default is null
         * @param {int} [$limit] max number of ledger entrys to return, default is null
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @return {array} a ~@link https://docs.ccxt.com/#/?id=ledger-structure ledger structure~
         */
        list($currency, $rows) = $this->get_asset_history_rows($code, $since, $limit, $params);
        return $this->parse_ledger($rows, $currency, $since, $limit, $params);
    }

    public function parse_ledger_entry($item, ?array $currency = null) {
        $networkizedCode = $this->safe_string($item, 'token');
        $currencyDefined = $this->get_currency_from_chaincode($networkizedCode, $currency);
        $code = $currencyDefined['code'];
        $amount = $this->safe_number($item, 'amount');
        $side = $this->safe_string($item, 'token_side');
        $direction = ($side === 'DEPOSIT') ? 'in' : 'out';
        $timestamp = $this->safe_timestamp($item, 'created_time');
        $fee = $this->parse_token_and_fee_temp($item, 'fee_token', 'fee_amount');
        return array(
            'id' => $this->safe_string($item, 'id'),
            'currency' => $code,
            'account' => $this->safe_string($item, 'account'),
            'referenceAccount' => null,
            'referenceId' => $this->safe_string($item, 'tx_id'),
            'status' => $this->parse_transaction_status($this->safe_string($item, 'status')),
            'amount' => $amount,
            'before' => null,
            'after' => null,
            'fee' => $fee,
            'direction' => $direction,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'type' => $this->parse_ledger_entry_type($this->safe_string($item, 'type')),
            'info' => $item,
        );
    }

    public function parse_ledger_entry_type($type) {
        $types = array(
            'BALANCE' => 'transaction', // Funds moved in/out wallet
            'COLLATERAL' => 'transfer', // Funds moved between portfolios
        );
        return $this->safe_string($types, $type, $type);
    }

    public function get_currency_from_chaincode($networkizedCode, $currency) {
        if ($currency !== null) {
            return $currency;
        } else {
            $parts = explode('_', $networkizedCode);
            $partsLength = count($parts);
            $firstPart = $this->safe_string($parts, 0);
            $currencyId = $this->safe_string($parts, 1, $firstPart);
            if ($partsLength > 2) {
                $currencyId .= '_' . $this->safe_string($parts, 2);
            }
            $currency = $this->safe_currency($currencyId);
        }
        return $currency;
    }

    public function fetch_deposits(?string $code = null, ?int $since = null, ?int $limit = null, $params = array ()): array {
        /**
         * fetch all deposits made to an account
         * @param {string} $code unified currency $code
         * @param {int} [$since] the earliest time in ms to fetch deposits for
         * @param {int} [$limit] the maximum number of deposits structures to retrieve
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @return {array[]} a list of ~@link https://docs.ccxt.com/#/?id=transaction-structure transaction structures~
         */
        $request = array(
            'token_side' => 'DEPOSIT',
        );
        return $this->fetch_deposits_withdrawals($code, $since, $limit, array_merge($request, $params));
    }

    public function fetch_withdrawals(?string $code = null, ?int $since = null, ?int $limit = null, $params = array ()): array {
        /**
         * fetch all withdrawals made from an account
         * @param {string} $code unified currency $code
         * @param {int} [$since] the earliest time in ms to fetch withdrawals for
         * @param {int} [$limit] the maximum number of withdrawals structures to retrieve
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @return {array[]} a list of ~@link https://docs.ccxt.com/#/?id=transaction-structure transaction structures~
         */
        $request = array(
            'token_side' => 'WITHDRAW',
        );
        return $this->fetch_deposits_withdrawals($code, $since, $limit, array_merge($request, $params));
    }

    public function fetch_deposits_withdrawals(?string $code = null, ?int $since = null, ?int $limit = null, $params = array ()): array {
        /**
         * fetch history of deposits and withdrawals
         * @param {string} [$code] unified $currency $code for the $currency of the deposit/withdrawals, default is null
         * @param {int} [$since] timestamp in ms of the earliest deposit/withdrawal, default is null
         * @param {int} [$limit] max number of deposit/withdrawals to return, default is null
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @return {array} a list of ~@link https://docs.ccxt.com/#/?id=transaction-structure transaction structure~
         */
        $request = array(
            'type' => 'BALANCE',
        );
        list($currency, $rows) = $this->get_asset_history_rows($code, $since, $limit, array_merge($request, $params));
        //
        //     {
        //         "rows":array(),
        //         "meta":array(
        //             "total":0,
        //             "records_per_page":25,
        //             "current_page":1
        //         ),
        //         "success":true
        //     }
        //
        return $this->parse_transactions($rows, $currency, $since, $limit, $params);
    }

    public function parse_transaction($transaction, ?array $currency = null): array {
        // example in fetchLedger
        $networkizedCode = $this->safe_string($transaction, 'token');
        $currencyDefined = $this->get_currency_from_chaincode($networkizedCode, $currency);
        $code = $currencyDefined['code'];
        $movementDirection = $this->safe_string_lower($transaction, 'token_side');
        if ($movementDirection === 'withdraw') {
            $movementDirection = 'withdrawal';
        }
        $fee = $this->parse_token_and_fee_temp($transaction, 'fee_token', 'fee_amount');
        $addressTo = $this->safe_string($transaction, 'target_address');
        $addressFrom = $this->safe_string($transaction, 'source_address');
        $timestamp = $this->safe_timestamp($transaction, 'created_time');
        return array(
            'info' => $transaction,
            'id' => $this->safe_string_2($transaction, 'id', 'withdraw_id'),
            'txid' => $this->safe_string($transaction, 'tx_id'),
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'address' => null,
            'addressFrom' => $addressFrom,
            'addressTo' => $addressTo,
            'tag' => $this->safe_string($transaction, 'extra'),
            'tagFrom' => null,
            'tagTo' => null,
            'type' => $movementDirection,
            'amount' => $this->safe_number($transaction, 'amount'),
            'currency' => $code,
            'status' => $this->parse_transaction_status($this->safe_string($transaction, 'status')),
            'updated' => $this->safe_timestamp($transaction, 'updated_time'),
            'comment' => null,
            'internal' => null,
            'fee' => $fee,
            'network' => null,
        );
    }

    public function parse_transaction_status($status) {
        $statuses = array(
            'NEW' => 'pending',
            'CONFIRMING' => 'pending',
            'PROCESSING' => 'pending',
            'COMPLETED' => 'ok',
            'CANCELED' => 'canceled',
        );
        return $this->safe_string($statuses, $status, $status);
    }

    public function transfer(string $code, float $amount, string $fromAccount, string $toAccount, $params = array ()): array {
        /**
         * @see https://docs.woo.org/#get-$transfer-history
         * $transfer $currency internally between wallets on the same account
         * @param {string} $code unified $currency $code
         * @param {float} $amount amount to $transfer
         * @param {string} $fromAccount account to $transfer from
         * @param {string} $toAccount account to $transfer to
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @return {array} a ~@link https://docs.ccxt.com/#/?id=$transfer-structure $transfer structure~
         */
        $this->load_markets();
        $currency = $this->currency($code);
        $request = array(
            'token' => $currency['id'],
            'amount' => $this->parse_to_numeric($amount),
            'from_application_id' => $fromAccount,
            'to_application_id' => $toAccount,
        );
        $response = $this->v1PrivatePostAssetMainSubTransfer (array_merge($request, $params));
        //
        //     {
        //         "success" => true,
        //         "id" => 200
        //     }
        //
        $transfer = $this->parse_transfer($response, $currency);
        $transferOptions = $this->safe_dict($this->options, 'transfer', array());
        $fillResponseFromRequest = $this->safe_bool($transferOptions, 'fillResponseFromRequest', true);
        if ($fillResponseFromRequest) {
            $transfer['amount'] = $amount;
            $transfer['fromAccount'] = $fromAccount;
            $transfer['toAccount'] = $toAccount;
        }
        return $transfer;
    }

    public function fetch_transfers(?string $code = null, ?int $since = null, ?int $limit = null, $params = array ()) {
        /**
         * fetch a history of internal transfers made on an account
         * @see https://docs.woo.org/#get-transfer-history
         * @param {string} $code unified currency $code of the currency transferred
         * @param {int} [$since] the earliest time in ms to fetch transfers for
         * @param {int} [$limit] the maximum number of  transfers structures to retrieve
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @param {int} [$params->until] the latest time in ms to fetch entries for
         * @return {array[]} a list of ~@link https://docs.ccxt.com/#/?id=transfer-structure transfer structures~
         */
        $request = array();
        if ($limit !== null) {
            $request['size'] = $limit;
        }
        if ($since !== null) {
            $request['start_t'] = $since;
        }
        $until = $this->safe_integer_2($params, 'until', 'till'); // unified in milliseconds
        $params = $this->omit($params, array( 'until', 'till' ));
        if ($until !== null) {
            $request['end_t'] = $until;
        }
        $response = $this->v1PrivateGetAssetMainSubTransferHistory (array_merge($request, $params));
        //
        //     {
        //         "rows" => array(
        //             {
        //                 "id" => 46704,
        //                 "token" => "USDT",
        //                 "amount" => 30000.00000000,
        //                 "status" => "COMPLETED",
        //                 "from_application_id" => "0f1bd3cd-dba2-4563-b8bb-0adb1bfb83a3",
        //                 "to_application_id" => "c01e6940-a735-4022-9b6c-9d3971cdfdfa",
        //                 "from_user" => "LeverageLow",
        //                 "to_user" => "dev",
        //                 "created_time" => "1709022325.427",
        //                 "updated_time" => "1709022325.542"
        //             }
        //         ),
        //         "meta" => array(
        //             "total" => 50,
        //             "records_per_page" => 25,
        //             "current_page" => 1
        //         ),
        //         "success" => true
        //     }
        //
        $data = $this->safe_list($response, 'rows', array());
        return $this->parse_transfers($data, null, $since, $limit, $params);
    }

    public function parse_transfer($transfer, ?array $currency = null) {
        //
        //    fetchTransfers
        //     {
        //         "id" => 46704,
        //         "token" => "USDT",
        //         "amount" => 30000.00000000,
        //         "status" => "COMPLETED",
        //         "from_application_id" => "0f1bd3cd-dba2-4563-b8bb-0adb1bfb83a3",
        //         "to_application_id" => "c01e6940-a735-4022-9b6c-9d3971cdfdfa",
        //         "from_user" => "LeverageLow",
        //         "to_user" => "dev",
        //         "created_time" => "1709022325.427",
        //         "updated_time" => "1709022325.542"
        //     }
        //
        //    $transfer
        //        {
        //            "success" => true,
        //            "id" => 200
        //        }
        //
        $networkizedCode = $this->safe_string($transfer, 'token');
        $currencyDefined = $this->get_currency_from_chaincode($networkizedCode, $currency);
        $code = $currencyDefined['code'];
        $timestamp = $this->safe_timestamp($transfer, 'created_time');
        $success = $this->safe_bool($transfer, 'success');
        $status = null;
        if ($success !== null) {
            $status = $success ? 'ok' : 'failed';
        }
        return array(
            'id' => $this->safe_string($transfer, 'id'),
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'currency' => $code,
            'amount' => $this->safe_number($transfer, 'amount'),
            'fromAccount' => $this->safe_string($transfer, 'from_application_id'),
            'toAccount' => $this->safe_string($transfer, 'to_application_id'),
            'status' => $this->parse_transfer_status($this->safe_string($transfer, 'status', $status)),
            'info' => $transfer,
        );
    }

    public function parse_transfer_status($status) {
        $statuses = array(
            'NEW' => 'pending',
            'CONFIRMING' => 'pending',
            'PROCESSING' => 'pending',
            'COMPLETED' => 'ok',
            'CANCELED' => 'canceled',
        );
        return $this->safe_string($statuses, $status, $status);
    }

    public function withdraw(string $code, float $amount, $address, $tag = null, $params = array ()) {
        /**
         * make a withdrawal
         * @param {string} $code unified $currency $code
         * @param {float} $amount the $amount to withdraw
         * @param {string} $address the $address to withdraw to
         * @param {string} $tag
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @return {array} a ~@link https://docs.ccxt.com/#/?id=transaction-structure transaction structure~
         */
        list($tag, $params) = $this->handle_withdraw_tag_and_params($tag, $params);
        $this->load_markets();
        $this->check_address($address);
        $currency = $this->currency($code);
        $request = array(
            'amount' => $amount,
            'address' => $address,
        );
        if ($tag !== null) {
            $request['extra'] = $tag;
        }
        $networks = $this->safe_dict($this->options, 'networks', array());
        $currencyNetworks = $this->safe_dict($currency, 'networks', array());
        $network = $this->safe_string_upper($params, 'network');
        $networkId = $this->safe_string($networks, $network, $network);
        $coinNetwork = $this->safe_dict($currencyNetworks, $networkId, array());
        $coinNetworkId = $this->safe_string($coinNetwork, 'id');
        if ($coinNetworkId === null) {
            throw new BadRequest($this->id . ' withdraw() require $network parameter');
        }
        $request['token'] = $coinNetworkId;
        $response = $this->v1PrivatePostAssetWithdraw (array_merge($request, $params));
        //
        //     {
        //         "success" => true,
        //         "withdraw_id" => "20200119145703654"
        //     }
        //
        return $this->parse_transaction($response, $currency);
    }

    public function repay_margin(string $code, $amount, ?string $symbol = null, $params = array ()) {
        /**
         * repay borrowed margin and interest
         * @see https://docs.woo.org/#repay-interest
         * @param {string} $code unified $currency $code of the $currency to repay
         * @param {float} $amount the $amount to repay
         * @param {string} $symbol not used by woo.repayMargin ()
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @return {array} a ~@link https://docs.ccxt.com/#/?id=margin-loan-structure margin loan structure~
         */
        $this->load_markets();
        $market = null;
        if ($symbol !== null) {
            $market = $this->market($symbol);
            $symbol = $market['symbol'];
        }
        $currency = $this->currency($code);
        $request = array(
            'token' => $currency['id'], // interest token that you want to repay
            'amount' => $this->currency_to_precision($code, $amount),
        );
        $response = $this->v1PrivatePostInterestRepay (array_merge($request, $params));
        //
        //     {
        //         "success" => true,
        //     }
        //
        $transaction = $this->parse_margin_loan($response, $currency);
        return array_merge($transaction, array(
            'amount' => $amount,
            'symbol' => $symbol,
        ));
    }

    public function parse_margin_loan($info, ?array $currency = null) {
        //
        //     {
        //         "success" => true,
        //     }
        //
        return array(
            'id' => null,
            'currency' => $this->safe_currency_code(null, $currency),
            'amount' => null,
            'symbol' => null,
            'timestamp' => null,
            'datetime' => null,
            'info' => $info,
        );
    }

    public function nonce() {
        return $this->milliseconds();
    }

    public function sign($path, $section = 'public', $method = 'GET', $params = array (), $headers = null, $body = null) {
        $version = $section[0];
        $access = $section[1];
        $pathWithParams = $this->implode_params($path, $params);
        $url = $this->implode_hostname($this->urls['api'][$access]);
        $url .= '/' . $version . '/';
        $params = $this->omit($params, $this->extract_params($path));
        $params = $this->keysort($params);
        if ($access === 'public') {
            $url .= $access . '/' . $pathWithParams;
            if ($params) {
                $url .= '?' . $this->urlencode($params);
            }
        } else {
            $this->check_required_credentials();
            if ($method === 'POST' && ($path === 'algo/order' || $path === 'order')) {
                $isSandboxMode = $this->safe_bool($this->options, 'sandboxMode', false);
                if (!$isSandboxMode) {
                    $applicationId = 'bc830de7-50f3-460b-9ee0-f430f83f9dad';
                    $brokerId = $this->safe_string($this->options, 'brokerId', $applicationId);
                    $isStop = mb_strpos($path, 'algo') > -1;
                    if ($isStop) {
                        $params['brokerId'] = $brokerId;
                    } else {
                        $params['broker_id'] = $brokerId;
                    }
                }
                $params = $this->keysort($params);
            }
            $auth = '';
            $ts = (string) $this->nonce();
            $url .= $pathWithParams;
            $headers = array(
                'x-api-key' => $this->apiKey,
                'x-api-timestamp' => $ts,
            );
            if ($version === 'v3') {
                $auth = $ts . $method . '/' . $version . '/' . $pathWithParams;
                if ($method === 'POST' || $method === 'PUT' || $method === 'DELETE') {
                    $body = $this->json($params);
                    $auth .= $body;
                } else {
                    if ($params) {
                        $query = $this->urlencode($params);
                        $url .= '?' . $query;
                        $auth .= '?' . $query;
                    }
                }
                $headers['content-type'] = 'application/json';
            } else {
                $auth = $this->urlencode($params);
                if ($method === 'POST' || $method === 'PUT' || $method === 'DELETE') {
                    $body = $auth;
                } else {
                    if ($params) {
                        $url .= '?' . $auth;
                    }
                }
                $auth .= '|' . $ts;
                $headers['content-type'] = 'application/x-www-form-urlencoded';
            }
            $headers['x-api-signature'] = $this->hmac($this->encode($auth), $this->encode($this->secret), 'sha256');
        }
        return array( 'url' => $url, 'method' => $method, 'body' => $body, 'headers' => $headers );
    }

    public function handle_errors($httpCode, $reason, $url, $method, $headers, $body, $response, $requestHeaders, $requestBody) {
        if (!$response) {
            return null; // fallback to default error handler
        }
        //
        //     400 Bad Request array("success":false,"code":-1012,"message":"Amount is required for buy market orders when margin disabled.")
        //                     array("code":"-1011","message":"The system is under maintenance.","success":false)
        //
        $success = $this->safe_bool($response, 'success');
        $errorCode = $this->safe_string($response, 'code');
        if (!$success) {
            $feedback = $this->id . ' ' . $this->json($response);
            $this->throw_broadly_matched_exception($this->exceptions['broad'], $body, $feedback);
            $this->throw_exactly_matched_exception($this->exceptions['exact'], $errorCode, $feedback);
        }
        return null;
    }

    public function parse_income($income, ?array $market = null) {
        //
        //     {
        //         "id":666666,
        //         "symbol":"PERP_BTC_USDT",
        //         "funding_rate":0.00001198,
        //         "mark_price":28941.04000000,
        //         "funding_fee":0.00069343,
        //         "payment_type":"Pay",
        //         "status":"COMPLETED",
        //         "created_time":"1653616000.666",
        //         "updated_time":"1653616000.605"
        //     }
        //
        $marketId = $this->safe_string($income, 'symbol');
        $symbol = $this->safe_symbol($marketId, $market);
        $amount = $this->safe_number($income, 'funding_fee');
        $code = $this->safe_currency_code('USD');
        $id = $this->safe_string($income, 'id');
        $timestamp = $this->safe_timestamp($income, 'updated_time');
        $rate = $this->safe_number($income, 'funding_rate');
        return array(
            'info' => $income,
            'symbol' => $symbol,
            'code' => $code,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'id' => $id,
            'amount' => $amount,
            'rate' => $rate,
        );
    }

    public function fetch_funding_history(?string $symbol = null, ?int $since = null, ?int $limit = null, $params = array ()) {
        $this->load_markets();
        $request = array();
        $market = null;
        if ($symbol !== null) {
            $market = $this->market($symbol);
            $request['symbol'] = $market['id'];
        }
        if ($since !== null) {
            $request['start_t'] = $since;
        }
        $response = $this->v1PrivateGetFundingFeeHistory (array_merge($request, $params));
        //
        //     {
        //         "rows":array(
        //             {
        //                 "id":666666,
        //                 "symbol":"PERP_BTC_USDT",
        //                 "funding_rate":0.00001198,
        //                 "mark_price":28941.04000000,
        //                 "funding_fee":0.00069343,
        //                 "payment_type":"Pay",
        //                 "status":"COMPLETED",
        //                 "created_time":"1653616000.666",
        //                 "updated_time":"1653616000.605"
        //             }
        //         ),
        //         "meta":array(
        //             "total":235,
        //             "records_per_page":25,
        //             "current_page":1
        //         ),
        //         "success":true
        //     }
        //
        $result = $this->safe_list($response, 'rows', array());
        return $this->parse_incomes($result, $market, $since, $limit);
    }

    public function parse_funding_rate($fundingRate, ?array $market = null) {
        //
        //         {
        //             "symbol":"PERP_AAVE_USDT",
        //             "est_funding_rate":-0.00003447,
        //             "est_funding_rate_timestamp":1653633959001,
        //             "last_funding_rate":-0.00002094,
        //             "last_funding_rate_timestamp":1653631200000,
        //             "next_funding_time":1653634800000
        //         }
        //
        //
        $symbol = $this->safe_string($fundingRate, 'symbol');
        $market = $this->market($symbol);
        $nextFundingTimestamp = $this->safe_integer($fundingRate, 'next_funding_time');
        $estFundingRateTimestamp = $this->safe_integer($fundingRate, 'est_funding_rate_timestamp');
        $lastFundingRateTimestamp = $this->safe_integer($fundingRate, 'last_funding_rate_timestamp');
        return array(
            'info' => $fundingRate,
            'symbol' => $market['symbol'],
            'markPrice' => null,
            'indexPrice' => null,
            'interestRate' => $this->parse_number('0'),
            'estimatedSettlePrice' => null,
            'timestamp' => $estFundingRateTimestamp,
            'datetime' => $this->iso8601($estFundingRateTimestamp),
            'fundingRate' => $this->safe_number($fundingRate, 'est_funding_rate'),
            'fundingTimestamp' => $nextFundingTimestamp,
            'fundingDatetime' => $this->iso8601($nextFundingTimestamp),
            'nextFundingRate' => null,
            'nextFundingTimestamp' => null,
            'nextFundingDatetime' => null,
            'previousFundingRate' => $this->safe_number($fundingRate, 'last_funding_rate'),
            'previousFundingTimestamp' => $lastFundingRateTimestamp,
            'previousFundingDatetime' => $this->iso8601($lastFundingRateTimestamp),
        );
    }

    public function fetch_funding_rate(string $symbol, $params = array ()) {
        $this->load_markets();
        $market = $this->market($symbol);
        $request = array(
            'symbol' => $market['id'],
        );
        $response = $this->v1PublicGetFundingRateSymbol (array_merge($request, $params));
        //
        //     {
        //         "success":true,
        //         "timestamp":1653640572711,
        //         "symbol":"PERP_BTC_USDT",
        //         "est_funding_rate":0.00000738,
        //         "est_funding_rate_timestamp":1653640559003,
        //         "last_funding_rate":0.00000629,
        //         "last_funding_rate_timestamp":1653638400000,
        //         "next_funding_time":1653642000000
        //     }
        //
        return $this->parse_funding_rate($response, $market);
    }

    public function fetch_funding_rates(?array $symbols = null, $params = array ()) {
        $this->load_markets();
        $symbols = $this->market_symbols($symbols);
        $response = $this->v1PublicGetFundingRates ($params);
        //
        //     {
        //         "success":true,
        //         "rows":array(
        //             {
        //                 "symbol":"PERP_AAVE_USDT",
        //                 "est_funding_rate":-0.00003447,
        //                 "est_funding_rate_timestamp":1653633959001,
        //                 "last_funding_rate":-0.00002094,
        //                 "last_funding_rate_timestamp":1653631200000,
        //                 "next_funding_time":1653634800000
        //             }
        //         ),
        //         "timestamp":1653633985646
        //     }
        //
        $rows = $this->safe_list($response, 'rows', array());
        $result = $this->parse_funding_rates($rows);
        return $this->filter_by_array($result, 'symbol', $symbols);
    }

    public function fetch_funding_rate_history(?string $symbol = null, ?int $since = null, ?int $limit = null, $params = array ()) {
        /**
         * fetches historical funding rate prices
         * @see https://docs.woo.org/#get-funding-rate-history-for-one-$market-public
         * @param {string} $symbol unified $symbol of the $market to fetch the funding rate history for
         * @param {int} [$since] $timestamp in ms of the earliest funding rate to fetch
         * @param {int} [$limit] the maximum amount of ~@link https://docs.ccxt.com/#/?id=funding-rate-history-structure funding rate structures~ to fetch
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @param {int} [$params->until] $timestamp in ms of the latest funding rate
         * @param {boolean} [$params->paginate] default false, when true will automatically $paginate by calling this endpoint multiple times. See in the docs all the [availble parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-$params)
         * @return {array[]} a list of ~@link https://docs.ccxt.com/#/?id=funding-rate-history-structure funding rate structures~
         */
        $this->load_markets();
        $paginate = false;
        list($paginate, $params) = $this->handle_option_and_params($params, 'fetchFundingRateHistory', 'paginate');
        if ($paginate) {
            return $this->fetch_paginated_call_incremental('fetchFundingRateHistory', $symbol, $since, $limit, $params, 'page', 25);
        }
        $request = array();
        if ($symbol !== null) {
            $market = $this->market($symbol);
            $symbol = $market['symbol'];
            $request['symbol'] = $market['id'];
        }
        if ($since !== null) {
            $request['start_t'] = $this->parse_to_int($since / 1000);
        }
        list($request, $params) = $this->handle_until_option('end_t', $request, $params, 0.001);
        $response = $this->v1PublicGetFundingRateHistory (array_merge($request, $params));
        //
        //     {
        //         "success":true,
        //         "meta":array(
        //             "total":2464,
        //             "records_per_page":25,
        //             "current_page":1
        //         ),
        //         "rows":array(
        //             {
        //                 "symbol":"PERP_BTC_USDT",
        //                 "funding_rate":0.00000629,
        //                 "funding_rate_timestamp":1653638400000,
        //                 "next_funding_time":1653642000000
        //             }
        //         ),
        //         "timestamp":1653640814885
        //     }
        //
        $result = $this->safe_list($response, 'rows');
        $rates = array();
        for ($i = 0; $i < count($result); $i++) {
            $entry = $result[$i];
            $marketId = $this->safe_string($entry, 'symbol');
            $timestamp = $this->safe_integer($entry, 'funding_rate_timestamp');
            $rates[] = array(
                'info' => $entry,
                'symbol' => $this->safe_symbol($marketId),
                'fundingRate' => $this->safe_number($entry, 'funding_rate'),
                'timestamp' => $timestamp,
                'datetime' => $this->iso8601($timestamp),
            );
        }
        $sorted = $this->sort_by($rates, 'timestamp');
        return $this->filter_by_symbol_since_limit($sorted, $symbol, $since, $limit);
    }

    public function set_position_mode(bool $hedged, ?string $symbol = null, $params = array ()) {
        /**
         * set $hedged to true or false for a market
         * @see https://docs.woo.org/#update-position-mode
         * @param {bool} $hedged set to true to use HEDGE_MODE, false for ONE_WAY
         * @param {string} $symbol not used by woo setPositionMode
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @return {array} $response from the exchange
         */
        $hedgeMode = null;
        if ($hedged) {
            $hedgeMode = 'HEDGE_MODE';
        } else {
            $hedgeMode = 'ONE_WAY';
        }
        $request = array(
            'position_mode' => $hedgeMode,
        );
        $response = $this->v1PrivatePostClientPositionMode (array_merge($request, $params));
        //
        //     {
        //         "success" => true,
        //         "data" => array(),
        //         "timestamp" => "1709195608551"
        //     }
        //
        return $response;
    }

    public function fetch_leverage(string $symbol, $params = array ()): array {
        /**
         * fetch the set leverage for a $market
         * @see https://docs.woo.org/#get-account-information-new
         * @param {string} $symbol unified $market $symbol
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @return {array} a ~@link https://docs.ccxt.com/#/?id=leverage-structure leverage structure~
         */
        $this->load_markets();
        $market = $this->market($symbol);
        $response = $this->v3PrivateGetAccountinfo ($params);
        //
        //     {
        //         "success" => true,
        //         "data" => array(
        //             "applicationId" => "dsa",
        //             "account" => "dsa",
        //             "alias" => "haha",
        //             "accountMode" => "MARGIN",
        //             "leverage" => 1,
        //             "takerFeeRate" => 1,
        //             "makerFeeRate" => 1,
        //             "interestRate" => 1,
        //             "futuresTakerFeeRate" => 1,
        //             "futuresMakerFeeRate" => 1,
        //             "otpauth" => true,
        //             "marginRatio" => 1,
        //             "openMarginRatio" => 1,
        //             "initialMarginRatio" => 1,
        //             "maintenanceMarginRatio" => 1,
        //             "totalCollateral" => 1,
        //             "freeCollateral" => 1,
        //             "totalAccountValue" => 1,
        //             "totalVaultValue" => 1,
        //             "totalStakingValue" => 1
        //         ),
        //         "timestamp" => 1673323685109
        //     }
        //
        $data = $this->safe_dict($response, 'data', array());
        return $this->parse_leverage($data, $market);
    }

    public function parse_leverage($leverage, $market = null): array {
        $leverageValue = $this->safe_integer($leverage, 'leverage');
        return array(
            'info' => $leverage,
            'symbol' => $market['symbol'],
            'marginMode' => null,
            'longLeverage' => $leverageValue,
            'shortLeverage' => $leverageValue,
        );
    }

    public function set_leverage(?int $leverage, ?string $symbol = null, $params = array ()) {
        $this->load_markets();
        if (($leverage < 1) || ($leverage > 20)) {
            throw new BadRequest($this->id . ' $leverage should be between 1 and 20');
        }
        $request = array(
            'leverage' => $leverage,
        );
        return $this->v1PrivatePostClientLeverage (array_merge($request, $params));
    }

    public function fetch_position(?string $symbol = null, $params = array ()) {
        $this->load_markets();
        $market = $this->market($symbol);
        $request = array(
            'symbol' => $market['id'],
        );
        $response = $this->v1PrivateGetPositionSymbol (array_merge($request, $params));
        //
        //     {
        //         "symbol":"PERP_ETC_USDT",
        //         "holding":0.0,
        //         "pnl_24_h":0,
        //         "settle_price":0.0,
        //         "average_open_price":0,
        //         "success":true,
        //         "mark_price":22.6955,
        //         "pending_short_qty":0.0,
        //         "pending_long_qty":0.0,
        //         "fee_24_h":0,
        //         "timestamp":"1652231044.920"
        //     }
        //
        return $this->parse_position($response, $market);
    }

    public function fetch_positions(?array $symbols = null, $params = array ()) {
        $this->load_markets();
        $response = $this->v3PrivateGetPositions ($params);
        //
        //     {
        //         "success" => true,
        //         "data" => {
        //             "positions" => array(
        //                 array(
        //                     "symbol" => "0_symbol",
        //                     "holding" => 1,
        //                     "pendingLongQty" => 0,
        //                     "pendingShortQty" => 1,
        //                     "settlePrice" => 1,
        //                     "averageOpenPrice" => 1,
        //                     "pnl24H" => 1,
        //                     "fee24H" => 1,
        //                     "markPrice" => 1,
        //                     "estLiqPrice" => 1,
        //                     "timestamp" => 12321321
        //                 }
        //             )
        //         ),
        //         "timestamp" => 1673323880342
        //     }
        //
        $result = $this->safe_dict($response, 'data', array());
        $positions = $this->safe_list($result, 'positions', array());
        return $this->parse_positions($positions, $symbols);
    }

    public function parse_position($position, ?array $market = null) {
        //
        //     {
        //         "symbol" => "0_symbol",
        //         "holding" => 1,
        //         "pendingLongQty" => 0,
        //         "pendingShortQty" => 1,
        //         "settlePrice" => 1,
        //         "averageOpenPrice" => 1,
        //         "pnl24H" => 1,
        //         "fee24H" => 1,
        //         "markPrice" => 1,
        //         "estLiqPrice" => 1,
        //         "timestamp" => 12321321
        //     }
        //
        $contract = $this->safe_string($position, 'symbol');
        $market = $this->safe_market($contract, $market);
        $size = $this->safe_string($position, 'holding');
        $side = null;
        if (Precise::string_gt($size, '0')) {
            $side = 'long';
        } else {
            $side = 'short';
        }
        $contractSize = $this->safe_string($market, 'contractSize');
        $markPrice = $this->safe_string($position, 'markPrice');
        $timestamp = $this->safe_timestamp($position, 'timestamp');
        $entryPrice = $this->safe_string($position, 'averageOpenPrice');
        $priceDifference = Precise::string_sub($markPrice, $entryPrice);
        $unrealisedPnl = Precise::string_mul($priceDifference, $size);
        $size = Precise::string_abs($size);
        $notional = Precise::string_mul($size, $markPrice);
        return $this->safe_position(array(
            'info' => $position,
            'id' => null,
            'symbol' => $this->safe_string($market, 'symbol'),
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'lastUpdateTimestamp' => null,
            'initialMargin' => null,
            'initialMarginPercentage' => null,
            'maintenanceMargin' => null,
            'maintenanceMarginPercentage' => null,
            'entryPrice' => $this->parse_number($entryPrice),
            'notional' => $this->parse_number($notional),
            'leverage' => null,
            'unrealizedPnl' => $this->parse_number($unrealisedPnl),
            'contracts' => $this->parse_number($size),
            'contractSize' => $this->parse_number($contractSize),
            'marginRatio' => null,
            'liquidationPrice' => $this->safe_number($position, 'estLiqPrice'),
            'markPrice' => $this->parse_number($markPrice),
            'lastPrice' => null,
            'collateral' => null,
            'marginMode' => 'cross',
            'marginType' => null,
            'side' => $side,
            'percentage' => null,
            'hedged' => null,
            'stopLossPrice' => null,
            'takeProfitPrice' => null,
        ));
    }

    public function fetch_convert_quote(string $fromCode, string $toCode, ?float $amount = null, $params = array ()): Conversion {
        /**
         * fetch a quote for converting from one currency to another
         * @see https://docs.woo.org/#get-quote-rfq
         * @param {string} $fromCode the currency that you want to sell and convert from
         * @param {string} $toCode the currency that you want to buy and convert into
         * @param {float} [$amount] how much you want to trade in units of the from currency
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @return {array} a ~@link https://docs.ccxt.com/#/?id=conversion-structure conversion structure~
         */
        $this->load_markets();
        $request = array(
            'sellToken' => strtoupper($fromCode),
            'buyToken' => strtoupper($toCode),
            'sellQuantity' => $this->number_to_string($amount),
        );
        $response = $this->v3PrivateGetConvertRfq (array_merge($request, $params));
        //
        //     {
        //         "success" => true,
        //         "data" => {
        //             "quoteId" => 123123123,
        //             "counterPartyId" => "",
        //             "sellToken" => "ETH",
        //             "sellQuantity" => "0.0445",
        //             "buyToken" => "USDT",
        //             "buyQuantity" => "33.45",
        //             "buyPrice" => "6.77",
        //             "expireTimestamp" => 1659084466000,
        //             "message" => 1659084466000
        //         }
        //     }
        //
        $data = $this->safe_dict($response, 'data', array());
        $fromCurrencyId = $this->safe_string($data, 'sellToken', $fromCode);
        $fromCurrency = $this->currency($fromCurrencyId);
        $toCurrencyId = $this->safe_string($data, 'buyToken', $toCode);
        $toCurrency = $this->currency($toCurrencyId);
        return $this->parse_conversion($data, $fromCurrency, $toCurrency);
    }

    public function create_convert_trade(string $id, string $fromCode, string $toCode, ?float $amount = null, $params = array ()): Conversion {
        /**
         * convert from one currency to another
         * @see https://docs.woo.org/#send-quote-rft
         * @param {string} $id the $id of the trade that you want to make
         * @param {string} $fromCode the currency that you want to sell and convert from
         * @param {string} $toCode the currency that you want to buy and convert into
         * @param {float} [$amount] how much you want to trade in units of the from currency
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @return {array} a ~@link https://docs.ccxt.com/#/?$id=conversion-structure conversion structure~
         */
        $this->load_markets();
        $request = array(
            'quoteId' => $id,
        );
        $response = $this->v3PrivatePostConvertRft (array_merge($request, $params));
        //
        //     {
        //         "success" => true,
        //         "data" => {
        //             "quoteId" => 123123123,
        //             "counterPartyId" => "",
        //             "rftAccepted" => 1 // 1 -> success; 2 -> processing; 3 -> fail
        //         }
        //     }
        //
        $data = $this->safe_dict($response, 'data', array());
        return $this->parse_conversion($data);
    }

    public function fetch_convert_trade(string $id, ?string $code = null, $params = array ()): Conversion {
        /**
         * fetch the $data for a conversion trade
         * @see https://docs.woo.org/#get-quote-trade
         * @param {string} $id the $id of the trade that you want to fetch
         * @param {string} [$code] the unified currency $code of the conversion trade
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @return {array} a ~@link https://docs.ccxt.com/#/?$id=conversion-structure conversion structure~
         */
        $this->load_markets();
        $request = array(
            'quoteId' => $id,
        );
        $response = $this->v3PrivateGetConvertTrade (array_merge($request, $params));
        //
        //     {
        //         "success" => true,
        //         "data" => {
        //             "quoteId" => 12,
        //             "buyAsset" => "",
        //             "sellAsset" => "",
        //             "buyAmount" => 12.11,
        //             "sellAmount" => 12.11,
        //             "tradeStatus" => 12,
        //             "createdTime" => ""
        //         }
        //     }
        //
        $data = $this->safe_dict($response, 'data', array());
        $fromCurrencyId = $this->safe_string($data, 'sellAsset');
        $toCurrencyId = $this->safe_string($data, 'buyAsset');
        $fromCurrency = null;
        $toCurrency = null;
        if ($fromCurrencyId !== null) {
            $fromCurrency = $this->currency($fromCurrencyId);
        }
        if ($toCurrencyId !== null) {
            $toCurrency = $this->currency($toCurrencyId);
        }
        return $this->parse_conversion($data, $fromCurrency, $toCurrency);
    }

    public function fetch_convert_trade_history(?string $code = null, ?int $since = null, ?int $limit = null, $params = array ()): array {
        /**
         * fetch the users history of conversion trades
         * @see https://docs.woo.org/#get-quote-trades
         * @param {string} [$code] the unified currency $code
         * @param {int} [$since] the earliest time in ms to fetch conversions for
         * @param {int} [$limit] the maximum number of conversion structures to retrieve
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @param {int} [$params->until] timestamp in ms of the latest conversion to fetch
         * @return {array[]} a list of ~@link https://docs.ccxt.com/#/?id=conversion-structure conversion structures~
         */
        $this->load_markets();
        $request = array();
        list($request, $params) = $this->handle_until_option('endTime', $request, $params);
        if ($since !== null) {
            $request['startTime'] = $since;
        }
        if ($limit !== null) {
            $request['size'] = $limit;
        }
        $response = $this->v3PrivateGetConvertTrades (array_merge($request, $params));
        //
        //     {
        //         "success" => true,
        //         "data" => {
        //             "count" => 12,
        //             "tradeVos":array(
        //                 {
        //                     "quoteId" => 12,
        //                     "buyAsset" => "",
        //                     "sellAsset" => "",
        //                     "buyAmount" => 12.11,
        //                     "sellAmount" => 12.11,
        //                     "tradeStatus" => 12,
        //                     "createdTime" => ""
        //                 }
        //                 ...
        //             )
        //         }
        //     }
        //
        $data = $this->safe_dict($response, 'data', array());
        $rows = $this->safe_list($data, 'tradeVos', array());
        return $this->parse_conversions($rows, 'sellAsset', 'buyAsset', $since, $limit);
    }

    public function parse_conversion($conversion, ?array $fromCurrency = null, ?array $toCurrency = null): Conversion {
        //
        // fetchConvertQuote
        //
        //     {
        //         "quoteId" => 123123123,
        //         "counterPartyId" => "",
        //         "sellToken" => "ETH",
        //         "sellQuantity" => "0.0445",
        //         "buyToken" => "USDT",
        //         "buyQuantity" => "33.45",
        //         "buyPrice" => "6.77",
        //         "expireTimestamp" => 1659084466000,
        //         "message" => 1659084466000
        //     }
        //
        // createConvertTrade
        //
        //     {
        //         "quoteId" => 123123123,
        //         "counterPartyId" => "",
        //         "rftAccepted" => 1 // 1 -> success; 2 -> processing; 3 -> fail
        //     }
        //
        // fetchConvertTrade, fetchConvertTradeHistory
        //
        //     {
        //         "quoteId" => 12,
        //         "buyAsset" => "",
        //         "sellAsset" => "",
        //         "buyAmount" => 12.11,
        //         "sellAmount" => 12.11,
        //         "tradeStatus" => 12,
        //         "createdTime" => ""
        //     }
        //
        $timestamp = $this->safe_integer_2($conversion, 'expireTimestamp', 'createdTime');
        $fromCurr = $this->safe_string_2($conversion, 'sellToken', 'buyAsset');
        $fromCode = $this->safe_currency_code($fromCurr, $fromCurrency);
        $to = $this->safe_string_2($conversion, 'buyToken', 'sellAsset');
        $toCode = $this->safe_currency_code($to, $toCurrency);
        return array(
            'info' => $conversion,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'id' => $this->safe_string($conversion, 'quoteId'),
            'fromCurrency' => $fromCode,
            'fromAmount' => $this->safe_number_2($conversion, 'sellQuantity', 'sellAmount'),
            'toCurrency' => $toCode,
            'toAmount' => $this->safe_number_2($conversion, 'buyQuantity', 'buyAmount'),
            'price' => $this->safe_number($conversion, 'buyPrice'),
            'fee' => null,
        );
    }

    public function fetch_convert_currencies($params = array ()): ?array {
        /**
         * fetches all available currencies that can be converted
         * @see https://docs.woo.org/#get-quote-asset-info
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @return {array} an associative dictionary of currencies
         */
        $this->load_markets();
        $response = $this->v3PrivateGetConvertAssetInfo ($params);
        //
        //     {
        //         "success" => true,
        //         "rows" => array(
        //             array(
        //                 "token" => "BTC",
        //                 "tick" => 0.0001,
        //                 "createdTime" => "1575014248.99", // Unix epoch time in seconds
        //                 "updatedTime" => "1575014248.99"  // Unix epoch time in seconds
        //             ),
        //         )
        //     }
        //
        $result = array();
        $data = $this->safe_list($response, 'rows', array());
        for ($i = 0; $i < count($data); $i++) {
            $entry = $data[$i];
            $id = $this->safe_string($entry, 'token');
            $code = $this->safe_currency_code($id);
            $result[$code] = array(
                'info' => $entry,
                'id' => $id,
                'code' => $code,
                'networks' => null,
                'type' => null,
                'name' => null,
                'active' => null,
                'deposit' => null,
                'withdraw' => null,
                'fee' => null,
                'precision' => $this->safe_number($entry, 'tick'),
                'limits' => array(
                    'amount' => array(
                        'min' => null,
                        'max' => null,
                    ),
                    'withdraw' => array(
                        'min' => null,
                        'max' => null,
                    ),
                    'deposit' => array(
                        'min' => null,
                        'max' => null,
                    ),
                ),
                'created' => $this->safe_timestamp($entry, 'createdTime'),
            );
        }
        return $result;
    }

    public function default_network_code_for_currency($code) {
        $currencyItem = $this->currency($code);
        $networks = $currencyItem['networks'];
        $networkKeys = is_array($networks) ? array_keys($networks) : array();
        for ($i = 0; $i < count($networkKeys); $i++) {
            $network = $networkKeys[$i];
            if ($network === 'ETH') {
                return $network;
            }
        }
        // if it was not returned according to above options, then return the first $network of currency
        return $this->safe_value($networkKeys, 0);
    }

    public function set_sandbox_mode(bool $enable) {
        parent::set_sandbox_mode($enable);
        $this->options['sandboxMode'] = $enable;
    }
}
