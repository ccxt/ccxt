<?php

namespace ccxt;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

use Exception; // a common import
use ccxt\abstract\bitopro as Exchange;

class bitopro extends Exchange {

    public function describe() {
        return $this->deep_extend(parent::describe(), array(
            'id' => 'bitopro',
            'name' => 'BitoPro',
            'countries' => array( 'TW' ), // Taiwan
            'version' => 'v3',
            'rateLimit' => 100,
            'pro' => true,
            'has' => array(
                'CORS' => null,
                'spot' => true,
                'margin' => false,
                'swap' => false,
                'future' => false,
                'option' => false,
                'cancelAllOrders' => true,
                'cancelOrder' => true,
                'cancelOrders' => true,
                'createOrder' => true,
                'editOrder' => false,
                'fetchBalance' => true,
                'fetchBorrowRate' => false,
                'fetchBorrowRateHistories' => false,
                'fetchBorrowRateHistory' => false,
                'fetchBorrowRates' => false,
                'fetchClosedOrders' => true,
                'fetchCurrencies' => true,
                'fetchDepositAddress' => false,
                'fetchDeposits' => true,
                'fetchFundingHistory' => false,
                'fetchFundingRate' => false,
                'fetchFundingRateHistory' => false,
                'fetchFundingRates' => false,
                'fetchIndexOHLCV' => false,
                'fetchMarginMode' => false,
                'fetchMarkets' => true,
                'fetchMarkOHLCV' => false,
                'fetchMyTrades' => true,
                'fetchOHLCV' => true,
                'fetchOpenInterestHistory' => false,
                'fetchOpenOrders' => true,
                'fetchOrder' => true,
                'fetchOrderBook' => true,
                'fetchOrders' => false,
                'fetchOrderTrades' => false,
                'fetchPositionMode' => false,
                'fetchPositions' => false,
                'fetchPremiumIndexOHLCV' => false,
                'fetchTicker' => true,
                'fetchTickers' => true,
                'fetchTime' => false,
                'fetchTrades' => true,
                'fetchTradingFee' => false,
                'fetchTradingFees' => true,
                'fetchTransactionFees' => false,
                'fetchTransactions' => false,
                'fetchTransfer' => false,
                'fetchTransfers' => false,
                'fetchWithdrawal' => true,
                'fetchWithdrawals' => true,
                'setLeverage' => false,
                'setMarginMode' => false,
                'transfer' => false,
                'withdraw' => true,
            ),
            'timeframes' => array(
                '1m' => '1m',
                '5m' => '5m',
                '15m' => '15m',
                '30m' => '30m',
                '1h' => '1h',
                '3h' => '3h',
                '6h' => '6h',
                '12h' => '12h',
                '1d' => '1d',
                '1w' => '1w',
                '1M' => '1M',
            ),
            'urls' => array(
                'logo' => 'https://user-images.githubusercontent.com/1294454/158227251-3a92a220-9222-453c-9277-977c6677fe71.jpg',
                'api' => array(
                    'rest' => 'https://api.bitopro.com/v3',
                ),
                'www' => 'https://www.bitopro.com',
                'doc' => array(
                    'https://github.com/bitoex/bitopro-offical-api-docs/blob/master/v3-1/rest-1/rest.md',
                ),
                'fees' => 'https://www.bitopro.com/fees',
            ),
            'requiredCredentials' => array(
                'apiKey' => true,
                'secret' => true,
            ),
            'api' => array(
                'public' => array(
                    'get' => array(
                        'order-book/{pair}',
                        'tickers',
                        'tickers/{pair}',
                        'trades/{pair}',
                        'provisioning/currencies',
                        'provisioning/trading-pairs',
                        'provisioning/limitations-and-fees',
                        'trading-history/{pair}',
                    ),
                ),
                'private' => array(
                    'get' => array(
                        'accounts/balance',
                        'orders/history',
                        'orders/all/{pair}',
                        'orders/trades/{pair}',
                        'orders/{pair}/{orderId}',
                        'wallet/withdraw/{currency}/{serial}',
                        'wallet/withdraw/{currency}/id/{id}',
                        'wallet/depositHistory/{currency}',
                        'wallet/withdrawHistory/{currency}',
                    ),
                    'post' => array(
                        'orders/{pair}',
                        'orders/batch',
                        'wallet/withdraw/{currency}',
                    ),
                    'put' => array(
                        'orders',
                    ),
                    'delete' => array(
                        'orders/{pair}/{id}',
                        'orders/all',
                        'orders/{pair}',
                    ),
                ),
            ),
            'fees' => array(
                'trading' => array(
                    'tierBased' => true,
                    'percentage' => true,
                    'maker' => $this->parse_number('0.001'),
                    'taker' => $this->parse_number('0.002'),
                    'tiers' => array(
                        'taker' => array(
                            array( $this->parse_number('0'), $this->parse_number('0.002') ),
                            array( $this->parse_number('3000000'), $this->parse_number('0.00194') ),
                            array( $this->parse_number('5000000'), $this->parse_number('0.0015') ),
                            array( $this->parse_number('30000000'), $this->parse_number('0.0014') ),
                            array( $this->parse_number('300000000'), $this->parse_number('0.0013') ),
                            array( $this->parse_number('550000000'), $this->parse_number('0.0012') ),
                            array( $this->parse_number('1300000000'), $this->parse_number('0.0011') ),
                        ),
                        'maker' => array(
                            array( $this->parse_number('0'), $this->parse_number('0.001') ),
                            array( $this->parse_number('3000000'), $this->parse_number('0.00097') ),
                            array( $this->parse_number('5000000'), $this->parse_number('0.0007') ),
                            array( $this->parse_number('30000000'), $this->parse_number('0.0006') ),
                            array( $this->parse_number('300000000'), $this->parse_number('0.0005') ),
                            array( $this->parse_number('550000000'), $this->parse_number('0.0004') ),
                            array( $this->parse_number('1300000000'), $this->parse_number('0.0003') ),
                        ),
                    ),
                ),
            ),
            'options' => array(
                'networks' => array(
                    'ERC20' => 'ERC20',
                    'ETH' => 'ERC20',
                    'TRX' => 'TRX',
                    'TRC20' => 'TRX',
                    'BEP20' => 'BSC',
                    'BSC' => 'BSC',
                ),
            ),
            'precisionMode' => TICK_SIZE,
            'exceptions' => array(
                'exact' => array(
                    'Unsupported currency.' => '\\ccxt\\BadRequest', // array("error":"Unsupported currency.")
                    'Unsupported order type' => '\\ccxt\\BadRequest', // array("error":"Unsupported order type")
                    'Invalid body' => '\\ccxt\\BadRequest', // array("error":"Invalid body")
                    'Invalid Signature' => '\\ccxt\\AuthenticationError', // array("error":"Invalid Signature")
                    'Address not in whitelist.' => '\\ccxt\\BadRequest',
                ),
                'broad' => array(
                    'Invalid amount' => '\\ccxt\\InvalidOrder', // array("error":"Invalid amount 0.0000000001, decimal limit is 8.")
                    'Balance for ' => '\\ccxt\\InsufficientFunds', // array("error":"Balance for eth not enough, only has 0, but ordered 0.01.")
                    'Invalid ' => '\\ccxt\\BadRequest', // array("error":"Invalid price -1.")
                    'Wrong parameter' => '\\ccxt\\BadRequest', // array("error":"Wrong parameter => from")
                ),
            ),
            'commonCurrencies' => array(
            ),
        ));
    }

    public function fetch_currencies($params = array ()) {
        /**
         * fetches all available $currencies on an exchange
         * @param {array} $params extra parameters specific to the bitopro api endpoint
         * @return {array} an associative dictionary of $currencies
         */
        $response = $this->publicGetProvisioningCurrencies ($params);
        $currencies = $this->safe_value($response, 'data', array());
        //
        //     {
        //         "data":array(
        //             {
        //                 "currency":"eth",
        //                 "withdrawFee":"0.007",
        //                 "minWithdraw":"0.001",
        //                 "maxWithdraw":"1000",
        //                 "maxDailyWithdraw":"2000",
        //                 "withdraw":true,
        //                 "deposit":true,
        //                 "depositConfirmation":"12"
        //             }
        //         )
        //     }
        //
        $result = array();
        for ($i = 0; $i < count($currencies); $i++) {
            $currency = $currencies[$i];
            $currencyId = $this->safe_string($currency, 'currency');
            $code = $this->safe_currency_code($currencyId);
            $deposit = $this->safe_value($currency, 'deposit');
            $withdraw = $this->safe_value($currency, 'withdraw');
            $fee = $this->safe_number($currency, 'withdrawFee');
            $withdrawMin = $this->safe_number($currency, 'minWithdraw');
            $withdrawMax = $this->safe_number($currency, 'maxWithdraw');
            $limits = array(
                'withdraw' => array(
                    'min' => $withdrawMin,
                    'max' => $withdrawMax,
                ),
                'amount' => array(
                    'min' => null,
                    'max' => null,
                ),
            );
            $result[$code] = array(
                'id' => $currencyId,
                'code' => $code,
                'info' => $currency,
                'type' => null,
                'name' => null,
                'active' => $deposit && $withdraw,
                'deposit' => $deposit,
                'withdraw' => $withdraw,
                'fee' => $fee,
                'precision' => null,
                'limits' => $limits,
            );
        }
        return $result;
    }

    public function fetch_markets($params = array ()) {
        /**
         * retrieves data on all $markets for bitopro
         * @param {array} $params extra parameters specific to the exchange api endpoint
         * @return {[array]} an array of objects representing $market data
         */
        $response = $this->publicGetProvisioningTradingPairs ();
        $markets = $this->safe_value($response, 'data', array());
        //
        //     {
        //         "data":array(
        //             {
        //                 "pair":"shib_twd",
        //                 "base":"shib",
        //                 "quote":"twd",
        //                 "basePrecision":"8",
        //                 "quotePrecision":"6",
        //                 "minLimitBaseAmount":"100000",
        //                 "maxLimitBaseAmount":"5500000000",
        //                 "minMarketBuyQuoteAmount":"1000",
        //                 "orderOpenLimit":"200",
        //                 "maintain":false,
        //                 "orderBookQuotePrecision":"6",
        //                 "orderBookQuoteScaleLevel":"5"
        //             }
        //         )
        //     }
        //
        $result = array();
        for ($i = 0; $i < count($markets); $i++) {
            $market = $markets[$i];
            $active = !$this->safe_value($market, 'maintain');
            $id = $this->safe_string($market, 'pair');
            $uppercaseId = strtoupper($id);
            $baseId = $this->safe_string($market, 'base');
            $quoteId = $this->safe_string($market, 'quote');
            $base = $this->safe_currency_code($baseId);
            $quote = $this->safe_currency_code($quoteId);
            $symbol = $base . '/' . $quote;
            $limits = array(
                'amount' => array(
                    'min' => $this->safe_number($market, 'minLimitBaseAmount'),
                    'max' => $this->safe_number($market, 'maxLimitBaseAmount'),
                ),
                'price' => array(
                    'min' => null,
                    'max' => null,
                ),
                'cost' => array(
                    'min' => null,
                    'max' => null,
                ),
                'leverage' => array(
                    'min' => null,
                    'max' => null,
                ),
            );
            $result[] = array(
                'id' => $id,
                'uppercaseId' => $uppercaseId,
                'symbol' => $symbol,
                'base' => $base,
                'quote' => $quote,
                'baseId' => $base,
                'quoteId' => $quote,
                'settle' => null,
                'settleId' => null,
                'type' => 'spot',
                'spot' => true,
                'margin' => false,
                'swap' => false,
                'future' => false,
                'option' => false,
                'derivative' => false,
                'contract' => false,
                'linear' => null,
                'inverse' => null,
                'contractSize' => null,
                'expiry' => null,
                'expiryDatetime' => null,
                'strike' => null,
                'optionType' => null,
                'limits' => $limits,
                'precision' => array(
                    'price' => $this->parse_number($this->parse_precision($this->safe_string($market, 'quotePrecision'))),
                    'amount' => $this->parse_number($this->parse_precision($this->safe_string($market, 'basePrecision'))),
                ),
                'active' => $active,
                'info' => $market,
            );
        }
        return $result;
    }

    public function parse_ticker($ticker, $market = null) {
        //
        //     {
        //         "pair":"btc_twd",
        //         "lastPrice":"1182449.00000000",
        //         "isBuyer":false,
        //         "priceChange24hr":"-1.99",
        //         "volume24hr":"9.13089740",
        //         "high24hr":"1226097.00000000",
        //         "low24hr":"1181000.00000000"
        //     }
        //
        $marketId = $this->safe_string($ticker, 'pair');
        $market = $this->safe_market($marketId, $market);
        $symbol = $this->safe_string($market, 'symbol');
        return $this->safe_ticker(array(
            'symbol' => $symbol,
            'timestamp' => null,
            'datetime' => null,
            'high' => $this->safe_string($ticker, 'high24hr'),
            'low' => $this->safe_string($ticker, 'low24hr'),
            'bid' => null,
            'bidVolume' => null,
            'ask' => null,
            'askVolume' => null,
            'vwap' => null,
            'open' => null,
            'close' => $this->safe_string($ticker, 'lastPrice'),
            'last' => $this->safe_string($ticker, 'lastPrice'),
            'previousClose' => null,
            'change' => null,
            'percentage' => $this->safe_string($ticker, 'priceChange24hr'),
            'average' => null,
            'baseVolume' => $this->safe_string($ticker, 'volume24hr'),
            'quoteVolume' => null,
            'info' => $ticker,
        ), $market);
    }

    public function fetch_ticker(string $symbol, $params = array ()) {
        /**
         * fetches a price $ticker, a statistical calculation with the information calculated over the past 24 hours for a specific $market
         * @param {string} $symbol unified $symbol of the $market to fetch the $ticker for
         * @param {array} $params extra parameters specific to the bitopro api endpoint
         * @return {array} a ~@link https://docs.ccxt.com/#/?id=$ticker-structure $ticker structure~
         */
        $this->load_markets();
        $market = $this->market($symbol);
        $request = array(
            'pair' => $market['id'],
        );
        $response = $this->publicGetTickersPair (array_merge($request, $params));
        $ticker = $this->safe_value($response, 'data', array());
        //
        //     {
        //         "data":{
        //             "pair":"btc_twd",
        //             "lastPrice":"1182449.00000000",
        //             "isBuyer":false,
        //             "priceChange24hr":"-1.99",
        //             "volume24hr":"9.13089740",
        //             "high24hr":"1226097.00000000",
        //             "low24hr":"1181000.00000000"
        //         }
        //     }
        //
        return $this->parse_ticker($ticker, $market);
    }

    public function fetch_tickers(?array $symbols = null, $params = array ()) {
        /**
         * fetches price $tickers for multiple markets, statistical calculations with the information calculated over the past 24 hours each market
         * @param {[string]|null} $symbols unified $symbols of the markets to fetch the ticker for, all market $tickers are returned if not assigned
         * @param {array} $params extra parameters specific to the bitopro api endpoint
         * @return {array} a dictionary of ~@link https://docs.ccxt.com/#/?id=ticker-structure ticker structures~
         */
        $this->load_markets();
        $response = $this->publicGetTickers ();
        $tickers = $this->safe_value($response, 'data', array());
        //
        //     {
        //         "data":array(
        //             {
        //                 "pair":"xrp_twd",
        //                 "lastPrice":"21.26110000",
        //                 "isBuyer":false,
        //                 "priceChange24hr":"-6.53",
        //                 "volume24hr":"102846.47084802",
        //                 "high24hr":"23.24460000",
        //                 "low24hr":"21.13730000"
        //             }
        //         )
        //     }
        //
        return $this->parse_tickers($tickers, $symbols);
    }

    public function fetch_order_book(string $symbol, ?int $limit = null, $params = array ()) {
        /**
         * fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
         * @param {string} $symbol unified $symbol of the $market to fetch the order book for
         * @param {int|null} $limit the maximum amount of order book entries to return
         * @param {array} $params extra parameters specific to the bitopro api endpoint
         * @return {array} A dictionary of ~@link https://docs.ccxt.com/#/?id=order-book-structure order book structures~ indexed by $market symbols
         */
        $this->load_markets();
        $market = $this->market($symbol);
        $request = array(
            'pair' => $market['id'],
        );
        if ($limit !== null) {
            $request['limit'] = $limit;
        }
        $response = $this->publicGetOrderBookPair (array_merge($request, $params));
        //
        //     {
        //         "bids":array(
        //             {
        //                 "price":"1175271",
        //                 "amount":"0.00022804",
        //                 "count":1,
        //                 "total":"0.00022804"
        //             }
        //         ),
        //         "asks":array(
        //             {
        //                 "price":"1176906",
        //                 "amount":"0.0496",
        //                 "count":1,
        //                 "total":"0.0496"
        //             }
        //         )
        //     }
        //
        return $this->parse_order_book($response, $market['symbol'], null, 'bids', 'asks', 'price', 'amount');
    }

    public function parse_trade($trade, $market = null) {
        //
        // fetchTrades
        //         {
        //                 "timestamp":1644651458,
        //                 "price":"1180785.00000000",
        //                 "amount":"0.00020000",
        //                 "isBuyer":false
        //         }
        //
        // fetchMyTrades
        //         {
        //                 "tradeId":"5685030251",
        //                 "orderId":"9669168142",
        //                 "price":"11821.8",
        //                 "action":"SELL",
        //                 "baseAmount":"0.01",
        //                 "quoteAmount":"118.218",
        //                 "fee":"0.236436",
        //                 "feeSymbol":"BNB",
        //                 "isTaker":true,
        //                 "timestamp":1644905714862,
        //                 "createdTimestamp":1644905714862
        //         }
        //
        $id = $this->safe_string($trade, 'tradeId');
        $orderId = $this->safe_string($trade, 'orderId');
        $timestamp = null;
        if ($id === null) {
            $timestamp = $this->safe_timestamp($trade, 'timestamp');
        } else {
            $timestamp = $this->safe_integer($trade, 'timestamp');
        }
        $marketId = $this->safe_string($trade, 'pair');
        $market = $this->safe_market($marketId, $market);
        $symbol = $this->safe_string($market, 'symbol');
        $price = $this->safe_string($trade, 'price');
        $type = $this->safe_string_lower($trade, 'type');
        $side = $this->safe_string_lower($trade, 'action');
        if ($side === null) {
            $isBuyer = $this->safe_value($trade, 'isBuyer');
            if ($isBuyer) {
                $side = 'buy';
            } else {
                $side = 'sell';
            }
        }
        $amount = $this->safe_string($trade, 'amount');
        if ($amount === null) {
            $amount = $this->safe_string($trade, 'baseAmount');
        }
        $fee = null;
        $feeAmount = $this->safe_string($trade, 'fee');
        $feeSymbol = $this->safe_currency_code($this->safe_string($trade, 'feeSymbol'));
        if ($feeAmount !== null) {
            $fee = array(
                'cost' => $feeAmount,
                'currency' => $feeSymbol,
                'rate' => null,
            );
        }
        $isTaker = $this->safe_value($trade, 'isTaker');
        $takerOrMaker = null;
        if ($isTaker !== null) {
            if ($isTaker) {
                $takerOrMaker = 'taker';
            } else {
                $takerOrMaker = 'maker';
            }
        }
        return $this->safe_trade(array(
            'id' => $id,
            'info' => $trade,
            'order' => $orderId,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'symbol' => $symbol,
            'takerOrMaker' => $takerOrMaker,
            'type' => $type,
            'side' => $side,
            'price' => $price,
            'amount' => $amount,
            'cost' => null,
            'fee' => $fee,
        ), $market);
    }

    public function fetch_trades(string $symbol, ?int $since = null, ?int $limit = null, $params = array ()) {
        /**
         * get the list of most recent $trades for a particular $symbol
         * @param {string} $symbol unified $symbol of the $market to fetch $trades for
         * @param {int|null} $since timestamp in ms of the earliest trade to fetch
         * @param {int|null} $limit the maximum amount of $trades to fetch
         * @param {array} $params extra parameters specific to the bitopro api endpoint
         * @return {[array]} a list of ~@link https://docs.ccxt.com/en/latest/manual.html?#public-$trades trade structures~
         */
        $this->load_markets();
        $market = $this->market($symbol);
        $request = array(
            'pair' => $market['id'],
        );
        $response = $this->publicGetTradesPair (array_merge($request, $params));
        $trades = $this->safe_value($response, 'data', array());
        //
        //     {
        //         "data":array(
        //             {
        //                 "timestamp":1644651458,
        //                 "price":"1180785.00000000",
        //                 "amount":"0.00020000",
        //                 "isBuyer":false
        //             }
        //         )
        //     }
        //
        return $this->parse_trades($trades, $market, $since, $limit);
    }

    public function fetch_trading_fees($params = array ()) {
        /**
         * fetch the trading fees for multiple markets
         * @param {array} $params extra parameters specific to the bitopro api endpoint
         * @return {array} a dictionary of ~@link https://docs.ccxt.com/#/?id=fee-structure fee structures~ indexed by market symbols
         */
        $this->load_markets();
        $response = $this->publicGetProvisioningLimitationsAndFees ($params);
        $tradingFeeRate = $this->safe_value($response, 'tradingFeeRate', array());
        $first = $this->safe_value($tradingFeeRate, 0);
        //
        //     {
        //         "tradingFeeRate":array(
        //             {
        //                 "rank":0,
        //                 "twdVolumeSymbol":"\u003c",
        //                 "twdVolume":"3000000",
        //                 "bitoAmountSymbol":"\u003c",
        //                 "bitoAmount":"7500",
        //                 "makerFee":"0.001",
        //                 "takerFee":"0.002",
        //                 "makerBitoFee":"0.0008",
        //                 "takerBitoFee":"0.0016"
        //             }
        //         ),
        //         "orderFeesAndLimitations":array(
        //             {
        //                 "pair":"BTC/TWD",
        //                 "minimumOrderAmount":"0.0001",
        //                 "minimumOrderAmountBase":"BTC",
        //                 "minimumOrderNumberOfDigits":"0"
        //             }
        //         ),
        //         "restrictionsOfWithdrawalFees":array(
        //             {
        //                 "currency":"TWD",
        //                 "fee":"15",
        //                 "minimumTradingAmount":"100",
        //                 "maximumTradingAmount":"1000000",
        //                 "dailyCumulativeMaximumAmount":"2000000",
        //                 "remarks":"",
        //                 "protocol":""
        //             }
        //         ),
        //         "cryptocurrencyDepositFeeAndConfirmation":array(
        //             {
        //                 "currency":"TWD",
        //                 "generalDepositFees":"0",
        //                 "blockchainConfirmationRequired":""
        //             }
        //         ),
        //         "ttCheckFeesAndLimitationsLevel1":array(
        //             {
        //                 "currency":"TWD",
        //                 "redeemDailyCumulativeMaximumAmount":"",
        //                 "generateMinimumTradingAmount":"",
        //                 "generateMaximumTradingAmount":"",
        //                 "generateDailyCumulativeMaximumAmount":""
        //             }
        //         ),
        //         "ttCheckFeesAndLimitationsLevel2":array(
        //             {
        //                 "currency":"TWD",
        //                 "redeemDailyCumulativeMaximumAmount":"20000000",
        //                 "generateMinimumTradingAmount":"30",
        //                 "generateMaximumTradingAmount":"10000000",
        //                 "generateDailyCumulativeMaximumAmount":"10000000"
        //             }
        //         )
        //     }
        //
        $result = array();
        $maker = $this->safe_number($first, 'makerFee');
        $taker = $this->safe_number($first, 'takerFee');
        for ($i = 0; $i < count($this->symbols); $i++) {
            $symbol = $this->symbols[$i];
            $result[$symbol] = array(
                'info' => $first,
                'symbol' => $symbol,
                'maker' => $maker,
                'taker' => $taker,
                'percentage' => true,
                'tierBased' => true,
            );
        }
        return $result;
    }

    public function parse_ohlcv($ohlcv, $market = null) {
        return array(
            $this->safe_integer($ohlcv, 'timestamp'),
            $this->safe_number($ohlcv, 'open'),
            $this->safe_number($ohlcv, 'high'),
            $this->safe_number($ohlcv, 'low'),
            $this->safe_number($ohlcv, 'close'),
            $this->safe_number($ohlcv, 'volume'),
        );
    }

    public function fetch_ohlcv(string $symbol, $timeframe = '1m', ?int $since = null, ?int $limit = null, $params = array ()) {
        /**
         * fetches historical candlestick $data containing the open, high, low, and close price, and the volume of a $market
         * @param {string} $symbol unified $symbol of the $market to fetch OHLCV $data for
         * @param {string} $timeframe the length of time each candle represents
         * @param {int|null} $since timestamp in ms of the earliest candle to fetch
         * @param {int|null} $limit the maximum amount of candles to fetch
         * @param {array} $params extra parameters specific to the bitopro api endpoint
         * @return {[[int]]} A list of candles ordered, open, high, low, close, volume
         */
        $this->load_markets();
        $market = $this->market($symbol);
        $resolution = $this->safe_string($this->timeframes, $timeframe, $timeframe);
        $request = array(
            'pair' => $market['id'],
            'resolution' => $resolution,
        );
        // we need to have a $limit argument because "to" and "from" are required
        if ($limit === null) {
            $limit = 500;
        }
        $timeframeInSeconds = $this->parse_timeframe($timeframe);
        $alignedSince = null;
        if ($since === null) {
            $request['to'] = $this->seconds();
            $request['from'] = $request['to'] - ($limit * $timeframeInSeconds);
        } else {
            $timeframeInMilliseconds = $timeframeInSeconds * 1000;
            $alignedSince = (int) floor($since / $timeframeInMilliseconds) * $timeframeInMilliseconds;
            $request['from'] = (int) floor($since / 1000);
            $request['to'] = $this->sum($request['from'], $limit * $timeframeInSeconds);
        }
        $response = $this->publicGetTradingHistoryPair (array_merge($request, $params));
        $data = $this->safe_value($response, 'data', array());
        //
        //     {
        //         "data":array(
        //             {
        //                 "timestamp":1644581100000,
        //                 "open":"1214737",
        //                 "high":"1215110",
        //                 "low":"1214737",
        //                 "close":"1215110",
        //                 "volume":"0.08423959"
        //             }
        //         )
        //     }
        //
        $sparse = $this->parse_ohlcvs($data, $market, $timeframe, $since, $limit);
        return $this->insert_missing_candles($sparse, $timeframeInSeconds, $alignedSince, $limit);
    }

    public function insert_missing_candles($candles, $distance, $since, $limit) {
        // the exchange doesn't send zero volume $candles so we emulate them instead
        // otherwise sending a $limit arg leads to unexpected results
        $length = count($candles);
        if ($length === 0) {
            return $candles;
        }
        $result = array();
        $copyFrom = $candles[0];
        $timestamp = null;
        if ($since === null) {
            $timestamp = $copyFrom[0];
        } else {
            $timestamp = $since;
        }
        $i = 0;
        $candleLength = count($candles);
        $resultLength = 0;
        while (($resultLength < $limit) && ($i < $candleLength)) {
            $candle = $candles[$i];
            if ($candle[0] === $timestamp) {
                $result[] = $candle;
                $i = $this->sum($i, 1);
            } else {
                $copy = $this->array_concat(array(), $copyFrom);
                $copy[0] = $timestamp;
                // set open, high, low to close
                $copy[1] = $copy[4];
                $copy[2] = $copy[4];
                $copy[3] = $copy[4];
                $copy[5] = $this->parse_number('0');
                $result[] = $copy;
            }
            $timestamp = $this->sum($timestamp, $distance * 1000);
            $resultLength = count($result);
            $copyFrom = $result[$resultLength - 1];
        }
        return $result;
    }

    public function parse_balance($response) {
        //
        //     [array(
        //         "currency":"twd",
        //         "amount":"0",
        //         "available":"0",
        //         "stake":"0",
        //         "tradable":true
        //     )]
        //
        $result = array(
            'info' => $response,
        );
        for ($i = 0; $i < count($response); $i++) {
            $balance = $response[$i];
            $currencyId = $this->safe_string($balance, 'currency');
            $code = $this->safe_currency_code($currencyId);
            $amount = $this->safe_string($balance, 'amount');
            $available = $this->safe_string($balance, 'available');
            $account = array(
                'free' => $available,
                'total' => $amount,
            );
            $result[$code] = $account;
        }
        return $this->safe_balance($result);
    }

    public function fetch_balance($params = array ()) {
        /**
         * query for balance and get the amount of funds available for trading or funds locked in orders
         * @param {array} $params extra parameters specific to the bitopro api endpoint
         * @return {array} a ~@link https://docs.ccxt.com/en/latest/manual.html?#balance-structure balance structure~
         */
        $this->load_markets();
        $response = $this->privateGetAccountsBalance ($params);
        $balances = $this->safe_value($response, 'data', array());
        //
        //     {
        //         "data":array(
        //             {
        //                 "currency":"twd",
        //                 "amount":"0",
        //                 "available":"0",
        //                 "stake":"0",
        //                 "tradable":true
        //             }
        //         )
        //     }
        //
        return $this->parse_balance($balances);
    }

    public function parse_order_status($status) {
        $statuses = array(
            '-1' => 'open',
            '0' => 'open',
            '1' => 'open',
            '2' => 'closed',
            '3' => 'closed',
            '4' => 'canceled',
            '6' => 'canceled',
        );
        return $this->safe_string($statuses, $status, null);
    }

    public function parse_order($order, $market = null) {
        //
        // createOrder
        //         {
        //             orderId => '2220595581',
        //             $timestamp => '1644896744886',
        //             action => 'SELL',
        //             $amount => '0.01',
        //             $price => '15000',
        //             $timeInForce => 'GTC'
        //         }
        //
        // fetchOrder
        //         {
        //             "id":"8777138788",
        //             "pair":"bnb_twd",
        //             "price":"16000",
        //             "avgExecutionPrice":"0",
        //             "action":"SELL",
        //             "type":"LIMIT",
        //             "timestamp":1644899002598,
        //             "status":4,
        //             "originalAmount":"0.01",
        //             "remainingAmount":"0.01",
        //             "executedAmount":"0",
        //             "fee":"0",
        //             "feeSymbol":"twd",
        //             "bitoFee":"0",
        //             "total":"0",
        //             "seq":"BNBTWD548774666",
        //             "timeInForce":"GTC",
        //             "createdTimestamp":1644898944074,
        //             "updatedTimestamp":1644899002598
        //         }
        //
        $id = $this->safe_string_2($order, 'id', 'orderId');
        $timestamp = $this->safe_integer_2($order, 'timestamp', 'createdTimestamp');
        $side = $this->safe_string($order, 'action');
        $side = strtolower($side);
        $amount = $this->safe_string_2($order, 'amount', 'originalAmount');
        $price = $this->safe_string($order, 'price');
        $marketId = $this->safe_string($order, 'pair');
        $market = $this->safe_market($marketId, $market, '_');
        $symbol = $this->safe_string($market, 'symbol');
        $orderStatus = $this->safe_string($order, 'status');
        $status = $this->parse_order_status($orderStatus);
        $type = $this->safe_string_lower($order, 'type');
        $average = $this->safe_string($order, 'avgExecutionPrice');
        $filled = $this->safe_string($order, 'executedAmount');
        $remaining = $this->safe_string($order, 'remainingAmount');
        $timeInForce = $this->safe_string($order, 'timeInForce');
        $postOnly = null;
        if ($timeInForce === 'POST_ONLY') {
            $postOnly = true;
        }
        $fee = null;
        $feeAmount = $this->safe_string($order, 'fee');
        $feeSymbol = $this->safe_currency_code($this->safe_string($order, 'feeSymbol'));
        if (Precise::string_gt($feeAmount, '0')) {
            $fee = array(
                'currency' => $feeSymbol,
                'cost' => $feeAmount,
            );
        }
        return $this->safe_order(array(
            'id' => $id,
            'clientOrderId' => null,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'lastTradeTimestamp' => $this->safe_integer($order, 'updatedTimestamp'),
            'symbol' => $symbol,
            'type' => $type,
            'timeInForce' => $timeInForce,
            'postOnly' => $postOnly,
            'side' => $side,
            'price' => $price,
            'stopPrice' => null,
            'triggerPrice' => null,
            'amount' => $amount,
            'cost' => null,
            'average' => $average,
            'filled' => $filled,
            'remaining' => $remaining,
            'status' => $status,
            'fee' => $fee,
            'trades' => null,
            'info' => $order,
        ), $market);
    }

    public function create_order(string $symbol, string $type, string $side, $amount, $price = null, $params = array ()) {
        /**
         * create a trade order
         * @param {string} $symbol unified $symbol of the $market to create an order in
         * @param {string} $type 'market' or 'limit'
         * @param {string} $side 'buy' or 'sell'
         * @param {float} $amount how much of currency you want to trade in units of base currency
         * @param {float|null} $price the $price at which the order is to be fullfilled, in units of the quote currency, ignored in $market orders
         * @param {array} $params extra parameters specific to the bitopro api endpoint
         * @return {array} an ~@link https://docs.ccxt.com/#/?id=order-structure order structure~
         */
        $this->load_markets();
        $market = $this->market($symbol);
        $request = array(
            'type' => $type,
            'pair' => $market['id'],
            'action' => $side,
            'amount' => $this->amount_to_precision($symbol, $amount),
            'timestamp' => $this->milliseconds(),
        );
        $orderType = strtoupper($type);
        if ($orderType === 'LIMIT') {
            $request['price'] = $this->price_to_precision($symbol, $price);
        }
        if ($orderType === 'STOP_LIMIT') {
            $request['price'] = $this->price_to_precision($symbol, $price);
            $stopPrice = $this->safe_value_2($params, 'triggerPrice', 'stopPrice');
            $params = $this->omit($params, array( 'triggerPrice', 'stopPrice' ));
            if ($stopPrice === null) {
                throw new InvalidOrder($this->id . ' createOrder() requires a $stopPrice parameter for ' . $orderType . ' orders');
            } else {
                $request['stopPrice'] = $this->price_to_precision($symbol, $stopPrice);
            }
            $condition = $this->safe_string($params, 'condition');
            if ($condition === null) {
                throw new InvalidOrder($this->id . ' createOrder() requires a $condition parameter for ' . $orderType . ' orders');
            } else {
                $request['condition'] = $condition;
            }
        }
        $postOnly = $this->is_post_only($orderType === 'MARKET', null, $params);
        if ($postOnly) {
            $request['timeInForce'] = 'POST_ONLY';
        }
        $response = $this->privatePostOrdersPair (array_merge($request, $params));
        //
        //     {
        //         orderId => '2220595581',
        //         timestamp => '1644896744886',
        //         action => 'SELL',
        //         $amount => '0.01',
        //         $price => '15000',
        //         timeInForce => 'GTC'
        //     }
        //
        return $this->parse_order($response, $market);
    }

    public function cancel_order(string $id, ?string $symbol = null, $params = array ()) {
        /**
         * cancels an open order
         * @param {string} $id order $id
         * @param {string} $symbol unified $symbol of the $market the order was made in
         * @param {array} $params extra parameters specific to the bitopro api endpoint
         * @return {array} An ~@link https://docs.ccxt.com/#/?$id=order-structure order structure~
         */
        if ($symbol === null) {
            throw new ArgumentsRequired($this->id . ' cancelOrder() requires the $symbol argument');
        }
        $this->load_markets();
        $market = $this->market($symbol);
        $request = array(
            'id' => $id,
            'pair' => $market['id'],
        );
        $response = $this->privateDeleteOrdersPairId (array_merge($request, $params));
        //
        //     {
        //         "orderId":"8777138788",
        //         "action":"SELL",
        //         "timestamp":1644899002465,
        //         "price":"16000",
        //         "amount":"0.01"
        //     }
        //
        return $this->parse_order($response, $market);
    }

    public function cancel_orders($ids, ?string $symbol = null, $params = array ()) {
        /**
         * cancel multiple orders
         * @param {[string]} $ids order $ids
         * @param {string} $symbol unified $market $symbol
         * @param {array} $params extra parameters specific to the bitopro api endpoint
         * @return {array} an list of ~@link https://docs.ccxt.com/#/?$id=order-structure order structures~
         */
        if ($symbol === null) {
            throw new ArgumentsRequired($this->id . ' cancelOrders() requires a $symbol argument');
        }
        $this->load_markets();
        $market = $this->market($symbol);
        $id = $market['uppercaseId'];
        $request = array();
        $request[$id] = $ids;
        $response = $this->privatePutOrders (array_merge($request, $params));
        //
        //     {
        //         "data":{
        //             "BNB_TWD":array(
        //                 "5236347105",
        //                 "359488711"
        //             )
        //         }
        //     }
        //
        return $response;
    }

    public function cancel_all_orders(?string $symbol = null, $params = array ()) {
        /**
         * cancel all open orders
         * @param {string|null} $symbol unified $market $symbol, only orders in the $market of this $symbol are cancelled when $symbol is not null
         * @param {array} $params extra parameters specific to the bitopro api endpoint
         * @return {[array]} a list of ~@link https://docs.ccxt.com/#/?id=order-structure order structures~
         */
        $this->load_markets();
        $request = array(
            // 'pair' => $market['id'], // optional
        );
        // privateDeleteOrdersAll or privateDeleteOrdersPair
        $method = $this->safe_string($this->options, 'privateDeleteOrdersPair', 'privateDeleteOrdersAll');
        if ($symbol !== null) {
            $market = $this->market($symbol);
            $request['pair'] = $market['id'];
            $method = 'privateDeleteOrdersPair';
        }
        $response = $this->$method (array_merge($request, $params));
        $result = $this->safe_value($response, 'data', array());
        //
        //     {
        //         "data":{
        //             "BNB_TWD":array(
        //                 "9515988421",
        //                 "4639130027"
        //             )
        //         }
        //     }
        //
        return $result;
    }

    public function fetch_order(string $id, ?string $symbol = null, $params = array ()) {
        /**
         * fetches information on an order made by the user
         * @param {string} $symbol unified $symbol of the $market the order was made in
         * @param {array} $params extra parameters specific to the bitopro api endpoint
         * @return {array} An ~@link https://docs.ccxt.com/#/?$id=order-structure order structure~
         */
        if ($symbol === null) {
            throw new ArgumentsRequired($this->id . ' fetchOrder() requires the $symbol argument');
        }
        $this->load_markets();
        $market = $this->market($symbol);
        $request = array(
            'orderId' => $id,
            'pair' => $market['id'],
        );
        $response = $this->privateGetOrdersPairOrderId (array_merge($request, $params));
        //
        //     {
        //         "id":"8777138788",
        //         "pair":"bnb_twd",
        //         "price":"16000",
        //         "avgExecutionPrice":"0",
        //         "action":"SELL",
        //         "type":"LIMIT",
        //         "timestamp":1644899002598,
        //         "status":4,
        //         "originalAmount":"0.01",
        //         "remainingAmount":"0.01",
        //         "executedAmount":"0",
        //         "fee":"0",
        //         "feeSymbol":"twd",
        //         "bitoFee":"0",
        //         "total":"0",
        //         "seq":"BNBTWD548774666",
        //         "timeInForce":"GTC",
        //         "createdTimestamp":1644898944074,
        //         "updatedTimestamp":1644899002598
        //     }
        //
        return $this->parse_order($response, $market);
    }

    public function fetch_orders(?string $symbol = null, ?int $since = null, ?int $limit = null, $params = array ()) {
        /**
         * fetches information on multiple $orders made by the user
         * @param {string} $symbol unified $market $symbol of the $market $orders were made in
         * @param {int|null} $since the earliest time in ms to fetch $orders for
         * @param {int|null} $limit the maximum number of  orde structures to retrieve
         * @param {array} $params extra parameters specific to the bitopro api endpoint
         * @return {[array]} a list of ~@link https://docs.ccxt.com/#/?id=order-structure order structures~
         */
        if ($symbol === null) {
            throw new ArgumentsRequired($this->id . ' fetchOrders() requires the $symbol argument');
        }
        $this->load_markets();
        $market = $this->market($symbol);
        $request = array(
            'pair' => $market['id'],
            // 'startTimestamp' => 0,
            // 'endTimestamp' => 0,
            // 'statusKind' => '',
            // 'orderId' => '',
        );
        if ($since !== null) {
            $request['startTimestamp'] = $since;
        }
        if ($limit !== null) {
            $request['limit'] = $limit;
        }
        $response = $this->privateGetOrdersAllPair (array_merge($request, $params));
        $orders = $this->safe_value($response, 'data');
        if ($orders === null) {
            $orders = array();
        }
        //
        //     {
        //         "data":array(
        //             {
        //                 "id":"2220595581",
        //                 "pair":"bnb_twd",
        //                 "price":"15000",
        //                 "avgExecutionPrice":"0",
        //                 "action":"SELL",
        //                 "type":"LIMIT",
        //                 "createdTimestamp":1644896744886,
        //                 "updatedTimestamp":1644898706236,
        //                 "status":4,
        //                 "originalAmount":"0.01",
        //                 "remainingAmount":"0.01",
        //                 "executedAmount":"0",
        //                 "fee":"0",
        //                 "feeSymbol":"twd",
        //                 "bitoFee":"0",
        //                 "total":"0",
        //                 "seq":"BNBTWD8540871774",
        //                 "timeInForce":"GTC"
        //             }
        //         )
        //     }
        //
        return $this->parse_orders($orders, $market, $since, $limit);
    }

    public function fetch_open_orders(?string $symbol = null, ?int $since = null, ?int $limit = null, $params = array ()) {
        $request = array(
            'statusKind' => 'OPEN',
        );
        return $this->fetch_orders($symbol, $since, $limit, array_merge($request, $params));
    }

    public function fetch_closed_orders(?string $symbol = null, ?int $since = null, ?int $limit = null, $params = array ()) {
        /**
         * fetches information on multiple closed orders made by the user
         * @param {string} $symbol unified market $symbol of the market orders were made in
         * @param {int|null} $since the earliest time in ms to fetch orders for
         * @param {int|null} $limit the maximum number of  orde structures to retrieve
         * @param {array} $params extra parameters specific to the bitopro api endpoint
         * @return {[array]} a list of ~@link https://docs.ccxt.com/#/?id=order-structure order structures~
         */
        $request = array(
            'statusKind' => 'DONE',
        );
        return $this->fetch_orders($symbol, $since, $limit, array_merge($request, $params));
    }

    public function fetch_my_trades(?string $symbol = null, ?int $since = null, ?int $limit = null, $params = array ()) {
        /**
         * fetch all $trades made by the user
         * @param {string} $symbol unified $market $symbol
         * @param {int|null} $since the earliest time in ms to fetch $trades for
         * @param {int|null} $limit the maximum number of $trades structures to retrieve
         * @param {array} $params extra parameters specific to the bitopro api endpoint
         * @return {[array]} a list of ~@link https://docs.ccxt.com/#/?id=trade-structure trade structures~
         */
        if ($symbol === null) {
            throw new ArgumentsRequired($this->id . ' fetchMyTrades() requires the $symbol argument');
        }
        $this->load_markets();
        $market = $this->market($symbol);
        $request = array(
            'pair' => $market['id'],
        );
        $response = $this->privateGetOrdersTradesPair (array_merge($request, $params));
        $trades = $this->safe_value($response, 'data', array());
        //
        //     {
        //         "data":array(
        //             {
        //                 "tradeId":"5685030251",
        //                 "orderId":"9669168142",
        //                 "price":"11821.8",
        //                 "action":"SELL",
        //                 "baseAmount":"0.01",
        //                 "quoteAmount":"118.218",
        //                 "fee":"0.236436",
        //                 "feeSymbol":"BNB",
        //                 "isTaker":true,
        //                 "timestamp":1644905714862,
        //                 "createdTimestamp":1644905714862
        //             }
        //         )
        //     }
        //
        return $this->parse_trades($trades, $market, $since, $limit);
    }

    public function parse_transaction_status($status) {
        $states = array(
            'COMPLETE' => 'ok',
            'INVALID' => 'failed',
            'PROCESSING' => 'pending',
            'WAIT_PROCESS' => 'pending',
            'FAILED' => 'failed',
            'EXPIRED' => 'failed',
            'CANCELLED' => 'failed',
            'EMAIL_VERIFICATION' => 'pending',
            'WAIT_CONFIRMATION' => 'pending',
        );
        return $this->safe_string($states, $status, $status);
    }

    public function parse_transaction($transaction, $currency = null) {
        //
        // fetchDeposits
        //
        //    {
        //        "serial" => "20220214X766799",
        //        "timestamp" => "1644833015053",
        //        "address" => "bnb1xml62k5a9dcewgc542fha75fyxdcp0zv8eqfsh",
        //        "amount" => "0.20000000",
        //        "fee" => "0.00000000",
        //        "total" => "0.20000000",
        //        "status" => "COMPLETE",
        //        "txid" => "A3CC4F6828CC752B9F3737F48B5826B9EC2857040CB5141D0CC955F7E53DB6D9",
        //        "message" => "778553959",
        //        "protocol" => "MAIN",
        //        "id" => "2905906537"
        //    }
        //
        // fetchWithdrawals || fetchWithdraw
        //
        //    {
        //        "serial" => "20220215BW14069838",
        //        "timestamp" => "1644907716044",
        //        "address" => "TKrwMaZaGiAvtXCFT41xHuusNcs4LPWS7w",
        //        "amount" => "8.00000000",
        //        "fee" => "2.00000000",
        //        "total" => "10.00000000",
        //        "status" => "COMPLETE",
        //        "txid" => "50bf250c71a582f40cf699fb58bab978437ea9bdf7259ff8072e669aab30c32b",
        //        "protocol" => "TRX",
        //        "id" => "9925310345"
        //    }
        //
        // withdraw
        //
        //    {
        //        "serial" => "20220215BW14069838",
        //        "currency" => "USDT",
        //        "protocol" => "TRX",
        //        "address" => "TKrwMaZaGiAvtXCFT41xHuusNcs4LPWS7w",
        //        "amount" => "8",
        //        "fee" => "2",
        //        "total" => "10"
        //    }
        //
        $currencyId = $this->safe_string($transaction, 'coin');
        $code = $this->safe_currency_code($currencyId, $currency);
        $timestamp = $this->safe_integer($transaction, 'timestamp');
        $address = $this->safe_string($transaction, 'address');
        $tag = $this->safe_string($transaction, 'message');
        $status = $this->safe_string($transaction, 'status');
        $networkId = $this->safe_string($transaction, 'protocol');
        if ($networkId === 'MAIN') {
            $networkId = $code;
        }
        return array(
            'info' => $transaction,
            'id' => $this->safe_string($transaction, 'serial'),
            'txid' => $this->safe_string($transaction, 'txid'),
            'type' => null,
            'currency' => $code,
            'network' => $this->network_id_to_code($networkId),
            'amount' => $this->safe_number($transaction, 'total'),
            'status' => $this->parse_transaction_status($status),
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'address' => $address,
            'addressFrom' => null,
            'addressTo' => $address,
            'tag' => $tag,
            'tagFrom' => null,
            'tagTo' => $tag,
            'updated' => null,
            'comment' => null,
            'fee' => array(
                'currency' => $code,
                'cost' => $this->safe_number($transaction, 'fee'),
                'rate' => null,
            ),
        );
    }

    public function fetch_deposits(?string $code = null, ?int $since = null, ?int $limit = null, $params = array ()) {
        /**
         * fetch all deposits made to an account
         * @param {string} $code unified $currency $code
         * @param {int|null} $since the earliest time in ms to fetch deposits for
         * @param {int|null} $limit the maximum number of deposits structures to retrieve
         * @param {array} $params extra parameters specific to the bitopro api endpoint
         * @return {[array]} a list of ~@link https://docs.ccxt.com/#/?id=transaction-structure transaction structures~
         */
        if ($code === null) {
            throw new ArgumentsRequired($this->id . ' fetchDeposits() requires the $code argument');
        }
        $this->load_markets();
        $currency = $this->safe_currency($code);
        $request = array(
            'currency' => $currency['id'],
            // 'endTimestamp' => 0,
            // 'id' => '',
            // 'statuses' => '', // 'ROCESSING,COMPLETE,INVALID,WAIT_PROCESS,CANCELLED,FAILED'
        );
        if ($since !== null) {
            $request['startTimestamp'] = $since;
        }
        if ($limit !== null) {
            $request['limit'] = $limit;
        }
        $response = $this->privateGetWalletDepositHistoryCurrency (array_merge($request, $params));
        $result = $this->safe_value($response, 'data', array());
        //
        //     {
        //         "data":array(
        //             {
        //                 "serial":"20220214X766799",
        //                 "timestamp":"1644833015053",
        //                 "address":"bnb1xml62k5a9dcewgc542fha75fyxdcp0zv8eqfsh",
        //                 "amount":"0.20000000",
        //                 "fee":"0.00000000",
        //                 "total":"0.20000000",
        //                 "status":"COMPLETE",
        //                 "txid":"A3CC4F6828CC752B9F3737F48B5826B9EC2857040CB5141D0CC955F7E53DB6D9",
        //                 "message":"778553959",
        //                 "protocol":"MAIN",
        //                 "id":"2905906537"
        //             }
        //         )
        //     }
        //
        return $this->parse_transactions($result, $currency, $since, $limit, array( 'type' => 'deposit' ));
    }

    public function fetch_withdrawals(?string $code = null, ?int $since = null, ?int $limit = null, $params = array ()) {
        /**
         * fetch all withdrawals made from an account
         * @param {string} $code unified $currency $code
         * @param {int|null} $since the earliest time in ms to fetch withdrawals for
         * @param {int|null} $limit the maximum number of withdrawals structures to retrieve
         * @param {array} $params extra parameters specific to the bitopro api endpoint
         * @return {[array]} a list of ~@link https://docs.ccxt.com/#/?id=transaction-structure transaction structures~
         */
        if ($code === null) {
            throw new ArgumentsRequired($this->id . ' fetchWithdrawals() requires the $code argument');
        }
        $this->load_markets();
        $currency = $this->safe_currency($code);
        $request = array(
            'currency' => $currency['id'],
            // 'endTimestamp' => 0,
            // 'id' => '',
            // 'statuses' => '', // 'PROCESSING,COMPLETE,EXPIRED,INVALID,WAIT_PROCESS,WAIT_CONFIRMATION,EMAIL_VERIFICATION,CANCELLED'
        );
        if ($since !== null) {
            $request['startTimestamp'] = $since;
        }
        if ($limit !== null) {
            $request['limit'] = $limit;
        }
        $response = $this->privateGetWalletWithdrawHistoryCurrency (array_merge($request, $params));
        $result = $this->safe_value($response, 'data', array());
        //
        //     {
        //         "data":array(
        //             {
        //                 "serial":"20220215BW14069838",
        //                 "timestamp":"1644907716044",
        //                 "address":"TKrwMaZaGiAvtXCFT41xHuusNcs4LPWS7w",
        //                 "amount":"8.00000000",
        //                 "fee":"2.00000000",
        //                 "total":"10.00000000",
        //                 "status":"COMPLETE",
        //                 "txid":"50bf250c71a582f40cf699fb58bab978437ea9bdf7259ff8072e669aab30c32b",
        //                 "protocol":"TRX",
        //                 "id":"9925310345"
        //             }
        //         )
        //     }
        //
        return $this->parse_transactions($result, $currency, $since, $limit, array( 'type' => 'withdrawal' ));
    }

    public function fetch_withdrawal(string $id, ?string $code = null, $params = array ()) {
        /**
         * fetch data on a $currency withdrawal via the withdrawal $id
         * @param {string} $id withdrawal $id
         * @param {string} $code unified $currency $code of the $currency withdrawn, default is null
         * @param {array} $params extra parameters specific to the bitopro api endpoint
         * @return {array} a ~@link https://docs.ccxt.com/#/?$id=transaction-structure transaction structure~
         */
        if ($code === null) {
            throw new ArgumentsRequired($this->id . ' fetchWithdrawal() requires the $code argument');
        }
        $this->load_markets();
        $currency = $this->safe_currency($code);
        $request = array(
            'serial' => $id,
            'currency' => $currency['id'],
        );
        $response = $this->privateGetWalletWithdrawCurrencySerial (array_merge($request, $params));
        $result = $this->safe_value($response, 'data', array());
        //
        //     {
        //         "data":{
        //             "serial":"20220215BW14069838",
        //             "address":"TKrwMaZaGiAvtXCFT41xHuusNcs4LPWS7w",
        //             "amount":"8.00000000",
        //             "fee":"2.00000000",
        //             "total":"10.00000000",
        //             "status":"COMPLETE",
        //             "txid":"50bf250c71a582f40cf699fb58bab978437ea9bdf7259ff8072e669aab30c32b",
        //             "protocol":"TRX",
        //             "id":"9925310345",
        //             "timestamp":"1644907716044"
        //         }
        //     }
        //
        return $this->parse_transaction($result, $currency);
    }

    public function withdraw(string $code, $amount, $address, $tag = null, $params = array ()) {
        /**
         * make a withdrawal
         * @param {string} $code unified $currency $code
         * @param {float} $amount the $amount to withdraw
         * @param {string} $address the $address to withdraw to
         * @param {string|null} $tag
         * @param {array} $params extra parameters specific to the bitopro api endpoint
         * @return {array} a ~@link https://docs.ccxt.com/#/?id=transaction-structure transaction structure~
         */
        list($tag, $params) = $this->handle_withdraw_tag_and_params($tag, $params);
        $this->load_markets();
        $this->check_address($address);
        $currency = $this->currency($code);
        $request = array(
            'currency' => $currency['id'],
            'amount' => $this->number_to_string($amount),
            'address' => $address,
        );
        if (is_array($params) && array_key_exists('network', $params)) {
            $networks = $this->safe_value($this->options, 'networks', array());
            $requestedNetwork = $this->safe_string_upper($params, 'network');
            $params = $this->omit($params, array( 'network' ));
            $networkId = $this->safe_string($networks, $requestedNetwork);
            if ($networkId === null) {
                throw new ExchangeError($this->id . ' invalid network ' . $requestedNetwork);
            }
            $request['protocol'] = $networkId;
        }
        if ($tag !== null) {
            $request['message'] = $tag;
        }
        $response = $this->privatePostWalletWithdrawCurrency (array_merge($request, $params));
        $result = $this->safe_value($response, 'data', array());
        //
        //     {
        //         "data":{
        //             "serial":"20220215BW14069838",
        //             "currency":"USDT",
        //             "protocol":"TRX",
        //             "address":"TKrwMaZaGiAvtXCFT41xHuusNcs4LPWS7w",
        //             "amount":"8",
        //             "fee":"2",
        //             "total":"10"
        //         }
        //     }
        //
        return $this->parse_transaction($result, $currency);
    }

    public function sign($path, $api = 'public', $method = 'GET', $params = array (), $headers = null, $body = null) {
        $url = '/' . $this->implode_params($path, $params);
        $query = $this->omit($params, $this->extract_params($path));
        if ($headers === null) {
            $headers = array();
        }
        $headers['X-BITOPRO-API'] = 'ccxt';
        if ($api === 'private') {
            $this->check_required_credentials();
            if ($method === 'POST' || $method === 'PUT') {
                $body = $this->json($params);
                $payload = base64_encode($body);
                $signature = $this->hmac($this->encode($payload), $this->encode($this->secret), 'sha384');
                $headers['X-BITOPRO-APIKEY'] = $this->apiKey;
                $headers['X-BITOPRO-PAYLOAD'] = $payload;
                $headers['X-BITOPRO-SIGNATURE'] = $signature;
            } elseif ($method === 'GET' || $method === 'DELETE') {
                if ($query) {
                    $url .= '?' . $this->urlencode($query);
                }
                $nonce = $this->milliseconds();
                $rawData = array(
                    'nonce' => $nonce,
                );
                $data = $this->json($rawData);
                $payload = base64_encode($data);
                $signature = $this->hmac($payload, $this->encode($this->secret), 'sha384');
                $headers['X-BITOPRO-APIKEY'] = $this->apiKey;
                $headers['X-BITOPRO-PAYLOAD'] = $payload;
                $headers['X-BITOPRO-SIGNATURE'] = $signature;
            }
        } elseif ($api === 'public' && $method === 'GET') {
            if ($query) {
                $url .= '?' . $this->urlencode($query);
            }
        }
        $url = $this->urls['api']['rest'] . $url;
        return array( 'url' => $url, 'method' => $method, 'body' => $body, 'headers' => $headers );
    }

    public function handle_errors($code, $reason, $url, $method, $headers, $body, $response, $requestHeaders, $requestBody) {
        if ($response === null) {
            return null; // fallback to the default $error handler
        }
        if ($code >= 200 && $code < 300) {
            return null;
        }
        $feedback = $this->id . ' ' . $body;
        $error = $this->safe_string($response, 'error');
        $this->throw_exactly_matched_exception($this->exceptions['exact'], $error, $feedback);
        $this->throw_broadly_matched_exception($this->exceptions['broad'], $error, $feedback);
        throw new ExchangeError($feedback); // unknown message
    }
}
