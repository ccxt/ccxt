<?php

namespace ccxt;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

use Exception; // a common import
use ccxt\abstract\vertex as Exchange;

class vertex extends Exchange {

    public function describe() {
        return $this->deep_extend(parent::describe(), array(
            'id' => 'vertex',
            'name' => 'Vertex',
            'countries' => [ ],
            'version' => 'v1',
            'rateLimit' => 50,
            'certified' => false,
            'pro' => true,
            'dex' => true,
            'has' => array(
                'CORS' => null,
                'spot' => true,
                'margin' => false,
                'swap' => true,
                'future' => true,
                'option' => false,
                'addMargin' => false,
                'borrowCrossMargin' => false,
                'borrowIsolatedMargin' => false,
                'cancelAllOrders' => true,
                'cancelAllOrdersAfter' => false,
                'cancelOrder' => true,
                'cancelOrders' => true,
                'cancelOrdersForSymbols' => false,
                'closeAllPositions' => false,
                'closePosition' => false,
                'createMarketBuyOrderWithCost' => false,
                'createMarketOrderWithCost' => false,
                'createMarketSellOrderWithCost' => false,
                'createOrder' => true,
                'createOrders' => true,
                'createReduceOnlyOrder' => true,
                'editOrder' => false,
                'fetchAccounts' => false,
                'fetchBalance' => true,
                'fetchBorrowInterest' => false,
                'fetchBorrowRateHistories' => false,
                'fetchBorrowRateHistory' => false,
                'fetchCanceledOrders' => false,
                'fetchClosedOrders' => false,
                'fetchCrossBorrowRate' => false,
                'fetchCrossBorrowRates' => false,
                'fetchCurrencies' => true,
                'fetchDepositAddress' => false,
                'fetchDepositAddresses' => false,
                'fetchDeposits' => false,
                'fetchDepositWithdrawFee' => false,
                'fetchDepositWithdrawFees' => false,
                'fetchFundingHistory' => false,
                'fetchFundingRate' => true,
                'fetchFundingRateHistory' => false,
                'fetchFundingRates' => true,
                'fetchIndexOHLCV' => false,
                'fetchIsolatedBorrowRate' => false,
                'fetchIsolatedBorrowRates' => false,
                'fetchLedger' => false,
                'fetchLeverage' => false,
                'fetchLeverageTiers' => false,
                'fetchLiquidations' => false,
                'fetchMarginMode' => null,
                'fetchMarketLeverageTiers' => false,
                'fetchMarkets' => true,
                'fetchMarkOHLCV' => false,
                'fetchMyLiquidations' => false,
                'fetchMyTrades' => true,
                'fetchOHLCV' => true,
                'fetchOpenInterest' => true,
                'fetchOpenInterestHistory' => false,
                'fetchOpenOrders' => true,
                'fetchOrder' => true,
                'fetchOrderBook' => true,
                'fetchOrders' => true,
                'fetchOrderTrades' => false,
                'fetchPosition' => false,
                'fetchPositionMode' => false,
                'fetchPositions' => true,
                'fetchPositionsRisk' => false,
                'fetchPremiumIndexOHLCV' => false,
                'fetchStatus' => true,
                'fetchTicker' => false,
                'fetchTickers' => true,
                'fetchTime' => true,
                'fetchTrades' => true,
                'fetchTradingFee' => false,
                'fetchTradingFees' => true,
                'fetchTransfer' => false,
                'fetchTransfers' => false,
                'fetchWithdrawal' => false,
                'fetchWithdrawals' => false,
                'reduceMargin' => false,
                'repayCrossMargin' => false,
                'repayIsolatedMargin' => false,
                'sandbox' => true,
                'setLeverage' => false,
                'setMarginMode' => false,
                'setPositionMode' => false,
                'transfer' => false,
                'withdraw' => true,
            ),
            'timeframes' => array(
                '1m' => 60,
                '5m' => 300,
                '15m' => 900,
                '1h' => 3600,
                '2h' => 7200,
                '4h' => 14400,
                '1d' => 86400,
                '1w' => 604800,
                '1M' => 604800,
            ),
            'hostname' => 'vertexprotocol.com',
            'urls' => array(
                'logo' => 'https://github.com/ccxt/ccxt/assets/43336371/bd04a0fa-3b48-47b6-9d8b-124954d520a8',
                'api' => array(
                    'v1' => array(
                        'archive' => 'https://archive.prod.{hostname}/v1',
                        'gateway' => 'https://gateway.prod.{hostname}/v1',
                        'trigger' => 'https://trigger.prod.{hostname}/v1',
                    ),
                    'v2' => array(
                        'archive' => 'https://archive.prod.{hostname}/v2',
                        'gateway' => 'https://gateway.prod.{hostname}/v2',
                    ),
                ),
                'test' => array(
                    'v1' => array(
                        'archive' => 'https://archive.sepolia-test.{hostname}/v1',
                        'gateway' => 'https://gateway.sepolia-test.{hostname}/v1',
                        'trigger' => 'https://trigger.sepolia-test.{hostname}/v1',
                    ),
                    'v2' => array(
                        'archive' => 'https://archive.sepolia-test.{hostname}/v2',
                        'gateway' => 'https://gateway.sepolia-test.{hostname}/v2',
                    ),
                ),
                'www' => 'https://vertexprotocol.com/',
                'doc' => 'https://docs.vertexprotocol.com/',
                'fees' => 'https://docs.vertexprotocol.com/basics/fees',
                'referral' => 'https://app.vertexprotocol.com?referrer=0xCfC9BaB96a2eA3d3c3F031c005e82E1D9F295aC1',
            ),
            'api' => array(
                'v1' => array(
                    'archive' => array(
                        'post' => array(
                            '' => 1,
                        ),
                    ),
                    'gateway' => array(
                        'get' => array(
                            'query' => 1,
                            'symbols' => 1,
                            'time' => 1,
                        ),
                        'post' => array(
                            'query' => 1,
                            'execute' => 1,
                        ),
                    ),
                    'trigger' => array(
                        'post' => array(
                            'execute' => 1,
                            'query' => 1,
                        ),
                    ),
                ),
                'v2' => array(
                    'archive' => array(
                        'get' => array(
                            'tickers' => 1,
                            'contracts' => 1,
                            'trades' => 1,
                            'vrtx' => 1,
                        ),
                    ),
                    'gateway' => array(
                        'get' => array(
                            'assets' => 0.6667,
                            'pairs' => 1,
                            'orderbook' => 1,
                        ),
                    ),
                ),
            ),
            'fees' => array(
                'swap' => array(
                    'taker' => $this->parse_number('0.0002'),
                    'maker' => $this->parse_number('0.0002'),
                ),
                'spot' => array(
                    'taker' => $this->parse_number('0.0002'),
                    'maker' => $this->parse_number('0.0002'),
                ),
            ),
            'requiredCredentials' => array(
                'apiKey' => false,
                'secret' => false,
                'walletAddress' => true,
                'privateKey' => true,
            ),
            'exceptions' => array(
                'exact' => array(
                    '1000' => '\\ccxt\\RateLimitExceeded',
                    '1015' => '\\ccxt\\RateLimitExceeded',
                    '1001' => '\\ccxt\\PermissionDenied',
                    '1002' => '\\ccxt\\PermissionDenied',
                    '1003' => '\\ccxt\\PermissionDenied',
                    '2000' => '\\ccxt\\InvalidOrder',
                    '2001' => '\\ccxt\\InvalidOrder',
                    '2002' => '\\ccxt\\InvalidOrder',
                    '2003' => '\\ccxt\\InvalidOrder',
                    '2004' => '\\ccxt\\InvalidOrder',
                    '2005' => '\\ccxt\\InvalidOrder',
                    '2006' => '\\ccxt\\InvalidOrder',
                    '2007' => '\\ccxt\\InvalidOrder',
                    '2008' => '\\ccxt\\InvalidOrder',
                    '2009' => '\\ccxt\\InvalidOrder',
                    '2010' => '\\ccxt\\InvalidOrder',
                    '2011' => '\\ccxt\\BadRequest',
                    '2012' => '\\ccxt\\BadRequest',
                    '2013' => '\\ccxt\\InvalidOrder',
                    '2014' => '\\ccxt\\PermissionDenied',
                    '2015' => '\\ccxt\\InvalidOrder',
                    '2016' => '\\ccxt\\InvalidOrder',
                    '2017' => '\\ccxt\\InvalidOrder',
                    '2019' => '\\ccxt\\InvalidOrder',
                    '2020' => '\\ccxt\\InvalidOrder',
                    '2021' => '\\ccxt\\InvalidOrder',
                    '2022' => '\\ccxt\\InvalidOrder',
                    '2023' => '\\ccxt\\InvalidOrder',
                    '2024' => '\\ccxt\\InsufficientFunds',
                    '2025' => '\\ccxt\\InsufficientFunds',
                    '2026' => '\\ccxt\\BadRequest',
                    '2027' => '\\ccxt\\AuthenticationError',
                    '2028' => '\\ccxt\\AuthenticationError',
                    '2029' => '\\ccxt\\AuthenticationError',
                    '2030' => '\\ccxt\\BadRequest',
                    '2031' => '\\ccxt\\InvalidOrder',
                    '2033' => '\\ccxt\\InvalidOrder',
                    '2034' => '\\ccxt\\InvalidOrder',
                    '2035' => '\\ccxt\\InvalidOrder',
                    '2036' => '\\ccxt\\InvalidOrder',
                    '2037' => '\\ccxt\\InvalidOrder',
                    '2038' => '\\ccxt\\InvalidOrder',
                    '2039' => '\\ccxt\\InvalidOrder',
                    '2040' => '\\ccxt\\InvalidOrder',
                    '2041' => '\\ccxt\\InvalidOrder',
                    '2042' => '\\ccxt\\InvalidOrder',
                    '2043' => '\\ccxt\\InvalidOrder',
                    '2044' => '\\ccxt\\InvalidOrder',
                    '2045' => '\\ccxt\\InvalidOrder',
                    '2046' => '\\ccxt\\InvalidOrder',
                    '2047' => '\\ccxt\\InvalidOrder',
                    '2048' => '\\ccxt\\InvalidOrder',
                    '2049' => '\\ccxt\\ExchangeError',
                    '2050' => '\\ccxt\\PermissionDenied',
                    '2051' => '\\ccxt\\InvalidOrder',
                    '2052' => '\\ccxt\\InvalidOrder',
                    '2053' => '\\ccxt\\InvalidOrder',
                    '2054' => '\\ccxt\\InvalidOrder',
                    '2055' => '\\ccxt\\InvalidOrder',
                    '2056' => '\\ccxt\\InvalidOrder',
                    '2057' => '\\ccxt\\InvalidOrder',
                    '2058' => '\\ccxt\\InvalidOrder',
                    '2059' => '\\ccxt\\InvalidOrder',
                    '2060' => '\\ccxt\\InvalidOrder',
                    '2061' => '\\ccxt\\InvalidOrder',
                    '2062' => '\\ccxt\\InvalidOrder',
                    '2063' => '\\ccxt\\InvalidOrder',
                    '2064' => '\\ccxt\\InvalidOrder',
                    '2065' => '\\ccxt\\InvalidOrder',
                    '2066' => '\\ccxt\\InvalidOrder',
                    '2067' => '\\ccxt\\InvalidOrder',
                    '2068' => '\\ccxt\\InvalidOrder',
                    '2069' => '\\ccxt\\InvalidOrder',
                    '2070' => '\\ccxt\\InvalidOrder',
                    '2071' => '\\ccxt\\InvalidOrder',
                    '2072' => '\\ccxt\\InvalidOrder',
                    '2073' => '\\ccxt\\InvalidOrder',
                    '2074' => '\\ccxt\\InvalidOrder',
                    '2075' => '\\ccxt\\InvalidOrder',
                    '2076' => '\\ccxt\\InvalidOrder',
                    '3000' => '\\ccxt\\BadRequest',
                    '3001' => '\\ccxt\\BadRequest',
                    '3002' => '\\ccxt\\BadRequest',
                    '3003' => '\\ccxt\\BadRequest',
                    '4000' => '\\ccxt\\BadRequest',
                    '4001' => '\\ccxt\\ExchangeError',
                    '4002' => '\\ccxt\\ExchangeError',
                    '4003' => '\\ccxt\\ExchangeError',
                    '4004' => '\\ccxt\\InvalidOrder',
                    '5000' => '\\ccxt\\ExchangeError',
                ),
                'broad' => array(
                ),
            ),
            'precisionMode' => TICK_SIZE,
            'commonCurrencies' => array(
            ),
            'options' => array(
                'defaultType' => 'swap',
                'sandboxMode' => false,
                'timeDifference' => 0, // the difference between system clock and exchange server clock
                'brokerId' => 5930043274845996,
            ),
        ));
    }

    public function set_sandbox_mode($enabled) {
        parent::set_sandbox_mode($enabled);
        $this->options['sandboxMode'] = $enabled;
    }

    public function convert_to_x18($num) {
        if (gettype($num) === 'string') {
            return Precise::string_mul($num, '1000000000000000000');
        }
        $numStr = $this->number_to_string($num);
        return Precise::string_mul($numStr, '1000000000000000000');
    }

    public function convert_from_x18($num) {
        if (gettype($num) === 'string') {
            return Precise::string_div($num, '1000000000000000000');
        }
        $numStr = $this->number_to_string($num);
        return Precise::string_div($numStr, '1000000000000000000');
    }

    public function fetch_currencies($params = array ()): ?array {
        /**
         * fetches all available currencies on an exchange
         *
         * @see https://docs.vertexprotocol.com/developer-resources/api/v2/assets
         *
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @return {array} an associative dictionary of currencies
         */
        $request = array();
        $response = $this->v2GatewayGetAssets ($this->extend($request, $params));
        //
        // array(
        //     array(
        //         "product_id" => 2,
        //         "ticker_id" => "BTC-PERP_USDC",
        //         "market_type" => "perp",
        //         "name" => "Bitcoin Perp",
        //         "symbol" => "BTC-PERP",
        //         "maker_fee" => 0.0002,
        //         "taker_fee" => 0,
        //         "can_withdraw" => false,
        //         "can_deposit" => false
        //     ),
        //     {
        //         "product_id" => 1,
        //         "ticker_id" => "BTC_USDC",
        //         "market_type" => "spot",
        //         "name" => "Bitcoin",
        //         "symbol" => "BTC",
        //         "taker_fee" => 0.0003,
        //         "maker_fee" => 0,
        //         "can_withdraw" => true,
        //         "can_deposit" => true
        //     }
        // )
        //
        $result = array();
        for ($i = 0; $i < count($response); $i++) {
            $data = $this->safe_dict($response, $i, array());
            $tickerId = $this->safe_string($data, 'ticker_id');
            if (($tickerId !== null) && (mb_strpos($tickerId, 'PERP') > 0)) {
                continue;
            }
            $id = $this->safe_string($data, 'product_id');
            $name = $this->safe_string($data, 'symbol');
            $code = $this->safe_currency_code($name);
            $result[$code] = array(
                'id' => $id,
                'name' => $name,
                'code' => $code,
                'precision' => null,
                'info' => $data,
                'active' => null,
                'deposit' => $this->safe_bool($data, 'can_deposit'),
                'withdraw' => $this->safe_bool($data, 'can_withdraw'),
                'networks' => null,
                'fee' => null,
                'limits' => array(
                    'amount' => array(
                        'min' => null,
                        'max' => null,
                    ),
                    'withdraw' => array(
                        'min' => null,
                        'max' => null,
                    ),
                ),
            );
        }
        return $result;
    }

    public function parse_market($market): array {
        //
        // {
        //     "type" => "spot",
        //     "product_id" => 3,
        //     "symbol" => "WETH",
        //     "price_increment_x18" => "100000000000000000",
        //     "size_increment" => "10000000000000000",
        //     "min_size" => "100000000000000000",
        //     "min_depth_x18" => "5000000000000000000000",
        //     "max_spread_rate_x18" => "2000000000000000",
        //     "maker_fee_rate_x18" => "0",
        //     "taker_fee_rate_x18" => "300000000000000",
        //     "long_weight_initial_x18" => "900000000000000000",
        //     "long_weight_maintenance_x18" => "950000000000000000"
        // }
        //
        $marketType = $this->safe_string($market, 'type');
        $quoteId = 'USDC';
        $quote = $this->safe_currency_code($quoteId);
        $baseId = $this->safe_string($market, 'symbol');
        $base = $this->safe_currency_code($baseId);
        $settleId = $quoteId;
        $settle = $this->safe_currency_code($settleId);
        $symbol = $base . '/' . $quote;
        $spot = $marketType === 'spot';
        $contract = !$spot;
        $swap = !$spot;
        if ($swap) {
            $splitSymbol = explode('-', $base);
            $symbol = $splitSymbol[0] . '/' . $quote . ':' . $settle;
        }
        $priceIncrementX18 = $this->safe_string($market, 'price_increment_x18');
        $sizeIncrementX18 = $this->safe_string($market, 'size_increment');
        $minSizeX18 = $this->safe_string($market, 'min_size');
        $takerX18 = $this->safe_number($market, 'taker_fee_rate_x18');
        $makerX18 = $this->safe_number($market, 'maker_fee_rate_x18');
        $isInverse = ($spot) ? null : false;
        $isLinear = ($spot) ? null : true;
        $contractSize = ($spot) ? null : $this->parse_number('1');
        return array(
            'id' => $this->safe_string($market, 'product_id'),
            'symbol' => $symbol,
            'base' => $base,
            'quote' => $quote,
            'settle' => ($spot) ? null : $settle,
            'baseId' => $baseId,
            'quoteId' => $quoteId,
            'settleId' => ($spot) ? null : $settleId,
            'type' => ($spot) ? 'spot' : 'swap',
            'spot' => $spot,
            'margin' => null,
            'swap' => $swap,
            'future' => false,
            'option' => false,
            'active' => true,
            'contract' => $contract,
            'linear' => $isLinear,
            'inverse' => $isInverse,
            'taker' => $this->parse_number($this->convert_from_x18($takerX18)),
            'maker' => $this->parse_number($this->convert_from_x18($makerX18)),
            'contractSize' => $contractSize,
            'expiry' => null,
            'expiryDatetime' => null,
            'strike' => null,
            'optionType' => null,
            'precision' => array(
                'amount' => $this->parse_number($this->convert_from_x18($sizeIncrementX18)),
                'price' => $this->parse_number($this->convert_from_x18($priceIncrementX18)),
            ),
            'limits' => array(
                'leverage' => array(
                    'min' => null,
                    'max' => null,
                ),
                'amount' => array(
                    'min' => $this->parse_number($this->convert_from_x18($minSizeX18)),
                    'max' => null,
                ),
                'price' => array(
                    'min' => null,
                    'max' => null,
                ),
                'cost' => array(
                    'min' => null,
                    'max' => null,
                ),
            ),
            'created' => null,
            'info' => $market,
        );
    }

    public function fetch_markets($params = array ()): array {
        /**
         * retrieves $data on all $markets for vertex
         *
         * @see https://docs.vertexprotocol.com/developer-resources/api/gateway/queries/symbols
         *
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @return {array[]} an array of objects representing market $data
         */
        $request = array(
            'type' => 'symbols',
        );
        $response = $this->v1GatewayGetQuery ($this->extend($request, $params));
        //
        // {
        //     "status" => "success",
        //     "data" => {
        //         "symbols" => {
        //             "WETH" => array(
        //                 "type" => "spot",
        //                 "product_id" => 3,
        //                 "symbol" => "WETH",
        //                 "price_increment_x18" => "100000000000000000",
        //                 "size_increment" => "10000000000000000",
        //                 "min_size" => "100000000000000000",
        //                 "min_depth_x18" => "5000000000000000000000",
        //                 "max_spread_rate_x18" => "2000000000000000",
        //                 "maker_fee_rate_x18" => "0",
        //                 "taker_fee_rate_x18" => "300000000000000",
        //                 "long_weight_initial_x18" => "900000000000000000",
        //                 "long_weight_maintenance_x18" => "950000000000000000"
        //             }
        //         }
        //     ),
        //     "request_type" => "query_symbols"
        // }
        //
        $data = $this->safe_dict($response, 'data', array());
        $markets = $this->safe_dict($data, 'symbols', array());
        $symbols = is_array($markets) ? array_keys($markets) : array();
        $result = array();
        for ($i = 0; $i < count($symbols); $i++) {
            $symbol = $symbols[$i];
            $rawMarket = $this->safe_dict($markets, $symbol, array());
            $result[] = $this->parse_market($rawMarket);
        }
        return $result;
    }

    public function fetch_time($params = array ()) {
        /**
         * fetches the current integer timestamp in milliseconds from the exchange server
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @return {int} the current integer timestamp in milliseconds from the exchange server
         */
        $response = $this->v1GatewayGetTime ($params);
        // 1717481623452
        return $this->parse_number($response);
    }

    public function fetch_status($params = array ()) {
        /**
         * the latest known information on the availability of the exchange API
         *
         * @see https://docs.vertexprotocol.com/developer-resources/api/gateway/queries/status
         *
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @return {array} a ~@link https://docs.ccxt.com/#/?id=exchange-$status-structure $status structure~
         */
        $request = array(
            'type' => 'status',
        );
        $response = $this->v1GatewayGetQuery ($this->extend($request, $params));
        //
        // {
        //     "status" => "success",
        //     "data" => "active",
        //     "request_type" => "query_status",
        // }
        //
        $status = $this->safe_string($response, 'data');
        if ($status === 'active') {
            $status = 'ok';
        } else {
            $status = 'error';
        }
        return array(
            'status' => $status,
            'updated' => null,
            'eta' => null,
            'url' => null,
            'info' => $response,
        );
    }

    public function parse_trade($trade, ?array $market = null): array {
        //
        // {
        //       "ticker_id" => "ARB_USDC",
        //       "trade_id" => 999994,
        //       "price" => 1.1366122408151016,
        //       "base_filled" => 175,
        //       "quote_filled" => -198.90714214264278,
        //       "timestamp" => 1691068943,
        //       "trade_type" => "buy"
        // }
        // fetchMytrades
        // {
        //     "digest" => "0x80ce789702b670b7d33f2aa67e12c85f124395c3f9acdb422dde3b4973ccd50c",
        //     "order" => array(
        //         "sender" => "0x12a0b4888021576eb10a67616dd3dd3d9ce206b664656661756c740000000000",
        //         "priceX18" => "27544000000000000000000",
        //         "amount" => "2000000000000000000",
        //         "expiration" => "4611686020107119633",
        //         "nonce" => "1761322608857448448"
        //     ),
        //     "base_filled" => "736000000000000000",
        //     "quote_filled" => "-20276464287857571514302",
        //     "fee" => "4055287857571514302",
        //     "sequencer_fee" => "0"
        //     "cumulative_fee" => "4055287857571514302",
        //     "cumulative_base_filled" => "736000000000000000",
        //     "cumulative_quote_filled" => "-20276464287857571514302",
        //     "submission_idx" => "563012",
        //     "pre_balance" => {
        //       "base" => {
        //         "perp" => array(
        //           "product_id" => 2,
        //           "lp_balance" => array(
        //             "amount" => "0",
        //             "last_cumulative_funding_x18" => "1823351297710837"
        //           ),
        //           "balance" => array(
        //             "amount" => "2686684000000000000000",
        //             "v_quote_balance" => "-76348662407149297671587247",
        //             "last_cumulative_funding_x18" => "134999841911604906604576"
        //           }
        //         }
        //       ),
        //       "quote" => null
        //     ),
        //     "post_balance" => {
        //       "base" => {
        //         "perp" => {
        //           "product_id" => 2,
        //           "lp_balance" => array(
        //             "amount" => "0",
        //             "last_cumulative_funding_x18" => "1823351297710837"
        //           ),
        //           "balance" => array(
        //             "amount" => "2686013000000000000000",
        //             "v_quote_balance" => "-76328351274188497671587247",
        //             "last_cumulative_funding_x18" => "134999841911604906604576"
        //           }
        //         }
        //       ),
        //       "quote" => null
        //     }
        //   }
        $price = null;
        $amount = null;
        $side = null;
        $fee = null;
        $feeCost = $this->convert_from_x18($this->safe_string($trade, 'fee'));
        if ($feeCost !== null) {
            $fee = array(
                'cost' => $feeCost,
                'currency' => null,
            );
        }
        $id = $this->safe_string_2($trade, 'trade_id', 'submission_idx');
        $order = $this->safe_string($trade, 'digest');
        $timestamp = $this->safe_timestamp($trade, 'timestamp');
        if ($timestamp === null) {
            // fetchMyTrades
            $baseBalance = $this->safe_dict($this->safe_dict($trade, 'pre_balance', array()), 'base', array());
            $marketId = null;
            if (is_array($baseBalance) && array_key_exists('perp', $baseBalance)) {
                $marketId = $this->safe_string($this->safe_dict($baseBalance, 'perp', array()), 'product_id');
            } else {
                $marketId = $this->safe_string($this->safe_dict($baseBalance, 'spot', array()), 'product_id');
            }
            $market = $this->safe_market($marketId);
            $subOrder = $this->safe_dict($trade, 'order', array());
            $price = $this->convert_from_x18($this->safe_string($subOrder, 'priceX18'));
            $amount = $this->convert_from_x18($this->safe_string($trade, 'base_filled'));
            if (Precise::string_lt($amount, '0')) {
                $side = 'sell';
            } else {
                $side = 'buy';
            }
        } else {
            $tickerId = $this->safe_string($trade, 'ticker_id');
            $splitTickerId = explode('_', $tickerId);
            $splitSymbol = explode('-', $splitTickerId[0]);
            $marketId = $splitSymbol[0] . $splitTickerId[1];
            $market = $this->safe_market($marketId, $market);
            $price = $this->safe_string($trade, 'price');
            $amount = $this->safe_string($trade, 'base_filled');
            $side = $this->safe_string_lower($trade, 'trade_type');
        }
        $amount = Precise::string_abs($amount);
        $symbol = $market['symbol'];
        return $this->safe_trade(array(
            'id' => $id,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'symbol' => $symbol,
            'side' => $side,
            'price' => $price,
            'amount' => $amount,
            'cost' => null,
            'order' => $order,
            'takerOrMaker' => null,
            'type' => null,
            'fee' => $fee,
            'info' => $trade,
        ), $market);
    }

    public function fetch_trades(string $symbol, ?int $since = null, ?int $limit = null, $params = array ()): array {
        /**
         * get the list of most recent trades for a particular $symbol
         *
         * @see https://docs.vertexprotocol.com/developer-resources/api/v2/trades
         *
         * @param {string} $symbol unified $symbol of the $market to fetch trades for
         * @param {int} [$since] timestamp in ms of the earliest trade to fetch
         * @param {int} [$limit] the maximum amount of trades to fetch
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @return {Trade[]} a list of ~@link https://docs.ccxt.com/#/?id=public-trades trade structures~
         */
        $this->load_markets();
        $market = $this->market($symbol);
        $marketId = $market['baseId'] . '_USDC';
        $request = array(
            'ticker_id' => $marketId,
        );
        if ($limit !== null) {
            $request['limit'] = $limit;
        }
        $response = $this->v2ArchiveGetTrades ($this->extend($request, $params));
        //
        // array(
        //     array(
        //       "ticker_id" => "ARB_USDC",
        //       "trade_id" => 999994,
        //       "price" => 1.1366122408151016,
        //       "base_filled" => 175,
        //       "quote_filled" => -198.90714214264278,
        //       "timestamp" => 1691068943,
        //       "trade_type" => "buy"
        //     ),
        //     {
        //       "ticker_id" => "ARB_USDC",
        //       "trade_id" => 999978,
        //       "price" => 1.136512210806099,
        //       "base_filled" => 175,
        //       "quote_filled" => -198.8896368910673,
        //       "timestamp" => 1691068882,
        //       "trade_type" => "buy"
        //     }
        // )
        //
        return $this->parse_trades($response, $market, $since, $limit);
    }

    public function fetch_my_trades(?string $symbol = null, ?int $since = null, ?int $limit = null, $params = array ()) {
        /**
         * fetch all $trades made by the user
         *
         * @see https://docs.vertexprotocol.com/developer-resources/api/archive-indexer/matches
         *
         * @param {string} $symbol unified $market $symbol
         * @param {int} [$since] the earliest time in ms to fetch $trades for
         * @param {int} [$limit] the maximum number of $trades structures to retrieve
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @param {string} [$params->user] user address, will default to $this->walletAddress if not provided
         * @return {Trade[]} a list of ~@link https://docs.ccxt.com/#/?id=trade-structure trade structures~
         */
        $this->load_markets();
        $userAddress = null;
        list($userAddress, $params) = $this->handle_public_address('fetchMyTrades', $params);
        $market = null;
        $matchesRequest = array(
            'subaccount' => $this->convert_address_to_sender($userAddress),
        );
        if ($symbol !== null) {
            $market = $this->market($symbol);
            $matchesRequest['product_ids'] = [ $this->parse_to_numeric($market['id']) ];
        }
        $until = $this->safe_integer($params, 'until');
        if ($until !== null) {
            $params = $this->omit($params, 'until');
            $matchesRequest['max_time'] = $until;
        }
        if ($limit !== null) {
            $matchesRequest['limit'] = $limit;
        }
        $request = array(
            'matches' => $matchesRequest,
        );
        $response = $this->v1ArchivePost ($this->extend($request, $params));
        //
        // {
        //     "matches" => array(
        //       {
        //         "digest" => "0x80ce789702b670b7d33f2aa67e12c85f124395c3f9acdb422dde3b4973ccd50c",
        //         "order" => array(
        //           "sender" => "0x12a0b4888021576eb10a67616dd3dd3d9ce206b664656661756c740000000000",
        //           "priceX18" => "27544000000000000000000",
        //           "amount" => "2000000000000000000",
        //           "expiration" => "4611686020107119633",
        //           "nonce" => "1761322608857448448"
        //         ),
        //         "base_filled" => "736000000000000000",
        //         "quote_filled" => "-20276464287857571514302",
        //         "fee" => "4055287857571514302",
        //         "sequencer_fee" => "0"
        //         "cumulative_fee" => "4055287857571514302",
        //         "cumulative_base_filled" => "736000000000000000",
        //         "cumulative_quote_filled" => "-20276464287857571514302",
        //         "submission_idx" => "563012",
        //         "pre_balance" => {
        //           "base" => {
        //             "perp" => array(
        //               "product_id" => 2,
        //               "lp_balance" => array(
        //                 "amount" => "0",
        //                 "last_cumulative_funding_x18" => "1823351297710837"
        //               ),
        //               "balance" => array(
        //                 "amount" => "2686684000000000000000",
        //                 "v_quote_balance" => "-76348662407149297671587247",
        //                 "last_cumulative_funding_x18" => "134999841911604906604576"
        //               }
        //             }
        //           ),
        //           "quote" => null
        //         ),
        //         "post_balance" => {
        //           "base" => {
        //             "perp" => array(
        //               "product_id" => 2,
        //               "lp_balance" => array(
        //                 "amount" => "0",
        //                 "last_cumulative_funding_x18" => "1823351297710837"
        //               ),
        //               "balance" => array(
        //                 "amount" => "2686013000000000000000",
        //                 "v_quote_balance" => "-76328351274188497671587247",
        //                 "last_cumulative_funding_x18" => "134999841911604906604576"
        //               }
        //             }
        //           ),
        //           "quote" => null
        //         }
        //       ),
        //       {
        //         "digest" => "0x0f6e5a0434e36d8e6d4fed950d3624b0d8c91a8a84efd156bb25c1382561c0c2",
        //         "order" => array(
        //           "sender" => "0x12a0b4888021576eb10a67616dd3dd3d9ce206b664656661756c740000000000",
        //           "priceX18" => "27540000000000000000000",
        //           "amount" => "2000000000000000000",
        //           "expiration" => "4611686020107119623",
        //           "nonce" => "1761322602510417920"
        //         ),
        //         "base_filled" => "723999999999999999",
        //         "quote_filled" => "-19944943483044913474043",
        //         "fee" => "5983483044913474042",
        //         "cumulative_fee" => "11958484645393618085",
        //         "cumulative_base_filled" => "1446999999999999998",
        //         "cumulative_quote_filled" => "-39861640484645393618087",
        //         "submission_idx" => "563011",
        //         "pre_balance" => {
        //           "base" => {
        //             "perp" => array(
        //               "product_id" => 2,
        //               "lp_balance" => array(
        //                 "amount" => "0",
        //                 "last_cumulative_funding_x18" => "1823351297710837"
        //               ),
        //               "balance" => array(
        //                 "amount" => "2686684000000000000000",
        //                 "v_quote_balance" => "-76348662407149297671587247",
        //                 "last_cumulative_funding_x18" => "134999841911604906604576"
        //               }
        //             }
        //           ),
        //           "quote" => null
        //         ),
        //         "post_balance" => {
        //           "base" => {
        //             "perp" => {
        //               "product_id" => 2,
        //               "lp_balance" => array(
        //                 "amount" => "0",
        //                 "last_cumulative_funding_x18" => "1823351297710837"
        //               ),
        //               "balance" => array(
        //                 "amount" => "2686013000000000000000",
        //                 "v_quote_balance" => "-76328351274188497671587247",
        //                 "last_cumulative_funding_x18" => "134999841911604906604576"
        //               }
        //             }
        //           ),
        //           "quote" => null
        //         }
        //       }
        //     ),
        //     "txs" => array(
        //       {
        //         "tx" => {
        //           "match_orders" => array(
        //             "product_id" => 2,
        //             "amm" => true,
        //             "taker" => array(
        //               "order" => array(
        //                 "sender" => "0x12a0b4888021576eb10a67616dd3dd3d9ce206b664656661756c740000000000",
        //                 "price_x18" => "27544000000000000000000",
        //                 "amount" => "2000000000000000000",
        //                 "expiration" => 4611686020107120000,
        //                 "nonce" => 1761322608857448400
        //               ),
        //               "signature" => "0xe8fa7151bde348afa3b46dc52798046b7c8318f1b0a7f689710debbc094658cc1bf5a7e478ccc8278b625da0b9402c86b580d2e31e13831337dfd6153f4b37811b"
        //             ),
        //             "maker" => array(
        //               "order" => array(
        //                 "sender" => "0xebdbbcdbd2646c5f23a1e0806027eee5f71b074664656661756c740000000000",
        //                 "price_x18" => "27544000000000000000000",
        //                 "amount" => "-736000000000000000",
        //                 "expiration" => 1679731669,
        //                 "nonce" => 1761322585591644200
        //               ),
        //               "signature" => "0x47f9d47f0777f3ca0b13f07b7682dbeea098c0e377b87dcb025754fe34c900e336b8c7744e021fb9c46a4f8c6a1478bafa28bf0d023ae496aa3efa4d8e81df181c"
        //             }
        //           }
        //         ),
        //         "submission_idx" => "563012",
        //         "timestamp" => "1679728133"
        //       ),
        //       {
        //         "tx" => {
        //           "match_orders" => {
        //             "product_id" => 1,
        //             "amm" => true,
        //             "taker" => array(
        //               "order" => array(
        //                 "sender" => "0x12a0b4888021576eb10a67616dd3dd3d9ce206b664656661756c740000000000",
        //                 "price_x18" => "27540000000000000000000",
        //                 "amount" => "2000000000000000000",
        //                 "expiration" => 4611686020107120000,
        //                 "nonce" => 1761322602510418000
        //               ),
        //               "signature" => "0x826c68f1a3f76d9ffbe8041f8d45e969d31f1ab6f2ae2f6379d1493e479e56436091d6cf4c72e212dd2f1d2fa17c627c4c21bd6d281c77172b8af030488478b71c"
        //             ),
        //             "maker" => array(
        //               "order" => array(
        //                 "sender" => "0xf8d240d9514c9a4715d66268d7af3b53d619642564656661756c740000000000",
        //                 "price_x18" => "27540000000000000000000",
        //                 "amount" => "-724000000000000000",
        //                 "expiration" => 1679731656,
        //                 "nonce" => 1761322565506171000
        //               ),
        //               "signature" => "0xd8b6505b8d9b8c3cbfe793080976388035682c02a27893fb26b48a5b2bfe943f4162dea3a42e24e0dff5e2f74fbf77e33d83619140a2a581117c55e6cc236bdb1c"
        //             }
        //           }
        //         ),
        //         "submission_idx" => "563011",
        //         "timestamp" => "1679728127"
        //       }
        //     )
        // }
        //
        $trades = $this->safe_list($response, 'matches', array());
        return $this->parse_trades($trades, $market, $since, $limit, $params);
    }

    public function fetch_order_book(string $symbol, ?int $limit = null, $params = array ()): array {
        /**
         * fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
         *
         * @see https://docs.vertexprotocol.com/developer-resources/api/v2/orderbook
         *
         * @param {string} $symbol unified $symbol of the $market to fetch the order book for
         * @param {int} [$limit] the maximum amount of order book entries to return
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @return {array} A dictionary of ~@link https://docs.ccxt.com/#/?id=order-book-structure order book structures~ indexed by $market symbols
         */
        $this->load_markets();
        $market = $this->market($symbol);
        $marketId = $market['baseId'] . '_USDC';
        if ($limit === null) {
            $limit = 100;
        }
        $request = array(
            'ticker_id' => $marketId,
            'depth' => $limit,
        );
        $response = $this->v2GatewayGetOrderbook ($this->extend($request, $params));
        //
        // {
        //     "ticker_id" => "ETH-PERP_USDC",
        //     "bids" => array(
        //         array(
        //             1612.3,
        //             0.31
        //         ),
        //         array(
        //             1612.0,
        //             0.93
        //         ),
        //         array(
        //             1611.5,
        //             1.55
        //         ),
        //         array(
        //             1610.8,
        //             2.17
        //         )
        //     ),
        //     "asks" => array(
        //         array(
        //             1612.9,
        //             0.93
        //         ),
        //         array(
        //             1613.4,
        //             1.55
        //         ),
        //         array(
        //             1614.1,
        //             2.17
        //         )
        //     ),
        //     "timestamp" => 1694375362016
        // }
        //
        $timestamp = $this->safe_integer($response, 'timestamp');
        return $this->parse_order_book($response, $symbol, $timestamp, 'bids', 'asks');
    }

    public function fetch_trading_fees($params = array ()): array {
        /**
         * fetch the trading fees for multiple markets
         *
         * @see https://docs.vertexprotocol.com/developer-resources/api/gateway/queries/fee-rates
         *
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @param {string} [$params->user] user address, will default to $this->walletAddress if not provided
         * @return {array} a dictionary of ~@link https://docs.ccxt.com/#/?id=fee-structure fee structures~ indexed by $market symbols
         */
        $this->load_markets();
        $userAddress = null;
        list($userAddress, $params) = $this->handle_public_address('fetchTradingFees', $params);
        $request = array(
            'type' => 'fee_rates',
            'sender' => $this->convert_address_to_sender($userAddress),
        );
        $response = $this->v1GatewayGetQuery ($this->extend($request, $params));
        //
        // {
        //     "status" => "success",
        //     "data" => array(
        //       "taker_fee_rates_x18" => array(
        //         "0",
        //         "300000000000000",
        //         "200000000000000",
        //         "300000000000000",
        //         "200000000000000"
        //       ),
        //       "maker_fee_rates_x18" => array(
        //         "0",
        //         "0",
        //         "0",
        //         "0",
        //         "0"
        //       ),
        //       "liquidation_sequencer_fee" => "250000000000000000",
        //       "health_check_sequencer_fee" => "100000000000000000",
        //       "taker_sequencer_fee" => "25000000000000000",
        //       "withdraw_sequencer_fees" => array(
        //         "10000000000000000",
        //         "40000000000000",
        //         "0",
        //         "600000000000000",
        //         "0"
        //       )
        //     ),
        //     "request_type" => "query_fee_rates",
        // }
        //
        $data = $this->safe_dict($response, 'data', array());
        $maker = $this->safe_list($data, 'maker_fee_rates_x18', array());
        $taker = $this->safe_list($data, 'taker_fee_rates_x18', array());
        $result = array();
        for ($i = 0; $i < count($taker); $i++) {
            $market = $this->safe_market($this->number_to_string($i));
            if ($market['id'] === null) {
                continue;
            }
            $symbol = $market['symbol'];
            $result[$symbol] = array(
                'info' => $response,
                'symbol' => $symbol,
                'maker' => $this->parse_number($this->convert_from_x18($maker[$i])),
                'taker' => $this->parse_number($this->convert_from_x18($taker[$i])),
                'percentage' => true,
                'tierBased' => false,
            );
        }
        return $result;
    }

    public function parse_ohlcv($ohlcv, ?array $market = null): array {
        // example response in fetchOHLCV
        return array(
            $this->safe_timestamp($ohlcv, 'timestamp'),
            $this->parse_number($this->convert_from_x18($this->safe_string($ohlcv, 'open_x18'))),
            $this->parse_number($this->convert_from_x18($this->safe_string($ohlcv, 'high_x18'))),
            $this->parse_number($this->convert_from_x18($this->safe_string($ohlcv, 'low_x18'))),
            $this->parse_number($this->convert_from_x18($this->safe_string($ohlcv, 'close_x18'))),
            $this->parse_number($this->convert_from_x18($this->safe_string($ohlcv, 'volume'))),
        );
    }

    public function fetch_ohlcv(string $symbol, $timeframe = '1m', ?int $since = null, ?int $limit = null, $params = array ()): array {
        /**
         *
         * @see https://docs.vertexprotocol.com/developer-resources/api/archive-indexer/candlesticks
         *
         * fetches historical candlestick data containing the open, high, low, and close price, and the volume of a $market
         * @param {string} $symbol unified $symbol of the $market to fetch OHLCV data for
         * @param {string} $timeframe the length of time each candle represents
         * @param {int} [$since] timestamp in ms of the earliest candle to fetch
         * @param {int} [$limit] max=1000, max=100 when $since is defined and is less than (now - (999 * (is_array(ms) && array_key_exists($timeframe, ms))))
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @return {int[][]} A list of candles ordered, open, high, low, close, volume
         */
        $this->load_markets();
        $market = $this->market($symbol);
        $ohlcvRequest = array(
            'product_id' => $this->parse_to_int($market['id']),
            'granularity' => $this->safe_integer($this->timeframes, $timeframe),
        );
        $until = $this->safe_integer($params, 'until');
        if ($until !== null) {
            $params = $this->omit($params, 'until');
            $ohlcvRequest['max_time'] = $until;
        }
        if ($limit !== null) {
            $ohlcvRequest['limit'] = min ($limit, 1000);
        }
        $request = array(
            'candlesticks' => $ohlcvRequest,
        );
        $response = $this->v1ArchivePost ($this->extend($request, $params));
        //
        // {
        //     "candlesticks" => array(
        //       array(
        //         "product_id" => 1,
        //         "granularity" => 60,
        //         "submission_idx" => "627709",
        //         "timestamp" => "1680118140",
        //         "open_x18" => "27235000000000000000000",
        //         "high_x18" => "27298000000000000000000",
        //         "low_x18" => "27235000000000000000000",
        //         "close_x18" => "27298000000000000000000",
        //         "volume" => "1999999999999999998"
        //       ),
        //       {
        //         "product_id" => 1,
        //         "granularity" => 60,
        //         "submission_idx" => "627699",
        //         "timestamp" => "1680118080",
        //         "open_x18" => "27218000000000000000000",
        //         "high_x18" => "27245000000000000000000",
        //         "low_x18" => "27218000000000000000000",
        //         "close_x18" => "27245000000000000000000",
        //         "volume" => "11852999999999999995"
        //       }
        //     )
        // }
        //
        $rows = $this->safe_list($response, 'candlesticks', array());
        return $this->parse_ohlcvs($rows, $market, $timeframe, $since, $limit);
    }

    public function parse_funding_rate($ticker, ?array $market = null): array {
        //
        // {
        //     "product_id" => 4,
        //     "funding_rate_x18" => "2447900598160952",
        //     "update_time" => "1680116326"
        // }
        //
        // {
        //     "ETH-PERP_USDC" => {
        //         "ticker_id" => "ETH-PERP_USDC",
        //         "base_currency" => "ETH-PERP",
        //         "quote_currency" => "USDC",
        //         "last_price" => 1620.3,
        //         "base_volume" => 1309.2,
        //         "quote_volume" => 2117828.093867611,
        //         "product_type" => "perpetual",
        //         "contract_price" => 1620.372642114429,
        //         "contract_price_currency" => "USD",
        //         "open_interest" => 1635.2,
        //         "open_interest_usd" => 2649633.3443855145,
        //         "index_price" => 1623.293496279935,
        //         "mark_price" => 1623.398589416731,
        //         "funding_rate" => 0.000068613217104332,
        //         "next_funding_rate_timestamp" => 1694379600,
        //         "price_change_percent_24h" => -0.6348599635253989
        //     }
        // }
        //
        $fundingRate = $this->safe_number($ticker, 'funding_rate');
        if ($fundingRate === null) {
            $fundingRateX18 = $this->safe_string($ticker, 'funding_rate_x18');
            $fundingRate = $this->parse_number($this->convert_from_x18($fundingRateX18));
        }
        $fundingTimestamp = $this->safe_timestamp_2($ticker, 'update_time', 'next_funding_rate_timestamp');
        $markPrice = $this->safe_number($ticker, 'mark_price');
        $indexPrice = $this->safe_number($ticker, 'index_price');
        return array(
            'info' => $ticker,
            'symbol' => $market['symbol'],
            'markPrice' => $markPrice,
            'indexPrice' => $indexPrice,
            'interestRate' => null,
            'estimatedSettlePrice' => null,
            'timestamp' => null,
            'datetime' => null,
            'fundingRate' => $fundingRate,
            'fundingTimestamp' => $fundingTimestamp,
            'fundingDatetime' => $this->iso8601($fundingTimestamp),
            'nextFundingRate' => null,
            'nextFundingTimestamp' => null,
            'nextFundingDatetime' => null,
            'previousFundingRate' => null,
            'previousFundingTimestamp' => null,
            'previousFundingDatetime' => null,
            'interval' => null,
        );
    }

    public function fetch_funding_rate(string $symbol, $params = array ()): array {
        /**
         * fetch the current funding rate
         *
         * @see https://docs.vertexprotocol.com/developer-resources/api/archive-indexer/funding-rate
         *
         * @param {string} $symbol unified $market $symbol
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @return {array} a ~@link https://docs.ccxt.com/#/?id=funding-rate-structure funding rate structure~
         */
        $this->load_markets();
        $market = $this->market($symbol);
        $request = array(
            'funding_rate' => array(
                'product_id' => $this->parse_to_int($market['id']),
            ),
        );
        $response = $this->v1ArchivePost ($this->extend($request, $params));
        //
        // {
        //     "product_id" => 4,
        //     "funding_rate_x18" => "2447900598160952",
        //     "update_time" => "1680116326"
        // }
        //
        return $this->parse_funding_rate($response, $market);
    }

    public function fetch_funding_rates(?array $symbols = null, $params = array ()): array {
        /**
         * fetches funding rates for multiple markets
         *
         * @see https://docs.vertexprotocol.com/developer-resources/api/v2/contracts
         *
         * @param {string[]} $symbols unified $symbols of the markets to fetch the funding rates for, all $market funding rates are returned if not assigned
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @return {array[]} an array of ~@link https://docs.ccxt.com/#/?id=funding-rate-structure funding rate structures~
         */
        $this->load_markets();
        $request = array();
        if ($symbols !== null) {
            $symbols = $this->market_symbols($symbols);
        }
        $response = $this->v2ArchiveGetContracts ($this->extend($request, $params));
        //
        // {
        //     "ETH-PERP_USDC" => {
        //         "ticker_id" => "ETH-PERP_USDC",
        //         "base_currency" => "ETH-PERP",
        //         "quote_currency" => "USDC",
        //         "last_price" => 1620.3,
        //         "base_volume" => 1309.2,
        //         "quote_volume" => 2117828.093867611,
        //         "product_type" => "perpetual",
        //         "contract_price" => 1620.372642114429,
        //         "contract_price_currency" => "USD",
        //         "open_interest" => 1635.2,
        //         "open_interest_usd" => 2649633.3443855145,
        //         "index_price" => 1623.293496279935,
        //         "mark_price" => 1623.398589416731,
        //         "funding_rate" => 0.000068613217104332,
        //         "next_funding_rate_timestamp" => 1694379600,
        //         "price_change_percent_24h" => -0.6348599635253989
        //     }
        // }
        //
        $keys = is_array($response) ? array_keys($response) : array();
        $fundingRates = array();
        for ($i = 0; $i < count($keys); $i++) {
            $tickerId = $keys[$i];
            $parsedTickerId = explode('-', $tickerId);
            $data = $response[$tickerId];
            $marketId = $parsedTickerId[0] . '/USDC:USDC';
            $market = $this->market($marketId);
            $ticker = $this->parse_funding_rate($data, $market);
            $symbol = $ticker['symbol'];
            $fundingRates[$symbol] = $ticker;
        }
        return $this->filter_by_array($fundingRates, 'symbol', $symbols);
    }

    public function parse_open_interest($interest, ?array $market = null) {
        //
        // {
        //     "ETH-PERP_USDC" => {
        //         "ticker_id" => "ETH-PERP_USDC",
        //         "base_currency" => "ETH-PERP",
        //         "quote_currency" => "USDC",
        //         "last_price" => 1620.3,
        //         "base_volume" => 1309.2,
        //         "quote_volume" => 2117828.093867611,
        //         "product_type" => "perpetual",
        //         "contract_price" => 1620.372642114429,
        //         "contract_price_currency" => "USD",
        //         "open_interest" => 1635.2,
        //         "open_interest_usd" => 2649633.3443855145,
        //         "index_price" => 1623.293496279935,
        //         "mark_price" => 1623.398589416731,
        //         "funding_rate" => 0.000068613217104332,
        //         "next_funding_rate_timestamp" => 1694379600,
        //         "price_change_percent_24h" => -0.6348599635253989
        //     }
        // }
        //
        $value = $this->safe_number($interest, 'open_interest_usd');
        return $this->safe_open_interest(array(
            'symbol' => $market['symbol'],
            'openInterestAmount' => null,
            'openInterestValue' => $value,
            'timestamp' => null,
            'datetime' => null,
            'info' => $interest,
        ), $market);
    }

    public function fetch_open_interest(string $symbol, $params = array ()) {
        /**
         * Retrieves the open interest of a derivative trading pair
         *
         * @see https://docs.vertexprotocol.com/developer-resources/api/v2/contracts
         *
         * @param {string} $symbol Unified CCXT $market $symbol
         * @param {array} [$params] exchange specific parameters
         * @return {array} an open interest structurearray(@link https://docs.ccxt.com/#/?id=open-interest-structure)
         */
        $this->load_markets();
        $market = $this->market($symbol);
        if (!$market['contract']) {
            throw new BadRequest($this->id . ' fetchOpenInterest() supports contract markets only');
        }
        $request = array();
        $response = $this->v2ArchiveGetContracts ($this->extend($request, $params));
        //
        // {
        //     "ETH-PERP_USDC" => {
        //         "ticker_id" => "ETH-PERP_USDC",
        //         "base_currency" => "ETH-PERP",
        //         "quote_currency" => "USDC",
        //         "last_price" => 1620.3,
        //         "base_volume" => 1309.2,
        //         "quote_volume" => 2117828.093867611,
        //         "product_type" => "perpetual",
        //         "contract_price" => 1620.372642114429,
        //         "contract_price_currency" => "USD",
        //         "open_interest" => 1635.2,
        //         "open_interest_usd" => 2649633.3443855145,
        //         "index_price" => 1623.293496279935,
        //         "mark_price" => 1623.398589416731,
        //         "funding_rate" => 0.000068613217104332,
        //         "next_funding_rate_timestamp" => 1694379600,
        //         "price_change_percent_24h" => -0.6348599635253989
        //     }
        // }
        //
        $tickerId = $market['base'] . '_USDC';
        $openInterest = $this->safe_dict($response, $tickerId, array());
        return $this->parse_open_interest($openInterest, $market);
    }

    public function parse_ticker(array $ticker, ?array $market = null): array {
        //
        //     {
        //         "ticker_id" => "BTC_USDC",
        //         "base_currency" => "BTC",
        //         "quote_currency" => "USDC",
        //         "last_price" => 25728.0,
        //         "base_volume" => 552.048,
        //         "quote_volume" => 14238632.207250029,
        //         "price_change_percent_24h" => -0.6348599635253989
        //     }
        //
        $base = $this->safe_string($ticker, 'base_currency');
        $quote = $this->safe_string($ticker, 'quote_currency');
        $marketId = $base . '/' . $quote;
        if (mb_strpos($base, 'PERP') > 0) {
            $marketId = str_replace('-PERP', '', $marketId) . ':USDC';
        }
        $market = $this->market($marketId);
        $last = $this->safe_string($ticker, 'last_price');
        return $this->safe_ticker(array(
            'symbol' => $market['symbol'],
            'timestamp' => null,
            'datetime' => null,
            'high' => null,
            'low' => null,
            'bid' => null,
            'bidVolume' => null,
            'ask' => null,
            'askVolume' => null,
            'vwap' => null,
            'open' => null,
            'close' => $last,
            'last' => $last,
            'previousClose' => null,
            'change' => null,
            'percentage' => $this->safe_string($ticker, 'price_change_percent_24h'),
            'average' => null,
            'baseVolume' => $this->safe_string($ticker, 'base_volume'),
            'quoteVolume' => $this->safe_string($ticker, 'quote_volume'),
            'info' => $ticker,
        ), $market);
    }

    public function fetch_tickers(?array $symbols = null, $params = array ()): array {
        /**
         * fetches price $tickers for multiple markets, statistical information calculated over the past 24 hours for each market
         *
         * @see https://docs.vertexprotocol.com/developer-resources/api/v2/tickers
         *
         * @param {string[]} [$symbols] unified $symbols of the markets to fetch the ticker for, all market $tickers are returned if not assigned
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @return {array} a dictionary of ~@link https://docs.ccxt.com/#/?id=ticker-structure ticker structures~
         */
        $this->load_markets();
        $symbols = $this->market_symbols($symbols, null, true, true, true);
        $request = array();
        $response = $this->v2ArchiveGetTickers ($this->extend($request, $params));
        //
        // {
        //     "ETH_USDC" => array(
        //         "ticker_id" => "ETH_USDC",
        //         "base_currency" => "ETH",
        //         "quote_currency" => "USDC",
        //         "last_price" => 1619.1,
        //         "base_volume" => 1428.32,
        //         "quote_volume" => 2310648.316391866,
        //         "price_change_percent_24h" => -1.0509394462969588
        //     ),
        //     "BTC_USDC" => {
        //         "ticker_id" => "BTC_USDC",
        //         "base_currency" => "BTC",
        //         "quote_currency" => "USDC",
        //         "last_price" => 25728.0,
        //         "base_volume" => 552.048,
        //         "quote_volume" => 14238632.207250029,
        //         "price_change_percent_24h" => -0.6348599635253989
        //     }
        // }
        //
        $tickers = is_array($response) ? array_values($response) : array();
        return $this->parse_tickers($tickers, $symbols);
    }

    public function query_contracts($params = array ()): ?array {
        // query contract addresses for sending order
        $cachedContracts = $this->safe_dict($this->options, 'v1contracts');
        if ($cachedContracts !== null) {
            return $cachedContracts;
        }
        $request = array(
            'type' => 'contracts',
        );
        $response = $this->v1GatewayGetQuery ($this->extend($request, $params));
        $data = $this->safe_dict($response, 'data', array());
        $this->options['v1contracts'] = $data;
        return $data;
    }

    public function nonce() {
        return $this->milliseconds() - $this->options['timeDifference'];
    }

    public function hash_message($message) {
        return '0x' . $this->hash($message, 'keccak', 'hex');
    }

    public function sign_hash($hash, $privateKey) {
        $signature = $this->ecdsa(mb_substr($hash, -64), mb_substr($privateKey, -64), 'secp256k1', null);
        $r = $signature['r'];
        $s = $signature['s'];
        $v = $this->int_to_base16($this->sum(27, $signature['v']));
        return '0x' . str_pad($r, 64, '0', STR_PAD_LEFT) . str_pad($s, 64, '0', STR_PAD_LEFT) . $v;
    }

    public function sign_message($message, $privateKey) {
        return $this->sign_hash($this->hash_message($message), mb_substr($privateKey, -64));
    }

    public function build_sig($chainId, $messageTypes, $message, $verifyingContractAddress = '') {
        $domain = array(
            'chainId' => $chainId,
            'name' => 'Vertex',
            'verifyingContract' => $verifyingContractAddress,
            'version' => '0.0.1',
        );
        $msg = $this->eth_encode_structured_data($domain, $messageTypes, $message);
        $signature = $this->sign_message($msg, $this->privateKey);
        return $signature;
    }

    public function build_create_order_sig($message, $chainId, $verifyingContractAddress) {
        $messageTypes = array(
            'Order' => array(
                array( 'name' => 'sender', 'type' => 'bytes32' ),
                array( 'name' => 'priceX18', 'type' => 'int128' ),
                array( 'name' => 'amount', 'type' => 'int128' ),
                array( 'name' => 'expiration', 'type' => 'uint64' ),
                array( 'name' => 'nonce', 'type' => 'uint64' ),
            ),
        );
        return $this->build_sig($chainId, $messageTypes, $message, $verifyingContractAddress);
    }

    public function build_list_trigger_tx_sig($message, $chainId, $verifyingContractAddress) {
        $messageTypes = array(
            'ListTriggerOrders' => array(
                array( 'name' => 'sender', 'type' => 'bytes32' ),
                array( 'name' => 'recvTime', 'type' => 'uint64' ),
            ),
        );
        return $this->build_sig($chainId, $messageTypes, $message, $verifyingContractAddress);
    }

    public function build_cancel_all_orders_sig($message, $chainId, $verifyingContractAddress) {
        $messageTypes = array(
            'CancellationProducts' => [
                array( 'name' => 'sender', 'type' => 'bytes32' ),
                array( 'name' => 'productIds', 'type' => 'uint32[]' ),
                array( 'name' => 'nonce', 'type' => 'uint64' ),
            ],
        );
        return $this->build_sig($chainId, $messageTypes, $message, $verifyingContractAddress);
    }

    public function build_cancel_orders_sig($message, $chainId, $verifyingContractAddress) {
        $messageTypes = array(
            'Cancellation' => [
                array( 'name' => 'sender', 'type' => 'bytes32' ),
                array( 'name' => 'productIds', 'type' => 'uint32[]' ),
                array( 'name' => 'digests', 'type' => 'bytes32[]' ),
                array( 'name' => 'nonce', 'type' => 'uint64' ),
            ],
        );
        return $this->build_sig($chainId, $messageTypes, $message, $verifyingContractAddress);
    }

    public function build_withdraw_sig($message, $chainId, $verifyingContractAddress) {
        $messageTypes = array(
            'WithdrawCollateral' => array(
                array( 'name' => 'sender', 'type' => 'bytes32' ),
                array( 'name' => 'productId', 'type' => 'uint32' ),
                array( 'name' => 'amount', 'type' => 'uint128' ),
                array( 'name' => 'nonce', 'type' => 'uint64' ),
            ),
        );
        return $this->build_sig($chainId, $messageTypes, $message, $verifyingContractAddress);
    }

    public function convert_address_to_sender(string $address) {
        $sender = $address . '64656661756c74';
        return str_pad($sender, 66, '0', STR_PAD_RIGHT);
    }

    public function get_nonce($now, $expiration) {
        if ($now === null) {
            $now = $this->nonce();
        }
        // nonce = (($now . $expiration) << 20) + 1000
        // 1 << 20 = 1048576
        return Precise::string_add(Precise::string_mul(Precise::string_add($this->number_to_string($now), $this->number_to_string($expiration)), '1048576'), '1000');
    }

    public function get_expiration($now, $timeInForce, $postOnly, $reduceOnly) {
        $expiration = Precise::string_add($this->number_to_string($now), '86400');
        if ($timeInForce === 'ioc') {
            // 1 << 62 = 4611686018427387904
            $expiration = Precise::string_or($expiration, '4611686018427387904');
        } elseif ($timeInForce === 'fok') {
            // 2 << 62 = 9223372036854775808
            $expiration = Precise::string_or($expiration, '9223372036854775808');
        } elseif ($postOnly) {
            // 3 << 62 = 13835058055282163712
            $expiration = Precise::string_or($expiration, '13835058055282163712');
        }
        if ($reduceOnly) {
            // 1 << 61 = 2305843009213693952
            $expiration = Precise::string_or($expiration, '2305843009213693952');
        }
        return $expiration;
    }

    public function get_amount($amount, $side) {
        $amountString = $this->number_to_string($amount);
        if ($side === 'sell') {
            if ($amount > 0) {
                // $amount *= -1;
                $amountString = Precise::string_mul($amountString, '-1');
            }
        } else {
            if ($amount < 0) {
                // $amount *= -1;
                $amountString = Precise::string_mul($amountString, '-1');
            }
        }
        return $amountString;
    }

    public function create_order(string $symbol, string $type, string $side, float $amount, ?float $price = null, $params = array ()) {
        /**
         * create a trade $order
         *
         * @see https://docs.vertexprotocol.com/developer-resources/api/gateway/executes/place-$order
         * @see https://docs.vertexprotocol.com/developer-resources/api/trigger/executes/place-$order
         *
         * @param {string} $symbol unified $symbol of the $market to create an $order in
         * @param {string} $type 'market' or 'limit'
         * @param {string} $side 'buy' or 'sell'
         * @param {float} $amount how much of currency you want to trade in units of base currency
         * @param {float} [$price] the $price at which the $order is to be fulfilled, in units of the quote currency, ignored in $market orders
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @param {string} [$params->timeInForce] ioc, fok
         * @param {bool} [$params->postOnly] true or false whether the $order is post-only
         * @param {bool} [$params->reduceOnly] true or false whether the $order is reduce-only, only works for ioc and fok $order
         * @param {float} [$params->triggerPrice] The $price at which a $trigger $order is triggered at
         * @return {array} an ~@link https://docs.ccxt.com/#/?id=$order-structure $order structure~
         */
        $this->check_required_credentials();
        $marketType = strtolower($type);
        $isMarketOrder = $marketType === 'market';
        if ($isMarketOrder && $price === null) {
            throw new ArgumentsRequired($this->id . ' createOrder() requires a $price argument for $market order');
        }
        $this->load_markets();
        $market = $this->market($symbol);
        $marketId = $this->parse_to_int($market['id']);
        $contracts = $this->query_contracts();
        $chainId = $this->safe_string($contracts, 'chain_id');
        $bookAddresses = $this->safe_list($contracts, 'book_addrs', array());
        $verifyingContractAddress = $this->safe_string($bookAddresses, $marketId);
        $defaultTimeInForce = ($isMarketOrder) ? 'fok' : null;
        $timeInForce = $this->safe_string_lower($params, 'timeInForce', $defaultTimeInForce);
        $postOnly = $this->safe_bool($params, 'postOnly', false);
        $reduceOnly = $this->safe_bool($params, 'reduceOnly', false);
        $triggerPrice = $this->safe_string_2($params, 'triggerPrice', 'stopPrice');
        $stopLossPrice = $this->safe_string($params, 'stopLossPrice', $triggerPrice);
        $takeProfitPrice = $this->safe_string($params, 'takeProfitPrice');
        $isTrigger = ($stopLossPrice || $takeProfitPrice);
        $now = $this->nonce();
        $nonce = $this->get_nonce($now, 90000);
        if ($postOnly && $reduceOnly) {
            throw new NotSupported($this->id . ' $reduceOnly not supported when $postOnly is enabled');
        }
        $expiration = $this->get_expiration($now, $timeInForce, $postOnly, $reduceOnly);
        if ($isTrigger) {
            // 1 << 63 = 9223372036854775808
            $nonce = Precise::string_or($nonce, '9223372036854775808');
        }
        $amountString = $this->get_amount($amount, $side);
        $order = array(
            'sender' => $this->convert_address_to_sender($this->walletAddress),
            'priceX18' => $this->convert_to_x18($this->price_to_precision($symbol, $price)),
            'amount' => $this->convert_to_x18($this->amount_to_precision($symbol, $amountString)),
            'expiration' => $expiration,
            'nonce' => $nonce,
        );
        $request = array(
            'place_order' => array(
                'product_id' => $marketId,
                'order' => array(
                    'sender' => $order['sender'],
                    'priceX18' => $order['priceX18'],
                    'amount' => $order['amount'],
                    'expiration' => $this->number_to_string($order['expiration']),
                    'nonce' => $order['nonce'],
                ),
                'signature' => $this->build_create_order_sig($order, $chainId, $verifyingContractAddress),
                'id' => $this->safe_integer($this->options, 'brokerId', 5930043274845996),
            ),
        );
        $params = $this->omit($params, array( 'timeInForce', 'reduceOnly', 'postOnly', 'triggerPrice', 'stopPrice', 'stopLossPrice', 'takeProfitPrice' ));
        $response = null;
        if ($isTrigger) {
            $trigger = array();
            if ($stopLossPrice !== null) {
                $trigger['last_price_below'] = $this->convert_to_x18($stopLossPrice);
            } elseif ($takeProfitPrice !== null) {
                $trigger['last_price_above'] = $this->convert_to_x18($takeProfitPrice);
            }
            $request['place_order']['trigger'] = $trigger;
            $response = $this->v1TriggerPostExecute ($this->extend($request, $params));
        } else {
            $response = $this->v1GatewayPostExecute ($this->extend($request, $params));
        }
        //
        // {
        //     "status" => "success",
        //     "signature" => {signature},
        //     "data" => array(
        //       "digest" => array($order digest)
        //     ),
        //     "request_type" => "execute_place_order"
        //     "id" => 100
        // }
        //
        $data = $this->safe_dict($response, 'data', array());
        return $this->safe_order(array(
            'id' => $this->safe_string($data, 'digest'),
        ));
    }

    public function edit_order(string $id, string $symbol, string $type, string $side, ?float $amount = null, ?float $price = null, $params = array ()) {
        /**
         * edit a trade $order
         *
         * @see https://docs.vertexprotocol.com/developer-resources/api/gateway/executes/cancel-and-place
         *
         * @param {string} $id cancel $order $id
         * @param {string} $symbol unified $symbol of the $market to create an $order in
         * @param {string} $type 'market' or 'limit'
         * @param {string} $side 'buy' or 'sell'
         * @param {float} $amount how much of currency you want to trade in units of base currency
         * @param {float} [$price] the $price at which the $order is to be fulfilled, in units of the quote currency, ignored in $market orders
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @param {string} [$params->timeInForce] ioc, fok
         * @param {bool} [$params->postOnly] true or false whether the $order is post-only
         * @param {bool} [$params->reduceOnly] true or false whether the $order is reduce-only, only works for ioc and fok $order
         * @param {float} [$params->triggerPrice] The $price at which a trigger $order is triggered at
         * @return {array} an ~@link https://docs.ccxt.com/#/?$id=$order-structure $order structure~
         */
        $this->check_required_credentials();
        $marketType = strtolower($type);
        $isMarketOrder = $marketType === 'market';
        if ($isMarketOrder && $price === null) {
            throw new ArgumentsRequired($this->id . ' editOrder() requires a $price argument for $market order');
        }
        $this->load_markets();
        $market = $this->market($symbol);
        $marketId = $this->parse_to_int($market['id']);
        $defaultTimeInForce = ($isMarketOrder) ? 'fok' : null;
        $timeInForce = $this->safe_string_lower($params, 'timeInForce', $defaultTimeInForce);
        $postOnly = $this->safe_bool($params, 'postOnly', false);
        $reduceOnly = $this->safe_bool($params, 'reduceOnly', false);
        $triggerPrice = $this->safe_string_2($params, 'triggerPrice', 'stopPrice');
        $stopLossPrice = $this->safe_string($params, 'stopLossPrice', $triggerPrice);
        $takeProfitPrice = $this->safe_string($params, 'takeProfitPrice');
        $isTrigger = ($stopLossPrice || $takeProfitPrice);
        $contracts = $this->query_contracts();
        $chainId = $this->safe_string($contracts, 'chain_id');
        $bookAddresses = $this->safe_list($contracts, 'book_addrs', array());
        $verifyingContractAddressOrder = $this->safe_string($bookAddresses, $marketId);
        $verifyingContractAddressCancel = $this->safe_string($contracts, 'endpoint_addr');
        $now = $this->nonce();
        $nonce = $this->get_nonce($now, 90000);
        $sender = $this->convert_address_to_sender($this->walletAddress);
        if ($postOnly && $reduceOnly) {
            throw new NotSupported($this->id . ' $reduceOnly not supported when $postOnly is enabled');
        }
        if ($isTrigger) {
            throw new NotSupported($this->id . ' editOrder() not supported for trigger order');
        }
        $expiration = $this->get_expiration($now, $timeInForce, $postOnly, $reduceOnly);
        $amountString = $this->get_amount($amount, $side);
        $order = array(
            'sender' => $sender,
            'priceX18' => $this->convert_to_x18($this->price_to_precision($symbol, $price)),
            'amount' => $this->convert_to_x18($this->amount_to_precision($symbol, $amountString)),
            'expiration' => $expiration,
            'nonce' => $nonce,
        );
        $cancels = array(
            'sender' => $sender,
            'productIds' => array( $marketId ),
            'digests' => array( $id ),
            'nonce' => $nonce,
        );
        $request = array(
            'cancel_and_place' => array(
                'cancel_tx' => array(
                    'sender' => $cancels['sender'],
                    'productIds' => $cancels['productIds'],
                    'digests' => $cancels['digests'],
                    'nonce' => $this->number_to_string($cancels['nonce']),
                ),
                'cancel_signature' => $this->build_cancel_orders_sig($cancels, $chainId, $verifyingContractAddressCancel),
                'place_order' => array(
                    'product_id' => $marketId,
                    'order' => array(
                        'sender' => $order['sender'],
                        'priceX18' => $order['priceX18'],
                        'amount' => $order['amount'],
                        'expiration' => $this->number_to_string($order['expiration']),
                        'nonce' => $order['nonce'],
                    ),
                    'signature' => $this->build_create_order_sig($order, $chainId, $verifyingContractAddressOrder),
                    'id' => $this->safe_integer($this->options, 'brokerId', 5930043274845996),
                ),
            ),
        );
        $params = $this->omit($params, array( 'timeInForce', 'reduceOnly', 'postOnly', 'triggerPrice', 'stopPrice', 'stopLossPrice', 'takeProfitPrice' ));
        $response = $this->v1GatewayPostExecute ($this->extend($request, $params));
        //
        // {
        //     "status" => "success",
        //     "signature" => {signature},
        //     "data" => array(
        //       "digest" => array($order digest)
        //     ),
        //     "request_type" => "execute_cancel_and_place"
        // }
        //
        $data = $this->safe_dict($response, 'data', array());
        return $this->safe_order(array(
            'id' => $this->safe_string($data, 'digest'),
        ));
    }

    public function parse_order_status($status) {
        if ($status !== null) {
            $statuses = array(
                'pending' => 'open',
            );
            if (gettype($status) === 'string') {
                return $this->safe_string($statuses, $status, $status);
            }
            $statusCancelled = $this->safe_dict($status, 'cancelled');
            if ($statusCancelled !== null) {
                return 'canceled';
            }
            $statusTriggered = $this->safe_dict($status, 'triggered', array());
            $triggeredStatus = $this->safe_string($statusTriggered, 'status', 'failure');
            if ($triggeredStatus === 'success') {
                return 'closed';
            }
            return 'canceled';
        }
        return $status;
    }

    public function parse_order($order, ?array $market = null): array {
        //
        // {
        //     "product_id" => 1,
        //     "sender" => "0x7a5ec2748e9065794491a8d29dcf3f9edb8d7c43000000000000000000000000",
        //     "price_x18" => "1000000000000000000",
        //     "amount" => "1000000000000000000",
        //     "expiration" => "2000000000",
        //     "nonce" => "1",
        //     "unfilled_amount" => "1000000000000000000",
        //     "digest" => "0x0000000000000000000000000000000000000000000000000000000000000000",
        //     "placed_at" => 1681951347,
        //     "order_type" => "ioc"
        // }
        // stop $order
        // {
        //     "order" => array(
        //       "order" => array(
        //         "sender" => "0x7a5ec2748e9065794491a8d29dcf3f9edb8d7c43000000000000000000000000",
        //         "priceX18" => "1000000000000000000",
        //         "amount" => "1000000000000000000",
        //         "expiration" => "2000000000",
        //         "nonce" => "1",
        //       ),
        //       "signature" => "0x...",
        //       "product_id" => 1,
        //       "spot_leverage" => true,
        //       "trigger" => array(
        //         "price_above" => "1000000000000000000"
        //       ),
        //       "digest" => "0x..."
        //     ),
        //     "status" => "pending",
        //     "updated_at" => 1688768157050
        // }
        //
        $marketId = $this->safe_string($order, 'product_id');
        $timestamp = $this->safe_timestamp($order, 'placed_at');
        $amount = $this->safe_string($order, 'amount');
        $price = $this->safe_string($order, 'price_x18');
        $remaining = $this->safe_string($order, 'unfilled_amount');
        $triggerPriceNum = null;
        $status = $this->safe_value($order, 'status');
        if ($status !== null) {
            // $trigger $order
            $outerOrder = $this->safe_dict($order, 'order', array());
            $innerOrder = $this->safe_dict($outerOrder, 'order', array());
            $marketId = $this->safe_string($outerOrder, 'product_id');
            $amount = $this->safe_string($innerOrder, 'amount');
            $price = $this->safe_string($innerOrder, 'priceX18');
            $timestamp = $this->safe_timestamp($order, 'updated_at');
            $trigger = $this->safe_dict($outerOrder, 'trigger', array());
            $triggerPrice = $this->safe_string_n($trigger, array( 'price_above', 'price_below', 'last_price_above', 'last_price_below' ));
            if ($triggerPrice !== null) {
                $triggerPriceNum = $this->parse_to_numeric($this->convert_from_x18($triggerPrice));
            }
        }
        $market = $this->safe_market($marketId, $market);
        $symbol = $market['symbol'];
        $priceNum = null;
        if ($price !== null) {
            $priceNum = $this->parse_to_numeric($this->convert_from_x18($price));
        }
        $amountNum = null;
        if ($amount !== null) {
            $amountNum = $this->parse_to_numeric($this->convert_from_x18($amount));
        }
        $remainingNum = null;
        if ($remaining !== null) {
            $remainingNum = $this->parse_to_numeric($this->convert_from_x18($remaining));
        }
        $side = null;
        if ($amountNum !== null && $remainingNum !== null) {
            $side = ($amountNum < 0 || $remainingNum < 0) ? 'sell' : 'buy';
        }
        $tif = $this->parse_time_in_force($this->safe_string($order, 'order_type'));
        $isPostOnly = ($tif === 'PO');
        return $this->safe_order(array(
            'info' => $order,
            'id' => $this->safe_string($order, 'digest'),
            'clientOrderId' => null,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'lastTradeTimestamp' => null,
            'lastUpdateTimestamp' => null,
            'symbol' => $symbol,
            'type' => null,
            'timeInForce' => $tif,
            'postOnly' => $isPostOnly,
            'reduceOnly' => null,
            'side' => $side,
            'price' => $priceNum,
            'triggerPrice' => $triggerPriceNum,
            'amount' => $amountNum,
            'cost' => null,
            'average' => null,
            'filled' => null,
            'remaining' => $remainingNum,
            'status' => $this->parse_order_status($status),
            'fee' => null,
            'trades' => null,
        ), $market);
    }

    public function parse_time_in_force($timeInForce) {
        $timeInForces = array(
            'POST_ONLY' => 'PO',
        );
        return $this->safe_string_upper($timeInForces, $timeInForce, $timeInForce);
    }

    public function fetch_order(string $id, ?string $symbol = null, $params = array ()) {
        /**
         * fetches information on an order made by the user
         *
         * @see https://docs.vertexprotocol.com/developer-resources/api/gateway/queries/order
         *
         * @param {string} $id the order $id
         * @param {string} $symbol unified $symbol of the $market the order was made in
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @return {array} An ~@link https://docs.ccxt.com/#/?$id=order-structure order structure~
         */
        $this->load_markets();
        $market = $this->market($symbol);
        $request = array(
            'type' => 'order',
            'product_id' => $this->parse_to_int($market['id']),
            'digest' => $id,
        );
        $response = $this->v1GatewayGetQuery ($this->extend($request, $params));
        //
        // {
        //     "status" => "success",
        //     "data" => array(
        //       "product_id" => 1,
        //       "sender" => "0x7a5ec2748e9065794491a8d29dcf3f9edb8d7c43000000000000000000000000",
        //       "price_x18" => "1000000000000000000",
        //       "amount" => "1000000000000000000",
        //       "expiration" => "2000000000",
        //       "nonce" => "1",
        //       "unfilled_amount" => "1000000000000000000",
        //       "digest" => "0x0000000000000000000000000000000000000000000000000000000000000000",
        //       "placed_at" => 1681951347,
        //       "order_type" => "ioc"
        //     ),
        //     "request_type" => "query_order",
        // }
        //
        $data = $this->safe_dict($response, 'data');
        return $this->parse_order($data, $market);
    }

    public function fetch_open_orders(?string $symbol = null, ?int $since = null, ?int $limit = null, $params = array ()): array {
        /**
         * fetch all unfilled currently open $orders
         *
         * @see https://docs.vertexprotocol.com/developer-resources/api/gateway/queries/orders
         * @see https://docs.vertexprotocol.com/developer-resources/api/trigger/queries/list-trigger-$orders
         *
         * @param {string} $symbol unified $market $symbol
         * @param {int} [$since] the earliest time in ms to fetch open $orders for
         * @param {int} [$limit] the maximum number of open $orders structures to retrieve
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @param {boolean} [$params->stop] whether the order is a stop/algo order
         * @param {string} [$params->user] user address, will default to $this->walletAddress if not provided
         * @return {Order[]} a list of ~@link https://docs.ccxt.com/#/?id=order-structure order structures~
         */
        $this->check_required_credentials();
        $this->load_markets();
        $userAddress = null;
        list($userAddress, $params) = $this->handle_public_address('fetchOpenOrders', $params);
        $request = array();
        $market = null;
        $stop = $this->safe_bool_2($params, 'stop', 'trigger');
        $params = $this->omit($params, array( 'stop', 'trigger' ));
        if ($symbol !== null) {
            $market = $this->market($symbol);
            $request['product_id'] = $this->parse_to_numeric($market['id']);
        }
        $response = null;
        if ($stop) {
            $contracts = $this->query_contracts();
            $chainId = $this->safe_string($contracts, 'chain_id');
            $verifyingContractAddress = $this->safe_string($contracts, 'endpoint_addr');
            $tx = array(
                'sender' => $this->convert_address_to_sender($userAddress),
                'recvTime' => $this->nonce() + 90000,
            );
            $request['signature'] = $this->build_list_trigger_tx_sig($tx, $chainId, $verifyingContractAddress);
            $request['tx'] = array(
                'sender' => $tx['sender'],
                'recvTime' => $this->number_to_string($tx['recvTime']),
            );
            $request['type'] = 'list_trigger_orders';
            $request['pending'] = true;
            $until = $this->safe_integer($params, 'until');
            $params = $this->omit($params, 'until');
            if ($until !== null) {
                $request['max_update_time'] = $until;
            }
            if ($limit !== null) {
                $request['limit'] = $limit;
            }
            $response = $this->v1TriggerPostQuery ($this->extend($request, $params));
            //
            // {
            //     "status" => "success",
            //     "data" => {
            //       "orders" => array(
            //         array(
            //           "order" => array(
            //             "order" => array(
            //               "sender" => "0x7a5ec2748e9065794491a8d29dcf3f9edb8d7c43000000000000000000000000",
            //               "priceX18" => "1000000000000000000",
            //               "amount" => "1000000000000000000",
            //               "expiration" => "2000000000",
            //               "nonce" => "1",
            //             ),
            //             "signature" => "0x...",
            //             "product_id" => 1,
            //             "spot_leverage" => true,
            //             "trigger" => array(
            //               "price_above" => "1000000000000000000"
            //             ),
            //             "digest" => "0x..."
            //           ),
            //           "status" => "pending",
            //           "updated_at" => 1688768157050
            //         }
            //       )
            //     ),
            //     "request_type" => "query_list_trigger_orders"
            // }
            //
        } else {
            $this->check_required_argument('fetchOpenOrders', $symbol, 'symbol');
            $request['type'] = 'subaccount_orders';
            $request['sender'] = $this->convert_address_to_sender($userAddress);
            $response = $this->v1GatewayPostQuery ($this->extend($request, $params));
            //
            // {
            //     "status" => "success",
            //     "data" => {
            //       "sender" => "0x7a5ec2748e9065794491a8d29dcf3f9edb8d7c43000000000000000000000000",
            //       "product_id" => 1,
            //       "orders" => array(
            //         array(
            //           "product_id" => 1,
            //           "sender" => "0x7a5ec2748e9065794491a8d29dcf3f9edb8d7c43000000000000000000000000",
            //           "price_x18" => "1000000000000000000",
            //           "amount" => "1000000000000000000",
            //           "expiration" => "2000000000",
            //           "nonce" => "1",
            //           "order_type" => "default",
            //           "unfilled_amount" => "1000000000000000000",
            //           "digest" => "0x0000000000000000000000000000000000000000000000000000000000000000",
            //           "placed_at" => 1682437739,
            //           "order_type" => "ioc"
            //         }
            //       )
            //     ),
            //     "request_type" => "query_subaccount_orders"
            // }
            //
        }
        $data = $this->safe_dict($response, 'data', array());
        $orders = $this->safe_list($data, 'orders');
        return $this->parse_orders($orders, $market, $since, $limit);
    }

    public function fetch_orders(?string $symbol = null, ?int $since = null, ?int $limit = null, $params = array ()): array {
        /**
         * fetches information on multiple $orders made by the user
         *
         * @see https://docs.vertexprotocol.com/developer-resources/api/trigger/queries/list-trigger-$orders
         *
         * @param {string} $symbol unified $market $symbol
         * @param {int} [$since] the earliest time in ms to fetch open $orders for
         * @param {int} [$limit] the maximum number of open $orders structures to retrieve
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @param {boolean} [$params->stop] whether the order is a stop/algo order
         * @param {string} [$params->user] user address, will default to $this->walletAddress if not provided
         * @return {Order[]} a list of ~@link https://docs.ccxt.com/#/?id=order-structure order structures~
         */
        $this->check_required_credentials();
        $stop = $this->safe_bool_2($params, 'stop', 'trigger');
        $params = $this->omit($params, array( 'stop', 'trigger' ));
        if (!$stop) {
            throw new NotSupported($this->id . ' fetchOrders only support trigger orders');
        }
        $userAddress = null;
        list($userAddress, $params) = $this->handle_public_address('fetchOrders', $params);
        $this->load_markets();
        $market = null;
        $request = array(
            'type' => 'list_trigger_orders',
            'pending' => false,
        );
        if ($symbol !== null) {
            $market = $this->market($symbol);
            $request['product_id'] = $this->parse_to_numeric($market['id']);
        }
        $contracts = $this->query_contracts();
        $chainId = $this->safe_string($contracts, 'chain_id');
        $verifyingContractAddress = $this->safe_string($contracts, 'endpoint_addr');
        $tx = array(
            'sender' => $this->convert_address_to_sender($userAddress),
            'recvTime' => $this->nonce() + 90000,
        );
        $request['signature'] = $this->build_list_trigger_tx_sig($tx, $chainId, $verifyingContractAddress);
        $request['tx'] = array(
            'sender' => $tx['sender'],
            'recvTime' => $this->number_to_string($tx['recvTime']),
        );
        $until = $this->safe_integer($params, 'until');
        $params = $this->omit($params, 'until');
        if ($until !== null) {
            $request['max_update_time'] = $until;
        }
        if ($limit !== null) {
            $request['limit'] = $limit;
        }
        $response = $this->v1TriggerPostQuery ($this->extend($request, $params));
        //
        // {
        //     "status" => "success",
        //     "data" => {
        //       "orders" => array(
        //         array(
        //           "order" => array(
        //             "order" => array(
        //               "sender" => "0x7a5ec2748e9065794491a8d29dcf3f9edb8d7c43000000000000000000000000",
        //               "priceX18" => "1000000000000000000",
        //               "amount" => "1000000000000000000",
        //               "expiration" => "2000000000",
        //               "nonce" => "1",
        //             ),
        //             "signature" => "0x...",
        //             "product_id" => 1,
        //             "spot_leverage" => true,
        //             "trigger" => array(
        //               "price_above" => "1000000000000000000"
        //             ),
        //             "digest" => "0x..."
        //           ),
        //           "status" => "pending",
        //           "updated_at" => 1688768157050
        //         }
        //       )
        //     ),
        //     "request_type" => "query_list_trigger_orders"
        // }
        //
        $data = $this->safe_dict($response, 'data', array());
        $orders = $this->safe_list($data, 'orders');
        return $this->parse_orders($orders, $market, $since, $limit);
    }

    public function cancel_all_orders(?string $symbol = null, $params = array ()) {
        /**
         *
         * @see https://docs.vertexprotocol.com/developer-resources/api/gateway/executes/cancel-product-orders
         * @see https://docs.vertexprotocol.com/developer-resources/api/trigger/executes/cancel-product-orders
         *
         * cancel all open orders in a $market
         * @param {string} $symbol unified $market $symbol
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @param {boolean} [$params->stop] whether the order is a stop/algo order
         * @return {array} an list of ~@link https://docs.ccxt.com/#/?id=order-structure order structures~
         */
        $this->check_required_credentials();
        $this->load_markets();
        if ($symbol === null) {
            throw new ArgumentsRequired($this->id . ' cancelAllOrders() requires a $symbol argument');
        }
        $market = $this->market($symbol);
        $marketId = $market['id'];
        $contracts = $this->query_contracts();
        $chainId = $this->safe_string($contracts, 'chain_id');
        $verifyingContractAddress = $this->safe_string($contracts, 'endpoint_addr');
        $now = $this->nonce();
        $nonce = $this->get_nonce($now, 90000);
        $cancels = array(
            'sender' => $this->convert_address_to_sender($this->walletAddress),
            'productIds' => array(
                $this->parse_to_numeric($marketId),
            ),
            'nonce' => $nonce,
        );
        $request = array(
            'cancel_product_orders' => array(
                'tx' => array(
                    'sender' => $cancels['sender'],
                    'productIds' => $cancels['productIds'],
                    'nonce' => $this->number_to_string($cancels['nonce']),
                ),
                'signature' => $this->build_cancel_all_orders_sig($cancels, $chainId, $verifyingContractAddress),
            ),
        );
        $stop = $this->safe_bool_2($params, 'stop', 'trigger');
        $params = $this->omit($params, array( 'stop', 'trigger' ));
        $response = null;
        if ($stop) {
            $response = $this->v1TriggerPostExecute ($this->extend($request, $params));
            //
            // {
            //     "status" => "success",
            //     "signature" => {signature},
            //     "request_type" => "execute_cancel_product_orders"
            // }
            //
        } else {
            $response = $this->v1GatewayPostExecute ($this->extend($request, $params));
            //
            // {
            //     "status" => "success",
            //     "signature" => {signature},
            //     "data" => array(
            //       "cancelled_orders" => array(
            //         array(
            //           "product_id" => 2,
            //           "sender" => "0x7a5ec2748e9065794491a8d29dcf3f9edb8d7c43746573743000000000000000",
            //           "price_x18" => "20000000000000000000000",
            //           "amount" => "-100000000000000000",
            //           "expiration" => "1686332748",
            //           "order_type" => "post_only",
            //           "nonce" => "1768248100142339392",
            //           "unfilled_amount" => "-100000000000000000",
            //           "digest" => "0x3195a7929feb8307edecf9c045j5ced68925108f0aa305f0ee5773854159377c",
            //           "placed_at" => 1686332708
            //         ),
            //         ...
            //       )
            //     ),
            //     "request_type" => "execute_cancel_product_orders"
            // }
            //
        }
        return $response;
    }

    public function cancel_order(string $id, ?string $symbol = null, $params = array ()) {
        /**
         * cancels an open order
         *
         * @see https://docs.vertexprotocol.com/developer-resources/api/gateway/executes/cancel-orders
         * @see https://docs.vertexprotocol.com/developer-resources/api/trigger/executes/cancel-orders
         *
         * @param {string} $id order $id
         * @param {string} $symbol unified $symbol of the market the order was made in
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @return {array} An ~@link https://docs.ccxt.com/#/?$id=order-structure order structure~
         */
        return $this->cancel_orders(array( $id ), $symbol, $params);
    }

    public function cancel_orders(array $ids, ?string $symbol = null, $params = array ()) {
        /**
         * cancel multiple orders
         *
         * @see https://docs.vertexprotocol.com/developer-resources/api/gateway/executes/cancel-orders
         * @see https://docs.vertexprotocol.com/developer-resources/api/trigger/executes/cancel-orders
         *
         * @param {string[]} $ids order $ids
         * @param {string} [$symbol] unified $market $symbol
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @return {array} an list of ~@link https://docs.ccxt.com/#/?id=order-structure order structures~
         */
        $this->check_required_credentials();
        if ($symbol === null) {
            throw new ArgumentsRequired($this->id . ' cancelOrders() requires a $symbol argument');
        }
        $this->load_markets();
        $market = $this->market($symbol);
        $marketId = $market['id'];
        $contracts = $this->query_contracts();
        $chainId = $this->safe_string($contracts, 'chain_id');
        $verifyingContractAddress = $this->safe_string($contracts, 'endpoint_addr');
        $now = $this->nonce();
        $nonce = $this->get_nonce($now, 90000);
        $cancels = array(
            'sender' => $this->convert_address_to_sender($this->walletAddress),
            'productIds' => array(),
            'digests' => $ids,
            'nonce' => $nonce,
        );
        $marketIdNum = $this->parse_to_numeric($marketId);
        for ($i = 0; $i < count($ids); $i++) {
            $cancels['productIds'][] = $marketIdNum;
        }
        $request = array(
            'cancel_orders' => array(
                'tx' => array(
                    'sender' => $cancels['sender'],
                    'productIds' => $cancels['productIds'],
                    'digests' => $cancels['digests'],
                    'nonce' => $this->number_to_string($cancels['nonce']),
                ),
                'signature' => $this->build_cancel_orders_sig($cancels, $chainId, $verifyingContractAddress),
            ),
        );
        $stop = $this->safe_bool_2($params, 'stop', 'trigger');
        $params = $this->omit($params, array( 'stop', 'trigger' ));
        $response = null;
        if ($stop) {
            $response = $this->v1TriggerPostExecute ($this->extend($request, $params));
            //
            // {
            //     "status" => "success",
            //     "signature" => {signature},
            //     "request_type" => "execute_cancel_orders"
            // }
            //
        } else {
            $response = $this->v1GatewayPostExecute ($this->extend($request, $params));
            //
            // {
            //     "status" => "success",
            //     "signature" => {signature},
            //     "data" => array(
            //       "cancelled_orders" => array(
            //         array(
            //           "product_id" => 2,
            //           "sender" => "0x7a5ec2748e9065794491a8d29dcf3f9edb8d7c43746573743000000000000000",
            //           "price_x18" => "20000000000000000000000",
            //           "amount" => "-100000000000000000",
            //           "expiration" => "1686332748",
            //           "order_type" => "post_only",
            //           "nonce" => "1768248100142339392",
            //           "unfilled_amount" => "-100000000000000000",
            //           "digest" => "0x3195a7929feb8307edecf9c045j5ced68925108f0aa305f0ee5773854159377c",
            //           "placed_at" => 1686332708
            //         ),
            //         ...
            //       )
            //     ),
            //     "request_type" => "execute_cancel_orders"
            // }
            //
        }
        return $response;
    }

    public function fetch_balance($params = array ()): array {
        /**
         * query for $balance and get the amount of funds available for trading or funds locked in orders
         *
         * @see https://docs.vertexprotocol.com/developer-resources/api/gateway/queries/subaccount-info
         *
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @param {string} [$params->user] user address, will default to $this->walletAddress if not provided
         * @return {array} a ~@link https://docs.ccxt.com/#/?id=$balance-structure $balance structure~
         */
        $userAddress = null;
        list($userAddress, $params) = $this->handle_public_address('fetchBalance', $params);
        $request = array(
            'type' => 'subaccount_info',
            'subaccount' => $this->convert_address_to_sender($userAddress),
        );
        $response = $this->v1GatewayGetQuery ($this->extend($request, $params));
        //
        // {
        //     "status" => "success",
        //     "data" => {
        //       "subaccount" => "0x265167ddfac55365d6ff07fc5943276319aa6b9f64656661756c740000000000",
        //       "exists" => true,
        //       "healths" => array(
        //         array(
        //           "assets" => "75323297691833342306",
        //           "liabilities" => "46329556869051092241",
        //           "health" => "28993740822782250065"
        //         ),
        //         array(
        //           "assets" => "75323297691833342306",
        //           "liabilities" => "35968911700887320741",
        //           "health" => "39354385990946021565"
        //         ),
        //         {
        //           "assets" => "80796966663601107565",
        //           "liabilities" => "0",
        //           "health" => "80796966663601107565"
        //         }
        //       ),
        //       "health_contributions" => array(
        //         array(
        //           "75323297691833340000",
        //           "75323297691833340000",
        //           "75323297691833340000"
        //         ),
        //         array(
        //           "0",
        //           "0",
        //           "0"
        //         ),
        //         array(
        //           "0",
        //           "0",
        //           "0"
        //         ),
        //         array(
        //           "0",
        //           "0",
        //           "0"
        //         ),
        //         array(
        //           "-46329556869051090000",
        //           "-35968911700887323000",
        //           "5473668971767765000"
        //         )
        //       ),
        //       "spot_count" => 3,
        //       "perp_count" => 2,
        //       "spot_balances" => array(
        //         {
        //           "product_id" => 1,
        //           "lp_balance" => array(
        //             "amount" => "0"
        //           ),
        //           "balance" => array(
        //             "amount" => "0",
        //             "last_cumulative_multiplier_x18" => "1003419811982007193"
        //           }
        //         ),
        //         {
        //           "product_id" => 3,
        //           "lp_balance" => array(
        //             "amount" => "0"
        //           ),
        //           "balance" => array(
        //             "amount" => "0",
        //             "last_cumulative_multiplier_x18" => "1007584195035969404"
        //           }
        //         ),
        //         {
        //           "product_id" => 0,
        //           "lp_balance" => array(
        //             "amount" => "0"
        //           ),
        //           "balance" => {
        //             "amount" => "75323297691833342306",
        //             "last_cumulative_multiplier_x18" => "1000000002391497578"
        //           }
        //         }
        //       ),
        //       "perp_balances" => array(
        //         {
        //           "product_id" => 2,
        //           "lp_balance" => array(
        //             "amount" => "0",
        //             "last_cumulative_funding_x18" => "-284321955122859921"
        //           ),
        //           "balance" => array(
        //             "amount" => "0",
        //             "v_quote_balance" => "0",
        //             "last_cumulative_funding_x18" => "6363466629611946777168"
        //           }
        //         ),
        //         {
        //           "product_id" => 4,
        //           "lp_balance" => array(
        //             "amount" => "0",
        //             "last_cumulative_funding_x18" => "-90979748449893411"
        //           ),
        //           "balance" => {
        //             "amount" => "-200000000000000000",
        //             "v_quote_balance" => "419899475698318625259",
        //             "last_cumulative_funding_x18" => "141182516563970577208"
        //           }
        //         }
        //       ),
        //       "spot_products" => array(
        //         {
        //           "product_id" => 1,
        //           "oracle_price_x18" => "30217830336443750750000",
        //           "risk" => array(
        //             "long_weight_initial_x18" => "750000000000000000",
        //             "short_weight_initial_x18" => "1250000000000000000",
        //             "long_weight_maintenance_x18" => "800000000000000000",
        //             "short_weight_maintenance_x18" => "1200000000000000000",
        //             "large_position_penalty_x18" => "0"
        //           ),
        //           "config" => array(
        //             "token" => "0x5cc7c91690b2cbaee19a513473d73403e13fb431",
        //             "interest_inflection_util_x18" => "800000000000000000",
        //             "interest_floor_x18" => "10000000000000000",
        //             "interest_small_cap_x18" => "40000000000000000",
        //             "interest_large_cap_x18" => "1000000000000000000"
        //           ),
        //           "state" => array(
        //             "cumulative_deposits_multiplier_x18" => "1001304691727847318",
        //             "cumulative_borrows_multiplier_x18" => "1003419811982007193",
        //             "total_deposits_normalized" => "213107447159798397806318",
        //             "total_borrows_normalized" => "4907820740150097483532"
        //           ),
        //           "lp_state" => {
        //             "supply" => "1304981417419495030893348",
        //             "quote" => array(
        //               "amount" => "2048495687410669565222259",
        //               "last_cumulative_multiplier_x18" => "1000000002391497578"
        //             ),
        //             "base" => array(
        //               "amount" => "67623029247538886515",
        //               "last_cumulative_multiplier_x18" => "1001304691727847318"
        //             }
        //           ),
        //           "book_info" => array(
        //             "size_increment" => "1000000000000000",
        //             "price_increment_x18" => "1000000000000000000",
        //             "min_size" => "10000000000000000",
        //             "collected_fees" => "8865582805773573662738183",
        //             "lp_spread_x18" => "3000000000000000"
        //           }
        //         ),
        //         {
        //           "product_id" => 3,
        //           "oracle_price_x18" => "2075217009708333333333",
        //           "risk" => array(
        //             "long_weight_initial_x18" => "750000000000000000",
        //             "short_weight_initial_x18" => "1250000000000000000",
        //             "long_weight_maintenance_x18" => "800000000000000000",
        //             "short_weight_maintenance_x18" => "1200000000000000000",
        //             "large_position_penalty_x18" => "0"
        //           ),
        //           "config" => array(
        //             "token" => "0xcc59686e3a32fb104c8ff84dd895676265efb8a6",
        //             "interest_inflection_util_x18" => "800000000000000000",
        //             "interest_floor_x18" => "10000000000000000",
        //             "interest_small_cap_x18" => "40000000000000000",
        //             "interest_large_cap_x18" => "1000000000000000000"
        //           ),
        //           "state" => array(
        //             "cumulative_deposits_multiplier_x18" => "1003722507760089346",
        //             "cumulative_borrows_multiplier_x18" => "1007584195035969404",
        //             "total_deposits_normalized" => "232750303205807326418622",
        //             "total_borrows_normalized" => "110730726549469855171025"
        //           ),
        //           "lp_state" => {
        //             "supply" => "902924999999999999774268",
        //             "quote" => array(
        //               "amount" => "1165328092090344104989049",
        //               "last_cumulative_multiplier_x18" => "1000000002391497578"
        //             ),
        //             "base" => array(
        //               "amount" => "563265647183403990588",
        //               "last_cumulative_multiplier_x18" => "1003722507760089346"
        //             }
        //           ),
        //           "book_info" => array(
        //             "size_increment" => "10000000000000000",
        //             "price_increment_x18" => "100000000000000000",
        //             "min_size" => "100000000000000000",
        //             "collected_fees" => "1801521329724633001446457",
        //             "lp_spread_x18" => "3000000000000000"
        //           }
        //         ),
        //         {
        //           "product_id" => 0,
        //           "oracle_price_x18" => "1000000000000000000",
        //           "risk" => array(
        //             "long_weight_initial_x18" => "1000000000000000000",
        //             "short_weight_initial_x18" => "1000000000000000000",
        //             "long_weight_maintenance_x18" => "1000000000000000000",
        //             "short_weight_maintenance_x18" => "1000000000000000000",
        //             "large_position_penalty_x18" => "0"
        //           ),
        //           "config" => array(
        //             "token" => "0x179522635726710dd7d2035a81d856de4aa7836c",
        //             "interest_inflection_util_x18" => "800000000000000000",
        //             "interest_floor_x18" => "10000000000000000",
        //             "interest_small_cap_x18" => "40000000000000000",
        //             "interest_large_cap_x18" => "1000000000000000000"
        //           ),
        //           "state" => array(
        //             "cumulative_deposits_multiplier_x18" => "1000000002391497578",
        //             "cumulative_borrows_multiplier_x18" => "1001593395547514024",
        //             "total_deposits_normalized" => "60000256267437588885818752247843",
        //             "total_borrows_normalized" => "391445043137305055810336885"
        //           ),
        //           "lp_state" => {
        //             "supply" => "0",
        //             "quote" => array(
        //               "amount" => "0",
        //               "last_cumulative_multiplier_x18" => "0"
        //             ),
        //             "base" => array(
        //               "amount" => "0",
        //               "last_cumulative_multiplier_x18" => "0"
        //             }
        //           ),
        //           "book_info" => {
        //             "size_increment" => "0",
        //             "price_increment_x18" => "0",
        //             "min_size" => "0",
        //             "collected_fees" => "0",
        //             "lp_spread_x18" => "0"
        //           }
        //         }
        //       ),
        //       "perp_products" => array(
        //         {
        //           "product_id" => 2,
        //           "oracle_price_x18" => "30219079716463070000000",
        //           "risk" => array(
        //             "long_weight_initial_x18" => "875000000000000000",
        //             "short_weight_initial_x18" => "1125000000000000000",
        //             "long_weight_maintenance_x18" => "900000000000000000",
        //             "short_weight_maintenance_x18" => "1100000000000000000",
        //             "large_position_penalty_x18" => "0"
        //           ),
        //           "state" => array(
        //             "cumulative_funding_long_x18" => "6363466629611946777168",
        //             "cumulative_funding_short_x18" => "6363466629611946777168",
        //             "available_settle" => "100612314098927536086702448",
        //             "open_interest" => "57975708279961875623240"
        //           ),
        //           "lp_state" => array(
        //             "supply" => "783207415944433511804197",
        //             "last_cumulative_funding_x18" => "6363466629611946777168",
        //             "cumulative_funding_per_lp_x18" => "-284321955122859921",
        //             "base" => "37321000000000000000",
        //             "quote" => "1150991638943862165224593"
        //           ),
        //           "book_info" => array(
        //             "size_increment" => "1000000000000000",
        //             "price_increment_x18" => "1000000000000000000",
        //             "min_size" => "10000000000000000",
        //             "collected_fees" => "7738341933653651206856235",
        //             "lp_spread_x18" => "3000000000000000"
        //           }
        //         ),
        //         {
        //           "product_id" => 4,
        //           "oracle_price_x18" => "2072129033632754300000",
        //           "risk" => array(
        //             "long_weight_initial_x18" => "875000000000000000",
        //             "short_weight_initial_x18" => "1125000000000000000",
        //             "long_weight_maintenance_x18" => "900000000000000000",
        //             "short_weight_maintenance_x18" => "1100000000000000000",
        //             "large_position_penalty_x18" => "0"
        //           ),
        //           "state" => array(
        //             "cumulative_funding_long_x18" => "141182516563970577208",
        //             "cumulative_funding_short_x18" => "141182516563970577208",
        //             "available_settle" => "33807443862986950288685582",
        //             "open_interest" => "316343836992291503987611"
        //           ),
        //           "lp_state" => array(
        //             "supply" => "541756546038144467864559",
        //             "last_cumulative_funding_x18" => "141182516563970577208",
        //             "cumulative_funding_per_lp_x18" => "-90979748449893411",
        //             "base" => "362320000000000000000",
        //             "quote" => "750080187685127907834038"
        //           ),
        //           "book_info" => array(
        //             "size_increment" => "10000000000000000",
        //             "price_increment_x18" => "100000000000000000",
        //             "min_size" => "100000000000000000",
        //             "collected_fees" => "1893278317732551619694831",
        //             "lp_spread_x18" => "3000000000000000"
        //           }
        //         }
        //       )
        //     ),
        //     "request_type" => "query_subaccount_info"
        // }
        //
        $data = $this->safe_dict($response, 'data', array());
        $balances = $this->safe_list($data, 'spot_balances', array());
        $result = array( 'info' => $response );
        for ($i = 0; $i < count($balances); $i++) {
            $balance = $balances[$i];
            $marketId = $this->safe_string($balance, 'product_id');
            $market = $this->safe_market($marketId);
            $isUsdcMarketId = $marketId === '0';
            if ($market['id'] === null && !$isUsdcMarketId) {
                continue;
            }
            $baseId = ($isUsdcMarketId) ? 'USDC' : $this->safe_string($market, 'baseId');
            $code = $this->safe_currency_code($baseId);
            $account = $this->account();
            $tokenBalance = $this->safe_dict($balance, 'balance', array());
            $total = $this->convert_from_x18($this->safe_string($tokenBalance, 'amount'));
            $account['total'] = $total;
            $result[$code] = $account;
        }
        return $this->safe_balance($result);
    }

    public function parse_position($position, ?array $market = null) {
        //
        // {
        //     "product_id" => 2,
        //     "lp_balance" => array(
        //       "amount" => "0",
        //       "last_cumulative_funding_x18" => "-284321955122859921"
        //     ),
        //     "balance" => array(
        //       "amount" => "0",
        //       "v_quote_balance" => "0",
        //       "last_cumulative_funding_x18" => "6363466629611946777168"
        //     }
        //   ),
        //   {
        //     "product_id" => 4,
        //     "lp_balance" => array(
        //       "amount" => "0",
        //       "last_cumulative_funding_x18" => "-90979748449893411"
        //     ),
        //     "balance" => {
        //       "amount" => "-200000000000000000",
        //       "v_quote_balance" => "419899475698318625259",
        //       "last_cumulative_funding_x18" => "141182516563970577208"
        //     }
        // }
        //
        $marketId = $this->safe_string($position, 'product_id');
        $market = $this->safe_market($marketId);
        $balance = $this->safe_dict($position, 'balance', array());
        $contractSize = $this->convert_from_x18($this->safe_string($balance, 'amount'));
        $side = 'buy';
        if (Precise::string_lt($contractSize, '1')) {
            $side = 'sell';
        }
        return $this->safe_position(array(
            'info' => $position,
            'id' => null,
            'symbol' => $this->safe_string($market, 'symbol'),
            'timestamp' => null,
            'datetime' => null,
            'lastUpdateTimestamp' => null,
            'initialMargin' => null,
            'initialMarginPercentage' => null,
            'maintenanceMargin' => null,
            'maintenanceMarginPercentage' => null,
            'entryPrice' => null,
            'notional' => null,
            'leverage' => null,
            'unrealizedPnl' => null,
            'contracts' => null,
            'contractSize' => $this->parse_to_numeric($contractSize),
            'marginRatio' => null,
            'liquidationPrice' => null,
            'markPrice' => null,
            'lastPrice' => null,
            'collateral' => null,
            'marginMode' => 'cross',
            'marginType' => null,
            'side' => $side,
            'percentage' => null,
            'hedged' => null,
            'stopLossPrice' => null,
            'takeProfitPrice' => null,
        ));
    }

    public function fetch_positions(?array $symbols = null, $params = array ()) {
        /**
         * fetch all open $positions
         *
         * @see https://docs.vertexprotocol.com/developer-resources/api/gateway/queries/subaccount-info
         *
         * @param {string[]} [$symbols] list of unified market $symbols
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @param {string} [$params->user] user address, will default to $this->walletAddress if not provided
         * @return {array[]} a list of ~@link https://docs.ccxt.com/#/?id=$position-structure $position structure~
         */
        $userAddress = null;
        list($userAddress, $params) = $this->handle_public_address('fetchPositions', $params);
        $request = array(
            'type' => 'subaccount_info',
            'subaccount' => $this->convert_address_to_sender($userAddress),
        );
        $response = $this->v1GatewayGetQuery ($this->extend($request, $params));
        // the $response is the same
        $data = $this->safe_dict($response, 'data', array());
        $positions = $this->safe_list($data, 'perp_balances', array());
        $symbols = $this->market_symbols($symbols);
        $result = array();
        for ($i = 0; $i < count($positions); $i++) {
            $position = $this->extend($this->parse_position($positions[$i], null), $params);
            if ($position['contractSize'] === 0) {
                continue;
            }
            $result[] = $position;
        }
        return $this->filter_by_array_positions($result, 'symbol', $symbols, false);
    }

    public function query_nonces() {
        $request = array(
            'type' => 'nonces',
            'address' => $this->walletAddress,
        );
        $response = $this->v1GatewayGetQuery ($request);
        //
        // {
        //     "status":"success",
        //     "data":array(
        //       "tx_nonce" => 0,
        //       "order_nonce" => 1753048133299863552
        //     ),
        //     "request_type" => "query_nonces",
        // }
        //
        return $this->safe_dict($response, 'data', array());
    }

    public function withdraw(string $code, float $amount, string $address, $tag = null, $params = array ()): array {
        /**
         * make a withdrawal
         *
         * @see https://docs.vertexprotocol.com/developer-resources/api/withdrawing-on-chain
         *
         * @param {string} $code unified $currency $code
         * @param {float} $amount the $amount to $withdraw
         * @param {string} $address the $address to $withdraw to
         * @param {string} $tag
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @return {array} a ~@link https://docs.ccxt.com/#/?id=$transaction-structure $transaction structure~
         */
        $this->check_required_credentials();
        $this->load_markets();
        $currency = $this->currency($code);
        $contracts = $this->query_contracts();
        $chainId = $this->safe_string($contracts, 'chain_id');
        $verifyingContractAddress = $this->safe_string($contracts, 'endpoint_addr');
        $nonces = $this->query_nonces();
        $nonce = $this->safe_number($nonces, 'tx_nonce');
        $withdraw = array(
            'sender' => $this->convert_address_to_sender($this->walletAddress),
            'productId' => $this->parse_to_numeric($currency['id']),
            'amount' => (string) $amount,
            'nonce' => $nonce,
        );
        $request = array(
            'withdraw_collateral' => array(
                'tx' => array(
                    'sender' => $withdraw['sender'],
                    'productId' => $withdraw['productId'],
                    'amount' => $withdraw['amount'],
                    'nonce' => $this->number_to_string($withdraw['nonce']),
                ),
                'signature' => $this->build_withdraw_sig($withdraw, $chainId, $verifyingContractAddress),
            ),
        );
        $response = $this->v1GatewayPostExecute ($this->extend($request, $params));
        //
        //     {
        //         "status" => "success",
        //         "signature" => {signature},
        //         "request_type" => "execute_withdraw_collateral"
        //     }
        //
        $transaction = $this->parse_transaction($response, $currency);
        return $this->extend($transaction, array(
            'amount' => $amount,
            'address' => $address,
        ));
    }

    public function parse_transaction(array $transaction, ?array $currency = null): array {
        //
        //     {
        //         "status" => "success",
        //         "signature" => {signature},
        //         "request_type" => "execute_withdraw_collateral"
        //     }
        //
        $code = null;
        if ($currency !== null) {
            $code = $currency['code'];
        }
        return array(
            'info' => $transaction,
            'id' => null,
            'txid' => null,
            'timestamp' => null,
            'datetime' => null,
            'addressFrom' => null,
            'address' => null,
            'addressTo' => null,
            'tagFrom' => null,
            'tag' => null,
            'tagTo' => null,
            'type' => 'withdrawal',
            'amount' => null,
            'currency' => $code,
            'status' => $this->parse_transaction_status($this->safe_string($transaction, 'status')),
            'updated' => null,
            'network' => null,
            'comment' => null,
            'internal' => null,
            'fee' => null,
        );
    }

    public function parse_transaction_status(?string $status) {
        $statuses = array(
            'success' => 'ok',
        );
        return $this->safe_string($statuses, $status, $status);
    }

    public function handle_public_address(string $methodName, array $params) {
        $userAux = null;
        list($userAux, $params) = $this->handle_option_and_params($params, $methodName, 'user');
        $user = $userAux;
        list($user, $params) = $this->handle_option_and_params($params, $methodName, 'address', $userAux);
        if (($user !== null) && ($user !== '')) {
            return array( $user, $params );
        }
        if (($this->walletAddress !== null) && ($this->walletAddress !== '')) {
            return array( $this->walletAddress, $params );
        }
        throw new ArgumentsRequired($this->id . ' ' . $methodName . '() requires a $user parameter inside \'params\' or the wallet address set');
    }

    public function handle_errors($code, $reason, $url, $method, $headers, $body, $response, $requestHeaders, $requestBody) {
        if (!$response) {
            return null; // fallback to default error handler
        }
        //
        //
        $status = $this->safe_string($response, 'status', '');
        if ($status === 'failure') {
            $message = $this->safe_string($response, 'error');
            $feedback = $this->id . ' ' . $body;
            $errorCode = $this->safe_string($response, 'error_code');
            $this->throw_exactly_matched_exception($this->exceptions['exact'], $errorCode, $feedback);
            $this->throw_broadly_matched_exception($this->exceptions['broad'], $message, $feedback);
            throw new ExchangeError($feedback);
        }
        return null;
    }

    public function sign($path, $api = 'public', $method = 'GET', $params = array (), $headers = null, $body = null) {
        $version = $this->safe_string($api, 0);
        $type = $this->safe_string($api, 1);
        $url = $this->implode_hostname($this->urls['api'][$version][$type]);
        if ($version !== 'v1' || $type !== 'archive') {
            $url = $url . '/' . $path;
        }
        if ($method === 'POST') {
            $headers = array(
                'Content-Type' => 'application/json',
            );
            $body = $this->json($params);
        } else {
            if ($params) {
                $url .= '?' . $this->urlencode($params);
            }
        }
        if ($path !== 'execute') {
            // required encoding for public methods
            if ($headers !== null) {
                $headers['Accept-Encoding'] = 'gzip';
            } else {
                $headers = array(
                    'Accept-Encoding' => 'gzip',
                );
            }
        }
        return array( 'url' => $url, 'method' => $method, 'body' => $body, 'headers' => $headers );
    }
}
