<?php

namespace ccxtpro;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

use Exception; // a common import
use \ccxt\WebSocketTrait; // websocket functionality

class bitmex extends \ccxt\bitmex {

    use WebSocketTrait;

    public function describe () {
        return array_replace_recursive (parent::describe (), array (
            'has' => array (
                'ws' => true,
                'fetchWsTicker' => true,
                'fetchWsOrderBook' => true,
            ),
            'urls' => array (
                'ws' => 'wss://www.bitmex.com/realtime',
            ),
            'versions' => array (
                'ws' => '0.2.0',
            ),
            'options' => array (
                'subscriptionStatusByChannelId' => array(),
                'fetchWsOrderBookLevel' => 'orderBookL2', // 'orderBookL2' = L2 full order book, 'orderBookL2_25' = L2 top 25, 'orderBook10' L3 top 10
            ),
            'exceptions' => array (
                'ws' => array (
                    'exact' => array (
                    ),
                    'broad' => array (
                        'Rate limit exceeded' => '\\ccxt\\RateLimitExceeded',
                    ),
                ),
            ),
        ));
    }

    public function handle_ws_ticker ($client, $message) {
        //
        //     array (
        //         0, // channelID
        //         array (
        //             "a" => array ( "5525.40000", 1, "1.000" ), // ask, wholeAskVolume, askVolume
        //             "b" => array ( "5525.10000", 1, "1.000" ), // bid, wholeBidVolume, bidVolume
        //             "c" => array ( "5525.10000", "0.00398963" ), // closing price, volume
        //             "h" => array ( "5783.00000", "5783.00000" ), // high price today, high price 24h ago
        //             "l" => array ( "5505.00000", "5505.00000" ), // low price today, low price 24h ago
        //             "o" => array ( "5760.70000", "5763.40000" ), // open price today, open price 24h ago
        //             "p" => array ( "5631.44067", "5653.78939" ), // $vwap today, $vwap 24h ago
        //             "t" => array ( 11493, 16267 ), // number of trades today, 24 hours ago
        //             "v" => array ( "2634.11501494", "3591.17907851" ), // volume today, volume 24 hours ago
        //         ),
        //         "$ticker",
        //         "XBT/USD"
        //     )
        //
        $wsName = $message[3];
        $name = 'ticker';
        $messageHash = $wsName . ':' . $name;
        $market = $this->safe_value($this->options['marketsByWsName'], $wsName);
        $symbol = $market['symbol'];
        $ticker = $message[1];
        $vwap = floatval ($ticker['p'][0]);
        $quoteVolume = null;
        $baseVolume = floatval ($ticker['v'][0]);
        if ($baseVolume !== null && $vwap !== null) {
            $quoteVolume = $baseVolume * $vwap;
        }
        $last = floatval ($ticker['c'][0]);
        $timestamp = $this->milliseconds ();
        $result = array (
            'symbol' => $symbol,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601 ($timestamp),
            'high' => floatval ($ticker['h'][0]),
            'low' => floatval ($ticker['l'][0]),
            'bid' => floatval ($ticker['b'][0]),
            'bidVolume' => floatval ($ticker['b'][2]),
            'ask' => floatval ($ticker['a'][0]),
            'askVolume' => floatval ($ticker['a'][2]),
            'vwap' => $vwap,
            'open' => floatval ($ticker['o'][0]),
            'close' => $last,
            'last' => $last,
            'previousClose' => null,
            'change' => null,
            'percentage' => null,
            'average' => null,
            'baseVolume' => $baseVolume,
            'quoteVolume' => $quoteVolume,
            'info' => $ticker,
        );
        // todo => add support for multiple tickers (may be tricky)
        // kraken confirms multi-pair subscriptions separately one by one
        // trigger correct fetchWsTickers calls upon receiving any of symbols
        // --------------------------------------------------------------------
        // if there's a corresponding fetchWsTicker call - trigger it
        $this->resolveWsFuture ($client, $messageHash, $result);
    }

    public function fetch_ws_balance ($params = array ()) {
        $this->load_markets();
        throw new NotImplemented($this->id . ' fetchWsBalance() not implemented yet');
    }

    public function handle_ws_trades ($client, $message) {
        //
        //     array (
        //         0, // channelID
        //         array ( //     price        volume         time             side type misc
        //             array ( "5541.20000", "0.15850568", "1534614057.321597", "s", "l", "" ),
        //             array ( "6060.00000", "0.02455000", "1534614057.324998", "b", "l", "" ),
        //         ),
        //         "$trade",
        //         "XBT/USD"
        //     )
        //
        //     // todo => add max limit to the dequeue of trades, unshift and push
        //     $trade = $this->parse_ws_trade ($client, delta, $market);
        //     $this->trades[] = $trade;
        //     tradesCount .= 1;
        //
        $wsName = $message[3];
        // $name = 'ticker';
        // $messageHash = $wsName . ':' . $name;
        $market = $this->safe_value($this->options['marketsByWsName'], $wsName);
        $symbol = $market['symbol'];
        // for ($i = 0; $i < is_array ($message[1]) ? count ($message[1]) : 0; $i++)
        $timestamp = intval ($message[2]);
        $result = array (
            'id' => null,
            'order' => null,
            'info' => $message,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601 ($timestamp),
            'symbol' => $symbol,
            // 'type' => type,
            // 'side' => side,
            'takerOrMaker' => null,
            // 'price' => price,
            // 'amount' => amount,
            // 'cost' => price * amount,
            // 'fee' => fee,
        );
        $result['id'] = null;
        throw NotImplemented ($this->id . ' handleWsTrades() not implemented yet (wip)');
    }

    public function handle_ws_ohlcv ($client, $message) {
        //
        //     array (
        //         216, // channelID
        //         array (
        //             '1574454214.962096', // Time, seconds since epoch
        //             '1574454240.000000', // End timestamp of the interval
        //             '0.020970', // Open price at midnight UTC
        //             '0.020970', // Intraday high price
        //             '0.020970', // Intraday low price
        //             '0.020970', // Closing price at midnight UTC
        //             '0.020970', // Volume weighted average price
        //             '0.08636138', // Accumulated volume today
        //             1, // Number of trades today
        //         ),
        //         'ohlc-1', // Channel Name of subscription
        //         'ETH/XBT', // Asset pair
        //     )
        //
        $wsName = $message[3];
        $name = 'ohlc';
        $candle = $message[1];
        // var_dump (
        //     $this->iso8601 (intval (floatval ($candle[0]) * 1000)), '-',
        //     $this->iso8601 (intval (floatval ($candle[1]) * 1000)), ' => [',
        //     floatval ($candle[2]),
        //     floatval ($candle[3]),
        //     floatval ($candle[4]),
        //     floatval ($candle[5]),
        //     floatval ($candle[7]), ']'
        // );
        $result = [
            intval (floatval ($candle[0]) * 1000),
            floatval ($candle[2]),
            floatval ($candle[3]),
            floatval ($candle[4]),
            floatval ($candle[5]),
            floatval ($candle[7]),
        ];
        $messageHash = $wsName . ':' . $name;
        $this->resolveWsFuture ($client, $messageHash, $result);
    }

    public function fetch_ws_order_book ($symbol, $limit = null, $params = array ()) {
        $name = null;
        if ($limit === null) {
            $name = $this->safe_string($this->options, 'fetchWsOrderBookLevel', 'orderBookL2');
        } else if ($limit === 25) {
            $name = 'orderBookL2_25';
        } else if ($limit === 10) {
            $name = 'orderBookL10';
        } else {
            throw new ExchangeError($this->id . ' fetchWsOrderBook $limit argument must be null (L2), 25 (L2) or 10 (L3)');
        }
        $this->load_markets();
        $market = $this->market ($symbol);
        $messageHash = $name . ':' . $market['id'];
        $url = $this->urls['ws'];
        $request = array (
            'op' => 'subscribe',
            'args' => array (
                $messageHash,
            ),
        );
        return $this->sendWsMessage ($url, $messageHash, array_replace_recursive ($request, $params), $messageHash);
    }

    public function fetch_ws_ohlcv ($symbol, $timeframe = '1m', $since = null, $limit = null, $params = array ()) {
        $name = 'ohlc';
        $request = array (
            'subscription' => array (
                'interval' => intval ($this->timeframes[$timeframe]),
            ),
        );
        return $this->fetchWsPublicMessage ($name, $symbol, array_merge ($request, $params));
    }

    public function load_markets ($reload = false, $params = array ()) {
        $markets = parent::load_markets($reload, $params);
        $marketsByWsName = $this->safe_value($this->options, 'marketsByWsName');
        if (($marketsByWsName === null) || $reload) {
            $marketsByWsName = array();
            for ($i = 0; $i < count ($this->symbols); $i++) {
                $symbol = $this->symbols[$i];
                $market = $this->markets[$symbol];
                if (!$market['darkpool']) {
                    $info = $this->safe_value($market, 'info', array());
                    $wsName = $this->safe_string($info, 'wsname');
                    $marketsByWsName[$wsName] = $market;
                }
            }
            $this->options['marketsByWsName'] = $marketsByWsName;
        }
        return $markets;
    }

    public function fetch_ws_heartbeat ($params = array ()) {
        $this->load_markets();
        $event = 'heartbeat';
        $url = $this->urls['api']['ws'];
        return $this->sendWsMessage ($url, $event);
    }

    public function sign_ws_message ($client, $messageHash, $message, $params = array ()) {
        // todo => not implemented yet
        return $message;
    }

    public function parse_ws_trade ($client, $trade, $market = null) {
        //
        // public trades
        //
        //     array (
        //         "t", // $trade
        //         "42706057", // $id
        //         1, // 1 = buy, 0 = sell
        //         "0.05567134", // $price
        //         "0.00181421", // $amount
        //         1522877119, // $timestamp
        //     )
        //
        $id = (string) $trade[1];
        $side = $trade[2] ? 'buy' : 'sell';
        $price = floatval ($trade[3]);
        $amount = floatval ($trade[4]);
        $timestamp = $trade[5] * 1000;
        $symbol = null;
        if ($market !== null) {
            $symbol = $market['symbol'];
        }
        return array (
            'info' => $trade,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601 ($timestamp),
            'symbol' => $symbol,
            'id' => $id,
            'order' => null,
            'type' => null,
            'takerOrMaker' => null,
            'side' => $side,
            'price' => $price,
            'amount' => $amount,
            'cost' => $price * $amount,
            'fee' => null,
        );
    }

    public function handle_ws_order_book ($client, $message) {
        //
        // first $message (snapshot)
        //
        //     {
        //         $table => 'orderBookL2',
        //         $action => 'partial',
        //         keys => array ( 'symbol', 'id', 'side' ),
        //         types => array (
        //             $symbol => 'symbol',
        //             $id => 'long',
        //             $side => 'symbol',
        //             $size => 'long',
        //             $price => 'float'
        //         ),
        //         foreignKeys => array( $symbol => 'instrument', $side => 'side' ),
        //         attributes => array( $symbol => 'parted', $id => 'sorted' ),
        //         $filter => array( $symbol => 'XBTUSD' ),
        //         $data => array (
        //             array( $symbol => 'XBTUSD', $id => 8700000100, $side => 'Sell', $size => 1, $price => 999999 ),
        //             array( $symbol => 'XBTUSD', $id => 8700000200, $side => 'Sell', $size => 3, $price => 999998 ),
        //             array( $symbol => 'XBTUSD', $id => 8716991250, $side => 'Sell', $size => 26, $price => 830087.5 ),
        //             array( $symbol => 'XBTUSD', $id => 8728701950, $side => 'Sell', $size => 1720, $price => 712980.5 ),
        //         )
        //     }
        //
        // subsequent updates
        //
        //     {
        //         $table => 'orderBookL2',
        //         $action => 'update',
        //         $data => array (
        //             array( $symbol => 'XBTUSD', $id => 8799285100, $side => 'Sell', $size => 70590 ),
        //             array( $symbol => 'XBTUSD', $id => 8799285550, $side => 'Sell', $size => 217652 ),
        //             array( $symbol => 'XBTUSD', $id => 8799288950, $side => 'Buy', $size => 47552 ),
        //             array( $symbol => 'XBTUSD', $id => 8799289250, $side => 'Buy', $size => 78217 ),
        //         )
        //     }
        //
        $action = $this->safe_string($message, 'action');
        $table = $this->safe_string($message, 'table');
        $data = $this->safe_value($message, 'data', array());
        // if it's an initial snapshot
        if ($action === 'partial') {
            $filter = $this->safe_value($message, 'filter', array());
            $marketId = $this->safe_value($filter, 'symbol');
            if (is_array($this->markets_by_id) && array_key_exists($marketId, $this->markets_by_id)) {
                $market = $this->markets_by_id[$marketId];
                $symbol = $market['symbol'];
                if ($table === 'orderBookL2') {
                    $this->orderbooks[$symbol] = $this->indexedOrderBook ();
                } else if ($table === 'orderBookL2_25') {
                    $this->orderbooks[$symbol] = $this->limitedIndexedOrderBook (array(), 25);
                } else if ($table === 'orderBook10') {
                    $this->orderbooks[$symbol] = $this->limitedIndexedOrderBook (array(), 10);
                }
                $orderbook = $this->orderbooks[$symbol];
                for ($i = 0; $i < count ($data); $i++) {
                    $price = $this->safe_float($data[$i], 'price');
                    $size = $this->safe_float($data[$i], 'size');
                    $id = $this->safe_string($data[$i], 'id');
                    $side = $this->safe_string($data[$i], 'side');
                    $side = ($side === 'Buy') ? 'bids' : 'asks';
                    $bookside = $orderbook[$side];
                    $bookside->store ($price, $size, $id);
                }
                $messageHash = $table . ':' . $marketId;
                $this->resolveWsFuture ($client, $messageHash, $orderbook->limit ());
            }
        } else {
            $numUpdatesByMarketId = array();
            for ($i = 0; $i < count ($data); $i++) {
                $marketId = $this->safe_value($data[$i], 'symbol');
                if (is_array($this->markets_by_id) && array_key_exists($marketId, $this->markets_by_id)) {
                    if (!(is_array($numUpdatesByMarketId) && array_key_exists($marketId, $numUpdatesByMarketId))) {
                        $numUpdatesByMarketId[$marketId] = 0;
                    }
                    $numUpdatesByMarketId[$marketId] .= 1;
                    $market = $this->markets_by_id[$marketId];
                    $symbol = $market['symbol'];
                    $orderbook = $this->orderbooks[$symbol];
                    $price = $this->safe_float($data[$i], 'price');
                    $size = $this->safe_float($data[$i], 'size', 0);
                    $id = $this->safe_string($data[$i], 'id');
                    $side = $this->safe_string($data[$i], 'side');
                    $side = ($side === 'Buy') ? 'bids' : 'asks';
                    $bookside = $orderbook[$side];
                    if ($action === 'insert') {
                        $bookside->store ($price, $size, $id);
                    } else {
                        $bookside->restore ($price, $size, $id);
                    }
                }
            }
            $marketIds = is_array($numUpdatesByMarketId) ? array_keys($numUpdatesByMarketId) : array();
            for ($i = 0; $i < count ($marketIds); $i++) {
                $marketId = $marketIds[$i];
                $messageHash = $table . ':' . $marketId;
                $market = $this->markets_by_id[$marketId];
                $symbol = $market['symbol'];
                $orderbook = $this->orderbooks[$symbol];
                $this->resolveWsFuture ($client, $messageHash, $orderbook->limit ());
            }
        }
    }

    public function handle_ws_deltas ($deltas, $bookside, $timestamp) {
        for ($j = 0; $j < count ($deltas); $j++) {
            $delta = $deltas[$j];
            $price = floatval ($delta[0]);
            $amount = floatval ($delta[1]);
            $timestamp = max ($timestamp || 0, intval ($delta[2] * 1000));
            $bookside->store ($price, $amount);
        }
        return $timestamp;
    }

    public function handle_ws_system_status ($client, $message) {
        //
        // todo => answer the question whether this method should be renamed
        // and unified as handleWsStatus for any usage pattern that
        // involves system status and maintenance updates
        //
        //     {
        //         info => 'Welcome to the BitMEX Realtime API.',
        //         version => '2019-11-22T00:24:37.000Z',
        //         timestamp => '2019-11-23T09:02:27.771Z',
        //         docs => 'https://www.bitmex.com/app/wsAPI',
        //         limit => array( remaining => 39 )
        //     }
        //
        return $message;
    }

    public function handle_ws_subscription_status ($client, $message) {
        //
        // todo => answer the question whether this method should be renamed
        // and unified as handleWsResponse for any usage pattern that
        // involves an identified request/response sequence
        //
        //     {
        //         success => true,
        //         subscribe => 'orderBookL2:XBTUSD',
        //         request => array( op => 'subscribe', args => array ( 'orderBookL2:XBTUSD' ) )
        //     }
        //
        // --------------------------------------------------------------------
        //
        // $channelId = $this->safe_string($message, 'channelID');
        // $this->options['subscriptionStatusByChannelId'][$channelId] = $message;
        // $requestId = $this->safe_string($message, 'reqid');
        // if ($client->futures[$requestId]) {
        //     // todo => transpile delete in ccxt
        //     unset($client->futures[$requestId]);
        // }
        //
        return $message;
    }

    public function handle_ws_errors ($client, $message) {
        //
        // generic $error format
        //
        //     array( "$error" => errorMessage )
        //
        // examples
        //
        //     {
        //         "status" => 429,
        //         "$error" => "Rate limit exceeded, retry in 1 seconds.",
        //         "meta" => array( "retryAfter" => 1 ),
        //         "$request" => array( "op" => "subscribe", "$args" => "orderBook" ),
        //     }
        //
        //     array( "$error" => "Rate limit exceeded, retry in 29 seconds." )
        //
        $error = $this->safe_value($message, 'error');
        if ($error !== null) {
            $request = $this->safe_value($message, 'request', array());
            $args = $this->safe_string($request, 'args', array());
            $numArgs = is_array ($args) ? count ($args) : 0;
            if ($numArgs > 0) {
                $messageHash = $args[0];
                $broad = $this->exceptions['ws']['broad'];
                $broadKey = $this->findBroadlyMatchedKey ($broad, $error);
                $exception = null;
                if ($broadKey === null) {
                    $exception = new ExchangeError ($error);
                } else {
                    $exception = new $broad[$broadKey] ($error);
                }
                // var_dump (requestId, $exception);
                $this->rejectWsFuture ($client, $messageHash, $exception);
                return false;
            }
        }
        return true;
    }

    public function handle_ws_message ($client, $message) {
        //
        //     {
        //         info => 'Welcome to the BitMEX Realtime API.',
        //         version => '2019-11-22T00:24:37.000Z',
        //         timestamp => '2019-11-23T09:04:42.569Z',
        //         docs => 'https://www.bitmex.com/app/wsAPI',
        //         limit => array( remaining => 38 )
        //     }
        //
        //     {
        //         success => true,
        //         subscribe => 'orderBookL2:XBTUSD',
        //         request => array( op => 'subscribe', args => array ( 'orderBookL2:XBTUSD' ) )
        //     }
        //
        //     {
        //         $table => 'orderBookL2',
        //         action => 'update',
        //         data => array (
        //             array( symbol => 'XBTUSD', id => 8799284800, side => 'Sell', size => 721000 ),
        //             array( symbol => 'XBTUSD', id => 8799285100, side => 'Sell', size => 70590 ),
        //             array( symbol => 'XBTUSD', id => 8799285550, side => 'Sell', size => 217652 ),
        //             array( symbol => 'XBTUSD', id => 8799285850, side => 'Sell', size => 105578 ),
        //             array( symbol => 'XBTUSD', id => 8799286350, side => 'Sell', size => 172093 ),
        //             array( symbol => 'XBTUSD', id => 8799286650, side => 'Sell', size => 201125 ),
        //             array( symbol => 'XBTUSD', id => 8799288950, side => 'Buy', size => 47552 ),
        //             array( symbol => 'XBTUSD', id => 8799289250, side => 'Buy', size => 78217 ),
        //             array( symbol => 'XBTUSD', id => 8799289700, side => 'Buy', size => 193677 ),
        //             array( symbol => 'XBTUSD', id => 8799290000, side => 'Buy', size => 818161 ),
        //             array( symbol => 'XBTUSD', id => 8799290500, side => 'Buy', size => 218806 ),
        //             array( symbol => 'XBTUSD', id => 8799290800, side => 'Buy', size => 102946 )
        //         )
        //     }
        //
        if ($this->handle_ws_errors ($client, $message)) {
            $table = $this->safe_string($message, 'table');
            $methods = array (
                'orderBookL2' => 'handleWsOrderBook',
                'orderBookL2_25' => 'handleWsOrderBook',
                'orderBook10' => 'handleWsOrderBook',
            );
            $method = $this->safe_string($methods, $table);
            if ($method === null) {
                var_dump ($message);
                return $message;
            } else {
                return $this->$method ($client, $message);
            }
        }
    }
}
