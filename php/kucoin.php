<?php

namespace ccxtpro;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

use Exception; // a common import
use \ccxt\ExchangeError;
use \ccxt\InvalidNonce;

class kucoin extends \ccxt\async\kucoin {

    use ClientTrait;

    public function describe() {
        return $this->deep_extend(parent::describe (), array(
            'has' => array(
                'ws' => true,
                'watchOrderBook' => true,
                'watchTickers' => false, // for now
                'watchTicker' => true,
                'watchTrades' => true,
                'watchBalance' => false, // for now
                'watchOHLCV' => false, // missing on the exchange side
            ),
            'options' => array(
                'tradesLimit' => 1000,
                'watchOrderBookRate' => 100, // get updates every 100ms or 1000ms
                'fetchOrderBookSnapshot' => array(
                    'maxAttempts' => 3, // default number of sync attempts
                    'delay' => 1000, // warmup delay in ms before synchronizing
                ),
            ),
            'streaming' => array(
                // kucoin does not support built-in ws protocol-level ping-pong
                // instead it requires a custom json-based text ping-pong
                // https://docs.kucoin.com/#ping
                'ping' => array($this, 'ping'),
            ),
        ));
    }

    public function negotiate($params = array ()) {
        $client = $this->client('ws');
        $messageHash = 'negotiate';
        $future = $this->safe_value($client->subscriptions, $messageHash);
        if ($future === null) {
            $future = $client->future ($messageHash);
            $client->subscriptions[$messageHash] = $future;
            $response = null;
            $throwException = false;
            if ($this->check_required_credentials($throwException)) {
                $response = yield $this->privatePostBulletPrivate ();
                //
                //     {
                //         code => "200000",
                //         $data => {
                //             $instanceServers => array(
                //                 {
                //                     pingInterval =>  50000,
                //                     $endpoint => "wss://push-private.kucoin.com/endpoint",
                //                     protocol => "websocket",
                //                     encrypt => true,
                //                     pingTimeout => 10000
                //                 }
                //             ),
                //             $token => "2neAiuYvAU61ZDXANAGAsiL4-iAExhsBXZxftpOeh_55i3Ysy2q2LEsEWU64mdzUOPusi34M_wGoSf7iNyEWJ1UQy47YbpY4zVdzilNP-Bj3iXzrjjGlWtiYB9J6i9GjsxUuhPw3BlrzazF6ghq4Lzf7scStOz3KkxjwpsOBCH4=.WNQmhZQeUKIkh97KYgU0Lg=="
                //         }
                //     }
                //
            } else {
                $response = yield $this->publicPostBulletPublic ();
            }
            $client->resolve ($response, $messageHash);
            // $data = $this->safe_value($response, 'data', array());
            // $instanceServers = $this->safe_value($data, 'instanceServers', array());
            // $firstServer = $this->safe_value($instanceServers, 0, array());
            // $endpoint = $this->safe_string($firstServer, 'endpoint');
            // $token = $this->safe_string($data, 'token');
        }
        return yield $future;
    }

    public function request_id() {
        $requestId = $this->sum($this->safe_integer($this->options, 'requestId', 0), 1);
        $this->options['requestId'] = $requestId;
        return $requestId;
    }

    public function subscribe($negotiation, $topic, $method, $symbol, $params = array ()) {
        yield $this->load_markets();
        $market = $this->market($symbol);
        $data = $this->safe_value($negotiation, 'data', array());
        $instanceServers = $this->safe_value($data, 'instanceServers', array());
        $firstServer = $this->safe_value($instanceServers, 0, array());
        $endpoint = $this->safe_string($firstServer, 'endpoint');
        $token = $this->safe_string($data, 'token');
        $nonce = $this->request_id();
        $query = array(
            'token' => $token,
            'acceptUserMessage' => 'true',
            // 'connectId' => $nonce, // user-defined id is supported, received by handleSystemStatus
        );
        $url = $endpoint . '?' . $this->urlencode($query);
        // $topic = '/market/snapshot'; // '/market/ticker';
        $messageHash = $topic . ':' . $market['id'];
        $subscribe = array(
            'id' => $nonce,
            'type' => 'subscribe',
            'topic' => $messageHash,
            'response' => true,
        );
        $subscription = array(
            'id' => (string) $nonce,
            'symbol' => $symbol,
            'topic' => $topic,
            'messageHash' => $messageHash,
            'method' => $method,
        );
        $request = array_merge($subscribe, $params);
        return yield $this->watch($url, $messageHash, $request, $messageHash, $subscription);
    }

    public function watch_ticker($symbol, $params = array ()) {
        yield $this->load_markets();
        $negotiation = yield $this->negotiate();
        $topic = '/market/snapshot';
        return yield $this->subscribe($negotiation, $topic, null, $symbol, $params);
    }

    public function handle_ticker($client, $message) {
        //
        // updates come in every 2 sec unless there
        // were no changes since the previous update
        //
        //     {
        //         "$data" => {
        //             "sequence" => "1545896669291",
        //             "$data" => array(
        //                 "trading" => true,
        //                 "$symbol" => "KCS-BTC",
        //                 "buy" => 0.00011,
        //                 "sell" => 0.00012,
        //                 "sort" => 100,
        //                 "volValue" => 3.13851792584, // total
        //                 "baseCurrency" => "KCS",
        //                 "market" => "BTC",
        //                 "quoteCurrency" => "BTC",
        //                 "symbolCode" => "KCS-BTC",
        //                 "datetime" => 1548388122031,
        //                 "high" => 0.00013,
        //                 "vol" => 27514.34842,
        //                 "low" => 0.0001,
        //                 "changePrice" => -1.0e-5,
        //                 "changeRate" => -0.0769,
        //                 "lastTradedPrice" => 0.00012,
        //                 "board" => 0,
        //                 "mark" => 0
        //             }
        //         ),
        //         "subject" => "trade.snapshot",
        //         "topic" => "/market/snapshot:KCS-BTC",
        //         "type" => "$message"
        //     }
        //
        $data = $this->safe_value($message, 'data', array());
        $rawTicker = $this->safe_value($data, 'data', array());
        $ticker = $this->parse_ticker($rawTicker);
        $symbol = $ticker['symbol'];
        $this->tickers[$symbol] = $ticker;
        $messageHash = $this->safe_string($message, 'topic');
        if ($messageHash !== null) {
            $client->resolve ($ticker, $messageHash);
        }
        return $message;
    }

    public function watch_trades($symbol, $since = null, $limit = null, $params = array ()) {
        yield $this->load_markets();
        $negotiation = yield $this->negotiate();
        $topic = '/market/match';
        $trades = yield $this->subscribe($negotiation, $topic, null, $symbol, $params);
        if ($this->newUpdates) {
            $limit = $trades->getLimit ($symbol, $limit);
        }
        return $this->filter_by_since_limit($trades, $since, $limit, 'timestamp', true);
    }

    public function handle_trade($client, $message) {
        //
        //     {
        //         $data => array(
        //             sequence => '1568787654360',
        //             $symbol => 'BTC-USDT',
        //             side => 'buy',
        //             size => '0.00536577',
        //             price => '9345',
        //             takerOrderId => '5e356c4a9f1a790008f8d921',
        //             time => '1580559434436443257',
        //             type => 'match',
        //             makerOrderId => '5e356bffedf0010008fa5d7f',
        //             tradeId => '5e356c4aeefabd62c62a1ece'
        //         ),
        //         subject => 'trade.l3match',
        //         topic => '/market/match:BTC-USDT',
        //         type => 'message'
        //     }
        //
        $data = $this->safe_value($message, 'data', array());
        $trade = $this->parse_trade($data);
        $messageHash = $this->safe_string($message, 'topic');
        $symbol = $trade['symbol'];
        $trades = $this->safe_value($this->trades, $symbol);
        if ($trades === null) {
            $limit = $this->safe_integer($this->options, 'tradesLimit', 1000);
            $trades = new ArrayCache ($limit);
            $this->trades[$symbol] = $trades;
        }
        $trades->append ($trade);
        $client->resolve ($trades, $messageHash);
        return $message;
    }

    public function watch_order_book($symbol, $limit = null, $params = array ()) {
        //
        // https://docs.kucoin.com/#level-2-market-data
        //
        // 1. After receiving the websocket Level 2 data flow, cache the data.
        // 2. Initiate a REST request to get the snapshot data of Level 2 order book.
        // 3. Playback the cached Level 2 data flow.
        // 4. Apply the new Level 2 data flow to the local snapshot to ensure that
        // the sequence of the new Level 2 update lines up with the sequence of
        // the previous Level 2 data. Discard all the message prior to that
        // sequence, and then playback the change to snapshot.
        // 5. Update the level2 full data based on sequence according to the
        // size. If the price is 0, ignore the messages and update the sequence.
        // If the size=0, update the sequence and remove the price of which the
        // size is 0 out of level 2. For other cases, please update the price.
        //
        if ($limit !== null) {
            if (($limit !== 20) && ($limit !== 100)) {
                throw new ExchangeError($this->id . " watchOrderBook 'limit' argument must be null, 20 or 100");
            }
        }
        yield $this->load_markets();
        $negotiation = yield $this->negotiate();
        $topic = '/market/level2';
        $orderbook = yield $this->subscribe($negotiation, $topic, array($this, 'handle_order_book_subscription'), $symbol, $params);
        return $orderbook->limit ($limit);
    }

    public function fetch_order_book_snapshot($client, $message, $subscription) {
        $symbol = $this->safe_string($subscription, 'symbol');
        $limit = $this->safe_integer($subscription, 'limit');
        $messageHash = $this->safe_string($subscription, 'messageHash');
        try {
            // 2. Initiate a REST request to get the $snapshot $data of Level 2 order book.
            // todo => this is a synch blocking call in ccxt.php - make it async
            $snapshot = yield $this->fetch_order_book($symbol, $limit);
            $orderbook = $this->orderbooks[$symbol];
            $messages = $orderbook->cache;
            // make sure we have at least one delta before fetching the $snapshot
            // otherwise we cannot synchronize the feed with the $snapshot
            // and that will lead to a bidask cross as reported here
            // https://github.com/ccxt/ccxt/issues/6762
            $firstMessage = $this->safe_value($messages, 0, array());
            $data = $this->safe_value($firstMessage, 'data', array());
            $sequenceStart = $this->safe_integer($data, 'sequenceStart');
            $nonce = $this->safe_integer($snapshot, 'nonce');
            $previousSequence = $sequenceStart - 1;
            // if the received $snapshot is earlier than the first cached delta
            // then we cannot align it with the cached deltas and we need to
            // retry synchronizing in $maxAttempts
            if ($nonce < $previousSequence) {
                $options = $this->safe_value($this->options, 'fetchOrderBookSnapshot', array());
                $maxAttempts = $this->safe_integer($options, 'maxAttempts', 3);
                $numAttempts = $this->safe_integer($subscription, 'numAttempts', 0);
                // retry to syncrhonize if we haven't reached $maxAttempts yet
                if ($numAttempts < $maxAttempts) {
                    // safety guard
                    if (is_array($client->subscriptions) && array_key_exists($messageHash, $client->subscriptions)) {
                        $numAttempts = $this->sum($numAttempts, 1);
                        $subscription['numAttempts'] = $numAttempts;
                        $client->subscriptions[$messageHash] = $subscription;
                        $this->spawn(array($this, 'fetch_order_book_snapshot'), $client, $message, $subscription);
                    }
                } else {
                    // throw upon failing to synchronize in $maxAttempts
                    throw new InvalidNonce($this->id . ' failed to synchronize WebSocket feed with the $snapshot for $symbol ' . $symbol . ' in ' . (string) $maxAttempts . ' attempts');
                }
            } else {
                $orderbook->reset ($snapshot);
                // unroll the accumulated deltas
                // 3. Playback the cached Level 2 $data flow.
                for ($i = 0; $i < count($messages); $i++) {
                    $message = $messages[$i];
                    $this->handle_order_book_message($client, $message, $orderbook);
                }
                $this->orderbooks[$symbol] = $orderbook;
                $client->resolve ($orderbook, $messageHash);
            }
        } catch (Exception $e) {
            $client->reject ($e, $messageHash);
        }
    }

    public function handle_delta($bookside, $delta, $nonce) {
        $price = $this->safe_float($delta, 0);
        if ($price > 0) {
            $sequence = $this->safe_integer($delta, 2);
            if ($sequence > $nonce) {
                $amount = $this->safe_float($delta, 1);
                $bookside->store ($price, $amount);
            }
        }
    }

    public function handle_deltas($bookside, $deltas, $nonce) {
        for ($i = 0; $i < count($deltas); $i++) {
            $this->handle_delta($bookside, $deltas[$i], $nonce);
        }
    }

    public function handle_order_book_message($client, $message, $orderbook) {
        //
        //     {
        //         "type":"$message",
        //         "topic":"/market/level2:BTC-USDT",
        //         "subject":"trade.l2update",
        //         "$data":{
        //             "$sequenceStart":1545896669105,
        //             "$sequenceEnd":1545896669106,
        //             "symbol":"BTC-USDT",
        //             "$changes" => {
        //                 "$asks" => [["6","1","1545896669105"]], // price, size, sequence
        //                 "$bids" => [["4","1","1545896669106"]]
        //             }
        //         }
        //     }
        //
        $data = $this->safe_value($message, 'data', array());
        $sequenceEnd = $this->safe_integer($data, 'sequenceEnd');
        // 4. Apply the new Level 2 $data flow to the local snapshot to ensure that
        // the sequence of the new Level 2 update lines up with the sequence of
        // the previous Level 2 $data-> Discard all the $message prior to that
        // sequence, and then playback the change to snapshot.
        if ($sequenceEnd > $orderbook['nonce']) {
            $sequenceStart = $this->safe_integer($message, 'sequenceStart');
            if (($sequenceStart !== null) && (($sequenceStart - 1) > $orderbook['nonce'])) {
                // todo => $client->reject from handleOrderBookMessage properly
                throw new ExchangeError($this->id . ' handleOrderBook received an out-of-order nonce');
            }
            $changes = $this->safe_value($data, 'changes', array());
            $asks = $this->safe_value($changes, 'asks', array());
            $bids = $this->safe_value($changes, 'bids', array());
            $asks = $this->sort_by($asks, 2); // sort by sequence
            $bids = $this->sort_by($bids, 2);
            // 5. Update the level2 full $data based on sequence according to the
            // size. If the price is 0, ignore the messages and update the sequence.
            // If the size=0, update the sequence and remove the price of which the
            // size is 0 out of level 2. For other cases, please update the price.
            $this->handle_deltas($orderbook['asks'], $asks, $orderbook['nonce']);
            $this->handle_deltas($orderbook['bids'], $bids, $orderbook['nonce']);
            $orderbook['nonce'] = $sequenceEnd;
            $orderbook['timestamp'] = null;
            $orderbook['datetime'] = null;
        }
        return $orderbook;
    }

    public function handle_order_book($client, $message) {
        //
        // initial snapshot is fetched with ccxt's fetchOrderBook
        // the feed does not include a snapshot, just the deltas
        //
        //     {
        //         "type":"$message",
        //         "topic":"/market/level2:BTC-USDT",
        //         "subject":"trade.l2update",
        //         "$data":{
        //             "sequenceStart":1545896669105,
        //             "sequenceEnd":1545896669106,
        //             "$symbol":"BTC-USDT",
        //             "changes" => {
        //                 "asks" => [["6","1","1545896669105"]], // price, size, sequence
        //                 "bids" => [["4","1","1545896669106"]]
        //             }
        //         }
        //     }
        //
        $messageHash = $this->safe_string($message, 'topic');
        $data = $this->safe_value($message, 'data');
        $marketId = $this->safe_string($data, 'symbol');
        $symbol = $this->safe_symbol($marketId, null, '-');
        $orderbook = $this->orderbooks[$symbol];
        if ($orderbook['nonce'] === null) {
            $subscription = $this->safe_value($client->subscriptions, $messageHash);
            $fetchingOrderBookSnapshot = $this->safe_value($subscription, 'fetchingOrderBookSnapshot');
            if ($fetchingOrderBookSnapshot === null) {
                $subscription['fetchingOrderBookSnapshot'] = true;
                $client->subscriptions[$messageHash] = $subscription;
                $options = $this->safe_value($this->options, 'fetchOrderBookSnapshot', array());
                $delay = $this->safe_integer($options, 'delay', $this->rateLimit);
                // fetch the snapshot in a separate async call after a warmup $delay
                $this->delay($delay, array($this, 'fetch_order_book_snapshot'), $client, $message, $subscription);
            }
            // 1. After receiving the websocket Level 2 $data flow, cache the $data->
            $orderbook->cache[] = $message;
        } else {
            $this->handle_order_book_message($client, $message, $orderbook);
            $client->resolve ($orderbook, $messageHash);
        }
    }

    public function handle_order_book_subscription($client, $message, $subscription) {
        $symbol = $this->safe_string($subscription, 'symbol');
        $limit = $this->safe_string($subscription, 'limit');
        if (is_array($this->orderbooks) && array_key_exists($symbol, $this->orderbooks)) {
            unset($this->orderbooks[$symbol]);
        }
        $this->orderbooks[$symbol] = $this->order_book(array(), $limit);
        // moved snapshot initialization to handleOrderBook to fix
        // https://github.com/ccxt/ccxt/issues/6820
        // the general idea is to fetch the snapshot after the first delta
        // but not before, because otherwise we cannot synchronize the feed
    }

    public function handle_subscription_status($client, $message) {
        //
        //     {
        //         $id => '1578090438322',
        //         type => 'ack'
        //     }
        //
        $id = $this->safe_string($message, 'id');
        $subscriptionsById = $this->index_by($client->subscriptions, 'id');
        $subscription = $this->safe_value($subscriptionsById, $id, array());
        $method = $this->safe_value($subscription, 'method');
        if ($method !== null) {
            $method($client, $message, $subscription);
        }
        return $message;
    }

    public function handle_system_status($client, $message) {
        //
        // todo => answer the question whether handleSystemStatus should be renamed
        // and unified as handleStatus for any usage pattern that
        // involves system status and maintenance updates
        //
        //     {
        //         id => '1578090234088', // connectId
        //         type => 'welcome',
        //     }
        //
        return $message;
    }

    public function handle_subject($client, $message) {
        //
        //     {
        //         "type":"$message",
        //         "topic":"/market/level2:BTC-USDT",
        //         "$subject":"trade.l2update",
        //         "data":{
        //             "sequenceStart":1545896669105,
        //             "sequenceEnd":1545896669106,
        //             "symbol":"BTC-USDT",
        //             "changes" => {
        //                 "asks" => [["6","1","1545896669105"]], // price, size, sequence
        //                 "bids" => [["4","1","1545896669106"]]
        //             }
        //         }
        //     }
        //
        $subject = $this->safe_string($message, 'subject');
        $methods = array(
            'trade.l2update' => array($this, 'handle_order_book'),
            'trade.snapshot' => array($this, 'handle_ticker'),
            'trade.l3match' => array($this, 'handle_trade'),
        );
        $method = $this->safe_value($methods, $subject);
        if ($method === null) {
            return $message;
        } else {
            return $method($client, $message);
        }
    }

    public function ping($client) {
        // kucoin does not support built-in ws protocol-level ping-pong
        // instead it requires a custom json-based text ping-pong
        // https://docs.kucoin.com/#ping
        $id = (string) $this->request_id();
        return array(
            'id' => $id,
            'type' => 'ping',
        );
    }

    public function handle_pong($client, $message) {
        // https://docs.kucoin.com/#ping
        $client->lastPong = $this->milliseconds();
        return $message;
    }

    public function handle_error_message($client, $message) {
        return $message;
    }

    public function handle_message($client, $message) {
        if ($this->handle_error_message($client, $message)) {
            $type = $this->safe_string($message, 'type');
            $methods = array(
                // 'heartbeat' => $this->handleHeartbeat,
                'welcome' => array($this, 'handle_system_status'),
                'ack' => array($this, 'handle_subscription_status'),
                'message' => array($this, 'handle_subject'),
                'pong' => array($this, 'handle_pong'),
            );
            $method = $this->safe_value($methods, $type);
            if ($method === null) {
                return $message;
            } else {
                return $method($client, $message);
            }
        }
    }
}
