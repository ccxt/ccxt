<?php

namespace ccxt\async;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

use Exception; // a common import
use ccxt\async\abstract\cryptocom as Exchange;
use ccxt\ExchangeError;
use ccxt\ArgumentsRequired;
use ccxt\NotSupported;
use ccxt\Precise;
use React\Async;
use React\Promise;

class cryptocom extends Exchange {

    public function describe() {
        return $this->deep_extend(parent::describe(), array(
            'id' => 'cryptocom',
            'name' => 'Crypto.com',
            'countries' => array( 'MT' ),
            'version' => 'v2',
            'rateLimit' => 10, // 100 requests per second
            'certified' => true,
            'pro' => true,
            'has' => array(
                'CORS' => false,
                'spot' => true,
                'margin' => true,
                'swap' => null, // has but not fully implemented
                'future' => null, // has but not fully implemented
                'option' => null,
                'borrowMargin' => true,
                'cancelAllOrders' => true,
                'cancelOrder' => true,
                'createOrder' => true,
                'fetchBalance' => true,
                'fetchBidsAsks' => false,
                'fetchBorrowInterest' => true,
                'fetchBorrowRate' => false,
                'fetchBorrowRateHistories' => false,
                'fetchBorrowRateHistory' => false,
                'fetchBorrowRates' => true,
                'fetchClosedOrders' => 'emulated',
                'fetchCurrencies' => false,
                'fetchDepositAddress' => true,
                'fetchDepositAddressesByNetwork' => true,
                'fetchDeposits' => true,
                'fetchDepositWithdrawFee' => 'emulated',
                'fetchDepositWithdrawFees' => true,
                'fetchFundingHistory' => false,
                'fetchFundingRate' => false,
                'fetchFundingRates' => false,
                'fetchMarginMode' => false,
                'fetchMarkets' => true,
                'fetchMyTrades' => true,
                'fetchOHLCV' => true,
                'fetchOpenOrders' => true,
                'fetchOrder' => true,
                'fetchOrderBook' => true,
                'fetchOrders' => true,
                'fetchPositionMode' => false,
                'fetchPositions' => false,
                'fetchStatus' => false,
                'fetchTicker' => true,
                'fetchTickers' => true,
                'fetchTime' => false,
                'fetchTrades' => true,
                'fetchTradingFee' => false,
                'fetchTradingFees' => false,
                'fetchTransactionFees' => false,
                'fetchTransactions' => false,
                'fetchTransfers' => true,
                'fetchWithdrawals' => true,
                'repayMargin' => true,
                'setLeverage' => false,
                'setMarginMode' => false,
                'transfer' => true,
                'withdraw' => true,
            ),
            'timeframes' => array(
                '1m' => '1m',
                '5m' => '5m',
                '15m' => '15m',
                '30m' => '30m',
                '1h' => '1h',
                '4h' => '4h',
                '6h' => '6h',
                '12h' => '12h',
                '1d' => '1D',
                '1w' => '7D',
                '2w' => '14D',
                '1M' => '1M',
            ),
            'urls' => array(
                'logo' => 'https://user-images.githubusercontent.com/1294454/147792121-38ed5e36-c229-48d6-b49a-48d05fc19ed4.jpeg',
                'test' => array(
                    'v1' => 'https://uat-api.3ona.co/exchange/v1',
                    'v2' => 'https://uat-api.3ona.co/v2',
                    'derivatives' => 'https://uat-api.3ona.co/v2',
                ),
                'api' => array(
                    'v1' => 'https://api.crypto.com/exchange/v1',
                    'v2' => 'https://api.crypto.com/v2',
                    'derivatives' => 'https://deriv-api.crypto.com/v1',
                ),
                'www' => 'https://crypto.com/',
                'referral' => 'https://crypto.com/exch/5835vstech',
                'doc' => array(
                    'https://exchange-docs.crypto.com/exchange/v1/rest-ws/index.html',
                    'https://exchange-docs.crypto.com/spot/index.html',
                    'https://exchange-docs.crypto.com/derivatives/index.html',
                ),
                'fees' => 'https://crypto.com/exchange/document/fees-limits',
            ),
            'api' => array(
                'v1' => array(
                    'public' => array(
                        'get' => array(
                            'public/auth' => 10 / 3,
                            'public/get-instruments' => 10 / 3,
                            'public/get-book' => 1,
                            'public/get-candlestick' => 1,
                            'public/get-trades' => 1,
                            'public/get-tickers' => 1,
                            'public/get-valuations' => 1,
                            'public/get-expired-settlement-price' => 10 / 3,
                            'public/get-insurance' => 1,
                        ),
                    ),
                    'private' => array(
                        'post' => array(
                            'private/set-cancel-on-disconnect' => 10 / 3,
                            'private/get-cancel-on-disconnect' => 10 / 3,
                            'private/user-balance' => 10 / 3,
                            'private/user-balance-history' => 10 / 3,
                            'private/get-positions' => 10 / 3,
                            'private/create-order' => 2 / 3,
                            'private/create-order-list' => 10 / 3,
                            'private/cancel-order' => 2 / 3,
                            'private/cancel-order-list' => 10 / 3,
                            'private/cancel-all-orders' => 2 / 3,
                            'private/close-position' => 10 / 3,
                            'private/get-order-history' => 100,
                            'private/get-open-orders' => 10 / 3,
                            'private/get-order-detail' => 1 / 3,
                            'private/get-trades' => 100,
                            'private/change-account-leverage' => 10 / 3,
                            'private/get-transactions' => 10 / 3,
                            'private/create-subaccount-transfer' => 10 / 3,
                            'private/get-subaccount-balances' => 10 / 3,
                            'private/get-order-list' => 10 / 3,
                            'private/create-withdrawal' => 10 / 3,
                            'private/get-currency-networks' => 10 / 3,
                            'private/get-deposit-address' => 10 / 3,
                            'private/get-accounts' => 10 / 3,
                        ),
                    ),
                ),
                'v2' => array(
                    'public' => array(
                        'get' => array(
                            'public/auth' => 1,
                            'public/get-instruments' => 1,
                            'public/get-book' => 1,
                            'public/get-candlestick' => 1,
                            'public/get-ticker' => 1,
                            'public/get-trades' => 1,
                            'public/margin/get-transfer-currencies' => 1,
                            'public/margin/get-load-currenices' => 1,
                            'public/respond-heartbeat' => 1,
                        ),
                    ),
                    'private' => array(
                        'post' => array(
                            'private/set-cancel-on-disconnect' => 10 / 3,
                            'private/get-cancel-on-disconnect' => 10 / 3,
                            'private/create-withdrawal' => 10 / 3,
                            'private/get-withdrawal-history' => 10 / 3,
                            'private/get-currency-networks' => 10 / 3,
                            'private/get-deposit-history' => 10 / 3,
                            'private/get-deposit-address' => 10 / 3,
                            'private/get-account-summary' => 10 / 3,
                            'private/create-order' => 2 / 3,
                            'private/cancel-order' => 2 / 3,
                            'private/cancel-all-orders' => 2 / 3,
                            'private/create-order-list' => 10 / 3,
                            'private/get-order-history' => 10 / 3,
                            'private/get-open-orders' => 10 / 3,
                            'private/get-order-detail' => 1 / 3,
                            'private/get-trades' => 100,
                            'private/margin/get-user-config' => 10 / 3,
                            'private/margin/get-account-summary' => 10 / 3,
                            'private/margin/transfer' => 10 / 3,
                            'private/margin/borrow' => 10 / 3,
                            'private/margin/repay' => 10 / 3,
                            'private/margin/get-transfer-history' => 10 / 3,
                            'private/margin/get-borrow-history' => 10 / 3,
                            'private/margin/get-interest-history' => 10 / 3,
                            'private/margin/get-repay-history' => 10 / 3,
                            'private/margin/get-liquidation-history' => 10 / 3,
                            'private/margin/get-liquidation-orders' => 10 / 3,
                            'private/margin/create-order' => 2 / 3,
                            'private/margin/cancel-order' => 2 / 3,
                            'private/margin/cancel-all-orders' => 2 / 3,
                            'private/margin/get-order-history' => 10 / 3,
                            'private/margin/get-open-orders' => 10 / 3,
                            'private/margin/get-order-detail' => 1 / 3,
                            'private/margin/get-trades' => 100,
                            'private/deriv/transfer' => 10 / 3,
                            'private/deriv/get-transfer-history' => 10 / 3,
                            'private/get-accounts' => 10 / 3,
                            'private/get-subaccount-balances' => 10 / 3,
                            'private/create-subaccount-transfer' => 10 / 3,
                            'private/otc/get-otc-user' => 10 / 3,
                            'private/otc/get-instruments' => 10 / 3,
                            'private/otc/request-quote' => 100,
                            'private/otc/accept-quote' => 100,
                            'private/otc/get-quote-history' => 10 / 3,
                            'private/otc/get-trade-history' => 10 / 3,
                        ),
                    ),
                ),
                'derivatives' => array(
                    'public' => array(
                        'get' => array(
                            'public/auth' => 10 / 3,
                            'public/get-instruments' => 10 / 3,
                            'public/get-book' => 1,
                            'public/get-candlestick' => 1,
                            'public/get-trades' => 1,
                            'public/get-tickers' => 1,
                            'public/get-valuations' => 1,
                            'public/get-expired-settlement-price' => 10 / 3,
                            'public/get-insurance' => 1,
                        ),
                    ),
                    'private' => array(
                        'post' => array(
                            'private/set-cancel-on-disconnect' => 10 / 3,
                            'private/get-cancel-on-disconnect' => 10 / 3,
                            'private/user-balance' => 10 / 3,
                            'private/user-balance-history' => 10 / 3,
                            'private/get-positions' => 10 / 3,
                            'private/create-order' => 2 / 3,
                            'private/create-order-list' => 10 / 3,
                            'private/cancel-order' => 2 / 3,
                            'private/cancel-order-list' => 10 / 3,
                            'private/cancel-all-orders' => 2 / 3,
                            'private/close-position' => 10 / 3,
                            'private/convert-collateral' => 10 / 3,
                            'private/get-order-history' => 100,
                            'private/get-open-orders' => 10 / 3,
                            'private/get-order-detail' => 1 / 3,
                            'private/get-trades' => 100,
                            'private/change-account-leverage' => 10 / 3,
                            'private/get-transactions' => 10 / 3,
                            'private/create-subaccount-transfer' => 10 / 3,
                            'private/get-subaccount-balances' => 10 / 3,
                            'private/get-order-list' => 10 / 3,
                        ),
                    ),
                ),
            ),
            'fees' => array(
                'trading' => array(
                    'maker' => $this->parse_number('0.004'),
                    'taker' => $this->parse_number('0.004'),
                    'tiers' => array(
                        'maker' => array(
                            array( $this->parse_number('0'), $this->parse_number('0.004') ),
                            array( $this->parse_number('25000'), $this->parse_number('0.0035') ),
                            array( $this->parse_number('50000'), $this->parse_number('0.0015') ),
                            array( $this->parse_number('100000'), $this->parse_number('0.001') ),
                            array( $this->parse_number('250000'), $this->parse_number('0.0009') ),
                            array( $this->parse_number('1000000'), $this->parse_number('0.0008') ),
                            array( $this->parse_number('20000000'), $this->parse_number('0.0007') ),
                            array( $this->parse_number('100000000'), $this->parse_number('0.0006') ),
                            array( $this->parse_number('200000000'), $this->parse_number('0.0004') ),
                        ),
                        'taker' => array(
                            array( $this->parse_number('0'), $this->parse_number('0.004') ),
                            array( $this->parse_number('25000'), $this->parse_number('0.0035') ),
                            array( $this->parse_number('50000'), $this->parse_number('0.0025') ),
                            array( $this->parse_number('100000'), $this->parse_number('0.0016') ),
                            array( $this->parse_number('250000'), $this->parse_number('0.00015') ),
                            array( $this->parse_number('1000000'), $this->parse_number('0.00014') ),
                            array( $this->parse_number('20000000'), $this->parse_number('0.00013') ),
                            array( $this->parse_number('100000000'), $this->parse_number('0.00012') ),
                            array( $this->parse_number('200000000'), $this->parse_number('0.0001') ),
                        ),
                    ),
                ),
            ),
            'options' => array(
                'defaultType' => 'spot',
                'accountsById' => array(
                    'funding' => 'SPOT',
                    'spot' => 'SPOT',
                    'margin' => 'MARGIN',
                    'derivatives' => 'DERIVATIVES',
                    'swap' => 'DERIVATIVES',
                    'future' => 'DERIVATIVES',
                ),
                'networks' => array(
                    'BEP20' => 'BSC',
                    'ERC20' => 'ETH',
                    'TRX' => 'TRON',
                    'TRC20' => 'TRON',
                ),
                'networksById' => array(
                    'BSC' => 'BEP20',
                    'ETH' => 'ERC20',
                    'TRON' => 'TRC20',
                ),
                'broker' => 'CCXT_',
            ),
            // https://exchange-docs.crypto.com/spot/index.html#response-and-reason-codes
            'commonCurrencies' => array(
                'USD_STABLE_COIN' => 'USDC',
            ),
            'precisionMode' => TICK_SIZE,
            'exceptions' => array(
                'exact' => array(
                    '10001' => '\\ccxt\\ExchangeError',
                    '10002' => '\\ccxt\\PermissionDenied',
                    '10003' => '\\ccxt\\PermissionDenied',
                    '10004' => '\\ccxt\\BadRequest',
                    '10005' => '\\ccxt\\PermissionDenied',
                    '10006' => '\\ccxt\\DDoSProtection',
                    '10007' => '\\ccxt\\InvalidNonce',
                    '10008' => '\\ccxt\\BadRequest',
                    '10009' => '\\ccxt\\BadRequest',
                    '20001' => '\\ccxt\\BadRequest',
                    '20002' => '\\ccxt\\InsufficientFunds',
                    '20005' => '\\ccxt\\AccountNotEnabled', // array("id":"123xxx","method":"private/margin/xxx","code":"20005","message":"ACCOUNT_NOT_FOUND")
                    '30003' => '\\ccxt\\BadSymbol',
                    '30004' => '\\ccxt\\BadRequest',
                    '30005' => '\\ccxt\\BadRequest',
                    '30006' => '\\ccxt\\InvalidOrder',
                    '30007' => '\\ccxt\\InvalidOrder',
                    '30008' => '\\ccxt\\InvalidOrder',
                    '30009' => '\\ccxt\\InvalidOrder',
                    '30010' => '\\ccxt\\BadRequest',
                    '30013' => '\\ccxt\\InvalidOrder',
                    '30014' => '\\ccxt\\InvalidOrder',
                    '30016' => '\\ccxt\\InvalidOrder',
                    '30017' => '\\ccxt\\InvalidOrder',
                    '30023' => '\\ccxt\\InvalidOrder',
                    '30024' => '\\ccxt\\InvalidOrder',
                    '30025' => '\\ccxt\\InvalidOrder',
                    '40001' => '\\ccxt\\BadRequest',
                    '40002' => '\\ccxt\\BadRequest',
                    '40003' => '\\ccxt\\BadRequest',
                    '40004' => '\\ccxt\\BadRequest',
                    '40005' => '\\ccxt\\BadRequest',
                    '40006' => '\\ccxt\\BadRequest',
                    '40007' => '\\ccxt\\BadRequest',
                    '40101' => '\\ccxt\\AuthenticationError',
                    '50001' => '\\ccxt\\BadRequest',
                    '9010001' => '\\ccxt\\OnMaintenance', // array("code":9010001,"message":"SYSTEM_MAINTENANCE","details":"Crypto.com Exchange is currently under maintenance. Please refer to https://status.crypto.com for more details.")
                ),
            ),
        ));
    }

    public function fetch_markets($params = array ()) {
        return Async\async(function () use ($params) {
            /**
             * @see https://exchange-docs.crypto.com/spot/index.html#public-get-instruments
             * @see https://exchange-docs.crypto.com/derivatives/index.html#public-get-instruments
             * retrieves data on all $markets for cryptocom
             * @param {array} $params extra parameters specific to the exchange api endpoint
             * @return {[array]} an array of objects representing market data
             */
            $promises = array( $this->fetch_spot_markets($params), $this->fetch_derivatives_markets($params) );
            // @ts-ignore
            $promises = Async\await(Promise\all($promises));
            $spotMarkets = $promises[0];
            $derivativeMarkets = $promises[1];
            $markets = $this->array_concat($spotMarkets, $derivativeMarkets);
            return $markets;
        }) ();
    }

    public function fetch_spot_markets($params = array ()) {
        return Async\async(function () use ($params) {
            $response = Async\await($this->v2PublicGetPublicGetInstruments ($params));
            //
            //    {
            //        $id => 11,
            //        method => 'public/get-instruments',
            //        code => 0,
            //        $result => {
            //            'instruments' => array(
            //                array(
            //                    instrument_name => 'NEAR_BTC',
            //                    quote_currency => 'BTC',
            //                    base_currency => 'NEAR',
            //                    price_decimals => '8',
            //                    quantity_decimals => '2',
            //                    margin_trading_enabled => true,
            //                    $margin_trading_enabled_5x => true,
            //                    $margin_trading_enabled_10x => true,
            //                    max_quantity => '100000000',
            //                    min_quantity => '0.01',
            //                    max_price:'1',
            //                    min_price:'0.00000001',
            //                    last_update_date:1667263094857,
            //                    quantity_tick_size:'0.1',
            //                    price_tick_size:'0.00000001'
            //               ),
            //            )
            //        }
            //    }
            //
            $resultResponse = $this->safe_value($response, 'result', array());
            $markets = $this->safe_value($resultResponse, 'instruments', array());
            $result = array();
            for ($i = 0; $i < count($markets); $i++) {
                $market = $markets[$i];
                $id = $this->safe_string($market, 'instrument_name');
                $baseId = $this->safe_string($market, 'base_currency');
                $quoteId = $this->safe_string($market, 'quote_currency');
                $base = $this->safe_currency_code($baseId);
                $quote = $this->safe_currency_code($quoteId);
                $minPrice = $this->safe_string($market, 'min_price');
                $minQuantity = $this->safe_string($market, 'min_quantity');
                $maxLeverage = $this->parse_number('1');
                $margin_trading_enabled_5x = $this->safe_value($market, 'margin_trading_enabled_5x');
                if ($margin_trading_enabled_5x) {
                    $maxLeverage = $this->parse_number('5');
                }
                $margin_trading_enabled_10x = $this->safe_value($market, 'margin_trading_enabled_10x');
                if ($margin_trading_enabled_10x) {
                    $maxLeverage = $this->parse_number('10');
                }
                $result[] = array(
                    'id' => $id,
                    'symbol' => $base . '/' . $quote,
                    'base' => $base,
                    'quote' => $quote,
                    'settle' => null,
                    'baseId' => $baseId,
                    'quoteId' => $quoteId,
                    'settleId' => null,
                    'type' => 'spot',
                    'spot' => true,
                    'margin' => $this->safe_value($market, 'margin_trading_enabled'),
                    'swap' => false,
                    'future' => false,
                    'option' => false,
                    'active' => null,
                    'contract' => false,
                    'linear' => null,
                    'inverse' => null,
                    'contractSize' => null,
                    'expiry' => null,
                    'expiryDatetime' => null,
                    'strike' => null,
                    'optionType' => null,
                    'precision' => array(
                        'amount' => $this->safe_number($market, 'quantity_tick_size'),
                        'price' => $this->safe_number($market, 'price_tick_size'),
                    ),
                    'limits' => array(
                        'leverage' => array(
                            'min' => $this->parse_number('1'),
                            'max' => $maxLeverage,
                        ),
                        'amount' => array(
                            'min' => $this->parse_number($minQuantity),
                            'max' => $this->safe_number($market, 'max_quantity'),
                        ),
                        'price' => array(
                            'min' => $this->parse_number($minPrice),
                            'max' => $this->safe_number($market, 'max_price'),
                        ),
                        'cost' => array(
                            'min' => $this->parse_number(Precise::string_mul($minQuantity, $minPrice)),
                            'max' => null,
                        ),
                    ),
                    'info' => $market,
                );
            }
            return $result;
        }) ();
    }

    public function fetch_derivatives_markets($params = array ()) {
        return Async\async(function () use ($params) {
            $result = array();
            $futuresResponse = Async\await($this->derivativesPublicGetPublicGetInstruments ());
            //
            //     {
            //       id => -1,
            //       method => 'public/get-instruments',
            //       code => 0,
            //       $result => {
            //         $data => array(
            //           array(
            //             $symbol => '1INCHUSD-PERP',
            //             $inst_type => 'PERPETUAL_SWAP',
            //             display_name => '1INCHUSD Perpetual',
            //             base_ccy => '1INCH',
            //             quote_ccy => 'USD_Stable_Coin',
            //             quote_decimals => 4,
            //             quantity_decimals => 0,
            //             price_tick_size => '0.0001',
            //             qty_tick_size => '1',
            //             max_leverage => '50',
            //             tradable => true,
            //             expiry_timestamp_ms => 0,
            //             beta_product => false,
            //             underlying_symbol => '1INCHUSD-INDEX',
            //             put_call => 'UNDEFINED',
            //             strike => '0',
            //             contract_size => '1'
            //           ),
            //         )
            //       }
            //     }
            //
            $futuresResult = $this->safe_value($futuresResponse, 'result', array());
            $data = $this->safe_value($futuresResult, 'data', array());
            for ($i = 0; $i < count($data); $i++) {
                $market = $data[$i];
                $inst_type = $this->safe_string($market, 'inst_type');
                $swap = $inst_type === 'PERPETUAL_SWAP';
                $future = $inst_type === 'FUTURE';
                if ($inst_type === 'CCY_PAIR') {
                    continue; // Found some inconsistencies between spot and derivatives api so use spot api for currency pairs.
                }
                $baseId = $this->safe_string($market, 'base_ccy');
                $quoteId = $this->safe_string($market, 'quote_ccy');
                $base = $this->safe_currency_code($baseId);
                $quote = $this->safe_currency_code($quoteId);
                $symbol = $base . '/' . $quote . ':' . $quote;
                $expiry = $this->safe_integer($market, 'expiry_timestamp_ms');
                if ($expiry === 0) {
                    $expiry = null;
                }
                $type = 'swap';
                if ($future) {
                    $type = 'future';
                    $symbol = $symbol . '-' . $this->yymmdd($expiry);
                }
                $contractSize = $this->safe_number($market, 'contract_size');
                $result[] = array(
                    'id' => $this->safe_string($market, 'symbol'),
                    'symbol' => $symbol,
                    'base' => $base,
                    'quote' => $quote,
                    'settle' => $quote,
                    'baseId' => $baseId,
                    'quoteId' => $quoteId,
                    'settleId' => $quoteId,
                    'type' => $type,
                    'spot' => false,
                    'margin' => false,
                    'swap' => $swap,
                    'future' => $future,
                    'option' => false,
                    'active' => $this->safe_value($market, 'tradable'),
                    'contract' => true,
                    'linear' => true,
                    'inverse' => false,
                    'contractSize' => $contractSize,
                    'expiry' => $expiry,
                    'expiryDatetime' => $this->iso8601($expiry),
                    'strike' => null,
                    'optionType' => null,
                    'precision' => array(
                        'price' => $this->parse_number($this->parse_precision($this->safe_string($market, 'quote_decimals'))),
                        'amount' => $this->parse_number($this->parse_precision($this->safe_string($market, 'quantity_decimals'))),
                    ),
                    'limits' => array(
                        'leverage' => array(
                            'min' => $this->parse_number('1'),
                            'max' => $this->safe_number($market, 'max_leverage'),
                        ),
                        'amount' => array(
                            'min' => $this->parse_number($contractSize),
                            'max' => null,
                        ),
                        'price' => array(
                            'min' => null,
                            'max' => null,
                        ),
                        'cost' => array(
                            'min' => null,
                            'max' => null,
                        ),
                    ),
                    'info' => $market,
                );
            }
            return $result;
        }) ();
    }

    public function fetch_tickers(?array $symbols = null, $params = array ()) {
        return Async\async(function () use ($symbols, $params) {
            /**
             * fetches price tickers for multiple markets, statistical calculations with the information calculated over the past 24 hours each $market
             * @see https://exchange-docs.crypto.com/spot/index.html#public-get-ticker
             * @see https://exchange-docs.crypto.com/derivatives/index.html#public-get-tickers
             * @param {[string]|null} $symbols unified $symbols of the markets to fetch the ticker for, all $market tickers are returned if not assigned
             * @param {array} $params extra parameters specific to the cryptocom api endpoint
             * @return {array} a dictionary of ~@link https://docs.ccxt.com/#/?id=ticker-structure ticker structures~
             */
            Async\await($this->load_markets());
            $symbols = $this->market_symbols($symbols);
            $market = null;
            if ($symbols !== null) {
                $symbol = $this->safe_value($symbols, 0);
                $market = $this->market($symbol);
            }
            list($marketType, $query) = $this->handle_market_type_and_params('fetchTickers', $market, $params);
            $method = $this->get_supported_mapping($marketType, array(
                'spot' => 'v2PublicGetPublicGetTicker',
                'future' => 'derivativesPublicGetPublicGetTickers',
                'swap' => 'derivativesPublicGetPublicGetTickers',
            ));
            $response = Async\await($this->$method ($query));
            //
            //     {
            //         "code":0,
            //         "method":"public/get-ticker",
            //         "result":{
            //         "data" => array(
            //             array("i":"CRO_BTC","b":0.00000890,"k":0.00001179,"a":0.00001042,"t":1591770793901,"v":14905879.59,"h":0.00,"l":0.00,"c":0.00),
            //             array("i":"EOS_USDT","b":2.7676,"k":2.7776,"a":2.7693,"t":1591770798500,"v":774.51,"h":0.05,"l":0.05,"c":0.00),
            //             array("i":"BCH_USDT","b":247.49,"k":251.73,"a":251.67,"t":1591770797601,"v":1.01693,"h":0.01292,"l":0.01231,"c":-0.00047),
            //             array("i":"ETH_USDT","b":239.92,"k":242.59,"a":240.30,"t":1591770798701,"v":0.97575,"h":0.01236,"l":0.01199,"c":-0.00018),
            //             array("i":"ETH_CRO","b":2693.11,"k":2699.84,"a":2699.55,"t":1591770795053,"v":95.680,"h":8.218,"l":7.853,"c":-0.050)
            //         )
            //         }
            //     }
            //
            $result = $this->safe_value($response, 'result', array());
            $data = $this->safe_value($result, 'data', array());
            return $this->parse_tickers($data, $symbols);
        }) ();
    }

    public function fetch_ticker(string $symbol, $params = array ()) {
        return Async\async(function () use ($symbol, $params) {
            /**
             * fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific $market
             * @param {string} $symbol unified $symbol of the $market to fetch the ticker for
             * @param {array} $params extra parameters specific to the cryptocom api endpoint
             * @return {array} a ~@link https://docs.ccxt.com/#/?id=ticker-structure ticker structure~
             */
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $request = array(
                'instrument_name' => $market['id'],
            );
            list($marketType, $query) = $this->handle_market_type_and_params('fetchTicker', $market, $params);
            if ($marketType !== 'spot') {
                throw new NotSupported($this->id . ' fetchTicker() only supports spot markets');
            }
            $response = Async\await($this->v2PublicGetPublicGetTicker (array_merge($request, $query)));
            //
            //   {
            //       "id":"-1",
            //       "method":"public/get-tickers",
            //       "code":"0",
            //       "result":{
            //          "data":array(
            //             array( "i":"BTC_USDT", "h":"20567.16", "l":"20341.39", "a":"20394.23", "v":"2236.3762", "vv":"45739074.30", "c":"-0.0036", "b":"20394.01", "k":"20394.02", "t":"1667406085934" )
            //          )
            //   }
            //
            $resultResponse = $this->safe_value($response, 'result', array());
            $data = $this->safe_value($resultResponse, 'data', array());
            $first = $this->safe_value($data, 0, array());
            return $this->parse_ticker($first, $market);
        }) ();
    }

    public function fetch_orders(?string $symbol = null, ?int $since = null, ?int $limit = null, $params = array ()) {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            /**
             * fetches information on multiple orders made by the user
             * @param {string} $symbol unified $market $symbol of the $market orders were made in
             * @param {int|null} $since the earliest time in ms to fetch orders for
             * @param {int|null} $limit the maximum number of  orde structures to retrieve
             * @param {array} $params extra parameters specific to the cryptocom api endpoint
             * @return {[array]} a list of ~@link https://docs.ccxt.com/#/?id=order-structure order structures~
             */
            if ($symbol === null) {
                throw new ArgumentsRequired($this->id . ' fetchOrders() requires a $symbol argument');
            }
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $request = array(
                'instrument_name' => $market['id'],
            );
            if ($since !== null) {
                // maximum date range is one day
                $request['start_ts'] = $since;
            }
            if ($limit !== null) {
                $request['page_size'] = $limit;
            }
            list($marketType, $marketTypeQuery) = $this->handle_market_type_and_params('fetchOrders', $market, $params);
            $method = $this->get_supported_mapping($marketType, array(
                'spot' => 'v2PrivatePostPrivateGetOrderHistory',
                'margin' => 'v2PrivatePostPrivateMarginGetOrderHistory',
                'future' => 'derivativesPrivatePostPrivateGetOrderHistory',
                'swap' => 'derivativesPrivatePostPrivateGetOrderHistory',
            ));
            list($marginMode, $query) = $this->custom_handle_margin_mode_and_params('fetchOrders', $marketTypeQuery);
            if ($marginMode !== null) {
                $method = 'v2PrivatePostPrivateMarginGetOrderHistory';
            }
            $response = Async\await($this->$method (array_merge($request, $query)));
            //
            // spot and margin
            //     {
            //       id => 1641026542065,
            //       $method => 'private/get-order-history',
            //       code => 0,
            //       result => {
            //         order_list => array(
            //           {
            //             status => 'FILLED',
            //             side => 'BUY',
            //             price => 0,
            //             quantity => 110,
            //             order_id => '2120246337927715937',
            //             client_oid => '',
            //             create_time => 1641025064904,
            //             update_time => 1641025064958,
            //             type => 'MARKET',
            //             instrument_name => 'USDC_USDT',
            //             avg_price => 1.0001,
            //             cumulative_quantity => 110,
            //             cumulative_value => 110.011,
            //             fee_currency => 'USDC',
            //             exec_inst => '',
            //             time_in_force => 'GOOD_TILL_CANCEL'
            //           }
            //         )
            //       }
            //     }
            //
            // swap
            //     {
            //       id => 1641026373106,
            //       $method => 'private/get-order-history',
            //       code => 0,
            //       result => {
            //         $data => array(
            //           {
            //             account_id => '85ff689a-7508-4b96-aa79-dc0545d6e637',
            //             order_id => 13191401932,
            //             client_oid => '1641025941461',
            //             order_type => 'LIMIT',
            //             time_in_force => 'GOOD_TILL_CANCEL',
            //             side => 'BUY',
            //             exec_inst => array(),
            //             quantity => '0.0001',
            //             limit_price => '48000.0',
            //             order_value => '4.80000000',
            //             maker_fee_rate => '0.00050',
            //             taker_fee_rate => '0.00070',
            //             avg_price => '47253.5',
            //             trigger_price => '0.0',
            //             ref_price_type => 'NULL_VAL',
            //             cumulative_quantity => '0.0001',
            //             cumulative_value => '4.72535000',
            //             cumulative_fee => '0.00330775',
            //             status => 'FILLED',
            //             update_user_id => 'ce075bef-b600-4277-bd6e-ff9007251e63',
            //             order_date => '2022-01-01',
            //             instrument_name => 'BTCUSD-PERP',
            //             fee_instrument_name => 'USD_Stable_Coin',
            //             create_time => 1641025941827,
            //             create_time_ns => '1641025941827994756',
            //             update_time => 1641025941827
            //           }
            //         )
            //       }
            //     }
            //
            $data = $this->safe_value($response, 'result', array());
            $orderList = $this->safe_value_2($data, 'order_list', 'data', array());
            return $this->parse_orders($orderList, $market, $since, $limit);
        }) ();
    }

    public function fetch_trades(string $symbol, ?int $since = null, ?int $limit = null, $params = array ()) {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            /**
             * get the list of most recent trades for a particular $symbol
             * @param {string} $symbol unified $symbol of the $market to fetch trades for
             * @param {int|null} $since timestamp in ms of the earliest trade to fetch
             * @param {int|null} $limit the maximum amount of trades to fetch
             * @param {array} $params extra parameters specific to the cryptocom api endpoint
             * @return {[array]} a list of ~@link https://docs.ccxt.com/en/latest/manual.html?#public-trades trade structures~
             */
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $request = array(
                'instrument_name' => $market['id'],
            );
            if ($since !== null) {
                // maximum date range is one day
                $request['start_ts'] = $since;
            }
            if ($limit !== null) {
                $request['page_size'] = $limit;
            }
            list($marketType, $query) = $this->handle_market_type_and_params('fetchTrades', $market, $params);
            $method = $this->get_supported_mapping($marketType, array(
                'spot' => 'v2PublicGetPublicGetTrades',
                'future' => 'derivativesPublicGetPublicGetTrades',
                'swap' => 'derivativesPublicGetPublicGetTrades',
            ));
            $response = Async\await($this->$method (array_merge($request, $query)));
            // {
            //     "code":0,
            //     "method":"public/get-trades",
            //     "result" => {
            //          "instrument_name" => "BTC_USDT",
            //          "data:" => array(
            //              array("dataTime":1591710781947,"d":465533583799589409,"s":"BUY","p":2.96,"q":16.0,"t":1591710781946,"i":"ICX_CRO"),
            //              array("dataTime":1591707701899,"d":465430234542863152,"s":"BUY","p":0.007749,"q":115.0,"t":1591707701898,"i":"VET_USDT"),
            //              array("dataTime":1591710786155,"d":465533724976458209,"s":"SELL","p":25.676,"q":0.55,"t":1591710786154,"i":"XTZ_CRO"),
            //              array("dataTime":1591710783300,"d":465533629172286576,"s":"SELL","p":2.9016,"q":0.6,"t":1591710783298,"i":"XTZ_USDT"),
            //              array("dataTime":1591710784499,"d":465533669425626384,"s":"SELL","p":2.7662,"q":0.58,"t":1591710784498,"i":"EOS_USDT"),
            //              array("dataTime":1591710784700,"d":465533676120104336,"s":"SELL","p":243.21,"q":0.01647,"t":1591710784698,"i":"ETH_USDT"),
            //              array("dataTime":1591710786600,"d":465533739878620208,"s":"SELL","p":253.06,"q":0.00516,"t":1591710786598,"i":"BCH_USDT"),
            //              array("dataTime":1591710786900,"d":465533749959572464,"s":"BUY","p":0.9999,"q":0.2,"t":1591710786898,"i":"USDC_USDT"),
            //              array("dataTime":1591710787500,"d":465533770081010000,"s":"BUY","p":3.159,"q":1.65,"t":1591710787498,"i":"ATOM_USDT"),
            //            )
            //      }
            // }
            $resultResponse = $this->safe_value($response, 'result', array());
            $data = $this->safe_value($resultResponse, 'data', array());
            return $this->parse_trades($data, $market, $since, $limit);
        }) ();
    }

    public function fetch_ohlcv(string $symbol, $timeframe = '1m', ?int $since = null, ?int $limit = null, $params = array ()) {
        return Async\async(function () use ($symbol, $timeframe, $since, $limit, $params) {
            /**
             * @see https://exchange-docs.crypto.com/derivatives/index.html#public-get-candlestick
             * @see https://exchange-docs.crypto.com/spot/index.html#public-get-candlestick
             * fetches historical candlestick $data containing the open, high, low, and close price, and the volume of a $market
             * @param {string} $symbol unified $symbol of the $market to fetch OHLCV $data for
             * @param {string} $timeframe the length of time each candle represents
             * @param {int|null} $since timestamp in ms of the earliest candle to fetch
             * @param {int|null} $limit the maximum amount of candles to fetch
             * @param {array} $params extra parameters specific to the cryptocom api endpoint
             * @return {[[int]]} A list of candles ordered, open, high, low, close, volume
             */
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $request = array(
                'instrument_name' => $market['id'],
                'timeframe' => $this->safe_string($this->timeframes, $timeframe, $timeframe),
            );
            if (!$market['spot']) {
                $reqLimit = 100;
                if ($limit !== null) {
                    $reqLimit = $limit;
                }
                $request['count'] = $reqLimit;
            }
            if ($since !== null) {
                $request['start_ts'] = $since;
            }
            $until = $this->safe_integer_2($params, 'until', 'till');
            $params = $this->omit($params, array( 'until', 'till' ));
            if ($until !== null) {
                $request['end_ts'] = $until;
            }
            $response = null;
            if ($market['spot']) {
                $response = Async\await($this->v2PublicGetPublicGetCandlestick (array_merge($request, $params)));
            } elseif ($market['contract']) {
                $response = Async\await($this->derivativesPublicGetPublicGetCandlestick (array_merge($request, $params)));
            }
            // {
            //     "code":0,
            //     "method":"public/get-candlestick",
            //     "result":{
            //       "instrument_name":"BTC_USDT",
            //       "interval":"5m",
            //       "data":array(
            //         array("t":1596944700000,"o":11752.38,"h":11754.77,"l":11746.65,"c":11753.64,"v":3.694583),
            //         array("t":1596945000000,"o":11753.63,"h":11754.77,"l":11739.83,"c":11746.17,"v":2.073019),
            //         array("t":1596945300000,"o":11746.16,"h":11753.24,"l":11738.1,"c":11740.65,"v":0.867247),
            //         ...
            //       )
            //     }
            // }
            $resultResponse = $this->safe_value($response, 'result', array());
            $data = $this->safe_value($resultResponse, 'data', array());
            return $this->parse_ohlcvs($data, $market, $timeframe, $since, $limit);
        }) ();
    }

    public function fetch_order_book(string $symbol, ?int $limit = null, $params = array ()) {
        return Async\async(function () use ($symbol, $limit, $params) {
            /**
             * fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other $data
             * @param {string} $symbol unified $symbol of the $market to fetch the order book for
             * @param {int|null} $limit the maximum amount of order book entries to return
             * @param {array} $params extra parameters specific to the cryptocom api endpoint
             * @return {array} A dictionary of ~@link https://docs.ccxt.com/#/?id=order-book-structure order book structures~ indexed by $market symbols
             */
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $request = array(
                'instrument_name' => $market['id'],
            );
            if ($limit) {
                $request['depth'] = $limit;
            }
            list($marketType, $query) = $this->handle_market_type_and_params('fetchOrderBook', $market, $params);
            $method = $this->get_supported_mapping($marketType, array(
                'spot' => 'v2PublicGetPublicGetBook',
                'future' => 'derivativesPublicGetPublicGetBook',
                'swap' => 'derivativesPublicGetPublicGetBook',
            ));
            $response = Async\await($this->$method (array_merge($request, $query)));
            // {
            //     "code":0,
            //     "method":"public/get-book",
            //     "result":{
            //       "bids":[[9668.44,0.006325,1.0],[9659.75,0.006776,1.0],[9653.14,0.011795,1.0],[9647.13,0.019434,1.0],[9634.62,0.013765,1.0],[9633.81,0.021395,1.0],[9628.46,0.037834,1.0],[9627.6,0.020909,1.0],[9621.51,0.026235,1.0],[9620.83,0.026701,1.0]],
            //       "asks":[[9697.0,0.68251,1.0],[9697.6,1.722864,2.0],[9699.2,1.664177,2.0],[9700.8,1.824953,2.0],[9702.4,0.85778,1.0],[9704.0,0.935792,1.0],[9713.32,0.002926,1.0],[9716.42,0.78923,1.0],[9732.19,0.00645,1.0],[9737.88,0.020216,1.0]],
            //       "t":1591704180270
            //     }
            // }
            $result = $this->safe_value($response, 'result');
            $data = $this->safe_value($result, 'data');
            $orderBook = $this->safe_value($data, 0);
            $timestamp = $this->safe_integer($orderBook, 't');
            return $this->parse_order_book($orderBook, $symbol, $timestamp);
        }) ();
    }

    public function parse_swap_balance($response) {
        $responseResult = $this->safe_value($response, 'result', array());
        $data = $this->safe_value($responseResult, 'data', array());
        $result = array( 'info' => $response );
        for ($i = 0; $i < count($data); $i++) {
            $balance = $data[$i];
            $currencyId = $this->safe_string($balance, 'instrument_name');
            $code = $this->safe_currency_code($currencyId);
            $account = $this->account();
            $account['total'] = $this->safe_string($balance, 'total_cash_balance');
            $account['free'] = $this->safe_string($balance, 'total_available_balance');
            $result[$code] = $account;
        }
        return $this->safe_balance($result);
    }

    public function parse_spot_balance($response) {
        $data = $this->safe_value($response, 'result', array());
        $coinList = $this->safe_value($data, 'accounts', array());
        $result = array( 'info' => $response );
        for ($i = 0; $i < count($coinList); $i++) {
            $balance = $coinList[$i];
            $currencyId = $this->safe_string($balance, 'currency');
            $code = $this->safe_currency_code($currencyId);
            $account = $this->account();
            $account['total'] = $this->safe_string($balance, 'balance');
            $account['free'] = $this->safe_string($balance, 'available');
            $account['used'] = $this->safe_string($balance, 'order');
            $result[$code] = $account;
        }
        return $this->safe_balance($result);
    }

    public function fetch_balance($params = array ()) {
        return Async\async(function () use ($params) {
            /**
             * $query for balance and get the amount of funds available for trading or funds locked in orders
             * @param {array} $params extra parameters specific to the cryptocom api endpoint
             * @return {array} a ~@link https://docs.ccxt.com/en/latest/manual.html?#balance-structure balance structure~
             */
            Async\await($this->load_markets());
            list($marketType, $marketTypeQuery) = $this->handle_market_type_and_params('fetchBalance', null, $params);
            $method = $this->get_supported_mapping($marketType, array(
                'spot' => 'v2PrivatePostPrivateGetAccountSummary',
                'margin' => 'v2PrivatePostPrivateMarginGetAccountSummary',
                'future' => 'derivativesPrivatePostPrivateUserBalance',
                'swap' => 'derivativesPrivatePostPrivateUserBalance',
            ));
            list($marginMode, $query) = $this->custom_handle_margin_mode_and_params('fetchBalance', $marketTypeQuery);
            if ($marginMode !== null) {
                $method = 'v2PrivatePostPrivateMarginGetAccountSummary';
            }
            $response = Async\await($this->$method ($query));
            // spot
            //     {
            //         "id" => 11,
            //         "method" => "private/get-account-summary",
            //         "code" => 0,
            //         "result" => {
            //             "accounts" => array(
            //                 {
            //                     "balance" => 99999999.905000000000000000,
            //                     "available" => 99999996.905000000000000000,
            //                     "order" => 3.000000000000000000,
            //                     "stake" => 0,
            //                     "currency" => "CRO"
            //                 }
            //             )
            //         }
            //     }
            //
            // margin
            //     {
            //         "id" => 1656529728178,
            //         "method" => "private/margin/get-account-summary",
            //         "code" => 0,
            //         "result" => {
            //             "accounts" => array(
            //                 array(
            //                     "balance" => 0,
            //                     "available" => 0,
            //                     "order" => 0,
            //                     "borrowed" => 0,
            //                     "position" => 0,
            //                     "positionHomeCurrency" => 0,
            //                     "positionBtc" => 0,
            //                     "lastPriceHomeCurrency" => 20111.38,
            //                     "lastPriceBtc" => 1,
            //                     "currency" => "BTC",
            //                     "accrued_interest" => 0,
            //                     "liquidation_price" => 0
            //                 ),
            //             ),
            //             "is_liquidating" => false,
            //             "total_balance" => 16,
            //             "total_balance_btc" => 0.00079556,
            //             "equity_value" => 16,
            //             "equity_value_btc" => 0.00079556,
            //             "total_borrowed" => 0,
            //             "total_borrowed_btc" => 0,
            //             "total_accrued_interest" => 0,
            //             "total_accrued_interest_btc" => 0,
            //             "margin_score" => "GOOD",
            //             "currency" => "USDT"
            //         }
            //     }
            //
            // swap
            //     {
            //       "id" : 1641025392400,
            //       "method" : "private/user-balance",
            //       "code" : 0,
            //       "result" : {
            //         "data" : array( {
            //           "total_available_balance" : "109.56000000",
            //           "total_margin_balance" : "109.56000000",
            //           "total_initial_margin" : "0.00000000",
            //           "total_maintenance_margin" : "0.00000000",
            //           "total_position_cost" : "0.00000000",
            //           "total_cash_balance" : "109.56000000",
            //           "total_collateral_value" : "109.56000000",
            //           "total_session_unrealized_pnl" : "0.00000000",
            //           "instrument_name" : "USD_Stable_Coin",
            //           "total_session_realized_pnl" : "0.00000000",
            //           "position_balances" : array( {
            //             "quantity" : "109.56000000",
            //             "collateral_weight" : "1.000000",
            //             "collateral_amount" : "109.56000000",
            //             "market_value" : "109.56000000",
            //             "max_withdrawal_balance" : "109.56000000",
            //             "instrument_name" : "USD_Stable_Coin"
            //           } ),
            //           "total_effective_leverage" : "0.000000",
            //           "position_limit" : "3000000.00000000",
            //           "used_position_limit" : "0.00000000",
            //           "is_liquidating" : false
            //         } )
            //       }
            //     }
            //
            $parser = $this->get_supported_mapping($marketType, array(
                'spot' => 'parseSpotBalance',
                'margin' => 'parseSpotBalance',
                'future' => 'parseSwapBalance',
                'swap' => 'parseSwapBalance',
            ));
            return $this->$parser ($response);
        }) ();
    }

    public function fetch_order(string $id, ?string $symbol = null, $params = array ()) {
        return Async\async(function () use ($id, $symbol, $params) {
            /**
             * fetches information on an $order made by the user
             * @param {string|null} $symbol unified $symbol of the $market the $order was made in
             * @param {array} $params extra parameters specific to the cryptocom api endpoint
             * @return {array} An ~@link https://docs.ccxt.com/#/?$id=$order-structure $order structure~
             */
            Async\await($this->load_markets());
            $market = null;
            if ($symbol !== null) {
                $market = $this->market($symbol);
            }
            $request = array();
            list($marketType, $marketTypeQuery) = $this->handle_market_type_and_params('fetchOrder', $market, $params);
            list($marginMode, $query) = $this->custom_handle_margin_mode_and_params('fetchOrder', $marketTypeQuery);
            if (($marketType === 'spot') || ($marketType === 'margin') || ($marginMode !== null)) {
                $request['order_id'] = (string) $id;
            } else {
                $request['order_id'] = intval($id);
            }
            $method = $this->get_supported_mapping($marketType, array(
                'spot' => 'v2PrivatePostPrivateGetOrderDetail',
                'margin' => 'v2PrivatePostPrivateMarginGetOrderDetail',
                'future' => 'derivativesPrivatePostPrivateGetOrderDetail',
                'swap' => 'derivativesPrivatePostPrivateGetOrderDetail',
            ));
            if ($marginMode !== null) {
                $method = 'v2PrivatePostPrivateMarginGetOrderDetail';
            }
            $response = Async\await($this->$method (array_merge($request, $query)));
            // {
            //     "id" => 11,
            //     "method" => "private/get-$order-detail",
            //     "code" => 0,
            //     "result" => {
            //       "trade_list" => array(
            //         {
            //           "side" => "BUY",
            //           "instrument_name" => "ETH_CRO",
            //           "fee" => 0.007,
            //           "trade_id" => "371303044218155296",
            //           "create_time" => 1588902493045,
            //           "traded_price" => 7,
            //           "traded_quantity" => 7,
            //           "fee_currency" => "CRO",
            //           "order_id" => "371302913889488619"
            //         }
            //       ),
            //       "order_info" => {
            //         "status" => "FILLED",
            //         "side" => "BUY",
            //         "order_id" => "371302913889488619",
            //         "client_oid" => "9_yMYJDNEeqHxLqtD_2j3g",
            //         "create_time" => 1588902489144,
            //         "update_time" => 1588902493024,
            //         "type" => "LIMIT",
            //         "instrument_name" => "ETH_CRO",
            //         "cumulative_quantity" => 7,
            //         "cumulative_value" => 7,
            //         "avg_price" => 7,
            //         "fee_currency" => "CRO",
            //         "time_in_force" => "GOOD_TILL_CANCEL",
            //         "exec_inst" => "POST_ONLY"
            //       }
            //     }
            // }
            $result = $this->safe_value($response, 'result', array());
            $order = $this->safe_value($result, 'order_info', $result);
            return $this->parse_order($order, $market);
        }) ();
    }

    public function create_order(string $symbol, string $type, string $side, $amount, $price = null, $params = array ()) {
        return Async\async(function () use ($symbol, $type, $side, $amount, $price, $params) {
            /**
             * create a trade order
             * @param {string} $symbol unified $symbol of the $market to create an order in
             * @param {string} $type 'market' or 'limit'
             * @param {string} $side 'buy' or 'sell'
             * @param {float} $amount how much of currency you want to trade in units of base currency
             * @param {float|null} $price the $price at which the order is to be fullfilled, in units of the quote currency, ignored in $market orders
             * @param {array} $params extra parameters specific to the cryptocom api endpoint
             * @return {array} an ~@link https://docs.ccxt.com/#/?id=order-structure order structure~
             */
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $uppercaseType = strtoupper($type);
            $request = array(
                'instrument_name' => $market['id'],
                'side' => strtoupper($side),
                'type' => $uppercaseType,
                'quantity' => $this->amount_to_precision($symbol, $amount),
            );
            if (($uppercaseType === 'LIMIT') || ($uppercaseType === 'STOP_LIMIT')) {
                $request['price'] = $this->price_to_precision($symbol, $price);
            }
            $broker = $this->safe_string($this->options, 'broker', 'CCXT_');
            $clientOrderId = $this->safe_string($params, 'clientOrderId');
            if ($clientOrderId === null) {
                $clientOrderId = $broker . $this->uuid22();
            }
            $request['client_oid'] = $clientOrderId;
            $postOnly = $this->safe_value($params, 'postOnly', false);
            if ($postOnly) {
                $request['exec_inst'] = 'POST_ONLY';
            }
            $params = $this->omit($params, array( 'postOnly', 'clientOrderId' ));
            list($marketType, $marketTypeQuery) = $this->handle_market_type_and_params('createOrder', $market, $params);
            $method = $this->get_supported_mapping($marketType, array(
                'spot' => 'v2PrivatePostPrivateCreateOrder',
                'margin' => 'v2PrivatePostPrivateMarginCreateOrder',
                'future' => 'derivativesPrivatePostPrivateCreateOrder',
                'swap' => 'derivativesPrivatePostPrivateCreateOrder',
            ));
            list($marginMode, $query) = $this->custom_handle_margin_mode_and_params('createOrder', $marketTypeQuery);
            if ($marginMode !== null) {
                $method = 'v2PrivatePostPrivateMarginCreateOrder';
            }
            $response = Async\await($this->$method (array_merge($request, $query)));
            // {
            //     "id" => 11,
            //     "method" => "private/create-order",
            //     "result" => {
            //       "order_id" => "337843775021233500",
            //       "client_oid" => "my_order_0002"
            //     }
            // }
            $result = $this->safe_value($response, 'result', array());
            return $this->parse_order($result, $market);
        }) ();
    }

    public function cancel_all_orders(?string $symbol = null, $params = array ()) {
        return Async\async(function () use ($symbol, $params) {
            /**
             * cancel all open orders
             * @param {string|null} $symbol unified $market $symbol, only orders in the $market of this $symbol are cancelled when $symbol is not null
             * @param {array} $params extra parameters specific to the cryptocom api endpoint
             * @return {[array]} a list of ~@link https://docs.ccxt.com/#/?id=order-structure order structures~
             */
            Async\await($this->load_markets());
            $market = null;
            if ($symbol !== null) {
                $market = $this->market($symbol);
            }
            $request = array();
            list($marketType, $marketTypeQuery) = $this->handle_market_type_and_params('cancelAllOrders', $market, $params);
            list($marginMode, $query) = $this->custom_handle_margin_mode_and_params('cancelAllOrders', $marketTypeQuery);
            if (($marketType === 'spot') || ($marketType === 'margin') || ($marginMode !== null)) {
                if ($symbol === null) {
                    throw new ArgumentsRequired($this->id . ' cancelAllOrders() requires a $symbol argument for ' . $marketType . ' orders');
                }
                $request['instrument_name'] = $market['id'];
            }
            $method = $this->get_supported_mapping($marketType, array(
                'spot' => 'v2PrivatePostPrivateCancelAllOrders',
                'margin' => 'v2PrivatePostPrivateMarginCancelAllOrders',
                'future' => 'derivativesPrivatePostPrivateCancelAllOrders',
                'swap' => 'derivativesPrivatePostPrivateCancelAllOrders',
            ));
            if ($marginMode !== null) {
                $method = 'v2PrivatePostPrivateMarginCancelAllOrders';
            }
            return Async\await($this->$method (array_merge($request, $query)));
        }) ();
    }

    public function cancel_order(string $id, ?string $symbol = null, $params = array ()) {
        return Async\async(function () use ($id, $symbol, $params) {
            /**
             * cancels an open order
             * @param {string} $id order $id
             * @param {string|null} $symbol unified $symbol of the $market the order was made in
             * @param {array} $params extra parameters specific to the cryptocom api endpoint
             * @return {array} An ~@link https://docs.ccxt.com/#/?$id=order-structure order structure~
             */
            Async\await($this->load_markets());
            $market = null;
            if ($symbol !== null) {
                $market = $this->market($symbol);
            }
            $request = array();
            list($marketType, $marketTypeQuery) = $this->handle_market_type_and_params('cancelOrder', $market, $params);
            list($marginMode, $query) = $this->custom_handle_margin_mode_and_params('cancelOrder', $marketTypeQuery);
            if (($marketType === 'spot') || ($marketType === 'margin') || ($marginMode !== null)) {
                if ($symbol === null) {
                    throw new ArgumentsRequired($this->id . ' cancelOrder() requires a $symbol argument for ' . $marketType . ' orders');
                }
                $request['instrument_name'] = $market['id'];
                $request['order_id'] = (string) $id;
            } else {
                $request['order_id'] = intval($id);
            }
            $method = $this->get_supported_mapping($marketType, array(
                'spot' => 'v2PrivatePostPrivateCancelOrder',
                'margin' => 'v2PrivatePostPrivateMarginCancelOrder',
                'future' => 'derivativesPrivatePostPrivateCancelOrder',
                'swap' => 'derivativesPrivatePostPrivateCancelOrder',
            ));
            if ($marginMode !== null) {
                $method = 'v2PrivatePostPrivateMarginCancelOrder';
            }
            $response = Async\await($this->$method (array_merge($request, $query)));
            $result = $this->safe_value($response, 'result', $response);
            return $this->parse_order($result);
        }) ();
    }

    public function fetch_open_orders(?string $symbol = null, ?int $since = null, ?int $limit = null, $params = array ()) {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            /**
             * fetch all unfilled currently open orders
             * @param {string|null} $symbol unified $market $symbol
             * @param {int|null} $since the earliest time in ms to fetch open orders for
             * @param {int|null} $limit the maximum number of  open orders structures to retrieve
             * @param {array} $params extra parameters specific to the cryptocom api endpoint
             * @return {[array]} a list of ~@link https://docs.ccxt.com/#/?id=order-structure order structures~
             */
            Async\await($this->load_markets());
            $market = null;
            $request = array();
            if ($symbol !== null) {
                $market = $this->market($symbol);
                $request['instrument_name'] = $market['id'];
            }
            if ($limit !== null) {
                $request['page_size'] = $limit;
            }
            list($marketType, $marketTypeQuery) = $this->handle_market_type_and_params('fetchOpenOrders', $market, $params);
            $method = $this->get_supported_mapping($marketType, array(
                'spot' => 'v2PrivatePostPrivateGetOpenOrders',
                'margin' => 'v2PrivatePostPrivateMarginGetOpenOrders',
                'future' => 'derivativesPrivatePostPrivateGetOpenOrders',
                'swap' => 'derivativesPrivatePostPrivateGetOpenOrders',
            ));
            list($marginMode, $query) = $this->custom_handle_margin_mode_and_params('fetchOpenOrders', $marketTypeQuery);
            if ($marginMode !== null) {
                $method = 'v2PrivatePostPrivateMarginGetOpenOrders';
            }
            $response = Async\await($this->$method (array_merge($request, $query)));
            // {
            //     "id" => 11,
            //     "method" => "private/get-open-orders",
            //     "code" => 0,
            //     "result" => {
            //       "count" => 1177,
            //       "order_list" => array(
            //         array(
            //           "status" => "ACTIVE",
            //           "side" => "BUY",
            //           "price" => 1,
            //           "quantity" => 1,
            //           "order_id" => "366543374673423753",
            //           "client_oid" => "my_order_0002",
            //           "create_time" => 1588760643829,
            //           "update_time" => 1588760644292,
            //           "type" => "LIMIT",
            //           "instrument_name" => "ETH_CRO",
            //           "cumulative_quantity" => 0,
            //           "cumulative_value" => 0,
            //           "avg_price" => 0,
            //           "fee_currency" => "CRO",
            //           "time_in_force" => "GOOD_TILL_CANCEL"
            //         ),
            //         {
            //           "status" => "ACTIVE",
            //           "side" => "BUY",
            //           "price" => 1,
            //           "quantity" => 1,
            //           "order_id" => "366455245775097673",
            //           "client_oid" => "my_order_0002",
            //           "create_time" => 1588758017375,
            //           "update_time" => 1588758017411,
            //           "type" => "LIMIT",
            //           "instrument_name" => "ETH_CRO",
            //           "cumulative_quantity" => 0,
            //           "cumulative_value" => 0,
            //           "avg_price" => 0,
            //           "fee_currency" => "CRO",
            //           "time_in_force" => "GOOD_TILL_CANCEL"
            //         }
            //       )
            //     }
            // }
            $data = $this->safe_value($response, 'result', array());
            $resultList = $this->safe_value_2($data, 'order_list', 'data', array());
            return $this->parse_orders($resultList, $market, $since, $limit);
        }) ();
    }

    public function fetch_my_trades(?string $symbol = null, ?int $since = null, ?int $limit = null, $params = array ()) {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            /**
             * fetch all trades made by the user
             * @param {string|null} $symbol unified $market $symbol
             * @param {int|null} $since the earliest time in ms to fetch trades for
             * @param {int|null} $limit the maximum number of trades structures to retrieve
             * @param {array} $params extra parameters specific to the cryptocom api endpoint
             * @return {[array]} a list of ~@link https://docs.ccxt.com/#/?id=trade-structure trade structures~
             */
            Async\await($this->load_markets());
            $request = array();
            $market = null;
            if ($symbol !== null) {
                $market = $this->market($symbol);
                $request['instrument_name'] = $market['id'];
            }
            if ($since !== null) {
                // maximum date range is one day
                $request['start_ts'] = $since;
                $endTimestamp = $this->sum($since, 24 * 60 * 60 * 1000);
                $request['end_ts'] = $endTimestamp;
            }
            if ($limit !== null) {
                $request['page_size'] = $limit;
            }
            list($marketType, $marketTypeQuery) = $this->handle_market_type_and_params('fetchMyTrades', $market, $params);
            $method = $this->get_supported_mapping($marketType, array(
                'spot' => 'v2PrivatePostPrivateGetTrades',
                'margin' => 'v2PrivatePostPrivateMarginGetTrades',
                'future' => 'derivativesPrivatePostPrivateGetTrades',
                'swap' => 'derivativesPrivatePostPrivateGetTrades',
            ));
            list($marginMode, $query) = $this->custom_handle_margin_mode_and_params('fetchMyTrades', $marketTypeQuery);
            if ($marginMode !== null) {
                $method = 'v2PrivatePostPrivateMarginGetTrades';
            }
            $response = Async\await($this->$method (array_merge($request, $query)));
            // {
            //     "id" => 11,
            //     "method" => "private/get-trades",
            //     "code" => 0,
            //     "result" => {
            //       "trade_list" => array(
            //         {
            //           "side" => "SELL",
            //           "instrument_name" => "ETH_CRO",
            //           "fee" => 0.014,
            //           "trade_id" => "367107655537806900",
            //           "create_time" => 1588777459755,
            //           "traded_price" => 7,
            //           "traded_quantity" => 1,
            //           "fee_currency" => "CRO",
            //           "order_id" => "367107623521528450"
            //         }
            //       )
            //     }
            // }
            $data = $this->safe_value($response, 'result', array());
            $resultList = $this->safe_value_2($data, 'trade_list', 'data', array());
            return $this->parse_trades($resultList, $market, $since, $limit);
        }) ();
    }

    public function parse_address($addressString) {
        $address = null;
        $tag = null;
        $rawTag = null;
        if (mb_strpos($addressString, '?') > 0) {
            list($address, $rawTag) = explode('?', $addressString);
            $splitted = explode('=', $rawTag);
            $tag = $splitted[1];
        } else {
            $address = $addressString;
        }
        return array( $address, $tag );
    }

    public function withdraw(string $code, $amount, $address, $tag = null, $params = array ()) {
        return Async\async(function () use ($code, $amount, $address, $tag, $params) {
            /**
             * make a withdrawal
             * @param {string} $code unified $currency $code
             * @param {float} $amount the $amount to withdraw
             * @param {string} $address the $address to withdraw to
             * @param {string|null} $tag
             * @param {array} $params extra parameters specific to the cryptocom api endpoint
             * @return {array} a ~@link https://docs.ccxt.com/#/?id=transaction-structure transaction structure~
             */
            list($tag, $params) = $this->handle_withdraw_tag_and_params($tag, $params);
            Async\await($this->load_markets());
            $currency = $this->currency($code);
            $request = array(
                'currency' => $currency['id'],
                'amount' => $amount,
                'address' => $address,
            );
            if ($tag !== null) {
                $request['address_tag'] = $tag;
            }
            $response = Async\await($this->v2PrivatePostPrivateCreateWithdrawal (array_merge($request, $params)));
            //
            //    {
            //        "id":-1,
            //        "method":"private/create-withdrawal",
            //        "code":0,
            //        "result" => {
            //            "id" => 2220,
            //            "amount" => 1,
            //            "fee" => 0.0004,
            //            "symbol" => "BTC",
            //            "address" => "2NBqqD5GRJ8wHy1PYyCXTe9ke5226FhavBf",
            //            "client_wid" => "my_withdrawal_002",
            //            "create_time":1607063412000
            //        }
            //     }
            //
            $result = $this->safe_value($response, 'result');
            return $this->parse_transaction($result, $currency);
        }) ();
    }

    public function fetch_deposit_addresses_by_network(string $code, $params = array ()) {
        return Async\async(function () use ($code, $params) {
            /**
             * fetch a dictionary of $addresses for a $currency, indexed by $network
             * @param {string} $code unified $currency $code of the $currency for the deposit $address
             * @param {array} $params extra parameters specific to the cryptocom api endpoint
             * @return {array} a dictionary of ~@link https://docs.ccxt.com/#/?id=$address-structure $address structures~ indexed by the $network
             */
            Async\await($this->load_markets());
            $currency = $this->currency($code);
            $request = array(
                'currency' => $currency['id'],
            );
            $response = Async\await($this->v2PrivatePostPrivateGetDepositAddress (array_merge($request, $params)));
            // {
            //     "id" => 11,
            //     "method" => "private/get-deposit-$address",
            //     "code" => 0,
            //     "result" => {
            //          "deposit_address_list" => array(
            //              array(
            //                  "currency" => "CRO",
            //                  "create_time" => 1615886328000,
            //                  "id" => "12345",
            //                  "address" => "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",
            //                  "status" => "1",
            //                  "network" => "CRO"
            //              ),
            //              {
            //                  "currency" => "CRO",
            //                  "create_time" => 1615886332000,
            //                  "id" => "12346",
            //                  "address" => "yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy",
            //                  "status" => "1",
            //                  "network" => "ETH"
            //              }
            //          )
            //    }
            // }
            $data = $this->safe_value($response, 'result', array());
            $addresses = $this->safe_value($data, 'deposit_address_list', array());
            $addressesLength = count($addresses);
            if ($addressesLength === 0) {
                throw new ExchangeError($this->id . ' fetchDepositAddressesByNetwork() generating $address->..');
            }
            $result = array();
            for ($i = 0; $i < $addressesLength; $i++) {
                $value = $this->safe_value($addresses, $i);
                $addressString = $this->safe_string($value, 'address');
                $currencyId = $this->safe_string($value, 'currency');
                $responseCode = $this->safe_currency_code($currencyId);
                list($address, $tag) = $this->parse_address($addressString);
                $this->check_address($address);
                $networkId = $this->safe_string($value, 'network');
                $network = $this->safe_network($networkId);
                $result[$network] = array(
                    'info' => $value,
                    'currency' => $responseCode,
                    'address' => $address,
                    'tag' => $tag,
                    'network' => $network,
                );
            }
            return $result;
        }) ();
    }

    public function fetch_deposit_address(string $code, $params = array ()) {
        return Async\async(function () use ($code, $params) {
            /**
             * fetch the deposit address for a currency associated with this account
             * @param {string} $code unified currency $code
             * @param {array} $params extra parameters specific to the cryptocom api endpoint
             * @return {array} an ~@link https://docs.ccxt.com/#/?id=address-structure address structure~
             */
            $network = $this->safe_string_upper($params, 'network');
            $params = $this->omit($params, array( 'network' ));
            $depositAddresses = Async\await($this->fetch_deposit_addresses_by_network($code, $params));
            if (is_array($depositAddresses) && array_key_exists($network, $depositAddresses)) {
                return $depositAddresses[$network];
            } else {
                $keys = is_array($depositAddresses) ? array_keys($depositAddresses) : array();
                return $depositAddresses[$keys[0]];
            }
        }) ();
    }

    public function safe_network($networkId) {
        $networksById = array(
            'BTC' => 'BTC',
            'ETH' => 'ETH',
            'SOL' => 'SOL',
            'BNB' => 'BNB',
            'CRONOS' => 'CRONOS',
            'MATIC' => 'MATIC',
            'OP' => 'OP',
        );
        return $this->safe_string($networksById, $networkId, $networkId);
    }

    public function fetch_deposits(?string $code = null, ?int $since = null, ?int $limit = null, $params = array ()) {
        return Async\async(function () use ($code, $since, $limit, $params) {
            /**
             * fetch all deposits made to an account
             * @param {string|null} $code unified $currency $code
             * @param {int|null} $since the earliest time in ms to fetch deposits for
             * @param {int|null} $limit the maximum number of deposits structures to retrieve
             * @param {array} $params extra parameters specific to the cryptocom api endpoint
             * @return {[array]} a list of ~@link https://docs.ccxt.com/#/?id=transaction-structure transaction structures~
             */
            Async\await($this->load_markets());
            $currency = null;
            $request = array();
            if ($code !== null) {
                $currency = $this->currency($code);
                $request['currency'] = $currency['id'];
            }
            if ($since !== null) {
                // 90 days date range
                $request['start_ts'] = $since;
            }
            if ($limit !== null) {
                $request['page_size'] = $limit;
            }
            $response = Async\await($this->v2PrivatePostPrivateGetDepositHistory (array_merge($request, $params)));
            // {
            //     "id" => 11,
            //     "method" => "private/get-deposit-history",
            //     "code" => 0,
            //     "result" => {
            //       "deposit_list" => array(
            //         {
            //           "currency" => "XRP",
            //           "fee" => 1.0,
            //           "create_time" => 1607063412000,
            //           "id" => "2220",
            //           "update_time" => 1607063460000,
            //           "amount" => 100,
            //           "address" => "2NBqqD5GRJ8wHy1PYyCXTe9ke5226FhavBf?1234567890",
            //           "status" => "1"
            //         }
            //       )
            //     }
            // }
            $data = $this->safe_value($response, 'result', array());
            $depositList = $this->safe_value($data, 'deposit_list', array());
            return $this->parse_transactions($depositList, $currency, $since, $limit);
        }) ();
    }

    public function fetch_withdrawals(?string $code = null, ?int $since = null, ?int $limit = null, $params = array ()) {
        return Async\async(function () use ($code, $since, $limit, $params) {
            /**
             * fetch all withdrawals made from an account
             * @param {string|null} $code unified $currency $code
             * @param {int|null} $since the earliest time in ms to fetch withdrawals for
             * @param {int|null} $limit the maximum number of withdrawals structures to retrieve
             * @param {array} $params extra parameters specific to the cryptocom api endpoint
             * @return {[array]} a list of ~@link https://docs.ccxt.com/#/?id=transaction-structure transaction structures~
             */
            Async\await($this->load_markets());
            $currency = null;
            $request = array();
            if ($code !== null) {
                $currency = $this->currency($code);
                $request['currency'] = $currency['id'];
            }
            if ($since !== null) {
                // 90 days date range
                $request['start_ts'] = $since;
            }
            if ($limit !== null) {
                $request['page_size'] = $limit;
            }
            $response = Async\await($this->v2PrivatePostPrivateGetWithdrawalHistory (array_merge($request, $params)));
            //
            //     {
            //       id => 1640704829096,
            //       method => 'private/get-withdrawal-history',
            //       $code => 0,
            //       result => {
            //         withdrawal_list => array(
            //           {
            //             $currency => 'DOGE',
            //             client_wid => '',
            //             fee => 50,
            //             create_time => 1640425168000,
            //             id => '3180557',
            //             update_time => 1640425168000,
            //             amount => 1102.64092,
            //             address => 'DDrGGqmp5Ddo1QH9tUvDfoL4u4rqys5975',
            //             status => '5',
            //             txid => 'ce23e9e21b6c38eef953070a05110e6dca2fd2bcc76d3381000547b9ff5290b2/0'
            //           }
            //         )
            //       }
            //     }
            //
            $data = $this->safe_value($response, 'result', array());
            $withdrawalList = $this->safe_value($data, 'withdrawal_list', array());
            return $this->parse_transactions($withdrawalList, $currency, $since, $limit);
        }) ();
    }

    public function transfer(string $code, $amount, $fromAccount, $toAccount, $params = array ()) {
        return Async\async(function () use ($code, $amount, $fromAccount, $toAccount, $params) {
            /**
             * transfer $currency internally between wallets on the same account
             * @param {string} $code unified $currency $code
             * @param {float} $amount amount to transfer
             * @param {string} $fromAccount account to transfer from
             * @param {string} $toAccount account to transfer to
             * @param {array} $params extra parameters specific to the cryptocom api endpoint
             * @return {array} a ~@link https://docs.ccxt.com/#/?id=transfer-structure transfer structure~
             */
            Async\await($this->load_markets());
            $currency = $this->currency($code);
            $fromAccount = strtolower($fromAccount);
            $toAccount = strtolower($toAccount);
            $accountsById = $this->safe_value($this->options, 'accountsById', array());
            $fromId = $this->safe_string($accountsById, $fromAccount, $fromAccount);
            $toId = $this->safe_string($accountsById, $toAccount, $toAccount);
            $request = array(
                'currency' => $currency['id'],
                'amount' => floatval($amount),
                'from' => $fromId,
                'to' => $toId,
            );
            $method = 'v2PrivatePostPrivateDerivTransfer';
            if (($fromAccount === 'margin') || ($toAccount === 'margin')) {
                $method = 'v2PrivatePostPrivateMarginTransfer';
            }
            $response = Async\await($this->$method (array_merge($request, $params)));
            //
            //     {
            //         "id" => 11,
            //         "method" => "private/deriv/transfer",
            //         "code" => 0
            //     }
            //
            return $this->parse_transfer($response, $currency);
        }) ();
    }

    public function fetch_transfers(?string $code = null, ?int $since = null, ?int $limit = null, $params = array ()) {
        return Async\async(function () use ($code, $since, $limit, $params) {
            /**
             * fetch a history of internal transfers made on an account
             * @param {string|null} $code unified $currency $code of the $currency transferred
             * @param {int|null} $since the earliest time in ms to fetch transfers for
             * @param {int|null} $limit the maximum number of  transfers structures to retrieve
             * @param {array} $params extra parameters specific to the cryptocom api endpoint
             * @return {[array]} a list of ~@link https://docs.ccxt.com/#/?id=$transfer-structure $transfer structures~
             */
            if (!(is_array($params) && array_key_exists('direction', $params))) {
                throw new ArgumentsRequired($this->id . ' fetchTransfers() requires a direction param to be either "IN" or "OUT"');
            }
            Async\await($this->load_markets());
            $currency = null;
            $request = array(
                'direction' => 'OUT',
            );
            if ($code !== null) {
                $currency = $this->currency($code);
                $request['currency'] = $currency['id'];
            }
            if ($since !== null) {
                $request['start_ts'] = $since;
            }
            if ($limit !== null) {
                $request['page_size'] = $limit;
            }
            $method = 'v2PrivatePostPrivateDerivGetTransferHistory';
            list($marginMode, $query) = $this->custom_handle_margin_mode_and_params('fetchTransfers', $params);
            if ($marginMode !== null) {
                $method = 'v2PrivatePostPrivateMarginGetTransferHistory';
            }
            $response = Async\await($this->$method (array_merge($request, $query)));
            //
            //     {
            //       id => '1641032709328',
            //       $method => 'private/deriv/get-$transfer-history',
            //       $code => '0',
            //       result => {
            //         transfer_list => array(
            //           {
            //             direction => 'IN',
            //             time => '1641025185223',
            //             amount => '109.56',
            //             status => 'COMPLETED',
            //             information => 'From Spot Wallet',
            //             $currency => 'USDC'
            //           }
            //         )
            //       }
            //     }
            //
            $transfer = array();
            $transfer[] = array(
                'response' => $response,
            );
            return $this->parse_transfers($transfer, $currency, $since, $limit, $params);
        }) ();
    }

    public function parse_transfer_status($status) {
        $statuses = array(
            'COMPLETED' => 'ok',
            'PROCESSING' => 'pending',
        );
        return $this->safe_string($statuses, $status, $status);
    }

    public function parse_transfer($transfer, $currency = null) {
        //
        //   {
        //     $response => {
        //       id => '1641032709328',
        //       $method => 'private/deriv/get-$transfer-history',
        //       $code => '0',
        //       $result => {
        //         transfer_list => array(
        //           {
        //             $direction => 'IN',
        //             time => '1641025185223',
        //             $amount => '109.56',
        //             $status => 'COMPLETED',
        //             $information => 'From Spot Wallet',
        //             $currency => 'USDC'
        //           }
        //         )
        //       }
        //     }
        //   }
        //
        $response = $this->safe_value($transfer, 'response', array());
        $result = $this->safe_value($response, 'result', array());
        $transferList = $this->safe_value($result, 'transfer_list', array());
        $timestamp = null;
        $amount = null;
        $code = null;
        $information = null;
        $status = null;
        for ($i = 0; $i < count($transferList); $i++) {
            $entry = $transferList[$i];
            $timestamp = $this->safe_integer($entry, 'time');
            $amount = $this->safe_number($entry, 'amount');
            $currencyId = $this->safe_string($entry, 'currency');
            $code = $this->safe_currency_code($currencyId);
            $information = $this->safe_string($entry, 'information');
            $rawStatus = $this->safe_string($entry, 'status');
            $status = $this->parse_transfer_status($rawStatus);
        }
        $fromAccount = null;
        $toAccount = null;
        if ($information !== null) {
            $parts = explode(' ', $information);
            $direction = $this->safe_string_lower($parts, 0);
            $method = $this->safe_string($response, 'method');
            if ($direction === 'from') {
                $fromAccount = $this->safe_string_lower($parts, 1);
                if ($method === 'private/margin/get-$transfer-history') {
                    $toAccount = 'margin';
                } else {
                    $toAccount = 'derivative';
                }
            } elseif ($direction === 'to') {
                $toAccount = $this->safe_string_lower($parts, 1);
                if ($method === 'private/margin/get-$transfer-history') {
                    $fromAccount = 'margin';
                } else {
                    $fromAccount = 'derivative';
                }
            }
        }
        return array(
            'info' => $transferList,
            'id' => $this->safe_string($response, 'id'),
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'currency' => $code,
            'amount' => $amount,
            'fromAccount' => $fromAccount,
            'toAccount' => $toAccount,
            'status' => $status,
        );
    }

    public function parse_ticker($ticker, $market = null) {
        // {
        //     "i":"CRO_BTC",
        //     "b":0.00000890,
        //     "k":0.00001179,
        //     "a":0.00001042,
        //     "t":1591770793901,
        //     "v":14905879.59,
        //     "h":0.00,
        //     "l":0.00,
        //     "c":0.00
        // }
        $timestamp = $this->safe_integer($ticker, 't');
        $marketId = $this->safe_string($ticker, 'i');
        $market = $this->safe_market($marketId, $market, '_');
        $symbol = $market['symbol'];
        $last = $this->safe_string($ticker, 'a');
        $relativeChange = $this->safe_string($ticker, 'c');
        return $this->safe_ticker(array(
            'symbol' => $symbol,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'high' => $this->safe_string($ticker, 'h'),
            'low' => $this->safe_string($ticker, 'l'),
            'bid' => $this->safe_string($ticker, 'b'),
            'bidVolume' => null,
            'ask' => $this->safe_string($ticker, 'k'),
            'askVolume' => null,
            'vwap' => null,
            'open' => null,
            'close' => $last,
            'last' => $last,
            'previousClose' => null,
            'change' => $relativeChange,
            'percentage' => null,
            'average' => null,
            'baseVolume' => $this->safe_string($ticker, 'v'),
            'quoteVolume' => null,
            'info' => $ticker,
        ), $market);
    }

    public function parse_trade($trade, $market = null) {
        //
        // public/get-trades
        //
        // array("dataTime":1591710781947,"d":465533583799589409,"s":"BUY","p":2.96,"q":16.0,"t":1591710781946,"i":"ICX_CRO"),
        //
        // private/get-trades
        //
        // {
        //     "side" => "SELL",
        //     "instrument_name" => "ETH_CRO",
        //     "fee" => 0.014,
        //     "trade_id" => "367107655537806900",
        //     "create_time" => 1588777459755,
        //     "traded_price" => 7,
        //     "traded_quantity" => 1,
        //     "fee_currency" => "CRO",
        //     "order_id" => "367107623521528450"
        // }
        $timestamp = $this->safe_integer_2($trade, 't', 'create_time');
        $marketId = $this->safe_string_2($trade, 'i', 'instrument_name');
        $market = $this->safe_market($marketId, $market, '_');
        $symbol = $market['symbol'];
        $price = $this->safe_string_2($trade, 'p', 'traded_price');
        $amount = $this->safe_string_2($trade, 'q', 'traded_quantity');
        $side = $this->safe_string_2($trade, 's', 'side');
        if ($side !== null) {
            $side = strtolower($side);
        }
        $id = $this->safe_string_2($trade, 'd', 'trade_id');
        $takerOrMaker = $this->safe_string_lower_2($trade, 'liquidity_indicator', 'taker_side');
        $order = $this->safe_string($trade, 'order_id');
        $fee = null;
        $feeCost = $this->safe_string_2($trade, 'fee', 'fees');
        if ($feeCost !== null) {
            $contract = $this->safe_value($market, 'contract', false);
            if ($contract) {
                $feeCost = Precise::string_neg($feeCost);
            }
            $feeCurrency = null;
            if ($market['spot']) {
                $feeCurrency = $this->safe_string($trade, 'fee_currency');
            } elseif ($market['linear']) {
                $feeCurrency = $market['quote'];
            }
            $fee = array(
                'currency' => $feeCurrency,
                'cost' => $feeCost,
            );
        }
        return $this->safe_trade(array(
            'info' => $trade,
            'id' => $id,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'symbol' => $symbol,
            'side' => $side,
            'price' => $price,
            'amount' => $amount,
            'cost' => null,
            'order' => $order,
            'takerOrMaker' => $takerOrMaker,
            'type' => null,
            'fee' => $fee,
        ), $market);
    }

    public function parse_ohlcv($ohlcv, $market = null) {
        //      array("t":1596944700000,"o":11752.38,"h":11754.77,"l":11746.65,"c":11753.64,"v":3.694583)
        return array(
            $this->safe_integer($ohlcv, 't'),
            $this->safe_number($ohlcv, 'o'),
            $this->safe_number($ohlcv, 'h'),
            $this->safe_number($ohlcv, 'l'),
            $this->safe_number($ohlcv, 'c'),
            $this->safe_number($ohlcv, 'v'),
        );
    }

    public function parse_order_status($status) {
        $statuses = array(
            'ACTIVE' => 'open',
            'CANCELED' => 'canceled',
            'FILLED' => 'closed',
            'REJECTED' => 'rejected',
            'EXPIRED' => 'expired',
        );
        return $this->safe_string($statuses, $status, $status);
    }

    public function parse_time_in_force($timeInForce) {
        $timeInForces = array(
            'GOOD_TILL_CANCEL' => 'GTC',
            'IMMEDIATE_OR_CANCEL' => 'IOC',
            'FILL_OR_KILL' => 'FOK',
        );
        return $this->safe_string($timeInForces, $timeInForce, $timeInForce);
    }

    public function parse_order($order, $market = null) {
        //       {
        //         "status" => "FILLED",
        //         "side" => "BUY",
        //         "order_id" => "371302913889488619",
        //         "client_oid" => "9_yMYJDNEeqHxLqtD_2j3g",
        //         "create_time" => 1588902489144,
        //         "update_time" => 1588902493024,
        //         "type" => "LIMIT",
        //         "instrument_name" => "ETH_CRO",
        //         "cumulative_quantity" => 7,
        //         "cumulative_value" => 7,
        //         "avg_price" => 7,
        //         "fee_currency" => "CRO",
        //         "time_in_force" => "GOOD_TILL_CANCEL",
        //         "exec_inst" => "POST_ONLY"
        //       }
        //
        //     {
        //       $id => 1641026373106,
        //       method => 'private/get-$order-history',
        //       code => 0,
        //       result => {
        //         data => array(
        //           {
        //             account_id => '85ff689a-7508-4b96-aa79-dc0545d6e637',
        //             order_id => 13191401932,
        //             client_oid => '1641025941461',
        //             order_type => 'LIMIT',
        //             time_in_force => 'GOOD_TILL_CANCEL',
        //             $side => 'BUY',
        //             exec_inst => array(),
        //             quantity => '0.0001',
        //             limit_price => '48000.0',
        //             order_value => '4.80000000',
        //             maker_fee_rate => '0.00050',
        //             taker_fee_rate => '0.00070',
        //             avg_price => '47253.5',
        //             trigger_price => '0.0',
        //             ref_price_type => 'NULL_VAL',
        //             cumulative_quantity => '0.0001',
        //             cumulative_value => '4.72535000',
        //             cumulative_fee => '0.00330775',
        //             $status => 'FILLED',
        //             update_user_id => 'ce075bef-b600-4277-bd6e-ff9007251e63',
        //             order_date => '2022-01-01',
        //             instrument_name => 'BTCUSD-PERP',
        //             fee_instrument_name => 'USD_Stable_Coin',
        //             create_time => 1641025941827,
        //             create_time_ns => '1641025941827994756',
        //             update_time => 1641025941827
        //           }
        //         )
        //       }
        //     }
        //
        $created = $this->safe_integer($order, 'create_time');
        $updated = $this->safe_integer($order, 'update_time');
        $marketId = $this->safe_string($order, 'instrument_name');
        $symbol = $this->safe_symbol($marketId, $market);
        $amount = $this->safe_string($order, 'quantity');
        $filled = $this->safe_string($order, 'cumulative_quantity');
        $status = $this->parse_order_status($this->safe_string($order, 'status'));
        $id = $this->safe_string($order, 'order_id');
        $clientOrderId = $this->safe_string($order, 'client_oid');
        $price = $this->safe_string_2($order, 'price', 'limit_price');
        $average = $this->safe_string($order, 'avg_price');
        $type = $this->safe_string_lower_2($order, 'type', 'order_type');
        $side = $this->safe_string_lower($order, 'side');
        $timeInForce = $this->parse_time_in_force($this->safe_string($order, 'time_in_force'));
        $execInst = $this->safe_string($order, 'exec_inst');
        $postOnly = null;
        if ($execInst !== null) {
            $postOnly = ($execInst === 'POST_ONLY');
        }
        $cost = $this->safe_string($order, 'cumulative_value');
        $feeCost = $this->safe_string($order, 'cumulative_fee');
        $fee = null;
        if ($feeCost !== null) {
            $feeCurrency = $this->safe_string($order, 'fee_instrument_name');
            $fee = array(
                'cost' => $feeCost,
                'currency' => $this->safe_currency_code($feeCurrency),
            );
        }
        return $this->safe_order(array(
            'info' => $order,
            'id' => $id,
            'clientOrderId' => $clientOrderId,
            'timestamp' => $created,
            'datetime' => $this->iso8601($created),
            'lastTradeTimestamp' => $updated,
            'status' => $status,
            'symbol' => $symbol,
            'type' => $type,
            'timeInForce' => $timeInForce,
            'postOnly' => $postOnly,
            'side' => $side,
            'price' => $price,
            'amount' => $amount,
            'filled' => $filled,
            'remaining' => null,
            'cost' => $cost,
            'fee' => $fee,
            'average' => $average,
            'trades' => array(),
        ), $market);
    }

    public function parse_deposit_status($status) {
        $statuses = array(
            '0' => 'pending',
            '1' => 'ok',
            '2' => 'failed',
            '3' => 'pending',
        );
        return $this->safe_string($statuses, $status, $status);
    }

    public function parse_withdrawal_status($status) {
        $statuses = array(
            '0' => 'pending',
            '1' => 'pending',
            '2' => 'failed',
            '3' => 'pending',
            '4' => 'failed',
            '5' => 'ok',
            '6' => 'canceled',
        );
        return $this->safe_string($statuses, $status, $status);
    }

    public function parse_transaction($transaction, $currency = null) {
        //
        // fetchDeposits
        //
        //     {
        //         "currency" => "XRP",
        //         "fee" => 1.0,
        //         "create_time" => 1607063412000,
        //         "id" => "2220",
        //         "update_time" => 1607063460000,
        //         "amount" => 100,
        //         "address" => "2NBqqD5GRJ8wHy1PYyCXTe9ke5226FhavBf?1234567890",
        //         "status" => "1"
        //     }
        //
        // fetchWithdrawals
        //
        //     {
        //         "currency" => "XRP",
        //         "client_wid" => "my_withdrawal_002",
        //         "fee" => 1.0,
        //         "create_time" => 1607063412000,
        //         "id" => "2220",
        //         "update_time" => 1607063460000,
        //         "amount" => 100,
        //         "address" => "2NBqqD5GRJ8wHy1PYyCXTe9ke5226FhavBf?1234567890",
        //         "status" => "1"
        //     }
        //
        // withdraw
        //
        //     {
        //         "id" => 2220,
        //         "amount" => 1,
        //         "fee" => 0.0004,
        //         "symbol" => "BTC",
        //         "address" => "2NBqqD5GRJ8wHy1PYyCXTe9ke5226FhavBf",
        //         "client_wid" => "my_withdrawal_002",
        //         "create_time":1607063412000
        //     }
        //
        $type = null;
        $rawStatus = $this->safe_string($transaction, 'status');
        $status = null;
        if (is_array($transaction) && array_key_exists('client_wid', $transaction)) {
            $type = 'withdrawal';
            $status = $this->parse_withdrawal_status($rawStatus);
        } else {
            $type = 'deposit';
            $status = $this->parse_deposit_status($rawStatus);
        }
        $id = $this->safe_string($transaction, 'id');
        $addressString = $this->safe_string($transaction, 'address');
        list($address, $tag) = $this->parse_address($addressString);
        $currencyId = $this->safe_string($transaction, 'currency');
        $code = $this->safe_currency_code($currencyId, $currency);
        $timestamp = $this->safe_integer($transaction, 'create_time');
        $amount = $this->safe_number($transaction, 'amount');
        $txId = $this->safe_string($transaction, 'txid');
        $feeCost = $this->safe_number($transaction, 'fee');
        $fee = null;
        if ($feeCost !== null) {
            $fee = array( 'currency' => $code, 'cost' => $feeCost );
        }
        $updated = $this->safe_integer($transaction, 'update_time');
        return array(
            'info' => $transaction,
            'id' => $id,
            'txid' => $txId,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'network' => null,
            'address' => $address,
            'addressTo' => $address,
            'addressFrom' => null,
            'tag' => $tag,
            'tagTo' => $tag,
            'tagFrom' => null,
            'type' => $type,
            'amount' => $amount,
            'currency' => $code,
            'status' => $status,
            'updated' => $updated,
            'internal' => null,
            'fee' => $fee,
        );
    }

    public function repay_margin(string $code, $amount, ?string $symbol = null, $params = array ()) {
        return Async\async(function () use ($code, $amount, $symbol, $params) {
            /**
             * repay borrowed margin and interest
             * @see https://exchange-docs.crypto.com/spot/index.html#private-margin-repay
             * @param {string} $code unified $currency $code of the $currency to repay
             * @param {float} $amount the $amount to repay
             * @param {string|null} $symbol unified market $symbol, not used by cryptocom.repayMargin ()
             * @param {array} $params extra parameters specific to the cryptocom api endpoint
             * @return {array} a ~@link https://docs.ccxt.com/#/?id=margin-loan-structure margin loan structure~
             */
            Async\await($this->load_markets());
            $currency = $this->currency($code);
            $request = array(
                'currency' => $currency['id'],
                'amount' => $this->currency_to_precision($code, $amount),
            );
            $response = Async\await($this->v2PrivatePostPrivateMarginRepay (array_merge($request, $params)));
            //
            //     {
            //         "id" => 1656620104211,
            //         "method" => "private/margin/repay",
            //         "code" => 0,
            //         "result" => {
            //             "badDebt" => 0
            //         }
            //     }
            //
            $transaction = $this->parse_margin_loan($response, $currency);
            return array_merge($transaction, array(
                'amount' => $amount,
            ));
        }) ();
    }

    public function borrow_margin(string $code, $amount, ?string $symbol = null, $params = array ()) {
        return Async\async(function () use ($code, $amount, $symbol, $params) {
            /**
             * create a loan to borrow margin
             * @see https://exchange-docs.crypto.com/spot/index.html#private-margin-borrow
             * @param {string} $code unified $currency $code of the $currency to borrow
             * @param {float} $amount the $amount to borrow
             * @param {string|null} $symbol unified market $symbol, not used by cryptocom.repayMargin ()
             * @param {array} $params extra parameters specific to the cryptocom api endpoint
             * @return {array} a ~@link https://docs.ccxt.com/#/?id=margin-loan-structure margin loan structure~
             */
            Async\await($this->load_markets());
            $currency = $this->currency($code);
            $request = array(
                'currency' => $currency['id'],
                'amount' => $this->currency_to_precision($code, $amount),
            );
            $response = Async\await($this->v2PrivatePostPrivateMarginBorrow (array_merge($request, $params)));
            //
            //     {
            //         "id" => 1656619578559,
            //         "method" => "private/margin/borrow",
            //         "code" => 0
            //     }
            //
            $transaction = $this->parse_margin_loan($response, $currency);
            return array_merge($transaction, array(
                'amount' => $amount,
            ));
        }) ();
    }

    public function parse_margin_loan($info, $currency = null) {
        //
        // borrowMargin
        //
        //     {
        //         "id" => 1656619578559,
        //         "method" => "private/margin/borrow",
        //         "code" => 0
        //     }
        //
        // repayMargin
        //
        //     {
        //         "id" => 1656620104211,
        //         "method" => "private/margin/repay",
        //         "code" => 0,
        //         "result" => {
        //             "badDebt" => 0
        //         }
        //     }
        //
        return array(
            'id' => $this->safe_integer($info, 'id'),
            'currency' => $this->safe_currency_code(null, $currency),
            'amount' => null,
            'symbol' => null,
            'timestamp' => null,
            'datetime' => null,
            'info' => $info,
        );
    }

    public function fetch_borrow_interest(?string $code = null, ?string $symbol = null, ?int $since = null, ?int $limit = null, $params = array ()) {
        return Async\async(function () use ($code, $symbol, $since, $limit, $params) {
            Async\await($this->load_markets());
            $request = array();
            $market = null;
            $currency = null;
            if ($symbol !== null) {
                $market = $this->market($symbol);
            }
            if ($code !== null) {
                $currency = $this->currency($code);
                $request['currency'] = $currency['id'];
            }
            if ($since !== null) {
                $request['start_ts'] = $since;
            }
            if ($limit !== null) {
                $request['page_size'] = $limit;
            }
            $response = Async\await($this->v2PrivatePostPrivateMarginGetInterestHistory (array_merge($request, $params)));
            //
            //     {
            //         "id" => 1656705829020,
            //         "method" => "private/margin/get-$interest-history",
            //         "code" => 0,
            //         "result" => {
            //             "list" => array(
            //                 array(
            //                     "loan_id" => "2643528867803765921",
            //                     "currency" => "USDT",
            //                     "interest" => 0.00000004,
            //                     "time" => 1656702899559,
            //                     "stake_amount" => 6,
            //                     "interest_rate" => 0.000025
            //                 ),
            //             )
            //         }
            //     }
            //
            $data = $this->safe_value($response, 'result', array());
            $rows = $this->safe_value($data, 'list', array());
            $interest = null;
            for ($i = 0; $i < count($rows); $i++) {
                $interest = $this->parse_borrow_interests($rows, $market);
            }
            return $this->filter_by_currency_since_limit($interest, $code, $since, $limit);
        }) ();
    }

    public function parse_borrow_interest($info, $market = null) {
        //
        //     array(
        //         "loan_id" => "2643528867803765921",
        //         "currency" => "USDT",
        //         "interest" => 0.00000004,
        //         "time" => 1656702899559,
        //         "stake_amount" => 6,
        //         "interest_rate" => 0.000025
        //     ),
        //
        $timestamp = $this->safe_integer($info, 'time');
        $symbol = null;
        if ($market !== null) {
            $symbol = $market['symbol'];
        }
        return array(
            'symbol' => $symbol,
            'marginMode' => null,
            'currency' => $this->safe_currency_code($this->safe_string($info, 'currency')),
            'interest' => $this->safe_number($info, 'interest'),
            'interestRate' => $this->safe_number($info, 'interest_rate'), // hourly interest rate
            'amountBorrowed' => null,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'info' => $info,
        );
    }

    public function fetch_borrow_rates($params = array ()) {
        return Async\async(function () use ($params) {
            /**
             * fetch the borrow interest $rates of all currencies
             * @param {array} $params extra parameters specific to the cryptocom api endpoint
             * @return {array} a list of ~@link https://docs.ccxt.com/#/?id=borrow-rate-structure borrow rate structures~
             */
            Async\await($this->load_markets());
            $response = Async\await($this->v2PrivatePostPrivateMarginGetUserConfig ($params));
            //
            //     {
            //         "id" => 1656707947456,
            //         "method" => "private/margin/get-user-config",
            //         "code" => 0,
            //         "result" => {
            //             "stake_amount" => 6,
            //             "currency_configs" => array(
            //                 array(
            //                     "currency" => "AGLD",
            //                     "hourly_rate" => 0.00003334,
            //                     "max_borrow_limit" => 342.4032393,
            //                     "min_borrow_limit" => 30
            //                 ),
            //             )
            //         }
            //     }
            //
            $data = $this->safe_value($response, 'result', array());
            $rates = $this->safe_value($data, 'currency_configs', array());
            return $this->parse_borrow_rates($rates, 'currency');
        }) ();
    }

    public function parse_borrow_rates($info, $codeKey) {
        //
        //     array(
        //         "currency" => "AGLD",
        //         "hourly_rate" => 0.00003334,
        //         "max_borrow_limit" => 342.4032393,
        //         "min_borrow_limit" => 30
        //     ),
        //
        $timestamp = $this->milliseconds();
        $rates = array();
        for ($i = 0; $i < count($info); $i++) {
            $entry = $info[$i];
            $rates[] = array(
                'currency' => $this->safe_currency_code($this->safe_string($entry, 'currency')),
                'rate' => $this->safe_number($entry, 'hourly_rate'),
                'period' => 3600000, // 1-Hour
                'timestamp' => $timestamp,
                'datetime' => $this->iso8601($timestamp),
                'info' => $entry,
            );
        }
        return $rates;
    }

    public function custom_handle_margin_mode_and_params($methodName, $params = array ()) {
        /**
         * @ignore
         * $marginMode specified by $params["marginMode"], $this->options["marginMode"], $this->options["defaultMarginMode"], $params["margin"] = true or $this->options["defaultType"] = 'margin'
         * @param {array} $params extra parameters specific to the exchange api endpoint
         * @return array([string|null, object]) the $marginMode in lowercase
         */
        $defaultType = $this->safe_string($this->options, 'defaultType');
        $isMargin = $this->safe_value($params, 'margin', false);
        $params = $this->omit($params, 'margin');
        $marginMode = null;
        list($marginMode, $params) = $this->handle_margin_mode_and_params($methodName, $params);
        if ($marginMode !== null) {
            if ($marginMode !== 'cross') {
                throw new NotSupported($this->id . ' only cross margin is supported');
            }
        } else {
            if (($defaultType === 'margin') || ($isMargin === true)) {
                $marginMode = 'cross';
            }
        }
        return array( $marginMode, $params );
    }

    public function parse_deposit_withdraw_fee($fee, $currency = null) {
        //
        //    {
        //        full_name => 'Alchemix',
        //        default_network => 'ETH',
        //        network_list => array(
        //          {
        //            network_id => 'ETH',
        //            withdrawal_fee => '0.25000000',
        //            withdraw_enabled => true,
        //            min_withdrawal_amount => '0.5',
        //            deposit_enabled => true,
        //            confirmation_required => '0'
        //          }
        //        )
        //    }
        //
        $networkList = $this->safe_value($fee, 'network_list');
        $networkListLength = count($networkList);
        $result = array(
            'info' => $fee,
            'withdraw' => array(
                'fee' => null,
                'percentage' => null,
            ),
            'deposit' => array(
                'fee' => null,
                'percentage' => null,
            ),
            'networks' => array(),
        );
        if ($networkList !== null) {
            for ($i = 0; $i < $networkListLength; $i++) {
                $networkInfo = $networkList[$i];
                $networkId = $this->safe_string($networkInfo, 'network_id');
                $currencyCode = $this->safe_string($currency, 'code');
                $networkCode = $this->network_id_to_code($networkId, $currencyCode);
                $result['networks'][$networkCode] = array(
                    'deposit' => array( 'fee' => null, 'percentage' => null ),
                    'withdraw' => array( 'fee' => $this->safe_number($networkInfo, 'withdrawal_fee'), 'percentage' => false ),
                );
                if ($networkListLength === 1) {
                    $result['withdraw']['fee'] = $this->safe_number($networkInfo, 'withdrawal_fee');
                    $result['withdraw']['percentage'] = false;
                }
            }
        }
        return $result;
    }

    public function fetch_deposit_withdraw_fees($codes = null, $params = array ()) {
        return Async\async(function () use ($codes, $params) {
            /**
             * fetch deposit and withdraw fees
             * @see https://exchange-docs.crypto.com/spot/index.html#private-get-currency-networks
             * @param {[string]|null} $codes list of unified currency $codes
             * @param {array} $params extra parameters specific to the cryptocom api endpoint
             * @return {array} a list of {@link https://docs.ccxt.com/en/latest/manual.html#fee-structure fee structures}
             */
            Async\await($this->load_markets());
            $response = Async\await($this->v2PrivatePostPrivateGetCurrencyNetworks ($params));
            $data = $this->safe_value($response, 'result');
            $currencyMap = $this->safe_value($data, 'currency_map');
            return $this->parse_deposit_withdraw_fees($currencyMap, $codes, 'full_name');
        }) ();
    }

    public function nonce() {
        return $this->milliseconds();
    }

    public function sign($path, $api = 'public', $method = 'GET', $params = array (), $headers = null, $body = null) {
        $type = $this->safe_string($api, 0);
        $access = $this->safe_string($api, 1);
        $url = $this->urls['api'][$type] . '/' . $path;
        $query = $this->omit($params, $this->extract_params($path));
        if ($access === 'public') {
            if ($query) {
                $url .= '?' . $this->urlencode($query);
            }
        } else {
            $this->check_required_credentials();
            $nonce = (string) $this->nonce();
            $requestParams = array_merge(array(), $params);
            $keysorted = $this->keysort($requestParams);
            $paramsKeys = is_array($keysorted) ? array_keys($keysorted) : array();
            $strSortKey = '';
            for ($i = 0; $i < count($paramsKeys); $i++) {
                $strSortKey = $strSortKey . (string) $paramsKeys[$i] . (string) $requestParams[$paramsKeys[$i]];
            }
            $payload = $path . $nonce . $this->apiKey . $strSortKey . $nonce;
            $signature = $this->hmac($this->encode($payload), $this->encode($this->secret), 'sha256');
            $paramsKeysLength = count($paramsKeys);
            $body = $this->json(array(
                'id' => $nonce,
                'method' => $path,
                'params' => $params,
                'api_key' => $this->apiKey,
                'sig' => $signature,
                'nonce' => $nonce,
            ));
            // fix issue https://github.com/ccxt/ccxt/issues/11179
            // php always encodes dictionaries
            // if an array is empty, php will put it in square brackets
            // python and js will put it in curly brackets
            // the code below checks and replaces those brackets in empty requests
            if ($paramsKeysLength === 0) {
                $paramsString = '{}';
                $arrayString = '[]';
                $body = str_replace($arrayString, $paramsString, $body);
            }
            $headers = array(
                'Content-Type' => 'application/json',
            );
        }
        return array( 'url' => $url, 'method' => $method, 'body' => $body, 'headers' => $headers );
    }

    public function handle_errors($code, $reason, $url, $method, $headers, $body, $response, $requestHeaders, $requestBody) {
        $errorCode = $this->safe_string($response, 'code');
        if ($errorCode !== '0') {
            $feedback = $this->id . ' ' . $body;
            $this->throw_exactly_matched_exception($this->exceptions['exact'], $errorCode, $feedback);
            throw new ExchangeError($this->id . ' ' . $body);
        }
        return null;
    }
}
