<?php

namespace ccxt\async;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

use Exception; // a common import
use ccxt\async\abstract\lykke as Exchange;
use ccxt\ExchangeError;
use ccxt\Precise;
use React\Async;
use React\Promise\PromiseInterface;

class lykke extends Exchange {

    public function describe() {
        return $this->deep_extend(parent::describe(), array(
            'id' => 'lykke',
            'name' => 'Lykke',
            'countries' => array( 'UK' ),
            'version' => '2',
            // 300 requests per minute per method => 60000ms / 300 = 200 (/api/orders/*)
            // 120 requests per minute per method => ( 60000ms / rateLimit ) / 120 = cost = 2.5 (/api/*)
            'rateLimit' => 200, // TODO => optim\ize https://lykkecity.github.io/Trading-API/#request-rate-limits
            'has' => array(
                'CORS' => null,
                'spot' => true,
                'margin' => false,
                'swap' => false,
                'future' => false,
                'option' => false,
                'cancelAllOrders' => true,
                'cancelOrder' => true,
                'createOrder' => true,
                'createStopLimitOrder' => false,
                'createStopMarketOrder' => false,
                'createStopOrder' => false,
                'editOrder' => false,
                'fetchBalance' => true,
                'fetchBorrowRateHistories' => false,
                'fetchBorrowRateHistory' => false,
                'fetchClosedOrders' => true,
                'fetchCrossBorrowRate' => false,
                'fetchCrossBorrowRates' => false,
                'fetchCurrencies' => true,
                'fetchDepositAddress' => true,
                'fetchDepositAddresses' => false,
                'fetchDepositAddressesByNetwork' => false,
                'fetchDeposits' => false,
                'fetchDepositsWithdrawals' => true,
                'fetchFundingHistory' => false,
                'fetchFundingRate' => false,
                'fetchFundingRateHistory' => false,
                'fetchFundingRates' => false,
                'fetchIndexOHLCV' => false,
                'fetchIsolatedBorrowRate' => false,
                'fetchIsolatedBorrowRates' => false,
                'fetchMarginMode' => false,
                'fetchMarkets' => true,
                'fetchMarkOHLCV' => false,
                'fetchMyTrades' => true,
                'fetchOHLCV' => null,
                'fetchOpenInterestHistory' => false,
                'fetchOpenOrders' => true,
                'fetchOrder' => true,
                'fetchOrderBook' => true,
                'fetchOrders' => false,
                'fetchOrderTrades' => false,
                'fetchPosition' => false,
                'fetchPositionHistory' => false,
                'fetchPositionMode' => false,
                'fetchPositions' => false,
                'fetchPositionsForSymbol' => false,
                'fetchPositionsHistory' => false,
                'fetchPositionsRisk' => false,
                'fetchPremiumIndexOHLCV' => false,
                'fetchTicker' => true,
                'fetchTickers' => true,
                'fetchTime' => false,
                'fetchTrades' => true,
                'fetchTradingFee' => false,
                'fetchTradingFees' => false,
                'fetchTransactionFees' => false,
                'fetchTransactions' => 'emulated',
                'fetchWithdrawals' => false,
                'setLeverage' => false,
                'setMarginMode' => false,
                'withdraw' => true,
            ),
            'requiredCredentials' => array(
                'apiKey' => true,
                'secret' => false,
            ),
            'urls' => array(
                'logo' => 'https://user-images.githubusercontent.com/1294454/155840500-1ea4fdf0-47c0-4daa-9597-c6c1cd51b9ec.jpg',
                'api' => array(
                    'public' => 'https://hft-apiv2.lykke.com/api',
                    'private' => 'https://hft-apiv2.lykke.com/api',
                ),
                'www' => 'https://www.lykke.com',
                'doc' => array(
                    'https://hft-apiv2.lykke.com/swagger/ui/index.html',
                    'https://lykkecity.github.io/Trading-API',
                ),
                'fees' => 'https://support.lykke.com/hc/en-us/articles/115002141125-What-are-the-fees-and-charges-', // zero fee
            ),
            'api' => array(
                'public' => array(
                    'get' => array(
                        'assetpairs' => 2.5,
                        'assetpairs/{id}' => 2.5,
                        'assets' => 2.5,
                        'assets/{id}' => 2.5,
                        'isalive' => 2.5,
                        'orderbooks' => 2.5,
                        'tickers' => 2.5,
                        'prices' => 2.5,
                        'trades/public/{assetPairId}' => 2.5,
                    ),
                ),
                'private' => array(
                    'get' => array(
                        'balance' => 2.5,
                        'trades' => 2.5,
                        'trades/order/{orderId}' => 2.5,
                        'orders/active' => 1,
                        'orders/closed' => 1,
                        'orders/{orderId}' => 1,
                        'operations' => 2.5,
                        'operations/deposits/addresses' => 2.5,
                        'operations/deposits/addresses/{assetId}' => 2.5,
                    ),
                    'post' => array(
                        'orders/limit' => 1,
                        'orders/market' => 1,
                        'orders/bulk' => 1,
                        'operations/withdrawals' => 2.5,
                        'operations/deposits/addresses' => 2.5,
                    ),
                    'delete' => array(
                        'orders' => 1,
                        'orders/{orderId}' => 1,
                    ),
                ),
            ),
            'fees' => array(
                'trading' => array(
                    'tierBased' => false,
                    'percentage' => true,
                    'maker' => 0, // https://support.lykke.com/hc/en-us/articles/115002141125-What-are-the-fees-and-min-amounts-
                    'taker' => 0,
                ),
            ),
            'precisionMode' => TICK_SIZE,
            'exceptions' => array(
                'exact' => array(
                    '1001' => '\\ccxt\\ExchangeError',
                    '1100' => '\\ccxt\\ExchangeError',
                    '1101' => '\\ccxt\\ExchangeError',
                    '2000' => '\\ccxt\\BadRequest',
                    '2001' => '\\ccxt\\InsufficientFunds',
                    '2202' => '\\ccxt\\DuplicateOrderId',
                    '2003' => '\\ccxt\\ExchangeError',
                    '2004' => '\\ccxt\\NotSupported',
                    '2005' => '\\ccxt\\ExchangeError',
                    '2006' => '\\ccxt\\InsufficientFunds',
                    '2007' => '\\ccxt\\InsufficientFunds',
                    '2008' => '\\ccxt\\InsufficientFunds',
                    '2009' => '\\ccxt\\ExchangeError',
                    '2010' => '\\ccxt\\InsufficientFunds',
                    '2011' => '\\ccxt\\InvalidOrder',
                    '2012' => '\\ccxt\\InvalidOrder',
                    '2013' => '\\ccxt\\InvalidOrder',
                    '2014' => '\\ccxt\\InvalidOrder',
                    '2015' => '\\ccxt\\InvalidOrder',
                    '2016' => '\\ccxt\\InvalidOrder',
                    '2017' => '\\ccxt\\InvalidOrder',
                    '2018' => '\\ccxt\\InvalidOrder',
                    '2019' => '\\ccxt\\InvalidOrder',
                    '2020' => '\\ccxt\\InvalidOrder',
                    '2021' => '\\ccxt\\InvalidOrder',
                    '2022' => '\\ccxt\\InvalidOrder',
                    '2023' => '\\ccxt\\ExchangeError',
                ),
                'broad' => array(),
            ),
            'commonCurrencies' => array(
            ),
        ));
    }

    public function fetch_currencies($params = array ()): PromiseInterface {
        return Async\async(function () use ($params) {
            /**
             * fetches all available $currencies on an exchange
             * @see https://lykkecity.github.io/Trading-API/#get-all-assets
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} an associative dictionary of $currencies
             */
            $response = Async\await($this->publicGetAssets ($params));
            $currencies = $this->safe_value($response, 'payload', array());
            //
            //     {
            //         "payload":array(
            //             {
            //                 "assetId":"115a60c2-0da1-40f9-a7f2-41da723b9074",
            //                 "name":"Monaco Token",
            //                 "symbol":"MCO",
            //                 "accuracy":6,
            //                 "multiplierPower":8,
            //                 "assetAddress":"",
            //                 "blockchainIntegrationLayerId":"",
            //                 "blockchain":"ethereum",
            //                 "type":"erc20Token",
            //                 "isTradable":true,
            //                 "isTrusted":true,
            //                 "kycNeeded":false,
            //                 "blockchainWithdrawal":true,
            //                 "cashoutMinimalAmount":0.1,
            //                 "lowVolumeAmount":null,
            //                 "lykkeEntityId":"LYKKE NL",
            //                 "siriusAssetId":0,
            //                 "siriusBlockchainId":null,
            //                 "blockchainIntegrationType":"none",
            //                 "blockchainDepositEnabled":false,
            //                 "isDisabled":false
            //             }
            //         ),
            //         "error":null
            //     }
            //
            $result = array();
            for ($i = 0; $i < count($currencies); $i++) {
                $currency = $currencies[$i];
                $id = $this->safe_string($currency, 'assetId');
                $code = $this->safe_string($currency, 'symbol');
                $name = $this->safe_string($currency, 'name');
                $rawType = $this->safe_string($currency, 'type');
                $type = ($rawType === 'erc20Token') ? 'crypto' : 'other';
                $deposit = $this->safe_value($currency, 'blockchainDepositEnabled');
                $withdraw = $this->safe_value($currency, 'blockchainWithdrawal');
                $isDisabled = $this->safe_value($currency, 'isDisabled');
                $active = !$isDisabled;
                $result[$code] = array(
                    'id' => $id,
                    'code' => $code,
                    'info' => $currency,
                    'type' => $type,
                    'name' => $name,
                    'active' => $active,
                    'deposit' => $deposit,
                    'withdraw' => $withdraw,
                    'fee' => null,
                    'precision' => $this->parse_number($this->parse_precision($this->safe_string($currency, 'accuracy'))),
                    'limits' => array(
                        'withdraw' => array(
                            'min' => $this->safe_value($currency, 'cashoutMinimalAmount'),
                            'max' => null,
                        ),
                        'amount' => array(
                            'min' => $this->safe_value($currency, 'lowVolumeAmount'),
                            'max' => null,
                        ),
                    ),
                    'networks' => array(),
                );
            }
            return $result;
        }) ();
    }

    public function fetch_markets($params = array ()): PromiseInterface {
        return Async\async(function () use ($params) {
            /**
             * retrieves data on all $markets for lykke
             * @see https://lykkecity.github.io/Trading-API/#get-asset-by-$id
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array[]} an array of objects representing $market data
             */
            $response = Async\await($this->publicGetAssetpairs ($params));
            $markets = $this->safe_value($response, 'payload', array());
            //
            //     {
            //         "payload":array(
            //             {
            //                 "assetPairId":"AAVEBTC",
            //                 "baseAssetId":"c9e55548-dae5-44fc-bebd-e72249cb19f3",
            //                 "quoteAssetId":"BTC",
            //                 "name":"AAVE/BTC",
            //                 "priceAccuracy":6,
            //                 "baseAssetAccuracy":6,
            //                 "quoteAssetAccuracy":8,
            //                 "minVolume":0.001,
            //                 "minOppositeVolume":0.0001
            //             }
            //         ),
            //         "error":null
            //     }
            //
            $result = array();
            for ($i = 0; $i < count($markets); $i++) {
                $market = $markets[$i];
                $id = $this->safe_string($market, 'assetPairId');
                $name = $this->safe_string($market, 'name');
                $baseAssetId = $this->safe_string($market, 'baseAssetId');
                $quoteAssetId = $this->safe_string($market, 'quoteAssetId');
                list($baseId, $quoteId) = explode('/', $name);
                $base = $this->safe_currency_code($baseId);
                $quote = $this->safe_currency_code($quoteId);
                $symbol = $base . '/' . $quote;
                $result[] = array(
                    'id' => $id,
                    'symbol' => $symbol,
                    'base' => $base,
                    'quote' => $quote,
                    'baseId' => $baseAssetId,
                    'quoteId' => $quoteAssetId,
                    'settle' => null,
                    'settleId' => null,
                    'type' => 'spot',
                    'spot' => true,
                    'margin' => false,
                    'swap' => false,
                    'future' => false,
                    'option' => false,
                    'contract' => false,
                    'active' => true,
                    'linear' => null,
                    'inverse' => null,
                    'contractSize' => null,
                    'expiry' => null,
                    'expiryDatetime' => null,
                    'strike' => null,
                    'optionType' => null,
                    'precision' => array(
                        'amount' => $this->parse_number($this->parse_precision($this->safe_string($market, 'baseAssetAccuracy'))),
                        'price' => $this->parse_number($this->parse_precision($this->safe_string($market, 'priceAccuracy'))),
                    ),
                    'limits' => array(
                        'amount' => array(
                            'min' => $this->safe_number($market, 'minVolume'),
                            'max' => null,
                        ),
                        'price' => array(
                            'min' => null,
                            'max' => null,
                        ),
                        'cost' => array(
                            'min' => $this->safe_number($market, 'minOppositeVolume'),
                            'max' => null,
                        ),
                        'leverage' => array(
                            'min' => null,
                            'max' => null,
                        ),
                    ),
                    'created' => null,
                    'info' => $market,
                );
            }
            return $result;
        }) ();
    }

    public function parse_ticker(array $ticker, ?array $market = null): array {
        //
        // fetchTickers
        //
        //     publicGetTickers
        //
        //     {
        //         "assetPairId":"BTCUSD",
        //         "volumeBase":2.56905016,
        //         "volumeQuote":95653.8730,
        //         "priceChange":-0.0367945778541765034194707584,
        //         "lastPrice":36840.0,
        //         "high":38371.645,
        //         "low":35903.356,
        //         "timestamp":1643295740729
        //     }
        //
        // fetchTicker
        //
        //     publicGetTickers
        //
        //     {
        //         "assetPairId":"BTCUSD",
        //         "volumeBase":2.56905016,
        //         "volumeQuote":95653.8730,
        //         "priceChange":-0.0367945778541765034194707584,
        //         "lastPrice":36840.0,
        //         "high":38371.645,
        //         "low":35903.356,
        //         "timestamp":1643295740729
        //     }
        //
        //     publicGetPrices
        //
        //     {
        //         "assetPairId":"BTCUSD",
        //         "bid":36181.521,
        //         "ask":36244.492,
        //         "timestamp":1643305510990
        //     }
        //
        $timestamp = null; // temporary bug in lykke api, returns unrealistic numbers
        $marketId = $this->safe_string($ticker, 'assetPairId');
        $market = $this->safe_market($marketId, $market);
        $close = $this->safe_string($ticker, 'lastPrice');
        return $this->safe_ticker(array(
            'symbol' => $this->safe_string($market, 'symbol'),
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'high' => $this->safe_string($ticker, 'high'),
            'low' => $this->safe_string($ticker, 'low'),
            'bid' => $this->safe_string($ticker, 'bid'),
            'bidVolume' => null,
            'ask' => $this->safe_string($ticker, 'ask'),
            'askVolume' => null,
            'vwap' => null,
            'open' => null,
            'close' => $close,
            'last' => $close,
            'previousClose' => null,
            'change' => $this->safe_string($ticker, 'priceChange'),
            'percentage' => null,
            'average' => null,
            'baseVolume' => $this->safe_string($ticker, 'volumeBase'),
            'quoteVolume' => $this->safe_string($ticker, 'volumeQuote'),
            'info' => $ticker,
        ), $market);
    }

    public function fetch_ticker(string $symbol, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $params) {
            /**
             * fetches a price $ticker, a statistical calculation with the information calculated over the past 24 hours for a specific $market
             * @see https://lykkecity.github.io/Trading-API/#get-current-prices
             * @see https://lykkecity.github.io/Trading-API/#24hr-$ticker-price-change-statistics
             * @param {string} $symbol unified $symbol of the $market to fetch the $ticker for
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} a ~@link https://docs.ccxt.com/#/?id=$ticker-structure $ticker structure~
             */
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $request = array(
                'assetPairIds' => $market['id'],
            );
            // publicGetTickers or publicGetPrices
            $method = $this->safe_string($this->options, 'fetchTickerMethod', 'publicGetTickers');
            $response = null;
            if ($method === 'publicGetPrices') {
                $response = Async\await($this->publicGetPrices ($this->extend($request, $params)));
            } else {
                $response = Async\await($this->publicGetTickers ($this->extend($request, $params)));
            }
            $ticker = $this->safe_value($response, 'payload', array());
            //
            // publicGetTickers
            //
            //     {
            //         "payload":array(
            //             {
            //                 "assetPairId":"BTCUSD",
            //                 "volumeBase":0.78056880,
            //                 "volumeQuote":29782.5169,
            //                 "priceChange":0.0436602362590968619931324699,
            //                 "lastPrice":38626.885,
            //                 "high":38742.896,
            //                 "low":36872.498,
            //                 "timestamp":1643687822840
            //             }
            //         ),
            //         "error":null
            //     }
            //
            // publicGetPrices
            //
            //     {
            //         "payload":array(
            //             {
            //                 "assetPairId":"BTCUSD",
            //                 "bid":38597.936,
            //                 "ask":38640.311,
            //                 "timestamp":1643688350847
            //             }
            //         ),
            //         "error":null
            //     }
            //
            return $this->parse_ticker($this->safe_value($ticker, 0, array()), $market);
        }) ();
    }

    public function fetch_tickers(?array $symbols = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbols, $params) {
            /**
             * fetches price $tickers for multiple markets, statistical information calculated over the past 24 hours for each market
             * @see https://lykkecity.github.io/Trading-API/#24hr-ticker-price-change-statistics
             * @param {string[]|null} $symbols unified $symbols of the markets to fetch the ticker for, all market $tickers are returned if not assigned
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} a dictionary of ~@link https://docs.ccxt.com/#/?id=ticker-structure ticker structures~
             */
            Async\await($this->load_markets());
            $response = Async\await($this->publicGetTickers ($params));
            $tickers = $this->safe_value($response, 'payload', array());
            //
            //     {
            //         "payload":array(
            //             {
            //                 "assetPairId":"BTCUSD",
            //                 "volumeBase":0.78056880,
            //                 "volumeQuote":29782.5169,
            //                 "priceChange":0.0436602362590968619931324699,
            //                 "lastPrice":38626.885,
            //                 "high":38742.896,
            //                 "low":36872.498,
            //                 "timestamp":1643687822840
            //             }
            //         ),
            //         "error":null
            //     }
            //
            return $this->parse_tickers($tickers, $symbols);
        }) ();
    }

    public function fetch_order_book(string $symbol, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $limit, $params) {
            /**
             * fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
             * @see https://lykkecity.github.io/Trading-API/#asset-pair-order-book-ticker
             * @param {string} $symbol unified $symbol of the $market to fetch the order book for
             * @param {int} [$limit] the maximum amount of order book entries to return
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} A dictionary of ~@link https://docs.ccxt.com/#/?id=order-book-structure order book structures~ indexed by $market symbols
             */
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $request = array(
                'assetPairId' => $market['id'],
            );
            if ($limit !== null) {
                $request['depth'] = $limit; // default 0
            }
            $response = Async\await($this->publicGetOrderbooks ($this->extend($request, $params)));
            $payload = $this->safe_value($response, 'payload', array());
            //
            //     {
            //         "payload":array(
            //             {
            //                 "assetPairId" => "BTCUSD",
            //                 "timestamp" => "1643298038203",
            //                 "bids" => array(
            //                     {
            //                         "v":0.59034382,
            //                         "p":36665.329
            //                     }
            //                 ),
            //                 "asks" => array(
            //                     {
            //                         "v":-0.003,
            //                         "p":36729.686
            //                     }
            //                 )
            //             }
            //         ),
            //         "error":null
            //     }
            //
            $orderbook = $this->safe_value($payload, 0, array());
            $timestamp = $this->safe_integer($orderbook, 'timestamp');
            return $this->parse_order_book($orderbook, $market['symbol'], $timestamp, 'bids', 'asks', 'p', 'v');
        }) ();
    }

    public function parse_trade(array $trade, ?array $market = null): array {
        //
        //  public fetchTrades
        //
        //     {
        //         "id":"71df1f0c-be4e-4d45-b809-c108fad5f2a8",
        //         "assetPairId":"BTCUSD",
        //         "timestamp":1643345958414,
        //         "volume":0.00010996,
        //         "price":37205.723,
        //         "side":"buy"
        //      }
        //
        //  private fetchMyTrades
        //         {
        //             "id":"813a3ffa-1c4b-45cb-b13f-1c077ea2748b",
        //             "timestamp":1644155923357,
        //             "assetPairId":"BCHEUR",
        //             "orderId":"1b367978-7e4f-454b-b870-64040d484443",
        //             "role":"Taker",
        //             "side":"sell",
        //             "price":280.569,
        //             "baseVolume":0.01,
        //             "quoteVolume":2.8056,
        //             "baseAssetId":"2a34d6a6-5839-40e5-836f-c1178fa09b89",
        //             "quoteAssetId":"EUR",
        //             "fee":null
        //         }
        //
        $marketId = $this->safe_string($trade, 'assetPairId');
        $market = $this->safe_market($marketId, $market);
        $symbol = $market['symbol'];
        $id = $this->safe_string_2($trade, 'id', 'id');
        $orderId = $this->safe_string($trade, 'orderId');
        $timestamp = $this->safe_integer($trade, 'timestamp');
        $price = $this->safe_string_2($trade, 'price', 'price');
        $amount = $this->safe_string_2($trade, 'volume', 'amount');
        if ($amount === null) {
            $amount = $this->safe_string_2($trade, 'baseVolume', 'amount');
        }
        $side = $this->safe_string_lower($trade, 'side');
        return $this->safe_trade(array(
            'id' => $id,
            'info' => $trade,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'symbol' => $symbol,
            'type' => null,
            'order' => $orderId,
            'side' => $side,
            'takerOrMaker' => null,
            'price' => $price,
            'amount' => $amount,
            'cost' => null,
            'fee' => null,
        ), $market);
    }

    public function fetch_trades(string $symbol, ?int $since = null, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            /**
             * get the list of most recent trades for a particular $symbol
             * @see https://lykkecity.github.io/Trading-API/#get-public-trades
             * @param {string} $symbol unified $symbol of the $market to fetch trades for
             * @param {int} [$since] timestamp in ms of the earliest trade to fetch
             * @param {int} [$limit] the maximum amount of trades to fetch
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {Trade[]} a list of ~@link https://docs.ccxt.com/#/?id=public-trades trade structures~
             */
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $request = array(
                'assetPairId' => $market['id'],
                // 'offset' => 0,
            );
            if ($limit !== null) {
                $request['take'] = $limit;
            }
            $response = Async\await($this->publicGetTradesPublicAssetPairId ($this->extend($request, $params)));
            $result = $this->safe_value($response, 'payload', array());
            //
            //     {
            //         "payload":array(
            //             {
            //                 "id":"71df1f0c-be4e-4d45-b809-c108fad5f2a8",
            //                 "assetPairId":"BTCUSD",
            //                 "timestamp":1643345958414,
            //                 "volume":0.00010996,
            //                 "price":37205.723,
            //                 "side":"buy"
            //             }
            //         ),
            //         "error":null
            //     }
            //
            return $this->parse_trades($result, $market, $since, $limit);
        }) ();
    }

    public function parse_balance($response): array {
        //
        //     array(
        //         {
        //             "assetId":"2a34d6a6-5839-40e5-836f-c1178fa09b89",
        //             "available":0.1,
        //             "reserved":0.0,
        //             "timestamp":1644146723620
        //         }
        //     )
        //
        $result = array( 'info' => $response );
        for ($i = 0; $i < count($response); $i++) {
            $balance = $response[$i];
            $currencyId = $this->safe_string($balance, 'assetId');
            $code = $this->safe_currency_code($currencyId);
            $account = $this->account();
            $total = $this->safe_string($balance, 'available');
            $used = $this->safe_string($balance, 'reserved');
            $account['total'] = $total;
            $account['used'] = $used;
            $result[$code] = $account;
        }
        return $this->safe_balance($result);
    }

    public function fetch_balance($params = array ()): PromiseInterface {
        return Async\async(function () use ($params) {
            /**
             * query for balance and get the amount of funds available for trading or funds locked in orders
             * @see https://lykkecity.github.io/Trading-API/#get-the-current-balance
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} a ~@link https://docs.ccxt.com/#/?id=balance-structure balance structure~
             */
            Async\await($this->load_markets());
            $response = Async\await($this->privateGetBalance ($params));
            $payload = $this->safe_value($response, 'payload', array());
            //
            //     {
            //         "payload":array(
            //             {
            //                 "assetId":"2a34d6a6-5839-40e5-836f-c1178fa09b89",
            //                 "available":0.1,
            //                 "reserved":0.0,
            //                 "timestamp":1644146723620
            //             }
            //         ),
            //         "error":null
            //     }
            //
            return $this->parse_balance($payload);
        }) ();
    }

    public function parse_order_status(?string $status) {
        $statuses = array(
            'Open' => 'open',
            'Pending' => 'open',
            'InOrderBook' => 'open',
            'Processing' => 'open',
            'Matched' => 'closed',
            'Cancelled' => 'canceled',
            'Rejected' => 'rejected',
            'Replaced' => 'canceled',
            'Placed' => 'open',
        );
        return $this->safe_string($statuses, $status, $status);
    }

    public function parse_order(array $order, ?array $market = null): array {
        //
        //     {
        //         "id":"1b367978-7e4f-454b-b870-64040d484443",
        //         "timestamp":1644155923357,
        //         "lastTradeTimestamp":1644155923357,
        //         "status":"Matched",
        //         "assetPairId":"BCHEUR",
        //         "type":"Market",
        //         "side":"Sell",
        //         "price":280.569,
        //         "volume":0.01,
        //         "filledVolume":0.01,
        //         "remainingVolume":0.0,
        //         "cost":2.80569
        //     }
        //
        $id = $this->safe_string($order, 'id');
        $status = $this->parse_order_status($this->safe_string($order, 'status'));
        $marketId = $this->safe_string($order, 'assetPairId');
        $symbol = $this->safe_symbol($marketId, $market);
        $type = $this->safe_string_lower($order, 'type');
        $lastTradeTimestamp = $this->safe_integer($order, 'lastTradeTimestamp');
        $timestamp = $this->safe_integer($order, 'timestamp');
        $price = $this->safe_string($order, 'price');
        $side = $this->safe_string_lower($order, 'side');
        $amount = $this->safe_string($order, 'volume');
        $remaining = $this->safe_string($order, 'remainingVolume');
        $filled = $this->safe_string($order, 'filledVolume');
        $cost = $this->safe_string($order, 'cost');
        return $this->safe_order(array(
            'info' => $order,
            'id' => $id,
            'clientOrderId' => null,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'lastTradeTimestamp' => $lastTradeTimestamp,
            'symbol' => $symbol,
            'type' => $type,
            'timeInForce' => null,
            'postOnly' => null,
            'side' => $side,
            'price' => $price,
            'stopPrice' => null,
            'triggerPrice' => null,
            'amount' => $amount,
            'cost' => $cost,
            'average' => null,
            'filled' => $filled,
            'remaining' => $remaining,
            'status' => $status,
            'fee' => null,
            'trades' => null,
        ), $market);
    }

    public function create_order(string $symbol, string $type, string $side, float $amount, ?float $price = null, $params = array ()) {
        return Async\async(function () use ($symbol, $type, $side, $amount, $price, $params) {
            /**
             * create a trade order
             * @see https://lykkecity.github.io/Trading-API/#place-a-limit-order
             * @see https://lykkecity.github.io/Trading-API/#place-a-$market-order
             * @param {string} $symbol unified $symbol of the $market to create an order in
             * @param {string} $type 'market' or 'limit'
             * @param {string} $side 'buy' or 'sell'
             * @param {float} $amount how much of currency you want to trade in units of base currency
             * @param {float} [$price] the $price at which the order is to be fulfilled, in units of the quote currency, ignored in $market orders
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} an ~@link https://docs.ccxt.com/#/?$id=order-structure order structure~
             */
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $query = array(
                'assetPairId' => $market['id'],
                'side' => $this->capitalize($side),
                'volume' => floatval($this->amount_to_precision($market['symbol'], $amount)),
            );
            if ($type === 'limit') {
                $query['price'] = floatval($this->price_to_precision($market['symbol'], $price));
            }
            $result = null;
            if ($this->capitalize($type) === 'Market') {
                $result = Async\await($this->privatePostOrdersMarket ($this->extend($query, $params)));
            } else {
                $result = Async\await($this->privatePostOrdersLimit ($this->extend($query, $params)));
            }
            //
            // $market
            //
            //         {
            //             "payload":array(
            //                 "orderId":"2b98ec26-8410-49b6-9f37-1fb2150e2299",
            //                 "price":280.699
            //             ),
            //             "error":null
            //         }
            //
            // limit
            //
            //         {
            //             "payload":array(
            //                 "orderId":"27be8802-30be-40ca-bf40-ec886b309c5b"
            //             ),
            //             "error":null
            //         }
            //
            $payload = $this->safe_value($result, 'payload');
            $id = $this->safe_string($payload, 'orderId');
            if ($type === 'market') {
                $price = $this->safe_number($payload, 'price');
            }
            return $this->safe_order(array(
                'id' => $id,
                'info' => $result,
                'clientOrderId' => null,
                'timestamp' => null,
                'datetime' => null,
                'lastTradeTimestamp' => null,
                'symbol' => $market['symbol'],
                'type' => $type,
                'side' => $side,
                'price' => $price,
                'amount' => $amount,
                'cost' => null,
                'average' => null,
                'filled' => null,
                'remaining' => null,
                'status' => null,
                'fee' => null,
                'trades' => null,
            ), $market);
        }) ();
    }

    public function cancel_order(string $id, ?string $symbol = null, $params = array ()) {
        return Async\async(function () use ($id, $symbol, $params) {
            /**
             * cancels an open order
             * @see https://lykkecity.github.io/Trading-API/#cancel-orders-by-$id
             * @param {string} $id order $id
             * @param {string} $symbol unified $symbol of the market the order was made in
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} An ~@link https://docs.ccxt.com/#/?$id=order-structure order structure~
             */
            $request = array(
                'orderId' => $id,
            );
            //
            //     {
            //         "payload":null,
            //         "error":null
            //     }
            //
            $response = Async\await($this->privateDeleteOrdersOrderId ($this->extend($request, $params)));
            return $this->safe_order(array(
                'info' => $response,
            ));
        }) ();
    }

    public function cancel_all_orders(?string $symbol = null, $params = array ()) {
        return Async\async(function () use ($symbol, $params) {
            /**
             * cancel all open orders
             * @see https://lykkecity.github.io/Trading-API/#mass-cancel-orders
             * @param {string} $symbol unified $market $symbol, only orders in the $market of this $symbol are cancelled when $symbol is not null
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array[]} a list of ~@link https://docs.ccxt.com/#/?id=order-structure order structures~
             */
            Async\await($this->load_markets());
            $request = array(
                // 'side' => 'Buy',
            );
            $market = null;
            if ($symbol !== null) {
                $market = $this->market($symbol);
                $request['assetPairId'] = $market['id'];
            }
            //
            //     {
            //         "payload":null,
            //         "error":null
            //     }
            //
            $response = Async\await($this->privateDeleteOrders ($this->extend($request, $params)));
            return array(
                $this->safe_order(array(
                    'info' => $response,
                )),
            );
        }) ();
    }

    public function fetch_order(string $id, ?string $symbol = null, $params = array ()) {
        return Async\async(function () use ($id, $symbol, $params) {
            /**
             * fetches information on an order made by the user
             * @see https://lykkecity.github.io/Trading-API/#get-order-by-$id
             * @param {string} $symbol not used by lykke fetchOrder
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} An ~@link https://docs.ccxt.com/#/?$id=order-structure order structure~
             */
            Async\await($this->load_markets());
            $request = array(
                'orderId' => $id,
            );
            $response = Async\await($this->privateGetOrdersOrderId ($this->extend($request, $params)));
            $payload = $this->safe_value($response, 'payload');
            //
            //     {
            //         "payload":array(
            //             "id":"1b367978-7e4f-454b-b870-64040d484443",
            //             "timestamp":1644155923357,
            //             "lastTradeTimestamp":1644155923357,
            //             "status":"Matched",
            //             "assetPairId":"BCHEUR",
            //             "type":"Market",
            //             "side":"Sell",
            //             "price":280.569,
            //             "volume":0.01,
            //             "filledVolume":0.01,
            //             "remainingVolume":0.0,
            //             "cost":2.80569
            //         ),
            //         "error":null
            //     }
            //
            return $this->parse_order($payload);
        }) ();
    }

    public function fetch_open_orders(?string $symbol = null, ?int $since = null, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            /**
             * fetch all unfilled currently open orders
             * @see https://lykkecity.github.io/Trading-API/#get-active-or-closed-orders
             * @param {string} $symbol unified $market $symbol
             * @param {int} [$since] the earliest time in ms to fetch open orders for
             * @param {int} [$limit] the maximum number of  open orders structures to retrieve
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {Order[]} a list of ~@link https://docs.ccxt.com/#/?id=order-structure order structures~
             */
            Async\await($this->load_markets());
            $market = null;
            if ($symbol !== null) {
                $market = $this->market($symbol);
            }
            $request = array(
                // 'offset' => 0,
                // 'take' => 1,
            );
            if ($limit !== null) {
                $request['take'] = $limit;
            }
            $response = Async\await($this->privateGetOrdersActive ($this->extend($request, $params)));
            $payload = $this->safe_value($response, 'payload');
            //
            //     {
            //         "payload":array(
            //             {
            //                 "id":"b26f58f5-8542-4b4c-9815-91562b523cc3",
            //                 "timestamp":1644157177155,
            //                 "lastTradeTimestamp":null,
            //                 "status":"Placed",
            //                 "assetPairId":"BCHEUR",
            //                 "type":"Limit",
            //                 "side":"Sell",
            //                 "price":666.666,
            //                 "volume":0.01,
            //                 "filledVolume":0.00,
            //                 "remainingVolume":0.01,
            //                 "cost":0.00000
            //             }
            //         ),
            //         "error":null
            //     }
            //
            return $this->parse_orders($payload, $market, $since, $limit);
        }) ();
    }

    public function fetch_closed_orders(?string $symbol = null, ?int $since = null, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            /**
             * fetches information on multiple closed orders made by the user
             * @see https://lykkecity.github.io/Trading-API/#get-active-or-closed-orders
             * @param {string} $symbol unified $market $symbol of the $market orders were made in
             * @param {int} [$since] the earliest time in ms to fetch orders for
             * @param {int} [$limit] the maximum number of order structures to retrieve
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {Order[]} a list of ~@link https://docs.ccxt.com/#/?id=order-structure order structures~
             */
            Async\await($this->load_markets());
            $market = null;
            if ($symbol !== null) {
                $market = $this->market($symbol);
            }
            $request = array(
                // 'offset' => 0,
                // 'take' => 1,
            );
            if ($limit !== null) {
                $request['take'] = $limit;
            }
            $response = Async\await($this->privateGetOrdersClosed ($this->extend($request, $params)));
            $payload = $this->safe_value($response, 'payload');
            //
            //     {
            //         "payload":array(
            //             {
            //                 "id":"1b367978-7e4f-454b-b870-64040d484443",
            //                 "timestamp":1644155923357,
            //                 "lastTradeTimestamp":1644155923357,
            //                 "status":"Matched",
            //                 "assetPairId":"BCHEUR",
            //                 "type":"Market",
            //                 "side":"Sell",
            //                 "price":280.569,
            //                 "volume":0.01,
            //                 "filledVolume":0.01,
            //                 "remainingVolume":0.0,
            //                 "cost":2.80569
            //             }
            //         ),
            //         "error":null
            //     }
            //
            return $this->parse_orders($payload, $market, $since, $limit);
        }) ();
    }

    public function fetch_my_trades(?string $symbol = null, ?int $since = null, ?int $limit = null, $params = array ()) {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            /**
             * fetch all trades made by the user
             * @see https://lykkecity.github.io/Trading-API/#get-trade-history
             * @param {string} $symbol unified $market $symbol
             * @param {int} [$since] the earliest time in ms to fetch trades for
             * @param {int} [$limit] the maximum number of trades structures to retrieve
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {Trade[]} a list of ~@link https://docs.ccxt.com/#/?id=trade-structure trade structures~
             */
            Async\await($this->load_markets());
            $request = array(
                // 'side' => 'buy',
                // 'offset' => 0,
                // 'take' => 1,
                // 'to' => 0,
            );
            $market = null;
            if ($limit !== null) {
                $request['take'] = $limit; // How many maximum items have to be returned, max 1000 default 100.
            }
            if ($symbol !== null) {
                $market = $this->market($symbol);
                $request['assetPairId'] = $market['id'];
            }
            if ($since !== null) {
                $request['from'] = $since;
            }
            $response = Async\await($this->privateGetTrades ($this->extend($request, $params)));
            $payload = $this->safe_value($response, 'payload');
            //
            //     {
            //         "payload":array(
            //             {
            //                 "id":"813a3ffa-1c4b-45cb-b13f-1c077ea2748b",
            //                 "timestamp":1644155923357,
            //                 "assetPairId":"BCHEUR",
            //                 "orderId":"1b367978-7e4f-454b-b870-64040d484443",
            //                 "role":"Taker",
            //                 "side":"sell",
            //                 "price":280.569,
            //                 "baseVolume":0.01,
            //                 "quoteVolume":2.8056,
            //                 "baseAssetId":"2a34d6a6-5839-40e5-836f-c1178fa09b89",
            //                 "quoteAssetId":"EUR",
            //                 "fee":null
            //             }
            //         ),
            //         "error":null
            //     }
            //
            return $this->parse_trades($payload, $market, $since, $limit);
        }) ();
    }

    public function parse_bid_ask($bidask, int|string $priceKey = 0, int|string $amountKey = 1, int|string $countOrIdKey = 2) {
        $price = $this->safe_string($bidask, $priceKey);
        $amount = Precise::string_abs($this->safe_string($bidask, $amountKey));
        return array( $this->parse_number($price), $this->parse_number($amount) );
    }

    public function fetch_deposit_address(string $code, $params = array ()): PromiseInterface {
        return Async\async(function () use ($code, $params) {
            /**
             * fetch the deposit $address for a $currency associated with this account
             * @see https://lykkecity.github.io/Trading-API/#get-deposit-$address-for-a-given-asset
             * @param {string} $code unified $currency $code
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} an ~@link https://docs.ccxt.com/#/?id=$address-structure $address structure~
             */
            Async\await($this->load_markets());
            $currency = $this->currency($code);
            $request = array(
                'assetId' => $this->safe_string($currency, 'id'),
            );
            $response = Async\await($this->privateGetOperationsDepositsAddressesAssetId ($this->extend($request, $params)));
            //
            //     {
            //         "assetId":"2a34d6a6-5839-40e5-836f-c1178fa09b89",
            //         "symbol":"BCH",
            //         "address":null,
            //         "baseAddress":null,
            //         "addressExtension":null,
            //         "state":"Active"
            //     }
            //
            $address = $this->safe_string($response, 'baseAddress');
            $tag = $this->safe_string($response, 'addressExtension');
            $this->check_address($address);
            return array(
                'info' => $response,
                'currency' => $code,
                'network' => null,
                'address' => $address,
                'tag' => $tag,
            );
        }) ();
    }

    public function parse_transaction(array $transaction, ?array $currency = null): array {
        //
        // withdraw
        //     "3035b1ad-2005-4587-a986-1f7966be78e0"
        //
        // fetchDepositsWithdrawals
        //     {
        //         "operationId":"787201c8-f1cc-45c0-aec1-fa06eeea426b",
        //         "assetId":"2a34d6a6-5839-40e5-836f-c1178fa09b89",
        //         "totalVolume":0.1,
        //         "fee":0.0,
        //         "type":"deposit",
        //         "timestamp":1644146723620
        //     }
        //
        $id = null;
        $assetId = null;
        $code = null;
        $amount = null;
        $fee = null;
        $type = null;
        $timestamp = null;
        if (gettype($transaction) === 'string') {
            $id = $transaction;
        } else {
            $id = $this->safe_string($transaction, 'operationId');
            $assetId = $this->safe_string($transaction, 'assetId');
            $code = $this->safe_currency_code($assetId, $currency);
            $amount = $this->safe_number($transaction, 'totalVolume');
            $type = $this->safe_string($transaction, 'type');
            $timestamp = $this->safe_integer($transaction, 'timestamp');
            $feeCost = $this->safe_number($transaction, 'fee');
            $fee = array(
                'currency' => $code,
                'cost' => $feeCost,
            );
        }
        return array(
            'info' => $transaction,
            'id' => $id,
            'txid' => null,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'network' => null,
            'addressFrom' => null,
            'address' => null,
            'addressTo' => null,
            'tagFrom' => null,
            'tag' => null,
            'tagTo' => null,
            'type' => $type,
            'amount' => $amount,
            'currency' => $code,
            'status' => null,
            'updated' => null,
            'internal' => null,
            'comment' => null,
            'fee' => $fee,
        );
    }

    public function fetch_deposits_withdrawals(?string $code = null, ?int $since = null, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($code, $since, $limit, $params) {
            /**
             * fetch history of deposits and withdrawals
             * @see https://lykkecity.github.io/Trading-API/#get-the-history-of-withdrawals-and-deposits
             * @param {string} [$code] unified $currency $code for the $currency of the deposit/withdrawals, default is null
             * @param {int} [$since] timestamp in ms of the earliest deposit/withdrawal, default is null
             * @param {int} [$limit] max number of deposit/withdrawals to return, default is null
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} a list of ~@link https://docs.ccxt.com/#/?id=transaction-structure transaction structure~
             */
            Async\await($this->load_markets());
            $request = array(
                // 'offset' => 0,
                // 'take' => 1,
            );
            if ($limit !== null) {
                $request['take'] = $limit;
            }
            $response = Async\await($this->privateGetOperations ($this->extend($request, $params)));
            $payload = $this->safe_value($response, 'payload', array());
            //
            //     {
            //         "payload":array(
            //             {
            //                 "operationId":"787201c8-f1cc-45c0-aec1-fa06eeea426b",
            //                 "assetId":"2a34d6a6-5839-40e5-836f-c1178fa09b89",
            //                 "totalVolume":0.1,
            //                 "fee":0.0,
            //                 "type":"deposit",
            //                 "timestamp":1644146723620
            //             }
            //         ),
            //         "error":null
            //     }
            //
            $currency = null;
            if ($code !== null) {
                $currency = $this->currency($code);
            }
            return $this->parse_transactions($payload, $currency, $since, $limit);
        }) ();
    }

    public function withdraw(string $code, float $amount, string $address, $tag = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($code, $amount, $address, $tag, $params) {
            /**
             * make a withdrawal
             * @see https://lykkecity.github.io/Trading-API/#withdrawal
             * @param {string} $code unified $currency $code
             * @param {float} $amount the $amount to withdraw
             * @param {string} $address the $address to withdraw to
             * @param {string} $tag
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} a ~@link https://docs.ccxt.com/#/?id=transaction-structure transaction structure~
             */
            Async\await($this->load_markets());
            $this->check_address($address);
            $currency = $this->currency($code);
            $request = array(
                'assetId' => $currency['id'],
                'volume' => floatval($this->currency_to_precision($code, $amount)),
                'destinationAddress' => $address,
                // 'destinationAddressExtension' => $tag,
            );
            if ($tag !== null) {
                $request['destinationAddressExtension'] = $tag;
            }
            $response = Async\await($this->privatePostOperationsWithdrawals ($this->extend($request, $params)));
            //
            //     "3035b1ad-2005-4587-a986-1f7966be78e0"
            //
            return $this->parse_transaction($response, $currency);
        }) ();
    }

    public function sign($path, $api = 'public', $method = 'GET', $params = array (), $headers = null, $body = null) {
        $url = $this->urls['api'][$api] . '/' . $this->implode_params($path, $params);
        $query = $this->omit($params, $this->extract_params($path));
        $headers = array(
            'Accept' => 'application/json',
            'Content-Type' => 'application/json',
        );
        if ($api === 'public') {
            if ($query) {
                $url .= '?' . $this->urlencode($query);
            }
        } elseif ($api === 'private') {
            if (($method === 'GET') || ($method === 'DELETE')) {
                if ($query) {
                    $url .= '?' . $this->urlencode($query);
                }
            }
            $this->check_required_credentials();
            $headers['Authorization'] = 'Bearer ' . $this->apiKey;
            if ($method === 'POST') {
                if ($params) {
                    $body = $this->json($params);
                }
            }
            if ($path === 'operations/withdrawals') {
                $headers['X-Request-ID'] = $this->uuid();
            }
        }
        return array( 'url' => $url, 'method' => $method, 'body' => $body, 'headers' => $headers );
    }

    public function handle_errors(int $code, string $reason, string $url, string $method, array $headers, string $body, $response, $requestHeaders, $requestBody) {
        if ($response === null) {
            return null;
        }
        $error = $this->safe_value($response, 'error', array());
        $errorCode = $this->safe_string($error, 'code');
        if (($errorCode !== null) && ($errorCode !== '0')) {
            $feedback = $this->id . ' ' . $body;
            $message = $this->safe_string($error, 'message');
            $this->throw_exactly_matched_exception($this->exceptions['exact'], $errorCode, $feedback);
            $this->throw_broadly_matched_exception($this->exceptions['broad'], $message, $feedback);
            throw new ExchangeError($feedback);
        }
        return null;
    }
}
