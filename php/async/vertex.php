<?php

namespace ccxt\async;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

use Exception; // a common import
use ccxt\async\abstract\vertex as Exchange;
use ccxt\ExchangeError;
use ccxt\ArgumentsRequired;
use ccxt\BadRequest;
use ccxt\NotSupported;
use ccxt\Precise;
use React\Async;
use React\Promise\PromiseInterface;

class vertex extends Exchange {

    public function describe() {
        return $this->deep_extend(parent::describe(), array(
            'id' => 'vertex',
            'name' => 'Vertex',
            'countries' => [ ],
            'version' => 'v1',
            'rateLimit' => 50,
            'certified' => false,
            'pro' => true,
            'dex' => true,
            'has' => array(
                'CORS' => null,
                'spot' => true,
                'margin' => false,
                'swap' => true,
                'future' => true,
                'option' => false,
                'addMargin' => false,
                'borrowCrossMargin' => false,
                'borrowIsolatedMargin' => false,
                'cancelAllOrders' => true,
                'cancelAllOrdersAfter' => false,
                'cancelOrder' => true,
                'cancelOrders' => true,
                'cancelOrdersForSymbols' => false,
                'closeAllPositions' => false,
                'closePosition' => false,
                'createMarketBuyOrderWithCost' => false,
                'createMarketOrderWithCost' => false,
                'createMarketSellOrderWithCost' => false,
                'createOrder' => true,
                'createOrders' => true,
                'createReduceOnlyOrder' => true,
                'createStopOrder' => true,
                'createTriggerOrder' => true,
                'editOrder' => false,
                'fetchAccounts' => false,
                'fetchBalance' => true,
                'fetchBorrowInterest' => false,
                'fetchBorrowRateHistories' => false,
                'fetchBorrowRateHistory' => false,
                'fetchCanceledOrders' => false,
                'fetchClosedOrders' => false,
                'fetchCrossBorrowRate' => false,
                'fetchCrossBorrowRates' => false,
                'fetchCurrencies' => true,
                'fetchDepositAddress' => false,
                'fetchDepositAddresses' => false,
                'fetchDeposits' => false,
                'fetchDepositWithdrawFee' => false,
                'fetchDepositWithdrawFees' => false,
                'fetchFundingHistory' => false,
                'fetchFundingRate' => true,
                'fetchFundingRateHistory' => false,
                'fetchFundingRates' => true,
                'fetchIndexOHLCV' => false,
                'fetchIsolatedBorrowRate' => false,
                'fetchIsolatedBorrowRates' => false,
                'fetchLedger' => false,
                'fetchLeverage' => false,
                'fetchLeverageTiers' => false,
                'fetchLiquidations' => false,
                'fetchMarginMode' => null,
                'fetchMarketLeverageTiers' => false,
                'fetchMarkets' => true,
                'fetchMarkOHLCV' => false,
                'fetchMyLiquidations' => false,
                'fetchMyTrades' => true,
                'fetchOHLCV' => true,
                'fetchOpenInterest' => true,
                'fetchOpenInterestHistory' => false,
                'fetchOpenInterests' => true,
                'fetchOpenOrders' => true,
                'fetchOrder' => true,
                'fetchOrderBook' => true,
                'fetchOrders' => true,
                'fetchOrderTrades' => false,
                'fetchPosition' => false,
                'fetchPositionMode' => false,
                'fetchPositions' => true,
                'fetchPositionsRisk' => false,
                'fetchPremiumIndexOHLCV' => false,
                'fetchStatus' => true,
                'fetchTicker' => false,
                'fetchTickers' => true,
                'fetchTime' => true,
                'fetchTrades' => true,
                'fetchTradingFee' => false,
                'fetchTradingFees' => true,
                'fetchTransfer' => false,
                'fetchTransfers' => false,
                'fetchWithdrawal' => false,
                'fetchWithdrawals' => false,
                'reduceMargin' => false,
                'repayCrossMargin' => false,
                'repayIsolatedMargin' => false,
                'sandbox' => true,
                'setLeverage' => false,
                'setMarginMode' => false,
                'setPositionMode' => false,
                'transfer' => false,
                'withdraw' => true,
            ),
            'timeframes' => array(
                '1m' => 60,
                '5m' => 300,
                '15m' => 900,
                '1h' => 3600,
                '2h' => 7200,
                '4h' => 14400,
                '1d' => 86400,
                '1w' => 604800,
                '1M' => 604800,
            ),
            'hostname' => 'vertexprotocol.com',
            'urls' => array(
                'logo' => 'https://github.com/ccxt/ccxt/assets/43336371/bd04a0fa-3b48-47b6-9d8b-124954d520a8',
                'api' => array(
                    'v1' => array(
                        'archive' => 'https://archive.prod.{hostname}/v1',
                        'gateway' => 'https://gateway.prod.{hostname}/v1',
                        'trigger' => 'https://trigger.prod.{hostname}/v1',
                    ),
                    'v2' => array(
                        'archive' => 'https://archive.prod.{hostname}/v2',
                        'gateway' => 'https://gateway.prod.{hostname}/v2',
                    ),
                ),
                'test' => array(
                    'v1' => array(
                        'archive' => 'https://archive.sepolia-test.{hostname}/v1',
                        'gateway' => 'https://gateway.sepolia-test.{hostname}/v1',
                        'trigger' => 'https://trigger.sepolia-test.{hostname}/v1',
                    ),
                    'v2' => array(
                        'archive' => 'https://archive.sepolia-test.{hostname}/v2',
                        'gateway' => 'https://gateway.sepolia-test.{hostname}/v2',
                    ),
                ),
                'www' => 'https://vertexprotocol.com/',
                'doc' => 'https://docs.vertexprotocol.com/',
                'fees' => 'https://docs.vertexprotocol.com/basics/fees',
                'referral' => 'https://app.vertexprotocol.com?referrer=0xCfC9BaB96a2eA3d3c3F031c005e82E1D9F295aC1',
            ),
            'api' => array(
                'v1' => array(
                    'archive' => array(
                        'post' => array(
                            '' => 1,
                        ),
                    ),
                    'gateway' => array(
                        'get' => array(
                            'query' => 1,
                            'symbols' => 1,
                            'time' => 1,
                        ),
                        'post' => array(
                            'query' => 1,
                            'execute' => 1,
                        ),
                    ),
                    'trigger' => array(
                        'post' => array(
                            'execute' => 1,
                            'query' => 1,
                        ),
                    ),
                ),
                'v2' => array(
                    'archive' => array(
                        'get' => array(
                            'tickers' => 1,
                            'contracts' => 1,
                            'trades' => 1,
                            'vrtx' => 1,
                        ),
                    ),
                    'gateway' => array(
                        'get' => array(
                            'assets' => 0.6667,
                            'pairs' => 1,
                            'orderbook' => 1,
                        ),
                    ),
                ),
            ),
            'fees' => array(
                'swap' => array(
                    'taker' => $this->parse_number('0.0002'),
                    'maker' => $this->parse_number('0.0002'),
                ),
                'spot' => array(
                    'taker' => $this->parse_number('0.0002'),
                    'maker' => $this->parse_number('0.0002'),
                ),
            ),
            'requiredCredentials' => array(
                'apiKey' => false,
                'secret' => false,
                'walletAddress' => true,
                'privateKey' => true,
            ),
            'exceptions' => array(
                'exact' => array(
                    '1000' => '\\ccxt\\RateLimitExceeded',
                    '1015' => '\\ccxt\\RateLimitExceeded',
                    '1001' => '\\ccxt\\PermissionDenied',
                    '1002' => '\\ccxt\\PermissionDenied',
                    '1003' => '\\ccxt\\PermissionDenied',
                    '2000' => '\\ccxt\\InvalidOrder',
                    '2001' => '\\ccxt\\InvalidOrder',
                    '2002' => '\\ccxt\\InvalidOrder',
                    '2003' => '\\ccxt\\InvalidOrder',
                    '2004' => '\\ccxt\\InvalidOrder',
                    '2005' => '\\ccxt\\InvalidOrder',
                    '2006' => '\\ccxt\\InvalidOrder',
                    '2007' => '\\ccxt\\InvalidOrder',
                    '2008' => '\\ccxt\\InvalidOrder',
                    '2009' => '\\ccxt\\InvalidOrder',
                    '2010' => '\\ccxt\\InvalidOrder',
                    '2011' => '\\ccxt\\BadRequest',
                    '2012' => '\\ccxt\\BadRequest',
                    '2013' => '\\ccxt\\InvalidOrder',
                    '2014' => '\\ccxt\\PermissionDenied',
                    '2015' => '\\ccxt\\InvalidOrder',
                    '2016' => '\\ccxt\\InvalidOrder',
                    '2017' => '\\ccxt\\InvalidOrder',
                    '2019' => '\\ccxt\\InvalidOrder',
                    '2020' => '\\ccxt\\InvalidOrder',
                    '2021' => '\\ccxt\\InvalidOrder',
                    '2022' => '\\ccxt\\InvalidOrder',
                    '2023' => '\\ccxt\\InvalidOrder',
                    '2024' => '\\ccxt\\InsufficientFunds',
                    '2025' => '\\ccxt\\InsufficientFunds',
                    '2026' => '\\ccxt\\BadRequest',
                    '2027' => '\\ccxt\\AuthenticationError',
                    '2028' => '\\ccxt\\AuthenticationError',
                    '2029' => '\\ccxt\\AuthenticationError',
                    '2030' => '\\ccxt\\BadRequest',
                    '2031' => '\\ccxt\\InvalidOrder',
                    '2033' => '\\ccxt\\InvalidOrder',
                    '2034' => '\\ccxt\\InvalidOrder',
                    '2035' => '\\ccxt\\InvalidOrder',
                    '2036' => '\\ccxt\\InvalidOrder',
                    '2037' => '\\ccxt\\InvalidOrder',
                    '2038' => '\\ccxt\\InvalidOrder',
                    '2039' => '\\ccxt\\InvalidOrder',
                    '2040' => '\\ccxt\\InvalidOrder',
                    '2041' => '\\ccxt\\InvalidOrder',
                    '2042' => '\\ccxt\\InvalidOrder',
                    '2043' => '\\ccxt\\InvalidOrder',
                    '2044' => '\\ccxt\\InvalidOrder',
                    '2045' => '\\ccxt\\InvalidOrder',
                    '2046' => '\\ccxt\\InvalidOrder',
                    '2047' => '\\ccxt\\InvalidOrder',
                    '2048' => '\\ccxt\\InvalidOrder',
                    '2049' => '\\ccxt\\ExchangeError',
                    '2050' => '\\ccxt\\PermissionDenied',
                    '2051' => '\\ccxt\\InvalidOrder',
                    '2052' => '\\ccxt\\InvalidOrder',
                    '2053' => '\\ccxt\\InvalidOrder',
                    '2054' => '\\ccxt\\InvalidOrder',
                    '2055' => '\\ccxt\\InvalidOrder',
                    '2056' => '\\ccxt\\InvalidOrder',
                    '2057' => '\\ccxt\\InvalidOrder',
                    '2058' => '\\ccxt\\InvalidOrder',
                    '2059' => '\\ccxt\\InvalidOrder',
                    '2060' => '\\ccxt\\InvalidOrder',
                    '2061' => '\\ccxt\\InvalidOrder',
                    '2062' => '\\ccxt\\InvalidOrder',
                    '2063' => '\\ccxt\\InvalidOrder',
                    '2064' => '\\ccxt\\InvalidOrder',
                    '2065' => '\\ccxt\\InvalidOrder',
                    '2066' => '\\ccxt\\InvalidOrder',
                    '2067' => '\\ccxt\\InvalidOrder',
                    '2068' => '\\ccxt\\InvalidOrder',
                    '2069' => '\\ccxt\\InvalidOrder',
                    '2070' => '\\ccxt\\InvalidOrder',
                    '2071' => '\\ccxt\\InvalidOrder',
                    '2072' => '\\ccxt\\InvalidOrder',
                    '2073' => '\\ccxt\\InvalidOrder',
                    '2074' => '\\ccxt\\InvalidOrder',
                    '2075' => '\\ccxt\\InvalidOrder',
                    '2076' => '\\ccxt\\InvalidOrder',
                    '3000' => '\\ccxt\\BadRequest',
                    '3001' => '\\ccxt\\BadRequest',
                    '3002' => '\\ccxt\\BadRequest',
                    '3003' => '\\ccxt\\BadRequest',
                    '4000' => '\\ccxt\\BadRequest',
                    '4001' => '\\ccxt\\ExchangeError',
                    '4002' => '\\ccxt\\ExchangeError',
                    '4003' => '\\ccxt\\ExchangeError',
                    '4004' => '\\ccxt\\InvalidOrder',
                    '5000' => '\\ccxt\\ExchangeError',
                ),
                'broad' => array(
                ),
            ),
            'precisionMode' => TICK_SIZE,
            'commonCurrencies' => array(
            ),
            'options' => array(
                'defaultType' => 'swap',
                'sandboxMode' => false,
                'timeDifference' => 0, // the difference between system clock and exchange server clock
                'brokerId' => 5930043274845996,
            ),
            'features' => array(
                'default' => array(
                    'sandbox' => true,
                    'createOrder' => array(
                        'marginMode' => false,
                        'triggerPrice' => true, // todo
                        'triggerDirection' => false,
                        'triggerPriceType' => null,
                        'stopLossPrice' => true, // todo
                        'takeProfitPrice' => true, // todo
                        'attachedStopLossTakeProfit' => null,
                        'timeInForce' => array(
                            'IOC' => false,
                            'FOK' => false,
                            'PO' => true,
                            'GTD' => true,
                        ),
                        'hedged' => false,
                        'trailing' => false,
                        'leverage' => false,
                        'marketBuyByCost' => true, // todo
                        'marketBuyRequiresPrice' => true, // todo fix implementation
                        'selfTradePrevention' => false,
                        'iceberg' => false,
                    ),
                    'createOrders' => null,
                    'fetchMyTrades' => array(
                        'marginMode' => false,
                        'limit' => 500,
                        'daysBack' => 100000, // todo
                        'untilDays' => null,
                        'symbolRequired' => false,
                    ),
                    'fetchOrder' => array(
                        'marginMode' => false,
                        'trigger' => false,
                        'trailing' => false,
                        'symbolRequired' => true,
                    ),
                    'fetchOpenOrders' => array(
                        'marginMode' => false,
                        'limit' => 500,
                        'trigger' => true,
                        'trailing' => false,
                        'symbolRequired' => false,
                    ),
                    'fetchOrders' => null, // todo, only for trigger
                    'fetchClosedOrders' => null, // todo through fetchOrders
                    'fetchOHLCV' => array(
                        'limit' => 1000,
                    ),
                ),
                'spot' => array(
                    'extends' => 'default',
                ),
                'swap' => array(
                    'linear' => array(
                        'extends' => 'default',
                    ),
                    'inverse' => null,
                ),
                'future' => array(
                    'linear' => null,
                    'inverse' => null,
                ),
            ),
        ));
    }

    public function set_sandbox_mode($enabled) {
        parent::set_sandbox_mode($enabled);
        $this->options['sandboxMode'] = $enabled;
    }

    public function convert_to_x18($num) {
        if (gettype($num) === 'string') {
            return Precise::string_mul($num, '1000000000000000000');
        }
        $numStr = $this->number_to_string($num);
        return Precise::string_mul($numStr, '1000000000000000000');
    }

    public function convert_from_x18($num) {
        if (gettype($num) === 'string') {
            return Precise::string_div($num, '1000000000000000000');
        }
        $numStr = $this->number_to_string($num);
        return Precise::string_div($numStr, '1000000000000000000');
    }

    public function fetch_currencies($params = array ()): PromiseInterface {
        return Async\async(function () use ($params) {
            /**
             * fetches all available currencies on an exchange
             *
             * @see https://docs.vertexprotocol.com/developer-resources/api/v2/assets
             *
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} an associative dictionary of currencies
             */
            $request = array();
            $response = Async\await($this->v2GatewayGetAssets ($this->extend($request, $params)));
            //
            // array(
            //     array(
            //         "product_id" => 2,
            //         "ticker_id" => "BTC-PERP_USDC",
            //         "market_type" => "perp",
            //         "name" => "Bitcoin Perp",
            //         "symbol" => "BTC-PERP",
            //         "maker_fee" => 0.0002,
            //         "taker_fee" => 0,
            //         "can_withdraw" => false,
            //         "can_deposit" => false
            //     ),
            //     {
            //         "product_id" => 1,
            //         "ticker_id" => "BTC_USDC",
            //         "market_type" => "spot",
            //         "name" => "Bitcoin",
            //         "symbol" => "BTC",
            //         "taker_fee" => 0.0003,
            //         "maker_fee" => 0,
            //         "can_withdraw" => true,
            //         "can_deposit" => true
            //     }
            // )
            //
            $result = array();
            for ($i = 0; $i < count($response); $i++) {
                $data = $this->safe_dict($response, $i, array());
                $tickerId = $this->safe_string($data, 'ticker_id');
                if (($tickerId !== null) && (mb_strpos($tickerId, 'PERP') > 0)) {
                    continue;
                }
                $id = $this->safe_string($data, 'product_id');
                $name = $this->safe_string($data, 'symbol');
                $code = $this->safe_currency_code($name);
                $result[$code] = array(
                    'id' => $id,
                    'name' => $name,
                    'code' => $code,
                    'precision' => null,
                    'info' => $data,
                    'active' => null,
                    'deposit' => $this->safe_bool($data, 'can_deposit'),
                    'withdraw' => $this->safe_bool($data, 'can_withdraw'),
                    'networks' => null,
                    'fee' => null,
                    'limits' => array(
                        'amount' => array(
                            'min' => null,
                            'max' => null,
                        ),
                        'withdraw' => array(
                            'min' => null,
                            'max' => null,
                        ),
                    ),
                );
            }
            return $result;
        }) ();
    }

    public function parse_market($market): array {
        //
        // {
        //     "type" => "spot",
        //     "product_id" => 3,
        //     "symbol" => "WETH",
        //     "price_increment_x18" => "100000000000000000",
        //     "size_increment" => "10000000000000000",
        //     "min_size" => "100000000000000000",
        //     "min_depth_x18" => "5000000000000000000000",
        //     "max_spread_rate_x18" => "2000000000000000",
        //     "maker_fee_rate_x18" => "0",
        //     "taker_fee_rate_x18" => "300000000000000",
        //     "long_weight_initial_x18" => "900000000000000000",
        //     "long_weight_maintenance_x18" => "950000000000000000"
        // }
        //
        $marketType = $this->safe_string($market, 'type');
        $quoteId = 'USDC';
        $quote = $this->safe_currency_code($quoteId);
        $baseId = $this->safe_string($market, 'symbol');
        $base = $this->safe_currency_code($baseId);
        $settleId = $quoteId;
        $settle = $this->safe_currency_code($settleId);
        $symbol = $base . '/' . $quote;
        $spot = $marketType === 'spot';
        $contract = !$spot;
        $swap = !$spot;
        if ($swap) {
            $splitSymbol = explode('-', $base);
            $symbol = $splitSymbol[0] . '/' . $quote . ':' . $settle;
        }
        $priceIncrementX18 = $this->safe_string($market, 'price_increment_x18');
        $sizeIncrementX18 = $this->safe_string($market, 'size_increment');
        $minSizeX18 = $this->safe_string($market, 'min_size');
        $takerX18 = $this->safe_number($market, 'taker_fee_rate_x18');
        $makerX18 = $this->safe_number($market, 'maker_fee_rate_x18');
        $isInverse = ($spot) ? null : false;
        $isLinear = ($spot) ? null : true;
        $contractSize = ($spot) ? null : $this->parse_number('1');
        return array(
            'id' => $this->safe_string($market, 'product_id'),
            'symbol' => $symbol,
            'base' => $base,
            'quote' => $quote,
            'settle' => ($spot) ? null : $settle,
            'baseId' => $baseId,
            'quoteId' => $quoteId,
            'settleId' => ($spot) ? null : $settleId,
            'type' => ($spot) ? 'spot' : 'swap',
            'spot' => $spot,
            'margin' => null,
            'swap' => $swap,
            'future' => false,
            'option' => false,
            'active' => true,
            'contract' => $contract,
            'linear' => $isLinear,
            'inverse' => $isInverse,
            'taker' => $this->parse_number($this->convert_from_x18($takerX18)),
            'maker' => $this->parse_number($this->convert_from_x18($makerX18)),
            'contractSize' => $contractSize,
            'expiry' => null,
            'expiryDatetime' => null,
            'strike' => null,
            'optionType' => null,
            'precision' => array(
                'amount' => $this->parse_number($this->convert_from_x18($sizeIncrementX18)),
                'price' => $this->parse_number($this->convert_from_x18($priceIncrementX18)),
            ),
            'limits' => array(
                'leverage' => array(
                    'min' => null,
                    'max' => null,
                ),
                'amount' => array(
                    'min' => $this->parse_number($this->convert_from_x18($minSizeX18)),
                    'max' => null,
                ),
                'price' => array(
                    'min' => null,
                    'max' => null,
                ),
                'cost' => array(
                    'min' => null,
                    'max' => null,
                ),
            ),
            'created' => null,
            'info' => $market,
        );
    }

    public function fetch_markets($params = array ()): PromiseInterface {
        return Async\async(function () use ($params) {
            /**
             * retrieves $data on all $markets for vertex
             *
             * @see https://docs.vertexprotocol.com/developer-resources/api/gateway/queries/symbols
             *
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array[]} an array of objects representing market $data
             */
            $request = array(
                'type' => 'symbols',
            );
            $response = Async\await($this->v1GatewayGetQuery ($this->extend($request, $params)));
            //
            // {
            //     "status" => "success",
            //     "data" => {
            //         "symbols" => {
            //             "WETH" => array(
            //                 "type" => "spot",
            //                 "product_id" => 3,
            //                 "symbol" => "WETH",
            //                 "price_increment_x18" => "100000000000000000",
            //                 "size_increment" => "10000000000000000",
            //                 "min_size" => "100000000000000000",
            //                 "min_depth_x18" => "5000000000000000000000",
            //                 "max_spread_rate_x18" => "2000000000000000",
            //                 "maker_fee_rate_x18" => "0",
            //                 "taker_fee_rate_x18" => "300000000000000",
            //                 "long_weight_initial_x18" => "900000000000000000",
            //                 "long_weight_maintenance_x18" => "950000000000000000"
            //             }
            //         }
            //     ),
            //     "request_type" => "query_symbols"
            // }
            //
            $data = $this->safe_dict($response, 'data', array());
            $markets = $this->safe_dict($data, 'symbols', array());
            $symbols = is_array($markets) ? array_keys($markets) : array();
            $result = array();
            for ($i = 0; $i < count($symbols); $i++) {
                $symbol = $symbols[$i];
                $rawMarket = $this->safe_dict($markets, $symbol, array());
                $result[] = $this->parse_market($rawMarket);
            }
            return $result;
        }) ();
    }

    public function fetch_time($params = array ()) {
        return Async\async(function () use ($params) {
            /**
             * fetches the current integer timestamp in milliseconds from the exchange server
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {int} the current integer timestamp in milliseconds from the exchange server
             */
            $response = Async\await($this->v1GatewayGetTime ($params));
            // 1717481623452
            return $this->parse_number($response);
        }) ();
    }

    public function fetch_status($params = array ()) {
        return Async\async(function () use ($params) {
            /**
             * the latest known information on the availability of the exchange API
             *
             * @see https://docs.vertexprotocol.com/developer-resources/api/gateway/queries/status
             *
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} a ~@link https://docs.ccxt.com/#/?id=exchange-$status-structure $status structure~
             */
            $request = array(
                'type' => 'status',
            );
            $response = Async\await($this->v1GatewayGetQuery ($this->extend($request, $params)));
            //
            // {
            //     "status" => "success",
            //     "data" => "active",
            //     "request_type" => "query_status",
            // }
            //
            $status = $this->safe_string($response, 'data');
            if ($status === 'active') {
                $status = 'ok';
            } else {
                $status = 'error';
            }
            return array(
                'status' => $status,
                'updated' => null,
                'eta' => null,
                'url' => null,
                'info' => $response,
            );
        }) ();
    }

    public function parse_trade($trade, ?array $market = null): array {
        //
        // {
        //       "ticker_id" => "ARB_USDC",
        //       "trade_id" => 999994,
        //       "price" => 1.1366122408151016,
        //       "base_filled" => 175,
        //       "quote_filled" => -198.90714214264278,
        //       "timestamp" => 1691068943,
        //       "trade_type" => "buy"
        // }
        // fetchMytrades
        // {
        //     "digest" => "0x80ce789702b670b7d33f2aa67e12c85f124395c3f9acdb422dde3b4973ccd50c",
        //     "order" => array(
        //         "sender" => "0x12a0b4888021576eb10a67616dd3dd3d9ce206b664656661756c740000000000",
        //         "priceX18" => "27544000000000000000000",
        //         "amount" => "2000000000000000000",
        //         "expiration" => "4611686020107119633",
        //         "nonce" => "1761322608857448448"
        //     ),
        //     "base_filled" => "736000000000000000",
        //     "quote_filled" => "-20276464287857571514302",
        //     "fee" => "4055287857571514302",
        //     "sequencer_fee" => "0"
        //     "cumulative_fee" => "4055287857571514302",
        //     "cumulative_base_filled" => "736000000000000000",
        //     "cumulative_quote_filled" => "-20276464287857571514302",
        //     "submission_idx" => "563012",
        //     "pre_balance" => {
        //       "base" => {
        //         "perp" => array(
        //           "product_id" => 2,
        //           "lp_balance" => array(
        //             "amount" => "0",
        //             "last_cumulative_funding_x18" => "1823351297710837"
        //           ),
        //           "balance" => array(
        //             "amount" => "2686684000000000000000",
        //             "v_quote_balance" => "-76348662407149297671587247",
        //             "last_cumulative_funding_x18" => "134999841911604906604576"
        //           }
        //         }
        //       ),
        //       "quote" => null
        //     ),
        //     "post_balance" => {
        //       "base" => {
        //         "perp" => {
        //           "product_id" => 2,
        //           "lp_balance" => array(
        //             "amount" => "0",
        //             "last_cumulative_funding_x18" => "1823351297710837"
        //           ),
        //           "balance" => array(
        //             "amount" => "2686013000000000000000",
        //             "v_quote_balance" => "-76328351274188497671587247",
        //             "last_cumulative_funding_x18" => "134999841911604906604576"
        //           }
        //         }
        //       ),
        //       "quote" => null
        //     }
        //   }
        $price = null;
        $amount = null;
        $side = null;
        $fee = null;
        $feeCost = $this->convert_from_x18($this->safe_string($trade, 'fee'));
        if ($feeCost !== null) {
            $fee = array(
                'cost' => $feeCost,
                'currency' => null,
            );
        }
        $id = $this->safe_string_2($trade, 'trade_id', 'submission_idx');
        $order = $this->safe_string($trade, 'digest');
        $timestamp = $this->safe_timestamp($trade, 'timestamp');
        if ($timestamp === null) {
            // fetchMyTrades
            $baseBalance = $this->safe_dict($this->safe_dict($trade, 'pre_balance', array()), 'base', array());
            $marketId = null;
            if (is_array($baseBalance) && array_key_exists('perp', $baseBalance)) {
                $marketId = $this->safe_string($this->safe_dict($baseBalance, 'perp', array()), 'product_id');
            } else {
                $marketId = $this->safe_string($this->safe_dict($baseBalance, 'spot', array()), 'product_id');
            }
            $market = $this->safe_market($marketId);
            $subOrder = $this->safe_dict($trade, 'order', array());
            $price = $this->convert_from_x18($this->safe_string($subOrder, 'priceX18'));
            $amount = $this->convert_from_x18($this->safe_string($trade, 'base_filled'));
            if (Precise::string_lt($amount, '0')) {
                $side = 'sell';
            } else {
                $side = 'buy';
            }
        } else {
            $tickerId = $this->safe_string($trade, 'ticker_id');
            $splitTickerId = explode('_', $tickerId);
            $splitSymbol = explode('-', $splitTickerId[0]);
            $marketId = $splitSymbol[0] . $splitTickerId[1];
            $market = $this->safe_market($marketId, $market);
            $price = $this->safe_string($trade, 'price');
            $amount = $this->safe_string($trade, 'base_filled');
            $side = $this->safe_string_lower($trade, 'trade_type');
        }
        $amount = Precise::string_abs($amount);
        $symbol = $market['symbol'];
        return $this->safe_trade(array(
            'id' => $id,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'symbol' => $symbol,
            'side' => $side,
            'price' => $price,
            'amount' => $amount,
            'cost' => null,
            'order' => $order,
            'takerOrMaker' => null,
            'type' => null,
            'fee' => $fee,
            'info' => $trade,
        ), $market);
    }

    public function fetch_trades(string $symbol, ?int $since = null, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            /**
             * get the list of most recent trades for a particular $symbol
             *
             * @see https://docs.vertexprotocol.com/developer-resources/api/v2/trades
             *
             * @param {string} $symbol unified $symbol of the $market to fetch trades for
             * @param {int} [$since] timestamp in ms of the earliest trade to fetch
             * @param {int} [$limit] the maximum amount of trades to fetch
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {Trade[]} a list of ~@link https://docs.ccxt.com/#/?id=public-trades trade structures~
             */
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $marketId = $market['baseId'] . '_USDC';
            $request = array(
                'ticker_id' => $marketId,
            );
            if ($limit !== null) {
                $request['limit'] = $limit;
            }
            $response = Async\await($this->v2ArchiveGetTrades ($this->extend($request, $params)));
            //
            // array(
            //     array(
            //       "ticker_id" => "ARB_USDC",
            //       "trade_id" => 999994,
            //       "price" => 1.1366122408151016,
            //       "base_filled" => 175,
            //       "quote_filled" => -198.90714214264278,
            //       "timestamp" => 1691068943,
            //       "trade_type" => "buy"
            //     ),
            //     {
            //       "ticker_id" => "ARB_USDC",
            //       "trade_id" => 999978,
            //       "price" => 1.136512210806099,
            //       "base_filled" => 175,
            //       "quote_filled" => -198.8896368910673,
            //       "timestamp" => 1691068882,
            //       "trade_type" => "buy"
            //     }
            // )
            //
            return $this->parse_trades($response, $market, $since, $limit);
        }) ();
    }

    public function fetch_my_trades(?string $symbol = null, ?int $since = null, ?int $limit = null, $params = array ()) {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            /**
             * fetch all $trades made by the user
             *
             * @see https://docs.vertexprotocol.com/developer-resources/api/archive-indexer/matches
             *
             * @param {string} $symbol unified $market $symbol
             * @param {int} [$since] the earliest time in ms to fetch $trades for
             * @param {int} [$limit] the maximum number of $trades structures to retrieve
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @param {string} [$params->user] user address, will default to $this->walletAddress if not provided
             * @return {Trade[]} a list of ~@link https://docs.ccxt.com/#/?id=trade-structure trade structures~
             */
            Async\await($this->load_markets());
            $userAddress = null;
            list($userAddress, $params) = $this->handle_public_address('fetchMyTrades', $params);
            $market = null;
            $matchesRequest = array(
                'subaccount' => $this->convert_address_to_sender($userAddress),
            );
            if ($symbol !== null) {
                $market = $this->market($symbol);
                $matchesRequest['product_ids'] = [ $this->parse_to_numeric($market['id']) ];
            }
            $until = $this->safe_integer($params, 'until');
            if ($until !== null) {
                $params = $this->omit($params, 'until');
                $matchesRequest['max_time'] = $until;
            }
            if ($limit !== null) {
                $matchesRequest['limit'] = $limit;
            }
            $request = array(
                'matches' => $matchesRequest,
            );
            $response = Async\await($this->v1ArchivePost ($this->extend($request, $params)));
            //
            // {
            //     "matches" => array(
            //       {
            //         "digest" => "0x80ce789702b670b7d33f2aa67e12c85f124395c3f9acdb422dde3b4973ccd50c",
            //         "order" => array(
            //           "sender" => "0x12a0b4888021576eb10a67616dd3dd3d9ce206b664656661756c740000000000",
            //           "priceX18" => "27544000000000000000000",
            //           "amount" => "2000000000000000000",
            //           "expiration" => "4611686020107119633",
            //           "nonce" => "1761322608857448448"
            //         ),
            //         "base_filled" => "736000000000000000",
            //         "quote_filled" => "-20276464287857571514302",
            //         "fee" => "4055287857571514302",
            //         "sequencer_fee" => "0"
            //         "cumulative_fee" => "4055287857571514302",
            //         "cumulative_base_filled" => "736000000000000000",
            //         "cumulative_quote_filled" => "-20276464287857571514302",
            //         "submission_idx" => "563012",
            //         "pre_balance" => {
            //           "base" => {
            //             "perp" => array(
            //               "product_id" => 2,
            //               "lp_balance" => array(
            //                 "amount" => "0",
            //                 "last_cumulative_funding_x18" => "1823351297710837"
            //               ),
            //               "balance" => array(
            //                 "amount" => "2686684000000000000000",
            //                 "v_quote_balance" => "-76348662407149297671587247",
            //                 "last_cumulative_funding_x18" => "134999841911604906604576"
            //               }
            //             }
            //           ),
            //           "quote" => null
            //         ),
            //         "post_balance" => {
            //           "base" => {
            //             "perp" => array(
            //               "product_id" => 2,
            //               "lp_balance" => array(
            //                 "amount" => "0",
            //                 "last_cumulative_funding_x18" => "1823351297710837"
            //               ),
            //               "balance" => array(
            //                 "amount" => "2686013000000000000000",
            //                 "v_quote_balance" => "-76328351274188497671587247",
            //                 "last_cumulative_funding_x18" => "134999841911604906604576"
            //               }
            //             }
            //           ),
            //           "quote" => null
            //         }
            //       ),
            //       {
            //         "digest" => "0x0f6e5a0434e36d8e6d4fed950d3624b0d8c91a8a84efd156bb25c1382561c0c2",
            //         "order" => array(
            //           "sender" => "0x12a0b4888021576eb10a67616dd3dd3d9ce206b664656661756c740000000000",
            //           "priceX18" => "27540000000000000000000",
            //           "amount" => "2000000000000000000",
            //           "expiration" => "4611686020107119623",
            //           "nonce" => "1761322602510417920"
            //         ),
            //         "base_filled" => "723999999999999999",
            //         "quote_filled" => "-19944943483044913474043",
            //         "fee" => "5983483044913474042",
            //         "cumulative_fee" => "11958484645393618085",
            //         "cumulative_base_filled" => "1446999999999999998",
            //         "cumulative_quote_filled" => "-39861640484645393618087",
            //         "submission_idx" => "563011",
            //         "pre_balance" => {
            //           "base" => {
            //             "perp" => array(
            //               "product_id" => 2,
            //               "lp_balance" => array(
            //                 "amount" => "0",
            //                 "last_cumulative_funding_x18" => "1823351297710837"
            //               ),
            //               "balance" => array(
            //                 "amount" => "2686684000000000000000",
            //                 "v_quote_balance" => "-76348662407149297671587247",
            //                 "last_cumulative_funding_x18" => "134999841911604906604576"
            //               }
            //             }
            //           ),
            //           "quote" => null
            //         ),
            //         "post_balance" => {
            //           "base" => {
            //             "perp" => {
            //               "product_id" => 2,
            //               "lp_balance" => array(
            //                 "amount" => "0",
            //                 "last_cumulative_funding_x18" => "1823351297710837"
            //               ),
            //               "balance" => array(
            //                 "amount" => "2686013000000000000000",
            //                 "v_quote_balance" => "-76328351274188497671587247",
            //                 "last_cumulative_funding_x18" => "134999841911604906604576"
            //               }
            //             }
            //           ),
            //           "quote" => null
            //         }
            //       }
            //     ),
            //     "txs" => array(
            //       {
            //         "tx" => {
            //           "match_orders" => array(
            //             "product_id" => 2,
            //             "amm" => true,
            //             "taker" => array(
            //               "order" => array(
            //                 "sender" => "0x12a0b4888021576eb10a67616dd3dd3d9ce206b664656661756c740000000000",
            //                 "price_x18" => "27544000000000000000000",
            //                 "amount" => "2000000000000000000",
            //                 "expiration" => 4611686020107120000,
            //                 "nonce" => 1761322608857448400
            //               ),
            //               "signature" => "0xe8fa7151bde348afa3b46dc52798046b7c8318f1b0a7f689710debbc094658cc1bf5a7e478ccc8278b625da0b9402c86b580d2e31e13831337dfd6153f4b37811b"
            //             ),
            //             "maker" => array(
            //               "order" => array(
            //                 "sender" => "0xebdbbcdbd2646c5f23a1e0806027eee5f71b074664656661756c740000000000",
            //                 "price_x18" => "27544000000000000000000",
            //                 "amount" => "-736000000000000000",
            //                 "expiration" => 1679731669,
            //                 "nonce" => 1761322585591644200
            //               ),
            //               "signature" => "0x47f9d47f0777f3ca0b13f07b7682dbeea098c0e377b87dcb025754fe34c900e336b8c7744e021fb9c46a4f8c6a1478bafa28bf0d023ae496aa3efa4d8e81df181c"
            //             }
            //           }
            //         ),
            //         "submission_idx" => "563012",
            //         "timestamp" => "1679728133"
            //       ),
            //       {
            //         "tx" => {
            //           "match_orders" => {
            //             "product_id" => 1,
            //             "amm" => true,
            //             "taker" => array(
            //               "order" => array(
            //                 "sender" => "0x12a0b4888021576eb10a67616dd3dd3d9ce206b664656661756c740000000000",
            //                 "price_x18" => "27540000000000000000000",
            //                 "amount" => "2000000000000000000",
            //                 "expiration" => 4611686020107120000,
            //                 "nonce" => 1761322602510418000
            //               ),
            //               "signature" => "0x826c68f1a3f76d9ffbe8041f8d45e969d31f1ab6f2ae2f6379d1493e479e56436091d6cf4c72e212dd2f1d2fa17c627c4c21bd6d281c77172b8af030488478b71c"
            //             ),
            //             "maker" => array(
            //               "order" => array(
            //                 "sender" => "0xf8d240d9514c9a4715d66268d7af3b53d619642564656661756c740000000000",
            //                 "price_x18" => "27540000000000000000000",
            //                 "amount" => "-724000000000000000",
            //                 "expiration" => 1679731656,
            //                 "nonce" => 1761322565506171000
            //               ),
            //               "signature" => "0xd8b6505b8d9b8c3cbfe793080976388035682c02a27893fb26b48a5b2bfe943f4162dea3a42e24e0dff5e2f74fbf77e33d83619140a2a581117c55e6cc236bdb1c"
            //             }
            //           }
            //         ),
            //         "submission_idx" => "563011",
            //         "timestamp" => "1679728127"
            //       }
            //     )
            // }
            //
            $trades = $this->safe_list($response, 'matches', array());
            return $this->parse_trades($trades, $market, $since, $limit, $params);
        }) ();
    }

    public function fetch_order_book(string $symbol, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $limit, $params) {
            /**
             * fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
             *
             * @see https://docs.vertexprotocol.com/developer-resources/api/v2/orderbook
             *
             * @param {string} $symbol unified $symbol of the $market to fetch the order book for
             * @param {int} [$limit] the maximum amount of order book entries to return
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} A dictionary of ~@link https://docs.ccxt.com/#/?id=order-book-structure order book structures~ indexed by $market symbols
             */
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $marketId = $market['baseId'] . '_USDC';
            if ($limit === null) {
                $limit = 100;
            }
            $request = array(
                'ticker_id' => $marketId,
                'depth' => $limit,
            );
            $response = Async\await($this->v2GatewayGetOrderbook ($this->extend($request, $params)));
            //
            // {
            //     "ticker_id" => "ETH-PERP_USDC",
            //     "bids" => array(
            //         array(
            //             1612.3,
            //             0.31
            //         ),
            //         array(
            //             1612.0,
            //             0.93
            //         ),
            //         array(
            //             1611.5,
            //             1.55
            //         ),
            //         array(
            //             1610.8,
            //             2.17
            //         )
            //     ),
            //     "asks" => array(
            //         array(
            //             1612.9,
            //             0.93
            //         ),
            //         array(
            //             1613.4,
            //             1.55
            //         ),
            //         array(
            //             1614.1,
            //             2.17
            //         )
            //     ),
            //     "timestamp" => 1694375362016
            // }
            //
            $timestamp = $this->safe_integer($response, 'timestamp');
            return $this->parse_order_book($response, $symbol, $timestamp, 'bids', 'asks');
        }) ();
    }

    public function fetch_trading_fees($params = array ()): PromiseInterface {
        return Async\async(function () use ($params) {
            /**
             * fetch the trading fees for multiple markets
             *
             * @see https://docs.vertexprotocol.com/developer-resources/api/gateway/queries/fee-rates
             *
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @param {string} [$params->user] user address, will default to $this->walletAddress if not provided
             * @return {array} a dictionary of ~@link https://docs.ccxt.com/#/?id=fee-structure fee structures~ indexed by $market symbols
             */
            Async\await($this->load_markets());
            $userAddress = null;
            list($userAddress, $params) = $this->handle_public_address('fetchTradingFees', $params);
            $request = array(
                'type' => 'fee_rates',
                'sender' => $this->convert_address_to_sender($userAddress),
            );
            $response = Async\await($this->v1GatewayGetQuery ($this->extend($request, $params)));
            //
            // {
            //     "status" => "success",
            //     "data" => array(
            //       "taker_fee_rates_x18" => array(
            //         "0",
            //         "300000000000000",
            //         "200000000000000",
            //         "300000000000000",
            //         "200000000000000"
            //       ),
            //       "maker_fee_rates_x18" => array(
            //         "0",
            //         "0",
            //         "0",
            //         "0",
            //         "0"
            //       ),
            //       "liquidation_sequencer_fee" => "250000000000000000",
            //       "health_check_sequencer_fee" => "100000000000000000",
            //       "taker_sequencer_fee" => "25000000000000000",
            //       "withdraw_sequencer_fees" => array(
            //         "10000000000000000",
            //         "40000000000000",
            //         "0",
            //         "600000000000000",
            //         "0"
            //       )
            //     ),
            //     "request_type" => "query_fee_rates",
            // }
            //
            $data = $this->safe_dict($response, 'data', array());
            $maker = $this->safe_list($data, 'maker_fee_rates_x18', array());
            $taker = $this->safe_list($data, 'taker_fee_rates_x18', array());
            $result = array();
            for ($i = 0; $i < count($taker); $i++) {
                $market = $this->safe_market($this->number_to_string($i));
                if ($market['id'] === null) {
                    continue;
                }
                $symbol = $market['symbol'];
                $result[$symbol] = array(
                    'info' => $response,
                    'symbol' => $symbol,
                    'maker' => $this->parse_number($this->convert_from_x18($maker[$i])),
                    'taker' => $this->parse_number($this->convert_from_x18($taker[$i])),
                    'percentage' => true,
                    'tierBased' => false,
                );
            }
            return $result;
        }) ();
    }

    public function parse_ohlcv($ohlcv, ?array $market = null): array {
        // example response in fetchOHLCV
        return array(
            $this->safe_timestamp($ohlcv, 'timestamp'),
            $this->parse_number($this->convert_from_x18($this->safe_string($ohlcv, 'open_x18'))),
            $this->parse_number($this->convert_from_x18($this->safe_string($ohlcv, 'high_x18'))),
            $this->parse_number($this->convert_from_x18($this->safe_string($ohlcv, 'low_x18'))),
            $this->parse_number($this->convert_from_x18($this->safe_string($ohlcv, 'close_x18'))),
            $this->parse_number($this->convert_from_x18($this->safe_string($ohlcv, 'volume'))),
        );
    }

    public function fetch_ohlcv(string $symbol, $timeframe = '1m', ?int $since = null, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $timeframe, $since, $limit, $params) {
            /**
             *
             * @see https://docs.vertexprotocol.com/developer-resources/api/archive-indexer/candlesticks
             *
             * fetches historical candlestick data containing the open, high, low, and close price, and the volume of a $market
             * @param {string} $symbol unified $symbol of the $market to fetch OHLCV data for
             * @param {string} $timeframe the length of time each candle represents
             * @param {int} [$since] timestamp in ms of the earliest candle to fetch
             * @param {int} [$limit] max=1000, max=100 when $since is defined and is less than (now - (999 * (is_array(ms) && array_key_exists($timeframe, ms))))
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {int[][]} A list of candles ordered, open, high, low, close, volume
             */
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $ohlcvRequest = array(
                'product_id' => $this->parse_to_int($market['id']),
                'granularity' => $this->safe_integer($this->timeframes, $timeframe),
            );
            $until = $this->safe_integer($params, 'until');
            if ($until !== null) {
                $params = $this->omit($params, 'until');
                $ohlcvRequest['max_time'] = $until;
            }
            if ($limit !== null) {
                $ohlcvRequest['limit'] = min ($limit, 1000);
            }
            $request = array(
                'candlesticks' => $ohlcvRequest,
            );
            $response = Async\await($this->v1ArchivePost ($this->extend($request, $params)));
            //
            // {
            //     "candlesticks" => array(
            //       array(
            //         "product_id" => 1,
            //         "granularity" => 60,
            //         "submission_idx" => "627709",
            //         "timestamp" => "1680118140",
            //         "open_x18" => "27235000000000000000000",
            //         "high_x18" => "27298000000000000000000",
            //         "low_x18" => "27235000000000000000000",
            //         "close_x18" => "27298000000000000000000",
            //         "volume" => "1999999999999999998"
            //       ),
            //       {
            //         "product_id" => 1,
            //         "granularity" => 60,
            //         "submission_idx" => "627699",
            //         "timestamp" => "1680118080",
            //         "open_x18" => "27218000000000000000000",
            //         "high_x18" => "27245000000000000000000",
            //         "low_x18" => "27218000000000000000000",
            //         "close_x18" => "27245000000000000000000",
            //         "volume" => "11852999999999999995"
            //       }
            //     )
            // }
            //
            $rows = $this->safe_list($response, 'candlesticks', array());
            return $this->parse_ohlcvs($rows, $market, $timeframe, $since, $limit);
        }) ();
    }

    public function parse_funding_rate($ticker, ?array $market = null): array {
        //
        // {
        //     "product_id" => 4,
        //     "funding_rate_x18" => "2447900598160952",
        //     "update_time" => "1680116326"
        // }
        //
        // {
        //     "ETH-PERP_USDC" => {
        //         "ticker_id" => "ETH-PERP_USDC",
        //         "base_currency" => "ETH-PERP",
        //         "quote_currency" => "USDC",
        //         "last_price" => 1620.3,
        //         "base_volume" => 1309.2,
        //         "quote_volume" => 2117828.093867611,
        //         "product_type" => "perpetual",
        //         "contract_price" => 1620.372642114429,
        //         "contract_price_currency" => "USD",
        //         "open_interest" => 1635.2,
        //         "open_interest_usd" => 2649633.3443855145,
        //         "index_price" => 1623.293496279935,
        //         "mark_price" => 1623.398589416731,
        //         "funding_rate" => 0.000068613217104332,
        //         "next_funding_rate_timestamp" => 1694379600,
        //         "price_change_percent_24h" => -0.6348599635253989
        //     }
        // }
        //
        $fundingRate = $this->safe_number($ticker, 'funding_rate');
        if ($fundingRate === null) {
            $fundingRateX18 = $this->safe_string($ticker, 'funding_rate_x18');
            $fundingRate = $this->parse_number($this->convert_from_x18($fundingRateX18));
        }
        $fundingTimestamp = $this->safe_timestamp_2($ticker, 'update_time', 'next_funding_rate_timestamp');
        $markPrice = $this->safe_number($ticker, 'mark_price');
        $indexPrice = $this->safe_number($ticker, 'index_price');
        return array(
            'info' => $ticker,
            'symbol' => $market['symbol'],
            'markPrice' => $markPrice,
            'indexPrice' => $indexPrice,
            'interestRate' => null,
            'estimatedSettlePrice' => null,
            'timestamp' => null,
            'datetime' => null,
            'fundingRate' => $fundingRate,
            'fundingTimestamp' => $fundingTimestamp,
            'fundingDatetime' => $this->iso8601($fundingTimestamp),
            'nextFundingRate' => null,
            'nextFundingTimestamp' => null,
            'nextFundingDatetime' => null,
            'previousFundingRate' => null,
            'previousFundingTimestamp' => null,
            'previousFundingDatetime' => null,
            'interval' => null,
        );
    }

    public function fetch_funding_rate(string $symbol, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $params) {
            /**
             * fetch the current funding rate
             *
             * @see https://docs.vertexprotocol.com/developer-resources/api/archive-indexer/funding-rate
             *
             * @param {string} $symbol unified $market $symbol
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} a ~@link https://docs.ccxt.com/#/?id=funding-rate-structure funding rate structure~
             */
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $request = array(
                'funding_rate' => array(
                    'product_id' => $this->parse_to_int($market['id']),
                ),
            );
            $response = Async\await($this->v1ArchivePost ($this->extend($request, $params)));
            //
            // {
            //     "product_id" => 4,
            //     "funding_rate_x18" => "2447900598160952",
            //     "update_time" => "1680116326"
            // }
            //
            return $this->parse_funding_rate($response, $market);
        }) ();
    }

    public function fetch_funding_rates(?array $symbols = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbols, $params) {
            /**
             * fetches funding rates for multiple markets
             *
             * @see https://docs.vertexprotocol.com/developer-resources/api/v2/contracts
             *
             * @param {string[]} $symbols unified $symbols of the markets to fetch the funding rates for, all $market funding rates are returned if not assigned
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array[]} an array of ~@link https://docs.ccxt.com/#/?id=funding-rate-structure funding rate structures~
             */
            Async\await($this->load_markets());
            $request = array();
            if ($symbols !== null) {
                $symbols = $this->market_symbols($symbols);
            }
            $response = Async\await($this->v2ArchiveGetContracts ($this->extend($request, $params)));
            //
            // {
            //     "ETH-PERP_USDC" => {
            //         "ticker_id" => "ETH-PERP_USDC",
            //         "base_currency" => "ETH-PERP",
            //         "quote_currency" => "USDC",
            //         "last_price" => 1620.3,
            //         "base_volume" => 1309.2,
            //         "quote_volume" => 2117828.093867611,
            //         "product_type" => "perpetual",
            //         "contract_price" => 1620.372642114429,
            //         "contract_price_currency" => "USD",
            //         "open_interest" => 1635.2,
            //         "open_interest_usd" => 2649633.3443855145,
            //         "index_price" => 1623.293496279935,
            //         "mark_price" => 1623.398589416731,
            //         "funding_rate" => 0.000068613217104332,
            //         "next_funding_rate_timestamp" => 1694379600,
            //         "price_change_percent_24h" => -0.6348599635253989
            //     }
            // }
            //
            $keys = is_array($response) ? array_keys($response) : array();
            $fundingRates = array();
            for ($i = 0; $i < count($keys); $i++) {
                $tickerId = $keys[$i];
                $parsedTickerId = explode('-', $tickerId);
                $data = $response[$tickerId];
                $marketId = $parsedTickerId[0] . '/USDC:USDC';
                $market = $this->market($marketId);
                $ticker = $this->parse_funding_rate($data, $market);
                $symbol = $ticker['symbol'];
                $fundingRates[$symbol] = $ticker;
            }
            return $this->filter_by_array($fundingRates, 'symbol', $symbols);
        }) ();
    }

    public function parse_open_interest($interest, ?array $market = null) {
        //
        // {
        //     "ETH-PERP_USDC" => {
        //         "ticker_id" => "ETH-PERP_USDC",
        //         "base_currency" => "ETH-PERP",
        //         "quote_currency" => "USDC",
        //         "last_price" => 1620.3,
        //         "base_volume" => 1309.2,
        //         "quote_volume" => 2117828.093867611,
        //         "product_type" => "perpetual",
        //         "contract_price" => 1620.372642114429,
        //         "contract_price_currency" => "USD",
        //         "open_interest" => 1635.2,
        //         "open_interest_usd" => 2649633.3443855145,
        //         "index_price" => 1623.293496279935,
        //         "mark_price" => 1623.398589416731,
        //         "funding_rate" => 0.000068613217104332,
        //         "next_funding_rate_timestamp" => 1694379600,
        //         "price_change_percent_24h" => -0.6348599635253989
        //     }
        // }
        //
        $marketId = $this->safe_string($interest, 'ticker_id');
        return $this->safe_open_interest(array(
            'symbol' => $this->safe_symbol($marketId, $market),
            'openInterestAmount' => $this->safe_number($interest, 'open_interest'),
            'openInterestValue' => $this->safe_number($interest, 'open_interest_usd'),
            'timestamp' => null,
            'datetime' => null,
            'info' => $interest,
        ), $market);
    }

    public function fetch_open_interests(?array $symbols = null, $params = array ()) {
        return Async\async(function () use ($symbols, $params) {
            /**
             * Retrieves the open interest for a list of $symbols
             *
             * @see https://docs.vertexprotocol.com/developer-resources/api/v2/contracts
             *
             * @param {string[]} [$symbols] a list of unified CCXT $market $symbols
             * @param {array} [$params] exchange specific parameters
             * @return {array[]} a list of ~@link https://docs.ccxt.com/#/?id=open-interest-structure open interest structures~
             */
            Async\await($this->load_markets());
            $symbols = $this->market_symbols($symbols);
            $response = Async\await($this->v2ArchiveGetContracts ($params));
            //
            //     {
            //         "ADA-PERP_USDC" => array(
            //             "ticker_id" => "ADA-PERP_USDC",
            //             "base_currency" => "ADA-PERP",
            //             "quote_currency" => "USDC",
            //             "last_price" => 0.85506,
            //             "base_volume" => 1241320.0,
            //             "quote_volume" => 1122670.9080057142,
            //             "product_type" => "perpetual",
            //             "contract_price" => 0.8558601432685385,
            //             "contract_price_currency" => "USD",
            //             "open_interest" => 104040.0,
            //             "open_interest_usd" => 89043.68930565874,
            //             "index_price" => 0.8561952606869176,
            //             "mark_price" => 0.856293781088936,
            //             "funding_rate" => 0.000116153806226841,
            //             "next_funding_rate_timestamp" => 1734685200,
            //             "price_change_percent_24h" => -12.274325340321374
            //         ),
            //     }
            //
            $parsedSymbols = array();
            $results = array();
            $markets = is_array($response) ? array_keys($response) : array();
            if ($symbols === null) {
                $symbols = array();
                for ($y = 0; $y < count($markets); $y++) {
                    $tickerId = $markets[$y];
                    $parsedTickerId = explode('-', $tickerId);
                    $currentSymbol = $parsedTickerId[0] . '/USDC:USDC';
                    if (!$this->in_array($currentSymbol, $symbols)) {
                        $symbols[] = $currentSymbol;
                    }
                }
            }
            for ($i = 0; $i < count($markets); $i++) {
                $marketId = $markets[$i];
                $marketInner = $this->safe_market($marketId);
                $openInterest = $this->safe_dict($response, $marketId, array());
                for ($j = 0; $j < count($symbols); $j++) {
                    $market = $this->market($symbols[$j]);
                    $tickerId = $market['base'] . '_USDC';
                    if ($marketInner['marketId'] === $tickerId) {
                        $parsedSymbols[] = $market['symbol'];
                        $results[] = $this->parse_open_interest($openInterest, $market);
                    }
                }
            }
            return $this->filter_by_array($results, 'symbol', $parsedSymbols);
        }) ();
    }

    public function fetch_open_interest(string $symbol, $params = array ()) {
        return Async\async(function () use ($symbol, $params) {
            /**
             * Retrieves the open interest of a derivative trading pair
             *
             * @see https://docs.vertexprotocol.com/developer-resources/api/v2/contracts
             *
             * @param {string} $symbol Unified CCXT $market $symbol
             * @param {array} [$params] exchange specific parameters
             * @return {array} an open interest structurearray(@link https://docs.ccxt.com/#/?id=open-interest-structure)
             */
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            if (!$market['contract']) {
                throw new BadRequest($this->id . ' fetchOpenInterest() supports contract markets only');
            }
            $request = array();
            $response = Async\await($this->v2ArchiveGetContracts ($this->extend($request, $params)));
            //
            // {
            //     "ETH-PERP_USDC" => {
            //         "ticker_id" => "ETH-PERP_USDC",
            //         "base_currency" => "ETH-PERP",
            //         "quote_currency" => "USDC",
            //         "last_price" => 1620.3,
            //         "base_volume" => 1309.2,
            //         "quote_volume" => 2117828.093867611,
            //         "product_type" => "perpetual",
            //         "contract_price" => 1620.372642114429,
            //         "contract_price_currency" => "USD",
            //         "open_interest" => 1635.2,
            //         "open_interest_usd" => 2649633.3443855145,
            //         "index_price" => 1623.293496279935,
            //         "mark_price" => 1623.398589416731,
            //         "funding_rate" => 0.000068613217104332,
            //         "next_funding_rate_timestamp" => 1694379600,
            //         "price_change_percent_24h" => -0.6348599635253989
            //     }
            // }
            //
            $tickerId = $market['base'] . '_USDC';
            $openInterest = $this->safe_dict($response, $tickerId, array());
            return $this->parse_open_interest($openInterest, $market);
        }) ();
    }

    public function parse_ticker(array $ticker, ?array $market = null): array {
        //
        //     {
        //         "ticker_id" => "BTC_USDC",
        //         "base_currency" => "BTC",
        //         "quote_currency" => "USDC",
        //         "last_price" => 25728.0,
        //         "base_volume" => 552.048,
        //         "quote_volume" => 14238632.207250029,
        //         "price_change_percent_24h" => -0.6348599635253989
        //     }
        //
        $base = $this->safe_string($ticker, 'base_currency');
        $quote = $this->safe_string($ticker, 'quote_currency');
        $marketId = $base . '/' . $quote;
        if (mb_strpos($base, 'PERP') > 0) {
            $marketId = str_replace('-PERP', '', $marketId) . ':USDC';
        }
        $market = $this->safe_market($marketId, $market);
        $last = $this->safe_string($ticker, 'last_price');
        return $this->safe_ticker(array(
            'symbol' => $market['symbol'],
            'timestamp' => null,
            'datetime' => null,
            'high' => null,
            'low' => null,
            'bid' => null,
            'bidVolume' => null,
            'ask' => null,
            'askVolume' => null,
            'vwap' => null,
            'open' => null,
            'close' => $last,
            'last' => $last,
            'previousClose' => null,
            'change' => null,
            'percentage' => $this->safe_string($ticker, 'price_change_percent_24h'),
            'average' => null,
            'baseVolume' => $this->safe_string($ticker, 'base_volume'),
            'quoteVolume' => $this->safe_string($ticker, 'quote_volume'),
            'info' => $ticker,
        ), $market);
    }

    public function fetch_tickers(?array $symbols = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbols, $params) {
            /**
             * fetches price $tickers for multiple markets, statistical information calculated over the past 24 hours for each market
             *
             * @see https://docs.vertexprotocol.com/developer-resources/api/v2/tickers
             *
             * @param {string[]} [$symbols] unified $symbols of the markets to fetch the ticker for, all market $tickers are returned if not assigned
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} a dictionary of ~@link https://docs.ccxt.com/#/?id=ticker-structure ticker structures~
             */
            Async\await($this->load_markets());
            $symbols = $this->market_symbols($symbols, null, true, true, true);
            $request = array();
            $response = Async\await($this->v2ArchiveGetTickers ($this->extend($request, $params)));
            //
            // {
            //     "ETH_USDC" => array(
            //         "ticker_id" => "ETH_USDC",
            //         "base_currency" => "ETH",
            //         "quote_currency" => "USDC",
            //         "last_price" => 1619.1,
            //         "base_volume" => 1428.32,
            //         "quote_volume" => 2310648.316391866,
            //         "price_change_percent_24h" => -1.0509394462969588
            //     ),
            //     "BTC_USDC" => {
            //         "ticker_id" => "BTC_USDC",
            //         "base_currency" => "BTC",
            //         "quote_currency" => "USDC",
            //         "last_price" => 25728.0,
            //         "base_volume" => 552.048,
            //         "quote_volume" => 14238632.207250029,
            //         "price_change_percent_24h" => -0.6348599635253989
            //     }
            // }
            //
            $tickers = is_array($response) ? array_values($response) : array();
            return $this->parse_tickers($tickers, $symbols);
        }) ();
    }

    public function query_contracts($params = array ()): PromiseInterface {
        return Async\async(function () use ($params) {
            // query contract addresses for sending order
            $cachedContracts = $this->safe_dict($this->options, 'v1contracts');
            if ($cachedContracts !== null) {
                return $cachedContracts;
            }
            $request = array(
                'type' => 'contracts',
            );
            $response = Async\await($this->v1GatewayGetQuery ($this->extend($request, $params)));
            $data = $this->safe_dict($response, 'data', array());
            $this->options['v1contracts'] = $data;
            return $data;
        }) ();
    }

    public function nonce() {
        return $this->milliseconds() - $this->options['timeDifference'];
    }

    public function hash_message($message) {
        return '0x' . $this->hash($message, 'keccak', 'hex');
    }

    public function sign_hash($hash, $privateKey) {
        $signature = $this->ecdsa(mb_substr($hash, -64), mb_substr($privateKey, -64), 'secp256k1', null);
        $r = $signature['r'];
        $s = $signature['s'];
        $v = $this->int_to_base16($this->sum(27, $signature['v']));
        return '0x' . str_pad($r, 64, '0', STR_PAD_LEFT) . str_pad($s, 64, '0', STR_PAD_LEFT) . $v;
    }

    public function sign_message($message, $privateKey) {
        return $this->sign_hash($this->hash_message($message), mb_substr($privateKey, -64));
    }

    public function build_sig($chainId, $messageTypes, $message, $verifyingContractAddress = '') {
        $domain = array(
            'chainId' => $chainId,
            'name' => 'Vertex',
            'verifyingContract' => $verifyingContractAddress,
            'version' => '0.0.1',
        );
        $msg = $this->eth_encode_structured_data($domain, $messageTypes, $message);
        $signature = $this->sign_message($msg, $this->privateKey);
        return $signature;
    }

    public function build_create_order_sig($message, $chainId, $verifyingContractAddress) {
        $messageTypes = array(
            'Order' => array(
                array( 'name' => 'sender', 'type' => 'bytes32' ),
                array( 'name' => 'priceX18', 'type' => 'int128' ),
                array( 'name' => 'amount', 'type' => 'int128' ),
                array( 'name' => 'expiration', 'type' => 'uint64' ),
                array( 'name' => 'nonce', 'type' => 'uint64' ),
            ),
        );
        return $this->build_sig($chainId, $messageTypes, $message, $verifyingContractAddress);
    }

    public function build_list_trigger_tx_sig($message, $chainId, $verifyingContractAddress) {
        $messageTypes = array(
            'ListTriggerOrders' => array(
                array( 'name' => 'sender', 'type' => 'bytes32' ),
                array( 'name' => 'recvTime', 'type' => 'uint64' ),
            ),
        );
        return $this->build_sig($chainId, $messageTypes, $message, $verifyingContractAddress);
    }

    public function build_cancel_all_orders_sig($message, $chainId, $verifyingContractAddress) {
        $messageTypes = array(
            'CancellationProducts' => [
                array( 'name' => 'sender', 'type' => 'bytes32' ),
                array( 'name' => 'productIds', 'type' => 'uint32[]' ),
                array( 'name' => 'nonce', 'type' => 'uint64' ),
            ],
        );
        return $this->build_sig($chainId, $messageTypes, $message, $verifyingContractAddress);
    }

    public function build_cancel_orders_sig($message, $chainId, $verifyingContractAddress) {
        $messageTypes = array(
            'Cancellation' => [
                array( 'name' => 'sender', 'type' => 'bytes32' ),
                array( 'name' => 'productIds', 'type' => 'uint32[]' ),
                array( 'name' => 'digests', 'type' => 'bytes32[]' ),
                array( 'name' => 'nonce', 'type' => 'uint64' ),
            ],
        );
        return $this->build_sig($chainId, $messageTypes, $message, $verifyingContractAddress);
    }

    public function build_withdraw_sig($message, $chainId, $verifyingContractAddress) {
        $messageTypes = array(
            'WithdrawCollateral' => array(
                array( 'name' => 'sender', 'type' => 'bytes32' ),
                array( 'name' => 'productId', 'type' => 'uint32' ),
                array( 'name' => 'amount', 'type' => 'uint128' ),
                array( 'name' => 'nonce', 'type' => 'uint64' ),
            ),
        );
        return $this->build_sig($chainId, $messageTypes, $message, $verifyingContractAddress);
    }

    public function convert_address_to_sender(string $address) {
        $sender = $address . '64656661756c74';
        return str_pad($sender, 66, '0', STR_PAD_RIGHT);
    }

    public function get_nonce($now, $expiration) {
        if ($now === null) {
            $now = $this->nonce();
        }
        // nonce = (($now . $expiration) << 20) + 1000
        // 1 << 20 = 1048576
        return Precise::string_add(Precise::string_mul(Precise::string_add($this->number_to_string($now), $this->number_to_string($expiration)), '1048576'), '1000');
    }

    public function get_expiration($now, $timeInForce, $postOnly, $reduceOnly) {
        $expiration = Precise::string_add($this->number_to_string($now), '86400');
        if ($timeInForce === 'ioc') {
            // 1 << 62 = 4611686018427387904
            $expiration = Precise::string_or($expiration, '4611686018427387904');
        } elseif ($timeInForce === 'fok') {
            // 2 << 62 = 9223372036854775808
            $expiration = Precise::string_or($expiration, '9223372036854775808');
        } elseif ($postOnly) {
            // 3 << 62 = 13835058055282163712
            $expiration = Precise::string_or($expiration, '13835058055282163712');
        }
        if ($reduceOnly) {
            // 1 << 61 = 2305843009213693952
            $expiration = Precise::string_or($expiration, '2305843009213693952');
        }
        return $expiration;
    }

    public function get_amount($amount, $side) {
        $amountString = $this->number_to_string($amount);
        if ($side === 'sell') {
            if ($amount > 0) {
                // $amount *= -1;
                $amountString = Precise::string_mul($amountString, '-1');
            }
        } else {
            if ($amount < 0) {
                // $amount *= -1;
                $amountString = Precise::string_mul($amountString, '-1');
            }
        }
        return $amountString;
    }

    public function create_order(string $symbol, string $type, string $side, float $amount, ?float $price = null, $params = array ()) {
        return Async\async(function () use ($symbol, $type, $side, $amount, $price, $params) {
            /**
             * create a trade $order
             *
             * @see https://docs.vertexprotocol.com/developer-resources/api/gateway/executes/place-$order
             * @see https://docs.vertexprotocol.com/developer-resources/api/trigger/executes/place-$order
             *
             * @param {string} $symbol unified $symbol of the $market to create an $order in
             * @param {string} $type 'market' or 'limit'
             * @param {string} $side 'buy' or 'sell'
             * @param {float} $amount how much of currency you want to trade in units of base currency
             * @param {float} [$price] the $price at which the $order is to be fulfilled, in units of the quote currency, ignored in $market orders
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @param {string} [$params->timeInForce] ioc, fok
             * @param {bool} [$params->postOnly] true or false whether the $order is post-only
             * @param {bool} [$params->reduceOnly] true or false whether the $order is reduce-only, only works for ioc and fok $order
             * @param {float} [$params->triggerPrice] The $price at which a $trigger $order is triggered at
             * @return {array} an ~@link https://docs.ccxt.com/#/?id=$order-structure $order structure~
             */
            $this->check_required_credentials();
            $marketType = strtolower($type);
            $isMarketOrder = $marketType === 'market';
            if ($isMarketOrder && $price === null) {
                throw new ArgumentsRequired($this->id . ' createOrder() requires a $price argument for $market order');
            }
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $marketId = $this->parse_to_int($market['id']);
            $contracts = Async\await($this->query_contracts());
            $chainId = $this->safe_string($contracts, 'chain_id');
            $bookAddresses = $this->safe_list($contracts, 'book_addrs', array());
            $verifyingContractAddress = $this->safe_string($bookAddresses, $marketId);
            $defaultTimeInForce = ($isMarketOrder) ? 'fok' : null;
            $timeInForce = $this->safe_string_lower($params, 'timeInForce', $defaultTimeInForce);
            $postOnly = $this->safe_bool($params, 'postOnly', false);
            $reduceOnly = $this->safe_bool($params, 'reduceOnly', false);
            $triggerPrice = $this->safe_string_2($params, 'triggerPrice', 'stopPrice');
            $stopLossPrice = $this->safe_string($params, 'stopLossPrice', $triggerPrice);
            $takeProfitPrice = $this->safe_string($params, 'takeProfitPrice');
            $isTrigger = ($stopLossPrice || $takeProfitPrice);
            $now = $this->nonce();
            $nonce = $this->get_nonce($now, 90000);
            if ($postOnly && $reduceOnly) {
                throw new NotSupported($this->id . ' $reduceOnly not supported when $postOnly is enabled');
            }
            $expiration = $this->get_expiration($now, $timeInForce, $postOnly, $reduceOnly);
            if ($isTrigger) {
                // 1 << 63 = 9223372036854775808
                $nonce = Precise::string_or($nonce, '9223372036854775808');
            }
            $amountString = $this->get_amount($amount, $side);
            $order = array(
                'sender' => $this->convert_address_to_sender($this->walletAddress),
                'priceX18' => $this->convert_to_x18($this->price_to_precision($symbol, $price)),
                'amount' => $this->convert_to_x18($this->amount_to_precision($symbol, $amountString)),
                'expiration' => $expiration,
                'nonce' => $nonce,
            );
            $request = array(
                'place_order' => array(
                    'product_id' => $marketId,
                    'order' => array(
                        'sender' => $order['sender'],
                        'priceX18' => $order['priceX18'],
                        'amount' => $order['amount'],
                        'expiration' => $this->number_to_string($order['expiration']),
                        'nonce' => $order['nonce'],
                    ),
                    'signature' => $this->build_create_order_sig($order, $chainId, $verifyingContractAddress),
                    'id' => $this->safe_integer($this->options, 'brokerId', 5930043274845996),
                ),
            );
            $params = $this->omit($params, array( 'timeInForce', 'reduceOnly', 'postOnly', 'triggerPrice', 'stopPrice', 'stopLossPrice', 'takeProfitPrice' ));
            $response = null;
            if ($isTrigger) {
                $trigger = array();
                if ($stopLossPrice !== null) {
                    $trigger['last_price_below'] = $this->convert_to_x18($stopLossPrice);
                } elseif ($takeProfitPrice !== null) {
                    $trigger['last_price_above'] = $this->convert_to_x18($takeProfitPrice);
                }
                $request['place_order']['trigger'] = $trigger;
                $response = Async\await($this->v1TriggerPostExecute ($this->extend($request, $params)));
            } else {
                $response = Async\await($this->v1GatewayPostExecute ($this->extend($request, $params)));
            }
            //
            // {
            //     "status" => "success",
            //     "signature" => {signature},
            //     "data" => array(
            //       "digest" => array($order digest)
            //     ),
            //     "request_type" => "execute_place_order"
            //     "id" => 100
            // }
            //
            $data = $this->safe_dict($response, 'data', array());
            return $this->safe_order(array(
                'id' => $this->safe_string($data, 'digest'),
            ));
        }) ();
    }

    public function edit_order(string $id, string $symbol, string $type, string $side, ?float $amount = null, ?float $price = null, $params = array ()) {
        return Async\async(function () use ($id, $symbol, $type, $side, $amount, $price, $params) {
            /**
             * edit a trade $order
             *
             * @see https://docs.vertexprotocol.com/developer-resources/api/gateway/executes/cancel-and-place
             *
             * @param {string} $id cancel $order $id
             * @param {string} $symbol unified $symbol of the $market to create an $order in
             * @param {string} $type 'market' or 'limit'
             * @param {string} $side 'buy' or 'sell'
             * @param {float} $amount how much of currency you want to trade in units of base currency
             * @param {float} [$price] the $price at which the $order is to be fulfilled, in units of the quote currency, ignored in $market orders
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @param {string} [$params->timeInForce] ioc, fok
             * @param {bool} [$params->postOnly] true or false whether the $order is post-only
             * @param {bool} [$params->reduceOnly] true or false whether the $order is reduce-only, only works for ioc and fok $order
             * @param {float} [$params->triggerPrice] The $price at which a trigger $order is triggered at
             * @return {array} an ~@link https://docs.ccxt.com/#/?$id=$order-structure $order structure~
             */
            $this->check_required_credentials();
            $marketType = strtolower($type);
            $isMarketOrder = $marketType === 'market';
            if ($isMarketOrder && $price === null) {
                throw new ArgumentsRequired($this->id . ' editOrder() requires a $price argument for $market order');
            }
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $marketId = $this->parse_to_int($market['id']);
            $defaultTimeInForce = ($isMarketOrder) ? 'fok' : null;
            $timeInForce = $this->safe_string_lower($params, 'timeInForce', $defaultTimeInForce);
            $postOnly = $this->safe_bool($params, 'postOnly', false);
            $reduceOnly = $this->safe_bool($params, 'reduceOnly', false);
            $triggerPrice = $this->safe_string_2($params, 'triggerPrice', 'stopPrice');
            $stopLossPrice = $this->safe_string($params, 'stopLossPrice', $triggerPrice);
            $takeProfitPrice = $this->safe_string($params, 'takeProfitPrice');
            $isTrigger = ($stopLossPrice || $takeProfitPrice);
            $contracts = Async\await($this->query_contracts());
            $chainId = $this->safe_string($contracts, 'chain_id');
            $bookAddresses = $this->safe_list($contracts, 'book_addrs', array());
            $verifyingContractAddressOrder = $this->safe_string($bookAddresses, $marketId);
            $verifyingContractAddressCancel = $this->safe_string($contracts, 'endpoint_addr');
            $now = $this->nonce();
            $nonce = $this->get_nonce($now, 90000);
            $sender = $this->convert_address_to_sender($this->walletAddress);
            if ($postOnly && $reduceOnly) {
                throw new NotSupported($this->id . ' $reduceOnly not supported when $postOnly is enabled');
            }
            if ($isTrigger) {
                throw new NotSupported($this->id . ' editOrder() not supported for trigger order');
            }
            $expiration = $this->get_expiration($now, $timeInForce, $postOnly, $reduceOnly);
            $amountString = $this->get_amount($amount, $side);
            $order = array(
                'sender' => $sender,
                'priceX18' => $this->convert_to_x18($this->price_to_precision($symbol, $price)),
                'amount' => $this->convert_to_x18($this->amount_to_precision($symbol, $amountString)),
                'expiration' => $expiration,
                'nonce' => $nonce,
            );
            $cancels = array(
                'sender' => $sender,
                'productIds' => array( $marketId ),
                'digests' => array( $id ),
                'nonce' => $nonce,
            );
            $request = array(
                'cancel_and_place' => array(
                    'cancel_tx' => array(
                        'sender' => $cancels['sender'],
                        'productIds' => $cancels['productIds'],
                        'digests' => $cancels['digests'],
                        'nonce' => $this->number_to_string($cancels['nonce']),
                    ),
                    'cancel_signature' => $this->build_cancel_orders_sig($cancels, $chainId, $verifyingContractAddressCancel),
                    'place_order' => array(
                        'product_id' => $marketId,
                        'order' => array(
                            'sender' => $order['sender'],
                            'priceX18' => $order['priceX18'],
                            'amount' => $order['amount'],
                            'expiration' => $this->number_to_string($order['expiration']),
                            'nonce' => $order['nonce'],
                        ),
                        'signature' => $this->build_create_order_sig($order, $chainId, $verifyingContractAddressOrder),
                        'id' => $this->safe_integer($this->options, 'brokerId', 5930043274845996),
                    ),
                ),
            );
            $params = $this->omit($params, array( 'timeInForce', 'reduceOnly', 'postOnly', 'triggerPrice', 'stopPrice', 'stopLossPrice', 'takeProfitPrice' ));
            $response = Async\await($this->v1GatewayPostExecute ($this->extend($request, $params)));
            //
            // {
            //     "status" => "success",
            //     "signature" => {signature},
            //     "data" => array(
            //       "digest" => array($order digest)
            //     ),
            //     "request_type" => "execute_cancel_and_place"
            // }
            //
            $data = $this->safe_dict($response, 'data', array());
            return $this->safe_order(array(
                'id' => $this->safe_string($data, 'digest'),
            ));
        }) ();
    }

    public function parse_order_status($status) {
        if ($status !== null) {
            $statuses = array(
                'pending' => 'open',
            );
            if (gettype($status) === 'string') {
                return $this->safe_string($statuses, $status, $status);
            }
            $statusCancelled = $this->safe_dict($status, 'cancelled');
            if ($statusCancelled !== null) {
                return 'canceled';
            }
            $statusTriggered = $this->safe_dict($status, 'triggered', array());
            $triggeredStatus = $this->safe_string($statusTriggered, 'status', 'failure');
            if ($triggeredStatus === 'success') {
                return 'closed';
            }
            return 'canceled';
        }
        return $status;
    }

    public function parse_order($order, ?array $market = null): array {
        //
        // {
        //     "product_id" => 1,
        //     "sender" => "0x7a5ec2748e9065794491a8d29dcf3f9edb8d7c43000000000000000000000000",
        //     "price_x18" => "1000000000000000000",
        //     "amount" => "1000000000000000000",
        //     "expiration" => "2000000000",
        //     "nonce" => "1",
        //     "unfilled_amount" => "1000000000000000000",
        //     "digest" => "0x0000000000000000000000000000000000000000000000000000000000000000",
        //     "placed_at" => 1681951347,
        //     "order_type" => "ioc"
        // }
        // stop $order
        // {
        //     "order" => array(
        //       "order" => array(
        //         "sender" => "0x7a5ec2748e9065794491a8d29dcf3f9edb8d7c43000000000000000000000000",
        //         "priceX18" => "1000000000000000000",
        //         "amount" => "1000000000000000000",
        //         "expiration" => "2000000000",
        //         "nonce" => "1",
        //       ),
        //       "signature" => "0x...",
        //       "product_id" => 1,
        //       "spot_leverage" => true,
        //       "trigger" => array(
        //         "price_above" => "1000000000000000000"
        //       ),
        //       "digest" => "0x..."
        //     ),
        //     "status" => "pending",
        //     "updated_at" => 1688768157050
        // }
        //
        $marketId = $this->safe_string($order, 'product_id');
        $timestamp = $this->safe_timestamp($order, 'placed_at');
        $amount = $this->safe_string($order, 'amount');
        $price = $this->safe_string($order, 'price_x18');
        $remaining = $this->safe_string($order, 'unfilled_amount');
        $triggerPriceNum = null;
        $status = $this->safe_value($order, 'status');
        if ($status !== null) {
            // $trigger $order
            $outerOrder = $this->safe_dict($order, 'order', array());
            $innerOrder = $this->safe_dict($outerOrder, 'order', array());
            $marketId = $this->safe_string($outerOrder, 'product_id');
            $amount = $this->safe_string($innerOrder, 'amount');
            $price = $this->safe_string($innerOrder, 'priceX18');
            $timestamp = $this->safe_timestamp($order, 'updated_at');
            $trigger = $this->safe_dict($outerOrder, 'trigger', array());
            $triggerPrice = $this->safe_string_n($trigger, array( 'price_above', 'price_below', 'last_price_above', 'last_price_below' ));
            if ($triggerPrice !== null) {
                $triggerPriceNum = $this->parse_to_numeric($this->convert_from_x18($triggerPrice));
            }
        }
        $market = $this->safe_market($marketId, $market);
        $symbol = $market['symbol'];
        $priceNum = null;
        if ($price !== null) {
            $priceNum = $this->parse_to_numeric($this->convert_from_x18($price));
        }
        $amountNum = null;
        if ($amount !== null) {
            $amountNum = $this->parse_to_numeric($this->convert_from_x18($amount));
        }
        $remainingNum = null;
        if ($remaining !== null) {
            $remainingNum = $this->parse_to_numeric($this->convert_from_x18($remaining));
        }
        $side = null;
        if ($amountNum !== null && $remainingNum !== null) {
            $side = ($amountNum < 0 || $remainingNum < 0) ? 'sell' : 'buy';
        }
        $tif = $this->parse_time_in_force($this->safe_string($order, 'order_type'));
        $isPostOnly = ($tif === 'PO');
        return $this->safe_order(array(
            'info' => $order,
            'id' => $this->safe_string($order, 'digest'),
            'clientOrderId' => null,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'lastTradeTimestamp' => null,
            'lastUpdateTimestamp' => null,
            'symbol' => $symbol,
            'type' => null,
            'timeInForce' => $tif,
            'postOnly' => $isPostOnly,
            'reduceOnly' => null,
            'side' => $side,
            'price' => $priceNum,
            'triggerPrice' => $triggerPriceNum,
            'amount' => $amountNum,
            'cost' => null,
            'average' => null,
            'filled' => null,
            'remaining' => $remainingNum,
            'status' => $this->parse_order_status($status),
            'fee' => null,
            'trades' => null,
        ), $market);
    }

    public function parse_time_in_force($timeInForce) {
        $timeInForces = array(
            'POST_ONLY' => 'PO',
        );
        return $this->safe_string_upper($timeInForces, $timeInForce, $timeInForce);
    }

    public function fetch_order(string $id, ?string $symbol = null, $params = array ()) {
        return Async\async(function () use ($id, $symbol, $params) {
            /**
             * fetches information on an order made by the user
             *
             * @see https://docs.vertexprotocol.com/developer-resources/api/gateway/queries/order
             *
             * @param {string} $id the order $id
             * @param {string} $symbol unified $symbol of the $market the order was made in
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} An ~@link https://docs.ccxt.com/#/?$id=order-structure order structure~
             */
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $request = array(
                'type' => 'order',
                'product_id' => $this->parse_to_int($market['id']),
                'digest' => $id,
            );
            $response = Async\await($this->v1GatewayGetQuery ($this->extend($request, $params)));
            //
            // {
            //     "status" => "success",
            //     "data" => array(
            //       "product_id" => 1,
            //       "sender" => "0x7a5ec2748e9065794491a8d29dcf3f9edb8d7c43000000000000000000000000",
            //       "price_x18" => "1000000000000000000",
            //       "amount" => "1000000000000000000",
            //       "expiration" => "2000000000",
            //       "nonce" => "1",
            //       "unfilled_amount" => "1000000000000000000",
            //       "digest" => "0x0000000000000000000000000000000000000000000000000000000000000000",
            //       "placed_at" => 1681951347,
            //       "order_type" => "ioc"
            //     ),
            //     "request_type" => "query_order",
            // }
            //
            $data = $this->safe_dict($response, 'data');
            return $this->parse_order($data, $market);
        }) ();
    }

    public function fetch_open_orders(?string $symbol = null, ?int $since = null, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            /**
             * fetch all unfilled currently open $orders
             *
             * @see https://docs.vertexprotocol.com/developer-resources/api/gateway/queries/orders
             * @see https://docs.vertexprotocol.com/developer-resources/api/trigger/queries/list-$trigger-$orders
             *
             * @param {string} $symbol unified $market $symbol
             * @param {int} [$since] the earliest time in ms to fetch open $orders for
             * @param {int} [$limit] the maximum number of open $orders structures to retrieve
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @param {boolean} [$params->trigger] whether the order is a trigger/algo order
             * @param {string} [$params->user] user address, will default to $this->walletAddress if not provided
             * @return {Order[]} a list of ~@link https://docs.ccxt.com/#/?id=order-structure order structures~
             */
            $this->check_required_credentials();
            Async\await($this->load_markets());
            $userAddress = null;
            list($userAddress, $params) = $this->handle_public_address('fetchOpenOrders', $params);
            $request = array();
            $market = null;
            $trigger = $this->safe_bool_2($params, 'stop', 'trigger');
            $params = $this->omit($params, array( 'stop', 'trigger' ));
            if ($symbol !== null) {
                $market = $this->market($symbol);
                $request['product_id'] = $this->parse_to_numeric($market['id']);
            }
            $response = null;
            if ($trigger) {
                $contracts = Async\await($this->query_contracts());
                $chainId = $this->safe_string($contracts, 'chain_id');
                $verifyingContractAddress = $this->safe_string($contracts, 'endpoint_addr');
                $tx = array(
                    'sender' => $this->convert_address_to_sender($userAddress),
                    'recvTime' => $this->nonce() + 90000,
                );
                $request['signature'] = $this->build_list_trigger_tx_sig($tx, $chainId, $verifyingContractAddress);
                $request['tx'] = array(
                    'sender' => $tx['sender'],
                    'recvTime' => $this->number_to_string($tx['recvTime']),
                );
                $request['type'] = 'list_trigger_orders';
                $request['pending'] = true;
                $until = $this->safe_integer($params, 'until');
                $params = $this->omit($params, 'until');
                if ($until !== null) {
                    $request['max_update_time'] = $until;
                }
                if ($limit !== null) {
                    $request['limit'] = $limit;
                }
                $response = Async\await($this->v1TriggerPostQuery ($this->extend($request, $params)));
                //
                // {
                //     "status" => "success",
                //     "data" => {
                //       "orders" => array(
                //         array(
                //           "order" => array(
                //             "order" => array(
                //               "sender" => "0x7a5ec2748e9065794491a8d29dcf3f9edb8d7c43000000000000000000000000",
                //               "priceX18" => "1000000000000000000",
                //               "amount" => "1000000000000000000",
                //               "expiration" => "2000000000",
                //               "nonce" => "1",
                //             ),
                //             "signature" => "0x...",
                //             "product_id" => 1,
                //             "spot_leverage" => true,
                //             "trigger" => array(
                //               "price_above" => "1000000000000000000"
                //             ),
                //             "digest" => "0x..."
                //           ),
                //           "status" => "pending",
                //           "updated_at" => 1688768157050
                //         }
                //       )
                //     ),
                //     "request_type" => "query_list_trigger_orders"
                // }
                //
            } else {
                $this->check_required_argument('fetchOpenOrders', $symbol, 'symbol');
                $request['type'] = 'subaccount_orders';
                $request['sender'] = $this->convert_address_to_sender($userAddress);
                $response = Async\await($this->v1GatewayPostQuery ($this->extend($request, $params)));
                //
                // {
                //     "status" => "success",
                //     "data" => {
                //       "sender" => "0x7a5ec2748e9065794491a8d29dcf3f9edb8d7c43000000000000000000000000",
                //       "product_id" => 1,
                //       "orders" => array(
                //         array(
                //           "product_id" => 2,
                //           "sender" => "0x7a5ec2748e9065794491a8d29dcf3f9edb8d7c43000000000000000000000000",
                //           "price_x18" => "1000000000000000000",
                //           "amount" => "1000000000000000000",
                //           "expiration" => "2000000000",
                //           "nonce" => "1",
                //           "order_type" => "default",
                //           "unfilled_amount" => "1000000000000000000",
                //           "digest" => "0x0000000000000000000000000000000000000000000000000000000000000000",
                //           "placed_at" => 1682437737,
                //           "order_type" => "ioc"
                //         }
                //       )
                //     ),
                //     "request_type" => "query_subaccount_orders"
                // }
                //
            }
            $data = $this->safe_dict($response, 'data', array());
            $orders = $this->safe_list($data, 'orders');
            return $this->parse_orders($orders, $market, $since, $limit);
        }) ();
    }

    public function fetch_orders(?string $symbol = null, ?int $since = null, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            /**
             * fetches information on multiple $orders made by the user
             *
             * @see https://docs.vertexprotocol.com/developer-resources/api/trigger/queries/list-$trigger-$orders
             *
             * @param {string} $symbol unified $market $symbol
             * @param {int} [$since] the earliest time in ms to fetch open $orders for
             * @param {int} [$limit] the maximum number of open $orders structures to retrieve
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @param {boolean} [$params->trigger] whether the order is a trigger/algo order
             * @param {string} [$params->user] user address, will default to $this->walletAddress if not provided
             * @return {Order[]} a list of ~@link https://docs.ccxt.com/#/?id=order-structure order structures~
             */
            $this->check_required_credentials();
            $trigger = $this->safe_bool_2($params, 'stop', 'trigger');
            $params = $this->omit($params, array( 'stop', 'trigger' ));
            if (!$trigger) {
                throw new NotSupported($this->id . ' fetchOrders only support $trigger orders');
            }
            $userAddress = null;
            list($userAddress, $params) = $this->handle_public_address('fetchOrders', $params);
            Async\await($this->load_markets());
            $market = null;
            $request = array(
                'type' => 'list_trigger_orders',
                'pending' => false,
            );
            if ($symbol !== null) {
                $market = $this->market($symbol);
                $request['product_id'] = $this->parse_to_numeric($market['id']);
            }
            $contracts = Async\await($this->query_contracts());
            $chainId = $this->safe_string($contracts, 'chain_id');
            $verifyingContractAddress = $this->safe_string($contracts, 'endpoint_addr');
            $tx = array(
                'sender' => $this->convert_address_to_sender($userAddress),
                'recvTime' => $this->nonce() + 90000,
            );
            $request['signature'] = $this->build_list_trigger_tx_sig($tx, $chainId, $verifyingContractAddress);
            $request['tx'] = array(
                'sender' => $tx['sender'],
                'recvTime' => $this->number_to_string($tx['recvTime']),
            );
            $until = $this->safe_integer($params, 'until');
            $params = $this->omit($params, 'until');
            if ($until !== null) {
                $request['max_update_time'] = $until;
            }
            if ($limit !== null) {
                $request['limit'] = $limit;
            }
            $response = Async\await($this->v1TriggerPostQuery ($this->extend($request, $params)));
            //
            // {
            //     "status" => "success",
            //     "data" => {
            //       "orders" => array(
            //         array(
            //           "order" => array(
            //             "order" => array(
            //               "sender" => "0x7a5ec2748e9065794491a8d29dcf3f9edb8d7c43000000000000000000000000",
            //               "priceX18" => "1000000000000000000",
            //               "amount" => "1000000000000000000",
            //               "expiration" => "2000000000",
            //               "nonce" => "1",
            //             ),
            //             "signature" => "0x...",
            //             "product_id" => 1,
            //             "spot_leverage" => true,
            //             "trigger" => array(
            //               "price_above" => "1000000000000000000"
            //             ),
            //             "digest" => "0x..."
            //           ),
            //           "status" => "pending",
            //           "updated_at" => 1688768157050
            //         }
            //       )
            //     ),
            //     "request_type" => "query_list_trigger_orders"
            // }
            //
            $data = $this->safe_dict($response, 'data', array());
            $orders = $this->safe_list($data, 'orders');
            return $this->parse_orders($orders, $market, $since, $limit);
        }) ();
    }

    public function cancel_all_orders(?string $symbol = null, $params = array ()) {
        return Async\async(function () use ($symbol, $params) {
            /**
             *
             * @see https://docs.vertexprotocol.com/developer-resources/api/gateway/executes/cancel-product-orders
             * @see https://docs.vertexprotocol.com/developer-resources/api/trigger/executes/cancel-product-orders
             *
             * cancel all open orders in a $market
             * @param {string} $symbol unified $market $symbol
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @param {boolean} [$params->trigger] whether the order is a trigger/algo order
             * @return {array} an list of ~@link https://docs.ccxt.com/#/?id=order-structure order structures~
             */
            $this->check_required_credentials();
            Async\await($this->load_markets());
            if ($symbol === null) {
                throw new ArgumentsRequired($this->id . ' cancelAllOrders() requires a $symbol argument');
            }
            $market = $this->market($symbol);
            $marketId = $market['id'];
            $contracts = Async\await($this->query_contracts());
            $chainId = $this->safe_string($contracts, 'chain_id');
            $verifyingContractAddress = $this->safe_string($contracts, 'endpoint_addr');
            $now = $this->nonce();
            $nonce = $this->get_nonce($now, 90000);
            $cancels = array(
                'sender' => $this->convert_address_to_sender($this->walletAddress),
                'productIds' => array(
                    $this->parse_to_numeric($marketId),
                ),
                'nonce' => $nonce,
            );
            $request = array(
                'cancel_product_orders' => array(
                    'tx' => array(
                        'sender' => $cancels['sender'],
                        'productIds' => $cancels['productIds'],
                        'nonce' => $this->number_to_string($cancels['nonce']),
                    ),
                    'signature' => $this->build_cancel_all_orders_sig($cancels, $chainId, $verifyingContractAddress),
                ),
            );
            $trigger = $this->safe_bool_2($params, 'stop', 'trigger');
            $params = $this->omit($params, array( 'stop', 'trigger' ));
            $response = null;
            if ($trigger) {
                $response = Async\await($this->v1TriggerPostExecute ($this->extend($request, $params)));
                //
                // {
                //     "status" => "success",
                //     "signature" => {signature},
                //     "request_type" => "execute_cancel_product_orders"
                // }
                //
            } else {
                $response = Async\await($this->v1GatewayPostExecute ($this->extend($request, $params)));
                //
                // {
                //     "status" => "success",
                //     "signature" => {signature},
                //     "data" => array(
                //       "cancelled_orders" => array(
                //         array(
                //           "product_id" => 2,
                //           "sender" => "0x7a5ec2748e9065794491a8d29dcf3f9edb8d7c43746573743000000000000000",
                //           "price_x18" => "20000000000000000000000",
                //           "amount" => "-100000000000000000",
                //           "expiration" => "1686332748",
                //           "order_type" => "post_only",
                //           "nonce" => "1768248100142339392",
                //           "unfilled_amount" => "-100000000000000000",
                //           "digest" => "0x3195a7929feb8307edecf9c045j5ced68925108f0aa305f0ee5773854159377c",
                //           "placed_at" => 1686332708
                //         ),
                //         ...
                //       )
                //     ),
                //     "request_type" => "execute_cancel_product_orders"
                // }
                //
            }
            return $response;
        }) ();
    }

    public function cancel_order(string $id, ?string $symbol = null, $params = array ()) {
        return Async\async(function () use ($id, $symbol, $params) {
            /**
             * cancels an open order
             *
             * @see https://docs.vertexprotocol.com/developer-resources/api/gateway/executes/cancel-orders
             * @see https://docs.vertexprotocol.com/developer-resources/api/trigger/executes/cancel-orders
             *
             * @param {string} $id order $id
             * @param {string} $symbol unified $symbol of the market the order was made in
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} An ~@link https://docs.ccxt.com/#/?$id=order-structure order structure~
             */
            return Async\await($this->cancel_orders(array( $id ), $symbol, $params));
        }) ();
    }

    public function cancel_orders(array $ids, ?string $symbol = null, $params = array ()) {
        return Async\async(function () use ($ids, $symbol, $params) {
            /**
             * cancel multiple orders
             *
             * @see https://docs.vertexprotocol.com/developer-resources/api/gateway/executes/cancel-orders
             * @see https://docs.vertexprotocol.com/developer-resources/api/trigger/executes/cancel-orders
             *
             * @param {string[]} $ids order $ids
             * @param {string} [$symbol] unified $market $symbol
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} an list of ~@link https://docs.ccxt.com/#/?id=order-structure order structures~
             */
            $this->check_required_credentials();
            if ($symbol === null) {
                throw new ArgumentsRequired($this->id . ' cancelOrders() requires a $symbol argument');
            }
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $marketId = $market['id'];
            $contracts = Async\await($this->query_contracts());
            $chainId = $this->safe_string($contracts, 'chain_id');
            $verifyingContractAddress = $this->safe_string($contracts, 'endpoint_addr');
            $now = $this->nonce();
            $nonce = $this->get_nonce($now, 90000);
            $cancels = array(
                'sender' => $this->convert_address_to_sender($this->walletAddress),
                'productIds' => array(),
                'digests' => $ids,
                'nonce' => $nonce,
            );
            $productIds = $cancels['productIds'];
            $marketIdNum = $this->parse_to_numeric($marketId);
            for ($i = 0; $i < count($ids); $i++) {
                $productIds[] = $marketIdNum;
            }
            $request = array(
                'cancel_orders' => array(
                    'tx' => array(
                        'sender' => $cancels['sender'],
                        'productIds' => $productIds,
                        'digests' => $cancels['digests'],
                        'nonce' => $this->number_to_string($cancels['nonce']),
                    ),
                    'signature' => $this->build_cancel_orders_sig($cancels, $chainId, $verifyingContractAddress),
                ),
            );
            $trigger = $this->safe_bool_2($params, 'stop', 'trigger');
            $params = $this->omit($params, array( 'stop', 'trigger' ));
            $response = null;
            if ($trigger) {
                $response = Async\await($this->v1TriggerPostExecute ($this->extend($request, $params)));
                //
                // {
                //     "status" => "success",
                //     "signature" => {signature},
                //     "request_type" => "execute_cancel_orders"
                // }
                //
            } else {
                $response = Async\await($this->v1GatewayPostExecute ($this->extend($request, $params)));
                //
                // {
                //     "status" => "success",
                //     "signature" => {signature},
                //     "data" => array(
                //       "cancelled_orders" => array(
                //         array(
                //           "product_id" => 2,
                //           "sender" => "0x7a5ec2748e9065794491a8d29dcf3f9edb8d7c43746573743000000000000000",
                //           "price_x18" => "20000000000000000000000",
                //           "amount" => "-100000000000000000",
                //           "expiration" => "1686332748",
                //           "order_type" => "post_only",
                //           "nonce" => "1768248100142339392",
                //           "unfilled_amount" => "-100000000000000000",
                //           "digest" => "0x3195a7929feb8307edecf9c045j5ced68925108f0aa305f0ee5773854159377c",
                //           "placed_at" => 1686332708
                //         ),
                //         ...
                //       )
                //     ),
                //     "request_type" => "execute_cancel_orders"
                // }
                //
            }
            return $response;
        }) ();
    }

    public function fetch_balance($params = array ()): PromiseInterface {
        return Async\async(function () use ($params) {
            /**
             * query for $balance and get the amount of funds available for trading or funds locked in orders
             *
             * @see https://docs.vertexprotocol.com/developer-resources/api/gateway/queries/subaccount-info
             *
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @param {string} [$params->user] user address, will default to $this->walletAddress if not provided
             * @return {array} a ~@link https://docs.ccxt.com/#/?id=$balance-structure $balance structure~
             */
            $userAddress = null;
            list($userAddress, $params) = $this->handle_public_address('fetchBalance', $params);
            $request = array(
                'type' => 'subaccount_info',
                'subaccount' => $this->convert_address_to_sender($userAddress),
            );
            $response = Async\await($this->v1GatewayGetQuery ($this->extend($request, $params)));
            //
            // {
            //     "status" => "success",
            //     "data" => {
            //       "subaccount" => "0x265167ddfac55365d6ff07fc5943276319aa6b9f64656661756c740000000000",
            //       "exists" => true,
            //       "healths" => array(
            //         array(
            //           "assets" => "75323297691833342306",
            //           "liabilities" => "46329556869051092241",
            //           "health" => "28993740822782250065"
            //         ),
            //         array(
            //           "assets" => "75323297691833342306",
            //           "liabilities" => "35968911700887320741",
            //           "health" => "39354385990946021565"
            //         ),
            //         {
            //           "assets" => "80796966663601107565",
            //           "liabilities" => "0",
            //           "health" => "80796966663601107565"
            //         }
            //       ),
            //       "health_contributions" => array(
            //         array(
            //           "75323297691833340000",
            //           "75323297691833340000",
            //           "75323297691833340000"
            //         ),
            //         array(
            //           "0",
            //           "0",
            //           "0"
            //         ),
            //         array(
            //           "0",
            //           "0",
            //           "0"
            //         ),
            //         array(
            //           "0",
            //           "0",
            //           "0"
            //         ),
            //         array(
            //           "-46329556869051090000",
            //           "-35968911700887323000",
            //           "5473668971767765000"
            //         )
            //       ),
            //       "spot_count" => 3,
            //       "perp_count" => 2,
            //       "spot_balances" => array(
            //         {
            //           "product_id" => 1,
            //           "lp_balance" => array(
            //             "amount" => "0"
            //           ),
            //           "balance" => array(
            //             "amount" => "0",
            //             "last_cumulative_multiplier_x18" => "1003419811982007193"
            //           }
            //         ),
            //         {
            //           "product_id" => 3,
            //           "lp_balance" => array(
            //             "amount" => "0"
            //           ),
            //           "balance" => array(
            //             "amount" => "0",
            //             "last_cumulative_multiplier_x18" => "1007584195035969404"
            //           }
            //         ),
            //         {
            //           "product_id" => 0,
            //           "lp_balance" => array(
            //             "amount" => "0"
            //           ),
            //           "balance" => {
            //             "amount" => "75323297691833342306",
            //             "last_cumulative_multiplier_x18" => "1000000002391497578"
            //           }
            //         }
            //       ),
            //       "perp_balances" => array(
            //         {
            //           "product_id" => 2,
            //           "lp_balance" => array(
            //             "amount" => "0",
            //             "last_cumulative_funding_x18" => "-284321955122859921"
            //           ),
            //           "balance" => array(
            //             "amount" => "0",
            //             "v_quote_balance" => "0",
            //             "last_cumulative_funding_x18" => "6363466629611946777168"
            //           }
            //         ),
            //         {
            //           "product_id" => 4,
            //           "lp_balance" => array(
            //             "amount" => "0",
            //             "last_cumulative_funding_x18" => "-90979748449893411"
            //           ),
            //           "balance" => {
            //             "amount" => "-200000000000000000",
            //             "v_quote_balance" => "419899475698318625259",
            //             "last_cumulative_funding_x18" => "141182516563970577208"
            //           }
            //         }
            //       ),
            //       "spot_products" => array(
            //         {
            //           "product_id" => 1,
            //           "oracle_price_x18" => "30217830336443750750000",
            //           "risk" => array(
            //             "long_weight_initial_x18" => "750000000000000000",
            //             "short_weight_initial_x18" => "1250000000000000000",
            //             "long_weight_maintenance_x18" => "800000000000000000",
            //             "short_weight_maintenance_x18" => "1200000000000000000",
            //             "large_position_penalty_x18" => "0"
            //           ),
            //           "config" => array(
            //             "token" => "0x5cc7c91690b2cbaee19a513473d73403e13fb431",
            //             "interest_inflection_util_x18" => "800000000000000000",
            //             "interest_floor_x18" => "10000000000000000",
            //             "interest_small_cap_x18" => "40000000000000000",
            //             "interest_large_cap_x18" => "1000000000000000000"
            //           ),
            //           "state" => array(
            //             "cumulative_deposits_multiplier_x18" => "1001304691727847318",
            //             "cumulative_borrows_multiplier_x18" => "1003419811982007193",
            //             "total_deposits_normalized" => "213107447159798397806318",
            //             "total_borrows_normalized" => "4907820740150097483532"
            //           ),
            //           "lp_state" => {
            //             "supply" => "1304981417419495030893348",
            //             "quote" => array(
            //               "amount" => "2048495687410669565222259",
            //               "last_cumulative_multiplier_x18" => "1000000002391497578"
            //             ),
            //             "base" => array(
            //               "amount" => "67623029247538886515",
            //               "last_cumulative_multiplier_x18" => "1001304691727847318"
            //             }
            //           ),
            //           "book_info" => array(
            //             "size_increment" => "1000000000000000",
            //             "price_increment_x18" => "1000000000000000000",
            //             "min_size" => "10000000000000000",
            //             "collected_fees" => "8865582805773573662738183",
            //             "lp_spread_x18" => "3000000000000000"
            //           }
            //         ),
            //         {
            //           "product_id" => 3,
            //           "oracle_price_x18" => "2075217009708333333333",
            //           "risk" => array(
            //             "long_weight_initial_x18" => "750000000000000000",
            //             "short_weight_initial_x18" => "1250000000000000000",
            //             "long_weight_maintenance_x18" => "800000000000000000",
            //             "short_weight_maintenance_x18" => "1200000000000000000",
            //             "large_position_penalty_x18" => "0"
            //           ),
            //           "config" => array(
            //             "token" => "0xcc59686e3a32fb104c8ff84dd895676265efb8a6",
            //             "interest_inflection_util_x18" => "800000000000000000",
            //             "interest_floor_x18" => "10000000000000000",
            //             "interest_small_cap_x18" => "40000000000000000",
            //             "interest_large_cap_x18" => "1000000000000000000"
            //           ),
            //           "state" => array(
            //             "cumulative_deposits_multiplier_x18" => "1003722507760089346",
            //             "cumulative_borrows_multiplier_x18" => "1007584195035969404",
            //             "total_deposits_normalized" => "232750303205807326418622",
            //             "total_borrows_normalized" => "110730726549469855171025"
            //           ),
            //           "lp_state" => {
            //             "supply" => "902924999999999999774268",
            //             "quote" => array(
            //               "amount" => "1165328092090344104989049",
            //               "last_cumulative_multiplier_x18" => "1000000002391497578"
            //             ),
            //             "base" => array(
            //               "amount" => "563265647183403990588",
            //               "last_cumulative_multiplier_x18" => "1003722507760089346"
            //             }
            //           ),
            //           "book_info" => array(
            //             "size_increment" => "10000000000000000",
            //             "price_increment_x18" => "100000000000000000",
            //             "min_size" => "100000000000000000",
            //             "collected_fees" => "1801521329724633001446457",
            //             "lp_spread_x18" => "3000000000000000"
            //           }
            //         ),
            //         {
            //           "product_id" => 0,
            //           "oracle_price_x18" => "1000000000000000000",
            //           "risk" => array(
            //             "long_weight_initial_x18" => "1000000000000000000",
            //             "short_weight_initial_x18" => "1000000000000000000",
            //             "long_weight_maintenance_x18" => "1000000000000000000",
            //             "short_weight_maintenance_x18" => "1000000000000000000",
            //             "large_position_penalty_x18" => "0"
            //           ),
            //           "config" => array(
            //             "token" => "0x179522635726710dd7d2035a81d856de4aa7836c",
            //             "interest_inflection_util_x18" => "800000000000000000",
            //             "interest_floor_x18" => "10000000000000000",
            //             "interest_small_cap_x18" => "40000000000000000",
            //             "interest_large_cap_x18" => "1000000000000000000"
            //           ),
            //           "state" => array(
            //             "cumulative_deposits_multiplier_x18" => "1000000002391497578",
            //             "cumulative_borrows_multiplier_x18" => "1001593395547514024",
            //             "total_deposits_normalized" => "60000256267437588885818752247843",
            //             "total_borrows_normalized" => "391445043137305055810336885"
            //           ),
            //           "lp_state" => {
            //             "supply" => "0",
            //             "quote" => array(
            //               "amount" => "0",
            //               "last_cumulative_multiplier_x18" => "0"
            //             ),
            //             "base" => array(
            //               "amount" => "0",
            //               "last_cumulative_multiplier_x18" => "0"
            //             }
            //           ),
            //           "book_info" => {
            //             "size_increment" => "0",
            //             "price_increment_x18" => "0",
            //             "min_size" => "0",
            //             "collected_fees" => "0",
            //             "lp_spread_x18" => "0"
            //           }
            //         }
            //       ),
            //       "perp_products" => array(
            //         {
            //           "product_id" => 2,
            //           "oracle_price_x18" => "30219079716463070000000",
            //           "risk" => array(
            //             "long_weight_initial_x18" => "875000000000000000",
            //             "short_weight_initial_x18" => "1125000000000000000",
            //             "long_weight_maintenance_x18" => "900000000000000000",
            //             "short_weight_maintenance_x18" => "1100000000000000000",
            //             "large_position_penalty_x18" => "0"
            //           ),
            //           "state" => array(
            //             "cumulative_funding_long_x18" => "6363466629611946777168",
            //             "cumulative_funding_short_x18" => "6363466629611946777168",
            //             "available_settle" => "100612314098927536086702448",
            //             "open_interest" => "57975708279961875623240"
            //           ),
            //           "lp_state" => array(
            //             "supply" => "783207415944433511804197",
            //             "last_cumulative_funding_x18" => "6363466629611946777168",
            //             "cumulative_funding_per_lp_x18" => "-284321955122859921",
            //             "base" => "37321000000000000000",
            //             "quote" => "1150991638943862165224593"
            //           ),
            //           "book_info" => array(
            //             "size_increment" => "1000000000000000",
            //             "price_increment_x18" => "1000000000000000000",
            //             "min_size" => "10000000000000000",
            //             "collected_fees" => "7738341933653651206856235",
            //             "lp_spread_x18" => "3000000000000000"
            //           }
            //         ),
            //         {
            //           "product_id" => 4,
            //           "oracle_price_x18" => "2072129033632754300000",
            //           "risk" => array(
            //             "long_weight_initial_x18" => "875000000000000000",
            //             "short_weight_initial_x18" => "1125000000000000000",
            //             "long_weight_maintenance_x18" => "900000000000000000",
            //             "short_weight_maintenance_x18" => "1100000000000000000",
            //             "large_position_penalty_x18" => "0"
            //           ),
            //           "state" => array(
            //             "cumulative_funding_long_x18" => "141182516563970577208",
            //             "cumulative_funding_short_x18" => "141182516563970577208",
            //             "available_settle" => "33807443862986950288685582",
            //             "open_interest" => "316343836992291503987611"
            //           ),
            //           "lp_state" => array(
            //             "supply" => "541756546038144467864559",
            //             "last_cumulative_funding_x18" => "141182516563970577208",
            //             "cumulative_funding_per_lp_x18" => "-90979748449893411",
            //             "base" => "362320000000000000000",
            //             "quote" => "750080187685127907834038"
            //           ),
            //           "book_info" => array(
            //             "size_increment" => "10000000000000000",
            //             "price_increment_x18" => "100000000000000000",
            //             "min_size" => "100000000000000000",
            //             "collected_fees" => "1893278317732551619694831",
            //             "lp_spread_x18" => "3000000000000000"
            //           }
            //         }
            //       )
            //     ),
            //     "request_type" => "query_subaccount_info"
            // }
            //
            $data = $this->safe_dict($response, 'data', array());
            $balances = $this->safe_list($data, 'spot_balances', array());
            $result = array( 'info' => $response );
            for ($i = 0; $i < count($balances); $i++) {
                $balance = $balances[$i];
                $marketId = $this->safe_string($balance, 'product_id');
                $market = $this->safe_market($marketId);
                $isUsdcMarketId = $marketId === '0';
                if ($market['id'] === null && !$isUsdcMarketId) {
                    continue;
                }
                $baseId = ($isUsdcMarketId) ? 'USDC' : $this->safe_string($market, 'baseId');
                $code = $this->safe_currency_code($baseId);
                $account = $this->account();
                $tokenBalance = $this->safe_dict($balance, 'balance', array());
                $total = $this->convert_from_x18($this->safe_string($tokenBalance, 'amount'));
                $account['total'] = $total;
                $result[$code] = $account;
            }
            return $this->safe_balance($result);
        }) ();
    }

    public function parse_position($position, ?array $market = null) {
        //
        // {
        //     "product_id" => 2,
        //     "lp_balance" => array(
        //       "amount" => "0",
        //       "last_cumulative_funding_x18" => "-284321955122859921"
        //     ),
        //     "balance" => array(
        //       "amount" => "0",
        //       "v_quote_balance" => "0",
        //       "last_cumulative_funding_x18" => "6363466629611946777168"
        //     }
        //   ),
        //   {
        //     "product_id" => 4,
        //     "lp_balance" => array(
        //       "amount" => "0",
        //       "last_cumulative_funding_x18" => "-90979748449893411"
        //     ),
        //     "balance" => {
        //       "amount" => "-200000000000000000",
        //       "v_quote_balance" => "419899475698318625259",
        //       "last_cumulative_funding_x18" => "141182516563970577208"
        //     }
        // }
        //
        $marketId = $this->safe_string($position, 'product_id');
        $market = $this->safe_market($marketId);
        $balance = $this->safe_dict($position, 'balance', array());
        $contractSize = $this->convert_from_x18($this->safe_string($balance, 'amount'));
        $side = 'buy';
        if (Precise::string_lt($contractSize, '1')) {
            $side = 'sell';
        }
        return $this->safe_position(array(
            'info' => $position,
            'id' => null,
            'symbol' => $this->safe_string($market, 'symbol'),
            'timestamp' => null,
            'datetime' => null,
            'lastUpdateTimestamp' => null,
            'initialMargin' => null,
            'initialMarginPercentage' => null,
            'maintenanceMargin' => null,
            'maintenanceMarginPercentage' => null,
            'entryPrice' => null,
            'notional' => null,
            'leverage' => null,
            'unrealizedPnl' => null,
            'contracts' => null,
            'contractSize' => $this->parse_to_numeric($contractSize),
            'marginRatio' => null,
            'liquidationPrice' => null,
            'markPrice' => null,
            'lastPrice' => null,
            'collateral' => null,
            'marginMode' => 'cross',
            'marginType' => null,
            'side' => $side,
            'percentage' => null,
            'hedged' => null,
            'stopLossPrice' => null,
            'takeProfitPrice' => null,
        ));
    }

    public function fetch_positions(?array $symbols = null, $params = array ()) {
        return Async\async(function () use ($symbols, $params) {
            /**
             * fetch all open $positions
             *
             * @see https://docs.vertexprotocol.com/developer-resources/api/gateway/queries/subaccount-info
             *
             * @param {string[]} [$symbols] list of unified market $symbols
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @param {string} [$params->user] user address, will default to $this->walletAddress if not provided
             * @return {array[]} a list of ~@link https://docs.ccxt.com/#/?id=$position-structure $position structure~
             */
            $userAddress = null;
            list($userAddress, $params) = $this->handle_public_address('fetchPositions', $params);
            $request = array(
                'type' => 'subaccount_info',
                'subaccount' => $this->convert_address_to_sender($userAddress),
            );
            $response = Async\await($this->v1GatewayGetQuery ($this->extend($request, $params)));
            // the $response is the same
            $data = $this->safe_dict($response, 'data', array());
            $positions = $this->safe_list($data, 'perp_balances', array());
            $symbols = $this->market_symbols($symbols);
            $result = array();
            for ($i = 0; $i < count($positions); $i++) {
                $position = $this->extend($this->parse_position($positions[$i], null), $params);
                if ($position['contractSize'] === 0) {
                    continue;
                }
                $result[] = $position;
            }
            return $this->filter_by_array_positions($result, 'symbol', $symbols, false);
        }) ();
    }

    public function query_nonces() {
        return Async\async(function ()  {
            $request = array(
                'type' => 'nonces',
                'address' => $this->walletAddress,
            );
            $response = Async\await($this->v1GatewayGetQuery ($request));
            //
            // {
            //     "status":"success",
            //     "data":array(
            //       "tx_nonce" => 0,
            //       "order_nonce" => 1753048133299863552
            //     ),
            //     "request_type" => "query_nonces",
            // }
            //
            return $this->safe_dict($response, 'data', array());
        }) ();
    }

    public function withdraw(string $code, float $amount, string $address, $tag = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($code, $amount, $address, $tag, $params) {
            /**
             * make a withdrawal
             *
             * @see https://docs.vertexprotocol.com/developer-resources/api/withdrawing-on-chain
             *
             * @param {string} $code unified $currency $code
             * @param {float} $amount the $amount to $withdraw
             * @param {string} $address the $address to $withdraw to
             * @param {string} $tag
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} a ~@link https://docs.ccxt.com/#/?id=$transaction-structure $transaction structure~
             */
            $this->check_required_credentials();
            Async\await($this->load_markets());
            $currency = $this->currency($code);
            $contracts = Async\await($this->query_contracts());
            $chainId = $this->safe_string($contracts, 'chain_id');
            $verifyingContractAddress = $this->safe_string($contracts, 'endpoint_addr');
            $nonces = Async\await($this->query_nonces());
            $nonce = $this->safe_number($nonces, 'tx_nonce');
            $withdraw = array(
                'sender' => $this->convert_address_to_sender($this->walletAddress),
                'productId' => $this->parse_to_numeric($currency['id']),
                'amount' => (string) $amount,
                'nonce' => $nonce,
            );
            $request = array(
                'withdraw_collateral' => array(
                    'tx' => array(
                        'sender' => $withdraw['sender'],
                        'productId' => $withdraw['productId'],
                        'amount' => $withdraw['amount'],
                        'nonce' => $this->number_to_string($withdraw['nonce']),
                    ),
                    'signature' => $this->build_withdraw_sig($withdraw, $chainId, $verifyingContractAddress),
                ),
            );
            $response = Async\await($this->v1GatewayPostExecute ($this->extend($request, $params)));
            //
            //     {
            //         "status" => "success",
            //         "signature" => {signature},
            //         "request_type" => "execute_withdraw_collateral"
            //     }
            //
            $transaction = $this->parse_transaction($response, $currency);
            return $this->extend($transaction, array(
                'amount' => $amount,
                'address' => $address,
            ));
        }) ();
    }

    public function parse_transaction(array $transaction, ?array $currency = null): array {
        //
        //     {
        //         "status" => "success",
        //         "signature" => {signature},
        //         "request_type" => "execute_withdraw_collateral"
        //     }
        //
        $code = null;
        if ($currency !== null) {
            $code = $currency['code'];
        }
        return array(
            'info' => $transaction,
            'id' => null,
            'txid' => null,
            'timestamp' => null,
            'datetime' => null,
            'addressFrom' => null,
            'address' => null,
            'addressTo' => null,
            'tagFrom' => null,
            'tag' => null,
            'tagTo' => null,
            'type' => 'withdrawal',
            'amount' => null,
            'currency' => $code,
            'status' => $this->parse_transaction_status($this->safe_string($transaction, 'status')),
            'updated' => null,
            'network' => null,
            'comment' => null,
            'internal' => null,
            'fee' => null,
        );
    }

    public function parse_transaction_status(?string $status) {
        $statuses = array(
            'success' => 'ok',
        );
        return $this->safe_string($statuses, $status, $status);
    }

    public function handle_public_address(string $methodName, array $params) {
        $userAux = null;
        list($userAux, $params) = $this->handle_option_and_params($params, $methodName, 'user');
        $user = $userAux;
        list($user, $params) = $this->handle_option_and_params($params, $methodName, 'address', $userAux);
        if (($user !== null) && ($user !== '')) {
            return array( $user, $params );
        }
        if (($this->walletAddress !== null) && ($this->walletAddress !== '')) {
            return array( $this->walletAddress, $params );
        }
        throw new ArgumentsRequired($this->id . ' ' . $methodName . '() requires a $user parameter inside \'params\' or the wallet address set');
    }

    public function handle_errors($code, $reason, $url, $method, $headers, $body, $response, $requestHeaders, $requestBody) {
        if (!$response) {
            return null; // fallback to default error handler
        }
        //
        //
        $status = $this->safe_string($response, 'status', '');
        if ($status === 'failure') {
            $message = $this->safe_string($response, 'error');
            $feedback = $this->id . ' ' . $body;
            $errorCode = $this->safe_string($response, 'error_code');
            $this->throw_exactly_matched_exception($this->exceptions['exact'], $errorCode, $feedback);
            $this->throw_broadly_matched_exception($this->exceptions['broad'], $message, $feedback);
            throw new ExchangeError($feedback);
        }
        return null;
    }

    public function sign($path, $api = 'public', $method = 'GET', $params = array (), $headers = null, $body = null) {
        $version = $this->safe_string($api, 0);
        $type = $this->safe_string($api, 1);
        $url = $this->implode_hostname($this->urls['api'][$version][$type]);
        if ($version !== 'v1' || $type !== 'archive') {
            $url = $url . '/' . $path;
        }
        if ($method === 'POST') {
            $headers = array(
                'Content-Type' => 'application/json',
            );
            $body = $this->json($params);
        } else {
            if ($params) {
                $url .= '?' . $this->urlencode($params);
            }
        }
        if ($path !== 'execute') {
            // required encoding for public methods
            if ($headers !== null) {
                $headers['Accept-Encoding'] = 'gzip';
            } else {
                $headers = array(
                    'Accept-Encoding' => 'gzip',
                );
            }
        }
        return array( 'url' => $url, 'method' => $method, 'body' => $body, 'headers' => $headers );
    }
}
