<?php

namespace ccxt\async;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

use Exception; // a common import
use ccxt\async\abstract\bitfinex as Exchange;
use ccxt\ExchangeError;
use ccxt\ArgumentsRequired;
use ccxt\NotSupported;
use ccxt\Precise;
use React\Async;
use React\Promise\PromiseInterface;

class bitfinex extends Exchange {

    public function describe() {
        return $this->deep_extend(parent::describe(), array(
            'id' => 'bitfinex',
            'name' => 'Bitfinex',
            'countries' => array( 'VG' ),
            'version' => 'v1',
            // cheapest is 90 requests a minute = 1.5 requests per second on average => ( 1000ms / 1.5) = 666.666 ms between requests on average
            'rateLimit' => 666.666,
            'pro' => true,
            // new metainfo interface
            'has' => array(
                'CORS' => null,
                'spot' => true,
                'margin' => null, // has but unimplemented
                'swap' => null, // has but unimplemented
                'future' => null,
                'option' => null,
                'cancelAllOrders' => true,
                'cancelOrder' => true,
                'createDepositAddress' => true,
                'createOrder' => true,
                'editOrder' => true,
                'fetchBalance' => true,
                'fetchClosedOrders' => true,
                'fetchDepositAddress' => true,
                'fetchDeposits' => false,
                'fetchDepositsWithdrawals' => true,
                'fetchDepositWithdrawFee' => 'emulated',
                'fetchDepositWithdrawFees' => true,
                'fetchIndexOHLCV' => false,
                'fetchLeverageTiers' => false,
                'fetchMarginMode' => false,
                'fetchMarkets' => true,
                'fetchMarkOHLCV' => false,
                'fetchMyTrades' => true,
                'fetchOHLCV' => true,
                'fetchOpenOrders' => true,
                'fetchOrder' => true,
                'fetchOrderBook' => true,
                'fetchPositionMode' => false,
                'fetchPositions' => true,
                'fetchPremiumIndexOHLCV' => false,
                'fetchTicker' => true,
                'fetchTickers' => true,
                'fetchTime' => false,
                'fetchTrades' => true,
                'fetchTradingFee' => false,
                'fetchTradingFees' => true,
                'fetchTransactionFees' => true,
                'fetchTransactions' => 'emulated',
                'transfer' => true,
                'withdraw' => true,
            ),
            'timeframes' => array(
                '1m' => '1m',
                '5m' => '5m',
                '15m' => '15m',
                '30m' => '30m',
                '1h' => '1h',
                '3h' => '3h',
                '4h' => '4h',
                '6h' => '6h',
                '12h' => '12h',
                '1d' => '1D',
                '1w' => '7D',
                '2w' => '14D',
                '1M' => '1M',
            ),
            'urls' => array(
                'logo' => 'https://user-images.githubusercontent.com/1294454/27766244-e328a50c-5ed2-11e7-947b-041416579bb3.jpg',
                'api' => array(
                    'v2' => 'https://api-pub.bitfinex.com', // https://github.com/ccxt/ccxt/issues/5109
                    'public' => 'https://api.bitfinex.com',
                    'private' => 'https://api.bitfinex.com',
                ),
                'www' => 'https://www.bitfinex.com',
                'referral' => 'https://www.bitfinex.com/?refcode=P61eYxFL',
                'doc' => array(
                    'https://docs.bitfinex.com/v1/docs',
                    'https://github.com/bitfinexcom/bitfinex-api-node',
                ),
            ),
            'api' => array(
                // v2 symbol ids require a 't' prefix
                // just the public part of it (use bitfinex2 for everything else)
                'v2' => array(
                    'get' => array(
                        'platform/status' => 3, // 30 requests per minute
                        'tickers' => 1, // 90 requests a minute
                        'ticker/{symbol}' => 1,
                        'tickers/hist' => 1,
                        'trades/{symbol}/hist' => 1,
                        'book/{symbol}/{precision}' => 0.375, // 240 requests per minute = 4 requests per second (1000ms / rateLimit) / 4  = 0.37500375
                        'book/{symbol}/P0' => 0.375,
                        'book/{symbol}/P1' => 0.375,
                        'book/{symbol}/P2' => 0.375,
                        'book/{symbol}/P3' => 0.375,
                        'book/{symbol}/R0' => 0.375,
                        'stats1/{key}:{size}:{symbol}:{side}/{section}' => 1, // 90 requests a minute
                        'stats1/{key}:{size}:{symbol}/{section}' => 1,
                        'stats1/{key}:{size}:{symbol}:long/last' => 1,
                        'stats1/{key}:{size}:{symbol}:long/hist' => 1,
                        'stats1/{key}:{size}:{symbol}:short/last' => 1,
                        'stats1/{key}:{size}:{symbol}:short/hist' => 1,
                        'candles/trade:{timeframe}:{symbol}/{section}' => 1, // 90 requests a minute
                        'candles/trade:{timeframe}:{symbol}/last' => 1,
                        'candles/trade:{timeframe}:{symbol}/hist' => 1,
                    ),
                ),
                'public' => array(
                    'get' => array(
                        'book/{symbol}' => 1, // 90 requests a minute
                        // 'candles/{symbol}':0,
                        'lendbook/{currency}' => 6, // 15 requests a minute
                        'lends/{currency}' => 3, // 30 requests a minute
                        'pubticker/{symbol}' => 3, // 30 requests a minute = 0.5 requests per second => (1000ms / rateLimit) / 0.5 = 3.00003
                        'stats/{symbol}' => 6, // 15 requests a minute = 0.25 requests per second => (1000ms / rateLimit ) /0.25 = 6.00006 (endpoint returns red html... or 'unknown symbol')
                        'symbols' => 18, // 5 requests a minute = 0.08333 requests per second => (1000ms / rateLimit) / 0.08333 = 18.0009
                        'symbols_details' => 18, // 5 requests a minute
                        'tickers' => 1, // endpoint not mentioned in v1 docs... but still responds
                        'trades/{symbol}' => 3, // 60 requests a minute = 1 request per second => (1000ms / rateLimit) / 1 = 1.5 ... but only works if set to 3
                    ),
                ),
                'private' => array(
                    'post' => array(
                        'account_fees' => 18,
                        'account_infos' => 6,
                        'balances' => 9.036, // 10 requests a minute = 0.166 requests per second => (1000ms / rateLimit) / 0.166 = 9.036
                        'basket_manage' => 6,
                        'credits' => 6,
                        'deposit/new' => 18,
                        'funding/close' => 6,
                        'history' => 6, // 15 requests a minute
                        'history/movements' => 6,
                        'key_info' => 6,
                        'margin_infos' => 3, // 30 requests a minute
                        'mytrades' => 3,
                        'mytrades_funding' => 6,
                        'offer/cancel' => 6,
                        'offer/new' => 6,
                        'offer/status' => 6,
                        'offers' => 6,
                        'offers/hist' => 90.03, // one request per minute
                        'order/cancel' => 0.2,
                        'order/cancel/all' => 0.2,
                        'order/cancel/multi' => 0.2,
                        'order/cancel/replace' => 0.2,
                        'order/new' => 0.2, // 450 requests a minute = 7.5 request a second => (1000ms / rateLimit) / 7.5 = 0.2000002
                        'order/new/multi' => 0.2,
                        'order/status' => 0.2,
                        'orders' => 0.2,
                        'orders/hist' => 90.03, // one request per minute = 0.1666 => (1000ms /  rateLimit) / 0.01666 = 90.03
                        'position/claim' => 18,
                        'position/close' => 18,
                        'positions' => 18,
                        'summary' => 18,
                        'taken_funds' => 6,
                        'total_taken_funds' => 6,
                        'transfer' => 18,
                        'unused_taken_funds' => 6,
                        'withdraw' => 18,
                    ),
                ),
            ),
            'fees' => array(
                'trading' => array(
                    'feeSide' => 'get',
                    'tierBased' => true,
                    'percentage' => true,
                    'maker' => $this->parse_number('0.001'),
                    'taker' => $this->parse_number('0.002'),
                    'tiers' => array(
                        'taker' => array(
                            array( $this->parse_number('0'), $this->parse_number('0.002') ),
                            array( $this->parse_number('500000'), $this->parse_number('0.002') ),
                            array( $this->parse_number('1000000'), $this->parse_number('0.002') ),
                            array( $this->parse_number('2500000'), $this->parse_number('0.002') ),
                            array( $this->parse_number('5000000'), $this->parse_number('0.002') ),
                            array( $this->parse_number('7500000'), $this->parse_number('0.002') ),
                            array( $this->parse_number('10000000'), $this->parse_number('0.0018') ),
                            array( $this->parse_number('15000000'), $this->parse_number('0.0016') ),
                            array( $this->parse_number('20000000'), $this->parse_number('0.0014') ),
                            array( $this->parse_number('25000000'), $this->parse_number('0.0012') ),
                            array( $this->parse_number('30000000'), $this->parse_number('0.001') ),
                        ),
                        'maker' => array(
                            array( $this->parse_number('0'), $this->parse_number('0.001') ),
                            array( $this->parse_number('500000'), $this->parse_number('0.0008') ),
                            array( $this->parse_number('1000000'), $this->parse_number('0.0006') ),
                            array( $this->parse_number('2500000'), $this->parse_number('0.0004') ),
                            array( $this->parse_number('5000000'), $this->parse_number('0.0002') ),
                            array( $this->parse_number('7500000'), $this->parse_number('0') ),
                            array( $this->parse_number('10000000'), $this->parse_number('0') ),
                            array( $this->parse_number('15000000'), $this->parse_number('0') ),
                            array( $this->parse_number('20000000'), $this->parse_number('0') ),
                            array( $this->parse_number('25000000'), $this->parse_number('0') ),
                            array( $this->parse_number('30000000'), $this->parse_number('0') ),
                        ),
                    ),
                ),
                'funding' => array(
                    'tierBased' => false, // true for tier-based/progressive
                    'percentage' => false, // fixed commission
                    // Actually deposit fees are free for larger deposits (> $1000 USD equivalent)
                    // these values below are deprecated, we should not hardcode fees and limits anymore
                    // to be reimplemented with bitfinex funding fees from their API or web endpoints
                    'deposit' => array(),
                    'withdraw' => array(),
                ),
            ),
            // todo rewrite for https://api-pub.bitfinex.com//v2/conf/pub:map:tx:method
            'commonCurrencies' => array(
                'ALG' => 'ALGO', // https://github.com/ccxt/ccxt/issues/6034
                'AMP' => 'AMPL',
                'ATO' => 'ATOM', // https://github.com/ccxt/ccxt/issues/5118
                'BCHABC' => 'XEC',
                'BCHN' => 'BCH',
                'DAT' => 'DATA',
                'DOG' => 'MDOGE',
                'DSH' => 'DASH',
                // https://github.com/ccxt/ccxt/issues/7399
                // https://coinmarketcap.com/currencies/pnetwork/
                // https://en.cryptonomist.ch/blog/eidoo/the-edo-to-pnt-upgrade-what-you-need-to-know-updated/
                'EDO' => 'PNT',
                'EUS' => 'EURS',
                'EUT' => 'EURT',
                'IDX' => 'ID',
                'IOT' => 'IOTA',
                'IQX' => 'IQ',
                'LUNA' => 'LUNC',
                'LUNA2' => 'LUNA',
                'MNA' => 'MANA',
                'ORS' => 'ORS Group', // conflict with Origin Sport #3230
                'PAS' => 'PASS',
                'QSH' => 'QASH',
                'QTM' => 'QTUM',
                'RBT' => 'RBTC',
                'SNG' => 'SNGLS',
                'STJ' => 'STORJ',
                'TERRAUST' => 'USTC',
                'TSD' => 'TUSD',
                'YGG' => 'YEED', // conflict with Yield Guild Games
                'YYW' => 'YOYOW',
                'UDC' => 'USDC',
                'UST' => 'USDT',
                'VSY' => 'VSYS',
                'WAX' => 'WAXP',
                'XCH' => 'XCHF',
                'ZBT' => 'ZB',
            ),
            'exceptions' => array(
                'exact' => array(
                    'temporarily_unavailable' => '\\ccxt\\ExchangeNotAvailable', // Sorry, the service is temporarily unavailable. See https://www.bitfinex.com/ for more info.
                    'Order could not be cancelled.' => '\\ccxt\\OrderNotFound', // non-existent order
                    'No such order found.' => '\\ccxt\\OrderNotFound', // ?
                    'Order price must be positive.' => '\\ccxt\\InvalidOrder', // on price <= 0
                    'Could not find a key matching the given X-BFX-APIKEY.' => '\\ccxt\\AuthenticationError',
                    'Key price should be a decimal number, e.g. "123.456"' => '\\ccxt\\InvalidOrder', // on isNaN (price)
                    'Key amount should be a decimal number, e.g. "123.456"' => '\\ccxt\\InvalidOrder', // on isNaN (amount)
                    'ERR_RATE_LIMIT' => '\\ccxt\\RateLimitExceeded',
                    'Ratelimit' => '\\ccxt\\RateLimitExceeded',
                    'Nonce is too small.' => '\\ccxt\\InvalidNonce',
                    'No summary found.' => '\\ccxt\\ExchangeError', // fetchTradingFees (summary) endpoint can give this vague error message
                    'Cannot evaluate your available balance, please try again' => '\\ccxt\\ExchangeNotAvailable',
                    'Unknown symbol' => '\\ccxt\\BadSymbol',
                    'Cannot complete transfer. Exchange balance insufficient.' => '\\ccxt\\InsufficientFunds',
                    'Momentary balance check. Please wait few seconds and try the transfer again.' => '\\ccxt\\ExchangeError',
                ),
                'broad' => array(
                    'Invalid X-BFX-SIGNATURE' => '\\ccxt\\AuthenticationError',
                    'This API key does not have permission' => '\\ccxt\\PermissionDenied', // authenticated but not authorized
                    'not enough exchange balance for ' => '\\ccxt\\InsufficientFunds', // when buying cost is greater than the available quote currency
                    'minimum size for ' => '\\ccxt\\InvalidOrder', // when amount below limits.amount.min
                    'Invalid order' => '\\ccxt\\InvalidOrder', // ?
                    'The available balance is only' => '\\ccxt\\InsufficientFunds', // array("status":"error","message":"Cannot withdraw 1.0027 ETH from your exchange wallet. The available balance is only 0.0 ETH. If you have limit orders, open positions, unused or active margin funding, this will decrease your available balance. To increase it, you can cancel limit orders or reduce/close your positions.","withdrawal_id":0,"fees":"0.0027")
                ),
            ),
            'precisionMode' => SIGNIFICANT_DIGITS,
            'options' => array(
                'currencyNames' => array(
                    'AGI' => 'agi',
                    'AID' => 'aid',
                    'AIO' => 'aio',
                    'ANT' => 'ant',
                    'AVT' => 'aventus', // #1811
                    'BAT' => 'bat',
                    // https://github.com/ccxt/ccxt/issues/5833
                    'BCH' => 'bab', // undocumented
                    // 'BCH' => 'bcash', // undocumented
                    'BCI' => 'bci',
                    'BFT' => 'bft',
                    'BSV' => 'bsv',
                    'BTC' => 'bitcoin',
                    'BTG' => 'bgold',
                    'CFI' => 'cfi',
                    'COMP' => 'comp',
                    'DAI' => 'dai',
                    'DADI' => 'dad',
                    'DASH' => 'dash',
                    'DATA' => 'datacoin',
                    'DTH' => 'dth',
                    'EDO' => 'eidoo', // #1811
                    'ELF' => 'elf',
                    'EOS' => 'eos',
                    'ETC' => 'ethereumc',
                    'ETH' => 'ethereum',
                    'ETP' => 'metaverse',
                    'FUN' => 'fun',
                    'GNT' => 'golem',
                    'IOST' => 'ios',
                    'IOTA' => 'iota',
                    // https://github.com/ccxt/ccxt/issues/5833
                    'LEO' => 'let', // ETH chain
                    // 'LEO' => 'les', // EOS chain
                    'LINK' => 'link',
                    'LRC' => 'lrc',
                    'LTC' => 'litecoin',
                    'LYM' => 'lym',
                    'MANA' => 'mna',
                    'MIT' => 'mit',
                    'MKR' => 'mkr',
                    'MTN' => 'mtn',
                    'NEO' => 'neo',
                    'ODE' => 'ode',
                    'OMG' => 'omisego',
                    'OMNI' => 'mastercoin',
                    'QASH' => 'qash',
                    'QTUM' => 'qtum', // #1811
                    'RCN' => 'rcn',
                    'RDN' => 'rdn',
                    'REP' => 'rep',
                    'REQ' => 'req',
                    'RLC' => 'rlc',
                    'SAN' => 'santiment',
                    'SNGLS' => 'sng',
                    'SNT' => 'status',
                    'SPANK' => 'spk',
                    'STORJ' => 'stj',
                    'TNB' => 'tnb',
                    'TRX' => 'trx',
                    'TUSD' => 'tsd',
                    'USD' => 'wire',
                    'USDC' => 'udc', // https://github.com/ccxt/ccxt/issues/5833
                    'UTK' => 'utk',
                    'USDT' => 'tetheruso', // Tether on Omni
                    // 'USDT' => 'tetheruse', // Tether on ERC20
                    // 'USDT' => 'tetherusl', // Tether on Liquid
                    // 'USDT' => 'tetherusx', // Tether on Tron
                    // 'USDT' => 'tetheruss', // Tether on EOS
                    'VEE' => 'vee',
                    'WAX' => 'wax',
                    'XLM' => 'xlm',
                    'XMR' => 'monero',
                    'XRP' => 'ripple',
                    'XVG' => 'xvg',
                    'YOYOW' => 'yoyow',
                    'ZEC' => 'zcash',
                    'ZRX' => 'zrx',
                    'XTZ' => 'xtz',
                ),
                'orderTypes' => array(
                    'limit' => 'exchange limit',
                    'market' => 'exchange market',
                ),
                'fiat' => array(
                    'USD' => 'USD',
                    'EUR' => 'EUR',
                    'JPY' => 'JPY',
                    'GBP' => 'GBP',
                    'CNH' => 'CNH',
                ),
                'accountsByType' => array(
                    'spot' => 'exchange',
                    'margin' => 'trading',
                    'funding' => 'deposit',
                    'swap' => 'trading',
                ),
            ),
        ));
    }

    public function fetch_transaction_fees($codes = null, $params = array ()) {
        return Async\async(function () use ($codes, $params) {
            /**
             * @deprecated
             * please use fetchDepositWithdrawFees instead
             * @see https://docs.bitfinex.com/v1/reference/rest-auth-$fees
             * @param {string[]|null} $codes list of unified currency $codes
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array[]} a list of ~@link https://docs.ccxt.com/#/?$id=fee-structure $fees structures~
             */
            Async\await($this->load_markets());
            $result = array();
            $response = Async\await($this->privatePostAccountFees ($params));
            //
            // {
            //     "withdraw" => {
            //         "BTC" => "0.0004",
            //     }
            // }
            //
            $fees = $this->safe_value($response, 'withdraw');
            $ids = is_array($fees) ? array_keys($fees) : array();
            for ($i = 0; $i < count($ids); $i++) {
                $id = $ids[$i];
                $code = $this->safe_currency_code($id);
                if (($codes !== null) && !$this->in_array($code, $codes)) {
                    continue;
                }
                $result[$code] = array(
                    'withdraw' => $this->safe_number($fees, $id),
                    'deposit' => array(),
                    'info' => $this->safe_number($fees, $id),
                );
            }
            return $result;
        }) ();
    }

    public function fetch_deposit_withdraw_fees(?array $codes = null, $params = array ()) {
        return Async\async(function () use ($codes, $params) {
            /**
             * fetch deposit and $withdraw fees
             * @see https://docs.bitfinex.com/v1/reference/rest-auth-fees
             * @param {string[]|null} $codes list of unified currency $codes
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array[]} a list of ~@link https://docs.ccxt.com/#/?id=fee-structure fees structures~
             */
            Async\await($this->load_markets());
            $response = Async\await($this->privatePostAccountFees ($params));
            //
            //    {
            //        "withdraw" => {
            //            "BTC" => "0.0004",
            //            ...
            //        }
            //    }
            //
            $withdraw = $this->safe_value($response, 'withdraw');
            return $this->parse_deposit_withdraw_fees($withdraw, $codes);
        }) ();
    }

    public function parse_deposit_withdraw_fee($fee, ?array $currency = null) {
        //
        //    '0.0004'
        //
        return array(
            'withdraw' => array(
                'fee' => $this->parse_number($fee),
                'percentage' => null,
            ),
            'deposit' => array(
                'fee' => null,
                'percentage' => null,
            ),
            'networks' => array(),
            'info' => $fee,
        );
    }

    public function fetch_trading_fees($params = array ()) {
        return Async\async(function () use ($params) {
            /**
             * fetch the trading fees for multiple markets
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} a dictionary of ~@link https://docs.ccxt.com/#/?id=$fee-structure $fee structures~ indexed by $market symbols
             */
            Async\await($this->load_markets());
            $response = Async\await($this->privatePostSummary ($params));
            //
            //     {
            //          "time" => "2022-02-23T16:05:47.659000Z",
            //          "status" => array( resid_hint => null, login_last => "2022-02-23T16:05:48Z" ),
            //          "is_locked" => false,
            //          "leo_lev" => "0",
            //          "leo_amount_avg" => "0.0",
            //          "trade_vol_30d" => array(
            //          {
            //              "curr" => "Total (USD)",
            //              "vol" => "0.0",
            //              "vol_safe" => "0.0",
            //              "vol_maker" => "0.0",
            //              "vol_BFX" => "0.0",
            //              "vol_BFX_safe" => "0.0",
            //              "vol_BFX_maker" => "0.0"
            //          }
            //          ),
            //          "fees_funding_30d" => array(),
            //          "fees_funding_total_30d" => "0",
            //          "fees_trading_30d" => array(),
            //          "fees_trading_total_30d" => "0",
            //          "rebates_trading_30d" => array(),
            //          "rebates_trading_total_30d" => "0",
            //          "maker_fee" => "0.001",
            //          "taker_fee" => "0.002",
            //          "maker_fee_2crypto" => "0.001",
            //          "maker_fee_2stablecoin" => "0.001",
            //          "maker_fee_2fiat" => "0.001",
            //          "maker_fee_2deriv" => "0.0002",
            //          "taker_fee_2crypto" => "0.002",
            //          "taker_fee_2stablecoin" => "0.002",
            //          "taker_fee_2fiat" => "0.002",
            //          "taker_fee_2deriv" => "0.00065",
            //          "deriv_maker_rebate" => "0.0002",
            //          "deriv_taker_fee" => "0.00065",
            //          "trade_last" => null
            //     }
            //
            $result = array();
            $fiat = $this->safe_value($this->options, 'fiat', array());
            $makerFee = $this->safe_number($response, 'maker_fee');
            $takerFee = $this->safe_number($response, 'taker_fee');
            $makerFee2Fiat = $this->safe_number($response, 'maker_fee_2fiat');
            $takerFee2Fiat = $this->safe_number($response, 'taker_fee_2fiat');
            $makerFee2Deriv = $this->safe_number($response, 'maker_fee_2deriv');
            $takerFee2Deriv = $this->safe_number($response, 'taker_fee_2deriv');
            for ($i = 0; $i < count($this->symbols); $i++) {
                $symbol = $this->symbols[$i];
                $market = $this->market($symbol);
                $fee = array(
                    'info' => $response,
                    'symbol' => $symbol,
                    'percentage' => true,
                    'tierBased' => true,
                );
                if (is_array($fiat) && array_key_exists($market['quote'], $fiat)) {
                    $fee['maker'] = $makerFee2Fiat;
                    $fee['taker'] = $takerFee2Fiat;
                } elseif ($market['contract']) {
                    $fee['maker'] = $makerFee2Deriv;
                    $fee['taker'] = $takerFee2Deriv;
                } else {
                    $fee['maker'] = $makerFee;
                    $fee['taker'] = $takerFee;
                }
                $result[$symbol] = $fee;
            }
            return $result;
        }) ();
    }

    public function fetch_markets($params = array ()) {
        return Async\async(function () use ($params) {
            /**
             * retrieves data on all markets for bitfinex
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array[]} an array of objects representing $market data
             */
            $ids = Async\await($this->publicGetSymbols ());
            //
            //     array( "btcusd", "ltcusd", "ltcbtc" )
            //
            $details = Async\await($this->publicGetSymbolsDetails ());
            //
            //     array(
            //         array(
            //             "pair":"btcusd",
            //             "price_precision":5,
            //             "initial_margin":"10.0",
            //             "minimum_margin":"5.0",
            //             "maximum_order_size":"2000.0",
            //             "minimum_order_size":"0.0002",
            //             "expiration":"NA",
            //             "margin":true
            //         ),
            //     )
            //
            $result = array();
            for ($i = 0; $i < count($details); $i++) {
                $market = $details[$i];
                $id = $this->safe_string($market, 'pair');
                if (!$this->in_array($id, $ids)) {
                    continue;
                }
                $id = strtoupper($id);
                $baseId = null;
                $quoteId = null;
                if (mb_strpos($id, ':') !== false) {
                    $parts = explode(':', $id);
                    $baseId = $parts[0];
                    $quoteId = $parts[1];
                } else {
                    $baseId = mb_substr($id, 0, 3 - 0);
                    $quoteId = mb_substr($id, 3, 6 - 3);
                }
                $base = $this->safe_currency_code($baseId);
                $quote = $this->safe_currency_code($quoteId);
                $symbol = $base . '/' . $quote;
                $type = 'spot';
                if (mb_strpos($id, 'F0') > -1) {
                    $type = 'swap';
                }
                $result[] = array(
                    'id' => $id,
                    'symbol' => $symbol,
                    'base' => $base,
                    'quote' => $quote,
                    'settle' => null,
                    'baseId' => $baseId,
                    'quoteId' => $quoteId,
                    'settleId' => null,
                    'type' => $type,
                    'spot' => ($type === 'spot'),
                    'margin' => $this->safe_value($market, 'margin'),
                    'swap' => ($type === 'swap'),
                    'future' => false,
                    'option' => false,
                    'active' => true,
                    'contract' => ($type === 'swap'),
                    'linear' => null,
                    'inverse' => null,
                    'contractSize' => null,
                    'expiry' => null,
                    'expiryDatetime' => null,
                    'strike' => null,
                    'optionType' => null,
                    'precision' => array(
                        // https://docs.bitfinex.com/docs/introduction#amount-precision
                        // The amount field allows up to 8 decimals.
                        // Anything exceeding this will be rounded to the 8th decimal.
                        'amount' => intval('8'),
                        'price' => $this->safe_integer($market, 'price_precision'),
                    ),
                    'limits' => array(
                        'leverage' => array(
                            'min' => null,
                            'max' => null,
                        ),
                        'amount' => array(
                            'min' => $this->safe_number($market, 'minimum_order_size'),
                            'max' => $this->safe_number($market, 'maximum_order_size'),
                        ),
                        'price' => array(
                            'min' => $this->parse_number('1e-8'),
                            'max' => null,
                        ),
                        'cost' => array(
                            'min' => null,
                            'max' => null,
                        ),
                    ),
                    'created' => null,
                    'info' => $market,
                );
            }
            return $result;
        }) ();
    }

    public function amount_to_precision($symbol, $amount) {
        // https://docs.bitfinex.com/docs/introduction#$amount-precision
        // The $amount field allows up to 8 decimals.
        // Anything exceeding this will be rounded to the 8th decimal.
        $symbol = $this->safe_symbol($symbol);
        return $this->decimal_to_precision($amount, TRUNCATE, $this->markets[$symbol]['precision']['amount'], DECIMAL_PLACES);
    }

    public function price_to_precision($symbol, $price) {
        $symbol = $this->safe_symbol($symbol);
        $price = $this->decimal_to_precision($price, ROUND, $this->markets[$symbol]['precision']['price'], $this->precisionMode);
        // https://docs.bitfinex.com/docs/introduction#$price-precision
        // The precision level of all trading prices is based on significant figures.
        // All pairs on Bitfinex use up to 5 significant digits and up to 8 decimals (e.g. 1.2345, 123.45, 1234.5, 0.00012345).
        // Prices submit with a precision larger than 5 will be cut by the API.
        return $this->decimal_to_precision($price, TRUNCATE, 8, DECIMAL_PLACES);
    }

    public function fetch_balance($params = array ()): PromiseInterface {
        return Async\async(function () use ($params) {
            /**
             * $query for $balance and get the amount of funds available for trading or funds locked in orders
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} a ~@link https://docs.ccxt.com/#/?id=$balance-structure $balance structure~
             */
            Async\await($this->load_markets());
            $accountsByType = $this->safe_value($this->options, 'accountsByType', array());
            $requestedType = $this->safe_string($params, 'type', 'exchange');
            $accountType = $this->safe_string($accountsByType, $requestedType, $requestedType);
            if ($accountType === null) {
                $keys = is_array($accountsByType) ? array_keys($accountsByType) : array();
                throw new ExchangeError($this->id . ' fetchBalance() $type parameter must be one of ' . implode(', ', $keys));
            }
            $query = $this->omit($params, 'type');
            $response = Async\await($this->privatePostBalances ($query));
            //    array( array( $type => "deposit",
            //        "currency" => "btc",
            //        "amount" => "0.00116721",
            //        "available" => "0.00116721" ),
            //      array( $type => "exchange",
            //        "currency" => "ust",
            //        "amount" => "0.0000002",
            //        "available" => "0.0000002" ),
            //      { $type => "trading",
            //        "currency" => "btc",
            //        "amount" => "0.0005",
            //        "available" => "0.0005" } ),
            $result = array( 'info' => $response );
            $isDerivative = $requestedType === 'derivatives';
            for ($i = 0; $i < count($response); $i++) {
                $balance = $response[$i];
                $type = $this->safe_string($balance, 'type');
                $currencyId = $this->safe_string_lower($balance, 'currency', '');
                $start = strlen($currencyId) - 2;
                $isDerivativeCode = mb_substr($currencyId, $start) === 'f0';
                // this will only filter the derivative codes if the $requestedType is 'derivatives'
                $derivativeCondition = (!$isDerivative || $isDerivativeCode);
                if (($accountType === $type) && $derivativeCondition) {
                    $code = $this->safe_currency_code($currencyId);
                    // bitfinex had BCH previously, now it's BAB, but the old
                    // BCH symbol is kept for backward-compatibility
                    // we need a workaround here so that the old BCH $balance
                    // would not override the new BAB $balance (BAB is unified to BCH)
                    // https://github.com/ccxt/ccxt/issues/4989
                    if (!(is_array($result) && array_key_exists($code, $result))) {
                        $account = $this->account();
                        $account['free'] = $this->safe_string($balance, 'available');
                        $account['total'] = $this->safe_string($balance, 'amount');
                        $result[$code] = $account;
                    }
                }
            }
            return $this->safe_balance($result);
        }) ();
    }

    public function transfer(string $code, $amount, $fromAccount, $toAccount, $params = array ()) {
        return Async\async(function () use ($code, $amount, $fromAccount, $toAccount, $params) {
            /**
             * transfer $currency internally between wallets on the same account
             * @param {string} $code unified $currency $code
             * @param {float} $amount amount to transfer
             * @param {string} $fromAccount account to transfer from
             * @param {string} $toAccount account to transfer to
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} a ~@link https://docs.ccxt.com/#/?id=transfer-structure transfer structure~
             */
            // transferring between derivatives wallet and regular wallet is not documented in their API
            // however we support it in CCXT (from just looking at web inspector)
            Async\await($this->load_markets());
            $accountsByType = $this->safe_value($this->options, 'accountsByType', array());
            $fromId = $this->safe_string($accountsByType, $fromAccount, $fromAccount);
            $toId = $this->safe_string($accountsByType, $toAccount, $toAccount);
            $currency = $this->currency($code);
            $fromCurrencyId = $this->convert_derivatives_id($currency['id'], $fromAccount);
            $toCurrencyId = $this->convert_derivatives_id($currency['id'], $toAccount);
            $requestedAmount = $this->currency_to_precision($code, $amount);
            $request = array(
                'amount' => $requestedAmount,
                'currency' => $fromCurrencyId,
                'currency_to' => $toCurrencyId,
                'walletfrom' => $fromId,
                'walletto' => $toId,
            );
            $response = Async\await($this->privatePostTransfer (array_merge($request, $params)));
            //
            //     array(
            //         {
            //             "status" => "success",
            //             "message" => "0.0001 Bitcoin transfered from Margin to Exchange"
            //         }
            //     )
            //
            $result = $this->safe_value($response, 0);
            $message = $this->safe_string($result, 'message');
            if ($message === null) {
                throw new ExchangeError($this->id . ' transfer failed');
            }
            return array_merge($this->parse_transfer($result, $currency), array(
                'fromAccount' => $fromAccount,
                'toAccount' => $toAccount,
                'amount' => $this->parse_number($requestedAmount),
            ));
        }) ();
    }

    public function parse_transfer($transfer, ?array $currency = null) {
        //
        //     {
        //         "status" => "success",
        //         "message" => "0.0001 Bitcoin transfered from Margin to Exchange"
        //     }
        //
        return array(
            'info' => $transfer,
            'id' => null,
            'timestamp' => null,
            'datetime' => null,
            'currency' => $this->safe_currency_code(null, $currency),
            'amount' => null,
            'fromAccount' => null,
            'toAccount' => null,
            'status' => $this->parse_transfer_status($this->safe_string($transfer, 'status')),
        );
    }

    public function parse_transfer_status($status) {
        $statuses = array(
            'SUCCESS' => 'ok',
        );
        return $this->safe_string($statuses, $status, $status);
    }

    public function convert_derivatives_id($currencyId, $type) {
        $start = strlen($currencyId) - 2;
        $isDerivativeCode = mb_substr($currencyId, $start) === 'F0';
        if (($type !== 'derivatives' && $type !== 'trading' && $type !== 'margin') && $isDerivativeCode) {
            $currencyId = mb_substr($currencyId, 0, $start - 0);
        } elseif ($type === 'derivatives' && !$isDerivativeCode) {
            $currencyId = $currencyId . 'F0';
        }
        return $currencyId;
    }

    public function fetch_order_book(string $symbol, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $limit, $params) {
            /**
             * fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
             * @param {string} $symbol unified $symbol of the $market to fetch the order book for
             * @param {int} [$limit] the maximum amount of order book entries to return
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} A dictionary of ~@link https://docs.ccxt.com/#/?id=order-book-structure order book structures~ indexed by $market symbols
             */
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $request = array(
                'symbol' => $market['id'],
            );
            if ($limit !== null) {
                $request['limit_bids'] = $limit;
                $request['limit_asks'] = $limit;
            }
            $response = Async\await($this->publicGetBookSymbol (array_merge($request, $params)));
            return $this->parse_order_book($response, $market['symbol'], null, 'bids', 'asks', 'price', 'amount');
        }) ();
    }

    public function fetch_tickers(?array $symbols = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbols, $params) {
            /**
             * fetches price tickers for multiple markets, statistical information calculated over the past 24 hours for each market
             * @param {string[]|null} $symbols unified $symbols of the markets to fetch the $ticker for, all market tickers are returned if not assigned
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} a dictionary of ~@link https://docs.ccxt.com/#/?id=$ticker-structure $ticker structures~
             */
            Async\await($this->load_markets());
            $symbols = $this->market_symbols($symbols);
            $response = Async\await($this->publicGetTickers ($params));
            $result = array();
            for ($i = 0; $i < count($response); $i++) {
                $ticker = $this->parse_ticker($response[$i]);
                $symbol = $ticker['symbol'];
                $result[$symbol] = $ticker;
            }
            return $this->filter_by_array_tickers($result, 'symbol', $symbols);
        }) ();
    }

    public function fetch_ticker(string $symbol, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $params) {
            /**
             * fetches a price $ticker, a statistical calculation with the information calculated over the past 24 hours for a specific $market
             * @param {string} $symbol unified $symbol of the $market to fetch the $ticker for
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} a ~@link https://docs.ccxt.com/#/?id=$ticker-structure $ticker structure~
             */
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $request = array(
                'symbol' => $market['id'],
            );
            $ticker = Async\await($this->publicGetPubtickerSymbol (array_merge($request, $params)));
            return $this->parse_ticker($ticker, $market);
        }) ();
    }

    public function parse_ticker($ticker, ?array $market = null): array {
        $timestamp = $this->safe_timestamp($ticker, 'timestamp');
        $marketId = $this->safe_string($ticker, 'pair');
        $market = $this->safe_market($marketId, $market);
        $symbol = $market['symbol'];
        $last = $this->safe_string($ticker, 'last_price');
        return $this->safe_ticker(array(
            'symbol' => $symbol,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'high' => $this->safe_string($ticker, 'high'),
            'low' => $this->safe_string($ticker, 'low'),
            'bid' => $this->safe_string($ticker, 'bid'),
            'bidVolume' => null,
            'ask' => $this->safe_string($ticker, 'ask'),
            'askVolume' => null,
            'vwap' => null,
            'open' => null,
            'close' => $last,
            'last' => $last,
            'previousClose' => null,
            'change' => null,
            'percentage' => null,
            'average' => $this->safe_string($ticker, 'mid'),
            'baseVolume' => $this->safe_string($ticker, 'volume'),
            'quoteVolume' => null,
            'info' => $ticker,
        ), $market);
    }

    public function parse_trade($trade, ?array $market = null): array {
        //
        // fetchTrades (public) v1
        //
        //     {
        //          "timestamp":1637258380,
        //          "tid":894452833,
        //          "price":"0.99941",
        //          "amount":"261.38",
        //          "exchange":"bitfinex",
        //          "type":"sell"
        //     }
        //
        // fetchMyTrades (private) v1
        //
        //     {
        //          "price":"0.99941",
        //          "amount":"261.38",
        //          "timestamp":"1637258380.0",
        //          "type":"Sell",
        //          "fee_currency":"UST",
        //          "fee_amount":"-0.52245157",
        //          "tid":894452833,
        //          "order_id":78819731373
        //     }
        //
        //     {
        //         "price":"0.99958",
        //         "amount":"261.90514",
        //         "timestamp":"1637258238.0",
        //         "type":"Buy",
        //         "fee_currency":"UDC",
        //         "fee_amount":"-0.52381028",
        //         "tid":894452800,
        //         "order_id":78819504838
        //     }
        //
        $id = $this->safe_string($trade, 'tid');
        $timestamp = $this->safe_timestamp($trade, 'timestamp');
        $type = null;
        $side = $this->safe_string_lower($trade, 'type');
        $orderId = $this->safe_string($trade, 'order_id');
        $priceString = $this->safe_string($trade, 'price');
        $amountString = $this->safe_string($trade, 'amount');
        $fee = null;
        if (is_array($trade) && array_key_exists('fee_amount', $trade)) {
            $feeCostString = Precise::string_neg($this->safe_string($trade, 'fee_amount'));
            $feeCurrencyId = $this->safe_string($trade, 'fee_currency');
            $feeCurrencyCode = $this->safe_currency_code($feeCurrencyId);
            $fee = array(
                'cost' => $feeCostString,
                'currency' => $feeCurrencyCode,
            );
        }
        return $this->safe_trade(array(
            'id' => $id,
            'info' => $trade,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'symbol' => $market['symbol'],
            'type' => $type,
            'order' => $orderId,
            'side' => $side,
            'takerOrMaker' => null,
            'price' => $priceString,
            'amount' => $amountString,
            'cost' => null,
            'fee' => $fee,
        ), $market);
    }

    public function fetch_trades(string $symbol, ?int $since = null, $limit = 50, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            /**
             * get the list of most recent trades for a particular $symbol
             * @param {string} $symbol unified $symbol of the $market to fetch trades for
             * @param {int} [$since] timestamp in ms of the earliest trade to fetch
             * @param {int} [$limit] the maximum amount of trades to fetch
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {Trade[]} a list of ~@link https://docs.ccxt.com/#/?id=public-trades trade structures~
             */
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $request = array(
                'symbol' => $market['id'],
                'limit_trades' => $limit,
            );
            if ($since !== null) {
                $request['timestamp'] = $this->parse_to_int($since / 1000);
            }
            $response = Async\await($this->publicGetTradesSymbol (array_merge($request, $params)));
            //
            //    array(
            //        array(
            //            "timestamp" => "1694284565",
            //            "tid" => "1415415034",
            //            "price" => "25862.0",
            //            "amount" => "0.00020685",
            //            "exchange" => "bitfinex",
            //            "type" => "buy"
            //        ),
            //    )
            //
            return $this->parse_trades($response, $market, $since, $limit);
        }) ();
    }

    public function fetch_my_trades(?string $symbol = null, ?int $since = null, ?int $limit = null, $params = array ()) {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            /**
             * fetch all trades made by the user
             * @param {string} $symbol unified $market $symbol
             * @param {int} [$since] the earliest time in ms to fetch trades for
             * @param {int} [$limit] the maximum number of trades structures to retrieve
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {Trade[]} a list of ~@link https://docs.ccxt.com/#/?id=trade-structure trade structures~
             */
            if ($symbol === null) {
                throw new ArgumentsRequired($this->id . ' fetchMyTrades() requires a $symbol argument');
            }
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $request = array(
                'symbol' => $market['id'],
            );
            if ($limit !== null) {
                $request['limit_trades'] = $limit;
            }
            if ($since !== null) {
                $request['timestamp'] = $this->parse_to_int($since / 1000);
            }
            $response = Async\await($this->privatePostMytrades (array_merge($request, $params)));
            return $this->parse_trades($response, $market, $since, $limit);
        }) ();
    }

    public function create_order(string $symbol, string $type, string $side, $amount, $price = null, $params = array ()) {
        return Async\async(function () use ($symbol, $type, $side, $amount, $price, $params) {
            /**
             * create a trade order
             * @param {string} $symbol unified $symbol of the $market to create an order in
             * @param {string} $type 'market' or 'limit'
             * @param {string} $side 'buy' or 'sell'
             * @param {float} $amount how much of currency you want to trade in units of base currency
             * @param {float} [$price] the $price at which the order is to be fullfilled, in units of the quote currency, ignored in $market orders
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} an ~@link https://docs.ccxt.com/#/?id=order-structure order structure~
             */
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $postOnly = $this->safe_value($params, 'postOnly', false);
            $type = strtolower($type);
            $params = $this->omit($params, array( 'postOnly' ));
            if ($market['spot']) {
                // although they claim that $type needs to be 'exchange limit' or 'exchange market'
                // in fact that's not the case for swap markets
                $type = $this->safe_string_lower($this->options['orderTypes'], $type, $type);
            }
            $request = array(
                'symbol' => $market['id'],
                'side' => $side,
                'amount' => $this->amount_to_precision($symbol, $amount),
                'type' => $type,
                'ocoorder' => false,
                'buy_price_oco' => 0,
                'sell_price_oco' => 0,
            );
            if (mb_strpos($type, 'market') > -1) {
                $request['price'] = (string) $this->nonce();
            } else {
                $request['price'] = $this->price_to_precision($symbol, $price);
            }
            if ($postOnly) {
                $request['is_postonly'] = true;
            }
            $response = Async\await($this->privatePostOrderNew (array_merge($request, $params)));
            return $this->parse_order($response, $market);
        }) ();
    }

    public function edit_order(string $id, $symbol, $type, $side, $amount = null, $price = null, $params = array ()) {
        return Async\async(function () use ($id, $symbol, $type, $side, $amount, $price, $params) {
            Async\await($this->load_markets());
            $order = array(
                'order_id' => intval($id),
            );
            if ($price !== null) {
                $order['price'] = $this->price_to_precision($symbol, $price);
            }
            if ($amount !== null) {
                $order['amount'] = $this->number_to_string($amount);
            }
            if ($symbol !== null) {
                $order['symbol'] = $this->market_id($symbol);
            }
            if ($side !== null) {
                $order['side'] = $side;
            }
            if ($type !== null) {
                $order['type'] = $this->safe_string($this->options['orderTypes'], $type, $type);
            }
            $response = Async\await($this->privatePostOrderCancelReplace (array_merge($order, $params)));
            return $this->parse_order($response);
        }) ();
    }

    public function cancel_order(string $id, ?string $symbol = null, $params = array ()) {
        return Async\async(function () use ($id, $symbol, $params) {
            /**
             * cancels an open order
             * @param {string} $id order $id
             * @param {string} $symbol not used by bitfinex cancelOrder ()
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} An ~@link https://docs.ccxt.com/#/?$id=order-structure order structure~
             */
            Async\await($this->load_markets());
            $request = array(
                'order_id' => intval($id),
            );
            return Async\await($this->privatePostOrderCancel (array_merge($request, $params)));
        }) ();
    }

    public function cancel_all_orders(?string $symbol = null, $params = array ()) {
        return Async\async(function () use ($symbol, $params) {
            /**
             * cancel all open orders
             * @param {string} $symbol unified market $symbol, only orders in the market of this $symbol are cancelled when $symbol is not null
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} response from exchange
             */
            return Async\await($this->privatePostOrderCancelAll ($params));
        }) ();
    }

    public function parse_order($order, ?array $market = null): array {
        //
        //     {
        //           "id" => 57334010955,
        //           "cid" => 1611584840966,
        //           "cid_date" => null,
        //           "gid" => null,
        //           "symbol" => "ltcbtc",
        //           "exchange" => null,
        //           "price" => "0.0042125",
        //           "avg_execution_price" => "0.0042097",
        //           "side" => "sell",
        //           "type" => "exchange $market",
        //           "timestamp" => "1611584841.0",
        //           "is_live" => false,
        //           "is_cancelled" => false,
        //           "is_hidden" => 0,
        //           "oco_order" => 0,
        //           "was_forced" => false,
        //           "original_amount" => "0.205176",
        //           "remaining_amount" => "0.0",
        //           "executed_amount" => "0.205176",
        //           "src" => "web"
        //     }
        //
        $side = $this->safe_string($order, 'side');
        $open = $this->safe_value($order, 'is_live');
        $canceled = $this->safe_value($order, 'is_cancelled');
        $status = null;
        if ($open) {
            $status = 'open';
        } elseif ($canceled) {
            $status = 'canceled';
        } else {
            $status = 'closed';
        }
        $marketId = $this->safe_string_upper($order, 'symbol');
        $symbol = $this->safe_symbol($marketId, $market);
        $orderType = $this->safe_string($order, 'type', '');
        $exchange = mb_strpos($orderType, 'exchange ') !== false;
        if ($exchange) {
            $parts = explode(' ', $order['type']);
            $orderType = $parts[1];
        }
        $timestamp = $this->safe_timestamp($order, 'timestamp');
        $id = $this->safe_string($order, 'id');
        return $this->safe_order(array(
            'info' => $order,
            'id' => $id,
            'clientOrderId' => null,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'lastTradeTimestamp' => null,
            'symbol' => $symbol,
            'type' => $orderType,
            'timeInForce' => null,
            'postOnly' => null,
            'side' => $side,
            'price' => $this->safe_string($order, 'price'),
            'stopPrice' => null,
            'triggerPrice' => null,
            'average' => $this->safe_string($order, 'avg_execution_price'),
            'amount' => $this->safe_string($order, 'original_amount'),
            'remaining' => $this->safe_string($order, 'remaining_amount'),
            'filled' => $this->safe_string($order, 'executed_amount'),
            'status' => $status,
            'fee' => null,
            'cost' => null,
            'trades' => null,
        ), $market);
    }

    public function fetch_open_orders(?string $symbol = null, ?int $since = null, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            /**
             * fetch all unfilled currently open $orders
             * @param {string} $symbol unified market $symbol
             * @param {int} [$since] the earliest time in ms to fetch open $orders for
             * @param {int} [$limit] the maximum number of  open $orders structures to retrieve
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {Order[]} a list of ~@link https://docs.ccxt.com/#/?id=order-structure order structures~
             */
            Async\await($this->load_markets());
            if ($symbol !== null) {
                if (!(is_array($this->markets) && array_key_exists($symbol, $this->markets))) {
                    throw new ExchangeError($this->id . ' has no $symbol ' . $symbol);
                }
            }
            $response = Async\await($this->privatePostOrders ($params));
            $orders = $this->parse_orders($response, null, $since, $limit);
            if ($symbol !== null) {
                $orders = $this->filter_by($orders, 'symbol', $symbol);
            }
            return $orders;
        }) ();
    }

    public function fetch_closed_orders(?string $symbol = null, ?int $since = null, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            /**
             * fetches information on multiple closed $orders made by the user
             * @param {string} $symbol unified market $symbol of the market $orders were made in
             * @param {int} [$since] the earliest time in ms to fetch $orders for
             * @param {int} [$limit] the maximum number of order structures to retrieve
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {Order[]} a list of ~@link https://docs.ccxt.com/#/?id=order-structure order structures~
             */
            Async\await($this->load_markets());
            $symbol = $this->symbol($symbol);
            $request = array();
            if ($limit !== null) {
                $request['limit'] = $limit;
            }
            $response = Async\await($this->privatePostOrdersHist (array_merge($request, $params)));
            $orders = $this->parse_orders($response, null, $since, $limit);
            if ($symbol !== null) {
                $orders = $this->filter_by($orders, 'symbol', $symbol);
            }
            $orders = $this->filter_by_array($orders, 'status', array( 'closed', 'canceled' ), false);
            return $orders;
        }) ();
    }

    public function fetch_order(string $id, ?string $symbol = null, $params = array ()) {
        return Async\async(function () use ($id, $symbol, $params) {
            /**
             * fetches information on an order made by the user
             * @param {string} $symbol not used by bitfinex fetchOrder
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} An ~@link https://docs.ccxt.com/#/?$id=order-structure order structure~
             */
            Async\await($this->load_markets());
            $request = array(
                'order_id' => intval($id),
            );
            $response = Async\await($this->privatePostOrderStatus (array_merge($request, $params)));
            return $this->parse_order($response);
        }) ();
    }

    public function parse_ohlcv($ohlcv, ?array $market = null): array {
        //
        //     array(
        //         1457539800000,
        //         0.02594,
        //         0.02594,
        //         0.02594,
        //         0.02594,
        //         0.1
        //     )
        //
        return array(
            $this->safe_integer($ohlcv, 0),
            $this->safe_number($ohlcv, 1),
            $this->safe_number($ohlcv, 3),
            $this->safe_number($ohlcv, 4),
            $this->safe_number($ohlcv, 2),
            $this->safe_number($ohlcv, 5),
        );
    }

    public function fetch_ohlcv(string $symbol, $timeframe = '1m', ?int $since = null, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $timeframe, $since, $limit, $params) {
            /**
             * fetches historical candlestick data containing the open, high, low, and close price, and the volume of a $market
             * @param {string} $symbol unified $symbol of the $market to fetch OHLCV data for
             * @param {string} $timeframe the length of time each candle represents
             * @param {int} [$since] timestamp in ms of the earliest candle to fetch
             * @param {int} [$limit] the maximum amount of candles to fetch
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {int[][]} A list of candles ordered, open, high, low, close, volume
             */
            Async\await($this->load_markets());
            if ($limit === null) {
                $limit = 100;
            }
            $market = $this->market($symbol);
            $v2id = 't' . $market['id'];
            $request = array(
                'symbol' => $v2id,
                'timeframe' => $this->safe_string($this->timeframes, $timeframe, $timeframe),
                'sort' => 1,
                'limit' => $limit,
            );
            if ($since !== null) {
                $request['start'] = $since;
            }
            $response = Async\await($this->v2GetCandlesTradeTimeframeSymbolHist (array_merge($request, $params)));
            //
            //     [
            //         [1457539800000,0.02594,0.02594,0.02594,0.02594,0.1],
            //         [1457547300000,0.02577,0.02577,0.02577,0.02577,0.01],
            //         [1457550240000,0.0255,0.0253,0.0255,0.0252,3.2640000000000002],
            //     ]
            //
            return $this->parse_ohlcvs($response, $market, $timeframe, $since, $limit);
        }) ();
    }

    public function get_currency_name($code) {
        // todo rewrite for https://api-pub.bitfinex.com//v2/conf/pub:map:tx:method
        if (is_array($this->options['currencyNames']) && array_key_exists($code, $this->options['currencyNames'])) {
            return $this->options['currencyNames'][$code];
        }
        throw new NotSupported($this->id . ' ' . $code . ' not supported for withdrawal');
    }

    public function create_deposit_address(string $code, $params = array ()) {
        return Async\async(function () use ($code, $params) {
            /**
             * create a currency deposit address
             * @param {string} $code unified currency $code of the currency for the deposit address
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} an ~@link https://docs.ccxt.com/#/?id=address-structure address structure~
             */
            Async\await($this->load_markets());
            $request = array(
                'renew' => 1,
            );
            return Async\await($this->fetch_deposit_address($code, array_merge($request, $params)));
        }) ();
    }

    public function fetch_deposit_address(string $code, $params = array ()) {
        return Async\async(function () use ($code, $params) {
            /**
             * fetch the deposit $address for a currency associated with this account
             * @param {string} $code unified currency $code
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} an ~@link https://docs.ccxt.com/#/?id=$address-structure $address structure~
             */
            Async\await($this->load_markets());
            // todo rewrite for https://api-pub.bitfinex.com//v2/conf/pub:map:tx:method
            $name = $this->get_currency_name($code);
            $request = array(
                'method' => $name,
                'wallet_name' => 'exchange',
                'renew' => 0, // a value of 1 will generate a new $address
            );
            $response = Async\await($this->privatePostDepositNew (array_merge($request, $params)));
            $address = $this->safe_value($response, 'address');
            $tag = null;
            if (is_array($response) && array_key_exists('address_pool', $response)) {
                $tag = $address;
                $address = $response['address_pool'];
            }
            $this->check_address($address);
            return array(
                'currency' => $code,
                'address' => $address,
                'tag' => $tag,
                'network' => null,
                'info' => $response,
            );
        }) ();
    }

    public function fetch_deposits_withdrawals(?string $code = null, ?int $since = null, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($code, $since, $limit, $params) {
            /**
             * fetch history of deposits and withdrawals
             * @param {string} $code unified $currency $code for the $currency of the deposit/withdrawals
             * @param {int} [$since] timestamp in ms of the earliest deposit/withdrawal, default is null
             * @param {int} [$limit] max number of deposit/withdrawals to return, default is null
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} a list of ~@link https://docs.ccxt.com/#/?id=transaction-structure transaction structure~
             */
            Async\await($this->load_markets());
            $currencyId = $this->safe_string($params, 'currency');
            $query = $this->omit($params, 'currency');
            $currency = null;
            if ($currencyId === null) {
                if ($code === null) {
                    throw new ArgumentsRequired($this->id . ' fetchDepositsWithdrawals() requires a $currency `$code` argument or a `$currency` parameter');
                } else {
                    $currency = $this->currency($code);
                    $currencyId = $currency['id'];
                }
            }
            $query['currency'] = $currencyId;
            if ($since !== null) {
                $query['since'] = $this->parse_to_int($since / 1000);
            }
            $response = Async\await($this->privatePostHistoryMovements (array_merge($query, $params)));
            //
            //     array(
            //         {
            //             "id" => 581183,
            //             "txid" =>  123456,
            //             "currency" => "BTC",
            //             "method" => "BITCOIN",
            //             "type" => "WITHDRAWAL",
            //             "amount" => ".01",
            //             "description" => "3QXYWgRGX2BPYBpUDBssGbeWEa5zq6snBZ, offchain transfer ",
            //             "address" => "3QXYWgRGX2BPYBpUDBssGbeWEa5zq6snBZ",
            //             "status" => "COMPLETED",
            //             "timestamp" => "1443833327.0",
            //             "timestamp_created" =>  "1443833327.1",
            //             "fee" =>  0.1,
            //         }
            //     )
            //
            return $this->parse_transactions($response, $currency, $since, $limit);
        }) ();
    }

    public function parse_transaction($transaction, ?array $currency = null): array {
        //
        // crypto
        //
        //     {
        //         "id" => 12042490,
        //         "fee" => "-0.02",
        //         "txid" => "EA5B5A66000B66855865EFF2494D7C8D1921FCBE996482157EBD749F2C85E13D",
        //         "type" => "DEPOSIT",
        //         "amount" => "2099.849999",
        //         "method" => "RIPPLE",
        //         "status" => "COMPLETED",
        //         "address" => "2505189261",
        //         "currency" => "XRP",
        //         "timestamp" => "1551730524.0",
        //         "description" => "EA5B5A66000B66855865EFF2494D7C8D1921FCBE996482157EBD749F2C85E13D",
        //         "timestamp_created" => "1551730523.0"
        //     }
        //
        // fiat
        //
        //     {
        //         "id" => 12725095,
        //         "fee" => "-60.0",
        //         "txid" => null,
        //         "type" => "WITHDRAWAL",
        //         "amount" => "9943.0",
        //         "method" => "WIRE",
        //         "status" => "SENDING",
        //         "address" => null,
        //         "currency" => "EUR",
        //         "timestamp" => "1561802484.0",
        //         "description" => "Name => bob, AccountAddress => some address, Account => someaccountno, Bank => bank address, SWIFT => foo, Country => UK, Details of Payment => withdrawal name, Intermediary Bank Name => , Intermediary Bank Address => , Intermediary Bank City => , Intermediary Bank Country => , Intermediary Bank Account => , Intermediary Bank SWIFT => , Fee => -60.0",
        //         "timestamp_created" => "1561716066.0"
        //     }
        //
        // withdraw
        //
        //     {
        //         "status" => "success",
        //         "message" => "Your withdrawal request has been successfully submitted.",
        //         "withdrawal_id" => 586829
        //     }
        //
        $timestamp = $this->safe_timestamp($transaction, 'timestamp_created');
        $currencyId = $this->safe_string($transaction, 'currency');
        $code = $this->safe_currency_code($currencyId, $currency);
        $feeCost = $this->safe_string($transaction, 'fee');
        if ($feeCost !== null) {
            $feeCost = Precise::string_abs($feeCost);
        }
        return array(
            'info' => $transaction,
            'id' => $this->safe_string_2($transaction, 'id', 'withdrawal_id'),
            'txid' => $this->safe_string($transaction, 'txid'),
            'type' => $this->safe_string_lower($transaction, 'type'), // DEPOSIT or WITHDRAWAL,
            'currency' => $code,
            'network' => null,
            'amount' => $this->safe_number($transaction, 'amount'),
            'status' => $this->parse_transaction_status($this->safe_string($transaction, 'status')),
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'address' => $this->safe_string($transaction, 'address'), // todo => this is actually the tag for XRP transfers (the address is missing)
            'addressFrom' => null,
            'addressTo' => null,
            'tag' => $this->safe_string($transaction, 'description'),
            'tagFrom' => null,
            'tagTo' => null,
            'updated' => $this->safe_timestamp($transaction, 'timestamp'),
            'comment' => null,
            'internal' => null,
            'fee' => array(
                'currency' => $code,
                'cost' => $this->parse_number($feeCost),
                'rate' => null,
            ),
        );
    }

    public function parse_transaction_status($status) {
        $statuses = array(
            'SENDING' => 'pending',
            'CANCELED' => 'canceled',
            'ZEROCONFIRMED' => 'failed', // ZEROCONFIRMED happens e.g. in a double spend attempt (I had one in my movements!)
            'COMPLETED' => 'ok',
        );
        return $this->safe_string($statuses, $status, $status);
    }

    public function withdraw(string $code, $amount, $address, $tag = null, $params = array ()) {
        return Async\async(function () use ($code, $amount, $address, $tag, $params) {
            /**
             * make a withdrawal
             * @param {string} $code unified $currency $code
             * @param {float} $amount the $amount to withdraw
             * @param {string} $address the $address to withdraw to
             * @param {string} $tag
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} a ~@link https://docs.ccxt.com/#/?$id=transaction-structure transaction structure~
             */
            list($tag, $params) = $this->handle_withdraw_tag_and_params($tag, $params);
            $this->check_address($address);
            Async\await($this->load_markets());
            // todo rewrite for https://api-pub.bitfinex.com//v2/conf/pub:map:tx:method
            $name = $this->get_currency_name($code);
            $currency = $this->currency($code);
            $request = array(
                'withdraw_type' => $name,
                'walletselected' => 'exchange',
                'amount' => $this->number_to_string($amount),
                'address' => $address,
            );
            if ($tag !== null) {
                $request['payment_id'] = $tag;
            }
            $responses = Async\await($this->privatePostWithdraw (array_merge($request, $params)));
            //
            //     array(
            //         {
            //             "status":"success",
            //             "message":"Your withdrawal $request has been successfully submitted.",
            //             "withdrawal_id":586829
            //         }
            //     )
            //
            $response = $this->safe_value($responses, 0, array());
            $id = $this->safe_number($response, 'withdrawal_id');
            $message = $this->safe_string($response, 'message');
            $errorMessage = $this->find_broadly_matched_key($this->exceptions['broad'], $message);
            if ($id === 0) {
                if ($errorMessage !== null) {
                    $ExceptionClass = $this->exceptions['broad'][$errorMessage];
                    throw new $ExceptionClass($this->id . ' ' . $message);
                }
                throw new ExchangeError($this->id . ' withdraw returned an $id of zero => ' . $this->json($response));
            }
            return $this->parse_transaction($response, $currency);
        }) ();
    }

    public function fetch_positions(?array $symbols = null, $params = array ()) {
        return Async\async(function () use ($symbols, $params) {
            /**
             * fetch all open positions
             * @param {string[]|null} $symbols list of unified market $symbols
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array[]} a list of ~@link https://docs.ccxt.com/#/?id=position-structure position structure~
             */
            Async\await($this->load_markets());
            $response = Async\await($this->privatePostPositions ($params));
            //
            //     array(
            //         {
            //             "id":943715,
            //             "symbol":"btcusd",
            //             "status":"ACTIVE",
            //             "base":"246.94",
            //             "amount":"1.0",
            //             "timestamp":"1444141857.0",
            //             "swap":"0.0",
            //             "pl":"-2.22042"
            //         }
            //     )
            //
            // todo unify parsePosition/parsePositions
            return $response;
        }) ();
    }

    public function nonce() {
        return $this->milliseconds();
    }

    public function sign($path, $api = 'public', $method = 'GET', $params = array (), $headers = null, $body = null) {
        $request = '/' . $this->implode_params($path, $params);
        if ($api === 'v2') {
            $request = '/' . $api . $request;
        } else {
            $request = '/' . $this->version . $request;
        }
        $query = $this->omit($params, $this->extract_params($path));
        $url = $this->urls['api'][$api] . $request;
        if (($api === 'public') || (mb_strpos($path, '/hist') !== false)) {
            if ($query) {
                $suffix = '?' . $this->urlencode($query);
                $url .= $suffix;
                $request .= $suffix;
            }
        }
        if ($api === 'private') {
            $this->check_required_credentials();
            $nonce = $this->nonce();
            $query = array_merge(array(
                'nonce' => (string) $nonce,
                'request' => $request,
            ), $query);
            $body = $this->json($query);
            $payload = base64_encode($body);
            $secret = $this->encode($this->secret);
            $signature = $this->hmac($this->encode($payload), $secret, 'sha384');
            $headers = array(
                'X-BFX-APIKEY' => $this->apiKey,
                'X-BFX-PAYLOAD' => $payload,
                'X-BFX-SIGNATURE' => $signature,
                'Content-Type' => 'application/json',
            );
        }
        return array( 'url' => $url, 'method' => $method, 'body' => $body, 'headers' => $headers );
    }

    public function handle_errors($code, $reason, $url, $method, $headers, $body, $response, $requestHeaders, $requestBody) {
        if ($response === null) {
            return null;
        }
        $throwError = false;
        if ($code >= 400) {
            if ($body[0] === '{') {
                $throwError = true;
            }
        } else {
            // json $response with error, i.e:
            // [array("status":"error","message":"Momentary balance check. Please wait few seconds and try the transfer again.")]
            $responseObject = $this->safe_value($response, 0, array());
            $status = $this->safe_string($responseObject, 'status', '');
            if ($status === 'error') {
                $throwError = true;
            }
        }
        if ($throwError) {
            $feedback = $this->id . ' ' . $body;
            $message = $this->safe_string_2($response, 'message', 'error');
            $this->throw_exactly_matched_exception($this->exceptions['exact'], $message, $feedback);
            $this->throw_broadly_matched_exception($this->exceptions['broad'], $message, $feedback);
            throw new ExchangeError($feedback); // unknown $message
        }
        return null;
    }
}
