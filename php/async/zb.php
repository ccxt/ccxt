<?php

namespace ccxt\async;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

use Exception; // a common import
use \ccxt\ExchangeError;
use \ccxt\ArgumentsRequired;
use \ccxt\BadRequest;
use \ccxt\BadSymbol;
use \ccxt\InvalidOrder;
use \ccxt\OrderNotFound;
use \ccxt\NotSupported;
use \ccxt\ExchangeNotAvailable;
use \ccxt\Precise;

class zb extends Exchange {

    public function describe() {
        return $this->deep_extend(parent::describe (), array(
            'id' => 'zb',
            'name' => 'ZB',
            'countries' => array( 'CN' ),
            'rateLimit' => 100,
            'version' => 'v1',
            'certified' => true,
            'pro' => true,
            'has' => array(
                'CORS' => null,
                'spot' => true,
                'margin' => null, // has but unimplemented
                'swap' => null, // has but unimplemented
                'future' => null,
                'option' => null,
                'addMargin' => true,
                'cancelAllOrders' => true,
                'cancelOrder' => true,
                'createMarketOrder' => null,
                'createOrder' => true,
                'fetchBalance' => true,
                'fetchClosedOrders' => true,
                'fetchCurrencies' => true,
                'fetchDepositAddress' => true,
                'fetchDepositAddresses' => true,
                'fetchDeposits' => true,
                'fetchFundingRate' => true,
                'fetchFundingRateHistory' => true,
                'fetchFundingRates' => true,
                'fetchMarkets' => true,
                'fetchOHLCV' => true,
                'fetchOpenOrders' => true,
                'fetchOrder' => true,
                'fetchOrderBook' => true,
                'fetchOrders' => true,
                'fetchPosition' => true,
                'fetchPositions' => true,
                'fetchTicker' => true,
                'fetchTickers' => true,
                'fetchTrades' => true,
                'fetchWithdrawals' => true,
                'reduceMargin' => true,
                'setLeverage' => true,
                'withdraw' => true,
            ),
            'timeframes' => array(
                '1m' => '1m',
                '3m' => '3m',
                '5m' => '5m',
                '15m' => '15m',
                '30m' => '30m',
                '1h' => '1h',
                '2h' => '2h',
                '4h' => '4h',
                '6h' => '6h',
                '12h' => '12h',
                '1d' => '1d',
                '3d' => '3d',
                '5d' => '5d',
                '1w' => '1w',
            ),
            'exceptions' => array(
                'ws' => array(
                    // '1000' => '\\ccxt\\ExchangeError', // The call is successful.
                    '1001' => '\\ccxt\\ExchangeError', // General error prompt
                    '1002' => '\\ccxt\\ExchangeError', // Internal Error
                    '1003' => '\\ccxt\\AuthenticationError', // Fail to verify
                    '1004' => '\\ccxt\\AuthenticationError', // The transaction password is locked
                    '1005' => '\\ccxt\\AuthenticationError', // Wrong transaction password, please check it and re-enter。
                    '1006' => '\\ccxt\\PermissionDenied', // Real-name authentication is pending approval or unapproved
                    '1007' => '\\ccxt\\ExchangeError', // Channel does not exist
                    '1009' => '\\ccxt\\OnMaintenance', // This interface is under maintenance
                    '1010' => '\\ccxt\\ExchangeNotAvailable', // Not available now
                    '1012' => '\\ccxt\\PermissionDenied', // Insufficient permissions
                    '1013' => '\\ccxt\\ExchangeError', // Cannot trade, please contact email => support@zb.cn for support.
                    '1014' => '\\ccxt\\ExchangeError', // Cannot sell during the pre-sale period
                    '2001' => '\\ccxt\\InsufficientFunds', // Insufficient CNY account balance
                    '2002' => '\\ccxt\\InsufficientFunds', // Insufficient BTC account balance
                    '2003' => '\\ccxt\\InsufficientFunds', // Insufficient LTC account balance
                    '2005' => '\\ccxt\\InsufficientFunds', // Insufficient ETH account balance
                    '2006' => '\\ccxt\\InsufficientFunds', // ETCInsufficient account balance
                    '2007' => '\\ccxt\\InsufficientFunds', // BTSInsufficient account balance
                    '2008' => '\\ccxt\\InsufficientFunds', // EOSInsufficient account balance
                    '2009' => '\\ccxt\\InsufficientFunds', // BCCInsufficient account balance
                    '3001' => '\\ccxt\\OrderNotFound', // Order not found or is completed
                    '3002' => '\\ccxt\\InvalidOrder', // Invalid amount
                    '3003' => '\\ccxt\\InvalidOrder', // Invalid quantity
                    '3004' => '\\ccxt\\AuthenticationError', // User does not exist
                    '3005' => '\\ccxt\\BadRequest', // Invalid parameter
                    '3006' => '\\ccxt\\PermissionDenied', // Invalid IP or not consistent with the bound IP
                    '3007' => '\\ccxt\\RequestTimeout', // The request time has expired
                    '3008' => '\\ccxt\\ExchangeError', // Transaction not found
                    '3009' => '\\ccxt\\InvalidOrder', // The price exceeds the limit
                    '3010' => '\\ccxt\\PermissionDenied', // It fails to place an order, due to you have set up to prohibit trading of this market.
                    '3011' => '\\ccxt\\InvalidOrder', // The entrusted price is abnormal, please modify it and place order again
                    '3012' => '\\ccxt\\InvalidOrder', // Duplicate custom customerOrderId
                    '4001' => '\\ccxt\\AccountSuspended', // APIThe interface is locked for one hour
                    '4002' => '\\ccxt\\RateLimitExceeded', // Request too frequently
                ),
                'exact' => array(
                    // '1000' => 'Successful operation',
                    '10001' => '\\ccxt\\ExchangeError', // Operation failed
                    '10002' => '\\ccxt\\PermissionDenied', // Operation is forbidden
                    '10003' => '\\ccxt\\BadResponse', // Data existed
                    '10004' => '\\ccxt\\BadResponse', // Date not exist
                    '10005' => '\\ccxt\\PermissionDenied', // Forbidden to access the interface
                    '10006' => '\\ccxt\\BadRequest', // Currency invalid or expired
                    '10007' => '\\ccxt\\ExchangeError', // {0}
                    '10008' => '\\ccxt\\ExchangeError', // Operation failed => {0}
                    '10009' => '\\ccxt\\ExchangeError', // URL error
                    '1001' => '\\ccxt\\ExchangeError', // 'General error message',
                    '10010' => '\\ccxt\\AuthenticationError', // API KEY not exist
                    '10011' => '\\ccxt\\AuthenticationError', // API KEY CLOSED
                    '10012' => '\\ccxt\\AccountSuspended', // User API has been frozen, please contact customer service for processing
                    '10013' => '\\ccxt\\AuthenticationError', // API verification failed
                    '10014' => '\\ccxt\\AuthenticationError', // Invalid signature(1001)
                    '10015' => '\\ccxt\\AuthenticationError', // Invalid signature(1002)
                    '10016' => '\\ccxt\\AuthenticationError', // Invalid ip
                    '10017' => '\\ccxt\\PermissionDenied', // Permission denied
                    '10018' => '\\ccxt\\AccountSuspended', // User has been frozen, please contact customer service
                    '10019' => '\\ccxt\\RequestTimeout', // Request time has expired
                    '1002' => '\\ccxt\\ExchangeError', // 'Internal error',
                    '10020' => '\\ccxt\\BadRequest', // {0}Parameter cannot be empty
                    '10021' => '\\ccxt\\BadRequest', // {0}Invalid parameter
                    '10022' => '\\ccxt\\BadRequest', // Request method error
                    '10023' => '\\ccxt\\RateLimitExceeded', // Request frequency is too fast, exceeding the limit allowed by the interface
                    '10024' => '\\ccxt\\AuthenticationError', // Login failed
                    '10025' => '\\ccxt\\ExchangeError', // Non-personal operation
                    '10026' => '\\ccxt\\NetworkError', // Failed to request interface, please try again
                    '10027' => '\\ccxt\\RequestTimeout', // Timed out, please try again later
                    '10028' => '\\ccxt\\ExchangeNotAvailable', // System busy, please try again later
                    '10029' => '\\ccxt\\DDoSProtection', // Frequent operation, please try again later
                    '1003' => '\\ccxt\\AuthenticationError', // 'Verification does not pass',
                    '10030' => '\\ccxt\\BadRequest', // Currency already exist
                    '10031' => '\\ccxt\\BadRequest', // Currency does not exist
                    '10032' => '\\ccxt\\BadRequest', // Market existed
                    '10033' => '\\ccxt\\BadRequest', // Market not exist
                    '10034' => '\\ccxt\\BadRequest', // Currency error
                    '10035' => '\\ccxt\\BadRequest', // Market not open
                    '10036' => '\\ccxt\\BadRequest', // Ineffective market type
                    '10037' => '\\ccxt\\ArgumentsRequired', // User id cannot be empty
                    '10038' => '\\ccxt\\BadRequest', // Market id cannot be empty
                    '10039' => '\\ccxt\\BadResponse', // Failed to get mark price
                    '1004' => '\\ccxt\\AuthenticationError', // 'Funding security password lock',
                    '10040' => '\\ccxt\\BadResponse', // Failed to obtain the opening margin configuration
                    '10041' => '\\ccxt\\BadResponse', // Failed to obtain maintenance margin allocation
                    '10042' => '\\ccxt\\ExchangeError', // Avg. price error
                    '10043' => '\\ccxt\\ExchangeError', // Abnormal acquisition of liquidation price
                    '10044' => '\\ccxt\\ExchangeError', // Unrealized profit and loss acquisition exception
                    '10045' => '\\ccxt\\ExchangeError', // jdbcData source acquisition failed
                    '10046' => '\\ccxt\\ExchangeError', // Invalid position opening direction
                    '10047' => '\\ccxt\\ExchangeError', // The maximum position allowed by the current leverage multiple has been exceeded
                    '10048' => '\\ccxt\\ExchangeError', // The maximum allowable order quantity has been exceeded
                    '10049' => '\\ccxt\\NetworkError', // Failed to get the latest price
                    '1005' => '\\ccxt\\AuthenticationError', // 'Funds security password is incorrect, please confirm and re-enter.',
                    '1006' => '\\ccxt\\AuthenticationError', // 'Real-name certification pending approval or audit does not pass',
                    '1009' => '\\ccxt\\ExchangeNotAvailable', // 'This interface is under maintenance',
                    '1010' => '\\ccxt\\ExchangeNotAvailable', // Not available now
                    '10100' => '\\ccxt\\OnMaintenance', // Sorry! System maintenance, stop operation
                    '1012' => '\\ccxt\\PermissionDenied', // Insufficient permissions
                    '1013' => '\\ccxt\\ExchangeError', // Cannot trade, please contact email => support@zb.cn for support.
                    '1014' => '\\ccxt\\ExchangeError', // Cannot sell during the pre-sale period
                    '11000' => '\\ccxt\\ExchangeError', // Funding change failed
                    '11001' => '\\ccxt\\ExchangeError', // Position change failed
                    '110011' => '\\ccxt\\ExchangeError', // Exceeds the maximum leverage allowed by the position
                    '11002' => '\\ccxt\\ExchangeError', // Funding not exist
                    '11003' => '\\ccxt\\ExchangeError', // Freeze records not exist
                    '11004' => '\\ccxt\\InsufficientFunds', // Insufficient frozen funds
                    '11005' => '\\ccxt\\InvalidOrder', // Insufficient positions
                    '11006' => '\\ccxt\\InsufficientFunds', // Insufficient frozen positions
                    '11007' => '\\ccxt\\OrderNotFound', // Position not exist
                    '11008' => '\\ccxt\\ExchangeError', // The contract have positions, cannot be modified
                    '11009' => '\\ccxt\\ExchangeError', // Failed to query data
                    '110110' => '\\ccxt\\ExchangeError', // Exceed the market's maximum leverage
                    '11012' => '\\ccxt\\InsufficientFunds', // Insufficient margin
                    '11013' => '\\ccxt\\ExchangeError', // Exceeding accuracy limit
                    '11014' => '\\ccxt\\ExchangeError', // Invalid bill type
                    '11015' => '\\ccxt\\AuthenticationError', // Failed to add default account
                    '11016' => '\\ccxt\\AuthenticationError', // Account not exist
                    '11017' => '\\ccxt\\ExchangeError', // Funds are not frozen or unfrozen
                    '11018' => '\\ccxt\\InsufficientFunds', // Insufficient funds
                    '11019' => '\\ccxt\\ExchangeError', // Bill does not exist
                    '11021' => '\\ccxt\\InsufficientFunds', // Inconsistent currency for funds transfer
                    '11023' => '\\ccxt\\ExchangeError', // Same transaction currency
                    '11030' => '\\ccxt\\PermissionDenied', // Position is locked, the operation is prohibited
                    '11031' => '\\ccxt\\ExchangeError', // The number of bill changes is zero
                    '11032' => '\\ccxt\\ExchangeError', // The same request is being processed, please do not submit it repeatedly
                    '11033' => '\\ccxt\\ArgumentsRequired', // Position configuration data is empty
                    '11034' => '\\ccxt\\ExchangeError', // Funding fee is being settled, please do not operate
                    '12000' => '\\ccxt\\InvalidOrder', // Invalid order price
                    '12001' => '\\ccxt\\InvalidOrder', // Invalid order amount
                    '12002' => '\\ccxt\\InvalidOrder', // Invalid order type
                    '12003' => '\\ccxt\\InvalidOrder', // Invalid price accuracy
                    '12004' => '\\ccxt\\InvalidOrder', // Invalid quantity precision
                    '12005' => '\\ccxt\\InvalidOrder', // order value less than the minimum or greater than the maximum
                    '12006' => '\\ccxt\\InvalidOrder', // Customize's order number format is wrong
                    '12007' => '\\ccxt\\InvalidOrder', // Direction error
                    '12008' => '\\ccxt\\InvalidOrder', // Order type error
                    '12009' => '\\ccxt\\InvalidOrder', // Commission type error
                    '12010' => '\\ccxt\\InvalidOrder', // Failed to place the order, the loss of the order placed at this price will exceed margin
                    '12011' => '\\ccxt\\InvalidOrder', // it's not a buz order
                    '12012' => '\\ccxt\\OrderNotFound', // order not exist
                    '12013' => '\\ccxt\\InvalidOrder', // Order user does not match
                    '12014' => '\\ccxt\\InvalidOrder', // Order is still in transaction
                    '12015' => '\\ccxt\\InvalidOrder', // Order preprocessing failed
                    '12016' => '\\ccxt\\InvalidOrder', // Order cannot be canceled
                    '12017' => '\\ccxt\\InvalidOrder', // Transaction Record not exist
                    '12018' => '\\ccxt\\InvalidOrder', // Order failed
                    '12019' => '\\ccxt\\ArgumentsRequired', // extend parameter cannot be empty
                    '12020' => '\\ccxt\\ExchangeError', // extend Parameter error
                    '12021' => '\\ccxt\\InvalidOrder', // The order price is not within the price limit rules!
                    '12022' => '\\ccxt\\InvalidOrder', // Stop placing an order while the system is calculating the fund fee
                    '12023' => '\\ccxt\\OrderNotFound', // There are no positions to close
                    '12024' => '\\ccxt\\InvalidOrder', // Orders are prohibited, stay tuned!
                    '12025' => '\\ccxt\\InvalidOrder', // Order cancellation is prohibited, so stay tuned!
                    '12026' => '\\ccxt\\DuplicateOrderId', // Order failed， customize order number exists
                    '12027' => '\\ccxt\\ExchangeNotAvailable', // System busy, please try again later
                    '12028' => '\\ccxt\\InvalidOrder', // The market has banned trading
                    '12029' => '\\ccxt\\InvalidOrder', // Forbidden place order, stay tuned
                    '12201' => '\\ccxt\\InvalidOrder', // Delegation strategy does not exist or the status has changed
                    '12202' => '\\ccxt\\InvalidOrder', // Delegation strategy has been changed, cannot be canceled
                    '12203' => '\\ccxt\\InvalidOrder', // Wrong order type
                    '12204' => '\\ccxt\\InvalidOrder', // Invalid trigger price
                    '12205' => '\\ccxt\\InvalidOrder', // The trigger price must be greater than the market’s selling price or lower than the buying price.
                    '12206' => '\\ccxt\\InvalidOrder', // Direction and order type do not match
                    '12207' => '\\ccxt\\RateLimitExceeded', // Submission failed, exceeding the allowed limit
                    '13001' => '\\ccxt\\AuthenticationError', // User not exist
                    '13002' => '\\ccxt\\PermissionDenied', // User did not activate futures
                    // '13003' => '\\ccxt\\AuthenticationError', // User is locked
                    '13003' => '\\ccxt\\InvalidOrder', // Margin gear is not continuous
                    '13004' => '\\ccxt\\InvalidOrder', // The margin quick calculation amount is less than 0
                    '13005' => '\\ccxt\\RateLimitExceeded', // You have exceeded the number of exports that day
                    '13006' => '\\ccxt\\ExchangeError', // No markets are bookmarked
                    '13007' => '\\ccxt\\ExchangeError', // Market not favorited
                    '13008' => '\\ccxt\\ExchangeError', // Not in any market user whitelist
                    '13009' => '\\ccxt\\ExchangeError', // Not in the whitelist of users in this market
                    '14000' => '\\ccxt\\ExchangeError', // {0}not support
                    '14001' => '\\ccxt\\AuthenticationError', // Already logged in, no need to log in multiple times
                    '14002' => '\\ccxt\\AuthenticationError', // Not logged in yet, please log in before subscribing
                    '14003' => '\\ccxt\\ExchangeError', // This is a channel for one-time queries, no need to unsubscribe
                    '14100' => '\\ccxt\\ExchangeError', // Accuracy does not support
                    '14101' => '\\ccxt\\RateLimitExceeded', // Request exceeded frequency limit
                    '14200' => '\\ccxt\\ArgumentsRequired', // id empty
                    '14300' => '\\ccxt\\ExchangeError', // activity not exist
                    '14301' => '\\ccxt\\ExchangeError', // The event has been opened and cannot be admitted
                    '14302' => '\\ccxt\\ExchangeError', // The purchase time has passed and cannot be admitted
                    '14303' => '\\ccxt\\ExchangeError', // Not yet open for the purchase
                    '14305' => '\\ccxt\\ExchangeError', // Cannot enter, the maximum number of returns has been exceeded
                    '14306' => '\\ccxt\\ExchangeError', // Cannot repeat admission
                    '14307' => '\\ccxt\\InvalidOrder', // Unable to cancel, status has been changed
                    '14308' => '\\ccxt\\InvalidOrder', // Unable to cancel, the amount does not match
                    '14309' => '\\ccxt\\ExchangeError', // Activity has not started
                    '14310' => '\\ccxt\\NotSupported', // Activity is over
                    '14311' => '\\ccxt\\NotSupported', // The activity does not support orders placed in this market
                    '14312' => '\\ccxt\\ExchangeError', // You have not participated in this activity
                    '14313' => '\\ccxt\\PermissionDenied', // Sorry! The purchase failed, the maximum number of participants has been reached
                    '14314' => '\\ccxt\\ExchangeError', // Active period id error
                    '2001' => '\\ccxt\\InsufficientFunds', // 'Insufficient CNY Balance',
                    '2002' => '\\ccxt\\InsufficientFunds', // 'Insufficient BTC Balance',
                    '2003' => '\\ccxt\\InsufficientFunds', // 'Insufficient LTC Balance',
                    '2005' => '\\ccxt\\InsufficientFunds', // 'Insufficient ETH Balance',
                    '2006' => '\\ccxt\\InsufficientFunds', // 'Insufficient ETC Balance',
                    '2007' => '\\ccxt\\InsufficientFunds', // 'Insufficient BTS Balance',
                    '2008' => '\\ccxt\\InsufficientFunds', // EOSInsufficient account balance
                    '2009' => '\\ccxt\\InsufficientFunds', // 'Account balance is not enough',
                    '3001' => '\\ccxt\\OrderNotFound', // 'Pending orders not found',
                    '3002' => '\\ccxt\\InvalidOrder', // 'Invalid price',
                    '3003' => '\\ccxt\\InvalidOrder', // 'Invalid amount',
                    '3004' => '\\ccxt\\AuthenticationError', // 'User does not exist',
                    '3005' => '\\ccxt\\BadRequest', // 'Invalid parameter',
                    '3006' => '\\ccxt\\AuthenticationError', // 'Invalid IP or inconsistent with the bound IP',
                    '3007' => '\\ccxt\\AuthenticationError', // 'The request time has expired',
                    '3008' => '\\ccxt\\OrderNotFound', // 'Transaction records not found',
                    '3009' => '\\ccxt\\InvalidOrder', // 'The price exceeds the limit',
                    '3010' => '\\ccxt\\PermissionDenied', // It fails to place an order, due to you have set up to prohibit trading of this market.
                    '3011' => '\\ccxt\\InvalidOrder', // 'The entrusted price is abnormal, please modify it and place order again',
                    '3012' => '\\ccxt\\InvalidOrder', // Duplicate custom customerOrderId
                    '4001' => '\\ccxt\\ExchangeNotAvailable', // 'API interface is locked or not enabled',
                    '4002' => '\\ccxt\\RateLimitExceeded', // 'Request too often',
                    '9999' => '\\ccxt\\ExchangeError', // Unknown error
                ),
                'broad' => array(
                    '提币地址有误, 请先添加提币地址。' => '\\ccxt\\InvalidAddress', // array("code":1001,"message":"提币地址有误，请先添加提币地址。")
                    '资金不足,无法划账' => '\\ccxt\\InsufficientFunds', // array("code":1001,"message":"资金不足,无法划账")
                    '响应超时' => '\\ccxt\\RequestTimeout', // array("code":1001,"message":"响应超时")
                ),
            ),
            'urls' => array(
                'logo' => 'https://user-images.githubusercontent.com/1294454/32859187-cd5214f0-ca5e-11e7-967d-96568e2e2bd1.jpg',
                'api' => array(
                    'spot' => array(
                        'v1' => array(
                            'public' => 'https://api.zb.work/data',
                            'private' => 'https://trade.zb.work/api',
                        ),
                    ),
                    'contract' => array(
                        'v1' => array(
                            'public' => 'https://fapi.zb.com/api/public',
                        ),
                        'v2' => array(
                            'public' => 'https://fapi.zb.com/Server/api',
                            'private' => 'https://fapi.zb.com/Server/api',
                        ),
                    ),
                ),
                'www' => 'https://www.zb.com',
                'doc' => 'https://www.zb.com/i/developer',
                'fees' => 'https://www.zb.com/i/rate',
                'referral' => array(
                    'url' => 'https://www.zbex.club/en/register?ref=4301lera',
                    'discount' => 0.16,
                ),
            ),
            'api' => array(
                'spot' => array(
                    'v1' => array(
                        'public' => array(
                            'get' => array(
                                'markets',
                                'ticker',
                                'allTicker',
                                'depth',
                                'trades',
                                'kline',
                                'getGroupMarkets',
                                'getFeeInfo',
                            ),
                        ),
                        'private' => array(
                            'get' => array(
                                // spot API
                                'order',
                                'orderMoreV2',
                                'cancelOrder',
                                'getOrder',
                                'getOrders',
                                'getOrdersNew',
                                'getOrdersIgnoreTradeType',
                                'getUnfinishedOrdersIgnoreTradeType',
                                'getFinishedAndPartialOrders',
                                'getAccountInfo',
                                'getUserAddress',
                                'getPayinAddress',
                                'getWithdrawAddress',
                                'getWithdrawRecord',
                                'getChargeRecord',
                                'getCnyWithdrawRecord',
                                'getCnyChargeRecord',
                                'withdraw',
                                // sub accounts
                                'addSubUser',
                                'getSubUserList',
                                'doTransferFunds',
                                'createSubUserKey', // removed on 2021-03-16 according to the update log in the API doc
                                // leverage API
                                'getLeverAssetsInfo',
                                'getLeverBills',
                                'transferInLever',
                                'transferOutLever',
                                'loan',
                                'cancelLoan',
                                'getLoans',
                                'getLoanRecords',
                                'borrow',
                                'autoBorrow',
                                'repay',
                                'doAllRepay',
                                'getRepayments',
                                'getFinanceRecords',
                                'changeInvestMark',
                                'changeLoop',
                                // cross API
                                'getCrossAssets',
                                'getCrossBills',
                                'transferInCross',
                                'transferOutCross',
                                'doCrossLoan',
                                'doCrossRepay',
                                'getCrossRepayRecords',
                            ),
                        ),
                    ),
                ),
                'contract' => array(
                    'v1' => array(
                        'public' => array(
                            'get' => array(
                                'depth',
                                'fundingRate',
                                'indexKline',
                                'indexPrice',
                                'kline',
                                'markKline',
                                'markPrice',
                                'ticker',
                                'trade',
                            ),
                        ),
                    ),
                    'v2' => array(
                        'public' => array(
                            'get' => array(
                                'allForceOrders',
                                'config/marketList',
                                'topLongShortAccountRatio',
                                'topLongShortPositionRatio',
                                'fundingRate',
                                'premiumIndex',
                            ),
                        ),
                        'private' => array(
                            'get' => array(
                                'Fund/balance',
                                'Fund/getAccount',
                                'Fund/getBill',
                                'Fund/getBillTypeList',
                                'Fund/marginHistory',
                                'Positions/getPositions',
                                'Positions/getNominalValue',
                                'Positions/marginInfo',
                                'setting/get',
                                'trade/getAllOrders',
                                'trade/getOrder',
                                'trade/getOrderAlgos',
                                'trade/getTradeList',
                                'trade/getUndoneOrders',
                                'trade/tradeHistory',
                            ),
                            'post' => array(
                                'activity/buyTicket',
                                'Fund/transferFund',
                                'Positions/setMarginCoins',
                                'Positions/updateAppendUSDValue',
                                'Positions/updateMargin',
                                'setting/setLeverage',
                                'trade/batchOrder',
                                'trade/batchCancelOrder',
                                'trade/cancelAlgos',
                                'trade/cancelAllOrders',
                                'trade/cancelOrder',
                                'trade/order',
                                'trade/orderAlgo',
                                'trade/updateOrderAlgo',
                            ),
                        ),
                    ),
                ),
            ),
            'fees' => array(
                'funding' => array(
                    'withdraw' => array(),
                ),
                'trading' => array(
                    'maker' => 0.2 / 100,
                    'taker' => 0.2 / 100,
                ),
            ),
            'commonCurrencies' => array(
                'ANG' => 'Anagram',
                'ENT' => 'ENTCash',
                'BCHABC' => 'BCHABC', // conflict with BCH / BCHA
                'BCHSV' => 'BCHSV', // conflict with BCH / BSV
            ),
            'options' => array(
                'timeframes' => array(
                    'spot' => array(
                        '1m' => '1min',
                        '3m' => '3min',
                        '5m' => '5min',
                        '15m' => '15min',
                        '30m' => '30min',
                        '1h' => '1hour',
                        '2h' => '2hour',
                        '4h' => '4hour',
                        '6h' => '6hour',
                        '12h' => '12hour',
                        '1d' => '1day',
                        '3d' => '3day',
                        '1w' => '1week',
                    ),
                    'swap' => array(
                        '1m' => '1M',
                        '5m' => '5M',
                        '15m' => '15M',
                        '30m' => '30M',
                        '1h' => '1H',
                        '6h' => '6H',
                        '1d' => '1D',
                        '5d' => '5D',
                    ),
                ),
            ),
        ));
    }

    public function fetch_markets($params = array ()) {
        $markets = yield $this->spotV1PublicGetMarkets ($params);
        //
        //     {
        //         "zb_qc":array(
        //             "amountScale":2,
        //             "minAmount":0.01,
        //             "minSize":5,
        //             "priceScale":4,
        //         ),
        //     }
        //
        $contracts = yield $this->contractV2PublicGetConfigMarketList ($params);
        //
        //     {
        //         BTC_USDT => array(
        //             $symbol => 'BTC_USDT',
        //             buyerCurrencyId => '6',
        //             contractType => '1',
        //             defaultMarginMode => '1',
        //             marketType => '2',
        //             historyDBName => 'trade_history_readonly.dbc',
        //             defaultLeverage => '20',
        //             $id => '100',
        //             canCancelOrder => true,
        //             area => '1',
        //             mixMarginCoinName => 'usdt',
        //             fundingRateRatio => '0.25',
        //             marginCurrencyName => 'usdt',
        //             minTradeMoney => '0.0001',
        //             enableTime => '1638954000000',
        //             maxTradeMoney => '10000000',
        //             canTrade => true,
        //             maxLeverage => '125',
        //             defaultPositionsMode => '2',
        //             onlyWhitelistVisible => false,
        //             riskWarnRatio => '0.8',
        //             marginDecimal => '8',
        //             $spot => false,
        //             $status => '1',
        //             amountDecimal => '3',
        //             leverage => false,
        //             minAmount => '0.001',
        //             canOrder => true,
        //             duration => '1',
        //             feeDecimal => '8',
        //             sellerCurrencyId => '1',
        //             maxAmount => '1000',
        //             canOpenPosition => true,
        //             isSupportMixMargin => false,
        //             markPriceLimitRate => '0.05',
        //             marginCurrencyId => '6',
        //             stopFundingFee => false,
        //             priceDecimal => '2',
        //             lightenUpFeeRate => '0',
        //             futures => true,
        //             sellerCurrencyName => 'btc',
        //             marketPriceLimitRate => '0.05',
        //             canRebate => true,
        //             marketName => 'BTC_USDT',
        //             depth => array( 0.01, 0.1, 1 ),
        //             createTime => '1607590430094',
        //             mixMarginCoinIds => array( 6 ),
        //             buyerCurrencyName => 'usdt',
        //             stopService => false
        //         ),
        //     }
        //
        $contractsData = $this->safe_value($contracts, 'data', array());
        $contractsById = $this->index_by($contractsData, 'marketName');
        $dataById = $this->deep_extend($contractsById, $markets);
        $keys = is_array($dataById) ? array_keys($dataById) : array();
        $result = array();
        for ($i = 0; $i < count($keys); $i++) {
            $id = $keys[$i];
            $market = $dataById[$id];
            list($baseId, $quoteId) = explode('_', $id);
            $base = $this->safe_currency_code($baseId);
            $quote = $this->safe_currency_code($quoteId);
            $settleId = $this->safe_value($market, 'marginCurrencyName');
            $settle = $this->safe_currency_code($settleId);
            $spot = $settle === null;
            $swap = $this->safe_value($market, 'futures', false);
            $linear = $swap ? true : null;
            $active = true;
            $symbol = $base . '/' . $quote;
            $amountPrecisionString = $this->safe_string_2($market, 'amountScale', 'amountDecimal');
            $pricePrecisionString = $this->safe_string_2($market, 'priceScale', 'priceDecimal');
            if ($swap) {
                $status = $this->safe_string($market, 'status');
                $active = ($status === '1');
                $symbol = $base . '/' . $quote . ':' . $settle;
            }
            $result[] = array(
                'id' => $id,
                'symbol' => $symbol,
                'base' => $base,
                'quote' => $quote,
                'settle' => $settle,
                'baseId' => $baseId,
                'quoteId' => $quoteId,
                'settleId' => $settleId,
                'type' => $swap ? 'swap' : 'spot',
                'spot' => $spot,
                'margin' => false,
                'swap' => $swap,
                'future' => false,
                'option' => false,
                'active' => $active,
                'contract' => $swap,
                'linear' => $linear,
                'inverse' => $swap ? !$linear : null,
                'contractSize' => null,
                'expiry' => null,
                'expiryDatetime' => null,
                'strike' => null,
                'optionType' => null,
                'precision' => array(
                    'amount' => intval($amountPrecisionString),
                    'price' => intval($pricePrecisionString),
                ),
                'limits' => array(
                    'leverage' => array(
                        'min' => null,
                        'max' => $this->safe_number($market, 'maxLeverage'),
                    ),
                    'amount' => array(
                        'min' => $this->safe_number($market, 'minAmount'),
                        'max' => $this->safe_number($market, 'maxAmount'),
                    ),
                    'price' => array(
                        'min' => null,
                        'max' => null,
                    ),
                    'cost' => array(
                        'min' => $this->safe_number_2($market, 'minSize', 'minTradeMoney'),
                        'max' => $this->safe_number($market, 'maxTradeMoney'),
                    ),
                ),
                'info' => $market,
            );
        }
        return $result;
    }

    public function fetch_currencies($params = array ()) {
        $response = yield $this->spotV1PublicGetGetFeeInfo ($params);
        //
        //     {
        //         "code":1000,
        //         "message":"success",
        //         "result":{
        //             "USDT":array(
        //                 array(
        //                     "chainName":"TRC20",
        //                     "canWithdraw":true,
        //                     "fee":1.0,
        //                     "mainChainName":"TRX",
        //                     "canDeposit":true
        //                 ),
        //                 array(
        //                     "chainName":"OMNI",
        //                     "canWithdraw":true,
        //                     "fee":5.0,
        //                     "mainChainName":"BTC",
        //                     "canDeposit":true
        //                 ),
        //                 {
        //                     "chainName":"ERC20",
        //                     "canWithdraw":true,
        //                     "fee":15.0,
        //                     "mainChainName":"ETH",
        //                     "canDeposit":true
        //                 }
        //             ),
        //         }
        //     }
        //
        $currencies = $this->safe_value($response, 'result', array());
        $ids = is_array($currencies) ? array_keys($currencies) : array();
        $result = array();
        for ($i = 0; $i < count($ids); $i++) {
            $id = $ids[$i];
            $currency = $currencies[$id];
            $code = $this->safe_currency_code($id);
            $precision = null;
            $isWithdrawEnabled = true;
            $isDepositEnabled = true;
            $fees = array();
            for ($j = 0; $j < count($currency); $j++) {
                $networkItem = $currency[$j];
                $network = $this->safe_string($networkItem, 'chainName');
                // $name = $this->safe_string($networkItem, 'name');
                $withdrawFee = $this->safe_number($networkItem, 'fee');
                $depositEnable = $this->safe_value($networkItem, 'canDeposit');
                $withdrawEnable = $this->safe_value($networkItem, 'canWithdraw');
                $isDepositEnabled = $isDepositEnabled || $depositEnable;
                $isWithdrawEnabled = $isWithdrawEnabled || $withdrawEnable;
                $fees[$network] = $withdrawFee;
            }
            $active = ($isWithdrawEnabled && $isDepositEnabled);
            $result[$code] = array(
                'id' => $id,
                'name' => null,
                'code' => $code,
                'precision' => $precision,
                'info' => $currency,
                'active' => $active,
                'deposit' => $isDepositEnabled,
                'withdraw' => $isWithdrawEnabled,
                'fee' => null,
                'fees' => $fees,
                'limits' => $this->limits,
            );
        }
        return $result;
    }

    public function parse_balance($response) {
        $balances = $this->safe_value($response['result'], 'coins');
        $result = array(
            'info' => $response,
        );
        for ($i = 0; $i < count($balances); $i++) {
            $balance = $balances[$i];
            //     {        enName => "BTC",
            //               freez => "0.00000000",
            //         unitDecimal =>  8, // always 8
            //              cnName => "BTC",
            //       isCanRecharge =>  true, // TODO => should use this
            //             unitTag => "฿",
            //       isCanWithdraw =>  true,  // TODO => should use this
            //           available => "0.00000000",
            //                 key => "btc"         }
            $account = $this->account();
            $currencyId = $this->safe_string($balance, 'key');
            $code = $this->safe_currency_code($currencyId);
            $account['free'] = $this->safe_string($balance, 'available');
            $account['used'] = $this->safe_string($balance, 'freez');
            $result[$code] = $account;
        }
        return $this->safe_balance($result);
    }

    public function parse_swap_balance($response) {
        $result = array(
            'info' => $response,
        );
        $data = $this->safe_value($response, 'data', array());
        for ($i = 0; $i < count($data); $i++) {
            $balance = $data[$i];
            //
            //     array(
            //         "userId" => "6896693805014120448",
            //         "currencyId" => "6",
            //         "currencyName" => "usdt",
            //         "amount" => "30.56585118",
            //         "freezeAmount" => "0",
            //         "contractType" => 1,
            //         "id" => "6899113714763638819",
            //         "createTime" => "1644876888934",
            //         "modifyTime" => "1645787446037",
            //         "accountBalance" => "30.56585118",
            //         "allMargin" => "0",
            //         "allowTransferOutAmount" => "30.56585118"
            //     ),
            //
            $code = $this->safe_currency_code($this->safe_string($balance, 'currencyName'));
            $account = $this->account();
            $account['total'] = $this->safe_string($balance, 'accountBalance');
            $account['free'] = $this->safe_string($balance, 'allowTransferOutAmount');
            $account['used'] = $this->safe_string($balance, 'freezeAmount');
            $result[$code] = $account;
        }
        return $this->safe_balance($result);
    }

    public function fetch_balance($params = array ()) {
        yield $this->load_markets();
        list($marketType, $query) = $this->handle_market_type_and_params('fetchBalance', null, $params);
        $method = $this->get_supported_mapping($marketType, array(
            'spot' => 'spotV1PrivateGetGetAccountInfo',
            'swap' => 'contractV2PrivateGetFundBalance',
        ));
        $request = array(
            // 'futuresAccountType' => 1, // SWAP
            // 'currencyId' => currency['id'], // SWAP
            // 'currencyName' => 'usdt', // SWAP
        );
        $swap = ($marketType === 'swap');
        if ($swap) {
            $request['futuresAccountType'] = 1;
        }
        $response = yield $this->$method (array_merge($request, $query));
        //
        // Spot
        //
        //     {
        //         "result" => {
        //             "coins" => array(
        //                 array(
        //                     "isCanWithdraw" => "true",
        //                     "canLoan" => false,
        //                     "fundstype" => 51,
        //                     "showName" => "ZB",
        //                     "isCanRecharge" => "true",
        //                     "cnName" => "ZB",
        //                     "enName" => "ZB",
        //                     "available" => "0",
        //                     "freez" => "0",
        //                     "unitTag" => "ZB",
        //                     "key" => "zb",
        //                     "unitDecimal" => 8
        //                 ),
        //             ),
        //             "version" => 1645856691340,
        //             "base" => array(
        //                 "auth_google_enabled" => true,
        //                 "auth_mobile_enabled" => false,
        //                 "trade_password_enabled" => true,
        //                 "username" => "blank@gmail.com"
        //             }
        //         ),
        //         "leverPerm" => true,
        //         "otcPerm" => false,
        //         "assetPerm" => true,
        //         "moneyPerm" => true,
        //         "subUserPerm" => true,
        //         "entrustPerm" => true
        //     }
        //
        // Swap
        //
        //     {
        //         "code" => 10000,
        //         "data" => array(
        //             array(
        //                 "userId" => "6896693805014120448",
        //                 "currencyId" => "6",
        //                 "currencyName" => "usdt",
        //                 "amount" => "30.56585118",
        //                 "freezeAmount" => "0",
        //                 "contractType" => 1,
        //                 "id" => "6899113714763638819",
        //                 "createTime" => "1644876888934",
        //                 "modifyTime" => "1645787446037",
        //                 "accountBalance" => "30.56585118",
        //                 "allMargin" => "0",
        //                 "allowTransferOutAmount" => "30.56585118"
        //             ),
        //         ),
        //         "desc" => "操作成功"
        //     }
        //
        // todo => use this somehow
        // $permissions = $response['result']['base'];
        if ($swap) {
            return $this->parse_swap_balance($response);
        } else {
            return $this->parse_balance($response);
        }
    }

    public function parse_deposit_address($depositAddress, $currency = null) {
        //
        // fetchDepositAddress
        //
        //     {
        //         "key" => "0x0af7f36b8f09410f3df62c81e5846da673d4d9a9"
        //     }
        //
        // fetchDepositAddresses
        //
        //     {
        //         "blockChain" => "btc",
        //         "isUseMemo" => false,
        //         "address" => "1LL5ati6pXHZnTGzHSA3rWdqi4mGGXudwM",
        //         "canWithdraw" => true,
        //         "canDeposit" => true
        //     }
        //     {
        //         "blockChain" => "bts",
        //         "isUseMemo" => true,
        //         "account" => "btstest",
        //         "memo" => "123",
        //         "canWithdraw" => true,
        //         "canDeposit" => true
        //     }
        //
        $address = $this->safe_string_2($depositAddress, 'key', 'address');
        $tag = null;
        $memo = $this->safe_string($depositAddress, 'memo');
        if ($memo !== null) {
            $tag = $memo;
        } else if (mb_strpos($address, '_') !== false) {
            $parts = explode('_', $address);
            $address = $parts[0];  // WARNING => MAY BE tag_address INSTEAD OF address_tag FOR SOME CURRENCIES!!
            $tag = $parts[1];
        }
        $currencyId = $this->safe_string($depositAddress, 'blockChain');
        $code = $this->safe_currency_code($currencyId, $currency);
        return array(
            'currency' => $code,
            'address' => $address,
            'tag' => $tag,
            'network' => null,
            'info' => $depositAddress,
        );
    }

    public function fetch_deposit_addresses($codes = null, $params = array ()) {
        yield $this->load_markets();
        $response = yield $this->spotV1PrivateGetGetPayinAddress ($params);
        //
        //     {
        //         "code" => 1000,
        //         "message" => {
        //             "des" => "success",
        //             "isSuc" => true,
        //             "datas" => array(
        //                 array(
        //                     "blockChain" => "btc",
        //                     "isUseMemo" => false,
        //                     "address" => "1LL5ati6pXHZnTGzHSA3rWdqi4mGGXudwM",
        //                     "canWithdraw" => true,
        //                     "canDeposit" => true
        //                 ),
        //                 array(
        //                     "blockChain" => "bts",
        //                     "isUseMemo" => true,
        //                     "account" => "btstest",
        //                     "memo" => "123",
        //                     "canWithdraw" => true,
        //                     "canDeposit" => true
        //                 ),
        //             )
        //         }
        //     }
        //
        $message = $this->safe_value($response, 'message', array());
        $datas = $this->safe_value($message, 'datas', array());
        return $this->parse_deposit_addresses($datas, $codes);
    }

    public function fetch_deposit_address($code, $params = array ()) {
        yield $this->load_markets();
        $currency = $this->currency($code);
        $request = array(
            'currency' => $currency['id'],
        );
        $response = yield $this->spotV1PrivateGetGetUserAddress (array_merge($request, $params));
        //
        //     {
        //         "code" => 1000,
        //         "message" => {
        //             "des" => "success",
        //             "isSuc" => true,
        //             "datas" => {
        //                 "key" => "0x0af7f36b8f09410f3df62c81e5846da673d4d9a9"
        //             }
        //         }
        //     }
        //
        $message = $this->safe_value($response, 'message', array());
        $datas = $this->safe_value($message, 'datas', array());
        return $this->parse_deposit_address($datas, $currency);
    }

    public function fetch_order_book($symbol, $limit = null, $params = array ()) {
        yield $this->load_markets();
        $market = $this->market($symbol);
        $request = array(
            // 'market' => $market['id'], // only applicable to SPOT
            // 'symbol' => $market['id'], // only applicable to SWAP
            // 'size' => $limit, // 1-50 applicable to SPOT and SWAP
            // 'merge' => 5.0, // float default depth only applicable to SPOT
            // 'scale' => 5, // int accuracy, only applicable to SWAP
        );
        $marketIdField = $market['swap'] ? 'symbol' : 'market';
        $request[$marketIdField] = $market['id'];
        $method = $this->get_supported_mapping($market['type'], array(
            'spot' => 'spotV1PublicGetDepth',
            'swap' => 'contractV1PublicGetDepth',
        ));
        if ($limit !== null) {
            $request['size'] = $limit;
        }
        $response = yield $this->$method (array_merge($request, $params));
        //
        // Spot
        //
        //     {
        //         "asks":[
        //             [35000.0,0.2741],
        //             [34949.0,0.0173],
        //             [34900.0,0.5004],
        //         ],
        //         "bids":[
        //             [34119.32,0.0030],
        //             [34107.83,0.1500],
        //             [34104.42,0.1500],
        //         ],
        //         "timestamp":1624536510
        //     }
        //
        // Swap
        //
        //     {
        //         "code" => 10000,
        //         "desc" => "操作成功",
        //         "data" => {
        //             "asks" => [
        //                 [43416.6,0.02],
        //                 [43418.25,0.04],
        //                 [43425.82,0.02]
        //             ],
        //             "bids" => [
        //                 [43414.61,0.1],
        //                 [43414.18,0.04],
        //                 [43413.03,0.05]
        //             ],
        //             "time" => 1645087743071
        //         }
        //     }
        //
        $result = null;
        $timestamp = null;
        if ($market['type'] === 'swap') {
            $result = $this->safe_value($response, 'data');
            $timestamp = $this->safe_integer($result, 'time');
        } else {
            $result = $response;
            $timestamp = $this->safe_timestamp($response, 'timestamp');
        }
        return $this->parse_order_book($result, $symbol, $timestamp);
    }

    public function fetch_tickers($symbols = null, $params = array ()) {
        yield $this->load_markets();
        $response = yield $this->spotV1PublicGetAllTicker ($params);
        $result = array();
        $marketsByIdWithoutUnderscore = array();
        $marketIds = is_array($this->markets_by_id) ? array_keys($this->markets_by_id) : array();
        for ($i = 0; $i < count($marketIds); $i++) {
            $tickerId = str_replace('_', '', $marketIds[$i]);
            $marketsByIdWithoutUnderscore[$tickerId] = $this->markets_by_id[$marketIds[$i]];
        }
        $ids = is_array($response) ? array_keys($response) : array();
        for ($i = 0; $i < count($ids); $i++) {
            $market = $marketsByIdWithoutUnderscore[$ids[$i]];
            $result[$market['symbol']] = $this->parse_ticker($response[$ids[$i]], $market);
        }
        return $this->filter_by_array($result, 'symbol', $symbols);
    }

    public function fetch_ticker($symbol, $params = array ()) {
        yield $this->load_markets();
        $market = $this->market($symbol);
        $request = array(
            // 'market' => $market['id'], // only applicable to SPOT
            // 'symbol' => $market['id'], // only applicable to SWAP
        );
        $marketIdField = $market['swap'] ? 'symbol' : 'market';
        $request[$marketIdField] = $market['id'];
        $method = $this->get_supported_mapping($market['type'], array(
            'spot' => 'spotV1PublicGetTicker',
            'swap' => 'contractV1PublicGetTicker',
        ));
        $response = yield $this->$method (array_merge($request, $params));
        //
        // Spot
        //
        //     {
        //         "date":"1624399623587",
        //         "ticker":{
        //             "high":"33298.38",
        //             "vol":"56152.9012",
        //             "last":"32578.55",
        //             "low":"28808.19",
        //             "buy":"32572.68",
        //             "sell":"32615.37",
        //             "turnover":"1764201303.6100",
        //             "open":"31664.85",
        //             "riseRate":"2.89"
        //         }
        //     }
        //
        // Swap
        //
        //     {
        //         "code" => 10000,
        //         "desc" => "操作成功",
        //         "data" => {
        //             "BTC_USDT" => [44053.47,44357.77,42911.54,43297.79,53471.264,-1.72,1645093002,302201.255084]
        //         }
        //     }
        //
        $ticker = null;
        if ($market['type'] === 'swap') {
            $ticker = array();
            $data = $this->safe_value($response, 'data');
            $values = $this->safe_value($data, $market['id']);
            for ($i = 0; $i < count($values); $i++) {
                $ticker['open'] = $this->safe_value($values, 0);
                $ticker['high'] = $this->safe_value($values, 1);
                $ticker['low'] = $this->safe_value($values, 2);
                $ticker['last'] = $this->safe_value($values, 3);
                $ticker['vol'] = $this->safe_value($values, 4);
                $ticker['riseRate'] = $this->safe_value($values, 5);
            }
        } else {
            $ticker = $this->safe_value($response, 'ticker', array());
            $ticker['date'] = $this->safe_value($response, 'date');
        }
        return $this->parse_ticker($ticker, $market);
    }

    public function parse_ticker($ticker, $market = null) {
        //
        // Spot
        //
        //     {
        //         "date":"1624399623587", // injected from outside
        //         "high":"33298.38",
        //         "vol":"56152.9012",
        //         "last":"32578.55",
        //         "low":"28808.19",
        //         "buy":"32572.68",
        //         "sell":"32615.37",
        //         "turnover":"1764201303.6100",
        //         "open":"31664.85",
        //         "riseRate":"2.89"
        //     }
        //
        // Swap
        //
        //     {
        //         open => 44083.82,
        //         high => 44357.77,
        //         low => 42911.54,
        //         $last => 43097.87,
        //         vol => 53451.641,
        //         riseRate => -2.24
        //     }
        //
        $timestamp = $this->safe_integer($ticker, 'date', $this->milliseconds());
        $last = $this->safe_string($ticker, 'last');
        return $this->safe_ticker(array(
            'symbol' => $this->safe_symbol(null, $market),
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'high' => $this->safe_string($ticker, 'high'),
            'low' => $this->safe_string($ticker, 'low'),
            'bid' => $this->safe_string($ticker, 'buy'),
            'bidVolume' => null,
            'ask' => $this->safe_string($ticker, 'sell'),
            'askVolume' => null,
            'vwap' => null,
            'open' => $this->safe_string($ticker, 'open'),
            'close' => $last,
            'last' => $last,
            'previousClose' => null,
            'change' => null,
            'percentage' => null,
            'average' => null,
            'baseVolume' => $this->safe_string($ticker, 'vol'),
            'quoteVolume' => null,
            'info' => $ticker,
        ), $market, false);
    }

    public function parse_ohlcv($ohlcv, $market = null) {
        if ($market['swap']) {
            return array(
                $this->safe_integer($ohlcv, 5),
                $this->safe_number($ohlcv, 0),
                $this->safe_number($ohlcv, 1),
                $this->safe_number($ohlcv, 2),
                $this->safe_number($ohlcv, 3),
                $this->safe_number($ohlcv, 4),
            );
        } else {
            return array(
                $this->safe_integer($ohlcv, 0),
                $this->safe_number($ohlcv, 1),
                $this->safe_number($ohlcv, 2),
                $this->safe_number($ohlcv, 3),
                $this->safe_number($ohlcv, 4),
                $this->safe_number($ohlcv, 5),
            );
        }
    }

    public function fetch_ohlcv($symbol, $timeframe = '1m', $since = null, $limit = null, $params = array ()) {
        yield $this->load_markets();
        $market = $this->market($symbol);
        $swap = $market['swap'];
        $options = $this->safe_value($this->options, 'timeframes', array());
        $timeframes = $this->safe_value($options, $market['type'], array());
        $timeframeValue = $this->safe_string($timeframes, $timeframe);
        if ($timeframeValue === null) {
            throw new NotSupported($this->id . ' fetchOHLCV() does not support ' . $timeframe . ' $timeframe for ' . $market['type'] . ' markets');
        }
        if ($limit === null) {
            $limit = 1000;
        }
        $request = array(
            // 'market' => $market['id'], // spot only
            // 'symbol' => $market['id'], // $swap only
            // 'type' => $timeframeValue, // spot only
            // 'period' => $timeframeValue, // $swap only
            // 'since' => $since, // spot only
            // 'limit' => $limit, // spot only
            // 'size' => $limit, // $swap only
        );
        $marketIdField = $swap ? 'symbol' : 'market';
        $request[$marketIdField] = $market['id'];
        $periodField = $swap ? 'period' : 'type';
        $request[$periodField] = $timeframeValue;
        $sizeField = $swap ? 'size' : 'limit';
        $request[$sizeField] = $limit;
        $method = $this->get_supported_mapping($market['type'], array(
            'spot' => 'spotV1PublicGetKline',
            'swap' => 'contractV1PublicGetKline',
        ));
        if ($since !== null) {
            $request['since'] = $since;
        }
        if ($limit !== null) {
            $request['size'] = $limit;
        }
        $response = yield $this->$method (array_merge($request, $params));
        //
        // Spot
        //
        //     {
        //         "symbol" => "BTC",
        //         "data" => [
        //             [1645091400000,43183.24,43187.49,43145.92,43182.28,0.9110],
        //             [1645091460000,43182.18,43183.15,43182.06,43183.15,1.4393],
        //             [1645091520000,43182.11,43240.1,43182.11,43240.1,0.3802]
        //         ],
        //         "moneyType" => "USDT"
        //     }
        //
        // Swap
        //
        //     {
        //         "code" => 10000,
        //         "desc" => "操作成功",
        //         "data" => [
        //             [41433.44,41433.44,41405.88,41408.75,21.368,1646366460],
        //             [41409.25,41423.74,41408.8,41423.42,9.828,1646366520],
        //             [41423.96,41429.39,41369.98,41370.31,123.104,1646366580]
        //         ]
        //     }
        //
        $data = $this->safe_value($response, 'data', array());
        return $this->parse_ohlcvs($data, $market, $timeframe, $since, $limit);
    }

    public function parse_trade($trade, $market = null) {
        //
        // Spot
        //
        //     {
        //         "date":1624537391,
        //         "amount":"0.0142",
        //         "price":"33936.42",
        //         "trade_type":"ask",
        //         "type":"sell",
        //         "tid":1718869018
        //     }
        //
        // Swap
        //
        //     array(
        //         "amount" => "0.002",
        //         "createTime" => "1645787446034",
        //         "feeAmount" => "-0.05762699",
        //         "feeCurrency" => "USDT",
        //         "id" => "6902932868050395136",
        //         "maker" => false,
        //         "orderId" => "6902932868042006528",
        //         "price" => "38417.99",
        //         "relizedPnl" => "0.30402",
        //         "side" => 4,
        //         "userId" => "6896693805014120448"
        //     ),
        //
        $sideField = $market['swap'] ? 'side' : 'trade_type';
        $side = $this->safe_string($trade, $sideField);
        $takerOrMaker = null;
        $maker = $this->safe_value($trade, 'maker');
        if ($maker !== null) {
            $takerOrMaker = $maker ? 'maker' : 'taker';
        }
        if ($market['spot']) {
            $side = ($side === 'bid') ? 'buy' : 'sell';
        } else {
            if ($side === '3') {
                $side = 'sell'; // close long
            } else if ($side === '4') {
                $side = 'buy'; // close short
            } else if ($side === '1') {
                $side = 'buy'; // open long
            } else if ($side === '2') {
                $side = 'sell'; // open short
            }
        }
        $timestamp = null;
        if ($market['swap']) {
            $timestamp = $this->safe_integer($trade, 'createTime');
        } else {
            $timestamp = $this->safe_timestamp($trade, 'date');
        }
        $price = $this->safe_string($trade, 'price');
        $amount = $this->safe_string($trade, 'amount');
        $fee = null;
        $feeCostString = $this->safe_string($trade, 'feeAmount');
        if ($feeCostString !== null) {
            $feeCurrencyId = $this->safe_string($trade, 'feeCurrency');
            $fee = array(
                'cost' => $feeCostString,
                'currency' => $this->safe_currency_code($feeCurrencyId),
            );
        }
        $market = $this->safe_market(null, $market);
        return $this->safe_trade(array(
            'info' => $trade,
            'id' => $this->safe_string($trade, 'tid'),
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'symbol' => $market['symbol'],
            'type' => null,
            'side' => $side,
            'order' => $this->safe_string($trade, 'orderId'),
            'takerOrMaker' => $takerOrMaker,
            'price' => $price,
            'amount' => $amount,
            'cost' => null,
            'fee' => $fee,
        ), $market);
    }

    public function fetch_trades($symbol, $since = null, $limit = null, $params = array ()) {
        if ($symbol === null) {
            throw new ArgumentsRequired($this->id . ' fetchTrades() requires a $symbol argument');
        }
        yield $this->load_markets();
        $market = $this->market($symbol);
        $swap = $market['swap'];
        $request = array(
            // 'market' => $market['id'], // SPOT
            // 'symbol' => $market['id'], // SWAP
            // 'side' => 1, // SWAP
            // 'dateRange' => 0, // SWAP
            // 'startTime' => $since, // SWAP
            // 'endtime' => $this->milliseconds(), // SWAP
            // 'pageNum' => 1, // SWAP
            // 'pageSize' => $limit,  // SWAP default is 10
        );
        if ($limit !== null) {
            $request['pageSize'] = $limit;
        }
        if ($since !== null) {
            $request['startTime'] = $since;
        }
        $marketIdField = $swap ? 'symbol' : 'market';
        $request[$marketIdField] = $market['id'];
        if ($swap && $params['pageNum'] === null) {
            $request['pageNum'] = 1;
        }
        $method = $this->get_supported_mapping($market['type'], array(
            'spot' => 'spotV1PublicGetTrades',
            'swap' => 'contractV2PrivateGetTradeTradeHistory',
        ));
        $response = yield $this->$method (array_merge($request, $params));
        //
        // Spot
        //
        //     array(
        //         array("date":1624537391,"amount":"0.0142","price":"33936.42","trade_type":"ask","type":"sell","tid":1718869018),
        //         array("date":1624537391,"amount":"0.0010","price":"33936.42","trade_type":"ask","type":"sell","tid":1718869020),
        //         array("date":1624537391,"amount":"0.0133","price":"33936.42","trade_type":"ask","type":"sell","tid":1718869021),
        //     )
        //
        // Swap
        //
        //     {
        //         "code" => 10000,
        //         "data" => array(
        //             "list" => array(
        //                 array(
        //                     "amount" => "0.002",
        //                     "createTime" => "1645787446034",
        //                     "feeAmount" => "-0.05762699",
        //                     "feeCurrency" => "USDT",
        //                     "id" => "6902932868050395136",
        //                     "maker" => false,
        //                     "orderId" => "6902932868042006528",
        //                     "price" => "38417.99",
        //                     "relizedPnl" => "0.30402",
        //                     "side" => 4,
        //                     "userId" => "6896693805014120448"
        //                 ),
        //             ),
        //             "pageNum" => 1,
        //             "pageSize" => 10
        //         ),
        //         "desc" => "操作成功"
        //     }
        //
        if ($swap) {
            $data = $this->safe_value($response, 'data');
            $response = $this->safe_value($data, 'list');
        }
        return $this->parse_trades($response, $market, $since, $limit);
    }

    public function create_order($symbol, $type, $side, $amount, $price = null, $params = array ()) {
        yield $this->load_markets();
        $market = $this->market($symbol);
        $swap = $market['swap'];
        $spot = $market['spot'];
        $timeInForce = $this->safe_string($params, 'timeInForce');
        if ($type === 'market') {
            throw new InvalidOrder($this->id . ' createOrder() on ' . $market['type'] . ' markets does not allow $market orders');
        }
        $method = $this->get_supported_mapping($market['type'], array(
            'spot' => 'spotV1PrivateGetOrder',
            'swap' => 'contractV2PrivatePostTradeOrder',
        ));
        $request = array(
            'amount' => $this->amount_to_precision($symbol, $amount),
        );
        if ($price) {
            $request['price'] = $this->price_to_precision($symbol, $price);
        }
        if ($spot) {
            $request['tradeType'] = ($side === 'buy') ? '1' : '0';
            $request['currency'] = $market['id'];
        } else if ($swap) {
            $reduceOnly = $this->safe_value($params, 'reduceOnly');
            $params = $this->omit($params, 'reduceOnly');
            if ($side === 'sell' && $reduceOnly) {
                $request['side'] = 3; // close long
            } else if ($side === 'buy' && $reduceOnly) {
                $request['side'] = 4; // close short
            } else if ($side === 'buy') {
                $request['side'] = 1; // open long
            } else if ($side === 'sell') {
                $request['side'] = 2; // open short
            }
            if ($type === 'limit') {
                $request['action'] = 1;
            } else if ($timeInForce === 'IOC') {
                $request['action'] = 3;
            } else if ($timeInForce === 'PO') {
                $request['action'] = 4;
            } else if ($timeInForce === 'FOK') {
                $request['action'] = 5;
            } else {
                $request['action'] = $type;
            }
            $request['symbol'] = $market['id'];
            $request['clientOrderId'] = $params['clientOrderId']; // OPTIONAL '^[a-zA-Z0-9-_]array(1,36)$', // The user-defined order number
            $request['extend'] = $params['extend']; // OPTIONAL array("orderAlgos":[array("bizType":1,"priceType":1,"triggerPrice":"70000"),array("bizType":2,"priceType":1,"triggerPrice":"40000")])
        }
        $response = yield $this->$method (array_merge($request, $params));
        //
        // Spot
        //
        //     {
        //         "code" => 1000,
        //         "message" => "操作成功",
        //         "id" => "202202224851151555"
        //     }
        //
        // Swap
        //
        //     {
        //         "code" => 10000,
        //         "desc" => "操作成功",
        //         "data" => {
        //             "orderId" => "6901786759944937472",
        //             "orderCode" => null
        //         }
        //     }
        //
        if ($swap) {
            $response = $this->safe_value($response, 'data');
        }
        $response['timeInForce'] = $timeInForce;
        $response['type'] = $request['tradeType'];
        $response['total_amount'] = $amount;
        $response['price'] = $price;
        return $this->parse_order($response, $market);
    }

    public function cancel_order($id, $symbol = null, $params = array ()) {
        if ($symbol === null) {
            throw new ArgumentsRequired($this->id . ' cancelOrder() requires a $symbol argument');
        }
        yield $this->load_markets();
        $market = $this->market($symbol);
        $swap = $market['swap'];
        $request = array(
            // 'currency' => $this->market_id($symbol), // only applicable to SPOT
            // 'id' => (string) $id, // only applicable to SPOT
            // 'symbol' => $this->market_id($symbol), // only applicable to SWAP
            // 'orderId' => (string) $id, // only applicable to SWAP
            // 'clientOrderId' => $params['clientOrderId'], // only applicable to SWAP
        );
        $marketIdField = $swap ? 'symbol' : 'currency';
        $request[$marketIdField] = $this->market_id($symbol);
        $orderIdField = $swap ? 'orderId' : 'id';
        $request[$orderIdField] = (string) $id;
        $method = $this->get_supported_mapping($market['type'], array(
            'spot' => 'spotV1PrivateGetCancelOrder',
            'swap' => 'contractV2PrivatePostTradeCancelOrder',
        ));
        $response = yield $this->$method (array_merge($request, $params));
        //
        // Spot
        //
        //     {
        //         "code" => 1000,
        //         "message" => "Success。"
        //     }
        //
        // Swap
        //
        //     {
        //         "code" => 10007,
        //         "desc" => "orderId与clientOrderId选填1个"
        //     }
        //
        return $this->parse_order($response, $market);
    }

    public function cancel_all_orders($symbol = null, $params = array ()) {
        if ($symbol === null) {
            throw new ArgumentsRequired($this->id . ' cancelAllOrders() requires a $symbol argument');
        }
        yield $this->load_markets();
        $market = $this->market($symbol);
        if ($market['spot']) {
            throw new NotSupported($this->id . ' cancelAllOrders() is not supported on ' . $market['type'] . ' markets');
        }
        $request = array(
            'symbol' => $market['id'],
        );
        return yield $this->contractV2PrivatePostTradeCancelAllOrders (array_merge($request, $params));
    }

    public function fetch_order($id, $symbol = null, $params = array ()) {
        if ($symbol === null) {
            throw new ArgumentsRequired($this->id . ' fetchOrder() requires a $symbol argument');
        }
        yield $this->load_markets();
        $market = $this->market($symbol);
        $swap = $market['swap'];
        $request = array(
            // 'currency' => $this->market_id($symbol), // only applicable to SPOT
            // 'id' => (string) $id, // only applicable to SPOT
            // 'symbol' => $this->market_id($symbol), // only applicable to SWAP
            // 'orderId' => (string) $id, // only applicable to SWAP
            // 'clientOrderId' => $params['clientOrderId'], // only applicable to SWAP
        );
        $marketIdField = $swap ? 'symbol' : 'currency';
        $request[$marketIdField] = $this->market_id($symbol);
        $orderIdField = $swap ? 'orderId' : 'id';
        $request[$orderIdField] = (string) $id;
        $method = $this->get_supported_mapping($market['type'], array(
            'spot' => 'spotV1PrivateGetGetOrder',
            'swap' => 'contractV2PrivateGetTradeGetOrder',
        ));
        $response = yield $this->$method (array_merge($request, $params));
        //
        // Spot
        //
        //     {
        //         'total_amount' => 0.01,
        //         'id' => '20180910244276459',
        //         'price' => 180.0,
        //         'trade_date' => 1536576744960,
        //         'status' => 2,
        //         'trade_money' => '1.96742',
        //         'trade_amount' => 0.01,
        //         'type' => 0,
        //         'currency' => 'eth_usdt'
        //     }
        //
        // Swap
        //
        //     {
        //         "code" => 10000,
        //         "data" => array(
        //             "action" => 1,
        //             "amount" => "0.002",
        //             "availableAmount" => "0.002",
        //             "availableValue" => "60",
        //             "avgPrice" => "0",
        //             "canCancel" => true,
        //             "cancelStatus" => 20,
        //             "createTime" => "1646185684379",
        //             "entrustType" => 1,
        //             "id" => "6904603200733782016",
        //             "leverage" => 2,
        //             "margin" => "30",
        //             "marketId" => "100",
        //             "modifyTime" => "1646185684416",
        //             "price" => "30000",
        //             "priority" => 0,
        //             "showStatus" => 1,
        //             "side" => 1,
        //             "sourceType" => 4,
        //             "status" => 12,
        //             "tradeAmount" => "0",
        //             "tradeValue" => "0",
        //             "type" => 1,
        //             "userId" => "6896693805014120448",
        //             "value" => "60"
        //         ),
        //         "desc":"操作成功"
        //     }
        //
        if ($swap) {
            $response = $this->safe_value($response, 'data', array());
        }
        return $this->parse_order($response, $market);
    }

    public function fetch_orders($symbol = null, $since = null, $limit = null, $params = array ()) {
        if ($symbol === null) {
            throw new ArgumentsRequired($this->id . 'fetchOrders() requires a $symbol argument');
        }
        yield $this->load_markets();
        $market = $this->market($symbol);
        $swap = $market['swap'];
        $request = array(
            'pageSize' => $limit, // default pageSize is 50 for spot, 30 for $swap
            // 'currency' => $market['id'], // only applicable to SPOT
            // 'pageIndex' => 1, // only applicable to SPOT
            // 'symbol' => $market['id'], // only applicable to SWAP
            // 'pageNum' => 1, // only applicable to SWAP
            // 'type' => $params['type'], // only applicable to SWAP
            // 'side' => $params['side'], // only applicable to SWAP
            // 'dateRange' => $params['dateRange'], // only applicable to SWAP
            // 'action' => $params['action'], // only applicable to SWAP
            // 'endTime' => $params['endTime'], // only applicable to SWAP
            // 'startTime' => $since, // only applicable to SWAP
        );
        $marketIdField = $market['swap'] ? 'symbol' : 'currency';
        $request[$marketIdField] = $market['id'];
        $pageNumField = $market['swap'] ? 'pageNum' : 'pageIndex';
        $request[$pageNumField] = 1;
        if ($swap) {
            $request['startTime'] = $since;
        }
        $method = $this->get_supported_mapping($market['type'], array(
            'spot' => 'spotV1PrivateGetGetOrdersIgnoreTradeType',
            'swap' => 'contractV2PrivateGetTradeGetAllOrders',
        ));
        // tradeType 交易类型1/0[buy/sell]
        if (is_array($params) && array_key_exists('tradeType', $params)) {
            $method = 'spotV1PrivateGetGetOrdersNew';
        }
        $response = null;
        try {
            $response = yield $this->$method (array_merge($request, $params));
        } catch (Exception $e) {
            if ($e instanceof OrderNotFound) {
                return array();
            }
            throw $e;
        }
        // Spot
        //
        //     array(
        //         {
        //             "acctType" => 0,
        //             "currency" => "btc_usdt",
        //             "fees" => 0,
        //             "id" => "202202234857482656",
        //             "price" => 30000.0,
        //             "status" => 3,
        //             "total_amount" => 0.0006,
        //             "trade_amount" => 0.0000,
        //             "trade_date" => 1645610254524,
        //             "trade_money" => 0.000000,
        //             "type" => 1,
        //             "useZbFee" => false,
        //             "webId" => 0
        //         }
        //     )
        //
        // Swap
        //
        //     {
        //         "code" => 10000,
        //         "data" => array(
        //             "list" => array(
        //                 array(
        //                     "action" => 1,
        //                     "amount" => "0.004",
        //                     "availableAmount" => "0.004",
        //                     "availableValue" => "120",
        //                     "avgPrice" => "0",
        //                     "canCancel" => true,
        //                     "cancelStatus" => 20,
        //                     "createTime" => "1645609643885",
        //                     "entrustType" => 1,
        //                     "id" => "6902187111785635850",
        //                     "leverage" => 5,
        //                     "margin" => "24",
        //                     "marketId" => "100",
        //                     "marketName" => "BTC_USDT",
        //                     "modifyTime" => "1645609643889",
        //                     "price" => "30000",
        //                     "showStatus" => 1,
        //                     "side" => 1,
        //                     "sourceType" => 1,
        //                     "status" => 12,
        //                     "tradeAmount" => "0",
        //                     "tradeValue" => "0",
        //                     "type" => 1,
        //                     "userId" => "6896693805014120448",
        //                     "value" => "120"
        //                 ),
        //             ),
        //             "pageNum" => 1,
        //             "pageSize" => 10
        //         ),
        //         "desc" => "操作成功"
        //     }
        //
        if ($swap) {
            $data = $this->safe_value($response, 'data', array());
            $response = $this->safe_value($data, 'list', array());
        }
        return $this->parse_orders($response, $market, $since, $limit);
    }

    public function fetch_closed_orders($symbol = null, $since = null, $limit = 10, $params = array ()) {
        if ($symbol === null) {
            throw new ArgumentsRequired($this->id . 'fetchClosedOrders() requires a $symbol argument');
        }
        yield $this->load_markets();
        $market = $this->market($symbol);
        $request = array(
            'currency' => $market['id'],
            'pageIndex' => 1, // default pageIndex is 1
            'pageSize' => $limit, // default pageSize is 10, doesn't work with other values now
        );
        $response = yield $this->spotV1PrivateGetGetFinishedAndPartialOrders (array_merge($request, $params));
        return $this->parse_orders($response, $market, $since, $limit);
    }

    public function fetch_open_orders($symbol = null, $since = null, $limit = null, $params = array ()) {
        if ($symbol === null) {
            throw new ArgumentsRequired($this->id . 'fetchOpenOrders() requires a $symbol argument');
        }
        yield $this->load_markets();
        $market = $this->market($symbol);
        $swap = $market['swap'];
        $request = array(
            // 'pageSize' => $limit, // default pageSize is 10 for spot, 30 for $swap
            // 'currency' => $market['id'], // spot only
            // 'pageIndex' => 1, // spot only
            // 'symbol' => $market['id'], // $swap only
            // 'pageNum' => 1, // $swap only
            // 'type' => $params['type'], // $swap only
            // 'side' => $params['side'], // $swap only
            // 'action' => $params['action'], // $swap only
        );
        if ($limit !== null) {
            $request['pageSize'] = $limit; // default pageSize is 10 for spot, 30 for $swap
        }
        $marketIdField = $market['swap'] ? 'symbol' : 'currency';
        $request[$marketIdField] = $market['id'];
        $pageNumField = $market['swap'] ? 'pageNum' : 'pageIndex';
        $request[$pageNumField] = 1;
        if ($swap && ($since !== null)) {
            $request['startTime'] = $since;
        }
        $method = $this->get_supported_mapping($market['type'], array(
            'spot' => 'spotV1PrivateGetGetUnfinishedOrdersIgnoreTradeType',
            'swap' => 'contractV2PrivateGetTradeGetUndoneOrders',
        ));
        // tradeType 交易类型1/0[buy/sell]
        if (is_array($params) && array_key_exists('tradeType', $params)) {
            $method = 'spotV1PrivateGetGetOrdersNew';
        }
        $response = null;
        try {
            $response = yield $this->$method (array_merge($request, $params));
        } catch (Exception $e) {
            if ($e instanceof OrderNotFound) {
                return array();
            }
            throw $e;
        }
        //
        // Spot
        //
        //     array(
        //         array(
        //             "currency" => "btc_usdt",
        //             "id" => "20150928158614292",
        //             "price" => 1560,
        //             "status" => 3,
        //             "total_amount" => 0.1,
        //             "trade_amount" => 0,
        //             "trade_date" => 1443410396717,
        //             "trade_money" => 0,
        //             "type" => 0,
        //             "fees" => "0.03",
        //             "useZbFee" => true
        //         ),
        //     )
        //
        // Swap
        //
        //     {
        //         "code" => 10000,
        //         "data" => {
        //             "list" => array(
        //                 array(
        //                     "action" => 1,
        //                     "amount" => "0.003",
        //                     "availableAmount" => "0.003",
        //                     "availableValue" => "90",
        //                     "avgPrice" => "0",
        //                     "canCancel" => true,
        //                     "cancelStatus" => 20,
        //                     "createTime" => "1645694610880",
        //                     "entrustType" => 1,
        //                     "id" => "6902543489192632320",
        //                     "leverage" => 5,
        //                     "margin" => "18",
        //                     "marketId" => "100",
        //                     "modifyTime" => "1645694610883",
        //                     "price" => "30000",
        //                     "priority" => 0,
        //                     "showStatus" => 1,
        //                     "side" => 1,
        //                     "sourceType" => 1,
        //                     "status" => 12,
        //                     "tradeAmount" => "0",
        //                     "tradeValue" => "0",
        //                     "type" => 1,
        //                     "userId" => "6896693805014120448",
        //                     "value" => "90"
        //                 }
        //             ),
        //             "pageNum" => 1,
        //             "pageSize" => 30
        //         ),
        //         "desc" => "操作成功"
        //     }
        //
        if ($swap) {
            $data = $this->safe_value($response, 'data', array());
            $response = $this->safe_value($data, 'list', array());
        }
        return $this->parse_orders($response, $market, $since, $limit);
    }

    public function parse_order($order, $market = null) {
        //
        // fetchOrder Spot
        //
        //     array(
        //         acctType => 0,
        //         currency => 'btc_usdt',
        //         fees => 3.6e-7,
        //         id => '202102282829772463',
        //         $price => 45177.5,
        //         $status => 2,
        //         total_amount => 0.0002,
        //         trade_amount => 0.0002,
        //         trade_date => 1614515104998,
        //         trade_money => 8.983712,
        //         type => 1,
        //         useZbFee => false
        //     ),
        //
        // fetchOrder Swap
        //
        //     array(
        //         "action" => 1,
        //         "amount" => "0.002",
        //         "availableAmount" => "0.002",
        //         "availableValue" => "60",
        //         "avgPrice" => "0",
        //         "canCancel" => true,
        //         "cancelStatus" => 20,
        //         "createTime" => "1646185684379",
        //         "entrustType" => 1,
        //         "id" => "6904603200733782016",
        //         "leverage" => 2,
        //         "margin" => "30",
        //         "marketId" => "100",
        //         "modifyTime" => "1646185684416",
        //         "price" => "30000",
        //         "priority" => 0,
        //         "showStatus" => 1,
        //         "side" => 1,
        //         "sourceType" => 4,
        //         "status" => 12,
        //         "tradeAmount" => "0",
        //         "tradeValue" => "0",
        //         "type" => 1,
        //         "userId" => "6896693805014120448",
        //         "value" => "60"
        //     ),
        //
        // Spot
        //
        //     {
        //         code => '1000',
        //         message => '操作成功',
        //         id => '202202224851151555',
        //         type => '1',
        //         total_amount => 0.0002,
        //         $price => 30000
        //     }
        //
        // Swap
        //
        //     {
        //         $orderId => '6901786759944937472',
        //         orderCode => null,
        //         $timeInForce => 'IOC',
        //         total_amount => 0.0002,
        //         $price => 30000
        //     }
        //
        $orderId = $market['swap'] ? $this->safe_value($order, 'orderId') : $this->safe_value($order, 'id');
        if ($orderId === null) {
            $orderId = $this->safe_value($order, 'id');
        }
        $side = $this->safe_integer($order, 'type');
        if ($side === null) {
            $side = null;
        } else {
            $side = ($side === 1) ? 'buy' : 'sell';
        }
        $timestamp = $this->safe_integer($order, 'trade_date');
        if ($timestamp === null) {
            $timestamp = $this->safe_integer($order, 'createTime');
        }
        $marketId = $this->safe_string($order, 'currency');
        $market = $this->safe_market($marketId, $market, '_');
        $price = $this->safe_string($order, 'price');
        $filled = $market['swap'] ? $this->safe_string($order, 'tradeAmount') : $this->safe_string($order, 'trade_amount');
        $amount = $this->safe_string($order, 'total_amount');
        if ($amount === null) {
            $amount = $this->safe_string($order, 'amount');
        }
        $cost = $this->safe_string($order, 'trade_money');
        $status = $this->parse_order_status($this->safe_string($order, 'status'));
        $timeInForce = $this->safe_string($order, 'timeInForce');
        $postOnly = ($timeInForce === 'PO');
        $feeCost = $this->safe_number($order, 'fees');
        $fee = null;
        if ($feeCost !== null) {
            $feeCurrency = null;
            $zbFees = $this->safe_value($order, 'useZbFee');
            if ($zbFees === true) {
                $feeCurrency = 'ZB';
            } else {
                $feeCurrency = ($side === 'sell') ? $market['quote'] : $market['base'];
            }
            $fee = array(
                'cost' => $feeCost,
                'currency' => $feeCurrency,
            );
        }
        return $this->safe_order(array(
            'info' => $order,
            'id' => $orderId,
            'clientOrderId' => $this->safe_string($order, 'userId'),
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'lastTradeTimestamp' => null,
            'symbol' => $market['symbol'],
            'type' => 'limit', // $market $order is not available on ZB
            'timeInForce' => $timeInForce,
            'postOnly' => $postOnly,
            'side' => $side,
            'price' => $price,
            'stopPrice' => null,
            'average' => $this->safe_string($order, 'avgPrice'),
            'cost' => $cost,
            'amount' => $amount,
            'filled' => $filled,
            'remaining' => null,
            'status' => $status,
            'fee' => $fee,
            'trades' => null,
        ), $market);
    }

    public function parse_order_status($status) {
        $statuses = array(
            '0' => 'open',
            '1' => 'canceled',
            '2' => 'closed',
            '3' => 'open', // partial
        );
        return $this->safe_string($statuses, $status, $status);
    }

    public function parse_transaction_status($status) {
        $statuses = array(
            '0' => 'pending', // submitted, pending confirmation
            '1' => 'failed',
            '2' => 'ok',
            '3' => 'canceled',
            '5' => 'ok', // confirmed
        );
        return $this->safe_string($statuses, $status, $status);
    }

    public function parse_transaction($transaction, $currency = null) {
        //
        // withdraw
        //
        //     {
        //         "code" => 1000,
        //         "message" => "success",
        //         "id" => "withdrawalId"
        //     }
        //
        // fetchWithdrawals
        //
        //     {
        //         "amount" => 0.01,
        //         "fees" => 0.001,
        //         "id" => 2016042556231,
        //         "manageTime" => 1461579340000,
        //         "status" => 3,
        //         "submitTime" => 1461579288000,
        //         "toAddress" => "14fxEPirL9fyfw1i9EF439Pq6gQ5xijUmp",
        //     }
        //
        // fetchDeposits
        //
        //     {
        //         "address" => "1FKN1DZqCm8HaTujDioRL2Aezdh7Qj7xxx",
        //         "amount" => "1.00000000",
        //         "confirmTimes" => 1,
        //         "currency" => "BTC",
        //         "description" => "Successfully Confirm",
        //         "hash" => "7ce842de187c379abafadd64a5fe66c5c61c8a21fb04edff9532234a1dae6xxx",
        //         "id" => 558,
        //         "itransfer" => 1,
        //         "status" => 2,
        //         "submit_time" => "2016-12-07 18:51:57",
        //     }
        //
        $id = $this->safe_string($transaction, 'id');
        $txid = $this->safe_string($transaction, 'hash');
        $amount = $this->safe_number($transaction, 'amount');
        $timestamp = $this->parse8601($this->safe_string($transaction, 'submit_time'));
        $timestamp = $this->safe_integer($transaction, 'submitTime', $timestamp);
        $address = $this->safe_string_2($transaction, 'toAddress', 'address');
        $tag = null;
        if ($address !== null) {
            $parts = explode('_', $address);
            $address = $this->safe_string($parts, 0);
            $tag = $this->safe_string($parts, 1);
        }
        $confirmTimes = $this->safe_integer($transaction, 'confirmTimes');
        $updated = $this->safe_integer($transaction, 'manageTime');
        $type = null;
        $currencyId = $this->safe_string($transaction, 'currency');
        $code = $this->safe_currency_code($currencyId, $currency);
        if ($address !== null) {
            $type = ($confirmTimes === null) ? 'withdrawal' : 'deposit';
        }
        $status = $this->parse_transaction_status($this->safe_string($transaction, 'status'));
        $fee = null;
        $feeCost = $this->safe_number($transaction, 'fees');
        if ($feeCost !== null) {
            $fee = array(
                'cost' => $feeCost,
                'currency' => $code,
            );
        }
        return array(
            'info' => $transaction,
            'id' => $id,
            'txid' => $txid,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'network' => null,
            'addressFrom' => null,
            'address' => $address,
            'addressTo' => $address,
            'tagFrom' => null,
            'tag' => $tag,
            'tagTo' => $tag,
            'type' => $type,
            'amount' => $amount,
            'currency' => $code,
            'status' => $status,
            'updated' => $updated,
            'fee' => $fee,
        );
    }

    public function set_leverage($leverage, $symbol = null, $params = array ()) {
        yield $this->load_markets();
        if ($symbol === null) {
            throw new ArgumentsRequired($this->id . ' setLeverage() requires a $symbol argument');
        }
        if (($leverage < 1) || ($leverage > 125)) {
            throw new BadRequest($this->id . ' $leverage should be between 1 and 125');
        }
        $market = $this->market($symbol);
        $accountType = null;
        if (!$market['swap']) {
            throw new BadSymbol($this->id . ' setLeverage() supports swap contracts only');
        } else {
            $accountType = 1;
        }
        $request = array(
            'symbol' => $market['id'],
            'leverage' => $leverage,
            'futuresAccountType' => $accountType, // 1 => USDT perpetual swaps
        );
        return yield $this->contractV2PrivatePostSettingSetLeverage (array_merge($request, $params));
    }

    public function fetch_funding_rate_history($symbol = null, $since = null, $limit = null, $params = array ()) {
        yield $this->load_markets();
        $request = array(
            // 'symbol' => $market['id'],
            // 'startTime' => $since,
            // 'endTime' => $endTime, // current time by default
            // 'limit' => $limit, // default 100, max 1000
        );
        if ($symbol !== null) {
            $market = $this->market($symbol);
            $request['symbol'] = $market['id'];
        }
        if ($since !== null) {
            $request['startTime'] = $since;
        }
        $till = $this->safe_integer($params, 'till');
        $endTime = $this->safe_string($params, 'endTime');
        $params = $this->omit($params, array( 'endTime', 'till' ));
        if ($till !== null) {
            $request['endTime'] = $till;
        } else if ($endTime !== null) {
            $request['endTime'] = $endTime;
        }
        if ($limit !== null) {
            $request['limit'] = $limit;
        }
        $response = yield $this->contractV2PublicGetFundingRate (array_merge($request, $params));
        //
        //     {
        //         "code" => 10000,
        //         "data" => array(
        //             array(
        //                 "symbol" => "BTC_USDT",
        //                 "fundingRate" => "0.0001",
        //                 "fundingTime" => "1645171200000"
        //             ),
        //         ),
        //         "desc" => "操作成功"
        //     }
        //
        $data = $this->safe_value($response, 'data');
        $rates = array();
        for ($i = 0; $i < count($data); $i++) {
            $entry = $data[$i];
            $marketId = $this->safe_string($entry, 'symbol');
            $symbol = $this->safe_symbol($marketId);
            $timestamp = $this->safe_string($entry, 'fundingTime');
            $rates[] = array(
                'info' => $entry,
                'symbol' => $symbol,
                'fundingRate' => $this->safe_number($entry, 'fundingRate'),
                'timestamp' => $timestamp,
                'datetime' => $this->iso8601($timestamp),
            );
        }
        $sorted = $this->sort_by($rates, 'timestamp');
        return $this->filter_by_symbol_since_limit($sorted, $symbol, $since, $limit);
    }

    public function fetch_funding_rate($symbol, $params = array ()) {
        yield $this->load_markets();
        $market = $this->market($symbol);
        if (!$market['swap']) {
            throw new BadSymbol($this->id . ' fetchFundingRate() does not supports contracts only');
        }
        $request = array(
            'symbol' => $market['id'],
        );
        $response = yield $this->contractV1PublicGetFundingRate (array_merge($request, $params));
        //
        //     {
        //         "code" => 10000,
        //         "desc" => "操作成功",
        //         "data" => {
        //             "fundingRate" => "0.0001",
        //             "nextCalculateTime" => "2022-02-19 00:00:00"
        //         }
        //     }
        //
        $data = $this->safe_value($response, 'data');
        return $this->parse_funding_rate($data, $market);
    }

    public function parse_funding_rate($contract, $market = null) {
        //
        // fetchFundingRate
        //
        //     {
        //         "fundingRate" => "0.0001",
        //         "nextCalculateTime" => "2022-02-19 00:00:00"
        //     }
        //
        // fetchFundingRates
        //
        //     {
        //         "symbol" => "BTC_USDT",
        //         "markPrice" => "43254.42",
        //         "indexPrice" => "43278.61",
        //         "lastFundingRate" => "0.0001",
        //         "nextFundingTime" => "1646121600000"
        //     }
        //
        $marketId = $this->safe_string($contract, 'symbol');
        $symbol = $this->safe_symbol($marketId, $market);
        $fundingRate = $this->safe_number($contract, 'fundingRate');
        $nextFundingDatetime = $this->safe_string($contract, 'nextCalculateTime');
        return array(
            'info' => $contract,
            'symbol' => $symbol,
            'markPrice' => $this->safe_string($contract, 'markPrice'),
            'indexPrice' => $this->safe_string($contract, 'indexPrice'),
            'interestRate' => null,
            'estimatedSettlePrice' => null,
            'timestamp' => null,
            'datetime' => null,
            'fundingRate' => $fundingRate,
            'fundingTimestamp' => null,
            'fundingDatetime' => null,
            'nextFundingRate' => null,
            'nextFundingTimestamp' => $this->parse8601($nextFundingDatetime),
            'nextFundingDatetime' => $nextFundingDatetime,
            'previousFundingRate' => $this->safe_string($contract, 'lastFundingRate'),
            'previousFundingTimestamp' => null,
            'previousFundingDatetime' => null,
        );
    }

    public function fetch_funding_rates($symbols, $params = array ()) {
        yield $this->load_markets();
        $response = yield $this->contractV2PublicGetPremiumIndex ($params);
        //
        //     {
        //         "code" => 10000,
        //         "data" => array(
        //             array(
        //                 "symbol" => "BTC_USDT",
        //                 "markPrice" => "43254.42",
        //                 "indexPrice" => "43278.61",
        //                 "lastFundingRate" => "0.0001",
        //                 "nextFundingTime" => "1646121600000"
        //             ),
        //         ),
        //         "desc":"操作成功"
        //     }
        //
        $data = $this->safe_value($response, 'data', array());
        $result = $this->parse_funding_rates($data);
        return $this->filter_by_array($result, 'symbol', $symbols);
    }

    public function withdraw($code, $amount, $address, $tag = null, $params = array ()) {
        list($tag, $params) = $this->handle_withdraw_tag_and_params($tag, $params);
        $password = $this->safe_string($params, 'safePwd', $this->password);
        if ($password === null) {
            throw new ArgumentsRequired($this->id . ' withdraw() requires exchange.password or a safePwd parameter');
        }
        $fees = $this->safe_number($params, 'fees');
        if ($fees === null) {
            throw new ArgumentsRequired($this->id . ' withdraw() requires a $fees parameter');
        }
        $this->check_address($address);
        yield $this->load_markets();
        $currency = $this->currency($code);
        if ($tag !== null) {
            $address .= '_' . $tag;
        }
        $request = array(
            'amount' => $this->currency_to_precision($code, $amount),
            'currency' => $currency['id'],
            'fees' => $this->currency_to_precision($code, $fees),
            // 'itransfer' => 0, // agree for an internal transfer, 0 disagree, 1 agree, the default is to disagree
            'method' => 'withdraw',
            'receiveAddr' => $address,
            'safePwd' => $password,
        );
        $response = yield $this->spotV1PrivateGetWithdraw (array_merge($request, $params));
        //
        //     {
        //         "code" => 1000,
        //         "message" => "success",
        //         "id" => "withdrawalId"
        //     }
        //
        $transaction = $this->parse_transaction($response, $currency);
        return array_merge($transaction, array(
            'type' => 'withdrawal',
            'address' => $address,
            'addressTo' => $address,
            'amount' => $amount,
        ));
    }

    public function fetch_withdrawals($code = null, $since = null, $limit = null, $params = array ()) {
        yield $this->load_markets();
        $request = array(
            // 'currency' => $currency['id'],
            // 'pageIndex' => 1,
            // 'pageSize' => $limit,
        );
        $currency = null;
        if ($code !== null) {
            $currency = $this->currency($code);
            $request['currency'] = $currency['id'];
        }
        if ($limit !== null) {
            $request['pageSize'] = $limit;
        }
        $response = yield $this->spotV1PrivateGetGetWithdrawRecord (array_merge($request, $params));
        //
        //     {
        //         "code" => 1000,
        //         "message" => {
        //             "des" => "success",
        //             "isSuc" => true,
        //             "datas" => {
        //                 "list" => array(
        //                     array(
        //                         "amount" => 0.01,
        //                         "fees" => 0.001,
        //                         "id" => 2016042556231,
        //                         "manageTime" => 1461579340000,
        //                         "status" => 3,
        //                         "submitTime" => 1461579288000,
        //                         "toAddress" => "14fxEPirL9fyfw1i9EF439Pq6gQ5xijUmp",
        //                     ),
        //                 ),
        //                 "pageIndex" => 1,
        //                 "pageSize" => 10,
        //                 "totalCount" => 4,
        //                 "totalPage" => 1
        //             }
        //         }
        //     }
        //
        $message = $this->safe_value($response, 'message', array());
        $datas = $this->safe_value($message, 'datas', array());
        $withdrawals = $this->safe_value($datas, 'list', array());
        return $this->parse_transactions($withdrawals, $currency, $since, $limit);
    }

    public function fetch_deposits($code = null, $since = null, $limit = null, $params = array ()) {
        yield $this->load_markets();
        $request = array(
            // 'currency' => $currency['id'],
            // 'pageIndex' => 1,
            // 'pageSize' => $limit,
        );
        $currency = null;
        if ($code !== null) {
            $currency = $this->currency($code);
            $request['currency'] = $currency['id'];
        }
        if ($limit !== null) {
            $request['pageSize'] = $limit;
        }
        $response = yield $this->spotV1PrivateGetGetChargeRecord (array_merge($request, $params));
        //
        //     {
        //         "code" => 1000,
        //         "message" => {
        //             "des" => "success",
        //             "isSuc" => true,
        //             "datas" => {
        //                 "list" => array(
        //                     array(
        //                         "address" => "1FKN1DZqCm8HaTujDioRL2Aezdh7Qj7xxx",
        //                         "amount" => "1.00000000",
        //                         "confirmTimes" => 1,
        //                         "currency" => "BTC",
        //                         "description" => "Successfully Confirm",
        //                         "hash" => "7ce842de187c379abafadd64a5fe66c5c61c8a21fb04edff9532234a1dae6xxx",
        //                         "id" => 558,
        //                         "itransfer" => 1,
        //                         "status" => 2,
        //                         "submit_time" => "2016-12-07 18:51:57",
        //                     ),
        //                 ),
        //                 "pageIndex" => 1,
        //                 "pageSize" => 10,
        //                 "total" => 8
        //             }
        //         }
        //     }
        //
        $message = $this->safe_value($response, 'message', array());
        $datas = $this->safe_value($message, 'datas', array());
        $deposits = $this->safe_value($datas, 'list', array());
        return $this->parse_transactions($deposits, $currency, $since, $limit);
    }

    public function fetch_position($symbol, $params = array ()) {
        yield $this->load_markets();
        $market = null;
        if ($symbol !== null) {
            $market = $this->market($symbol);
        }
        $request = array(
            'futuresAccountType' => 1, // 1 => USDT-M Perpetual Futures
            // 'symbol' => $market['id'],
            // 'marketId' => $market['id'],
            // 'side' => $params['side'],
        );
        $response = yield $this->contractV2PrivateGetPositionsGetPositions (array_merge($request, $params));
        //
        //     {
        //         "code" => 10000,
        //         "data" => array(
        //             {
        //                 "amount" => "0.002",
        //                 "appendAmount" => "0",
        //                 "autoLightenRatio" => "0",
        //                 "avgPrice" => "38570",
        //                 "bankruptcyPrice" => "46288.41",
        //                 "contractType" => 1,
        //                 "createTime" => "1645784751867",
        //                 "freezeAmount" => "0",
        //                 "freezeList" => array(
        //                     {
        //                         "amount" => "15.436832",
        //                         "currencyId" => "6",
        //                         "currencyName" => "usdt",
        //                         "modifyTime" => "1645784751867"
        //                     }
        //                 ),
        //                 "id" => "6902921567894972486",
        //                 "lastAppendAmount" => "0",
        //                 "leverage" => 5,
        //                 "liquidateLevel" => 1,
        //                 "liquidatePrice" => "46104",
        //                 "maintainMargin" => "0.30912384",
        //                 "margin" => "15.436832",
        //                 "marginAppendCount" => 0,
        //                 "marginBalance" => "15.295872",
        //                 "marginMode" => 1,
        //                 "marginRate" => "0.020209",
        //                 "marketId" => "100",
        //                 "marketName" => "BTC_USDT",
        //                 "modifyTime" => "1645784751867",
        //                 "nominalValue" => "77.14736",
        //                 "originAppendAmount" => "0",
        //                 "originId" => "6902921567894972591",
        //                 "refreshType" => "Timer",
        //                 "returnRate" => "-0.0091",
        //                 "side" => 0,
        //                 "status" => 1,
        //                 "unrealizedPnl" => "-0.14096",
        //                 "userId" => "6896693805014120448"
        //             }
        //         ),
        //         "desc" => "操作成功"
        //     }
        //
        $data = $this->safe_value($response, 'data', array());
        $firstPosition = $this->safe_value($data, 0);
        return $this->parse_position($firstPosition, $market);
    }

    public function fetch_positions($symbols = null, $params = array ()) {
        yield $this->load_markets();
        $market = null;
        if ($symbols !== null) {
            $market = $this->market($symbols);
        }
        $request = array(
            'futuresAccountType' => 1, // 1 => USDT-M Perpetual Futures
            // 'symbol' => $market['id'],
            // 'marketId' => $market['id'],
            // 'side' => $params['side'],
        );
        $response = yield $this->contractV2PrivateGetPositionsGetPositions (array_merge($request, $params));
        //
        //     {
        //         "code" => 10000,
        //         "data" => array(
        //             {
        //                 "amount" => "0.002",
        //                 "appendAmount" => "0",
        //                 "autoLightenRatio" => "0",
        //                 "avgPrice" => "38570",
        //                 "bankruptcyPrice" => "46288.41",
        //                 "contractType" => 1,
        //                 "createTime" => "1645784751867",
        //                 "freezeAmount" => "0",
        //                 "freezeList" => array(
        //                     array(
        //                         "amount" => "15.436832",
        //                         "currencyId" => "6",
        //                         "currencyName" => "usdt",
        //                         "modifyTime" => "1645784751867"
        //                     }
        //                 ),
        //                 "id" => "6902921567894972486",
        //                 "lastAppendAmount" => "0",
        //                 "leverage" => 5,
        //                 "liquidateLevel" => 1,
        //                 "liquidatePrice" => "46104",
        //                 "maintainMargin" => "0.30912384",
        //                 "margin" => "15.436832",
        //                 "marginAppendCount" => 0,
        //                 "marginBalance" => "15.295872",
        //                 "marginMode" => 1,
        //                 "marginRate" => "0.020209",
        //                 "marketId" => "100",
        //                 "marketName" => "BTC_USDT",
        //                 "modifyTime" => "1645784751867",
        //                 "nominalValue" => "77.14736",
        //                 "originAppendAmount" => "0",
        //                 "originId" => "6902921567894972591",
        //                 "refreshType" => "Timer",
        //                 "returnRate" => "-0.0091",
        //                 "side" => 0,
        //                 "status" => 1,
        //                 "unrealizedPnl" => "-0.14096",
        //                 "userId" => "6896693805014120448"
        //             ),
        //         ),
        //         "desc" => "操作成功"
        //     }
        //
        $data = $this->safe_value($response, 'data', array());
        return $this->parse_positions($data, $market);
    }

    public function parse_position($position, $market = null) {
        //
        //     {
        //         "amount" => "0.002",
        //         "appendAmount" => "0",
        //         "autoLightenRatio" => "0",
        //         "avgPrice" => "38570",
        //         "bankruptcyPrice" => "46288.41",
        //         "contractType" => 1,
        //         "createTime" => "1645784751867",
        //         "freezeAmount" => "0",
        //         "freezeList" => array(
        //             {
        //                 "amount" => "15.436832",
        //                 "currencyId" => "6",
        //                 "currencyName" => "usdt",
        //                 "modifyTime" => "1645784751867"
        //             }
        //         ),
        //         "id" => "6902921567894972486",
        //         "lastAppendAmount" => "0",
        //         "leverage" => 5,
        //         "liquidateLevel" => 1,
        //         "liquidatePrice" => "46104",
        //         "maintainMargin" => "0.30912384",
        //         "margin" => "15.436832",
        //         "marginAppendCount" => 0,
        //         "marginBalance" => "15.295872",
        //         "marginMode" => 1,
        //         "marginRate" => "0.020209",
        //         "marketId" => "100",
        //         "marketName" => "BTC_USDT",
        //         "modifyTime" => "1645784751867",
        //         "nominalValue" => "77.14736",
        //         "originAppendAmount" => "0",
        //         "originId" => "6902921567894972591",
        //         "refreshType" => "Timer",
        //         "returnRate" => "-0.0091",
        //         "side" => 0,
        //         "status" => 1,
        //         "unrealizedPnl" => "-0.14096",
        //         "userId" => "6896693805014120448"
        //     }
        //
        $market = $this->safe_market($this->safe_string($position, 'marketName'), $market);
        $symbol = $market['symbol'];
        $contracts = $this->safe_string($position, 'amount');
        $entryPrice = $this->safe_number($position, 'avgPrice');
        $initialMargin = $this->safe_string($position, 'margin');
        $rawSide = $this->safe_string($position, 'side');
        $side = ($rawSide === '1') ? 'long' : 'short';
        $openType = $this->safe_string($position, 'marginMode');
        $marginType = ($openType === '1') ? 'isolated' : 'cross';
        $leverage = $this->safe_string($position, 'leverage');
        $liquidationPrice = $this->safe_number($position, 'liquidatePrice');
        $unrealizedProfit = $this->safe_number($position, 'unrealizedPnl');
        $maintenanceMargin = $this->safe_number($position, 'maintainMargin');
        $marginRatio = $this->safe_number($position, 'marginRate');
        $notional = $this->safe_number($position, 'nominalValue');
        $percentage = Precise::string_mul($this->safe_string($position, 'returnRate'), '100');
        $timestamp = $this->safe_number($position, 'createTime');
        return array(
            'info' => $position,
            'symbol' => $symbol,
            'contracts' => $this->parse_number($contracts),
            'contractSize' => null,
            'entryPrice' => $entryPrice,
            'collateral' => null,
            'side' => $side,
            'unrealizedProfit' => $unrealizedProfit,
            'leverage' => $this->parse_number($leverage),
            'percentage' => $percentage,
            'marginType' => $marginType,
            'notional' => $notional,
            'markPrice' => null,
            'liquidationPrice' => $liquidationPrice,
            'initialMargin' => $this->parse_number($initialMargin),
            'initialMarginPercentage' => null,
            'maintenanceMargin' => $maintenanceMargin,
            'maintenanceMarginPercentage' => null,
            'marginRatio' => $marginRatio,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
        );
    }

    public function parse_positions($positions) {
        $result = array();
        for ($i = 0; $i < count($positions); $i++) {
            $result[] = $this->parse_position($positions[$i]);
        }
        return $result;
    }

    public function modify_margin_helper($symbol, $amount, $type, $params = array ()) {
        if ($params['positionsId'] === null) {
            throw new ArgumentsRequired($this->id . ' modifyMarginHelper() requires a positionsId argument in the params');
        }
        yield $this->load_markets();
        $market = $this->market($symbol);
        $amount = $this->amount_to_precision($symbol, $amount);
        $position = $this->safe_string($params, 'positionsId');
        $request = array(
            'positionsId' => $position,
            'amount' => $amount,
            'type' => $type, // 1 increase, 0 reduce
            'futuresAccountType' => 1, // 1 => USDT Perpetual Futures
        );
        $response = yield $this->contractV2PrivatePostPositionsUpdateMargin (array_merge($request, $params));
        //
        //     {
        //         "code" => 10000,
        //         "data" => array(
        //             "amount" => "0.002",
        //             "appendAmount" => "0",
        //             "avgPrice" => "43927.23",
        //             "bankruptcyPrice" => "41730.86",
        //             "createTime" => "1646208695609",
        //             "freezeAmount" => "0",
        //             "id" => "6900781818669377576",
        //             "keyMark" => "6896693805014120448-100-1-",
        //             "lastAppendAmount" => "0",
        //             "lastTime" => "1646209235505",
        //             "leverage" => 20,
        //             "liquidateLevel" => 1,
        //             "liquidatePrice" => "41898.46",
        //             "maintainMargin" => "0",
        //             "margin" => "4.392723",
        //             "marginAppendCount" => 0,
        //             "marginBalance" => "0",
        //             "marginMode" => 1,
        //             "marginRate" => "0",
        //             "marketId" => "100",
        //             "marketName" => "BTC_USDT",
        //             "modifyTime" => "1646209235505",
        //             "nominalValue" => "87.88828",
        //             "originAppendAmount" => "0",
        //             "originId" => "6904699716827818029",
        //             "positionsMode" => 2,
        //             "sellerCurrencyId" => "1",
        //             "side" => 1,
        //             "status" => 1,
        //             "unrealizedPnl" => "0.03382",
        //             "usable" => true,
        //             "userId" => "6896693805014120448"
        //         ),
        //         "desc":"操作成功"
        //     }
        //
        $data = $this->safe_value($response, 'data', array());
        $side = ($type === 1) ? 'add' : 'reduce';
        $errorCode = $this->safe_integer($data, 'status');
        $status = ($errorCode === 1) ? 'ok' : 'failed';
        return array(
            'info' => $response,
            'type' => $side,
            'amount' => $amount,
            'code' => $market['quote'],
            'symbol' => $market['symbol'],
            'status' => $status,
        );
    }

    public function reduce_margin($symbol, $amount, $params = array ()) {
        if ($params['positionsId'] === null) {
            throw new ArgumentsRequired($this->id . ' reduceMargin() requires a positionsId argument in the params');
        }
        return yield $this->modify_margin_helper($symbol, $amount, 0, $params);
    }

    public function add_margin($symbol, $amount, $params = array ()) {
        if ($params['positionsId'] === null) {
            throw new ArgumentsRequired($this->id . ' addMargin() requires a positionsId argument in the params');
        }
        return yield $this->modify_margin_helper($symbol, $amount, 1, $params);
    }

    public function nonce() {
        return $this->milliseconds();
    }

    public function sign($path, $api = 'public', $method = 'GET', $params = array (), $headers = null, $body = null) {
        list($section, $version, $access) = $api;
        $url = $this->urls['api'][$section][$version][$access];
        if ($access === 'public') {
            if ($path === 'getFeeInfo') {
                $url = $this->urls['api'][$section][$version]['private'] . '/' . $path;
            } else {
                $url .= '/' . $version . '/' . $path;
            }
            if ($params) {
                $url .= '?' . $this->urlencode($params);
            }
        } else if ($section === 'contract') {
            $timestamp = $this->milliseconds();
            $iso8601 = $this->iso8601($timestamp);
            $signedString = $iso8601 . $method . '/Server/api/' . $version . '/' . $path;
            $params = $this->keysort($params);
            $headers = array(
                'ZB-APIKEY' => $this->apiKey,
                'ZB-TIMESTAMP' => $iso8601,
                // 'ZB-LAN' => 'cn', // cn, en, kr
            );
            $url .= '/' . $version . '/' . $path;
            if ($method === 'POST') {
                $headers['Content-Type'] = 'application/json';
                $body = $this->json($params);
                $signedString .= $this->urlencode($params);
            } else {
                if ($params) {
                    $query = $this->urlencode($params);
                    $url .= '?' . $query;
                    $signedString .= $query;
                }
            }
            $secret = $this->hash($this->encode($this->secret), 'sha1');
            $signature = $this->hmac($this->encode($signedString), $this->encode($secret), 'sha256', 'base64');
            $headers['ZB-SIGN'] = $signature;
        } else {
            $query = $this->keysort(array_merge(array(
                'method' => $path,
                'accesskey' => $this->apiKey,
            ), $params));
            $nonce = $this->nonce();
            $query = $this->keysort($query);
            $auth = $this->rawencode($query);
            $secret = $this->hash($this->encode($this->secret), 'sha1');
            $signature = $this->hmac($this->encode($auth), $this->encode($secret), 'md5');
            $suffix = 'sign=' . $signature . '&reqTime=' . (string) $nonce;
            $url .= '/' . $path . '?' . $auth . '&' . $suffix;
        }
        return array( 'url' => $url, 'method' => $method, 'body' => $body, 'headers' => $headers );
    }

    public function handle_errors($httpCode, $reason, $url, $method, $headers, $body, $response, $requestHeaders, $requestBody) {
        if ($response === null) {
            return; // fallback to default error handler
        }
        if ($body[0] === '{') {
            $feedback = $this->id . ' ' . $body;
            $this->throw_broadly_matched_exception($this->exceptions['broad'], $body, $feedback);
            if (is_array($response) && array_key_exists('code', $response)) {
                $code = $this->safe_string($response, 'code');
                $this->throw_exactly_matched_exception($this->exceptions['exact'], $code, $feedback);
                if (($code !== '1000') && ($code !== '10000')) {
                    throw new ExchangeError($feedback);
                }
            }
            // special case for array("result":false,"message":"服务端忙碌") (a "Busy Server" reply)
            $result = $this->safe_value($response, 'result');
            if ($result !== null) {
                if (!$result) {
                    $message = $this->safe_string($response, 'message');
                    if ($message === '服务端忙碌') {
                        throw new ExchangeNotAvailable($feedback);
                    } else {
                        throw new ExchangeError($feedback);
                    }
                }
            }
        }
    }
}
