<?php

namespace ccxt\async;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

use Exception; // a common import
use ccxt\ExchangeError;
use ccxt\ArgumentsRequired;
use ccxt\BadRequest;
use ccxt\InvalidAddress;
use ccxt\InvalidOrder;
use ccxt\NotSupported;
use ccxt\Precise;
use React\Async;

class mexc3 extends Exchange {

    public function describe() {
        return $this->deep_extend(parent::describe(), array(
            'id' => 'mexc3',
            'name' => 'MEXC Global',
            'countries' => array( 'SC' ), // Seychelles
            'rateLimit' => 50, // default rate limit is 20 times per second
            'version' => 'v3',
            'has' => array(
                'CORS' => null,
                'spot' => null,
                'margin' => true,
                'swap' => null,
                'future' => null,
                'option' => null,
                'addMargin' => true,
                'borrowMargin' => true,
                'cancelAllOrders' => true,
                'cancelOrder' => true,
                'cancelOrders' => null,
                'createDepositAddress' => null,
                'createLimitOrder' => null,
                'createMarketOrder' => null,
                'createOrder' => true,
                'createReduceOnlyOrder' => true,
                'deposit' => null,
                'editOrder' => null,
                'fetchAccounts' => true,
                'fetchBalance' => true,
                'fetchBidsAsks' => true,
                'fetchBorrowRate' => null,
                'fetchBorrowRateHistory' => null,
                'fetchBorrowRates' => null,
                'fetchBorrowRatesPerSymbol' => null,
                'fetchCanceledOrders' => true,
                'fetchClosedOrder' => null,
                'fetchClosedOrders' => true,
                'fetchCurrencies' => true,
                'fetchDeposit' => null,
                'fetchDepositAddress' => true,
                'fetchDepositAddresses' => null,
                'fetchDepositAddressesByNetwork' => true,
                'fetchDeposits' => true,
                'fetchDepositWithdrawFee' => 'emulated',
                'fetchDepositWithdrawFees' => true,
                'fetchFundingHistory' => true,
                'fetchFundingRate' => true,
                'fetchFundingRateHistory' => true,
                'fetchFundingRates' => null,
                'fetchIndexOHLCV' => true,
                'fetchL2OrderBook' => true,
                'fetchLedger' => null,
                'fetchLedgerEntry' => null,
                'fetchLeverageTiers' => true,
                'fetchMarginMode' => false,
                'fetchMarketLeverageTiers' => null,
                'fetchMarkets' => true,
                'fetchMarkOHLCV' => true,
                'fetchMyTrades' => true,
                'fetchOHLCV' => true,
                'fetchOpenOrder' => null,
                'fetchOpenOrders' => true,
                'fetchOrder' => true,
                'fetchOrderBook' => true,
                'fetchOrderBooks' => null,
                'fetchOrders' => true,
                'fetchOrderTrades' => true,
                'fetchPosition' => true,
                'fetchPositionMode' => true,
                'fetchPositions' => true,
                'fetchPositionsRisk' => null,
                'fetchPremiumIndexOHLCV' => false,
                'fetchStatus' => true,
                'fetchTicker' => true,
                'fetchTickers' => true,
                'fetchTime' => true,
                'fetchTrades' => true,
                'fetchTradingFee' => null,
                'fetchTradingFees' => true,
                'fetchTradingLimits' => null,
                'fetchTransactionFee' => 'emulated',
                'fetchTransactionFees' => true,
                'fetchTransactions' => null,
                'fetchTransfer' => true,
                'fetchTransfers' => true,
                'fetchWithdrawal' => null,
                'fetchWithdrawals' => true,
                'privateAPI' => true,
                'publicAPI' => true,
                'reduceMargin' => true,
                'repayMargin' => true,
                'setLeverage' => true,
                'setMarginMode' => null,
                'setPositionMode' => true,
                'signIn' => null,
                'transfer' => null,
                'withdraw' => true,
            ),
            'urls' => array(
                'logo' => 'https://user-images.githubusercontent.com/1294454/137283979-8b2a818d-8633-461b-bfca-de89e8c446b2.jpg',
                'api' => array(
                    'spot' => array(
                        'public' => 'https://api.mexc.com',
                        'private' => 'https://api.mexc.com',
                    ),
                    'spot2' => array(
                        'public' => 'https://www.mexc.com/open/api/v2',
                        'private' => 'https://www.mexc.com/open/api/v2',
                    ),
                    'contract' => array(
                        'public' => 'https://contract.mexc.com/api/v1/contract',
                        'private' => 'https://contract.mexc.com/api/v1/private',
                    ),
                ),
                'www' => 'https://www.mexc.com/',
                'doc' => array(
                    'https://mxcdevelop.github.io/apidocs/spot_v3_en/',
                    'https://mxcdevelop.github.io/APIDoc/', // v1 & v2 : soon to be deprecated
                ),
                'fees' => array(
                    'https://www.mexc.com/fee',
                ),
                'referral' => 'https://m.mexc.com/auth/signup?inviteCode=1FQ1G',
            ),
            'api' => array(
                'spot' => array(
                    'public' => array(
                        'get' => array(
                            'ping' => 1,
                            'time' => 1,
                            'exchangeInfo' => 1,
                            'depth' => 1,
                            'trades' => 1,
                            'historicalTrades' => 1,
                            'aggTrades' => 1,
                            'klines' => 1,
                            'avgPrice' => 1,
                            'ticker/24hr' => 1,
                            'ticker/price' => 1,
                            'ticker/bookTicker' => 1,
                            'etf/info' => 1,
                        ),
                    ),
                    'private' => array(
                        'get' => array(
                            'order' => 1,
                            'openOrders' => 1,
                            'allOrders' => 1,
                            'account' => 1,
                            'myTrades' => 1,
                            'sub-account/list' => 1,
                            'sub-account/apiKey' => 1,
                            'capital/config/getall' => 1,
                            'capital/deposit/hisrec' => 1,
                            'capital/withdraw/history' => 1,
                            'capital/deposit/address' => 1,
                            'capital/transfer' => 1,
                            'capital/sub-account/universalTransfer' => 1,
                            'margin/loan' => 1,
                            'margin/allOrders' => 1,
                            'margin/myTrades' => 1,
                            'margin/openOrders' => 1,
                            'margin/maxTransferable' => 1,
                            'margin/priceIndex' => 1,
                            'margin/order' => 1,
                            'margin/isolated/account' => 1,
                            'margin/maxBorrowable' => 1,
                            'margin/repay' => 1,
                            'margin/isolated/pair' => 1,
                            'margin/forceLiquidationRec' => 1,
                            'margin/isolatedMarginData' => 1,
                            'margin/isolatedMarginTier' => 1,
                            'rebate/taxQuery' => 1,
                            'rebate/detail' => 1,
                            'rebate/detail/kickback' => 1,
                            'rebate/referCode' => 1,
                            'mxDeduct/enable' => 1,
                        ),
                        'post' => array(
                            'order' => 1,
                            'order/test' => 1,
                            'sub-account/virtualSubAccount' => 1,
                            'sub-account/apiKey' => 1,
                            'sub-account/futures' => 1,
                            'sub-account/margin' => 1,
                            'batchOrders' => 1,
                            'capital/withdraw/apply' => 1,
                            'capital/transfer' => 1,
                            'capital/deposit/address' => 1,
                            'capital/sub-account/universalTransfer' => 1,
                            'margin/tradeMode' => 1,
                            'margin/order' => 1,
                            'margin/loan' => 1,
                            'margin/repay' => 1,
                            'mxDeduct/enable' => 1,
                        ),
                        'delete' => array(
                            'order' => 1,
                            'openOrders' => 1,
                            'sub-account/apiKey' => 1,
                            'margin/order' => 1,
                            'margin/openOrders' => 1,
                        ),
                    ),
                ),
                'contract' => array(
                    'public' => array(
                        'get' => array(
                            'ping' => 2,
                            'detail' => 2,
                            'support_currencies' => 2, // TODO => should we implement 'fetchCurrencies' solely for swap? because spot doesnt have it atm
                            'depth/{symbol}' => 2,
                            'depth_commits/{symbol}/{limit}' => 2,
                            'index_price/{symbol}' => 2,
                            'fair_price/{symbol}' => 2,
                            'funding_rate/{symbol}' => 2,
                            'kline/{symbol}' => 2,
                            'kline/index_price/{symbol}' => 2,
                            'kline/fair_price/{symbol}' => 2,
                            'deals/{symbol}' => 2,
                            'ticker' => 2,
                            'risk_reverse' => 2,
                            'risk_reverse/history' => 2,
                            'funding_rate/history' => 2,
                        ),
                    ),
                    'private' => array(
                        'get' => array(
                            'account/assets' => 2,
                            'account/asset/{currency}' => 2,
                            'account/transfer_record' => 2,
                            'position/list/history_positions' => 2,
                            'position/open_positions' => 2,
                            'position/funding_records' => 2,
                            'position/position_mode' => 2,
                            'order/list/open_orders/{symbol}' => 2,
                            'order/list/history_orders' => 2,
                            'order/external/{symbol}/{external_oid}' => 2,
                            'order/get/{order_id}' => 2,
                            'order/batch_query' => 8,
                            'order/deal_details/{order_id}' => 2,
                            'order/list/order_deals' => 2,
                            'planorder/list/orders' => 2,
                            'stoporder/list/orders' => 2,
                            'stoporder/order_details/{stop_order_id}' => 2,
                            'account/risk_limit' => 2, // TO_DO => gets max/min position size, allowed sides, leverage, maintenance margin, initial margin, etc...
                            'account/tiered_fee_rate' => 2, // TO_DO => taker/maker fees for account
                            'position/leverage' => 2,
                        ),
                        'post' => array(
                            'position/change_margin' => 2,
                            'position/change_leverage' => 2,
                            'position/change_position_mode' => 2,
                            'order/submit' => 2,
                            'order/submit_batch' => 40,
                            'order/cancel' => 2,
                            'order/cancel_with_external' => 2,
                            'order/cancel_all' => 2,
                            'account/change_risk_level' => 2,
                            'planorder/place' => 2,
                            'planorder/cancel' => 2,
                            'planorder/cancel_all' => 2,
                            'stoporder/cancel' => 2,
                            'stoporder/cancel_all' => 2,
                            'stoporder/change_price' => 2,
                            'stoporder/change_plan_price' => 2,
                        ),
                    ),
                ),
                'spot2' => array(
                    'public' => array(
                        'get' => array(
                            'market/symbols' => 1,
                            'market/coin/list' => 2,
                            'common/timestamp' => 1,
                            'common/ping' => 1,
                            'market/ticker' => 1,
                            'market/depth' => 1,
                            'market/deals' => 1,
                            'market/kline' => 1,
                            'market/api_default_symbols' => 2,
                        ),
                    ),
                    'private' => array(
                        'get' => array(
                            'account/info' => 1,
                            'order/open_orders' => 1,
                            'order/list' => 1,
                            'order/query' => 1,
                            'order/deals' => 1,
                            'order/deal_detail' => 1,
                            'asset/deposit/address/list' => 2,
                            'asset/deposit/list' => 2,
                            'asset/address/list' => 2,
                            'asset/withdraw/list' => 2,
                            'asset/internal/transfer/record' => 10,
                            'account/balance' => 10,
                            'asset/internal/transfer/info' => 10,
                            'market/api_symbols' => 2,
                        ),
                        'post' => array(
                            'order/place' => 1,
                            'order/place_batch' => 1,
                            'order/advanced/place_batch' => 1,
                            'asset/withdraw' => 2,
                            'asset/internal/transfer' => 10,
                        ),
                        'delete' => array(
                            'order/cancel' => 1,
                            'order/cancel_by_symbol' => 1,
                            'asset/withdraw' => 2,
                        ),
                    ),
                ),
            ),
            'precisionMode' => TICK_SIZE,
            'timeframes' => array(
                '1m' => '1m', // spot, swap
                '3m' => '3m', // spot
                '5m' => '5m', // spot, swap
                '15m' => '15m', // spot, swap
                '30m' => '30m', // spot, swap
                '1h' => '1h', // spot, swap
                '2h' => '2h', // spot
                '4h' => '4h', // spot, swap
                '6h' => '6h', // spot
                '8h' => '8h', // spot, swap
                '12h' => '12h', // spot
                '1d' => '1d', // spot, swap
                '3d' => '3d', // spot
                '1w' => '1w', // spot, swap
                '1M' => '1M', // spot, swap
            ),
            'fees' => array(
                'trading' => array(
                    'tierBased' => false,
                    'percentage' => true,
                    'maker' => $this->parse_number('0.002'), // maker / taker
                    'taker' => $this->parse_number('0.002'),
                ),
            ),
            'options' => array(
                'createMarketBuyOrderRequiresPrice' => true,
                'unavailableContracts' => array(
                    'BTC/USDT:USDT' => true,
                    'LTC/USDT:USDT' => true,
                    'ETH/USDT:USDT' => true,
                ),
                'fetchMarkets' => array(
                    'types' => array(
                        'spot' => true,
                        'future' => array(
                            'linear' => false,
                            'inverse' => false,
                        ),
                        'swap' => array(
                            'linear' => true,
                            'inverse' => false,
                        ),
                    ),
                ),
                'timeframes' => array(
                    'spot' => array(
                        '1m' => '1m',
                        '3m' => '3m',
                        '5m' => '5m',
                        '15m' => '15m',
                        '30m' => '30m',
                        '1h' => '1h',
                        '2h' => '2h',
                        '4h' => '4h',
                        '6h' => '6h',
                        '8h' => '8h',
                        '12h' => '12h',
                        '1d' => '1d',
                        '3d' => '3d',
                        '1w' => '1w',
                        '1M' => '1M',
                    ),
                    'swap' => array(
                        '1m' => 'Min1',
                        '5m' => 'Min5',
                        '15m' => 'Min15',
                        '30m' => 'Min30',
                        '1h' => 'Min60',
                        '4h' => 'Hour4',
                        '8h' => 'Hour8',
                        '1d' => 'Day1',
                        '1w' => 'Week1',
                        '1M' => 'Month1',
                    ),
                ),
                'defaultType' => 'spot', // spot, swap
                'networks' => array(
                    'TRX' => 'TRC20',
                    'ETH' => 'ERC20',
                    'BEP20' => 'BEP20(BSC)',
                    'BSC' => 'BEP20(BSC)',
                ),
                'networksById' => array(
                    'BEP20(BSC)' => 'BSC',
                ),
                'networkAliases' => array(
                    'BSC(BEP20)' => 'BSC',
                ),
                'recvWindow' => 5 * 1000, // 5 sec, default
                'maxTimeTillEnd' => 90 * 86400 * 1000 - 1, // 90 days
                'broker' => 'CCXT',
            ),
            'commonCurrencies' => array(
                'BEYONDPROTOCOL' => 'BEYOND',
                'BIFI' => 'BIFIF',
                'BYN' => 'BeyondFi',
                'COFI' => 'COFIX', // conflict with CoinFi
                'DFI' => 'DfiStarter',
                'DFT' => 'dFuture',
                'DRK' => 'DRK',
                'EGC' => 'Egoras Credit',
                'FLUX1' => 'FLUX', // switched places
                'FLUX' => 'FLUX1', // switched places
                'FREE' => 'FreeRossDAO', // conflict with FREE Coin
                'GMT' => 'GMT Token', // Conflict with GMT (STEPN)
                'STEPN' => 'GMT', // Conflict with GMT Token
                'HERO' => 'Step Hero', // conflict with Metahero
                'MIMO' => 'Mimosa',
                'PROS' => 'Pros.Finance', // conflict with Prosper
                'SIN' => 'Sin City Token',
                'SOUL' => 'Soul Swap',
            ),
            'exceptions' => array(
                'exact' => array(
                    // until mexc migrates fully to v3, it might be worth to note the version & market aside errors, not easily remove obsolete version's exceptions in future
                    '-1128' => '\\ccxt\\BadRequest',
                    '-2011' => '\\ccxt\\BadRequest',
                    '-1121' => '\\ccxt\\BadSymbol',
                    '10101' => '\\ccxt\\InsufficientFunds', // array("msg":"资金不足","code":10101)
                    '2009' => '\\ccxt\\InvalidOrder', // array("success":false,"code":2009,"message":"Position is not exists or closed.")
                    '2011' => '\\ccxt\\BadRequest',
                    '30004' => '\\ccxt\\InsufficientFunds',
                    '33333' => '\\ccxt\\BadRequest', // array("msg":"Not support transfer","code":33333)
                    '44444' => '\\ccxt\\BadRequest',
                    '1002' => '\\ccxt\\InvalidOrder',
                    '30019' => '\\ccxt\\BadRequest',
                    '30005' => '\\ccxt\\InvalidOrder',
                    '2003' => '\\ccxt\\InvalidOrder',
                    '2005' => '\\ccxt\\InsufficientFunds',
                    '600' => '\\ccxt\\BadRequest',
                    '70011' => '\\ccxt\\PermissionDenied', // array("code":70011,"msg":"Pair user ban trade apikey.")
                    '88004' => '\\ccxt\\InsufficientFunds', // array("msg":"超出最大可借，最大可借币为:18.09833211","code":88004)
                    '88009' => '\\ccxt\\ExchangeError', // v3 array("msg":"Loan record does not exist","code":88009)
                    '88013' => '\\ccxt\\InvalidOrder', // array("msg":"最小交易额不能小于：5USDT","code":88013)
                    '88015' => '\\ccxt\\InsufficientFunds', // array("msg":"持仓不足","code":88015)
                    '700003' => '\\ccxt\\InvalidNonce', // array("code":700003,"msg":"Timestamp for this request is outside of the recvWindow.")
                ),
                'broad' => array(
                    'Order quantity error, please try to modify.' => '\\ccxt\\BadRequest', // code:2011
                    'Combination of optional parameters invalid' => '\\ccxt\\BadRequest', // code:-2011
                    'api market order is disabled' => '\\ccxt\\BadRequest', //
                    'Contract not allow place order!' => '\\ccxt\\InvalidOrder', // code:1002
                    'Oversold' => '\\ccxt\\InvalidOrder', // code:30005
                    'Insufficient position' => '\\ccxt\\InsufficientFunds', // code:30004
                    'Insufficient balance!' => '\\ccxt\\InsufficientFunds', // code:2005
                    'Bid price is great than max allow price' => '\\ccxt\\InvalidOrder', // code:2003
                    'Invalid symbol.' => '\\ccxt\\BadSymbol', // code:-1121
                    'Param error!' => '\\ccxt\\BadRequest', // code:600
                ),
            ),
        ));
    }

    public function fetch_status($params = array ()) {
        return Async\async(function () use ($params) {
            /**
             * the latest known information on the availability of the exchange API
             * @param {array} $params extra parameters specific to the mexc3 api endpoint
             * @return {array} a {@link https://docs.ccxt.com/en/latest/manual.html#exchange-$status-structure $status structure}
             */
            list($marketType, $query) = $this->handle_market_type_and_params('fetchStatus', null, $params);
            $response = null;
            $status = null;
            $updated = null;
            if ($marketType === 'spot') {
                $response = Async\await($this->spotPublicGetPing ($query));
                //
                //     array()
                //
                $status = $response ? $this->json($response) : 'ok';
            } elseif ($marketType === 'swap') {
                $response = Async\await($this->contractPublicGetPing ($query));
                //
                //     array("success":true,"code":"0","data":"1648124374985")
                //
                $status = $this->safe_value($response, 'success') ? 'ok' : $this->json($response);
                $updated = $this->safe_integer($response, 'data');
            }
            return array(
                'status' => $status,
                'updated' => $updated,
                'url' => null,
                'eta' => null,
                'info' => $response,
            );
        }) ();
    }

    public function fetch_time($params = array ()) {
        return Async\async(function () use ($params) {
            /**
             * fetches the current integer timestamp in milliseconds from the exchange server
             * @param {array} $params extra parameters specific to the mexc3 api endpoint
             * @return {int} the current integer timestamp in milliseconds from the exchange server
             */
            list($marketType, $query) = $this->handle_market_type_and_params('fetchTime', null, $params);
            $response = null;
            if ($marketType === 'spot') {
                $response = Async\await($this->spotPublicGetTime ($query));
                //
                //     array("serverTime" => "1647519277579")
                //
                return $this->safe_integer($response, 'serverTime');
            } elseif ($marketType === 'swap') {
                $response = Async\await($this->contractPublicGetPing ($query));
                //
                //     array("success":true,"code":"0","data":"1648124374985")
                //
                return $this->safe_integer($response, 'data');
            }
        }) ();
    }

    public function fetch_currencies($params = array ()) {
        return Async\async(function () use ($params) {
            /**
             * fetches all available currencies on an exchange
             * @see https://mxcdevelop.github.io/apidocs/spot_v3_en/#query-the-$currency-information
             * @param {array} $params extra parameters specific to the mexc3 api endpoint
             * @return {array} an associative dictionary of currencies
             */
            // this endpoint requires authentication
            // while fetchCurrencies is a public API method by design
            // therefore we check the keys here
            // and fallback to generating the currencies from the markets
            if (!$this->check_required_credentials(false)) {
                return null;
            }
            $response = Async\await($this->spotPrivateGetCapitalConfigGetall ($params));
            //
            // {
            //     coin => 'QANX',
            //     $name => 'QANplatform',
            //     networkList => array(
            //       array(
            //         coin => 'QANX',
            //         depositDesc => null,
            //         depositEnable => true,
            //         minConfirm => '0',
            //         $name => 'QANplatform',
            //         $network => 'BEP20(BSC)',
            //         withdrawEnable => false,
            //         withdrawFee => '42.000000000000000000',
            //         withdrawIntegerMultiple => null,
            //         $withdrawMax => '24000000.000000000000000000',
            //         $withdrawMin => '20.000000000000000000',
            //         sameAddress => false,
            //         contract => '0xAAA7A10a8ee237ea61E8AC46C50A8Db8bCC1baaa'
            //       ),
            //       {
            //         coin => 'QANX',
            //         depositDesc => null,
            //         depositEnable => true,
            //         minConfirm => '0',
            //         $name => 'QANplatform',
            //         $network => 'ERC20',
            //         withdrawEnable => true,
            //         withdrawFee => '2732.000000000000000000',
            //         withdrawIntegerMultiple => null,
            //         $withdrawMax => '24000000.000000000000000000',
            //         $withdrawMin => '240.000000000000000000',
            //         sameAddress => false,
            //         contract => '0xAAA7A10a8ee237ea61E8AC46C50A8Db8bCC1baaa'
            //       }
            //     )
            //   }
            //
            $result = array();
            for ($i = 0; $i < count($response); $i++) {
                $currency = $response[$i];
                $id = $this->safe_string($currency, 'coin');
                $code = $this->safe_currency_code($id);
                $name = $this->safe_string($currency, 'name');
                $currencyActive = false;
                $currencyFee = null;
                $currencyWithdrawMin = null;
                $currencyWithdrawMax = null;
                $depositEnabled = false;
                $withdrawEnabled = false;
                $networks = array();
                $chains = $this->safe_value($currency, 'networkList', array());
                for ($j = 0; $j < count($chains); $j++) {
                    $chain = $chains[$j];
                    $networkId = $this->safe_string($chain, 'network');
                    $network = $this->safe_network($networkId);
                    $isDepositEnabled = $this->safe_value($chain, 'depositEnable', false);
                    $isWithdrawEnabled = $this->safe_value($chain, 'withdrawEnable', false);
                    $active = ($isDepositEnabled && $isWithdrawEnabled);
                    $currencyActive = $active || $currencyActive;
                    $withdrawMin = $this->safe_string($chain, 'withdrawMin');
                    $withdrawMax = $this->safe_string($chain, 'withdrawMax');
                    $currencyWithdrawMin = ($currencyWithdrawMin === null) ? $withdrawMin : $currencyWithdrawMin;
                    $currencyWithdrawMax = ($currencyWithdrawMax === null) ? $withdrawMax : $currencyWithdrawMax;
                    $fee = $this->safe_number($chain, 'withdrawFee');
                    $currencyFee = ($currencyFee === null) ? $fee : $currencyFee;
                    if (Precise::string_gt($currencyWithdrawMin, $withdrawMin)) {
                        $currencyWithdrawMin = $withdrawMin;
                    }
                    if (Precise::string_lt($currencyWithdrawMax, $withdrawMax)) {
                        $currencyWithdrawMax = $withdrawMax;
                    }
                    if ($isDepositEnabled) {
                        $depositEnabled = true;
                    }
                    if ($isWithdrawEnabled) {
                        $withdrawEnabled = true;
                    }
                    $networks[$network] = array(
                        'info' => $chain,
                        'id' => $networkId,
                        'network' => $network,
                        'active' => $active,
                        'deposit' => $isDepositEnabled,
                        'withdraw' => $isWithdrawEnabled,
                        'fee' => $this->safe_number($chain, 'fee'),
                        'precision' => null,
                        'limits' => array(
                            'withdraw' => array(
                                'min' => $withdrawMin,
                                'max' => $withdrawMax,
                            ),
                        ),
                    );
                }
                $networkKeys = is_array($networks) ? array_keys($networks) : array();
                $networkKeysLength = count($networkKeys);
                if (($networkKeysLength === 1) || (is_array($networks) && array_key_exists('NONE', $networks))) {
                    $defaultNetwork = $this->safe_value_2($networks, 'NONE', $networkKeysLength - 1);
                    if ($defaultNetwork !== null) {
                        $currencyFee = $defaultNetwork['fee'];
                    }
                }
                $result[$code] = array(
                    'info' => $currency,
                    'id' => $id,
                    'code' => $code,
                    'name' => $name,
                    'active' => $currencyActive,
                    'deposit' => $depositEnabled,
                    'withdraw' => $withdrawEnabled,
                    'fee' => $currencyFee,
                    'precision' => null,
                    'limits' => array(
                        'amount' => array(
                            'min' => null,
                            'max' => null,
                        ),
                        'withdraw' => array(
                            'min' => $currencyWithdrawMin,
                            'max' => $currencyWithdrawMax,
                        ),
                    ),
                    'networks' => $networks,
                );
            }
            return $result;
        }) ();
    }

    public function safe_network($networkId) {
        if (mb_strpos($networkId, 'BSC') !== false) {
            return 'BEP20';
        }
        $parts = explode(' ', $networkId);
        $networkId = implode('', $parts);
        $networkId = str_replace('-20', '20', $networkId);
        $networksById = array(
            'ETH' => 'ETH',
            'ERC20' => 'ERC20',
            'BEP20(BSC)' => 'BEP20',
            'TRX' => 'TRC20',
        );
        return $this->safe_string($networksById, $networkId, $networkId);
    }

    public function fetch_markets($params = array ()) {
        return Async\async(function () use ($params) {
            /**
             * retrieves data on all markets for mexc3
             * @param {array} $params extra parameters specific to the exchange api endpoint
             * @return {[array]} an array of objects representing market data
             */
            $spotMarket = Async\await($this->fetch_spot_markets($params));
            $swapMarket = Async\await($this->fetch_swap_markets($params));
            return $this->array_concat($spotMarket, $swapMarket);
        }) ();
    }

    public function fetch_spot_markets($params = array ()) {
        return Async\async(function () use ($params) {
            $response = Async\await($this->spotPublicGetExchangeInfo ($params));
            //
            //     {
            //         "timezone" => "CST",
            //         "serverTime" => 1647521860402,
            //         "rateLimits" => array(),
            //         "exchangeFilters" => array(),
            //         "symbols" => array(
            //           array(
            //                "symbol" => "OGNUSDT",
            //                "status" => "ENABLED",
            //                "baseAsset" => "OGN",
            //                "baseAssetPrecision" => "2",
            //                "quoteAsset" => "USDT",
            //                "quoteAssetPrecision" => "4",
            //                "orderTypes" => array(
            //                    "LIMIT",
            //                    "LIMIT_MAKER"
            //                ),
            //                "baseCommissionPrecision" => "2",
            //                "quoteCommissionPrecision" => "4",
            //                "quoteOrderQtyMarketAllowed" => false,
            //                "isSpotTradingAllowed" => true,
            //                "isMarginTradingAllowed" => true,
            //                "permissions" => array(
            //                    "SPOT",
            //                    "MARGIN"
            //                ),
            //                "filters" => array(),
            //                "baseSizePrecision" => "0.01", // this turned out to be a minimum $base amount for order
            //                "maxQuoteAmount" => "5000000",
            //                "makerCommission" => "0.002",
            //                "takerCommission" => "0.002"
            //                "quoteAmountPrecision" => "5", // this turned out to be a minimum cost amount for order
            //                "quotePrecision" => "4", // deprecated in favor of 'quoteAssetPrecision' ( https://dev.binance.vision/t/what-is-the-difference-between-quoteprecision-and-quoteassetprecision/4333 )
            //                // note, "icebergAllowed" & "ocoAllowed" fields were recently removed
            //            ),
            //         )
            //     }
            //
            // Notes:
            // - 'quoteAssetPrecision' & 'baseAssetPrecision' are not currency's real blockchain precision (to view currency's actual individual precision, refer to fetchCurrencies() method).
            //
            $data = $this->safe_value($response, 'symbols', array());
            $result = array();
            for ($i = 0; $i < count($data); $i++) {
                $market = $data[$i];
                $id = $this->safe_string($market, 'symbol');
                $baseId = $this->safe_string($market, 'baseAsset');
                $quoteId = $this->safe_string($market, 'quoteAsset');
                $base = $this->safe_currency_code($baseId);
                $quote = $this->safe_currency_code($quoteId);
                $status = $this->safe_string($market, 'status');
                $isSpotTradingAllowed = $this->safe_value($market, 'isSpotTradingAllowed');
                $active = false;
                if (($status === 'ENABLED') && ($isSpotTradingAllowed)) {
                    $active = true;
                }
                $isMarginTradingAllowed = $this->safe_value($market, 'isMarginTradingAllowed');
                $makerCommission = $this->safe_number($market, 'makerCommission');
                $takerCommission = $this->safe_number($market, 'takerCommission');
                $maxQuoteAmount = $this->safe_number($market, 'maxQuoteAmount');
                $result[] = array(
                    'id' => $id,
                    'symbol' => $base . '/' . $quote,
                    'base' => $base,
                    'quote' => $quote,
                    'settle' => null,
                    'baseId' => $baseId,
                    'quoteId' => $quoteId,
                    'settleId' => null,
                    'type' => 'spot',
                    'spot' => true,
                    'margin' => $isMarginTradingAllowed,
                    'swap' => false,
                    'future' => false,
                    'option' => false,
                    'active' => $active,
                    'contract' => false,
                    'linear' => null,
                    'inverse' => null,
                    'taker' => $takerCommission,
                    'maker' => $makerCommission,
                    'contractSize' => null,
                    'expiry' => null,
                    'expiryDatetime' => null,
                    'strike' => null,
                    'optionType' => null,
                    'precision' => array(
                        'amount' => $this->parse_number($this->parse_precision($this->safe_string($market, 'baseAssetPrecision'))),
                        'price' => $this->parse_number($this->parse_precision($this->safe_string($market, 'quoteAssetPrecision'))),
                    ),
                    'limits' => array(
                        'leverage' => array(
                            'min' => null,
                            'max' => null,
                        ),
                        'amount' => array(
                            'min' => $this->safe_number($market, 'baseSizePrecision'),
                            'max' => null,
                        ),
                        'price' => array(
                            'min' => null,
                            'max' => null,
                        ),
                        'cost' => array(
                            'min' => $this->safe_number($market, 'quoteAmountPrecision'),
                            'max' => $maxQuoteAmount,
                        ),
                    ),
                    'info' => $market,
                );
            }
            return $result;
        }) ();
    }

    public function fetch_swap_markets($params = array ()) {
        return Async\async(function () use ($params) {
            $response = Async\await($this->contractPublicGetDetail ($params));
            //
            //     {
            //         "success":true,
            //         "code":0,
            //         "data":[
            //             array(
            //                 "symbol":"BTC_USDT",
            //                 "displayName":"BTC_USDT永续",
            //                 "displayNameEn":"BTC_USDT SWAP",
            //                 "positionOpenType":3,
            //                 "baseCoin":"BTC",
            //                 "quoteCoin":"USDT",
            //                 "settleCoin":"USDT",
            //                 "contractSize":0.0001,
            //                 "minLeverage":1,
            //                 "maxLeverage":125,
            //                 "priceScale":2, // seems useless atm, as it's just how UI shows the price, $i->e. 29583.50 for BTC/USDT:USDT, while price ticksize is 0.5
            //                 "volScale":0, // probably => contract amount precision
            //                 "amountScale":4, // probably => $quote currency precision
            //                 "priceUnit":0.5, // price tick size
            //                 "volUnit":1, // probably => contract tick size
            //                 "minVol":1,
            //                 "maxVol":1000000,
            //                 "bidLimitPriceRate":0.1,
            //                 "askLimitPriceRate":0.1,
            //                 "takerFeeRate":0.0006,
            //                 "makerFeeRate":0.0002,
            //                 "maintenanceMarginRate":0.004,
            //                 "initialMarginRate":0.008,
            //                 "riskBaseVol":10000,
            //                 "riskIncrVol":200000,
            //                 "riskIncrMmr":0.004,
            //                 "riskIncrImr":0.004,
            //                 "riskLevelLimit":5,
            //                 "priceCoefficientVariation":0.1,
            //                 "indexOrigin":["BINANCE","GATEIO","HUOBI","MXC"],
            //                 "state":0, // 0 enabled, 1 delivery, 2 completed, 3 offline, 4 pause
            //                 "isNew":false,
            //                 "isHot":true,
            //                 "isHidden":false
            //             ),
            //         ]
            //     }
            //
            $data = $this->safe_value($response, 'data', array());
            $result = array();
            for ($i = 0; $i < count($data); $i++) {
                $market = $data[$i];
                $id = $this->safe_string($market, 'symbol');
                $baseId = $this->safe_string($market, 'baseCoin');
                $quoteId = $this->safe_string($market, 'quoteCoin');
                $settleId = $this->safe_string($market, 'settleCoin');
                $base = $this->safe_currency_code($baseId);
                $quote = $this->safe_currency_code($quoteId);
                $settle = $this->safe_currency_code($settleId);
                $state = $this->safe_string($market, 'state');
                $result[] = array(
                    'id' => $id,
                    'symbol' => $base . '/' . $quote . ':' . $settle,
                    'base' => $base,
                    'quote' => $quote,
                    'settle' => $settle,
                    'baseId' => $baseId,
                    'quoteId' => $quoteId,
                    'settleId' => $settleId,
                    'type' => 'swap',
                    'spot' => false,
                    'margin' => false,
                    'swap' => true,
                    'future' => false,
                    'option' => false,
                    'active' => ($state === '0'),
                    'contract' => true,
                    'linear' => true,
                    'inverse' => false,
                    'taker' => $this->safe_number($market, 'takerFeeRate'),
                    'maker' => $this->safe_number($market, 'makerFeeRate'),
                    'contractSize' => $this->safe_number($market, 'contractSize'),
                    'expiry' => null,
                    'expiryDatetime' => null,
                    'strike' => null,
                    'optionType' => null,
                    'precision' => array(
                        'amount' => $this->safe_number($market, 'volUnit'),
                        'price' => $this->safe_number($market, 'priceUnit'),
                    ),
                    'limits' => array(
                        'leverage' => array(
                            'min' => $this->safe_number($market, 'minLeverage'),
                            'max' => $this->safe_number($market, 'maxLeverage'),
                        ),
                        'amount' => array(
                            'min' => $this->safe_number($market, 'minVol'),
                            'max' => $this->safe_number($market, 'maxVol'),
                        ),
                        'price' => array(
                            'min' => null,
                            'max' => null,
                        ),
                        'cost' => array(
                            'min' => null,
                            'max' => null,
                        ),
                    ),
                    'info' => $market,
                );
            }
            return $result;
        }) ();
    }

    public function fetch_order_book($symbol, $limit = null, $params = array ()) {
        return Async\async(function () use ($symbol, $limit, $params) {
            /**
             * fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other $data
             * @param {string} $symbol unified $symbol of the $market to fetch the order book for
             * @param {int|null} $limit the maximum amount of order book entries to return
             * @param {array} $params extra parameters specific to the mexc3 api endpoint
             * @return {array} A dictionary of {@link https://docs.ccxt.com/en/latest/manual.html#order-book-structure order book structures} indexed by $market symbols
             */
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $request = array(
                'symbol' => $market['id'],
            );
            if ($limit !== null) {
                $request['limit'] = $limit;
            }
            $orderbook = null;
            if ($market['spot']) {
                $response = Async\await($this->spotPublicGetDepth (array_merge($request, $params)));
                //
                //     {
                //         "lastUpdateId" => "744267132",
                //         "bids" => [
                //             ["40838.50","0.387864"],
                //             ["40837.95","0.008400"],
                //         ],
                //         "asks" => [
                //             ["40838.61","6.544908"],
                //             ["40838.88","0.498000"],
                //         ]
                //     }
                //
                $orderbook = $this->parse_order_book($response, $symbol);
                $orderbook['nonce'] = $this->safe_integer($response, 'lastUpdateId');
            } elseif ($market['swap']) {
                $response = Async\await($this->contractPublicGetDepthSymbol (array_merge($request, $params)));
                //
                //     {
                //         "success":true,
                //         "code":0,
                //         "data":{
                //             "asks":[
                //                 [3445.72,48379,1],
                //                 [3445.75,34994,1],
                //             ],
                //             "bids":[
                //                 [3445.55,44081,1],
                //                 [3445.51,24857,1],
                //             ],
                //             "version":2827730444,
                //             "timestamp":1634117846232
                //         }
                //     }
                //
                $data = $this->safe_value($response, 'data');
                $timestamp = $this->safe_integer($data, 'timestamp');
                $orderbook = $this->parse_order_book($data, $symbol, $timestamp);
                $orderbook['nonce'] = $this->safe_integer($data, 'version');
            }
            return $orderbook;
        }) ();
    }

    public function fetch_trades($symbol, $since = null, $limit = null, $params = array ()) {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            /**
             * get the list of most recent $trades for a particular $symbol
             * @param {string} $symbol unified $symbol of the $market to fetch $trades for
             * @param {int|null} $since timestamp in ms of the earliest trade to fetch
             * @param {int|null} $limit the maximum amount of $trades to fetch
             * @param {array} $params extra parameters specific to the mexc3 api endpoint
             * @return {[array]} a list of ~@link https://docs.ccxt.com/en/latest/manual.html?#public-$trades trade structures~
             */
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $request = array(
                'symbol' => $market['id'],
            );
            if ($limit !== null) {
                $request['limit'] = $limit;
            }
            // if ($since !== null) {
            //     $request['startTime'] = $since; bug in api, waiting for fix
            // }
            $trades = null;
            if ($market['spot']) {
                $method = $this->safe_string($this->options, 'fetchTradesMethod', 'spotPublicGetAggTrades');
                $method = $this->safe_string($params, 'method', $method); // AggTrades, HistoricalTrades, Trades
                $trades = Async\await($this->$method (array_merge($request, $params)));
                //
                //     /trades, /historicalTrades
                //
                //     array(
                //         array(
                //             "id" => null,
                //             "price" => "40798.94",
                //             "qty" => "0.000508",
                //             "quoteQty" => "20.72586152",
                //             "time" => "1647546934374",
                //             "isBuyerMaker" => true,
                //             "isBestMatch" => true
                //         ),
                //     )
                //
                //     /aggrTrades
                //
                //     array(
                //         array(
                //           "a" => null,
                //           "f" => null,
                //           "l" => null,
                //           "p" => "40679",
                //           "q" => "0.001309",
                //           "T" => 1647551328000,
                //           "m" => true,
                //           "M" => true
                //         ),
                //     )
                //
            } elseif ($market['swap']) {
                $response = Async\await($this->contractPublicGetDealsSymbol (array_merge($request, $params)));
                //
                //     {
                //         "success" => true,
                //         "code" => 0,
                //         "data" => array(
                //             array(
                //                 "p" => 31199,
                //                 "v" => 18,
                //                 "T" => 1,
                //                 "O" => 3,
                //                 "M" => 2,
                //                 "t" => 1609831235985
                //             ),
                //         )
                //     }
                //
                $trades = $this->safe_value($response, 'data');
            }
            return $this->parse_trades($trades, $market, $since, $limit);
        }) ();
    }

    public function parse_trade($trade, $market = null) {
        $id = null;
        $timestamp = null;
        $orderId = null;
        $symbol = null;
        $fee = null;
        $type = null;
        $side = null;
        $takerOrMaker = null;
        $priceString = null;
        $amountString = null;
        $costString = null;
        // if swap
        if (is_array($trade) && array_key_exists('v', $trade)) {
            //
            // swap => fetchTrades
            //
            //     {
            //         "p" => 31199,
            //         "v" => 18,
            //         "T" => 1,
            //         "O" => 3,
            //         "M" => 2,
            //         "t" => 1609831235985
            //     }
            //
            $timestamp = $this->safe_integer($trade, 't');
            $market = $this->safe_market(null, $market);
            $symbol = $market['symbol'];
            $priceString = $this->safe_string($trade, 'p');
            $amountString = $this->safe_string($trade, 'v');
            $side = $this->parse_order_side($this->safe_string($trade, 'T'));
            $takerOrMaker = 'taker';
        } else {
            //
            // spot => fetchTrades (for aggTrades)
            //
            //         {
            //             "a" => null,
            //             "f" => null,
            //             "l" => null,
            //             "p" => "40679",
            //             "q" => "0.001309",
            //             "T" => 1647551328000,
            //             "m" => true,
            //             "M" => true
            //         }
            //
            // spot => fetchMyTrades, fetchOrderTrades
            //
            //         {
            //             "symbol" => "BTCUSDT",
            //             "id" => "133948532984922113",
            //             "orderId" => "133948532531949568",
            //             "orderListId" => "-1",
            //             "price" => "41995.51",
            //             "qty" => "0.0002",
            //             "quoteQty" => "8.399102",
            //             "commission" => "0.016798204",
            //             "commissionAsset" => "USDT",
            //             "time" => "1647718055000",
            //             "isBuyer" => true,
            //             "isMaker" => false,
            //             "isBestMatch" => true
            //         }
            //
            // swap => fetchMyTrades, fetchOrderTrades
            //
            //         {
            //             "id" => "299444585",
            //             "symbol" => "STEPN_USDT",
            //             "side" => "1",
            //             "vol" => "1",
            //             "price" => "2.45455",
            //             "feeCurrency" => "USDT",
            //             "fee" => "0.00147273",
            //             "timestamp" => "1648924557000",
            //             "profit" => "0",
            //             "category" => "1",
            //             "orderId" => "265307163526610432",
            //             "positionMode" => "1",
            //             "taker" => true
            //         }
            //
            $marketId = $this->safe_string($trade, 'symbol');
            $market = $this->safe_market($marketId, $market);
            $symbol = $market['symbol'];
            $id = $this->safe_string_2($trade, 'id', 'a');
            $priceString = $this->safe_string_2($trade, 'price', 'p');
            $orderId = $this->safe_string($trade, 'orderId');
            // if swap
            if (is_array($trade) && array_key_exists('positionMode', $trade)) {
                $timestamp = $this->safe_integer($trade, 'timestamp');
                $amountString = $this->safe_string($trade, 'vol');
                $side = $this->parse_order_side($this->safe_string($trade, 'side'));
                $fee = array(
                    'cost' => $this->safe_string($trade, 'fee'),
                    'currency' => $this->safe_currency_code($this->safe_string($trade, 'feeCurrency')),
                );
                $takerOrMaker = $this->safe_value($trade, 'taker') ? 'taker' : 'maker';
            } else {
                $timestamp = $this->safe_integer_2($trade, 'time', 'T');
                $amountString = $this->safe_string_2($trade, 'qty', 'q');
                $costString = $this->safe_string($trade, 'quoteQty');
                $isBuyer = $this->safe_value($trade, 'isBuyer');
                $isMaker = $this->safe_value($trade, 'isMaker');
                $buyerMaker = $this->safe_string_2($trade, 'isBuyerMaker', 'm');
                if ($isMaker !== null) {
                    $takerOrMaker = $isMaker ? 'maker' : 'taker';
                }
                if ($isBuyer !== null) {
                    $side = $isBuyer ? 'buy' : 'sell';
                }
                if ($buyerMaker !== null) {
                    $side = $buyerMaker ? 'sell' : 'buy';
                    $takerOrMaker = 'taker';
                }
                $feeAsset = $this->safe_string($trade, 'commissionAsset');
                if ($feeAsset !== null) {
                    $fee = array(
                        'cost' => $this->safe_string($trade, 'commission'),
                        'currency' => $this->safe_currency_code($feeAsset),
                    );
                }
            }
        }
        if ($id === null) {
            $id = $this->synthetic_trade_id($market, $timestamp, $side, $amountString, $priceString, $type, $takerOrMaker);
        }
        return $this->safe_trade(array(
            'id' => $id,
            'order' => $orderId,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'symbol' => $symbol,
            'type' => $type,
            'side' => $side,
            'takerOrMaker' => $takerOrMaker,
            'price' => $priceString,
            'amount' => $amountString,
            'cost' => $costString,
            'fee' => $fee,
            'info' => $trade,
        ), $market);
    }

    public function synthetic_trade_id($market = null, $timestamp = null, $side = null, $amount = null, $price = null, $orderType = null, $takerOrMaker = null) {
        // TODO => can be unified method? this approach is being used by multiple exchanges (mexc, woo-coinsbit, dydx, ...)
        $id = '';
        if ($timestamp !== null) {
            $id = $this->number_to_string($timestamp) . '-' . $this->safe_string($market, 'id', '_');
            if ($side !== null) {
                $id .= '-' . $side;
            }
            if ($amount !== null) {
                $id .= '-' . $this->number_to_string($amount);
            }
            if ($price !== null) {
                $id .= '-' . $this->number_to_string($price);
            }
            if ($takerOrMaker !== null) {
                $id .= '-' . $takerOrMaker;
            }
            if ($orderType !== null) {
                $id .= '-' . $orderType;
            }
        }
        return $id;
    }

    public function fetch_ohlcv($symbol, $timeframe = '1m', $since = null, $limit = null, $params = array ()) {
        return Async\async(function () use ($symbol, $timeframe, $since, $limit, $params) {
            /**
             * fetches historical candlestick $data containing the open, high, low, and close price, and the volume of a $market
             * @param {string} $symbol unified $symbol of the $market to fetch OHLCV $data for
             * @param {string} $timeframe the length of time each candle represents
             * @param {int|null} $since timestamp in ms of the earliest candle to fetch
             * @param {int|null} $limit the maximum amount of $candles to fetch
             * @param {array} $params extra parameters specific to the mexc3 api endpoint
             * @return {[[int]]} A list of $candles ordered as timestamp, open, high, low, close, volume
             */
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $options = $this->safe_value($this->options, 'timeframes', array());
            $timeframes = $this->safe_value($options, $market['type'], array());
            $timeframeValue = $this->safe_string($timeframes, $timeframe);
            $request = array(
                'symbol' => $market['id'],
                'interval' => $timeframeValue,
            );
            $candles = null;
            if ($market['spot']) {
                if ($since !== null) {
                    $request['startTime'] = $since;
                }
                if ($limit !== null) {
                    $request['limit'] = $limit;
                }
                $response = Async\await($this->spotPublicGetKlines (array_merge($request, $params)));
                //
                //     array(
                //       array(
                //         1640804880000,
                //         "47482.36",
                //         "47482.36",
                //         "47416.57",
                //         "47436.1",
                //         "3.550717",
                //         1640804940000,
                //         "168387.3"
                //       ),
                //     )
                //
                $candles = $response;
            } elseif ($market['swap']) {
                if ($since !== null) {
                    $request['start'] = intval($since / 1000);
                }
                $priceType = $this->safe_string($params, 'price', 'default');
                $params = $this->omit($params, 'price');
                $method = $this->get_supported_mapping($priceType, array(
                    'default' => 'contractPublicGetKlineSymbol',
                    'index' => 'contractPublicGetKlineIndexPriceSymbol',
                    'mark' => 'contractPublicGetKlineFairPriceSymbol',
                ));
                $response = Async\await($this->$method (array_merge($request, $params)));
                //
                //     {
                //         "success":true,
                //         "code":0,
                //         "data":{
                //             "time":[1634052300,1634052360,1634052420],
                //             "open":[3492.2,3491.3,3495.65],
                //             "close":[3491.3,3495.65,3495.2],
                //             "high":[3495.85,3496.55,3499.4],
                //             "low":[3491.15,3490.9,3494.2],
                //             "vol":[1740.0,351.0,314.0],
                //             "amount":[60793.623,12260.4885,10983.1375],
                //         }
                //     }
                //
                $data = $this->safe_value($response, 'data');
                $candles = $this->convert_trading_view_to_ohlcv($data, 'time', 'open', 'high', 'low', 'close', 'vol');
            }
            return $this->parse_ohlcvs($candles, $market, $timeframe, $since, $limit);
        }) ();
    }

    public function parse_ohlcv($ohlcv, $market = null) {
        return array(
            $this->safe_integer($ohlcv, 0),
            $this->safe_number($ohlcv, 1),
            $this->safe_number($ohlcv, 2),
            $this->safe_number($ohlcv, 3),
            $this->safe_number($ohlcv, 4),
            $this->safe_number($ohlcv, 5),
        );
    }

    public function fetch_tickers($symbols = null, $params = array ()) {
        return Async\async(function () use ($symbols, $params) {
            /**
             * fetches price $tickers for multiple markets, statistical calculations with the information calculated over the past 24 hours each $market
             * @param {[string]|null} $symbols unified $symbols of the markets to fetch the ticker for, all $market $tickers are returned if not assigned
             * @param {array} $params extra parameters specific to the mexc3 api endpoint
             * @return {array} an array of {@link https://docs.ccxt.com/en/latest/manual.html#ticker-structure ticker structures}
             */
            Async\await($this->load_markets());
            $request = array();
            $market = null;
            $isSingularMarket = false;
            if ($symbols !== null) {
                $length = count($symbols);
                $isSingularMarket = $length === 1;
                $firstSymbol = $this->safe_string($symbols, 0);
                $market = $this->market($firstSymbol);
            }
            list($marketType, $query) = $this->handle_market_type_and_params('fetchTickers', $market, $params);
            $tickers = null;
            if ($isSingularMarket) {
                $request['symbol'] = $market['id'];
            }
            if ($marketType === 'spot') {
                $tickers = Async\await($this->spotPublicGetTicker24hr (array_merge($request, $query)));
                //
                //     array(
                //         {
                //             "symbol" => "BTCUSDT",
                //             "priceChange" => "184.34",
                //             "priceChangePercent" => "0.00400048",
                //             "prevClosePrice" => "46079.37",
                //             "lastPrice" => "46263.71",
                //             "lastQty" => "",
                //             "bidPrice" => "46260.38",
                //             "bidQty" => "",
                //             "askPrice" => "46260.41",
                //             "askQty" => "",
                //             "openPrice" => "46079.37",
                //             "highPrice" => "47550.01",
                //             "lowPrice" => "45555.5",
                //             "volume" => "1732.461487",
                //             "quoteVolume" => null,
                //             "openTime" => 1641349500000,
                //             "closeTime" => 1641349582808,
                //             "count" => null
                //         }
                //     )
                //
            } elseif ($marketType === 'swap') {
                $response = Async\await($this->contractPublicGetTicker (array_merge($request, $query)));
                //
                //     {
                //         "success":true,
                //         "code":0,
                //         "data":array(
                //             array(
                //                 "symbol":"ETH_USDT",
                //                 "lastPrice":3581.3,
                //                 "bid1":3581.25,
                //                 "ask1":3581.5,
                //                 "volume24":4045530,
                //                 "amount24":141331823.5755,
                //                 "holdVol":5832946,
                //                 "lower24Price":3413.4,
                //                 "high24Price":3588.7,
                //                 "riseFallRate":0.0275,
                //                 "riseFallValue":95.95,
                //                 "indexPrice":3580.7852,
                //                 "fairPrice":3581.08,
                //                 "fundingRate":0.000063,
                //                 "maxBidPrice":3938.85,
                //                 "minAskPrice":3222.7,
                //                 "timestamp":1634162885016
                //             ),
                //         )
                //     }
                //
                $tickers = $this->safe_value($response, 'data', array());
            }
            // when it's single symbol $request, the returned structure is different (singular object) for both spot & swap, thus we need to wrap inside array
            if ($isSingularMarket) {
                $tickers = array( $tickers );
            }
            return $this->parse_tickers($tickers, $symbols);
        }) ();
    }

    public function fetch_ticker($symbol, $params = array ()) {
        return Async\async(function () use ($symbol, $params) {
            /**
             * fetches a price $ticker, a statistical calculation with the information calculated over the past 24 hours for a specific $market
             * @param {string} $symbol unified $symbol of the $market to fetch the $ticker for
             * @param {array} $params extra parameters specific to the mexc3 api endpoint
             * @return {array} a {@link https://docs.ccxt.com/en/latest/manual.html#$ticker-structure $ticker structure}
             */
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            list($marketType, $query) = $this->handle_market_type_and_params('fetchTicker', $market, $params);
            $ticker = null;
            $request = array(
                'symbol' => $market['id'],
            );
            if ($marketType === 'spot') {
                $ticker = Async\await($this->spotPublicGetTicker24hr (array_merge($request, $query)));
                //
                //     {
                //         "symbol" => "BTCUSDT",
                //         "priceChange" => "184.34",
                //         "priceChangePercent" => "0.00400048",
                //         "prevClosePrice" => "46079.37",
                //         "lastPrice" => "46263.71",
                //         "lastQty" => "",
                //         "bidPrice" => "46260.38",
                //         "bidQty" => "",
                //         "askPrice" => "46260.41",
                //         "askQty" => "",
                //         "openPrice" => "46079.37",
                //         "highPrice" => "47550.01",
                //         "lowPrice" => "45555.5",
                //         "volume" => "1732.461487",
                //         "quoteVolume" => null,
                //         "openTime" => 1641349500000,
                //         "closeTime" => 1641349582808,
                //         "count" => null
                //     }
                //
            } elseif ($marketType === 'swap') {
                $response = Async\await($this->contractPublicGetTicker (array_merge($request, $query)));
                //
                //     {
                //         "success":true,
                //         "code":0,
                //         "data":{
                //             "symbol":"ETH_USDT",
                //             "lastPrice":3581.3,
                //             "bid1":3581.25,
                //             "ask1":3581.5,
                //             "volume24":4045530,
                //             "amount24":141331823.5755,
                //             "holdVol":5832946,
                //             "lower24Price":3413.4,
                //             "high24Price":3588.7,
                //             "riseFallRate":0.0275,
                //             "riseFallValue":95.95,
                //             "indexPrice":3580.7852,
                //             "fairPrice":3581.08,
                //             "fundingRate":0.000063,
                //             "maxBidPrice":3938.85,
                //             "minAskPrice":3222.7,
                //             "timestamp":1634162885016
                //         }
                //     }
                //
                $ticker = $this->safe_value($response, 'data', array());
            }
            // when it's single $symbol $request, the returned structure is different (singular object) for both spot & swap, thus we need to wrap inside array
            return $this->parse_ticker($ticker, $symbol);
        }) ();
    }

    public function parse_ticker($ticker, $market = null) {
        $marketId = $this->safe_string($ticker, 'symbol');
        $market = $this->safe_market($marketId, $market);
        $timestamp = null;
        $bid = null;
        $ask = null;
        $bidVolume = null;
        $askVolume = null;
        $baseVolume = null;
        $quoteVolume = null;
        $open = null;
        $high = null;
        $low = null;
        $changePcnt = null;
        $changeValue = null;
        $prevClose = null;
        $isSwap = $this->safe_value($market, 'swap');
        // if swap
        if ($isSwap || (is_array($ticker) && array_key_exists('timestamp', $ticker))) {
            //
            //     {
            //         "symbol":"ETH_USDT",
            //         "lastPrice":3581.3,
            //         "bid1":3581.25,
            //         "ask1":3581.5,
            //         "volume24":4045530,
            //         "amount24":141331823.5755,
            //         "holdVol":5832946,
            //         "lower24Price":3413.4,
            //         "high24Price":3588.7,
            //         "riseFallRate":0.0275,
            //         "riseFallValue":95.95,
            //         "indexPrice":3580.7852,
            //         "fairPrice":3581.08,
            //         "fundingRate":0.000063,
            //         "maxBidPrice":3938.85,
            //         "minAskPrice":3222.7,
            //         "timestamp":1634162885016
            //     }
            //
            $timestamp = $this->safe_integer($ticker, 'timestamp');
            $bid = $this->safe_number($ticker, 'bid1');
            $ask = $this->safe_number($ticker, 'ask1');
            $baseVolume = $this->safe_string($ticker, 'volume24');
            $quoteVolume = $this->safe_string($ticker, 'amount24');
            $high = $this->safe_number($ticker, 'high24Price');
            $low = $this->safe_number($ticker, 'lower24Price');
            $changeValue = $this->safe_string($ticker, 'riseFallValue');
            $changePcnt = $this->safe_string($ticker, 'riseFallRate');
            $changePcnt = $this->parse_number(Precise::string_mul($changePcnt, '100'));
        } else {
            //
            //     {
            //         "symbol" => "BTCUSDT",
            //         "priceChange" => "184.34",
            //         "priceChangePercent" => "0.00400048",
            //         "prevClosePrice" => "46079.37",
            //         "lastPrice" => "46263.71",
            //         "lastQty" => "",
            //         "bidPrice" => "46260.38",
            //         "bidQty" => "",
            //         "askPrice" => "46260.41",
            //         "askQty" => "",
            //         "openPrice" => "46079.37",
            //         "highPrice" => "47550.01",
            //         "lowPrice" => "45555.5",
            //         "volume" => "1732.461487",
            //         "quoteVolume" => null,
            //         "openTime" => 1641349500000,
            //         "closeTime" => 1641349582808,
            //         "count" => null
            //     }
            //
            $timestamp = $this->safe_integer($ticker, 'closeTime');
            $bid = $this->safe_number($ticker, 'bidPrice');
            $ask = $this->safe_number($ticker, 'askPrice');
            $bidVolume = $this->safe_number($ticker, 'bidQty');
            $askVolume = $this->safe_number($ticker, 'askQty');
            if ($bidVolume === 0) {
                $bidVolume = null;
            }
            if ($askVolume === 0) {
                $askVolume = null;
            }
            $baseVolume = $this->safe_string($ticker, 'volume');
            $quoteVolume = $this->safe_string($ticker, 'quoteVolume');
            $open = $this->safe_string($ticker, 'openPrice');
            $high = $this->safe_number($ticker, 'highPrice');
            $low = $this->safe_number($ticker, 'lowPrice');
            $prevClose = $this->safe_string($ticker, 'prevClosePrice');
            $changeValue = $this->safe_string($ticker, 'priceChange');
            $changePcnt = $this->safe_string($ticker, 'priceChangePercent');
            $changePcnt = $this->parse_number(Precise::string_mul($changePcnt, '100'));
        }
        return $this->safe_ticker(array(
            'symbol' => $market['symbol'],
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'open' => $open,
            'high' => $high,
            'low' => $low,
            'close' => $this->safe_string($ticker, 'lastPrice'),
            'bid' => $bid,
            'bidVolume' => $bidVolume,
            'ask' => $ask,
            'askVolume' => $askVolume,
            'vwap' => null,
            'previousClose' => $prevClose,
            'change' => $changeValue,
            'percentage' => $changePcnt,
            'average' => null,
            'baseVolume' => $baseVolume,
            'quoteVolume' => $quoteVolume,
            'info' => $ticker,
        ), $market);
    }

    public function fetch_bids_asks($symbols = null, $params = array ()) {
        return Async\async(function () use ($symbols, $params) {
            /**
             * fetches the bid and ask price and volume for multiple markets
             * @param {[string]|null} $symbols unified $symbols of the markets to fetch the bids and asks for, all markets are returned if not assigned
             * @param {array} $params extra parameters specific to the mexc3 api endpoint
             * @return {array} an array of {@link https://docs.ccxt.com/en/latest/manual.html#ticker-structure ticker structures}
             */
            Async\await($this->load_markets());
            $market = null;
            $isSingularMarket = false;
            if ($symbols !== null) {
                $length = count($symbols);
                $isSingularMarket = $length === 1;
                $market = $this->market($symbols[0]);
            }
            list($marketType, $query) = $this->handle_market_type_and_params('fetchBidsAsks', $market, $params);
            $tickers = null;
            if ($marketType === 'spot') {
                $tickers = Async\await($this->spotPublicGetTickerBookTicker ($query));
                //
                //     array(
                //       array(
                //         "symbol" => "AEUSDT",
                //         "bidPrice" => "0.11001",
                //         "bidQty" => "115.59",
                //         "askPrice" => "0.11127",
                //         "askQty" => "215.48"
                //       ),
                //     )
                //
            } elseif ($marketType === 'swap') {
                throw new NotSupported($this->id . ' fetchBidsAsks() is not available for ' . $marketType . ' markets');
            }
            // when it's single symbol request, the returned structure is different (singular object) for both spot & swap, thus we need to wrap inside array
            if ($isSingularMarket) {
                $tickers = array( $tickers );
            }
            return $this->parse_tickers($tickers, $symbols);
        }) ();
    }

    public function create_order($symbol, $type, $side, $amount, $price = null, $params = array ()) {
        return Async\async(function () use ($symbol, $type, $side, $amount, $price, $params) {
            /**
             * create a trade order
             * @param {string} $symbol unified $symbol of the $market to create an order in
             * @param {string} $type 'market' or 'limit'
             * @param {string} $side 'buy' or 'sell'
             * @param {float} $amount how much of currency you want to trade in units of base currency
             * @param {float|null} $price the $price at which the order is to be fullfilled, in units of the quote currency, ignored in $market orders
             * @param {array} $params extra parameters specific to the mexc3 api endpoint
             * @param {string|null} $params->marginMode only 'isolated' is supported for spot-margin trading
             * @return {array} an {@link https://docs.ccxt.com/en/latest/manual.html#order-structure order structure}
             */
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            list($marginMode, $query) = $this->handle_margin_mode_and_params('createOrder', $params);
            if ($market['spot']) {
                return Async\await($this->create_spot_order($market, $type, $side, $amount, $price, $marginMode, $query));
            } elseif ($market['swap']) {
                return Async\await($this->create_swap_order($market, $type, $side, $amount, $price, $marginMode, $query));
            }
        }) ();
    }

    public function create_spot_order($market, $type, $side, $amount, $price = null, $marginMode = null, $params = array ()) {
        return Async\async(function () use ($market, $type, $side, $amount, $price, $marginMode, $params) {
            $symbol = $market['symbol'];
            $orderSide = ($side === 'buy') ? 'BUY' : 'SELL';
            $request = array(
                'symbol' => $market['id'],
                'side' => $orderSide,
                'type' => strtoupper($type),
            );
            if ($orderSide === 'BUY' && $type === 'market') {
                $quoteOrderQty = $this->safe_number($params, 'quoteOrderQty');
                if ($quoteOrderQty !== null) {
                    $amount = $quoteOrderQty;
                } elseif ($this->options['createMarketBuyOrderRequiresPrice']) {
                    if ($price === null) {
                        throw new InvalidOrder($this->id . " createOrder() requires the $price argument with $market buy orders to calculate total order cost ($amount to spend), where cost = $amount * $price-> Supply a $price argument to createOrder() call if you want the cost to be calculated for you from $price and $amount, or, alternatively, add .options['createMarketBuyOrderRequiresPrice'] = false to supply the cost in the $amount argument (the exchange-specific behaviour)");
                    } else {
                        $amountString = $this->number_to_string($amount);
                        $priceString = $this->number_to_string($price);
                        $quoteAmount = Precise::string_mul($amountString, $priceString);
                        $amount = $this->parse_number($quoteAmount);
                    }
                }
                $request['quoteOrderQty'] = $amount;
            } else {
                $request['quantity'] = $this->amount_to_precision($symbol, $amount);
            }
            if ($price !== null) {
                $request['price'] = $this->price_to_precision($symbol, $price);
            }
            $clientOrderId = $this->safe_string($params, 'clientOrderId');
            if ($clientOrderId !== null) {
                $request['newClientOrderId'] = $clientOrderId;
                $params = $this->omit($params, array( 'type', 'clientOrderId' ));
            }
            $method = 'spotPrivatePostOrder';
            if ($marginMode !== null) {
                if ($marginMode !== 'isolated') {
                    throw new BadRequest($this->id . ' createOrder() does not support $marginMode ' . $marginMode . ' for spot-margin trading');
                }
                $method = 'spotPrivatePostMarginOrder';
            }
            $response = Async\await($this->$method (array_merge($request, $params)));
            //
            // spot
            //
            //     {
            //         "symbol" => "BTCUSDT",
            //         "orderId" => "123738410679123456",
            //         "orderListId" => -1
            //     }
            //
            // margin
            //
            //     {
            //         "symbol" => "BTCUSDT",
            //         "orderId" => "762634301354414080",
            //         "clientOrderId" => null,
            //         "isIsolated" => true,
            //         "transactTime" => 1661992652132
            //     }
            //
            return array_merge($this->parse_order($response, $market), array(
                'side' => $side,
                'type' => $type,
                'price' => $price,
                'amount' => $amount,
            ));
        }) ();
    }

    public function create_swap_order($market, $type, $side, $amount, $price = null, $marginMode = null, $params = array ()) {
        return Async\async(function () use ($market, $type, $side, $amount, $price, $marginMode, $params) {
            Async\await($this->load_markets());
            $symbol = $market['symbol'];
            $unavailableContracts = $this->safe_value($this->options, 'unavailableContracts', array());
            $isContractUnavaiable = $this->safe_value($unavailableContracts, $symbol, false);
            if ($isContractUnavaiable) {
                throw new NotSupported($this->id . ' createSwapOrder() does not support yet this $symbol:' . $symbol);
            }
            $openType = null;
            if ($marginMode !== null) {
                if ($marginMode === 'cross') {
                    $openType = 2;
                } elseif ($marginMode === 'isolated') {
                    $openType = 1;
                } else {
                    throw new ArgumentsRequired($this->id . ' createSwapOrder() $marginMode parameter should be either "cross" or "isolated"');
                }
            } else {
                $openType = $this->safe_integer($params, 'openType', 2); // defaulting to cross margin
            }
            if (($type !== 'limit') && ($type !== 'market') && ($type !== 1) && ($type !== 2) && ($type !== 3) && ($type !== 4) && ($type !== 5) && ($type !== 6)) {
                throw new InvalidOrder($this->id . ' createSwapOrder() order $type must either limit, $market, or 1 for limit orders, 2 for post-only orders, 3 for IOC orders, 4 for FOK orders, 5 for $market orders or 6 to convert $market $price to current price');
            }
            $postOnly = $this->safe_value($params, 'postOnly', false);
            if ($postOnly) {
                $type = 2;
            } elseif ($type === 'limit') {
                $type = 1;
            } elseif ($type === 'market') {
                $type = 6;
            }
            $request = array(
                'symbol' => $market['id'],
                // 'price' => floatval($this->price_to_precision($symbol, $price)),
                'vol' => floatval($this->amount_to_precision($symbol, $amount)),
                // 'leverage' => int, // required for isolated margin
                // 'side' => $side, // 1 open long, 2 close short, 3 open short, 4 close long
                //
                // supported order types
                //
                //     1 limit
                //     2 post only maker (PO)
                //     3 transact or cancel instantly (IOC)
                //     4 transact completely or cancel completely (FOK)
                //     5 $market orders
                //     6 convert $market $price to current $price
                //
                'type' => $type,
                'openType' => $openType, // 1 isolated, 2 cross
                // 'positionId' => 1394650, // long, filling in this parameter when closing a position is recommended
                // 'externalOid' => $clientOrderId,
                // 'triggerPrice' => 10.0, // Required for trigger order
                // 'triggerType' => 1, // Required for trigger order 1 => more than or equal, 2 => less than or equal
                // 'executeCycle' => 1, // Required for trigger order 1 => 24 hours,2 => 7 days
                // 'trend' => 1, // Required for trigger order 1 => latest $price, 2 => fair $price, 3 => index $price
                // 'orderType' => 1, // Required for trigger order 1 => limit order,2:Post Only Maker,3 => close or cancel instantly ,4 => close or cancel completely,5 => Market order
            );
            $method = 'contractPrivatePostOrderSubmit';
            $stopPrice = $this->safe_number_2($params, 'triggerPrice', 'stopPrice');
            $params = $this->omit($params, array( 'stopPrice', 'triggerPrice' ));
            if ($stopPrice) {
                $method = 'contractPrivatePostPlanorderPlace';
                $request['triggerPrice'] = $this->price_to_precision($symbol, $stopPrice);
                $request['triggerType'] = $this->safe_integer($params, 'triggerType', 1);
                $request['executeCycle'] = $this->safe_integer($params, 'executeCycle', 1);
                $request['trend'] = $this->safe_integer($params, 'trend', 1);
                $request['orderType'] = $this->safe_integer($params, 'orderType', 1);
            }
            if (($type !== 5) && ($type !== 6) && ($type !== 'market')) {
                $request['price'] = floatval($this->price_to_precision($symbol, $price));
            }
            if ($openType === 1) {
                $leverage = $this->safe_integer($params, 'leverage');
                if ($leverage === null) {
                    throw new ArgumentsRequired($this->id . ' createSwapOrder() requires a $leverage parameter for isolated margin orders');
                }
            }
            $reduceOnly = $this->safe_value($params, 'reduceOnly', false);
            if ($reduceOnly) {
                $request['side'] = ($side === 'buy') ? 2 : 4;
            } else {
                $request['side'] = ($side === 'buy') ? 1 : 3;
            }
            $clientOrderId = $this->safe_string_2($params, 'clientOrderId', 'externalOid');
            if ($clientOrderId !== null) {
                $request['externalOid'] = $clientOrderId;
            }
            $params = $this->omit($params, array( 'clientOrderId', 'externalOid', 'postOnly' ));
            $response = Async\await($this->$method (array_merge($request, $params)));
            //
            // Swap
            //     array("code":200,"data":"2ff3163e8617443cb9c6fc19d42b1ca4")
            //
            // Trigger
            //     array("success":true,"code":0,"data":259208506303929856)
            //
            $data = $this->safe_string($response, 'data');
            return $this->parse_order($data, $market);
        }) ();
    }

    public function fetch_order($id, $symbol = null, $params = array ()) {
        return Async\async(function () use ($id, $symbol, $params) {
            /**
             * fetches information on an order made by the user
             * @param {string} $symbol unified $symbol of the $market the order was made in
             * @param {array} $params extra parameters specific to the mexc3 api endpoint
             * @param {string|null} $params->marginMode only 'isolated' is supported, for spot-margin trading
             * @return {array} An {@link https://docs.ccxt.com/en/latest/manual.html#order-structure order structure}
             */
            if ($symbol === null) {
                throw new ArgumentsRequired($this->id . ' fetchOrder() requires a $symbol argument');
            }
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $request = array(
                'symbol' => $market['id'],
            );
            $data = null;
            if ($market['spot']) {
                $clientOrderId = $this->safe_string($params, 'clientOrderId');
                if ($clientOrderId !== null) {
                    $params = $this->omit($params, 'clientOrderId');
                    $request['origClientOrderId'] = $clientOrderId;
                } else {
                    $request['orderId'] = $id;
                }
                list($marginMode, $query) = $this->handle_margin_mode_and_params('fetchOrder', $params);
                $method = 'spotPrivateGetOrder';
                if ($marginMode !== null) {
                    if ($marginMode !== 'isolated') {
                        throw new BadRequest($this->id . ' fetchOrder() does not support $marginMode ' . $marginMode . ' for spot-margin trading');
                    }
                    $method = 'spotPrivateGetMarginOrder';
                }
                $data = Async\await($this->$method (array_merge($request, $query)));
                //
                // spot
                //
                //     {
                //         "symbol" => "BTCUSDT",
                //         "orderId" => "133734823834147272",
                //         "orderListId" => "-1",
                //         "clientOrderId" => null,
                //         "price" => "30000",
                //         "origQty" => "0.0002",
                //         "executedQty" => "0",
                //         "cummulativeQuoteQty" => "0",
                //         "status" => "CANCELED",
                //         "timeInForce" => null,
                //         "type" => "LIMIT",
                //         "side" => "BUY",
                //         "stopPrice" => null,
                //         "icebergQty" => null,
                //         "time" => "1647667102000",
                //         "updateTime" => "1647708567000",
                //         "isWorking" => true,
                //         "origQuoteOrderQty" => "6"
                //     }
                //
                // margin
                //
                //     {
                //         "symbol" => "BTCUSDT",
                //         "orderId" => "763307297891028992",
                //         "orderListId" => "-1",
                //         "clientOrderId" => null,
                //         "price" => "18000",
                //         "origQty" => "0.0014",
                //         "executedQty" => "0",
                //         "cummulativeQuoteQty" => "0",
                //         "status" => "NEW",
                //         "type" => "LIMIT",
                //         "side" => "BUY",
                //         "isIsolated" => true,
                //         "isWorking" => true,
                //         "time" => 1662153107000,
                //         "updateTime" => 1662153107000
                //     }
                //
            } elseif ($market['swap']) {
                $request['order_id'] = $id;
                $response = Async\await($this->contractPrivateGetOrderGetOrderId (array_merge($request, $params)));
                //
                //     {
                //         "success" => true,
                //         "code" => "0",
                //         "data" => {
                //             "orderId" => "264995729269765120",
                //             "symbol" => "STEPN_USDT",
                //             "positionId" => "0",
                //             "price" => "2.2",
                //             "vol" => "15",
                //             "leverage" => "20",
                //             "side" => "1",
                //             "category" => "1",
                //             "orderType" => "1",
                //             "dealAvgPrice" => "0",
                //             "dealVol" => "0",
                //             "orderMargin" => "2.2528",
                //             "takerFee" => "0",
                //             "makerFee" => "0",
                //             "profit" => "0",
                //             "feeCurrency" => "USDT",
                //             "openType" => "1",
                //             "state" => "2",
                //             "externalOid" => "_m_0e9520c256744d64b942985189026d20",
                //             "errorCode" => "0",
                //             "usedMargin" => "0",
                //             "createTime" => "1648850305236",
                //             "updateTime" => "1648850305245",
                //             "positionMode" => "1"
                //         }
                //     }
                //
                $data = $this->safe_value($response, 'data');
            }
            return $this->parse_order($data, $market);
        }) ();
    }

    public function fetch_orders($symbol = null, $since = null, $limit = null, $params = array ()) {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            /**
             * fetches information on multiple orders made by the user
             * @param {string|null} $symbol unified $market $symbol of the $market orders were made in
             * @param {int|null} $since the earliest time in ms to fetch orders for
             * @param {int|null} $limit the maximum number of  orde structures to retrieve
             * @param {array} $params extra parameters specific to the mexc3 api endpoint
             * @param {string|null} $params->marginMode only 'isolated' is supported, for spot-margin trading
             * @return {[array]} a list of {@link https://docs.ccxt.com/en/latest/manual.html#order-structure order structures}
             */
            Async\await($this->load_markets());
            $request = array();
            $market = null;
            if ($symbol !== null) {
                $market = $this->market($symbol);
                $request['symbol'] = $market['id'];
            }
            list($marketType, $query) = $this->handle_market_type_and_params('fetchOrders', $market, $params);
            if ($marketType === 'spot') {
                if ($symbol === null) {
                    throw new ArgumentsRequired($this->id . ' fetchOrders() requires a $symbol argument for spot market');
                }
                list($marginMode, $query) = $this->handle_margin_mode_and_params('fetchOrders', $params);
                $method = 'spotPrivateGetAllOrders';
                if ($marginMode !== null) {
                    if ($marginMode !== 'isolated') {
                        throw new BadRequest($this->id . ' fetchOrders() does not support $marginMode ' . $marginMode . ' for spot-margin trading');
                    }
                    $method = 'spotPrivateGetMarginAllOrders';
                }
                if ($since !== null) {
                    $request['startTime'] = $since;
                }
                if ($limit !== null) {
                    $request['limit'] = $limit;
                }
                $response = Async\await($this->$method (array_merge($request, $query)));
                //
                // spot
                //
                //     array(
                //         array(
                //             "symbol" => "BTCUSDT",
                //             "orderId" => "133949373632483328",
                //             "orderListId" => "-1",
                //             "clientOrderId" => null,
                //             "price" => "45000",
                //             "origQty" => "0.0002",
                //             "executedQty" => "0",
                //             "cummulativeQuoteQty" => "0",
                //             "status" => "NEW",
                //             "timeInForce" => null,
                //             "type" => "LIMIT",
                //             "side" => "SELL",
                //             "stopPrice" => null,
                //             "icebergQty" => null,
                //             "time" => "1647718255000",
                //             "updateTime" => "1647718255000",
                //             "isWorking" => true,
                //             "origQuoteOrderQty" => "9"
                //         ),
                //     )
                //
                // margin
                //
                //     array(
                //         {
                //             "symbol" => "BTCUSDT",
                //             "orderId" => "763307297891028992",
                //             "orderListId" => "-1",
                //             "clientOrderId" => null,
                //             "price" => "18000",
                //             "origQty" => "0.0014",
                //             "executedQty" => "0",
                //             "cummulativeQuoteQty" => "0",
                //             "status" => "NEW",
                //             "type" => "LIMIT",
                //             "side" => "BUY",
                //             "isIsolated" => true,
                //             "isWorking" => true,
                //             "time" => 1662153107000,
                //             "updateTime" => 1662153107000
                //         }
                //     )
                //
                return $this->parse_orders($response, $market, $since, $limit);
            } else {
                if ($since !== null) {
                    $request['start_time'] = $since;
                    $end = $this->safe_integer($params, 'end_time');
                    if ($end === null) {
                        $request['end_time'] = $this->sum($since, $this->options['maxTimeTillEnd']);
                    }
                }
                if ($limit !== null) {
                    $request['page_size'] = $limit;
                }
                $method = $this->safe_string($this->options, 'fetchOrders', 'contractPrivateGetOrderListHistoryOrders');
                $method = $this->safe_string($query, 'method', $method);
                $ordersOfRegular = array();
                $ordersOfTrigger = array();
                if ($method === 'contractPrivateGetOrderListHistoryOrders') {
                    $response = Async\await($this->contractPrivateGetOrderListHistoryOrders (array_merge($request, $query)));
                    //
                    //     {
                    //         "success" => true,
                    //         "code" => "0",
                    //         "data" => array(
                    //             array(
                    //                 "orderId" => "265230764677709315",
                    //                 "symbol" => "STEPN_USDT",
                    //                 "positionId" => "0",
                    //                 "price" => "2.1",
                    //                 "vol" => "102",
                    //                 "leverage" => "20",
                    //                 "side" => "1",
                    //                 "category" => "1",
                    //                 "orderType" => "1",
                    //                 "dealAvgPrice" => "0",
                    //                 "dealVol" => "0",
                    //                 "orderMargin" => "10.96704",
                    //                 "takerFee" => "0",
                    //                 "makerFee" => "0",
                    //                 "profit" => "0",
                    //                 "feeCurrency" => "USDT",
                    //                 "openType" => "1",
                    //                 "state" => "2",
                    //                 "externalOid" => "_m_7e42f8df6b324c869e4e200397e2b00f",
                    //                 "errorCode" => "0",
                    //                 "usedMargin" => "0",
                    //                 "createTime" => "1648906342000",
                    //                 "updateTime" => "1648906342000",
                    //                 "positionMode" => "1"
                    //             ),
                    //          )
                    //     }
                    //
                    $ordersOfRegular = $this->safe_value($response, 'data');
                } else {
                    // the Planorder endpoints work not only for stop-$market orders, but also for stop-$limit orders that were supposed to have a separate endpoint
                    $response = Async\await($this->contractPrivateGetPlanorderListOrders (array_merge($request, $query)));
                    //
                    //     {
                    //         "success" => true,
                    //         "code" => "0",
                    //         "data" => array(
                    //             array(
                    //                 "symbol" => "STEPN_USDT",
                    //                 "leverage" => "20",
                    //                 "side" => "1",
                    //                 "vol" => "13",
                    //                 "openType" => "1",
                    //                 "state" => "1",
                    //                 "orderType" => "1",
                    //                 "errorCode" => "0",
                    //                 "createTime" => "1648984276000",
                    //                 "updateTime" => "1648984276000",
                    //                 "id" => "265557643326564352",
                    //                 "triggerType" => "1",
                    //                 "triggerPrice" => "3",
                    //                 "price" => "2.9", // not present in stop-$market, but in stop-$limit order
                    //                 "executeCycle" => "87600",
                    //                 "trend" => "1",
                    //             ),
                    //         )
                    //     }
                    //
                    $ordersOfTrigger = $this->safe_value($response, 'data');
                }
                $merged = $this->array_concat($ordersOfTrigger, $ordersOfRegular);
                return $this->parse_orders($merged, $market, $since, $limit, $params);
            }
        }) ();
    }

    public function fetch_orders_by_ids($ids, $symbol = null, $params = array ()) {
        return Async\async(function () use ($ids, $symbol, $params) {
            Async\await($this->load_markets());
            $request = array();
            $market = null;
            if ($symbol !== null) {
                $market = $this->market($symbol);
                $request['symbol'] = $market['id'];
            }
            list($marketType, $query) = $this->handle_market_type_and_params('fetchOrdersByIds', $market, $params);
            if ($marketType === 'spot') {
                throw new BadRequest($this->id . ' fetchOrdersByIds() is not supported for ' . $marketType);
            } else {
                $request['order_ids'] = implode(',', $ids);
                $response = Async\await($this->contractPrivateGetOrderBatchQuery (array_merge($request, $query)));
                //
                //     {
                //         "success" => true,
                //         "code" => "0",
                //         "data" => array(
                //             {
                //                 "orderId" => "265230764677709315",
                //                 "symbol" => "STEPN_USDT",
                //                 "positionId" => "0",
                //                 "price" => "2.1",
                //                 "vol" => "102",
                //                 "leverage" => "20",
                //                 "side" => "1",
                //                 "category" => "1",
                //                 "orderType" => "1",
                //                 "dealAvgPrice" => "0",
                //                 "dealVol" => "0",
                //                 "orderMargin" => "10.96704",
                //                 "takerFee" => "0",
                //                 "makerFee" => "0",
                //                 "profit" => "0",
                //                 "feeCurrency" => "USDT",
                //                 "openType" => "1",
                //                 "state" => "2",
                //                 "externalOid" => "_m_7e42f8df6b324c869e4e200397e2b00f",
                //                 "errorCode" => "0",
                //                 "usedMargin" => "0",
                //                 "createTime" => "1648906342000",
                //                 "updateTime" => "1648906342000",
                //                 "positionMode" => "1"
                //             }
                //         )
                //     }
                //
                $data = $this->safe_value($response, 'data');
                return $this->parse_orders($data, $market);
            }
        }) ();
    }

    public function fetch_open_orders($symbol = null, $since = null, $limit = null, $params = array ()) {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            /**
             * fetch all unfilled currently open orders
             * @param {string|null} $symbol unified $market $symbol
             * @param {int|null} $since the earliest time in ms to fetch open orders for
             * @param {int|null} $limit the maximum number of  open orders structures to retrieve
             * @param {array} $params extra parameters specific to the mexc3 api endpoint
             * @param {string|null} $params->marginMode only 'isolated' is supported, for spot-margin trading
             * @return {[array]} a list of {@link https://docs.ccxt.com/en/latest/manual.html#order-structure order structures}
             */
            Async\await($this->load_markets());
            $request = array();
            $market = null;
            if ($symbol !== null) {
                $market = $this->market($symbol);
                $request['symbol'] = $market['id'];
            }
            $marketType = null;
            list($marketType, $params) = $this->handle_market_type_and_params('fetchOpenOrders', $market, $params);
            if ($marketType === 'spot') {
                if ($symbol === null) {
                    throw new ArgumentsRequired($this->id . ' fetchOpenOrders() requires a $symbol argument for spot market');
                }
                $method = 'spotPrivateGetOpenOrders';
                list($marginMode, $query) = $this->handle_margin_mode_and_params('fetchOpenOrders', $params);
                if ($marginMode !== null) {
                    if ($marginMode !== 'isolated') {
                        throw new BadRequest($this->id . ' fetchOpenOrders() does not support $marginMode ' . $marginMode . ' for spot-margin trading');
                    }
                    $method = 'spotPrivateGetMarginOpenOrders';
                }
                $response = Async\await($this->$method (array_merge($request, $query)));
                //
                // spot
                //
                //     array(
                //         {
                //             "symbol" => "BTCUSDT",
                //             "orderId" => "133949373632483328",
                //             "orderListId" => "-1",
                //             "clientOrderId" => "",
                //             "price" => "45000",
                //             "origQty" => "0.0002",
                //             "executedQty" => "0",
                //             "cummulativeQuoteQty" => "0",
                //             "status" => "NEW",
                //             "timeInForce" => null,
                //             "type" => "LIMIT",
                //             "side" => "SELL",
                //             "stopPrice" => null,
                //             "icebergQty" => null,
                //             "time" => "1647718255199",
                //             "updateTime" => null,
                //             "isWorking" => true,
                //             "origQuoteOrderQty" => "9"
                //         }
                //     )
                //
                // margin
                //
                //     array(
                //         {
                //             "symbol" => "BTCUSDT",
                //             "orderId" => "764547676405633024",
                //             "orderListId" => "-1",
                //             "clientOrderId" => null,
                //             "price" => "18000",
                //             "origQty" => "0.0013",
                //             "executedQty" => "0",
                //             "cummulativeQuoteQty" => "0",
                //             "status" => "NEW",
                //             "type" => "LIMIT",
                //             "side" => "BUY",
                //             "isIsolated" => true,
                //             "isWorking" => true,
                //             "time" => 1662448836000,
                //             "updateTime" => 1662448836000
                //         }
                //     )
                //
                return $this->parse_orders($response, $market, $since, $limit);
            } else {
                // TO_DO => another possible way is through => open_orders/{$symbol}, but as they have same ratelimits, and less granularity, i think historical orders are more convenient, as it supports more $params (however, theoretically, open-orders endpoint might be sligthly fast)
                return Async\await($this->fetch_orders_by_state(2, $symbol, $since, $limit, $params));
            }
        }) ();
    }

    public function fetch_closed_orders($symbol = null, $since = null, $limit = null, $params = array ()) {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            /**
             * fetches information on multiple closed orders made by the user
             * @param {string|null} $symbol unified market $symbol of the market orders were made in
             * @param {int|null} $since the earliest time in ms to fetch orders for
             * @param {int|null} $limit the maximum number of  orde structures to retrieve
             * @param {array} $params extra parameters specific to the mexc3 api endpoint
             * @return {[array]} a list of {@link https://docs.ccxt.com/en/latest/manual.html#order-structure order structures}
             */
            return Async\await($this->fetch_orders_by_state(3, $symbol, $since, $limit, $params));
        }) ();
    }

    public function fetch_canceled_orders($symbol = null, $since = null, $limit = null, $params = array ()) {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            /**
             * fetches information on multiple canceled orders made by the user
             * @param {string|null} $symbol unified market $symbol of the market orders were made in
             * @param {int|null} $since timestamp in ms of the earliest order, default is null
             * @param {int|null} $limit max number of orders to return, default is null
             * @param {array} $params extra parameters specific to the mexc3 api endpoint
             * @return {array} a list of {@link https://docs.ccxt.com/en/latest/manual.html#order-structure order structures}
             */
            return Async\await($this->fetch_orders_by_state(4, $symbol, $since, $limit, $params));
        }) ();
    }

    public function fetch_orders_by_state($state, $symbol = null, $since = null, $limit = null, $params = array ()) {
        return Async\async(function () use ($state, $symbol, $since, $limit, $params) {
            Async\await($this->load_markets());
            $request = array();
            $market = null;
            if ($symbol !== null) {
                $market = $this->market($symbol);
                $request['symbol'] = $market['id'];
            }
            list($marketType) = $this->handle_market_type_and_params('fetchOrdersByState', $market, $params);
            if ($marketType === 'spot') {
                throw new BadRequest($this->id . ' fetchOrdersByState() is not supported for ' . $marketType);
            } else {
                $params['states'] = $state;
                return $this->fetch_orders($symbol, $since, $limit, $params);
            }
        }) ();
    }

    public function cancel_order($id, $symbol = null, $params = array ()) {
        return Async\async(function () use ($id, $symbol, $params) {
            /**
             * cancels an open $order
             * @param {string} $id $order $id
             * @param {string|null} $symbol unified $symbol of the $market the $order was made in
             * @param {array} $params extra parameters specific to the mexc3 api endpoint
             * @param {string|null} $params->marginMode only 'isolated' is supported for spot-margin trading
             * @return {array} An {@link https://docs.ccxt.com/en/latest/manual.html#$order-structure $order structure}
             */
            Async\await($this->load_markets());
            $request = array();
            $market = null;
            if ($symbol !== null) {
                $market = $this->market($symbol);
                $request['symbol'] = $market['id'];
            }
            $marketType = null;
            list($marketType, $params) = $this->handle_market_type_and_params('cancelOrder', $market, $params);
            list($marginMode, $query) = $this->handle_margin_mode_and_params('cancelOrder', $params);
            $data = null;
            if ($marketType === 'spot') {
                if ($symbol === null) {
                    throw new ArgumentsRequired($this->id . ' cancelOrder() requires a $symbol argument');
                }
                $request = array(
                    'symbol' => $market['id'],
                );
                $clientOrderId = $this->safe_string($params, 'clientOrderId');
                if ($clientOrderId !== null) {
                    $params = $this->omit($query, 'clientOrderId');
                    $request['origClientOrderId'] = $clientOrderId;
                } else {
                    $request['orderId'] = $id;
                }
                $method = 'spotPrivateDeleteOrder';
                if ($marginMode !== null) {
                    if ($marginMode !== 'isolated') {
                        throw new BadRequest($this->id . ' cancelOrder() does not support $marginMode ' . $marginMode . ' for spot-margin trading');
                    }
                    $method = 'spotPrivateDeleteMarginOrder';
                }
                $data = Async\await($this->$method (array_merge($request, $query)));
                //
                // spot
                //
                //     {
                //         "symbol" => "BTCUSDT",
                //         "orderId" => "133734823834447872",
                //         "price" => "30000",
                //         "origQty" => "0.0002",
                //         "type" => "LIMIT",
                //         "side" => "BUY"
                //     }
                //
                // margin
                //
                //     array(
                //         {
                //             "symbol" => "BTCUSDT",
                //             "orderId" => "762640232574226432",
                //             "orderListId" => "-1",
                //             "clientOrderId" => null,
                //             "price" => "18000",
                //             "origQty" => "0.00147",
                //             "executedQty" => "0",
                //             "cummulativeQuoteQty" => "0",
                //             "status" => "NEW",
                //             "type" => "LIMIT",
                //             "side" => "BUY",
                //             "isIsolated" => true,
                //             "isWorking" => true,
                //             "time" => 1661994066000,
                //             "updateTime" => 1661994066000
                //         }
                //     )
                //
            } else {
                // TODO => PlanorderCancel endpoint has bug atm. waiting for fix.
                $method = $this->safe_string($this->options, 'cancelOrder', 'contractPrivatePostOrderCancel'); // contractPrivatePostOrderCancel, contractPrivatePostPlanorderCancel
                $method = $this->safe_string($query, 'method', $method);
                $response = Async\await($this->$method (array( $id ))); // the $request cannot be changed or extended. This is the only way to send.
                //
                //     {
                //         "success" => true,
                //         "code" => "0",
                //         "data" => array(
                //             {
                //                 "orderId" => "264995729269765120",
                //                 "errorCode" => "0",         // if already canceled => "2041"; if doesn't exist => "2040"
                //                 "errorMsg" => "success",    // if already canceled => "order state cannot be cancelled"; if doesn't exist => "order not exist"
                //             }
                //         )
                //     }
                //
                $data = $this->safe_value($response, 'data');
                $order = $this->safe_value($data, 0);
                $errorMsg = $this->safe_value($order, 'errorMsg', '');
                if ($errorMsg !== 'success') {
                    throw new InvalidOrder($this->id . ' cancelOrder() the $order with $id ' . $id . ' cannot be cancelled => ' . $errorMsg);
                }
            }
            return $this->parse_order($data, $market);
        }) ();
    }

    public function cancel_orders($ids, $symbol = null, $params = array ()) {
        return Async\async(function () use ($ids, $symbol, $params) {
            /**
             * cancel multiple orders
             * @param {[string]} $ids order $ids
             * @param {string|null} $symbol unified $market $symbol, default is null
             * @param {array} $params extra parameters specific to the mexc3 api endpoint
             * @return {array} an list of {@link https://docs.ccxt.com/en/latest/manual.html#order-structure order structures}
             */
            Async\await($this->load_markets());
            $market = ($symbol !== null) ? $this->market($symbol) : null;
            list($marketType) = $this->handle_market_type_and_params('cancelOrders', $market, $params);
            if ($marketType === 'spot') {
                throw new BadRequest($this->id . ' cancelOrders() is not supported for ' . $marketType);
            } else {
                $response = Async\await($this->contractPrivatePostOrderCancel ($ids)); // the request cannot be changed or extended. The only way to send.
                //
                //     {
                //         "success" => true,
                //         "code" => "0",
                //         "data" => array(
                //             array(
                //                 "orderId" => "264995729269765120",
                //                 "errorCode" => "0",         // if already canceled => "2041"
                //                 "errorMsg" => "success",    // if already canceled => "order state cannot be cancelled"
                //             ),
                //         )
                //     }
                //
                $data = $this->safe_value($response, 'data');
                return $this->parse_orders($data, $market);
            }
        }) ();
    }

    public function cancel_all_orders($symbol = null, $params = array ()) {
        return Async\async(function () use ($symbol, $params) {
            /**
             * cancel all open orders
             * @param {string|null} $symbol unified $market $symbol, only orders in the $market of this $symbol are cancelled when $symbol is not null
             * @param {array} $params extra parameters specific to the mexc3 api endpoint
             * @param {string|null} $params->marginMode only 'isolated' is supported for spot-margin trading
             * @return {[array]} a list of {@link https://docs.ccxt.com/en/latest/manual.html#order-structure order structures}
             */
            Async\await($this->load_markets());
            $market = ($symbol !== null) ? $this->market($symbol) : null;
            $request = array();
            $marketType = null;
            list($marketType, $params) = $this->handle_market_type_and_params('cancelAllOrders', $market, $params);
            list($marginMode, $query) = $this->handle_margin_mode_and_params('cancelAllOrders', $params);
            if ($marketType === 'spot') {
                if ($symbol === null) {
                    throw new ArgumentsRequired($this->id . ' cancelAllOrders() requires a $symbol argument on spot');
                }
                $request['symbol'] = $market['id'];
                $method = 'spotPrivateDeleteOpenOrders';
                if ($marginMode !== null) {
                    if ($marginMode !== 'isolated') {
                        throw new BadRequest($this->id . ' cancelAllOrders() does not support $marginMode ' . $marginMode . ' for spot-margin trading');
                    }
                    $method = 'spotPrivateDeleteMarginOpenOrders';
                }
                $response = Async\await($this->$method (array_merge($request, $query)));
                //
                // spot
                //
                //     array(
                //         array(
                //             "symbol" => "BTCUSDT",
                //             "orderId" => "133926492139692032",
                //             "price" => "30000",
                //             "origQty" => "0.0002",
                //             "type" => "LIMIT",
                //             "side" => "BUY"
                //         ),
                //     )
                //
                // margin
                //
                //     array(
                //         {
                //             "symbol" => "BTCUSDT",
                //             "orderId" => "762640232574226432",
                //             "orderListId" => "-1",
                //             "clientOrderId" => null,
                //             "price" => "18000",
                //             "origQty" => "0.00147",
                //             "executedQty" => "0",
                //             "cummulativeQuoteQty" => "0",
                //             "status" => "NEW",
                //             "type" => "LIMIT",
                //             "side" => "BUY",
                //             "isIsolated" => true,
                //             "isWorking" => true,
                //             "time" => 1661994066000,
                //             "updateTime" => 1661994066000
                //         }
                //     )
                //
                return $this->parse_orders($response, $market);
            } else {
                if ($symbol !== null) {
                    $request['symbol'] = $market['id'];
                }
                // $method can be either => contractPrivatePostOrderCancelAll or contractPrivatePostPlanorderCancelAll
                // the Planorder endpoints work not only for stop-$market orders but also for stop-limit orders that are supposed to have separate endpoint
                $method = $this->safe_string($this->options, 'cancelAllOrders', 'contractPrivatePostOrderCancelAll');
                $method = $this->safe_string($query, 'method', $method);
                $response = Async\await($this->$method (array_merge($request, $query)));
                //
                //     {
                //         "success" => true,
                //         "code" => "0"
                //     }
                //
                $data = $this->safe_value($response, 'data', array());
                return $this->parse_orders($data, $market);
            }
        }) ();
    }

    public function parse_order($order, $market = null) {
        //
        // spot => createOrder
        //
        //     {
        //         "symbol" => "BTCUSDT",
        //         "orderId" => "123738410679123456",
        //         "orderListId" => -1
        //     }
        //
        // margin => createOrder
        //
        //     {
        //         "symbol" => "BTCUSDT",
        //         "orderId" => "762634301354414080",
        //         "clientOrderId" => null,
        //         "isIsolated" => true,
        //         "transactTime" => 1661992652132
        //     }
        //
        // spot => cancelOrder, cancelAllOrders
        //
        //     {
        //         "symbol" => "BTCUSDT",
        //         "orderId" => "133926441921286144",
        //         "price" => "30000",
        //         "origQty" => "0.0002",
        //         "type" => "LIMIT",
        //         "side" => "BUY"
        //     }
        //
        // margin => cancelOrder, cancelAllOrders
        //
        //     {
        //         "symbol" => "BTCUSDT",
        //         "orderId" => "762640232574226432",
        //         "orderListId" => "-1",
        //         "clientOrderId" => null,
        //         "price" => "18000",
        //         "origQty" => "0.00147",
        //         "executedQty" => "0",
        //         "cummulativeQuoteQty" => "0",
        //         "status" => "NEW",
        //         "type" => "LIMIT",
        //         "side" => "BUY",
        //         "isIsolated" => true,
        //         "isWorking" => true,
        //         "time" => 1661994066000,
        //         "updateTime" => 1661994066000
        //     }
        //
        // spot => fetchOrder, fetchOpenOrders, fetchOrders
        //
        //     {
        //         "symbol" => "BTCUSDT",
        //         "orderId" => "133734823834147272",
        //         "orderListId" => "-1",
        //         "clientOrderId" => null,
        //         "price" => "30000",
        //         "origQty" => "0.0002",
        //         "executedQty" => "0",
        //         "cummulativeQuoteQty" => "0",
        //         "status" => "CANCELED",
        //         "timeInForce" => null,
        //         "type" => "LIMIT",
        //         "side" => "BUY",
        //         "stopPrice" => null,
        //         "icebergQty" => null,
        //         "time" => "1647667102000",
        //         "updateTime" => "1647708567000",
        //         "isWorking" => true,
        //         "origQuoteOrderQty" => "6"
        //     }
        //
        // margin => fetchOrder, fetchOrders
        //
        //     {
        //         "symbol" => "BTCUSDT",
        //         "orderId" => "763307297891028992",
        //         "orderListId" => "-1",
        //         "clientOrderId" => null,
        //         "price" => "18000",
        //         "origQty" => "0.0014",
        //         "executedQty" => "0",
        //         "cummulativeQuoteQty" => "0",
        //         "status" => "NEW",
        //         "type" => "LIMIT",
        //         "side" => "BUY",
        //         "isIsolated" => true,
        //         "isWorking" => true,
        //         "time" => 1662153107000,
        //         "updateTime" => 1662153107000
        //     }
        //
        // swap => createOrder
        //
        //     2ff3163e8617443cb9c6fc19d42b1ca4
        //
        // swap => fetchOrder, fetchOrders
        //
        //     regular
        //     {
        //         "orderId" => "264995729269765120",
        //         "symbol" => "STEPN_USDT",
        //         "positionId" => "0",
        //         "price" => "2.2",
        //         "vol" => "15",
        //         "leverage" => "20",
        //         "side" => "1", // TODO => not unified
        //         "category" => "1",
        //         "orderType" => "1", // TODO => not unified
        //         "dealAvgPrice" => "0",
        //         "dealVol" => "0",
        //         "orderMargin" => "2.2528",
        //         "takerFee" => "0",
        //         "makerFee" => "0",
        //         "profit" => "0",
        //         "feeCurrency" => "USDT",
        //         "openType" => "1",
        //         "state" => "2", // TODO
        //         "externalOid" => "_m_0e9520c256744d64b942985189026d20",
        //         "errorCode" => "0",
        //         "usedMargin" => "0",
        //         "createTime" => "1648850305236",
        //         "updateTime" => "1648850305245",
        //         "positionMode" => "1"
        //     }
        //
        //     stop
        //     {
        //         "id" => "265557643326564352",
        //         "triggerType" => "1",
        //         "triggerPrice" => "3",
        //         "price" => "2.9", // not present in stop-$market, but in stop-limit $order
        //         "executeCycle" => "87600",
        //         "trend" => "1",
        //          // below keys are same as in regular $order structure
        //         "symbol" => "STEPN_USDT",
        //         "leverage" => "20",
        //         "side" => "1",
        //         "vol" => "13",
        //         "openType" => "1",
        //         "state" => "1",
        //         "orderType" => "1",
        //         "errorCode" => "0",
        //         "createTime" => "1648984276000",
        //         "updateTime" => "1648984276000",
        //     }
        //
        $id = null;
        if (gettype($order) === 'string') {
            $id = $order;
        } else {
            $id = $this->safe_string_2($order, 'orderId', 'id');
        }
        $marketId = $this->safe_string($order, 'symbol');
        $market = $this->safe_market($marketId, $market);
        $timestamp = $this->safe_integer_n($order, array( 'time', 'createTime', 'transactTime' ));
        $fee = null;
        $feeCurrency = $this->safe_string($order, 'feeCurrency');
        if ($feeCurrency !== null) {
            $takerFee = $this->safe_string($order, 'takerFee');
            $makerFee = $this->safe_string($order, 'makerFee');
            $feeSum = Precise::string_add($takerFee, $makerFee);
            $fee = array(
                'currency' => $feeCurrency,
                'cost' => $this->parse_number($feeSum),
            );
        }
        return $this->safe_order(array(
            'id' => $id,
            'clientOrderId' => $this->safe_string($order, 'clientOrderId'),
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'lastTradeTimestamp' => null, // TODO => this might be 'updateTime' if $order-status is filled, otherwise cancellation time. needs to be checked
            'status' => $this->parse_order_status($this->safe_string_2($order, 'status', 'state')),
            'symbol' => $market['symbol'],
            'type' => $this->parse_order_type($this->safe_string($order, 'type')),
            'timeInForce' => $this->parse_order_time_in_force($this->safe_string($order, 'timeInForce')),
            'side' => $this->parse_order_side($this->safe_string($order, 'side')),
            'price' => $this->safe_number($order, 'price'),
            'stopPrice' => $this->safe_number_2($order, 'stopPrice', 'triggerPrice'),
            'average' => $this->safe_number($order, 'dealAvgPrice'),
            'amount' => $this->safe_number_2($order, 'origQty', 'vol'),
            'cost' => $this->safe_number($order, 'cummulativeQuoteQty'),  // 'cummulativeQuoteQty' vs 'origQuoteOrderQty'
            'filled' => $this->safe_number_2($order, 'executedQty', 'dealVol'),
            'remaining' => null,
            'fee' => $fee,
            'trades' => null,
            'info' => $order,
        ), $market);
    }

    public function parse_order_side($status) {
        $statuses = array(
            'BUY' => 'buy',
            'SELL' => 'sell',
            // contracts v1 : TODO
        );
        return $this->safe_string($statuses, $status, $status);
    }

    public function parse_order_type($status) {
        $statuses = array(
            'MARKET' => 'market',
            'LIMIT' => 'limit',
            'LIMIT_MAKER' => 'limit',
        );
        return $this->safe_string($statuses, $status, $status);
    }

    public function parse_order_status($status) {
        $statuses = array(
            'NEW' => 'open',
            'FILLED' => 'closed',
            'CANCELED' => 'canceled',
            'PARTIALLY_FILLED' => 'open',
            'PARTIALLY_CANCELED' => 'canceled',
            // contracts v1
            // '1' => 'uninformed', // TODO => wt?
            '2' => 'open',
            '3' => 'closed',
            '4' => 'canceled',
            // '5' => 'invalid', //  TODO => wt?
        );
        return $this->safe_string($statuses, $status, $status);
    }

    public function parse_order_time_in_force($status) {
        $statuses = array(
            'GTC' => 'GTC',
            'FOK' => 'FOK',
            'IOC' => 'IOC',
        );
        return $this->safe_string($statuses, $status, $status);
    }

    public function fetch_account_helper($type, $params) {
        return Async\async(function () use ($type, $params) {
            if ($type === 'spot') {
                return Async\await($this->spotPrivateGetAccount ($params));
                //
                //     {
                //         "makerCommission" => "20",
                //         "takerCommission" => "20",
                //         "buyerCommission" => "0",
                //         "sellerCommission" => "0",
                //         "canTrade" => true,
                //         "canWithdraw" => true,
                //         "canDeposit" => true,
                //         "updateTime" => null,
                //         "accountType" => "SPOT",
                //         "balances" => array(
                //             array(
                //                 "asset" => "BTC",
                //                 "free" => "0.002",
                //                 "locked" => "0"
                //             ),
                //             array(
                //                 "asset" => "USDT",
                //                 "free" => "88.120131350620957006",
                //                 "locked" => "0"
                //             ),
                //         ),
                //         "permissions" => array(
                //             "SPOT"
                //         )
                //     }
                //
            } elseif ($type === 'swap') {
                $response = Async\await($this->contractPrivateGetAccountAssets ($params));
                //
                //     {
                //         "success":true,
                //         "code":0,
                //         "data":array(
                //            array(
                //              "currency":"BSV",
                //              "positionMargin":0,
                //              "availableBalance":0,
                //              "cashBalance":0,
                //              "frozenBalance":0,
                //              "equity":0,
                //              "unrealized":0,
                //              "bonus":0
                //           ),
                //         )
                //     }
                //
                return $this->safe_value($response, 'data');
            }
        }) ();
    }

    public function fetch_accounts($params = array ()) {
        return Async\async(function () use ($params) {
            /**
             * fetch all the accounts associated with a profile
             * @param {array} $params extra parameters specific to the mexc3 api endpoint
             * @return {array} a dictionary of {@link https://docs.ccxt.com/en/latest/manual.html#$account-structure $account structures} indexed by the $account type
             */
            // TODO => is the below endpoints suitable for fetchAccounts?
            list($marketType, $query) = $this->handle_market_type_and_params('fetchAccounts', null, $params);
            Async\await($this->load_markets());
            $response = Async\await($this->fetch_account_helper($marketType, $query));
            $data = $this->safe_value($response, 'balances', array());
            $result = array();
            for ($i = 0; $i < count($data); $i++) {
                $account = $data[$i];
                $currencyId = $this->safe_string_2($account, 'asset', 'currency');
                $code = $this->safe_currency_code($currencyId);
                $result[] = array(
                    'id' => $this->safe_string($account, 'id'),
                    'type' => $this->safe_string($account, 'type'),
                    'code' => $code,
                    'info' => $account,
                );
            }
            return $result;
        }) ();
    }

    public function fetch_trading_fees($params = array ()) {
        return Async\async(function () use ($params) {
            /**
             * fetch the trading fees for multiple markets
             * @param {array} $params extra parameters specific to the mexc3 api endpoint
             * @return {array} a dictionary of {@link https://docs.ccxt.com/en/latest/manual.html#fee-structure fee structures} indexed by market symbols
             */
            Async\await($this->load_markets());
            $response = Async\await($this->fetch_account_helper('spot', $params));
            $makerFee = $this->safe_string($response, 'makerCommission');
            $takerFee = $this->safe_string($response, 'takerCommission');
            $makerFee = Precise::string_div($makerFee, '1000');
            $takerFee = Precise::string_div($takerFee, '1000');
            $result = array();
            for ($i = 0; $i < count($this->symbols); $i++) {
                $symbol = $this->symbols[$i];
                $result[$symbol] = array(
                    'symbol' => $symbol,
                    'maker' => $this->parse_number($makerFee),
                    'taker' => $this->parse_number($takerFee),
                    'percentage' => true,
                    'tierBased' => false,
                    'info' => $response,
                );
            }
            return $result;
        }) ();
    }

    public function parse_balance($response, $marketType) {
        //
        // spot
        //
        //     {
        //         "asset" => "USDT",
        //         "free" => "0.000000000674",
        //         "locked" => "0"
        //     }
        //
        // swap
        //
        //     {
        //         "currency" => "BSV",
        //         "positionMargin" => 0,
        //         "availableBalance" => 0,
        //         "cashBalance" => 0,
        //         "frozenBalance" => 0,
        //         "equity" => 0,
        //         "unrealized" => 0,
        //         "bonus" => 0
        //     }
        //
        // margin
        //
        //     {
        //         "baseAsset" => {
        //             "asset" => "BTC",
        //             "borrowEnabled" => true,
        //             "borrowed" => "0",
        //             "free" => "0",
        //             "interest" => "0",
        //             "locked" => "0",
        //             "netAsset" => "0",
        //             "netAssetOfBtc" => "0",
        //             "repayEnabled" => true,
        //             "totalAsset" => "0"
        //         }
        //         "quoteAsset" => {
        //             "asset" => "USDT",
        //             "borrowEnabled" => true,
        //             "borrowed" => "0",
        //             "free" => "10",
        //             "interest" => "0",
        //             "locked" => "0",
        //             "netAsset" => "10",
        //             "netAssetOfBtc" => "0",
        //             "repayEnabled" => true,
        //             "totalAsset" => "10"
        //         }
        //         "symbol" => "BTCUSDT",
        //         "isolatedCreated" => true,
        //         "enabled" => true,
        //         "marginLevel" => "999",
        //         "marginRatio" => "9",
        //         "indexPrice" => "16741.137068965517241379",
        //         "liquidatePrice" => "--",
        //         "liquidateRate" => "--",
        //         "tradeEnabled" => true
        //     }
        //
        $wallet = null;
        if ($marketType === 'margin') {
            $wallet = $this->safe_value($response, 'assets', array());
        } elseif ($marketType === 'swap') {
            $wallet = $this->safe_value($response, 'data', array());
        } else {
            $wallet = $this->safe_value($response, 'balances', array());
        }
        $result = array( 'info' => $response );
        if ($marketType === 'margin') {
            for ($i = 0; $i < count($wallet); $i++) {
                $entry = $wallet[$i];
                $marketId = $this->safe_string($entry, 'symbol');
                $symbol = $this->safe_symbol($marketId, null);
                $base = $this->safe_value($entry, 'baseAsset', array());
                $quote = $this->safe_value($entry, 'quoteAsset', array());
                $baseCode = $this->safe_currency_code($this->safe_string($base, 'asset'));
                $quoteCode = $this->safe_currency_code($this->safe_string($quote, 'asset'));
                $subResult = array();
                $subResult[$baseCode] = $this->parse_balance_helper($base);
                $subResult[$quoteCode] = $this->parse_balance_helper($quote);
                $result[$symbol] = $this->safe_balance($subResult);
            }
            return $result;
        } elseif ($marketType === 'swap') {
            for ($i = 0; $i < count($wallet); $i++) {
                $entry = $wallet[$i];
                $currencyId = $this->safe_string($entry, 'currency');
                $code = $this->safe_currency_code($currencyId);
                $account = $this->account();
                $account['free'] = $this->safe_string($entry, 'availableBalance');
                $account['used'] = $this->safe_string($entry, 'frozenBalance');
                $result[$code] = $account;
            }
            return $this->safe_balance($result);
        } else {
            for ($i = 0; $i < count($wallet); $i++) {
                $entry = $wallet[$i];
                $currencyId = $this->safe_string($entry, 'asset');
                $code = $this->safe_currency_code($currencyId);
                $account = $this->account();
                $account['free'] = $this->safe_string($entry, 'free');
                $account['used'] = $this->safe_string($entry, 'locked');
                $result[$code] = $account;
            }
            return $this->safe_balance($result);
        }
    }

    public function parse_balance_helper($entry) {
        $account = $this->account();
        $account['used'] = $this->safe_string($entry, 'locked');
        $account['free'] = $this->safe_string($entry, 'free');
        $account['total'] = $this->safe_string($entry, 'totalAsset');
        $debt = $this->safe_string($entry, 'borrowed');
        $interest = $this->safe_string($entry, 'interest');
        $account['debt'] = Precise::string_add($debt, $interest);
        return $account;
    }

    public function fetch_balance($params = array ()) {
        return Async\async(function () use ($params) {
            /**
             * query for balance and get the amount of funds available for trading or funds locked in orders
             * @see https://mxcdevelop.github.io/apidocs/spot_v3_en/#account-information
             * @see https://mxcdevelop.github.io/apidocs/contract_v1_en/#get-all-informations-of-user-39-s-asset
             * @see https://mxcdevelop.github.io/apidocs/spot_v3_en/#isolated-account
             * @param {array} $params extra parameters specific to the mexc3 api endpoint
             * @param {string|null} $params->symbols // required for margin, $market id's separated by commas
             * @return {array} a ~@link https://docs.ccxt.com/en/latest/manual.html?#balance-structure balance structure~
             */
            Async\await($this->load_markets());
            $marketType = null;
            $request = array();
            list($marketType, $params) = $this->handle_market_type_and_params('fetchBalance', null, $params);
            $method = $this->get_supported_mapping($marketType, array(
                'spot' => 'spotPrivateGetAccount',
                'swap' => 'contractPrivateGetAccountAssets',
                'margin' => 'spotPrivateGetMarginIsolatedAccount',
            ));
            $marginMode = $this->safe_string($params, 'marginMode');
            $isMargin = $this->safe_value($params, 'margin', false);
            if (($marginMode !== null) || ($isMargin) || ($marketType === 'margin')) {
                $parsedSymbols = null;
                $symbol = $this->safe_string($params, 'symbol');
                if ($symbol === null) {
                    $symbols = $this->safe_value($params, 'symbols');
                    if ($symbols !== null) {
                        $parsedSymbols = implode(',', $this->market_ids($symbols));
                    }
                } else {
                    $market = $this->market($symbol);
                    $parsedSymbols = $market['id'];
                }
                $this->check_required_argument('fetchBalance', $parsedSymbols, 'symbol or symbols');
                $method = 'spotPrivateGetMarginIsolatedAccount';
                $marketType = 'margin';
                $request['symbols'] = $parsedSymbols;
            }
            $params = $this->omit($params, array( 'margin', 'marginMode', 'symbol', 'symbols' ));
            $response = Async\await($this->$method (array_merge($request, $params)));
            //
            // spot
            //
            //     {
            //         "makerCommission" => 0,
            //         "takerCommission" => 20,
            //         "buyerCommission" => 0,
            //         "sellerCommission" => 0,
            //         "canTrade" => true,
            //         "canWithdraw" => true,
            //         "canDeposit" => true,
            //         "updateTime" => null,
            //         "accountType" => "SPOT",
            //         "balances" => array(
            //             array(
            //                 "asset" => "USDT",
            //                 "free" => "0.000000000674",
            //                 "locked" => "0"
            //             ),
            //         ),
            //         "permissions" => ["SPOT"]
            //     }
            //
            // swap
            //
            //     {
            //         "success" => true,
            //         "code" => 0,
            //         "data" => array(
            //             array(
            //                 "currency" => "BSV",
            //                 "positionMargin" => 0,
            //                 "availableBalance" => 0,
            //                 "cashBalance" => 0,
            //                 "frozenBalance" => 0,
            //                 "equity" => 0,
            //                 "unrealized" => 0,
            //                 "bonus" => 0
            //             ),
            //         )
            //     }
            //
            // margin
            //
            //     {
            //         "assets" => array(
            //             {
            //                 "baseAsset" => array(
            //                     "asset" => "BTC",
            //                     "borrowEnabled" => true,
            //                     "borrowed" => "0",
            //                     "free" => "0",
            //                     "interest" => "0",
            //                     "locked" => "0",
            //                     "netAsset" => "0",
            //                     "netAssetOfBtc" => "0",
            //                     "repayEnabled" => true,
            //                     "totalAsset" => "0"
            //                 ),
            //                 "quoteAsset" => array(
            //                     "asset" => "USDT",
            //                     "borrowEnabled" => true,
            //                     "borrowed" => "0",
            //                     "free" => "10",
            //                     "interest" => "0",
            //                     "locked" => "0",
            //                     "netAsset" => "10",
            //                     "netAssetOfBtc" => "0",
            //                     "repayEnabled" => true,
            //                     "totalAsset" => "10"
            //                 ),
            //                 "symbol" => "BTCUSDT",
            //                 "isolatedCreated" => true,
            //                 "enabled" => true,
            //                 "marginLevel" => "999",
            //                 "marginRatio" => "9",
            //                 "indexPrice" => "16741.137068965517241379",
            //                 "liquidatePrice" => "--",
            //                 "liquidateRate" => "--",
            //                 "tradeEnabled" => true
            //             }
            //         )
            //     }
            //
            return $this->parse_balance($response, $marketType);
        }) ();
    }

    public function fetch_my_trades($symbol = null, $since = null, $limit = null, $params = array ()) {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            /**
             * fetch all $trades made by the user
             * @param {string} $symbol unified $market $symbol
             * @param {int|null} $since the earliest time in ms to fetch $trades for
             * @param {int|null} $limit the maximum number of $trades structures to retrieve
             * @param {array} $params extra parameters specific to the mexc3 api endpoint
             * @return {[array]} a list of {@link https://docs.ccxt.com/en/latest/manual.html#trade-structure trade structures}
             */
            if ($symbol === null) {
                throw new ArgumentsRequired($this->id . ' fetchMyTrades() requires a $symbol argument');
            }
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            list($marketType, $query) = $this->handle_market_type_and_params('fetchMyTrades', $market, $params);
            $request = array(
                'symbol' => $market['id'],
            );
            $trades = null;
            if ($marketType === 'spot') {
                if ($since !== null) {
                    $request['start_time'] = $since;
                }
                if ($limit !== null) {
                    $request['limit'] = $limit;
                }
                $trades = Async\await($this->spotPrivateGetMyTrades (array_merge($request, $query)));
                //
                // spot
                //
                //     array(
                //         {
                //             "symbol" => "BTCUSDT",
                //             "id" => "133948532984922113",
                //             "orderId" => "133948532531949568",
                //             "orderListId" => "-1",
                //             "price" => "41995.51",
                //             "qty" => "0.0002",
                //             "quoteQty" => "8.399102",
                //             "commission" => "0.016798204",
                //             "commissionAsset" => "USDT",
                //             "time" => "1647718055000",
                //             "isBuyer" => true,
                //             "isMaker" => false,
                //             "isBestMatch" => true
                //         }
                //     )
                //
            } else {
                if ($since !== null) {
                    $request['start_time'] = $since;
                    $end = $this->safe_integer($params, 'end_time');
                    if ($end === null) {
                        $request['end_time'] = $this->sum($since, $this->options['maxTimeTillEnd']);
                    }
                }
                if ($limit !== null) {
                    $request['page_size'] = $limit;
                }
                $response = Async\await($this->contractPrivateGetOrderListOrderDeals (array_merge($request, $query)));
                //
                //     {
                //         "success" => true,
                //         "code" => "0",
                //         "data" => array(
                //             {
                //                 "id" => "299444585",
                //                 "symbol" => "STEPN_USDT",
                //                 "side" => "1",
                //                 "vol" => "1",
                //                 "price" => "2.45455",
                //                 "feeCurrency" => "USDT",
                //                 "fee" => "0.00147273",
                //                 "timestamp" => "1648924557000",
                //                 "profit" => "0",
                //                 "category" => "1",
                //                 "orderId" => "265307163526610432",
                //                 "positionMode" => "1",
                //                 "taker" => true
                //             }
                //         )
                //     }
                //
                $trades = $this->safe_value($response, 'data');
            }
            return $this->parse_trades($trades, $market, $since, $limit);
        }) ();
    }

    public function fetch_order_trades($id, $symbol = null, $since = null, $limit = null, $params = array ()) {
        return Async\async(function () use ($id, $symbol, $since, $limit, $params) {
            /**
             * fetch all the $trades made from a single order
             * @param {string} $id order $id
             * @param {string|null} $symbol unified $market $symbol
             * @param {int|null} $since the earliest time in ms to fetch $trades for
             * @param {int|null} $limit the maximum number of $trades to retrieve
             * @param {array} $params extra parameters specific to the mexc3 api endpoint
             * @return {[array]} a list of {@link https://docs.ccxt.com/en/latest/manual.html#trade-structure trade structures}
             */
            Async\await($this->load_markets());
            $request = array();
            $market = null;
            if ($symbol !== null) {
                $market = $this->market($symbol);
            }
            list($marketType, $query) = $this->handle_market_type_and_params('fetchOrderTrades', $market, $params);
            $trades = null;
            if ($marketType === 'spot') {
                if ($symbol === null) {
                    throw new ArgumentsRequired($this->id . ' fetchOrderTrades() requires a $symbol argument');
                }
                $request['symbol'] = $market['id'];
                $request['orderId'] = $id;
                $trades = Async\await($this->spotPrivateGetMyTrades (array_merge($request, $query)));
                //
                // spot
                //
                //     array(
                //         {
                //             "symbol" => "BTCUSDT",
                //             "id" => "133948532984922113",
                //             "orderId" => "133948532531949568",
                //             "orderListId" => "-1",
                //             "price" => "41995.51",
                //             "qty" => "0.0002",
                //             "quoteQty" => "8.399102",
                //             "commission" => "0.016798204",
                //             "commissionAsset" => "USDT",
                //             "time" => "1647718055000",
                //             "isBuyer" => true,
                //             "isMaker" => false,
                //             "isBestMatch" => true
                //         }
                //     )
                //
            } else {
                $request['order_id'] = $id;
                $response = Async\await($this->contractPrivateGetOrderDealDetailsOrderId (array_merge($request, $query)));
                //
                //     {
                //         "success" => true,
                //         "code" => "0",
                //         "data" => array(
                //             {
                //                 "id" => "299444585",
                //                 "symbol" => "STEPN_USDT",
                //                 "side" => "1",
                //                 "vol" => "1",
                //                 "price" => "2.45455",
                //                 "feeCurrency" => "USDT",
                //                 "fee" => "0.00147273",
                //                 "timestamp" => "1648924557000",
                //                 "profit" => "0",
                //                 "category" => "1",
                //                 "orderId" => "265307163526610432",
                //                 "positionMode" => "1",
                //                 "taker" => true
                //             }
                //         )
                //     }
                //
                $trades = $this->safe_value($response, 'data');
            }
            return $this->parse_trades($trades, $market, $since, $limit, $query);
        }) ();
    }

    public function modify_margin_helper($symbol, $amount, $addOrReduce, $params = array ()) {
        return Async\async(function () use ($symbol, $amount, $addOrReduce, $params) {
            $positionId = $this->safe_integer($params, 'positionId');
            if ($positionId === null) {
                throw new ArgumentsRequired($this->id . ' modifyMarginHelper() requires a $positionId parameter');
            }
            Async\await($this->load_markets());
            $request = array(
                'positionId' => $positionId,
                'amount' => $amount,
                'type' => $addOrReduce,
            );
            $response = Async\await($this->contractPrivatePostPositionChangeMargin (array_merge($request, $params)));
            //
            //     {
            //         "success" => true,
            //         "code" => 0
            //     }
            return $response;
        }) ();
    }

    public function reduce_margin($symbol, $amount, $params = array ()) {
        return Async\async(function () use ($symbol, $amount, $params) {
            /**
             * remove margin from a position
             * @param {string} $symbol unified market $symbol
             * @param {float} $amount the $amount of margin to remove
             * @param {array} $params extra parameters specific to the mexc3 api endpoint
             * @return {array} a {@link https://docs.ccxt.com/en/latest/manual.html#reduce-margin-structure margin structure}
             */
            return Async\await($this->modify_margin_helper($symbol, $amount, 'SUB', $params));
        }) ();
    }

    public function add_margin($symbol, $amount, $params = array ()) {
        return Async\async(function () use ($symbol, $amount, $params) {
            /**
             * add margin
             * @param {string} $symbol unified market $symbol
             * @param {float} $amount amount of margin to add
             * @param {array} $params extra parameters specific to the mexc3 api endpoint
             * @return {array} a {@link https://docs.ccxt.com/en/latest/manual.html#add-margin-structure margin structure}
             */
            return Async\await($this->modify_margin_helper($symbol, $amount, 'ADD', $params));
        }) ();
    }

    public function set_leverage($leverage, $symbol = null, $params = array ()) {
        return Async\async(function () use ($leverage, $symbol, $params) {
            /**
             * set the level of $leverage for a $market
             * @param {float} $leverage the rate of $leverage
             * @param {string|null} $symbol unified $market $symbol
             * @param {array} $params extra parameters specific to the mexc3 api endpoint
             * @return {array} response from the exchange
             */
            Async\await($this->load_markets());
            $request = array(
                'leverage' => $leverage,
            );
            $positionId = $this->safe_integer($params, 'positionId');
            if ($positionId === null) {
                $openType = $this->safe_number($params, 'openType'); // 1 or 2
                $positionType = $this->safe_number($params, 'positionType'); // 1 or 2
                $market = ($symbol !== null) ? $this->market($symbol) : null;
                if (($openType === null) || ($positionType === null) || ($market === null)) {
                    throw new ArgumentsRequired($this->id . ' setLeverage() requires a $positionId parameter or a $symbol argument with $openType and $positionType parameters, use $openType 1 or 2 for isolated or cross margin respectively, use $positionType 1 or 2 for long or short positions');
                } else {
                    $request['openType'] = $openType;
                    $request['symbol'] = $market['symbol'];
                    $request['positionType'] = $positionType;
                }
            } else {
                $request['positionId'] = $positionId;
            }
            return Async\await($this->contractPrivatePostPositionChangeLeverage (array_merge($request, $params)));
        }) ();
    }

    public function fetch_funding_history($symbol = null, $since = null, $limit = null, $params = array ()) {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            /**
             * fetch the history of funding payments paid and received on this account
             * @param {string|null} $symbol unified $market $symbol
             * @param {int|null} $since the earliest time in ms to fetch funding history for
             * @param {int|null} $limit the maximum number of funding history structures to retrieve
             * @param {array} $params extra parameters specific to the mexc3 api endpoint
             * @return {array} a {@link https://docs.ccxt.com/en/latest/manual.html#funding-history-structure funding history structure}
             */
            Async\await($this->load_markets());
            $market = null;
            $request = array(
                // 'symbol' => $market['id'],
                // 'position_id' => positionId,
                // 'page_num' => 1,
                // 'page_size' => $limit, // default 20, max 100
            );
            if ($symbol !== null) {
                $market = $this->market($symbol);
                $request['symbol'] = $market['id'];
            }
            if ($limit !== null) {
                $request['page_size'] = $limit;
            }
            $response = Async\await($this->contractPrivateGetPositionFundingRecords (array_merge($request, $params)));
            //
            //     {
            //         "success" => true,
            //         "code" => 0,
            //         "data" => {
            //             "pageSize" => 20,
            //             "totalCount" => 2,
            //             "totalPage" => 1,
            //             "currentPage" => 1,
            //             "resultList" => array(
            //                 array(
            //                     "id" => 7423910,
            //                     "symbol" => "BTC_USDT",
            //                     "positionType" => 1,
            //                     "positionValue" => 29.30024,
            //                     "funding" => 0.00076180624,
            //                     "rate" => -0.000026,
            //                     "settleTime" => 1643299200000
            //                 ),
            //                 {
            //                     "id" => 7416473,
            //                     "symbol" => "BTC_USDT",
            //                     "positionType" => 1,
            //                     "positionValue" => 28.9188,
            //                     "funding" => 0.0014748588,
            //                     "rate" => -0.000051,
            //                     "settleTime" => 1643270400000
            //                 }
            //             )
            //         }
            //     }
            //
            $data = $this->safe_value($response, 'data', array());
            $resultList = $this->safe_value($data, 'resultList', array());
            $result = array();
            for ($i = 0; $i < count($resultList); $i++) {
                $entry = $resultList[$i];
                $timestamp = $this->safe_integer($entry, 'settleTime');
                $result[] = array(
                    'info' => $entry,
                    'symbol' => $symbol,
                    'code' => null,
                    'timestamp' => $timestamp,
                    'datetime' => $this->iso8601($timestamp),
                    'id' => $this->safe_number($entry, 'id'),
                    'amount' => $this->safe_number($entry, 'funding'),
                );
            }
            return $result;
        }) ();
    }

    public function parse_funding_rate($contract, $market = null) {
        //
        //     {
        //         "symbol" => "BTC_USDT",
        //         "fundingRate" => 0.000014,
        //         "maxFundingRate" => 0.003,
        //         "minFundingRate" => -0.003,
        //         "collectCycle" => 8,
        //         "nextSettleTime" => 1643241600000,
        //         "timestamp" => 1643240373359
        //     }
        //
        $nextFundingRate = $this->safe_number($contract, 'fundingRate');
        $nextFundingTimestamp = $this->safe_integer($contract, 'nextSettleTime');
        $marketId = $this->safe_string($contract, 'symbol');
        $symbol = $this->safe_symbol($marketId, $market);
        $timestamp = $this->safe_integer($contract, 'timestamp');
        $datetime = $this->iso8601($timestamp);
        return array(
            'info' => $contract,
            'symbol' => $symbol,
            'markPrice' => null,
            'indexPrice' => null,
            'interestRate' => null,
            'estimatedSettlePrice' => null,
            'timestamp' => $timestamp,
            'datetime' => $datetime,
            'fundingRate' => $nextFundingRate,
            'fundingTimestamp' => $nextFundingTimestamp,
            'fundingDatetime' => $this->iso8601($nextFundingTimestamp),
            'nextFundingRate' => null,
            'nextFundingTimestamp' => null,
            'nextFundingDatetime' => null,
            'previousFundingRate' => null,
            'previousFundingTimestamp' => null,
            'previousFundingDatetime' => null,
        );
    }

    public function fetch_funding_rate($symbol, $params = array ()) {
        return Async\async(function () use ($symbol, $params) {
            /**
             * fetch the current funding rate
             * @param {string} $symbol unified $market $symbol
             * @param {array} $params extra parameters specific to the mexc3 api endpoint
             * @return {array} a {@link https://docs.ccxt.com/en/latest/manual.html#funding-rate-structure funding rate structure}
             */
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $request = array(
                'symbol' => $market['id'],
            );
            $response = Async\await($this->contractPublicGetFundingRateSymbol (array_merge($request, $params)));
            //
            //     {
            //         "success" => true,
            //         "code" => 0,
            //         "data" => {
            //             "symbol" => "BTC_USDT",
            //             "fundingRate" => 0.000014,
            //             "maxFundingRate" => 0.003,
            //             "minFundingRate" => -0.003,
            //             "collectCycle" => 8,
            //             "nextSettleTime" => 1643241600000,
            //             "timestamp" => 1643240373359
            //         }
            //     }
            //
            $result = $this->safe_value($response, 'data', array());
            return $this->parse_funding_rate($result, $market);
        }) ();
    }

    public function fetch_funding_rate_history($symbol = null, $since = null, $limit = null, $params = array ()) {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            /**
             * fetches historical funding rate prices
             * @param {string|null} $symbol unified $symbol of the $market to fetch the funding rate history for
             * @param {int|null} $since not used by mexc, but filtered internally by ccxt
             * @param {int|null} $limit mexc $limit is page_size default 20, maximum is 100
             * @param {array} $params extra parameters specific to the mexc api endpoint
             * @return {[array]} a list of ~@link https://docs.ccxt.com/en/latest/manual.html?#funding-rate-history-structure funding rate structures~
             */
            if ($symbol === null) {
                throw new ArgumentsRequired($this->id . ' fetchFundingRateHistory() requires a $symbol argument');
            }
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $request = array(
                'symbol' => $market['id'],
                // 'page_size' => $limit, // optional
                // 'page_num' => 1, // optional, current page number, default is 1
            );
            if ($limit !== null) {
                $request['page_size'] = $limit;
            }
            $response = Async\await($this->contractPublicGetFundingRateHistory (array_merge($request, $params)));
            //
            //    {
            //        "success" => true,
            //        "code" => 0,
            //        "data" => {
            //            "pageSize" => 2,
            //            "totalCount" => 21,
            //            "totalPage" => 11,
            //            "currentPage" => 1,
            //            "resultList" => array(
            //                array(
            //                    "symbol" => "BTC_USDT",
            //                    "fundingRate" => 0.000266,
            //                    "settleTime" => 1609804800000
            //                ),
            //                {
            //                    "symbol" => "BTC_USDT",
            //                    "fundingRate" => 0.00029,
            //                    "settleTime" => 1609776000000
            //                }
            //            )
            //        }
            //    }
            //
            $data = $this->safe_value($response, 'data');
            $result = $this->safe_value($data, 'resultList', array());
            $rates = array();
            for ($i = 0; $i < count($result); $i++) {
                $entry = $result[$i];
                $marketId = $this->safe_string($entry, 'symbol');
                $symbol = $this->safe_symbol($marketId);
                $timestamp = $this->safe_integer($entry, 'settleTime');
                $rates[] = array(
                    'info' => $entry,
                    'symbol' => $symbol,
                    'fundingRate' => $this->safe_number($entry, 'fundingRate'),
                    'timestamp' => $timestamp,
                    'datetime' => $this->iso8601($timestamp),
                );
            }
            $sorted = $this->sort_by($rates, 'timestamp');
            return $this->filter_by_symbol_since_limit($sorted, $market['symbol'], $since, $limit);
        }) ();
    }

    public function fetch_leverage_tiers($symbols = null, $params = array ()) {
        return Async\async(function () use ($symbols, $params) {
            /**
             * retrieve information on the maximum leverage, and maintenance margin for trades of varying trade sizes
             * @param {[string]|null} $symbols list of unified market $symbols
             * @param {array} $params extra parameters specific to the mexc3 api endpoint
             * @return {array} a dictionary of {@link https://docs.ccxt.com/en/latest/manual.html#leverage-tiers-structure leverage tiers structures}, indexed by market $symbols
             */
            Async\await($this->load_markets());
            $response = Async\await($this->contractPublicGetDetail ($params));
            //
            //     {
            //         "success":true,
            //         "code":0,
            //         "data":[
            //             array(
            //                 "symbol" => "BTC_USDT",
            //                 "displayName" => "BTC_USDT永续",
            //                 "displayNameEn" => "BTC_USDT SWAP",
            //                 "positionOpenType" => 3,
            //                 "baseCoin" => "BTC",
            //                 "quoteCoin" => "USDT",
            //                 "settleCoin" => "USDT",
            //                 "contractSize" => 0.0001,
            //                 "minLeverage" => 1,
            //                 "maxLeverage" => 125,
            //                 "priceScale" => 2,
            //                 "volScale" => 0,
            //                 "amountScale" => 4,
            //                 "priceUnit" => 0.5,
            //                 "volUnit" => 1,
            //                 "minVol" => 1,
            //                 "maxVol" => 1000000,
            //                 "bidLimitPriceRate" => 0.1,
            //                 "askLimitPriceRate" => 0.1,
            //                 "takerFeeRate" => 0.0006,
            //                 "makerFeeRate" => 0.0002,
            //                 "maintenanceMarginRate" => 0.004,
            //                 "initialMarginRate" => 0.008,
            //                 "riskBaseVol" => 10000,
            //                 "riskIncrVol" => 200000,
            //                 "riskIncrMmr" => 0.004,
            //                 "riskIncrImr" => 0.004,
            //                 "riskLevelLimit" => 5,
            //                 "priceCoefficientVariation" => 0.1,
            //                 "indexOrigin" => ["BINANCE","GATEIO","HUOBI","MXC"],
            //                 "state" => 0, // 0 enabled, 1 delivery, 2 completed, 3 offline, 4 pause
            //                 "isNew" => false,
            //                 "isHot" => true,
            //                 "isHidden" => false
            //             ),
            //             ...
            //         ]
            //     }
            //
            $data = $this->safe_value($response, 'data');
            return $this->parse_leverage_tiers($data, $symbols, 'symbol');
        }) ();
    }

    public function parse_market_leverage_tiers($info, $market) {
        /**
            @param $info => Exchange response for 1 $market
            {
                "symbol" => "BTC_USDT",
                "displayName" => "BTC_USDT永续",
                "displayNameEn" => "BTC_USDT SWAP",
                "positionOpenType" => 3,
                "baseCoin" => "BTC",
                "quoteCoin" => "USDT",
                "settleCoin" => "USDT",
                "contractSize" => 0.0001,
                "minLeverage" => 1,
                "maxLeverage" => 125,
                "priceScale" => 2,
                "volScale" => 0,
                "amountScale" => 4,
                "priceUnit" => 0.5,
                "volUnit" => 1,
                "minVol" => 1,
                "maxVol" => 1000000,
                "bidLimitPriceRate" => 0.1,
                "askLimitPriceRate" => 0.1,
                "takerFeeRate" => 0.0006,
                "makerFeeRate" => 0.0002,
                "maintenanceMarginRate" => 0.004,
                "initialMarginRate" => 0.008,
                "riskBaseVol" => 10000,
                "riskIncrVol" => 200000,
                "riskIncrMmr" => 0.004,
                "riskIncrImr" => 0.004,
                "riskLevelLimit" => 5,
                "priceCoefficientVariation" => 0.1,
                "indexOrigin" => ["BINANCE","GATEIO","HUOBI","MXC"],
                "state" => 0, // 0 enabled, 1 delivery, 2 completed, 3 offline, 4 pause
                "isNew" => false,
                "isHot" => true,
                "isHidden" => false
            }
            @param $market => CCXT $market
         */
        $maintenanceMarginRate = $this->safe_string($info, 'maintenanceMarginRate');
        $initialMarginRate = $this->safe_string($info, 'initialMarginRate');
        $maxVol = $this->safe_string($info, 'maxVol');
        $riskIncrVol = $this->safe_string($info, 'riskIncrVol');
        $riskIncrMmr = $this->safe_string($info, 'riskIncrMmr');
        $riskIncrImr = $this->safe_string($info, 'riskIncrImr');
        $floor = '0';
        $tiers = array();
        $quoteId = $this->safe_string($info, 'quoteCoin');
        while (Precise::string_lt($floor, $maxVol)) {
            $cap = Precise::string_add($floor, $riskIncrVol);
            $tiers[] = array(
                'tier' => $this->parse_number(Precise::string_div($cap, $riskIncrVol)),
                'currency' => $this->safe_currency_code($quoteId),
                'notionalFloor' => $this->parse_number($floor),
                'notionalCap' => $this->parse_number($cap),
                'maintenanceMarginRate' => $this->parse_number($maintenanceMarginRate),
                'maxLeverage' => $this->parse_number(Precise::string_div('1', $initialMarginRate)),
                'info' => $info,
            );
            $initialMarginRate = Precise::string_add($initialMarginRate, $riskIncrImr);
            $maintenanceMarginRate = Precise::string_add($maintenanceMarginRate, $riskIncrMmr);
            $floor = $cap;
        }
        return $tiers;
    }

    public function parse_deposit_address($depositAddress, $currency = null) {
        //
        //     array("chain":"ERC-20","address":"0x55cbd73db24eafcca97369e3f2db74b2490586e6"),
        //     array("chain":"MATIC","address":"0x05aa3236f1970eae0f8feb17ec19435b39574d74"),
        //     array("chain":"TRC20","address":"TGaPfhW41EXD3sAfs1grLF6DKfugfqANNw"),
        //     array("chain":"SOL","address":"5FSpUKuh2gjw4mF89T2e7sEjzUA1SkRKjBChFqP43KhV"),
        //     array("chain":"ALGO","address":"B3XTZND2JJTSYR7R2TQVCUDT4QSSYVAIZYDPWVBX34DGAYATBU3AUV43VU")
        //
        //
        $address = $this->safe_string($depositAddress, 'address');
        $code = $this->safe_currency_code(null, $currency);
        $networkId = $this->safe_string($depositAddress, 'chain');
        $network = $this->safe_network($networkId);
        $this->check_address($address);
        return array(
            'currency' => $code,
            'address' => $address,
            'tag' => null,
            'network' => $network,
            'info' => $depositAddress,
        );
    }

    public function fetch_deposit_addresses_by_network($code, $params = array ()) {
        return Async\async(function () use ($code, $params) {
            /**
             * fetch a dictionary of addresses for a $currency, indexed by $network
             * @see https://mxcdevelop.github.io/apidocs/spot_v3_en/#deposit-$address-supporting-$network
             * @param {string} $code unified $currency $code of the $currency for the deposit $address
             * @param {array} $params extra parameters specific to the mexc3 api endpoint
             * @return {array} a dictionary of {@link https://docs.ccxt.com/en/latest/manual.html#$address-structure $address structures} indexed by the $network
             */
            Async\await($this->load_markets());
            $currency = $this->currency($code);
            $request = array(
                'coin' => $currency['id'],
            );
            $response = Async\await($this->spotPrivateGetCapitalDepositAddress (array_merge($request, $params)));
            $result = array();
            for ($i = 0; $i < count($response); $i++) {
                $depositAddress = $response[$i];
                $coin = $this->safe_string($depositAddress, 'coin');
                $currency = $this->currency($coin);
                $networkId = $this->safe_string($depositAddress, 'network');
                $network = $this->safe_network($networkId);
                $address = $this->safe_string($depositAddress, 'address', null);
                $tag = $this->safe_string_2($depositAddress, 'tag', 'memo', null);
                $result[] = array(
                    'currency' => $currency['id'],
                    'network' => $network,
                    'address' => $address,
                    'tag' => $tag,
                );
            }
            return $result;
        }) ();
    }

    public function fetch_deposit_address($code, $params = array ()) {
        return Async\async(function () use ($code, $params) {
            /**
             * fetch the deposit address for a currency associated with this account
             * @see https://mxcdevelop.github.io/apidocs/spot_v3_en/#deposit-address-supporting-$network
             * @param {string} $code unified currency $code
             * @param {array} $params extra parameters specific to the mexc3 api endpoint
             * @return {array} an {@link https://docs.ccxt.com/en/latest/manual.html#address-structure address structure}
             */
            $rawNetwork = $this->safe_string_upper($params, 'network');
            $params = $this->omit($params, 'network');
            $response = Async\await($this->fetch_deposit_addresses_by_network($code, $params));
            if ($rawNetwork !== null) {
                for ($i = 0; $i < count($response); $i++) {
                    $depositAddress = $response[$i];
                    $network = $this->safe_string_upper($depositAddress, 'network');
                    if ($rawNetwork === $network) {
                        return $depositAddress;
                    }
                }
            }
            $result = $this->safe_value($response, 0);
            if ($result === null) {
                throw new InvalidAddress($this->id . ' fetchDepositAddress() cannot find a deposit address for ' . $code . ', consider creating one using the MEXC platform');
            }
            return $result;
        }) ();
    }

    public function fetch_deposits($code = null, $since = null, $limit = null, $params = array ()) {
        return Async\async(function () use ($code, $since, $limit, $params) {
            /**
             * fetch all deposits made to an account
             * @see https://mxcdevelop.github.io/apidocs/spot_v3_en/#deposit-history-supporting-network
             * @param {string} $code unified $currency $code
             * @param {int|null} $since the earliest time in ms to fetch deposits for
             * @param {int|null} $limit the maximum number of deposits structures to retrieve
             * @param {array} $params extra parameters specific to the mexc3 api endpoint
             * @return {[array]} a list of {@link https://docs.ccxt.com/en/latest/manual.html#transaction-structure transaction structures}
             */
            if ($code === null) {
                throw new ArgumentsRequired($this->id . ' fetchDeposits() requires a $currency $code argument');
            }
            Async\await($this->load_markets());
            $request = array(
                // 'coin' => $currency['id'] . network example => USDT-TRX,
                // 'status' => 'status',
                // 'startTime' => $since, // default 90 days
                // 'endTime' => $this->milliseconds(),
                // 'limit' => $limit, // default 1000, maximum 1000
            );
            $currency = null;
            $rawNetwork = $this->safe_string($params, 'network');
            $params = $this->omit($params, 'network');
            if ($rawNetwork === null) {
                throw new ArgumentsRequired($this->id . ' fetchDeposits() requires a network parameter when the $currency is specified');
            }
            // currently mexc does not have network names unified so for certain things we might need TRX or TRC-20
            // due to that I'm applying the network parameter directly so the user can control it on its side
            $currency = $this->currency($code);
            $request['coin'] = $currency['id'] . '-' . $rawNetwork;
            if ($since !== null) {
                $request['startTime'] = $since;
            }
            if ($limit !== null) {
                if ($limit > 1000) {
                    throw new ExchangeError('This exchange supports a maximum $limit of 1000');
                }
                $request['limit'] = $limit;
            }
            $response = Async\await($this->spotPrivateGetCapitalDepositHisrec (array_merge($request, $params)));
            //
            // array(
            //     {
            //         amount => '10',
            //         coin => 'USDC-TRX',
            //         network => 'TRX',
            //         status => '5',
            //         address => 'TSMcEDDvkqY9dz8RkFnrS86U59GwEZjfvh',
            //         addressTag => null,
            //         txId => '51a8f49e6f03f2c056e71fe3291aa65e1032880be855b65cecd0595a1b8af95b',
            //         insertTime => '1664805021000',
            //         unlockConfirm => '200',
            //         confirmTimes => '203'
            //     }
            // )
            //
            return $this->parse_transactions($response, $currency, $since, $limit);
        }) ();
    }

    public function fetch_withdrawals($code = null, $since = null, $limit = null, $params = array ()) {
        return Async\async(function () use ($code, $since, $limit, $params) {
            /**
             * fetch all withdrawals made from an account
             * @see https://mxcdevelop.github.io/apidocs/spot_v3_en/#withdraw-history-supporting-network
             * @param {string} $code unified $currency $code
             * @param {int|null} $since the earliest time in ms to fetch withdrawals for
             * @param {int|null} $limit the maximum number of withdrawals structures to retrieve
             * @param {array} $params extra parameters specific to the mexc3 api endpoint
             * @return {[array]} a list of {@link https://docs.ccxt.com/en/latest/manual.html#transaction-structure transaction structures}
             */
            if ($code === null) {
                throw new ArgumentsRequired($this->id . ' fetchWithdrawals() requires a $currency $code argument');
            }
            Async\await($this->load_markets());
            $request = array(
                // 'coin' => $currency['id'],
                // 'status' => 'status',
                // 'startTime' => $since, // default 90 days
                // 'endTime' => $this->milliseconds(),
                // 'limit' => $limit, // default 1000, maximum 1000
            );
            $currency = $this->currency($code);
            $request['coin'] = $currency['id'];
            if ($since !== null) {
                $request['startTime'] = $since;
            }
            if ($limit !== null) {
                if ($limit > 1000) {
                    throw new ExchangeError('This exchange supports a maximum $limit of 1000');
                }
                $request['limit'] = $limit;
            }
            $response = Async\await($this->spotPrivateGetCapitalWithdrawHistory (array_merge($request, $params)));
            //
            // array(
            //     {
            //       id => 'adcd1c8322154de691b815eedcd10c42',
            //       txId => '0xc8c918cd69b2246db493ef6225a72ffdc664f15b08da3e25c6879b271d05e9d0',
            //       coin => 'USDC-MATIC',
            //       network => 'MATIC',
            //       address => '0xeE6C7a415995312ED52c53a0f8f03e165e0A5D62',
            //       amount => '2',
            //       transferType => '0',
            //       status => '7',
            //       transactionFee => '1',
            //       confirmNo => null,
            //       applyTime => '1664882739000',
            //       remark => ''
            //     }
            // )
            //
            return $this->parse_transactions($response, $currency, $since, $limit);
        }) ();
    }

    public function parse_transaction($transaction, $currency = null) {
        //
        // fetchDeposits
        //
        // {
        //     amount => '10',
        //     coin => 'USDC-TRX',
        //     $network => 'TRX',
        //     $status => '5',
        //     $address => 'TSMcEDDvkqY9dz8RkFnrS86U59GwEZjfvh',
        //     addressTag => null,
        //     txId => '51a8f49e6f03f2c056e71fe3291aa65e1032880be855b65cecd0595a1b8af95b',
        //     insertTime => '1664805021000',
        //     unlockConfirm => '200',
        //     confirmTimes => '203'
        // }
        //
        // fetchWithdrawals
        //
        // {
        //     $id => 'adcd1c8322154de691b815eedcd10c42',
        //     txId => '0xc8c918cd69b2246db493ef6225a72ffdc664f15b08da3e25c6879b271d05e9d0',
        //     coin => 'USDC-MATIC',
        //     $network => 'MATIC',
        //     $address => '0xeE6C7a415995312ED52c53a0f8f03e165e0A5D62',
        //     amount => '2',
        //     transferType => '0',
        //     $status => '7',
        //     transactionFee => '1',
        //     confirmNo => null,
        //     applyTime => '1664882739000',
        //     remark => ''
        //   }
        //
        // withdraw
        //
        //     {
        //         "withdrawId":"25fb2831fb6d4fc7aa4094612a26c81d"
        //     }
        //
        $id = $this->safe_string($transaction, 'id');
        $type = ($id === null) ? 'deposit' : 'withdrawal';
        $timestamp = $this->safe_integer_2($transaction, 'insertTime', 'applyTime');
        $currencyId = $this->safe_string($transaction, 'currency');
        $network = $this->safe_string($transaction, 'network');
        $code = $this->safe_currency_code($currencyId, $currency);
        $status = $this->parse_transaction_status($this->safe_string($transaction, 'status'));
        $amountString = $this->safe_string($transaction, 'amount');
        $address = $this->safe_string($transaction, 'address');
        $txid = $this->safe_string($transaction, 'txId');
        $fee = null;
        $feeCostString = $this->safe_string($transaction, 'transactionFee');
        if ($feeCostString !== null) {
            $fee = array(
                'cost' => $this->parse_number($feeCostString),
                'currency' => $code,
            );
        }
        if ($type === 'withdrawal') {
            // mexc withdrawal amount includes the $fee
            $amountString = Precise::string_sub($amountString, $feeCostString);
        }
        return array(
            'info' => $transaction,
            'id' => $id,
            'txid' => $txid,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'network' => $network,
            'address' => $address,
            'addressTo' => $address,
            'addressFrom' => null,
            'tag' => $this->safe_string($transaction, 'memo'),
            'tagTo' => null,
            'tagFrom' => null,
            'type' => $type,
            'amount' => $this->parse_number($amountString),
            'currency' => $code,
            'status' => $status,
            'updated' => null,
            'fee' => $fee,
        );
    }

    public function parse_transaction_status($status) {
        $statuses = array(
            'WAIT' => 'pending',
            'WAIT_PACKAGING' => 'pending',
            'SUCCESS' => 'ok',
        );
        return $this->safe_string($statuses, $status, $status);
    }

    public function fetch_position($symbol, $params = array ()) {
        return Async\async(function () use ($symbol, $params) {
            /**
             * fetch data on a single open contract trade position
             * @param {string} $symbol unified $market $symbol of the $market the position is held in, default is null
             * @param {array} $params extra parameters specific to the mexc3 api endpoint
             * @return {array} a {@link https://docs.ccxt.com/en/latest/manual.html#position-structure position structure}
             */
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $request = array(
                'symbol' => $market['id'],
            );
            $response = Async\await($this->fetch_positions(null, array_merge($request, $params)));
            return $this->safe_value($response, 0);
        }) ();
    }

    public function fetch_positions($symbols = null, $params = array ()) {
        return Async\async(function () use ($symbols, $params) {
            /**
             * fetch all open positions
             * @param {[string]|null} $symbols list of unified market $symbols
             * @param {array} $params extra parameters specific to the mexc3 api endpoint
             * @return {[array]} a list of {@link https://docs.ccxt.com/en/latest/manual.html#position-structure position structure}
             */
            Async\await($this->load_markets());
            $response = Async\await($this->contractPrivateGetPositionOpenPositions ($params));
            //
            //     {
            //         "success" => true,
            //         "code" => 0,
            //         "data" => array(
            //             {
            //                 "positionId" => 1394650,
            //                 "symbol" => "ETH_USDT",
            //                 "positionType" => 1,
            //                 "openType" => 1,
            //                 "state" => 1,
            //                 "holdVol" => 1,
            //                 "frozenVol" => 0,
            //                 "closeVol" => 0,
            //                 "holdAvgPrice" => 1217.3,
            //                 "openAvgPrice" => 1217.3,
            //                 "closeAvgPrice" => 0,
            //                 "liquidatePrice" => 1211.2,
            //                 "oim" => 0.1290338,
            //                 "im" => 0.1290338,
            //                 "holdFee" => 0,
            //                 "realised" => -0.0073,
            //                 "leverage" => 100,
            //                 "createTime" => 1609991676000,
            //                 "updateTime" => 1609991676000,
            //                 "autoAddIm" => false
            //             }
            //         )
            //     }
            //
            $data = $this->safe_value($response, 'data', array());
            return $this->parse_positions($data, $symbols);
        }) ();
    }

    public function parse_position($position, $market = null) {
        //
        //     {
        //         "positionId" => 1394650,
        //         "symbol" => "ETH_USDT",
        //         "positionType" => 1,
        //         "openType" => 1,
        //         "state" => 1,
        //         "holdVol" => 1,
        //         "frozenVol" => 0,
        //         "closeVol" => 0,
        //         "holdAvgPrice" => 1217.3,
        //         "openAvgPrice" => 1217.3,
        //         "closeAvgPrice" => 0,
        //         "liquidatePrice" => 1211.2,
        //         "oim" => 0.1290338,
        //         "im" => 0.1290338,
        //         "holdFee" => 0,
        //         "realised" => -0.0073,
        //         "leverage" => 100,
        //         "createTime" => 1609991676000,
        //         "updateTime" => 1609991676000,
        //         "autoAddIm" => false
        //     }
        //
        $market = $this->safe_market($this->safe_string($position, 'symbol'), $market);
        $symbol = $market['symbol'];
        $contracts = $this->safe_string($position, 'holdVol');
        $entryPrice = $this->safe_number($position, 'openAvgPrice');
        $initialMargin = $this->safe_string($position, 'im');
        $rawSide = $this->safe_string($position, 'positionType');
        $side = ($rawSide === '1') ? 'long' : 'short';
        $openType = $this->safe_string($position, 'margin_mode');
        $marginType = ($openType === '1') ? 'isolated' : 'cross';
        $leverage = $this->safe_number($position, 'leverage');
        $liquidationPrice = $this->safe_number($position, 'liquidatePrice');
        $timestamp = $this->safe_number($position, 'updateTime');
        return array(
            'info' => $position,
            'id' => null,
            'symbol' => $symbol,
            'contracts' => $this->parse_number($contracts),
            'contractSize' => null,
            'entryPrice' => $entryPrice,
            'collateral' => null,
            'side' => $side,
            'unrealizedProfit' => null,
            'leverage' => $this->parse_number($leverage),
            'percentage' => null,
            'marginType' => $marginType,
            'notional' => null,
            'markPrice' => null,
            'liquidationPrice' => $liquidationPrice,
            'initialMargin' => $this->parse_number($initialMargin),
            'initialMarginPercentage' => null,
            'maintenanceMargin' => null,
            'maintenanceMarginPercentage' => null,
            'marginRatio' => null,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
        );
    }

    public function fetch_transfer($id, $since = null, $limit = null, $params = array ()) {
        return Async\async(function () use ($id, $since, $limit, $params) {
            list($marketType, $query) = $this->handle_market_type_and_params('fetchTransfer', null, $params);
            Async\await($this->load_markets());
            if ($marketType === 'spot') {
                $request = array(
                    'transact_id' => $id,
                );
                $response = Async\await($this->spot2PrivateGetAssetInternalTransferInfo (array_merge($request, $query)));
                //
                //     {
                //         code => '200',
                //         $data => {
                //             currency => 'USDT',
                //             amount => '1',
                //             transact_id => '954877a2ef54499db9b28a7cf9ebcf41',
                //             from => 'MAIN',
                //             to => 'CONTRACT',
                //             transact_state => 'SUCCESS'
                //         }
                //     }
                //
                $data = $this->safe_value($response, 'data', array());
                return $this->parse_transfer($data);
            } elseif ($marketType === 'swap') {
                throw new BadRequest($this->id . ' fetchTransfer() is not supported for ' . $marketType);
            }
        }) ();
    }

    public function fetch_transfers($code = null, $since = null, $limit = null, $params = array ()) {
        return Async\async(function () use ($code, $since, $limit, $params) {
            /**
             * fetch a history of internal transfers made on an account
             * @param {string|null} $code unified $currency $code of the $currency transferred
             * @param {int|null} $since the earliest time in ms to fetch transfers for
             * @param {int|null} $limit the maximum number of  transfers structures to retrieve
             * @param {array} $params extra parameters specific to the mexc3 api endpoint
             * @return {[array]} a list of {@link https://docs.ccxt.com/en/latest/manual.html#transfer-structure transfer structures}
             */
            list($marketType, $query) = $this->handle_market_type_and_params('fetchTransfers', null, $params);
            Async\await($this->load_markets());
            $request = array();
            $currency = null;
            $resultList = null;
            if ($code !== null) {
                $currency = $this->currency($code);
                $request['currency'] = $currency['id'];
            }
            if ($marketType === 'spot') {
                if ($since !== null) {
                    $request['start_time'] = $since;
                }
                if ($limit !== null) {
                    if ($limit > 50) {
                        throw new ExchangeError('This exchange supports a maximum $limit of 50');
                    }
                    $request['page-size'] = $limit;
                }
                $response = Async\await($this->spot2PrivateGetAssetInternalTransferRecord (array_merge($request, $query)));
                //
                //     {
                //         $code => '200',
                //         $data => {
                //             total_page => '1',
                //             total_size => '5',
                //             result_list => [array(
                //                     $currency => 'USDT',
                //                     amount => '1',
                //                     transact_id => '954877a2ef54499db9b28a7cf9ebcf41',
                //                     from => 'MAIN',
                //                     to => 'CONTRACT',
                //                     transact_state => 'SUCCESS'
                //                 ),
                //                 ...
                //             ]
                //         }
                //     }
                //
                $data = $this->safe_value($response, 'data', array());
                $resultList = $this->safe_value($data, 'result_list', array());
            } elseif ($marketType === 'swap') {
                if ($limit !== null) {
                    $request['page_size'] = $limit;
                }
                $response = Async\await($this->contractPrivateGetAccountTransferRecord (array_merge($request, $query)));
                $data = $this->safe_value($response, 'data');
                $resultList = $this->safe_value($data, 'resultList');
                //
                //     {
                //         "success" => true,
                //         "code" => "0",
                //         "data" => {
                //             "pageSize" => "20",
                //             "totalCount" => "10",
                //             "totalPage" => "1",
                //             "currentPage" => "1",
                //             "resultList" => array(
                //                 array(
                //                     "id" => "2980812",
                //                     "txid" => "fa8a1e7bf05940a3b7025856dc48d025",
                //                     "currency" => "USDT",
                //                     "amount" => "22.90213135",
                //                     "type" => "IN",
                //                     "state" => "SUCCESS",
                //                     "createTime" => "1648849076000",
                //                     "updateTime" => "1648849076000"
                //                 ),
                //             )
                //         }
                //     }
                //
            }
            return $this->parse_transfers($resultList, $currency, $since, $limit);
        }) ();
    }

    public function transfer($code, $amount, $fromAccount, $toAccount, $params = array ()) {
        return Async\async(function () use ($code, $amount, $fromAccount, $toAccount, $params) {
            /**
             * transfer $currency internally between wallets on the same account
             * @see https://mxcdevelop.github.io/apidocs/spot_v3_en/#user-universal-transfer
             * @param {string} $code unified $currency $code
             * @param {float} $amount amount to transfer
             * @param {string} $fromAccount account to transfer from
             * @param {string} $toAccount account to transfer to
             * @param {array} $params extra parameters specific to the mexc3 api endpoint
             * @param {string|null} $params->symbol $market $symbol required for margin account transfers eg:BTCUSDT
             * @return {array} a {@link https://docs.ccxt.com/en/latest/manual.html#transfer-structure transfer structure}
             */
            Async\await($this->load_markets());
            $currency = $this->currency($code);
            $accounts = array(
                'spot' => 'SPOT',
                'swap' => 'FUTURES',
                'margin' => 'ISOLATED_MARGIN',
            );
            $fromId = $this->safe_string($accounts, $fromAccount);
            $toId = $this->safe_string($accounts, $toAccount);
            if ($fromId === null) {
                $keys = is_array($accounts) ? array_keys($accounts) : array();
                throw new ExchangeError($this->id . ' $fromAccount must be one of ' . implode(', ', $keys));
            }
            if ($toId === null) {
                $keys = is_array($accounts) ? array_keys($accounts) : array();
                throw new ExchangeError($this->id . ' $toAccount must be one of ' . implode(', ', $keys));
            }
            $request = array(
                'asset' => $currency['id'],
                'amount' => $amount,
                'fromAccountType' => $fromId,
                'toAccountType' => $toId,
            );
            if (($fromId === 'ISOLATED_MARGIN') || ($toId === 'ISOLATED_MARGIN')) {
                $symbol = $this->safe_string($params, 'symbol');
                $params = $this->omit($params, 'symbol');
                if ($symbol === null) {
                    throw new ArgumentsRequired($this->id . ' transfer() requires a $symbol argument for isolated margin');
                }
                $market = $this->market($symbol);
                $request['symbol'] = $market['id'];
            }
            $response = Async\await($this->spotPrivatePostCapitalTransfer (array_merge($request, $params)));
            //
            //     {
            //         "tranId" => "ebb06123e6a64f4ab234b396c548d57e"
            //     }
            //
            $transaction = $this->parse_transfer($response, $currency);
            return array_merge($transaction, array(
                'amount' => $amount,
                'fromAccount' => $fromAccount,
                'toAccount' => $toAccount,
            ));
        }) ();
    }

    public function parse_transfer($transfer, $currency = null) {
        //
        // spot => fetchTransfer
        //
        //     {
        //         $currency => 'USDT',
        //         amount => '1',
        //         transact_id => 'b60c1df8e7b24b268858003f374ecb75',
        //         from => 'MAIN',
        //         to => 'CONTRACT',
        //         transact_state => 'WAIT'
        //     }
        //
        // swap => fetchTransfer
        //
        //     {
        //         "currency" => "USDT",
        //         "amount" => "22.90213135",
        //         "txid" => "fa8a1e7bf05940a3b7025856dc48d025",
        //         "id" => "2980812",
        //         "type" => "IN",
        //         "state" => "SUCCESS",
        //         "createTime" => "1648849076000",
        //         "updateTime" => "1648849076000"
        //     }
        //
        // $transfer
        //
        //     {
        //         "tranId" => "ebb06123e6a64f4ab234b396c548d57e"
        //     }
        //
        $currencyId = $this->safe_string($transfer, 'currency');
        $id = $this->safe_string_n($transfer, array( 'transact_id', 'txid', 'tranId' ));
        $timestamp = $this->safe_integer($transfer, 'createTime');
        $datetime = ($timestamp !== null) ? $this->iso8601($timestamp) : null;
        $direction = $this->safe_string($transfer, 'type');
        $accountFrom = null;
        $accountTo = null;
        if ($direction !== null) {
            $accountFrom = ($direction === 'IN') ? 'MAIN' : 'CONTRACT';
            $accountTo = ($direction === 'IN') ? 'CONTRACT' : 'MAIN';
        } else {
            $accountFrom = $this->safe_string($transfer, 'from');
            $accountTo = $this->safe_string($transfer, 'to');
        }
        return array(
            'info' => $transfer,
            'id' => $id,
            'timestamp' => $timestamp,
            'datetime' => $datetime,
            'currency' => $this->safe_currency_code($currencyId, $currency),
            'amount' => $this->safe_number($transfer, 'amount'),
            'fromAccount' => $this->parse_account_id($accountFrom),
            'toAccount' => $this->parse_account_id($accountTo),
            'status' => $this->parse_transfer_status($this->safe_string_2($transfer, 'transact_state', 'state')),
        );
    }

    public function parse_account_id($status) {
        $statuses = array(
            'MAIN' => 'spot',
            'CONTRACT' => 'swap',
        );
        return $this->safe_string($statuses, $status, $status);
    }

    public function parse_transfer_status($status) {
        $statuses = array(
            'SUCCESS' => 'ok',
            'FAILED' => 'failed',
            'WAIT' => 'pending',
        );
        return $this->safe_string($statuses, $status, $status);
    }

    public function withdraw($code, $amount, $address, $tag = null, $params = array ()) {
        return Async\async(function () use ($code, $amount, $address, $tag, $params) {
            /**
             * make a withdrawal
             * @see https://mxcdevelop.github.io/apidocs/spot_v3_en/#withdraw
             * @param {string} $code unified $currency $code
             * @param {float} $amount the $amount to withdraw
             * @param {string} $address the $address to withdraw to
             * @param {string|null} $tag
             * @param {array} $params extra parameters specific to the mexc3 api endpoint
             * @return {array} a {@link https://docs.ccxt.com/en/latest/manual.html#transaction-structure transaction structure}
             */
            list($tag, $params) = $this->handle_withdraw_tag_and_params($tag, $params);
            $networks = $this->safe_value($this->options, 'networks', array());
            $network = $this->safe_string_upper_2($params, 'network', 'chain'); // this line allows the user to specify either ERC20 or ETH
            $network = $this->safe_string($networks, $network, $network); // handle ETH > ERC-20 alias
            $this->check_address($address);
            Async\await($this->load_markets());
            $currency = $this->currency($code);
            $request = array(
                'coin' => $currency['id'],
                'address' => $address,
                'amount' => $amount,
            );
            if ($tag !== null) {
                $request['memo'] = $tag;
            }
            if ($network !== null) {
                $request['network'] = $network;
                $params = $this->omit($params, 'network');
            }
            $response = Async\await($this->spotPrivatePostCapitalWithdrawApply (array_merge($request, $params)));
            //
            //     {
            //       "id":"7213fea8e94b4a5593d507237e5a555b"
            //     }
            //
            return $this->parse_transaction($response, $currency);
        }) ();
    }

    public function set_position_mode($hedged, $symbol = null, $params = array ()) {
        return Async\async(function () use ($hedged, $symbol, $params) {
            $request = array(
                'positionMode' => $hedged ? 1 : 2, // 1 Hedge, 2 One-way, before changing position mode make sure that there are no active orders, planned orders, or open positions, the risk limit level will be reset to 1
            );
            $response = Async\await($this->contractPrivatePostPositionChangePositionMode (array_merge($request, $params)));
            //
            //     {
            //         "success":true,
            //         "code":0
            //     }
            //
            return $response;
        }) ();
    }

    public function fetch_position_mode($symbol = null, $params = array ()) {
        return Async\async(function () use ($symbol, $params) {
            $response = Async\await($this->contractPrivateGetPositionPositionMode ($params));
            //
            //     {
            //         "success":true,
            //         "code":0,
            //         "data":2
            //     }
            //
            $positionMode = $this->safe_integer($response, 'data');
            return array(
                'info' => $response,
                'hedged' => ($positionMode === 1),
            );
        }) ();
    }

    public function borrow_margin($code, $amount, $symbol = null, $params = array ()) {
        return Async\async(function () use ($code, $amount, $symbol, $params) {
            /**
             * create a loan to borrow margin
             * @see https://mxcdevelop.github.io/apidocs/spot_v3_en/#loan
             * @param {string} $code unified $currency $code of the $currency to borrow
             * @param {float} $amount the $amount to borrow
             * @param {string} $symbol unified $market $symbol
             * @param {array} $params extra parameters specific to the mexc3 api endpoint
             * @return {array} a {@link https://docs.ccxt.com/en/latest/manual.html#margin-loan-structure margin loan structure}
             */
            Async\await($this->load_markets());
            if ($symbol === null) {
                throw new ArgumentsRequired($this->id . ' borrowMargin() requires a $symbol argument for isolated margin');
            }
            $market = $this->market($symbol);
            $currency = $this->currency($code);
            $request = array(
                'asset' => $currency['id'],
                'amount' => $this->currency_to_precision($code, $amount),
                'symbol' => $market['id'],
            );
            $response = Async\await($this->spotPrivatePostMarginLoan (array_merge($request, $params)));
            //
            //     {
            //         "tranId" => "762407666453712896"
            //     }
            //
            $transaction = $this->parse_margin_loan($response, $currency);
            return array_merge($transaction, array(
                'amount' => $amount,
                'symbol' => $symbol,
            ));
        }) ();
    }

    public function repay_margin($code, $amount, $symbol = null, $params = array ()) {
        return Async\async(function () use ($code, $amount, $symbol, $params) {
            /**
             * repay borrowed margin and interest
             * @see https://mxcdevelop.github.io/apidocs/spot_v3_en/#repayment
             * @param {string} $code unified $currency $code of the $currency to repay
             * @param {float} $amount the $amount to repay
             * @param {string} $symbol unified $market $symbol
             * @param {array} $params extra parameters specific to the mexc3 api endpoint
             * @param {string} $params->borrowId $transaction $id '762407666453712896'
             * @return {array} a {@link https://docs.ccxt.com/en/latest/manual.html#margin-loan-structure margin loan structure}
             */
            Async\await($this->load_markets());
            if ($symbol === null) {
                throw new ArgumentsRequired($this->id . ' repayMargin() requires a $symbol argument for isolated margin');
            }
            $id = $this->safe_string_2($params, 'id', 'borrowId');
            if ($id === null) {
                throw new ArgumentsRequired($this->id . ' repayMargin() requires a borrowId argument in the params');
            }
            $market = $this->market($symbol);
            $currency = $this->currency($code);
            $request = array(
                'asset' => $currency['id'],
                'amount' => $this->currency_to_precision($code, $amount),
                'borrowId' => $id,
                'symbol' => $market['id'],
            );
            $response = Async\await($this->spotPrivatePostMarginRepay (array_merge($request, $params)));
            //
            //     {
            //         "tranId" => "762407666453712896"
            //     }
            //
            $transaction = $this->parse_margin_loan($response, $currency);
            return array_merge($transaction, array(
                'amount' => $amount,
                'symbol' => $symbol,
            ));
        }) ();
    }

    public function fetch_transaction_fees($codes = null, $params = array ()) {
        return Async\async(function () use ($codes, $params) {
            /**
             * fetch deposit and withdrawal fees
             * @see https://mxcdevelop.github.io/apidocs/spot_v3_en/#query-the-currency-information
             * @param {[string]|null} $codes returns fees for all currencies if null
             * @param {array} $params extra parameters specific to the mexc3 api endpoint
             * @return {[array]} a list of {@link https://docs.ccxt.com/en/latest/manual.html#fee-structure fee structures}
             */
            Async\await($this->load_markets());
            $response = Async\await($this->spotPrivateGetCapitalConfigGetall ($params));
            //
            //    array(
            //       {
            //           coin => 'AGLD',
            //           name => 'Adventure Gold',
            //           networkList => array(
            //               array(
            //                   coin => 'AGLD',
            //                   depositDesc => null,
            //                   depositEnable => true,
            //                   minConfirm => '0',
            //                   name => 'Adventure Gold',
            //                   network => 'ERC20',
            //                   withdrawEnable => true,
            //                   withdrawFee => '10.000000000000000000',
            //                   withdrawIntegerMultiple => null,
            //                   withdrawMax => '1200000.000000000000000000',
            //                   withdrawMin => '20.000000000000000000',
            //                   sameAddress => false,
            //                   contract => '0x32353a6c91143bfd6c7d363b546e62a9a2489a20',
            //                   withdrawTips => null,
            //                   depositTips => null
            //               }
            //               ...
            //           )
            //       ),
            //       ...
            //    )
            //
            return $this->parse_transaction_fees($response, $codes);
        }) ();
    }

    public function parse_transaction_fees($response, $codes = null) {
        $withdrawFees = array();
        for ($i = 0; $i < count($response); $i++) {
            $entry = $response[$i];
            $currencyId = $this->safe_string($entry, 'coin');
            $currency = $this->safe_currency($currencyId);
            $code = $this->safe_string($currency, 'code');
            if (($codes === null) || ($this->in_array($code, $codes))) {
                $withdrawFees[$code] = $this->parse_transaction_fee($entry, $currency);
            }
        }
        return array(
            'withdraw' => $withdrawFees,
            'deposit' => array(),
            'info' => $response,
        );
    }

    public function parse_transaction_fee($transaction, $currency = null) {
        //
        //    {
        //        coin => 'AGLD',
        //        name => 'Adventure Gold',
        //        $networkList => array(
        //            {
        //                coin => 'AGLD',
        //                depositDesc => null,
        //                depositEnable => true,
        //                minConfirm => '0',
        //                name => 'Adventure Gold',
        //                network => 'ERC20',
        //                withdrawEnable => true,
        //                withdrawFee => '10.000000000000000000',
        //                withdrawIntegerMultiple => null,
        //                withdrawMax => '1200000.000000000000000000',
        //                withdrawMin => '20.000000000000000000',
        //                sameAddress => false,
        //                contract => '0x32353a6c91143bfd6c7d363b546e62a9a2489a20',
        //                withdrawTips => null,
        //                depositTips => null
        //            }
        //            ...
        //        )
        //    }
        //
        $networkList = $this->safe_value($transaction, 'networkList', array());
        $result = array();
        for ($j = 0; $j < count($networkList); $j++) {
            $networkEntry = $networkList[$j];
            $networkId = $this->safe_string($networkEntry, 'network');
            $networkCode = $this->safe_string($this->options['networks'], $networkId, $networkId);
            $fee = $this->safe_number($networkEntry, 'withdrawFee');
            $result[$networkCode] = $fee;
        }
        return $result;
    }

    public function fetch_deposit_withdraw_fees($codes = null, $params = array ()) {
        return Async\async(function () use ($codes, $params) {
            /**
             * fetch deposit and withdrawal fees
             * @see https://mxcdevelop.github.io/apidocs/spot_v3_en/#query-the-currency-information
             * @param {[string]|null} $codes returns fees for all currencies if null
             * @param {array} $params extra parameters specific to the mexc3 api endpoint
             * @return {[array]} a list of {@link https://docs.ccxt.com/en/latest/manual.html#fee-structure fee structures}
             */
            Async\await($this->load_markets());
            $response = Async\await($this->spotPrivateGetCapitalConfigGetall ($params));
            //
            //    array(
            //       {
            //           coin => 'AGLD',
            //           name => 'Adventure Gold',
            //           networkList => array(
            //               array(
            //                   coin => 'AGLD',
            //                   depositDesc => null,
            //                   depositEnable => true,
            //                   minConfirm => '0',
            //                   name => 'Adventure Gold',
            //                   network => 'ERC20',
            //                   withdrawEnable => true,
            //                   withdrawFee => '10.000000000000000000',
            //                   withdrawIntegerMultiple => null,
            //                   withdrawMax => '1200000.000000000000000000',
            //                   withdrawMin => '20.000000000000000000',
            //                   sameAddress => false,
            //                   contract => '0x32353a6c91143bfd6c7d363b546e62a9a2489a20',
            //                   withdrawTips => null,
            //                   depositTips => null
            //               }
            //               ...
            //           )
            //       ),
            //       ...
            //    )
            //
            return $this->parse_deposit_withdraw_fees($response, $codes, 'coin');
        }) ();
    }

    public function parse_deposit_withdraw_fee($fee, $currency = null) {
        //
        //    {
        //        coin => 'AGLD',
        //        name => 'Adventure Gold',
        //        $networkList => array(
        //            {
        //                coin => 'AGLD',
        //                depositDesc => null,
        //                depositEnable => true,
        //                minConfirm => '0',
        //                name => 'Adventure Gold',
        //                network => 'ERC20',
        //                withdrawEnable => true,
        //                withdrawFee => '10.000000000000000000',
        //                withdrawIntegerMultiple => null,
        //                withdrawMax => '1200000.000000000000000000',
        //                withdrawMin => '20.000000000000000000',
        //                sameAddress => false,
        //                contract => '0x32353a6c91143bfd6c7d363b546e62a9a2489a20',
        //                withdrawTips => null,
        //                depositTips => null
        //            }
        //            ...
        //        )
        //    }
        //
        $networkList = $this->safe_value($fee, 'networkList', array());
        $result = $this->deposit_withdraw_fee($fee);
        for ($j = 0; $j < count($networkList); $j++) {
            $networkEntry = $networkList[$j];
            $networkId = $this->safe_string($networkEntry, 'network');
            $networkCode = $this->network_id_to_code($networkId, $this->safe_string($currency, 'code'));
            $result['networks'][$networkCode] = array(
                'withdraw' => array(
                    'fee' => $this->safe_number($networkEntry, 'withdrawFee'),
                    'percentage' => null,
                ),
                'deposit' => array(
                    'fee' => null,
                    'percentage' => null,
                ),
            );
        }
        return $this->assign_default_deposit_withdraw_fees($result);
    }

    public function parse_margin_loan($info, $currency = null) {
        //
        //     {
        //         "tranId" => "762407666453712896"
        //     }
        //
        return array(
            'id' => $this->safe_string($info, 'tranId'),
            'currency' => $this->safe_currency_code(null, $currency),
            'amount' => null,
            'symbol' => null,
            'timestamp' => null,
            'datetime' => null,
            'info' => $info,
        );
    }

    public function handle_margin_mode_and_params($methodName, $params = array (), $defaultValue = null) {
        /**
         * @ignore
         * $marginMode specified by $params["marginMode"], $this->options["marginMode"], $this->options["defaultMarginMode"], $params["margin"] = true or $this->options["defaultType"] = 'margin'
         * @param {array} $params extra parameters specific to the exchange api endpoint
         * @param {bool|null} $params->margin true for trading spot-margin
         * @return array([string|null, object]) the $marginMode in lowercase
         */
        $defaultType = $this->safe_string($this->options, 'defaultType');
        $isMargin = $this->safe_value($params, 'margin', false);
        $marginMode = null;
        list($marginMode, $params) = parent::handle_margin_mode_and_params($methodName, $params, $defaultValue);
        if (($defaultType === 'margin') || ($isMargin === true)) {
            $marginMode = 'isolated';
        }
        return array( $marginMode, $params );
    }

    public function sign($path, $api = 'public', $method = 'GET', $params = array (), $headers = null, $body = null) {
        list($section, $access) = $api;
        list($path, $params) = $this->resolve_path($path, $params);
        $url = null;
        if ($section === 'spot') {
            $url = $this->urls['api'][$section][$access] . '/api/' . $this->version . '/' . $path;
            $paramsEncoded = '';
            if ($access === 'private') {
                $params['timestamp'] = $this->milliseconds();
                $params['recvWindow'] = $this->safe_integer($this->options, 'recvWindow', 5000);
            }
            if ($params) {
                $paramsEncoded = $this->urlencode($params);
                $url .= '?' . $paramsEncoded;
            }
            if ($access === 'private') {
                $this->check_required_credentials();
                $signature = $this->hmac($this->encode($paramsEncoded), $this->encode($this->secret), 'sha256');
                $url .= '&' . 'signature=' . $signature;
                $headers = array(
                    'X-MEXC-APIKEY' => $this->apiKey,
                    'source' => $this->safe_string($this->options, 'broker', 'CCXT'),
                );
            }
            if ($method === 'POST') {
                $headers['Content-Type'] = 'application/json';
            }
        } elseif ($section === 'contract' || $section === 'spot2') {
            $url = $this->urls['api'][$section][$access] . '/' . $this->implode_params($path, $params);
            $params = $this->omit($params, $this->extract_params($path));
            if ($access === 'public') {
                if ($params) {
                    $url .= '?' . $this->urlencode($params);
                }
            } else {
                $this->check_required_credentials();
                $timestamp = (string) $this->milliseconds();
                $auth = '';
                $headers = array(
                    'ApiKey' => $this->apiKey,
                    'Request-Time' => $timestamp,
                    'Content-Type' => 'application/json',
                );
                if ($method === 'POST') {
                    $auth = $this->json($params);
                    $body = $auth;
                } else {
                    $params = $this->keysort($params);
                    if ($params) {
                        $auth .= $this->urlencode($params);
                        $url .= '?' . $auth;
                    }
                }
                $auth = $this->apiKey . $timestamp . $auth;
                $signature = $this->hmac($this->encode($auth), $this->encode($this->secret), 'sha256');
                $headers['Signature'] = $signature;
            }
        }
        return array( 'url' => $url, 'method' => $method, 'body' => $body, 'headers' => $headers );
    }

    public function handle_errors($code, $reason, $url, $method, $headers, $body, $response, $requestHeaders, $requestBody) {
        if ($response === null) {
            return;
        }
        // spot
        //     array("code":-1128,"msg":"Combination of optional parameters invalid.","_extend":null)
        //     array("success":false,"code":123456,"message":"Order quantity error....")
        //
        // contract
        //
        //     array("code":10232,"msg":"The currency not exist")
        //     array("code":10216,"msg":"No available deposit address")
        //     array("success":true, "code":0, "data":1634095541710)
        //
        $success = $this->safe_value($response, 'success', false); // v1
        if ($success === true) {
            return;
        }
        $responseCode = $this->safe_string($response, 'code', null);
        if (($responseCode !== null) && ($responseCode !== '200') && ($responseCode !== '0')) {
            $feedback = $this->id . ' ' . $body;
            $this->throw_broadly_matched_exception($this->exceptions['broad'], $body, $feedback);
            $this->throw_exactly_matched_exception($this->exceptions['exact'], $responseCode, $feedback);
            throw new ExchangeError($feedback);
        }
    }
}
