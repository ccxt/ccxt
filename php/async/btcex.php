<?php

namespace ccxt\async;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

use Exception; // a common import
use ccxt\ExchangeError;
use ccxt\AuthenticationError;
use ccxt\ArgumentsRequired;
use ccxt\Precise;
use React\Async;

class btcex extends Exchange {

    public function describe() {
        return $this->deep_extend(parent::describe(), array(
            'id' => 'btcex',
            'name' => 'BTCEX',
            'countries' => array( 'CA' ), // Canada
            'version' => 'v1',
            'certified' => false,
            'pro' => false,
            'requiredCredentials' => array(
                'apiKey' => true,
                'secret' => true,
            ),
            'urls' => array(
                'logo' => 'https://user-images.githubusercontent.com/1294454/173489620-d49807a4-55cd-4f4e-aca9-534921298bbf.jpg',
                'www' => 'https://www.btcex.com/',
                'api' => array(
                    'rest' => 'https://api.btcex.com',
                ),
                'doc' => 'https://docs.btcex.com/',
                'fees' => 'https://support.btcex.com/hc/en-us/articles/4415995130647',
                'referral' => array(
                    'url' => 'https://www.btcex.com/en-us/register?i=48biatg1',
                    'discount' => 0.1,
                ),
            ),
            'has' => array(
                'CORS' => null,
                'spot' => true,
                'margin' => true,
                'swap' => true,
                'future' => true,
                'option' => true,
                'cancelAllOrders' => true,
                'cancelOrder' => true,
                'createOrder' => true,
                'editOrder' => false,
                'fetchBalance' => true,
                'fetchBorrowRate' => false,
                'fetchBorrowRateHistories' => false,
                'fetchBorrowRateHistory' => false,
                'fetchBorrowRates' => false,
                'fetchClosedOrders' => true,
                'fetchCurrencies' => false,
                'fetchDepositAddress' => false,
                'fetchDeposits' => true,
                'fetchFundingHistory' => false,
                'fetchFundingRate' => false,
                'fetchFundingRateHistory' => false,
                'fetchFundingRates' => false,
                'fetchIndexOHLCV' => false,
                'fetchMarginMode' => false,
                'fetchMarkets' => true,
                'fetchMarkOHLCV' => false,
                'fetchMyTrades' => true,
                'fetchOHLCV' => true,
                'fetchOpenOrders' => true,
                'fetchOrder' => true,
                'fetchOrderBook' => true,
                'fetchOrders' => true,
                'fetchOrderTrades' => true,
                'fetchPosition' => true,
                'fetchPositionMode' => false,
                'fetchPositions' => true,
                'fetchPremiumIndexOHLCV' => false,
                'fetchTicker' => true,
                'fetchTickers' => false,
                'fetchTime' => false,
                'fetchTrades' => true,
                'fetchTradingFee' => false,
                'fetchTradingFees' => false,
                'fetchTransactionFees' => null,
                'fetchWithdrawal' => true,
                'fetchWithdrawals' => true,
                'signIn' => true,
                'withdraw' => false,
            ),
            'timeframes' => array(
                '15s' => '15',
                '1m' => '60',
                '5m' => '300',
                '15m' => '900',
                '1h' => '3600',
                '4h' => '14400',
                '1d' => '86400',
                '3d' => '259200',
                '1w' => '604800',
                '2w' => '1209600',
                '1M' => '2592000',
            ),
            'api' => array(
                'public' => array(
                    'get' => array(
                        // Market data
                        'get_last_trades_by_currency',
                        'get_last_trades_by_instrument',
                        'get_order_book',
                        'tickers',
                        'get_instruments',
                        'get_tradingview_chart_data',
                        // CMC
                        'cmc_spot_summary',
                        'cmc_spot_ticker',
                        'cmc_spot_orderbook',
                        'cmc_market_trades',
                        'cmc_contracts',
                        'cmc_contract_orderbook',
                        // CoinGecko
                        'coin_gecko_spot_pairs',
                        'coin_gecko_spot_ticker',
                        'coin_gecko_spot_orderbook',
                        'coin_gecko_market_trades',
                        'coin_gecko_contracts',
                        'coin_gecko_contract_orderbook',
                    ),
                    'post' => array(
                        'auth',
                    ),
                ),
                'private' => array(
                    'get' => array(
                        // wallet
                        'get_deposit_record',
                        'get_withdraw_record',
                        // trade
                        'get_position',
                        'get_positions',
                        'get_open_orders_by_currency',
                        'get_open_orders_by_instrument',
                        'get_order_history_by_currency',
                        'get_order_history_by_instrument',
                        'get_order_state',
                        'get_user_trades_by_currency',
                        'get_user_trades_by_instrument',
                        'get_user_trades_by_order',
                    ),
                    'post' => array(
                        // auth
                        'logout',
                        // wallet
                        'get_assets_info',
                        'add_withdraw_address',
                        // trade
                        'buy',
                        'sell',
                        'cancel',
                        'cancel_all_by_currency',
                        'cancel_all_by_instrument',
                        'close_position',
                    ),
                    'delete' => array(),
                ),
            ),
            'fees' => array(
                'trading' => array(
                    'tierBased' => false,
                    'percentage' => true,
                    'maker' => $this->parse_number('0.001'),
                    'taker' => $this->parse_number('0.001'),
                ),
                'margin' => array(
                    'tierBased' => false,
                    'percentage' => true,
                    'maker' => $this->parse_number('0.001'),
                    'taker' => $this->parse_number('0.001'),
                ),
                'perpetual' => array(
                    'tierBased' => false,
                    'percentage' => true,
                    'maker' => $this->parse_number('0.002'),
                    'taker' => $this->parse_number('0.002'),
                ),
            ),
            'exceptions' => array(
                'exact' => array(
                    '9999' => '\\ccxt\\ExchangeError', // SYSTEM_INNER_ERROR System error, please try again later
                    '9900' => '\\ccxt\\ExchangeNotAvailable', // SERVICE_BUSY Service is busyï¼Œplease try again later
                    '401' => '\\ccxt\\AuthenticationError', // UNAUTHENTICATION_ERROR UnAuthentication
                    '403' => '\\ccxt\\AuthenticationError', // ACCESS_DENIED_ERROR Access denied
                    '1000' => '\\ccxt\\ExchangeNotAvailable', // NO_SERVICE No service found
                    '1001' => '\\ccxt\\BadRequest', // BAD_REQUEST Bad requested
                    '2000' => '\\ccxt\\AuthenticationError', // NEED_LOGIN Login is required
                    '2001' => '\\ccxt\\AuthenticationError', // ACCOUNT_NOT_MATCH Account information does not match
                    '2002' => '\\ccxt\\AuthenticationError', // ACCOUNT_NEED_ENABLE Account needs to be activated
                    '2003' => '\\ccxt\\AuthenticationError', // ACCOUNT_NOT_AVAILABLE Account not available
                    '3000' => '\\ccxt\\AuthenticationError', // TEST user
                    '3002' => '\\ccxt\\AuthenticationError', // NICKNAME_EXIST Nicknames exist
                    '3003' => '\\ccxt\\AuthenticationError', // ACCOUNT_NOT_EXIST No account
                    '3004' => '\\ccxt\\BadRequest', // PARAM_ERROR Parameter exception
                    '3005' => '\\ccxt\\NotSupported', // LANGUAGE_NONSUPPORT Unsupported languages
                    '3007' => '\\ccxt\\AuthenticationError', // ONLY_SUBACCOUNT_OPE Sub-account operations only
                    '3008' => '\\ccxt\\AuthenticationError', // LOGIN_ENABLE Account not logged
                    '3009' => '\\ccxt\\AuthenticationError', // TFA_EXPIRE_ERROR Google key failed
                    '3011' => '\\ccxt\\AuthenticationError', // PASSWORD_ERROR Password error
                    '3012' => '\\ccxt\\AuthenticationError', // TFA_UUID_ERROR One-time unlock code error
                    '3013' => '\\ccxt\\RequestTimeout', // TIME_OUT time out
                    '3015' => '\\ccxt\\AuthenticationError', // ID_IS_ERROR id_is_error
                    '3016' => '\\ccxt\\AuthenticationError', // WRONG_SUBACCOUNT_NAME already taken
                    '3018' => '\\ccxt\\BadRequest', // USER_NAME_AT_LEAST_5_BYTE The user name must have at least 5 digits
                    '3019' => '\\ccxt\\BadRequest', // PASSWORD_AT_LEAST_8_BYTE 8-32 bits contain at least three of the numbers, capital, lowercase letters and special symbols!
                    '3020' => '\\ccxt\\BadRequest', // TFA_ALREADY_SET GoogleCode Already Set
                    '3021' => '\\ccxt\\BadRequest', // PWD_MATCH_ERROR pwd_match_error
                    '3022' => '\\ccxt\\BadRequest', // ILLEGAL_OPERATION illegal operation
                    '3023' => '\\ccxt\\BadRequest', // REMOVE_SUBACCOUNT_OVER_LIMIT remove subaccount over limit
                    '3024' => '\\ccxt\\BadRequest', // GOOGLE_VERIFICATION_CODE_TURNED_ON Google verification code turned on
                    '3025' => '\\ccxt\\BadRequest', // OPERATION_FAILURE The operation failure
                    '3026' => '\\ccxt\\BadRequest', // ACCOUNT_ACTIVED Account has Actived
                    '3027' => '\\ccxt\\BadRequest', // INVALID_EMAIL_ADDRESS Invalid email address!
                    '3028' => '\\ccxt\\BadRequest', // PASSWORD_FORMAT_ERROR Password format err
                    '3029' => '\\ccxt\\DDoSProtection', // ONE_MINUTE_LIMIT Only one operation per minute and the remaining ${times}s
                    '3030' => '\\ccxt\\DDoSProtection', // ONE_HOUR_LIMIT Do this up to 5 times per hour
                    '3031' => '\\ccxt\\BadRequest', // USER_NAME_UP_12_BYTE Up to 12 characters, only letters and numbers are supported
                    '3032' => '\\ccxt\\BadRequest', // EMAIL_SETTED You need to set email address and password first
                    '3033' => '\\ccxt\\BadRequest', // PASSWORD_SETTED You need to set password first
                    '3034' => '\\ccxt\\AuthenticationError', // SUBACCOUNT_EMAIL_ACTIVATE You need to wait for email confirmation
                    '3035' => '\\ccxt\\BadRequest', // API_NOT_EXIST No api message
                    '3036' => '\\ccxt\\BadRequest', // UNAVAILABLE_IN_SUBACCOUNT Unavailable in subaccount
                    '3037' => '\\ccxt\\BadRequest', // MAX_SUBACCOUNT_NUMBER Limit of subaccounts is reached
                    '3038' => '\\ccxt\\BadRequest', // MAIN_SUBACCOUNT_EMAIL_SAME Provided email address is already used for your other subaccount
                    '3039' => '\\ccxt\\BadRequest', // MAX_API_KEY_NUMBER You cannot have more than 8 API keys
                    '3040' => '\\ccxt\\AuthenticationError', // ALPHA_TEST Non-invited users shall contact BTCEX Team to obtain the internal tests qualification
                    '3041' => '\\ccxt\\BadRequest', // API_NAME_MAX_LENGTH Name of key maximum length - 16 characters
                    '4000' => '\\ccxt\\BadRequest', // WALLET_ERROR Wallet error || RECHARGE_CLOSED Recharge closed
                    '4001' => '\\ccxt\\InvalidAddress', // WRONG_WITHDRAWAL_ADDRESS Wrong withdrawal address
                    '4002' => '\\ccxt\\InvalidAddress', // ADDRESS_DOES_NOT_EXIST Address does not exist
                    '4003' => '\\ccxt\\BadRequest', // WITHDRAWAL_CLOSED Withdrawal closed || TOO_SMALL_WITHDRAWAL_AMOUNT Too small withdrawal amount
                    '4004' => '\\ccxt\\NotSupported', // INTERNAL_TRANSFER_IS_NOT_SUPPORTED_TEMPORARILY Internal transfer is not supported temporarily
                    '4005' => '\\ccxt\\ExchangeError', // WITHDRAW_FAIL Withdrawal failed
                    '4006' => '\\ccxt\\InsufficientFunds', // INSUFFICIENT_ASSET ser asset not enough
                    '4007' => '\\ccxt\\BadRequest', // TRANSFER_ACCOUNT_ERROR Transfer account error
                    '4008' => '\\ccxt\\NotSupported', // AMOUNT_ERROR Amount error
                    '4009' => '\\ccxt\\InvalidAddress', // NO_RECHARGE_ADDRESS No recharge address
                    '4010' => '\\ccxt\\BadRequest', // GET_TRANSFER_SUBACCOUNT_ERROR Get transfer subaccount error
                    '4011' => '\\ccxt\\BadRequest', // TRANSFER_SUBMIT_URL_ERROR Transfer submit url error
                    '5001' => '\\ccxt\\InvalidOrder', // ORDER_PARAM_WRONG Order's param wrong.
                    '5002' => '\\ccxt\\OrderNotFound', // ORDER_DOSE_NOT_EXIST Order does not exist.
                    '5003' => '\\ccxt\\InvalidOrder', // CONTRACT_DOSE_NOT_EXIST Contract does not exist.
                    '5004' => '\\ccxt\\InvalidOrder', // ORDER_STATUS_ERR Order status error.
                    '5005' => '\\ccxt\\InvalidOrder', // ORDER_AMOUNT_MIN_TRANCSACTION_ERR Order amount min transaction error.
                    '5006' => '\\ccxt\\InvalidOrder', // ORDER_PRICE_MIN_TRANCSACTION_ERR Order price min price error.
                    '5007' => '\\ccxt\\InvalidOrder', // ORDER_PRICE_TICK_SIZE_ERR Order price tick size error.
                    '5008' => '\\ccxt\\InvalidOrder', // ORDER_TYPE_ERR Order type error.
                    '5009' => '\\ccxt\\InvalidOrder', // ORDER_OPTION_IS_EXPIRED Order option is expired.
                    '5010' => '\\ccxt\\InvalidOrder', // ORDER_IS_NOT_ACTIVE Order is not active.
                    '5011' => '\\ccxt\\InvalidOrder', // IV_ORDER_ARE_NOT_SUPPORTED Iv orders are not supported.
                    '5012' => '\\ccxt\\InvalidOrder', // ORDER_NO_MARK_PRICE_ERROR No mark price error.
                    '5013' => '\\ccxt\\InvalidOrder', // ORDER_PRICE_RANGE_IS_TOO_HIGH order price range is too high.
                    '5014' => '\\ccxt\\InvalidOrder', // ORDER_PRICE_RANGE_IS_TOO_LOW Order price range is too low.
                    '5109' => '\\ccxt\\InvalidOrder', // ORDER_PRICE_RANGE_IS_TOO_LOW Order price range is too low.
                    '5135' => '\\ccxt\\InvalidOrder', // The quantity should be larger than => 0.01
                    '5901' => '\\ccxt\\InvalidOrder', // TRANSFER_RESULT transfer out success.
                    '5902' => '\\ccxt\\InvalidOrder', // ORDER_SUCCESS place order success.
                    '5903' => '\\ccxt\\InvalidOrder', // ORDER_FAIL place order fail.
                    '5904' => '\\ccxt\\InvalidOrder', // PRICE_TRIGGER_LIQ price trigger liquidation
                    '5905' => '\\ccxt\\InvalidOrder', // LIQ_CANCEL liquidation make order cancel.
                    '5906' => '\\ccxt\\InvalidOrder', // LIQ_ORDER liquidation place a new order
                    '5907' => '\\ccxt\\InsufficientFunds', // ASSET_NOT_ENOUTH asset not enough
                    '8000' => '\\ccxt\\BadRequest', // PARAM_ERROR Request params not valid!
                    '8001' => '\\ccxt\\BadRequest', // DATA_NOT_EXIST The data doesn't exist!
                    '8100' => '\\ccxt\\BadRequest', // CODE_CHECK_FAIL Incorrect verification code
                    '8101' => '\\ccxt\\RequestTimeout', // CODE_NOT_EXIST Verification code time out, please retry later
                    '8102' => '\\ccxt\\DDoSProtection', // CODE_CHECK_FAIL_LIMIT Errors exceed the limit. Please try again after 24H.
                    '8103' => '\\ccxt\\BadRequest', // SMS_CODE_CHECK_FAIL Incorrect SMS verification code
                    '8104' => '\\ccxt\\BadRequest', // MAIL_CODE_CHECK_FAIL Incorrect mail verification code
                    '8105' => '\\ccxt\\BadRequest', // GOOGLE_CODE_CHECK_FAIL 2FA Code error!
                    '8106' => '\\ccxt\\DDoSProtection', // SMS_CODE_LIMIT Your message service is over limit today, please try tomorrow
                    '8107' => '\\ccxt\\ExchangeError', // REQUEST_FAILED Request failed
                    '11000' => '\\ccxt\\BadRequest', // CHANNEL_REGEX_ERROR channel regex not match
                ),
                'broad' => array(
                ),
            ),
            'precisionMode' => TICK_SIZE,
            'options' => array(
                'accountsByType' => array(
                    'wallet' => 'WALLET',
                    'spot' => 'SPOT',
                    'perpetual' => 'PERPETUAL',
                    'margin' => 'MARGIN',
                    'swap' => 'PERPETUAL',
                    'BTC' => 'BTC',
                    'ETH' => 'ETH',
                ),
            ),
            'commonCurrencies' => array(
            ),
        ));
    }

    public function fetch_markets($params = array ()) {
        return Async\async(function () use ($params) {
            $response = Async\await($this->publicGetGetInstruments ($params));
            $markets = $this->safe_value($response, 'result', array());
            //
            //     {
            //         "jsonrpc":"2.0",
            //         "usIn":1647533492507,
            //         "usOut":1647533492511,
            //         "usDiff":4,
            //         "result":[array(
            //             "currency":"BTC",
            //             "base_currency":"USDT",
            //             "contract_size":"0.01",
            //             "creation_timestamp":"1632384961348",
            //             "expiration_timestamp":"1648195200000",
            //             "instrument_name":"BTC-25MAR22",
            //             "show_name":"BTC-25MAR22",
            //             "is_active":true,
            //             "kind":"future",
            //             "leverage":0,
            //             "maker_commission":"10",
            //             "taker_commission":"17",
            //             "min_trade_amount":"0.01",
            //             "option_type":"init",
            //             "quote_currency":"USDT",
            //             "settlement_period":"week",
            //             "strike":"0",
            //             "tick_size":"0.1",
            //             "instr_multiple":"0.01",
            //             "order_price_low_rate":"0.8",
            //             "order_price_high_rate":"1.2",
            //             "order_price_limit_type":0,
            //             "min_qty":"0.01",
            //             "min_notional":"0",
            //             "support_trace_trade":false
            //         )]
            //     }
            //
            $result = array();
            for ($i = 0; $i < count($markets); $i++) {
                $market = $markets[$i];
                $id = $this->safe_string($market, 'instrument_name');
                $type = $this->safe_string($market, 'kind');
                $unifiedType = $type;
                if ($type === 'perpetual') {
                    $unifiedType = 'swap';
                }
                $baseId = $this->safe_string($market, 'quote_currency');
                $quoteId = $this->safe_string($market, 'base_currency');
                $swap = ($type === 'perpetual');
                $spot = ($type === 'spot');
                $margin = ($type === 'margin');
                $option = ($type === 'option');
                $future = ($type === 'future');
                $contract = $swap || $future || $option;
                $expiry = null;
                if ($option || $future) {
                    $baseId = $this->safe_string($market, 'currency');
                    $expiry = $this->safe_integer($market, 'expiration_timestamp');
                }
                $contractSize = null;
                $settleId = null;
                $settle = null;
                if ($contract) {
                    $settleId = $quoteId;
                    $settle = $this->safe_currency_code($settleId);
                }
                $optionType = null;
                $strike = null;
                if ($option) {
                    $optionType = $this->safe_string($market, 'option_type');
                    $strike = $this->safe_number($market, 'strike');
                }
                $base = $this->safe_currency_code($baseId);
                $quote = $this->safe_currency_code($quoteId);
                $symbol = null;
                if ($margin) {
                    $symbol = $id;
                } else {
                    $symbol = $base . '/' . $quote;
                }
                if ($contract) {
                    $contractSize = $this->safe_number($market, 'contract_size');
                    $symbol = $symbol . ':' . $settle;
                    if ($future || $option) {
                        $symbol = $symbol . '-' . $this->yymmdd($expiry);
                        if ($option) {
                            $letter = ($optionType === 'call') ? 'C' : 'P';
                            $symbol = $symbol . ':' . $this->number_to_string($strike) . ':' . $letter;
                        }
                    }
                }
                $minTradeAmount = $this->safe_number($market, 'min_trade_amount');
                $tickSize = $this->safe_number($market, 'tick_size');
                $maker = $this->safe_number($market, 'maker_commission');
                $taker = $this->safe_number($market, 'taker_commission');
                $percentage = !($option || $future);
                $result[] = array(
                    'id' => $id,
                    'symbol' => $symbol,
                    'base' => $base,
                    'quote' => $quote,
                    'baseId' => $baseId,
                    'quoteId' => $quoteId,
                    'settleId' => $settleId,
                    'settle' => $settle,
                    'type' => $unifiedType,
                    'maker' => $maker,
                    'taker' => $taker,
                    'percentage' => $percentage,
                    'spot' => $spot,
                    'margin' => $margin,
                    'swap' => $swap,
                    'future' => $future,
                    'option' => $option,
                    'active' => $this->safe_value($market, 'is_active'),
                    'contract' => $contract,
                    'linear' => $contract ? true : null,
                    'inverse' => $contract ? false : null,
                    'contractSize' => $contractSize,
                    'expiry' => $expiry,
                    'expiryDatetime' => $this->iso8601($expiry),
                    'strike' => $strike,
                    'optionType' => $optionType,
                    'precision' => array(
                        'amount' => $minTradeAmount,
                        'price' => $tickSize,
                    ),
                    'limits' => array(
                        'leverage' => array(
                            'min' => null,
                            'max' => $this->safe_string($market, 'leverage'),
                        ),
                        'amount' => array(
                            'min' => $minTradeAmount,
                            'max' => null,
                        ),
                        'price' => array(
                            'min' => $tickSize,
                            'max' => null,
                        ),
                        'cost' => array(
                            'min' => null,
                            'max' => null,
                        ),
                    ),
                    'info' => $market,
                );
            }
            return $result;
        }) ();
    }

    public function parse_ticker($ticker, $market = null) {
        //
        //     {
        //         "best_ask_amount":"0.20962",
        //         "best_ask_price":"40491.7",
        //         "best_bid_amount":"0.08855",
        //         "best_bid_price":"40491.6",
        //         "instrument_name":"BTC-USDT",
        //         "last_price":"40493",
        //         "mark_price":"40493.10644717",
        //         "state":"open",
        //         "stats":array(
        //             "high":"41468.8",
        //             "low":"40254.9",
        //             "price_change":"-0.0159",
        //             "volume":"3847.35240000000000005"
        //             "turnover":"1109811189.67100102035328746"
        //         ),
        //         "timestamp":"1647569486224"
        //     }
        //
        $marketId = $this->safe_string($ticker, 'instrument_name');
        $market = $this->safe_market($marketId, $market);
        $symbol = $this->safe_symbol($marketId, $market);
        $timestamp = $this->safe_integer($ticker, 'timestamp');
        $stats = $this->safe_value($ticker, 'stats');
        return $this->safe_ticker(array(
            'symbol' => $symbol,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'high' => $this->safe_string($stats, 'high'),
            'low' => $this->safe_string($stats, 'low'),
            'bid' => $this->safe_string($ticker, 'best_bid_price'),
            'bidVolume' => $this->safe_string($ticker, 'best_bid_amount'),
            'ask' => $this->safe_string($ticker, 'best_ask_price'),
            'askVolume' => $this->safe_string($ticker, 'best_ask_amount'),
            'vwap' => null,
            'open' => null,
            'close' => $this->safe_string($ticker, 'last_price'),
            'last' => $this->safe_string($ticker, 'last_price'),
            'previousClose' => null,
            'change' => null,
            'percentage' => $this->safe_string($stats, 'price_change'),
            'average' => null,
            'baseVolume' => $this->safe_string($stats, 'volume'),
            'quoteVolume' => $this->safe_string($stats, 'turnover'),
            'info' => $ticker,
        ), $market);
    }

    public function fetch_ticker($symbol, $params = array ()) {
        return Async\async(function () use ($symbol, $params) {
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $request = array(
                'instrument_name' => $market['id'],
            );
            $response = Async\await($this->publicGetTickers (array_merge($request, $params)));
            $result = $this->safe_value($response, 'result', array());
            //
            //     {
            //         "jsonrpc":"2.0",
            //         "usIn":1647569487238,
            //         "usOut":1647569487240,
            //         "usDiff":2,
            //         "result":[array(
            //             "best_ask_amount":"0.20962",
            //             "best_ask_price":"40491.7",
            //             "best_bid_amount":"0.08855",
            //             "best_bid_price":"40491.6",
            //             "instrument_name":"BTC-USDT",
            //             "last_price":"40493",
            //             "mark_price":"40493.10644717",
            //             "state":"open",
            //             "stats":array(
            //                 "high":"41468.8",
            //                 "low":"40254.9",
            //                 "price_change":"-0.0159",
            //                 "volume":"3847.35240000000000005"
            //             ),
            //             "timestamp":"1647569486224"
            //         )]
            //     }
            //
            $ticker = $this->safe_value($result, 0);
            return $this->parse_ticker($ticker, $market);
        }) ();
    }

    public function fetch_order_book($symbol, $limit = null, $params = array ()) {
        return Async\async(function () use ($symbol, $limit, $params) {
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $request = array(
                'instrument_name' => $market['id'],
            );
            $response = Async\await($this->publicGetGetOrderBook (array_merge($request, $params)));
            $result = $this->safe_value($response, 'result', array());
            //
            //     {
            //         "jsonrpc":"2.0",
            //         "usIn":1647573916524,
            //         "usOut":1647573916526,
            //         "usDiff":2,
            //         "result":{
            //             "asks":[["10155.00000","0.200","186.980","0.000"],["10663.00000","0.200","217.480","0.000"]],
            //             "bids":[["7896.00000","0.200","1.000","0.000"],["7481.00000","0.200","1.000","0.000"]],
            //             "timestamp":"1647573916525",
            //             "instrument_name":"BTC-25MAR22-32000-C",
            //             "version":1002541
            //         }
            //     }
            //
            $timestamp = $this->safe_integer($result, 'timestamp');
            return $this->parse_order_book($result, $market['symbol'], $timestamp);
        }) ();
    }

    public function parse_ohlcv($ohlcv, $market = null) {
        //
        //     {
        //         "tick":1647547200,
        //         "open":"40868.16800000",
        //         "high":"40877.65600000",
        //         "low":"40647.00000000",
        //         "close":"40699.10000000",
        //         "volume":"100.27789000",
        //         "cost":"4083185.78337596"
        //     }
        //
        return array(
            $this->safe_integer($ohlcv, 'tick'),
            $this->safe_number($ohlcv, 'open'),
            $this->safe_number($ohlcv, 'high'),
            $this->safe_number($ohlcv, 'low'),
            $this->safe_number($ohlcv, 'close'),
            $this->safe_number($ohlcv, 'volume'),
        );
    }

    public function fetch_ohlcv($symbol, $timeframe = '1m', $since = null, $limit = null, $params = array ()) {
        return Async\async(function () use ($symbol, $timeframe, $since, $limit, $params) {
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            if ($limit === null) {
                $limit = 10;
            }
            $request = array(
                'resolution' => $this->timeframes[$timeframe],
                // 'start_timestamp' => 0,
                // 'end_timestamp' => 0,
            );
            $marketId = $market['id'];
            if ($market['spot'] || $market['margin']) {
                $marketId = $market['baseId'] . '-' . $market['quoteId'];
            }
            $request['instrument_name'] = $marketId;
            if ($since === null) {
                $request['end_timestamp'] = $this->milliseconds();
                $request['start_timestamp'] = 0;
            } else {
                $timeframeInSeconds = $this->parse_timeframe($timeframe);
                $timeframeInMilliseconds = $timeframeInSeconds * 1000;
                $request['start_timestamp'] = $since;
                $request['end_timestamp'] = $this->sum($request['start_timestamp'], $limit * $timeframeInMilliseconds);
            }
            $response = Async\await($this->publicGetGetTradingviewChartData (array_merge($request, $params)));
            $result = $this->safe_value($response, 'result', array());
            //
            //     {
            //         "jsonrpc":"2.0",
            //         "usIn":1647578562427,
            //         "usOut":1647578562428,
            //         "usDiff":1,
            //         "result":[array(
            //             "tick":1647547200,
            //             "open":"40868.16800000",
            //             "high":"40877.65600000",
            //             "low":"40647.00000000",
            //             "close":"40699.10000000",
            //             "volume":"100.27789000",
            //             "cost":"4083185.78337596"
            //         )]
            //     }
            //
            return $this->parse_ohlcvs($result, $market, $timeframe, $since, $limit);
        }) ();
    }

    public function parse_trade($trade, $market = null) {
        //
        // fetchTrades (public)
        //
        //     {
        //         "amount":"0.0003",
        //         "direction":"sell",
        //         "iv":"0",
        //         "price":"40767.18",
        //         "timestamp":"1647582687050",
        //         "instrument_name":"BTC-USDT-SPOT",
        //         "trade_id":57499240
        //     }
        //
        // fetchOrderTrades || fetchMyTrades
        //
        //     {
        //         "direction":"sell",
        //         "amount":"0.03",
        //         "price":"397.8",
        //         "fee":"0.011934",
        //         "timestamp":1647668570759,
        //         "role":"taker",
        //         "trade_id":"58319385",
        //         "order_id":"250979478947823616",
        //         "instrument_name":"BNB-USDT-SPOT",
        //         "order_type":"market",
        //         "fee_use_coupon":false,
        //         "fee_coin_type":"USDT",
        //         "index_price":"",
        //         "self_trade":false
        //     }
        //
        $id = $this->safe_string($trade, 'trade_id');
        $marketId = $this->safe_string($trade, 'instrument_name');
        $symbol = $this->safe_symbol($marketId, $market);
        $timestamp = $this->safe_integer($trade, 'timestamp');
        $side = $this->safe_string($trade, 'direction');
        $priceString = $this->safe_string($trade, 'price');
        $amountString = $this->safe_string($trade, 'amount');
        $takerOrMaker = $this->safe_string($trade, 'role');
        $feeCostString = $this->safe_string($trade, 'fee');
        $fee = null;
        if ($feeCostString !== null) {
            $feeCurrencyId = $this->safe_string($trade, 'fee_coin_type');
            $feeCurrencyCode = $this->safe_currency_code($feeCurrencyId);
            $fee = array(
                'cost' => $feeCostString,
                'currency' => $feeCurrencyCode,
            );
        }
        return $this->safe_trade(array(
            'info' => $trade,
            'id' => $id,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'symbol' => $symbol,
            'order' => $this->safe_string($trade, 'order_id'),
            'type' => $this->safe_string($trade, 'order_type'),
            'side' => $side,
            'takerOrMaker' => $takerOrMaker,
            'price' => $priceString,
            'amount' => $amountString,
            'cost' => null,
            'fee' => $fee,
        ), $market);
    }

    public function fetch_trades($symbol, $since = null, $limit = null, $params = array ()) {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $request = array(
                'instrument_name' => $market['id'],
                // 'start_id' : 0,
                // 'end_id' => 0,
                // 'sorting' => 'asc', // asc | desc
            );
            if ($limit !== null) {
                $request['count'] = $limit; // default 10
            }
            $response = Async\await($this->publicGetGetLastTradesByInstrument (array_merge($request, $params)));
            $result = $this->safe_value($response, 'result', array());
            //
            //     {
            //         "jsonrpc":"2.0",
            //         "usIn":1647582703220,
            //         "usOut":1647582703253,
            //         "usDiff":33,
            //         "result":{
            //             "trades":[array(
            //                 "amount":"0.0003",
            //                 "direction":"sell",
            //                 "iv":"0",
            //                 "price":"40767.18",
            //                 "timestamp":"1647582687050",
            //                 "instrument_name":"BTC-USDT-SPOT",
            //                 "trade_id":57499240
            //             )],
            //             "has_more":true
            //         }
            //     }
            //
            $trades = $this->safe_value($result, 'trades', array());
            return $this->parse_trades($trades, $market, $since, $limit);
        }) ();
    }

    public function sign_in($params = array ()) {
        return Async\async(function () use ($params) {
            $accessToken = $this->safe_string($this->options, 'accessToken');
            if ($accessToken !== null) {
                return $accessToken;
            }
            $this->check_required_credentials();
            $request = array(
                'grant_type' => 'client_credentials', // client_signature || refresh_token
                'client_id' => $this->apiKey,
                'client_secret' => $this->secret,
                // 'refresh_token' => '', // Required for grant type refresh_token
                // 'signature' => '', // Required for grant type client_signature
            );
            $response = Async\await($this->publicPostAuth (array_merge($request, $params)));
            $result = $this->safe_value($response, 'result');
            //
            //     {
            //         jsonrpc => '2.0',
            //         usIn => '1647601525586',
            //         usOut => '1647601525597',
            //         usDiff => '11',
            //         $result => {
            //         access_token => '',
            //         token_type => 'bearer',
            //         refresh_token => '',
            //         expires_in => '604799',
            //         scope => 'account:read_write block_trade:read_write trade:read_write wallet:read_write'
            //         }
            //     }
            //
            $accessToken = $this->safe_string($result, 'access_token');
            $this->options['accessToken'] = $accessToken;
            return $accessToken;
        }) ();
    }

    public function parse_balance($response) {
        //
        //     {
        //         "WALLET":array(
        //             "total":"0",
        //             "coupon":"0",
        //             "details":[array(
        //                 "available":"0",
        //                 "freeze":"0",
        //                 "coin_type":"1INCH",
        //                 "current_mark_price":"1.657"
        //             )]
        //         ),
        //         "MARGIN":array(
        //             "total":"0",
        //             "net":"0",
        //             "available":"0",
        //             "borrowed":"0",
        //             "details":array(),
        //             "maintenance_margin":"0",
        //             "interest_owed":"0"
        //         ),
        //         "SPOT":array(
        //             "total":"3.965",
        //             "available":"15.887066",
        //             "details":[array(
        //                 "available":"0",
        //                 "freeze":"0",
        //                 "total":"0",
        //                 "coin_type":"1INCH",
        //                 "current_mark_price":"1.657"
        //             )]
        //         ),
        //         "BTC":array(
        //             "currency":"BTC",
        //             "balance":"0",
        //             "freeze":"0",
        //             "equity":"0",
        //             "base_currency":"USDT",
        //             "available_funds":"0",
        //             "available_withdrawal_funds":"0",
        //             "initial_margin":"0",
        //             "maintenance_margin":"0",
        //             "margin_balance":"0",
        //             "session_funding":"0",
        //             "session_rpl":"0",
        //             "session_upl":"0",
        //             "futures_pl":"0",
        //             "futures_session_rpl":"0",
        //             "futures_session_upl":"0",
        //             "options_value":"0",
        //             "options_pl":"0",
        //             "options_session_rpl":"0",
        //             "options_session_upl":"0",
        //             "total_pl":"0",
        //             "options_delta":"0",
        //             "options_gamma":"0",
        //             "options_theta":"0",
        //             "options_vega":"0",
        //             "delta_total":"0"
        //         ),
        //         "ETH":array(
        //             "currency":"ETH",
        //             "balance":"0",
        //             "freeze":"0",
        //             "equity":"0",
        //             "base_currency":"USDT",
        //             "available_funds":"0",
        //             "available_withdrawal_funds":"0",
        //             "initial_margin":"0",
        //             "maintenance_margin":"0",
        //             "margin_balance":"0",
        //             "session_funding":"0",
        //             "session_rpl":"0",
        //             "session_upl":"0",
        //             "futures_pl":"0",
        //             "futures_session_rpl":"0",
        //             "futures_session_upl":"0",
        //             "options_value":"0",
        //             "options_pl":"0",
        //             "options_session_rpl":"0",
        //             "options_session_upl":"0",
        //             "total_pl":"0",
        //             "options_delta":"0",
        //             "options_gamma":"0",
        //             "options_theta":"0",
        //             "options_vega":"0",
        //             "delta_total":"0"
        //         ),
        //         "PERPETUAL":{
        //             "bonus":"0",
        //             "global_state":0,
        //             "available_funds":"0",
        //             "wallet_balance":"0",
        //             "available_withdraw_funds":"0",
        //             "total_pl":"0",
        //             "total_upl":"0",
        //             "position_rpl":"0",
        //             "total_upl_isolated":"0",
        //             "total_upl_cross":"0",
        //             "total_initial_margin_cross":"0",
        //             "total_initial_margin_isolated":"0",
        //             "total_margin_balance_isolated":"0",
        //             "total_margin_balance":"0",
        //             "total_margin_balance_cross":"0",
        //             "total_maintenance_margin_cross":"0",
        //             "total_wallet_balance_isolated":"0",
        //             "order_frozen":"0",
        //             "order_cross_frozen":"0",
        //             "order_isolated_frozen":"0",
        //             "risk_level":"0",
        //             "bonus_max":"0"
        //         }
        //     }
        //
        $result = array( 'info' => $response );
        $assetTypes = is_array($response) ? array_keys($response) : array();
        for ($i = 0; $i < count($assetTypes); $i++) {
            $assetType = $assetTypes[$i];
            $currency = $this->safe_value($response, $assetType);
            if (($assetType === 'WALLET') || ($assetType === 'SPOT')) {
                $details = $this->safe_value($currency, 'details');
                if ($details !== null) {
                    for ($i = 0; $i < count($details); $i++) {
                        $detail = $details[$i];
                        $coinType = $this->safe_string($detail, 'coin_type');
                        $code = $this->safe_currency_code($coinType);
                        $account = $this->safe_value($result, $code, $this->account());
                        $account['free'] = $this->safe_string($detail, 'available');
                        $account['used'] = $this->safe_string($detail, 'freeze');
                        $account['total'] = $this->safe_string($detail, 'total');
                        $result[$code] = $account;
                    }
                }
            } else {
                // all other wallets are linear futures
                $code = 'USDT';
                $account = $this->account();
                $account['total'] = $this->safe_string($currency, 'wallet_balance');
                $account['free'] = $this->safe_string($currency, 'available_withdraw_funds');
                $result[$code] = $account;
            }
        }
        return $this->safe_balance($result);
    }

    public function fetch_balance($params = array ()) {
        return Async\async(function () use ($params) {
            Async\await($this->sign_in());
            Async\await($this->load_markets());
            $type = $this->safe_string_lower($params, 'type', 'spot');
            $types = $this->safe_value($this->options, 'accountsByType', array());
            $assetType = $this->safe_string($types, $type, $type);
            $params = $this->omit($params, 'type');
            $request = array(
                'asset_type' => array( $assetType ),
            );
            $response = Async\await($this->privatePostGetAssetsInfo (array_merge($request, $params)));
            $result = $this->safe_value($response, 'result', array());
            //
            //     {
            //         "id":"1647675393",
            //         "jsonrpc":"2.0",
            //         "usIn":1647675394091,
            //         "usOut":1647675394104,
            //         "usDiff":13,
            //         "result":{
            //             "WALLET":array(
            //                 "total":"0",
            //                 "coupon":"0",
            //                 "details":[array(
            //                     "available":"0",
            //                     "freeze":"0",
            //                     "coin_type":"1INCH",
            //                     "current_mark_price":"1.657"
            //                 )]
            //             ),
            //             "MARGIN":array(
            //                 "total":"0",
            //                 "net":"0",
            //                 "available":"0",
            //                 "borrowed":"0",
            //                 "details":array(),
            //                 "maintenance_margin":"0",
            //                 "interest_owed":"0"
            //             ),
            //             "SPOT":array(
            //                 "total":"3.965",
            //                 "available":"15.887066",
            //                 "details":[array(
            //                     "available":"0",
            //                     "freeze":"0",
            //                     "total":"0",
            //                     "coin_type":"1INCH",
            //                     "current_mark_price":"1.657"
            //                 )]
            //             ),
            //             "BTC":array(
            //                 "currency":"BTC",
            //                 "balance":"0",
            //                 "freeze":"0",
            //                 "equity":"0",
            //                 "base_currency":"USDT",
            //                 "available_funds":"0",
            //                 "available_withdrawal_funds":"0",
            //                 "initial_margin":"0",
            //                 "maintenance_margin":"0",
            //                 "margin_balance":"0",
            //                 "session_funding":"0",
            //                 "session_rpl":"0",
            //                 "session_upl":"0",
            //                 "futures_pl":"0",
            //                 "futures_session_rpl":"0",
            //                 "futures_session_upl":"0",
            //                 "options_value":"0",
            //                 "options_pl":"0",
            //                 "options_session_rpl":"0",
            //                 "options_session_upl":"0",
            //                 "total_pl":"0",
            //                 "options_delta":"0",
            //                 "options_gamma":"0",
            //                 "options_theta":"0",
            //                 "options_vega":"0",
            //                 "delta_total":"0"
            //             ),
            //             "ETH":array(
            //                 "currency":"ETH",
            //                 "balance":"0",
            //                 "freeze":"0",
            //                 "equity":"0",
            //                 "base_currency":"USDT",
            //                 "available_funds":"0",
            //                 "available_withdrawal_funds":"0",
            //                 "initial_margin":"0",
            //                 "maintenance_margin":"0",
            //                 "margin_balance":"0",
            //                 "session_funding":"0",
            //                 "session_rpl":"0",
            //                 "session_upl":"0",
            //                 "futures_pl":"0",
            //                 "futures_session_rpl":"0",
            //                 "futures_session_upl":"0",
            //                 "options_value":"0",
            //                 "options_pl":"0",
            //                 "options_session_rpl":"0",
            //                 "options_session_upl":"0",
            //                 "total_pl":"0",
            //                 "options_delta":"0",
            //                 "options_gamma":"0",
            //                 "options_theta":"0",
            //                 "options_vega":"0",
            //                 "delta_total":"0"
            //             ),
            //             "PERPETUAL":{
            //                 "bonus":"0",
            //                 "global_state":0,
            //                 "available_funds":"0",
            //                 "wallet_balance":"0",
            //                 "available_withdraw_funds":"0",
            //                 "total_pl":"0",
            //                 "total_upl":"0",
            //                 "position_rpl":"0",
            //                 "total_upl_isolated":"0",
            //                 "total_upl_cross":"0",
            //                 "total_initial_margin_cross":"0",
            //                 "total_initial_margin_isolated":"0",
            //                 "total_margin_balance_isolated":"0",
            //                 "total_margin_balance":"0",
            //                 "total_margin_balance_cross":"0",
            //                 "total_maintenance_margin_cross":"0",
            //                 "total_wallet_balance_isolated":"0",
            //                 "order_frozen":"0",
            //                 "order_cross_frozen":"0",
            //                 "order_isolated_frozen":"0",
            //                 "risk_level":"0",
            //                 "bonus_max":"0"
            //             }
            //         }
            //     }
            //
            return $this->parse_balance($result);
        }) ();
    }

    public function parse_order_status($status) {
        $statuses = array(
            'open' => 'open',
            'cancelled' => 'canceled',
            'filled' => 'closed',
            'rejected' => 'rejected',
        );
        return $this->safe_string($statuses, $status, $status);
    }

    public function parse_time_in_force($timeInForce) {
        if ($timeInForce === '-') {
            return null;
        }
        $timeInForces = array(
            'good_til_cancelled' => 'GTC',
            'good_til_date' => 'GTD',
            'fill_or_kill' => 'FOK',
            'immediate_or_cancel' => 'IOC',
        );
        return $this->safe_string($timeInForces, $timeInForce, $timeInForce);
    }

    public function parse_order($order, $market = null) {
        //
        // fetchOrder || fetchOpenOrders || fetchClosedOrders
        //         {
        //             "kind":"spot",
        //             "direction":"sell",
        //             "amount":"0.02",
        //             "price":"900",
        //             "advanced":"usdt",
        //             "source":"api",
        //             "mmp":false,
        //             "version":1,
        //             "order_id":"250971492850401280",
        //             "order_state":"open",
        //             "instrument_name":"BNB-USDT-SPOT",
        //             "filled_amount":"0",
        //             "average_price":"0",
        //             "order_type":"limit",
        //             "time_in_force":"GTC",
        //             "post_only":false,
        //             "reduce_only":false,
        //             "creation_timestamp":1647666666723,
        //             "last_update_timestamp":1647666666725
        //         }
        //
        // createOrder
        //
        //         {
        //             "order_id":"251052889774161920",
        //             "custom_order_id":"-"
        //         }
        //
        // closeOrder
        //         {
        //             "order_id":"250979354159153152"
        //         }
        //
        $timestamp = $this->safe_integer($order, 'creation_timestamp');
        $lastUpdate = $this->safe_integer($order, 'last_update_timestamp');
        $id = $this->safe_string($order, 'order_id');
        $priceString = $this->safe_string($order, 'price');
        $averageString = $this->safe_string($order, 'average_price');
        $amountString = $this->safe_string($order, 'amount');
        $filledString = $this->safe_string($order, 'filled_amount');
        $lastTradeTimestamp = null;
        if ($filledString !== null) {
            $isFilledPositive = Precise::string_gt($filledString, '0');
            if ($isFilledPositive) {
                $lastTradeTimestamp = $lastUpdate;
            }
        }
        $status = $this->parse_order_status($this->safe_string($order, 'order_state'));
        $marketId = $this->safe_string($order, 'instrument_name');
        $market = $this->safe_market($marketId, $market);
        $side = $this->safe_string_lower($order, 'direction');
        $feeCostString = $this->safe_string($order, 'commission');
        $fee = null;
        if ($feeCostString !== null) {
            $feeCostString = Precise::string_abs($feeCostString);
            $fee = array(
                'cost' => $feeCostString,
                'currency' => $market['base'],
            );
        }
        $type = $this->safe_string($order, 'order_type');
        // injected in createOrder
        $trades = $this->safe_value($order, 'trades');
        if ($trades !== null) {
            $trades = $this->parse_trades($trades, $market);
        }
        $timeInForce = $this->parse_time_in_force($this->safe_string($order, 'time_in_force'));
        $stopPrice = $this->safe_value($order, 'trigger_price');
        $postOnly = $this->safe_value($order, 'post_only');
        return $this->safe_order(array(
            'info' => $order,
            'id' => $id,
            'clientOrderId' => null,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'lastTradeTimestamp' => $lastTradeTimestamp,
            'symbol' => $market['symbol'],
            'type' => $type,
            'timeInForce' => $timeInForce,
            'postOnly' => $postOnly,
            'side' => $side,
            'price' => $priceString,
            'stopPrice' => $stopPrice,
            'amount' => $amountString,
            'cost' => null,
            'average' => $averageString,
            'filled' => $filledString,
            'remaining' => null,
            'status' => $status,
            'fee' => $fee,
            'trades' => $trades,
        ), $market);
    }

    public function fetch_order($id, $symbol = null, $params = array ()) {
        return Async\async(function () use ($id, $symbol, $params) {
            Async\await($this->load_markets());
            $request = array(
                'order_id' => $id,
            );
            $response = Async\await($this->privateGetGetOrderState (array_merge($request, $params)));
            $result = $this->safe_value($response, 'result');
            //
            //     {
            //         "jsonrpc":"2.0",
            //         "usIn":1647672034018,
            //         "usOut":1647672034033,
            //         "usDiff":15,
            //         "result":{
            //             "currency":"SPOT",
            //             "kind":"spot",
            //             "direction":"sell",
            //             "amount":"0.03",
            //             "price":"-1",
            //             "advanced":"usdt",
            //             "source":"api",
            //             "mmp":false,
            //             "version":1,
            //             "order_id":"250979478947823616",
            //             "order_state":"filled",
            //             "instrument_name":"BNB-USDT-SPOT",
            //             "filled_amount":"0.03",
            //             "average_price":"397.8",
            //             "order_type":"market",
            //             "time_in_force":"GTC",
            //             "post_only":false,
            //             "reduce_only":false,
            //             "creation_timestamp":1647668570759,
            //             "last_update_timestamp":1647668570761
            //         }
            //     }
            //
            return $this->parse_order($result);
        }) ();
    }

    public function create_order($symbol, $type, $side, $amount, $price = null, $params = array ()) {
        return Async\async(function () use ($symbol, $type, $side, $amount, $price, $params) {
            Async\await($this->sign_in());
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $request = array(
                'instrument_name' => $market['id'],
                'amount' => $this->amount_to_precision($symbol, $amount),
                'type' => $type, // limit, $market, default is limit
                // 'price' => $this->price_to_precision($symbol, 123.45), // The $order $price for limit $order-> When adding options $order with advanced=iv, the field $price should be a value of implied volatility in percentages. For example, $price=100, means implied volatility of 100%
                // 'time_in_force' : 'good_til_cancelled', // good_til_cancelled, good_til_date, fill_or_kill, immediate_or_cancel Specifies how long the $order remains in effect, default => good_til_cancelled
                // 'post_only' => false, // If true, the $order is considered post-only, default => false
                // 'reduce_only' => false, // If true, the $order is considered reduce-only which is intended to only reduce a current position. default => false
                // 'condition_type' => '', // NORMAL, STOP, TRAILING, IF_TOUCHED, Condition sheet policy, the default is NORMAL. Available when kind is future
                // 'trigger_price' => 'index_price', // trigger $price-> Available when condition_type is STOP or IF_TOUCHED
                // 'trail_price' => false, // trail $price, Tracking $price change Delta. Available when condition_type is TRAILING
                // 'advanced' => 'usd', // Advanced option $order $type, (Only for options), default => usdt. If set to ivï¼Œthen the $price field means iv value
            );
            if ($type === 'limit') {
                $request['price'] = $this->price_to_precision($symbol, $price);
            }
            if ($market['contract']) {
                $timeInForce = $this->safe_string_upper($params, 'timeInForce');
                if ($timeInForce === 'GTC') {
                    $request['time_in_force'] = 'good_till_cancelled';
                } elseif ($timeInForce === 'FOK') {
                    $request['time_in_force'] = 'fill_or_kill';
                } elseif ($timeInForce === 'IOC') {
                    $request['time_in_force'] = 'immediate_or_cancel';
                }
                $isMarketOrder = $type === 'market';
                $exchangeSpecificParam = $this->safe_value($params, 'post_only', false);
                $postOnly = $this->is_post_only($isMarketOrder, $exchangeSpecificParam, $params);
                if ($postOnly) {
                    $request['post_only'] = true;
                }
                $reduceOnly = $this->safe_value($params, 'reduceOnly', false);
                if ($reduceOnly) {
                    $request['reduce_only'] = true;
                }
                $params = $this->omit($params, array( 'timeInForce', 'postOnly', 'reduceOnly' ));
            }
            $method = 'privatePost' . $this->capitalize($side);
            $response = Async\await($this->$method (array_merge($request, $params)));
            $result = $this->safe_value($response, 'result', array());
            //
            //     {
            //         "id":"1647686073",
            //         "jsonrpc":"2.0",
            //         "usIn":1647686073252,
            //         "usOut":1647686073264,
            //         "usDiff":12,
            //         "result":{
            //             "order":{
            //                 "order_id":"251052889774161920",
            //                 "custom_order_id":"-"
            //             }
            //         }
            //     }
            //
            $order = $this->safe_value($result, 'order');
            return $this->parse_order($order, $market);
        }) ();
    }

    public function cancel_order($id, $symbol = null, $params = array ()) {
        return Async\async(function () use ($id, $symbol, $params) {
            Async\await($this->sign_in());
            Async\await($this->load_markets());
            $request = array(
                'order_id' => $id,
            );
            $response = Async\await($this->privatePostCancel (array_merge($request, $params)));
            $result = $this->safe_value($response, 'result', array());
            //
            //     {
            //         "id":"1647675007",
            //         "jsonrpc":"2.0",
            //         "usIn":1647675007485,
            //         "usOut":1647675007494,
            //         "usDiff":9,
            //         "result":{
            //             "order_id":"250979354159153152"
            //         }
            //     }
            //
            return $this->parse_order($result);
        }) ();
    }

    public function cancel_all_orders($symbol = null, $params = array ()) {
        return Async\async(function () use ($symbol, $params) {
            if ($symbol === null) {
                throw new ArgumentsRequired($this->id . ' cancelAllOrders() requires a $symbol argument');
            }
            Async\await($this->sign_in());
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $request = array(
                'instrument_name' => $market['id'],
            );
            $response = Async\await($this->privatePostCancelAllByInstrument (array_merge($request, $params)));
            //
            //     {
            //         "id":"1647686580",
            //         "jsonrpc":"2.0",
            //         "usIn":1647686581216,
            //         "usOut":1647686581224,
            //         "usDiff":8,
            //         "result":2
            //     }
            //
            return $response;
        }) ();
    }

    public function fetch_open_orders($symbol = null, $since = null, $limit = null, $params = array ()) {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            if ($symbol === null) {
                throw new ArgumentsRequired($this->id . ' fetchOpenOrders() requires a $symbol argument');
            }
            Async\await($this->sign_in());
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $request = array(
                'instrument_name' => $market['id'],
            );
            $response = Async\await($this->privateGetGetOpenOrdersByInstrument (array_merge($request, $params)));
            $result = $this->safe_value($response, 'result', array());
            //
            //     {
            //         "jsonrpc":"2.0",
            //         "usIn":1647667026285,
            //         "usOut":1647667026291,
            //         "usDiff":6,
            //         "result":[array(
            //             "kind":"spot",
            //             "direction":"sell",
            //             "amount":"0.02",
            //             "price":"900",
            //             "advanced":"usdt",
            //             "source":"api",
            //             "mmp":false,
            //             "version":1,
            //             "order_id":"250971492850401280",
            //             "order_state":"open",
            //             "instrument_name":"BNB-USDT-SPOT",
            //             "filled_amount":"0",
            //             "average_price":"0",
            //             "order_type":"limit",
            //             "time_in_force":"GTC",
            //             "post_only":false,
            //             "reduce_only":false,
            //             "creation_timestamp":1647666666723,
            //             "last_update_timestamp":1647666666725
            //         )]
            //     }
            //
            return $this->parse_orders($result, $market, $since, $limit);
        }) ();
    }

    public function fetch_closed_orders($symbol = null, $since = null, $limit = null, $params = array ()) {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            if ($symbol === null) {
                throw new ArgumentsRequired($this->id . ' fetchClosedOrders() requires a $symbol argument');
            }
            Async\await($this->sign_in());
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $request = array(
                'instrument_name' => $market['id'],
            );
            if ($limit !== null) {
                $request['count'] = $limit;
            }
            $response = Async\await($this->privateGetGetOrderHistoryByInstrument (array_merge($request, $params)));
            $result = $this->safe_value($response, 'result', array());
            //
            //     {
            //         "jsonrpc":"2.0",
            //         "usIn":1647671721716,
            //         "usOut":1647671721730,
            //         "usDiff":14,
            //         "result":[array(
            //             "currency":"SPOT",
            //             "kind":"spot",
            //             "direction":"sell",
            //             "amount":"0.03",
            //             "price":"-1",
            //             "advanced":"usdt",
            //             "source":"api",
            //             "mmp":false,
            //             "version":1,
            //             "order_id":"250979478947823616",
            //             "order_state":"filled",
            //             "instrument_name":"BNB-USDT-SPOT",
            //             "filled_amount":"0.03",
            //             "average_price":"397.8",
            //             "order_type":"market",
            //             "time_in_force":"GTC",
            //             "post_only":false,
            //             "reduce_only":false,
            //             "creation_timestamp":1647668570759,
            //             "last_update_timestamp":1647668570761
            //         )]
            //     }
            //
            return $this->parse_orders($result, $market, $since, $limit);
        }) ();
    }

    public function fetch_order_trades($id, $symbol = null, $since = null, $limit = null, $params = array ()) {
        return Async\async(function () use ($id, $symbol, $since, $limit, $params) {
            if ($id === null) {
                throw new ArgumentsRequired($this->id . ' fetchOrderTrades() requires a $id argument');
            }
            Async\await($this->load_markets());
            $request = array(
                'order_id' => $id,
                // 'start_id' => 0, // The ID number of the first trade to be returned
                // 'end_id' => 0, // The ID number of the last trade to be returned
                // 'sorting' => '', // Direction of results sorting,default => desc
            );
            if ($limit !== null) {
                $request['count'] = $limit; // default 20
            }
            $response = Async\await($this->privateGetGetUserTradesByOrder (array_merge($request, $params)));
            $result = $this->safe_value($response, 'result', array());
            //
            //     {
            //         "jsonrpc":"2.0",
            //         "usIn":1647671425457,
            //         "usOut":1647671425470,
            //         "usDiff":13,
            //         "result":{
            //             "count":1,
            //             "trades":[array(
            //                 "direction":"sell",
            //                 "amount":"0.03",
            //                 "price":"397.8",
            //                 "fee":"0.011934",
            //                 "timestamp":1647668570759,
            //                 "role":"taker",
            //                 "trade_id":"58319385",
            //                 "order_id":"250979478947823616",
            //                 "instrument_name":"BNB-USDT-SPOT",
            //                 "order_type":"market",
            //                 "fee_use_coupon":false,
            //                 "fee_coin_type":"USDT",
            //                 "index_price":"",
            //                 "self_trade":false
            //             )],
            //             "has_more":false
            //         }
            //     }
            //
            $trades = $this->safe_value($result, 'trades', array());
            return $this->parse_trades($trades, null, $since, $limit);
        }) ();
    }

    public function fetch_my_trades($symbol = null, $since = null, $limit = null, $params = array ()) {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            if ($symbol === null) {
                throw new ArgumentsRequired($this->id . ' fetchMyTrades() requires a id argument');
            }
            Async\await($this->sign_in());
            Async\await($this->load_markets());
            $request = array(
                // 'kind' => '', // The order kind, eg. margin, spot, option, future, perpetual. only used when call privateGetGetUserTradesByCurrency
                // 'start_id' => 0, // The ID number of the first trade to be returned
                // 'end_id' => 0, // The ID number of the last trade to be returned
                // 'sorting' => '', // Direction of results sorting,default => desc
                // 'self_trade' => false, // If not set, query all
            );
            $method = null;
            $market = $this->market($symbol);
            $request['instrument_name'] = $market['id'];
            if ($since === null) {
                $method = 'privateGetGetUserTradesByInstrument';
            } else {
                $method = 'privateGetGetUserTradesByInstrumentAndTime';
            }
            if ($limit !== null) {
                $request['count'] = $limit; // default 20
            }
            $response = Async\await($this->$method (array_merge($request, $params)));
            $result = $this->safe_value($response, 'result', array());
            //
            //     {
            //         "jsonrpc":"2.0",
            //         "usIn":1647668582167,
            //         "usOut":1647668582187,
            //         "usDiff":20,
            //         "result":{
            //             "count":1,
            //             "trades":[array(
            //                 "direction":"sell",
            //                 "amount":"0.03",
            //                 "price":"397.8",
            //                 "fee":"0.011934",
            //                 "timestamp":1647668570759,
            //                 "role":"taker",
            //                 "trade_id":"58319385",
            //                 "order_id":"250979478947823616",
            //                 "instrument_name":"BNB-USDT-SPOT",
            //                 "order_type":"market",
            //                 "fee_use_coupon":false,
            //                 "fee_coin_type":"USDT",
            //                 "index_price":"",
            //                 "self_trade":false
            //             )],
            //             "has_more":false
            //         }
            //     }
            //
            $trades = $this->safe_value($result, 'trades', array());
            return $this->parse_trades($trades, $market, $since, $limit);
        }) ();
    }

    public function parse_position($position, $market = null) {
        //
        //     {
        //         "currency":"PERPETUAL",
        //         "kind":"perpetual",
        //         "size":"-0.08",
        //         "direction":"sell",
        //         "leverage":"3",
        //         "margin":"10.7724",
        //         "version":"553",
        //         "roe":"-0.000483",
        //         "traceType":0,
        //         "pos_id":"0",
        //         "instrument_name":"BNB-USDT-PERPETUAL",
        //         "average_price":"403.9",
        //         "mark_price":"403.965",
        //         "initial_margin":"10.77066668",
        //         "maintenance_margin":"0.2100618",
        //         "floating_profit_loss":"-0.0052",
        //         "liquid_price":"549.15437158",
        //         "margin_type":"cross",
        //         "risk_level":"0.017651",
        //         "available_withdraw_funds":"1.13004332",
        //         "order_id":"251085320510201856",
        //         "stop_loss_price":"0",
        //         "stop_loss_type":1,
        //         "take_profit_price":"0",
        //         "take_profit_type":1
        //     }
        //
        $contract = $this->safe_string($position, 'instrument_name');
        $market = $this->safe_market($contract, $market);
        $size = $this->safe_string($position, 'size');
        $side = $this->safe_string($position, 'direction');
        $side = ($side === 'buy') ? 'long' : 'short';
        $maintenanceMarginString = $this->safe_string($position, 'maintenance_margin');
        $riskLevel = $this->safe_string($position, 'risk_level');
        // maint_margin / $collateral = risk_level
        // $collateral = maint_margin / risk_level
        $collateral = Precise::string_div($maintenanceMarginString, $riskLevel);
        $markPrice = $this->safe_string($position, 'mark_price');
        $notionalString = Precise::string_mul($markPrice, $size);
        $unrealisedPnl = $this->safe_string($position, 'floating_profit_loss');
        $initialMarginString = $this->safe_string($position, 'initial_margin');
        $percentage = Precise::string_mul(Precise::string_div($unrealisedPnl, $initialMarginString), '100');
        $marginType = $this->safe_string($position, 'margin_type');
        return array(
            'info' => $position,
            'id' => null,
            'symbol' => $this->safe_string($market, 'symbol'),
            'timestamp' => null,
            'datetime' => null,
            'initialMargin' => $this->parse_number($initialMarginString),
            'initialMarginPercentage' => $this->parse_number(Precise::string_div($initialMarginString, $notionalString)),
            'maintenanceMargin' => $this->parse_number($maintenanceMarginString),
            'maintenanceMarginPercentage' => $this->parse_number(Precise::string_div($maintenanceMarginString, $notionalString)),
            'entryPrice' => $this->safe_number($position, 'average_price'),
            'notional' => $this->parse_number($notionalString),
            'leverage' => $this->safe_number($position, 'leverage'),
            'unrealizedPnl' => $this->parse_number($unrealisedPnl),
            'contracts' => $this->parse_number($size),  // in USD for perpetuals on deribit
            'contractSize' => $this->safe_value($market, 'contractSize'),
            'marginRatio' => $this->parse_number($riskLevel),
            'liquidationPrice' => $this->safe_number($position, 'liquid_price'),
            'markPrice' => $this->parse_number($markPrice),
            'collateral' => $this->parse_number($collateral),
            'marginType' => $marginType,
            'side' => $side,
            'percentage' => $this->parse_number($percentage),
        );
    }

    public function fetch_position($symbol, $params = array ()) {
        return Async\async(function () use ($symbol, $params) {
            Async\await($this->sign_in());
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $request = array(
                'instrument_name' => $market['id'],
            );
            $response = Async\await($this->privateGetGetPosition (array_merge($request, $params)));
            $result = $this->safe_value($response, 'result');
            //
            //     {
            //         "jsonrpc":"2.0",
            //         "usIn":1647693832273,
            //         "usOut":1647693832282,
            //         "usDiff":9,
            //         "result":{
            //             "currency":"PERPETUAL",
            //             "kind":"perpetual",
            //             "size":"-0.08",
            //             "direction":"sell",
            //             "leverage":"3",
            //             "margin":"10.7724",
            //             "version":"553",
            //             "roe":"-0.000483",
            //             "traceType":0,
            //             "pos_id":"0",
            //             "instrument_name":"BNB-USDT-PERPETUAL",
            //             "average_price":"403.9",
            //             "mark_price":"403.965",
            //             "initial_margin":"10.77066668",
            //             "maintenance_margin":"0.2100618",
            //             "floating_profit_loss":"-0.0052",
            //             "liquid_price":"549.15437158",
            //             "margin_type":"cross",
            //             "risk_level":"0.017651",
            //             "available_withdraw_funds":"1.13004332",
            //             "order_id":"251085320510201856",
            //             "stop_loss_price":"0",
            //             "stop_loss_type":1,
            //             "take_profit_price":"0",
            //             "take_profit_type":1
            //         }
            //     }
            //
            return $this->parse_position($result);
        }) ();
    }

    public function fetch_positions($symbols = null, $params = array ()) {
        return Async\async(function () use ($symbols, $params) {
            Async\await($this->sign_in());
            Async\await($this->load_markets());
            $request = array(
                'currency' => 'PERPETUAL',
                // 'kind' : '', // option, future, spot, margin,perpetual The order kind
            );
            $response = Async\await($this->privateGetGetPositions (array_merge($request, $params)));
            $result = $this->safe_value($response, 'result');
            //
            //     {
            //         "jsonrpc":"2.0",
            //         "usIn":1647694531356,
            //         "usOut":1647694531364,
            //         "usDiff":8,
            //         "result":[array(
            //             "currency":"PERPETUAL",
            //             "kind":"perpetual",
            //             "size":"-0.08",
            //             "direction":"sell",
            //             "leverage":"3",
            //             "margin":"10.7836",
            //             "version":"1251",
            //             "roe":"-0.003602",
            //             "traceType":0,
            //             "pos_id":"0",
            //             "instrument_name":"BNB-USDT-PERPETUAL",
            //             "average_price":"403.9",
            //             "mark_price":"404.385",
            //             "initial_margin":"10.77066668",
            //             "maintenance_margin":"0.2102802",
            //             "floating_profit_loss":"-0.0388",
            //             "liquid_price":"549.15437158",
            //             "margin_type":"cross",
            //             "risk_level":"0.01772",
            //             "available_withdraw_funds":"1.09644332",
            //             "order_id":"251085320510201856",
            //             "stop_loss_price":"0",
            //             "stop_loss_type":1,
            //             "take_profit_price":"0",
            //             "take_profit_type":1
            //         )]
            //     }
            //
            return $this->parse_positions($result, $symbols);
        }) ();
    }

    public function parse_transaction_status($status) {
        $states = array(
            'deposit_confirmed' => 'ok',
            'deposit_waiting_confirm' => 'pending',
            'withdraw_init' => 'pending',
            'withdraw_noticed_block_chain' => 'pending',
            'withdraw_waiting_confirm' => 'pending',
            'withdraw_confirmed' => 'ok',
            'withdraw_failed' => 'failed',
            'withdraw_auditing' => 'pending',
            'withdraw_audit_reject' => 'failed',
        );
        return $this->safe_string($states, $status, $status);
    }

    public function parse_transaction($transaction, $currency = null) {
        //
        // fetchDeposits
        //         {
        //             "id":"250325458128736256",
        //             "amount":"0.04",
        //             "state":"deposit_confirmed",
        //             "coin_type":"BNB",
        //             "token_code":"BNB",
        //             "create_time":"1647512640040",
        //             "update_time":"1647512640053",
        //             "tx_hash":"",
        //             "full_name":"Binance Coin"
        //         }
        //
        // fetchWithdrawals || fetchWithdraw
        //         {
        //             "id":"251076247882829824",
        //             "address":"",
        //             "amount":"0.01",
        //             "state":"withdraw_auditing",
        //             "coin_type":"BNB",
        //             "create_time":"1647691642267",
        //             "update_time":"1647691650090",
        //             "full_name":"Binance Coin",
        //             "token_code":"BNB"
        //         }
        //
        $currencyId = $this->safe_string($transaction, 'coin_type');
        $code = $this->safe_currency_code($currencyId, $currency);
        $id = $this->safe_string($transaction, 'id');
        $txId = $this->safe_string($transaction, 'tx_hash');
        $timestamp = $this->safe_integer($transaction, 'create_time');
        $updated = $this->safe_integer($transaction, 'update_time');
        $amount = $this->safe_number($transaction, 'amount');
        $status = $this->safe_string($transaction, 'state');
        return array(
            'info' => $transaction,
            'id' => $id,
            'txid' => $txId,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'network' => null,
            'addressFrom' => null,
            'address' => null,
            'addressTo' => null,
            'tagFrom' => null,
            'tag' => null,
            'tagTo' => null,
            'type' => null,
            'amount' => $amount,
            'currency' => $code,
            'status' => $this->parse_transaction_status($status),
            'updated' => $updated,
            'fee' => null,
        );
    }

    public function fetch_deposits($code = null, $since = null, $limit = null, $params = array ()) {
        return Async\async(function () use ($code, $since, $limit, $params) {
            if ($code === null) {
                throw new ArgumentsRequired($this->id . ' fetchDeposits() requires the $code argument');
            }
            Async\await($this->sign_in());
            Async\await($this->load_markets());
            $currency = $this->safe_currency($code);
            $request = array(
                'coin_type' => $currency['id'],
            );
            $response = Async\await($this->privateGetGetDepositRecord (array_merge($request, $params)));
            $result = $this->safe_value($response, 'result', array());
            //
            //     {
            //         "jsonrpc":"2.0",
            //         "usIn":1647606752447,
            //         "usOut":1647606752457,
            //         "usDiff":10,
            //         "result":[array(
            //             "id":"250325458128736256",
            //             "amount":"0.04",
            //             "state":"deposit_confirmed",
            //             "coin_type":"BNB",
            //             "token_code":"BNB",
            //             "create_time":"1647512640040",
            //             "update_time":"1647512640053",
            //             "tx_hash":"",
            //             "full_name":"Binance Coin"
            //         )]
            //     }
            //     }
            //
            return $this->parse_transactions($result, $currency, $since, $limit, array( 'type' => 'deposit' ));
        }) ();
    }

    public function fetch_withdrawals($code = null, $since = null, $limit = null, $params = array ()) {
        return Async\async(function () use ($code, $since, $limit, $params) {
            if ($code === null) {
                throw new ArgumentsRequired($this->id . ' fetchWithdrawals() requires the $code argument');
            }
            Async\await($this->sign_in());
            Async\await($this->load_markets());
            $currency = $this->safe_currency($code);
            $request = array(
                'coin_type' => $currency['id'],
                // 'withdraw_id' => 0,
            );
            $response = Async\await($this->privateGetGetWithdrawRecord (array_merge($request, $params)));
            $result = $this->safe_value($response, 'result', array());
            //
            //     {
            //         "jsonrpc":"2.0",
            //         "usIn":1647691750112,
            //         "usOut":1647691750125,
            //         "usDiff":13,
            //         "result":[array(
            //             "id":"251076247882829824",
            //             "address":"",
            //             "amount":"0.01",
            //             "state":"withdraw_auditing",
            //             "coin_type":"BNB",
            //             "create_time":"1647691642267",
            //             "update_time":"1647691650090",
            //             "full_name":"Binance Coin",
            //             "token_code":"BNB"
            //         )]
            //     }
            //
            return $this->parse_transactions($result, $currency, $since, $limit, array( 'type' => 'withdrawal' ));
        }) ();
    }

    public function fetch_withdrawal($id, $code = null, $params = array ()) {
        return Async\async(function () use ($id, $code, $params) {
            if ($code === null) {
                throw new ArgumentsRequired($this->id . ' fetchWithdrawal() requires the $code argument');
            }
            Async\await($this->sign_in());
            Async\await($this->load_markets());
            $currency = $this->safe_currency($code);
            $request = array(
                'coin_type' => $currency['id'],
                'withdraw_id' => $id,
            );
            $response = Async\await($this->privateGetGetWithdrawRecord (array_merge($request, $params)));
            $result = $this->safe_value($response, 'result', array());
            //
            //     {
            //         "jsonrpc":"2.0",
            //         "usIn":1647691750112,
            //         "usOut":1647691750125,
            //         "usDiff":13,
            //         "result":[array(
            //             "id":"251076247882829824",
            //             "address":"",
            //             "amount":"0.01",
            //             "state":"withdraw_auditing",
            //             "coin_type":"BNB",
            //             "create_time":"1647691642267",
            //             "update_time":"1647691650090",
            //             "full_name":"Binance Coin",
            //             "token_code":"BNB"
            //         )]
            //     }
            //
            $records = $this->filter_by($result, 'id', $id);
            $record = $this->safe_value($records, 0);
            return $this->parse_transaction($record, $currency);
        }) ();
    }

    public function sign($path, $api = 'public', $method = 'GET', $params = array (), $headers = null, $body = null) {
        $request = '/' . 'api/' . $this->version . '/' . $api . '/' . $path;
        if ($api === 'public') {
            if ($params) {
                $request .= '?' . $this->urlencode($params);
            }
        }
        if ($api === 'private') {
            $this->check_required_credentials();
            if ($method === 'GET') {
                if ($params) {
                    $request .= '?' . $this->urlencode($params);
                }
            }
            $sessionToken = $this->safe_string($this->options, 'accessToken');
            if ($sessionToken === null) {
                throw new AuthenticationError($this->id . ' sign() requires access token');
            }
            $headers = array(
                'Authorization' => 'bearer ' . $sessionToken,
            );
            if ($method === 'POST') {
                $headers['Content-Type'] = 'application/json';
                if ($params) {
                    $rpcPayload = array(
                        'jsonrpc' => '2.0',
                        'id' => $this->nonce(),
                        'method' => '/' . $api . '/' . $path,
                        'params' => $params,
                    );
                    $body = $this->json($rpcPayload);
                }
            }
        }
        $url = $this->urls['api']['rest'] . $request;
        return array( 'url' => $url, 'method' => $method, 'body' => $body, 'headers' => $headers );
    }

    public function handle_errors($code, $reason, $url, $method, $headers, $body, $response, $requestHeaders, $requestBody) {
        if ($response === null) {
            return; // fallback to the default $error handler
        }
        $error = $this->safe_value($response, 'error');
        if ($error) {
            $feedback = $this->id . ' ' . $body;
            $code = $this->safe_string($error, 'code');
            $message = $this->safe_string($error, 'message');
            $this->throw_exactly_matched_exception($this->exceptions['exact'], $code, $feedback);
            $this->throw_broadly_matched_exception($this->exceptions['broad'], $message, $feedback);
            throw new ExchangeError($feedback); // unknown $message
        }
    }
}
