<?php

namespace ccxt\async;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

use Exception; // a common import
use ccxt\async\abstract\bigone as Exchange;
use ccxt\ExchangeError;
use ccxt\ArgumentsRequired;
use ccxt\BadRequest;
use ccxt\InvalidOrder;
use ccxt\NotSupported;
use ccxt\Precise;
use React\Async;
use React\Promise;
use React\Promise\PromiseInterface;

class bigone extends Exchange {

    public function describe() {
        return $this->deep_extend(parent::describe(), array(
            'id' => 'bigone',
            'name' => 'BigONE',
            'countries' => array( 'CN' ),
            'version' => 'v3',
            'rateLimit' => 1200, // 500 request per 10 minutes
            'has' => array(
                'CORS' => null,
                'spot' => true,
                'margin' => false,
                'swap' => null, // has but unimplemented
                'future' => null, // has but unimplemented
                'option' => false,
                'cancelAllOrders' => true,
                'cancelOrder' => true,
                'createMarketBuyOrderWithCost' => true,
                'createMarketOrderWithCost' => false,
                'createMarketSellOrderWithCost' => false,
                'createOrder' => true,
                'createPostOnlyOrder' => true,
                'createStopLimitOrder' => true,
                'createStopMarketOrder' => true,
                'createStopOrder' => true,
                'fetchBalance' => true,
                'fetchClosedOrders' => true,
                'fetchCurrencies' => true,
                'fetchDepositAddress' => true,
                'fetchDeposits' => true,
                'fetchFundingRate' => false,
                'fetchMarkets' => true,
                'fetchMyTrades' => true,
                'fetchOHLCV' => true,
                'fetchOpenOrders' => true,
                'fetchOrder' => true,
                'fetchOrderBook' => true,
                'fetchOrders' => true,
                'fetchTicker' => true,
                'fetchTickers' => true,
                'fetchTime' => true,
                'fetchTrades' => true,
                'fetchTradingFee' => false,
                'fetchTradingFees' => false,
                'fetchTransactionFees' => false,
                'fetchWithdrawals' => true,
                'transfer' => true,
                'withdraw' => true,
            ),
            'timeframes' => array(
                '1m' => 'min1',
                '5m' => 'min5',
                '15m' => 'min15',
                '30m' => 'min30',
                '1h' => 'hour1',
                '3h' => 'hour3',
                '4h' => 'hour4',
                '6h' => 'hour6',
                '12h' => 'hour12',
                '1d' => 'day1',
                '1w' => 'week1',
                '1M' => 'month1',
            ),
            'hostname' => 'big.one', // or 'bigone.com'
            'urls' => array(
                'logo' => 'https://user-images.githubusercontent.com/1294454/69354403-1d532180-0c91-11ea-88ed-44c06cefdf87.jpg',
                'api' => array(
                    'public' => 'https://{hostname}/api/v3',
                    'private' => 'https://{hostname}/api/v3/viewer',
                    'contractPublic' => 'https://{hostname}/api/contract/v2',
                    'contractPrivate' => 'https://{hostname}/api/contract/v2',
                    'webExchange' => 'https://{hostname}/api/',
                ),
                'www' => 'https://big.one',
                'doc' => 'https://open.big.one/docs/api.html',
                'fees' => 'https://bigone.zendesk.com/hc/en-us/articles/115001933374-BigONE-Fee-Policy',
                'referral' => 'https://b1.run/users/new?code=D3LLBVFT',
            ),
            'api' => array(
                'public' => array(
                    'get' => array(
                        'ping',
                        'asset_pairs',
                        'asset_pairs/{asset_pair_name}/depth',
                        'asset_pairs/{asset_pair_name}/trades',
                        'asset_pairs/{asset_pair_name}/ticker',
                        'asset_pairs/{asset_pair_name}/candles',
                        'asset_pairs/tickers',
                    ),
                ),
                'private' => array(
                    'get' => array(
                        'accounts',
                        'fund/accounts',
                        'assets/{asset_symbol}/address',
                        'orders',
                        'orders/{id}',
                        'orders/multi',
                        'trades',
                        'withdrawals',
                        'deposits',
                    ),
                    'post' => array(
                        'orders',
                        'orders/{id}/cancel',
                        'orders/cancel',
                        'withdrawals',
                        'transfer',
                    ),
                ),
                'contractPublic' => array(
                    'get' => array(
                        'symbols',
                        'instruments',
                        'depth@{symbol}/snapshot',
                        'instruments/difference',
                        'instruments/prices',
                    ),
                ),
                'contractPrivate' => array(
                    'get' => array(
                        'accounts',
                        'orders/{id}',
                        'orders',
                        'orders/opening',
                        'orders/count',
                        'orders/opening/count',
                        'trades',
                        'trades/count',
                    ),
                    'post' => array(
                        'orders',
                        'orders/batch',
                    ),
                    'put' => array(
                        'positions/{symbol}/margin',
                        'positions/{symbol}/risk-limit',
                    ),
                    'delete' => array(
                        'orders/{id}',
                        'orders/batch',
                    ),
                ),
                'webExchange' => array(
                    'get' => array(
                        'uc/v2/assets',
                    ),
                ),
            ),
            'fees' => array(
                'trading' => array(
                    'maker' => $this->parse_number('0.001'),
                    'taker' => $this->parse_number('0.001'),
                ),
                'funding' => array(
                    'withdraw' => array(),
                ),
            ),
            'options' => array(
                'createMarketBuyOrderRequiresPrice' => true,
                'accountsByType' => array(
                    'spot' => 'SPOT',
                    'fund' => 'FUND',
                    'funding' => 'FUND',
                    'future' => 'CONTRACT',
                    'swap' => 'CONTRACT',
                ),
                'transfer' => array(
                    'fillResponseFromRequest' => true,
                ),
                'exchangeMillisecondsCorrection' => -100,
                'fetchCurrencies' => array(
                    'webApiEnable' => true, // fetches from WEB
                    'webApiRetries' => 5,
                    'webApiMuteFailure' => true,
                ),
                'defaultNetwork' => 'ERC20',
                'defaultNetworks' => array(
                    'USDT' => 'TRC20',
                ),
                'networks' => array(
                    'ABBC' => 'ABBC',
                    'ACA' => 'Acala',
                    'AE' => 'Aeternity',
                    'ALGO' => 'Algorand',
                    'APT' => 'Aptos',
                    'AR' => 'Arweave',
                    'ASTR' => 'Astar',
                    'AVAXC' => 'Avax',
                    'AVAXX' => 'AvaxChain',
                    'BEAM' => 'Beam',
                    'BEP20' => 'BinanceSmartChain',
                    'BITCI' => 'BitciChain',
                    'BTC' => 'Bitcoin',
                    'BCH' => 'BitcoinCash',
                    'BSV' => 'BitcoinSV',
                    'CELO' => 'Celo',
                    'CKKB' => 'CKB',
                    'ATOM' => 'Cosmos',
                    'CRC20' => 'CRO',
                    'DASH' => 'Dash',
                    'DOGE' => 'Dogecoin',
                    'XEC' => 'ECash',
                    'EOS' => 'EOS',
                    'ETH' => 'Ethereum',
                    'ETC' => 'EthereumClassic',
                    'ETHW' => 'EthereumPow',
                    'FTM' => 'Fantom',
                    'FIL' => 'Filecoin',
                    'FSN' => 'Fusion',
                    'GRIN' => 'Grin',
                    'ONE' => 'Harmony',
                    'HRC20' => 'Hecochain',
                    'HBAR' => 'Hedera',
                    'HNT' => 'Helium',
                    'ZEN' => 'Horizen',
                    'IOST' => 'IOST',
                    'IRIS' => 'IRIS',
                    'KLAY' => 'Klaytn',
                    'KSM' => 'Kusama',
                    'LTC' => 'Litecoin',
                    'XMR' => 'Monero',
                    'GLMR' => 'Moonbeam',
                    'NEAR' => 'Near',
                    'NEO' => 'Neo',
                    'NEON3' => 'NeoN3',
                    'OASIS' => 'Oasis',
                    'OKC' => 'Okexchain',
                    'ONT' => 'Ontology',
                    'OPTIMISM' => 'Optimism',
                    'DOT' => 'Polkadot',
                    'MATIC' => 'Polygon',
                    'QTUM' => 'Qtum',
                    'REI' => 'REI',
                    'XRP' => 'Ripple',
                    'SGB' => 'SGB',
                    'SDN' => 'Shiden',
                    'SOL' => 'Solana',
                    'XLM' => 'Stellar',
                    'TERA' => 'Tera',
                    'XTZ' => 'Tezos',
                    'TRC20' => 'Tron',
                    'VET' => 'Vechain',
                    'VSYS' => 'VSystems',
                    'WAX' => 'WAX',
                    'ZEC' => 'Zcash',
                    // todo => uncomment after consensus
                    // 'BITSHARES_OLD' => 'Bitshares',
                    // 'BITSHARES_NEW' => 'NewBitshares',
                    // 'MOBILECOIN' => 'Mobilecoin',
                    // 'LBRY' => 'Lbry',
                    // 'ZEEPIN' => 'Zeepin',
                    // 'WAYFCOIN' => 'Wayfcoin',
                    // 'UCACOIN' => 'Ucacoin',
                    // 'VANILLACASH' => 'Vcash',
                    // 'LAMDEN' => 'Lamden',
                    // 'GXSHARES' => 'Gxshares',
                    // 'ICP' => 'Dfinity',
                    // 'CLOVER' => 'Clover',
                    // 'CLASSZZ' => 'Classzz',
                    // 'CLASSZZ_V2' => 'ClasszzV2',
                    // 'CHAINX_V2' => 'ChainxV2',
                    // 'BITCOINDIAMON' => 'BitcoinDiamond',
                    // 'BITCOINGOLD' => 'BitcoinGold',
                    // 'BUTTRUSTSYSTEM' => 'BitTrustSystem',
                    // 'BYTOM_V2' => 'BytomV2',
                    // 'LIBONOMY' => 'Libonomy',
                    // 'TERRACLASSIC' => 'Terra',
                    // 'TERRA' => 'Terra2',
                    // 'SUPERBITCOIN' => 'SuperBitcoin',
                    // 'SIACLASSIC' => 'Sia',
                    // 'SIACOIN' => 'SiaCore',
                    // 'PARALLELFINANCE' => 'Parallel',
                    // 'PLCULTIMA' => 'Plcu',
                    // 'PLCULTIMA2' => 'Plcu2',
                    // undetermined => XinFin, YAS, Ycash
                ),
            ),
            'precisionMode' => TICK_SIZE,
            'exceptions' => array(
                'exact' => array(
                    '10001' => '\\ccxt\\BadRequest', // syntax error
                    '10005' => '\\ccxt\\ExchangeError', // internal error
                    "Amount's scale must greater than AssetPair's base scale" => '\\ccxt\\InvalidOrder',
                    "Price mulit with amount should larger than AssetPair's min_quote_value" => '\\ccxt\\InvalidOrder',
                    '10007' => '\\ccxt\\BadRequest', // parameter error, array("code":10007,"message":"Amount's scale must greater than AssetPair's base scale")
                    '10011' => '\\ccxt\\ExchangeError', // system error
                    '10013' => '\\ccxt\\BadSymbol', // array("code":10013,"message":"Resource not found")
                    '10014' => '\\ccxt\\InsufficientFunds', // array("code":10014,"message":"Insufficient funds")
                    '10403' => '\\ccxt\\PermissionDenied', // permission denied
                    '10429' => '\\ccxt\\RateLimitExceeded', // too many requests
                    '40004' => '\\ccxt\\AuthenticationError', // array("code":40004,"message":"invalid jwt")
                    '40103' => '\\ccxt\\AuthenticationError', // invalid otp code
                    '40104' => '\\ccxt\\AuthenticationError', // invalid asset pin code
                    '40301' => '\\ccxt\\PermissionDenied', // array("code":40301,"message":"Permission denied withdrawal create")
                    '40302' => '\\ccxt\\ExchangeError', // already requested
                    '40601' => '\\ccxt\\ExchangeError', // resource is locked
                    '40602' => '\\ccxt\\ExchangeError', // resource is depleted
                    '40603' => '\\ccxt\\InsufficientFunds', // insufficient resource
                    '40604' => '\\ccxt\\InvalidOrder', // array("code":40604,"message":"Price exceed the maximum order price")
                    '40605' => '\\ccxt\\InvalidOrder', // array("code":40605,"message":"Price less than the minimum order price")
                    '40120' => '\\ccxt\\InvalidOrder', // Order is in trading
                    '40121' => '\\ccxt\\InvalidOrder', // Order is already cancelled or filled
                    '60100' => '\\ccxt\\BadSymbol', // array("code":60100,"message":"Asset pair is suspended")
                ),
                'broad' => array(
                ),
            ),
            'commonCurrencies' => array(
                'CRE' => 'Cybereits',
                'FXT' => 'FXTTOKEN',
                'FREE' => 'FreeRossDAO',
                'MBN' => 'Mobilian Coin',
                'ONE' => 'BigONE Token',
            ),
        ));
    }

    public function fetch_currencies($params = array ()) {
        return Async\async(function () use ($params) {
            /**
             * fetches all available currencies on an exchange
             * @param {dict} [$params] extra parameters specific to the exchange API endpoint
             * @return {dict} an associative dictionary of currencies
             */
            // we use undocumented link (possible, less informative alternative is : https://big.one/api/uc/v3/assets/accounts)
            $data = Async\await($this->fetch_web_endpoint('fetchCurrencies', 'webExchangeGetUcV2Assets', true));
            if ($data === null) {
                return null;
            }
            //
            // {
            //     "code" => "0",
            //     "message" => "",
            //     "data" => array(
            //       array(
            //         "name" => "TetherUS",
            //         "symbol" => "USDT",
            //         "contract_address" => "31",
            //         "is_deposit_enabled" => true,
            //         "is_withdrawal_enabled" => true,
            //         "is_stub" => false,
            //         "withdrawal_fee" => "5.0",
            //         "is_fiat" => false,
            //         "is_memo_required" => false,
            //         "logo" => array(
            //           "default" => "https://assets.peatio.com/assets/v1/color/normal/usdt.png",
            //           "white" => "https://assets.peatio.com/assets/v1/white/normal/usdt.png",
            //         ),
            //         "info_link" => null,
            //         "scale" => "12",
            //         "default_gateway" => ..., // one object from "gateways"
            //         "gateways" => array(
            //           array(
            //             "uuid" => "f0fa5a85-7f65-428a-b7b7-13aad55c2837",
            //             "name" => "Mixin",
            //             "kind" => "CHAIN",
            //             "required_confirmations" => "0",
            //           ),
            //           array(
            //             "uuid" => "b75446c6-1446-4c8d-b3d1-39f385b0a926",
            //             "name" => "Ethereum",
            //             "kind" => "CHAIN",
            //             "required_confirmations" => "18",
            //           ),
            //           array(
            //             "uuid" => "fe9b1b0b-e55c-4017-b5ce-16f524df5fc0",
            //             "name" => "Tron",
            //             "kind" => "CHAIN",
            //             "required_confirmations" => "1",
            //           ),
            //          ...
            //         ),
            //         "payments" => array(),
            //         "uuid" => "17082d1c-0195-4fb6-8779-2cdbcb9eeb3c",
            //         "binding_gateways" => array(
            //           array(
            //             "guid" => "07efc37f-d1ec-4bc9-8339-a745256ea2ba",
            //             "contract_address" => "0xdac17f958d2ee523a2206206994597c13d831ec7",
            //             "is_deposit_enabled" => true,
            //             "display_name" => "Ethereum(ERC20)",
            //             "gateway_name" => "Ethereum",
            //             "min_withdrawal_amount" => "0.000001",
            //             "min_internal_withdrawal_amount" => "0.00000001",
            //             "withdrawal_fee" => "14",
            //             "is_withdrawal_enabled" => true,
            //             "min_deposit_amount" => "0.000001",
            //             "is_memo_required" => false,
            //             "withdrawal_scale" => "2",
            //             "gateway" => array(
            //               "uuid" => "b75446c6-1446-4c8d-b3d1-39f385b0a926",
            //               "name" => "Ethereum",
            //               "kind" => "CHAIN",
            //               "required_confirmations" => "18",
            //             ),
            //             "scale" => "12",
            //          ),
            //          array(
            //             "guid" => "b80a4d13-cac7-4319-842d-b33c3bfab8ec",
            //             "contract_address" => "TR7NHqjeKQxGTCi8q8ZY4pL8otSzgjLj6t",
            //             "is_deposit_enabled" => true,
            //             "display_name" => "Tron(TRC20)",
            //             "gateway_name" => "Tron",
            //             "min_withdrawal_amount" => "0.000001",
            //             "min_internal_withdrawal_amount" => "0.00000001",
            //             "withdrawal_fee" => "1",
            //             "is_withdrawal_enabled" => true,
            //             "min_deposit_amount" => "0.000001",
            //             "is_memo_required" => false,
            //             "withdrawal_scale" => "6",
            //             "gateway" => array(
            //               "uuid" => "fe9b1b0b-e55c-4017-b5ce-16f524df5fc0",
            //               "name" => "Tron",
            //               "kind" => "CHAIN",
            //               "required_confirmations" => "1",
            //             ),
            //             "scale" => "12",
            //           ),
            //           ...
            //         ),
            //       ),
            //       ...
            //     ),
            // }
            //
            $currenciesData = $this->safe_value($data, 'data', array());
            $result = array();
            for ($i = 0; $i < count($currenciesData); $i++) {
                $currency = $currenciesData[$i];
                $id = $this->safe_string($currency, 'symbol');
                $code = $this->safe_currency_code($id);
                $name = $this->safe_string($currency, 'name');
                $type = $this->safe_value($currency, 'is_fiat') ? 'fiat' : 'crypto';
                $networks = array();
                $chains = $this->safe_value($currency, 'binding_gateways', array());
                $currencyMaxPrecision = $this->parse_precision($this->safe_string_2($currency, 'withdrawal_scale', 'scale'));
                $currencyDepositEnabled = null;
                $currencyWithdrawEnabled = null;
                for ($j = 0; $j < count($chains); $j++) {
                    $chain = $chains[$j];
                    $networkId = $this->safe_string($chain, 'gateway_name');
                    $networkCode = $this->network_id_to_code($networkId);
                    $deposit = $this->safe_value($chain, 'is_deposit_enabled');
                    $withdraw = $this->safe_value($chain, 'is_withdrawal_enabled');
                    $isActive = ($deposit && $withdraw);
                    $minDepositAmount = $this->safe_string($chain, 'min_deposit_amount');
                    $minWithdrawalAmount = $this->safe_string($chain, 'min_withdrawal_amount');
                    $withdrawalFee = $this->safe_string($chain, 'withdrawal_fee');
                    $precision = $this->parse_precision($this->safe_string_2($chain, 'withdrawal_scale', 'scale'));
                    $networks[$networkCode] = array(
                        'id' => $networkId,
                        'network' => $networkCode,
                        'margin' => null,
                        'deposit' => $deposit,
                        'withdraw' => $withdraw,
                        'active' => $isActive,
                        'fee' => $this->parse_number($withdrawalFee),
                        'precision' => $this->parse_number($precision),
                        'limits' => array(
                            'deposit' => array(
                                'min' => $minDepositAmount,
                                'max' => null,
                            ),
                            'withdraw' => array(
                                'min' => $minWithdrawalAmount,
                                'max' => null,
                            ),
                        ),
                        'info' => $chain,
                    );
                    // fill global values
                    $currencyDepositEnabled = ($currencyDepositEnabled === null) || $deposit ? $deposit : $currencyDepositEnabled;
                    $currencyWithdrawEnabled = ($currencyWithdrawEnabled === null) || $withdraw ? $withdraw : $currencyWithdrawEnabled;
                    $currencyMaxPrecision = ($currencyMaxPrecision === null) || Precise::string_gt($currencyMaxPrecision, $precision) ? $precision : $currencyMaxPrecision;
                }
                $result[$code] = array(
                    'id' => $id,
                    'code' => $code,
                    'info' => $currency,
                    'name' => $name,
                    'type' => $type,
                    'active' => null,
                    'deposit' => $currencyDepositEnabled,
                    'withdraw' => $currencyWithdrawEnabled,
                    'fee' => null,
                    'precision' => $this->parse_number($currencyMaxPrecision),
                    'limits' => array(
                        'amount' => array(
                            'min' => null,
                            'max' => null,
                        ),
                        'withdraw' => array(
                            'min' => null,
                            'max' => null,
                        ),
                    ),
                    'networks' => $networks,
                );
            }
            return $result;
        }) ();
    }

    public function fetch_markets($params = array ()) {
        return Async\async(function () use ($params) {
            /**
             * retrieves data on all $markets for bigone
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array[]} an array of objects representing $market data
             */
            $promises = array( $this->publicGetAssetPairs ($params), $this->contractPublicGetSymbols ($params) );
            $promisesResult = Async\await(Promise\all($promises));
            $response = $promisesResult[0];
            $contractResponse = $promisesResult[1];
            //
            //     {
            //         "code":0,
            //         "data":array(
            //             array(
            //                 "id":"01e48809-b42f-4a38-96b1-c4c547365db1",
            //                 "name":"PCX-BTC",
            //                 "quote_scale":7,
            //                 "quote_asset":array(
            //                     "id":"0df9c3c3-255a-46d7-ab82-dedae169fba9",
            //                     "symbol":"BTC",
            //                     "name":"Bitcoin",
            //                 ),
            //                 "base_asset":array(
            //                     "id":"405484f7-4b03-4378-a9c1-2bd718ecab51",
            //                     "symbol":"PCX",
            //                     "name":"ChainX",
            //                 ),
            //                 "base_scale":3,
            //                 "min_quote_value":"0.0001",
            //                 "max_quote_value":"35"
            //             ),
            //         )
            //     }
            //
            //
            //    array(
            //        array(
            //            "baseCurrency" => "BTC",
            //            "multiplier" => 1,
            //            "enable" => true,
            //            "priceStep" => 0.5,
            //            "maxRiskLimit" => 1000,
            //            "pricePrecision" => 1,
            //            "maintenanceMargin" => 0.00500,
            //            "symbol" => "BTCUSD",
            //            "valuePrecision" => 4,
            //            "minRiskLimit" => 100,
            //            "riskLimit" => 100,
            //            "isInverse" => true,
            //            "riskStep" => 1,
            //            "settleCurrency" => "BTC",
            //            "baseName" => "Bitcoin",
            //            "feePrecision" => 8,
            //            "priceMin" => 0.5,
            //            "priceMax" => 1E+6,
            //            "initialMargin" => 0.01000,
            //            "quoteCurrency" => "USD"
            //        ),
            //        ...
            //    )
            //
            $markets = $this->safe_value($response, 'data', array());
            $result = array();
            for ($i = 0; $i < count($markets); $i++) {
                $market = $markets[$i];
                $baseAsset = $this->safe_value($market, 'base_asset', array());
                $quoteAsset = $this->safe_value($market, 'quote_asset', array());
                $baseId = $this->safe_string($baseAsset, 'symbol');
                $quoteId = $this->safe_string($quoteAsset, 'symbol');
                $base = $this->safe_currency_code($baseId);
                $quote = $this->safe_currency_code($quoteId);
                $result[] = $this->safe_market_structure(array(
                    'id' => $this->safe_string($market, 'name'),
                    'uuid' => $this->safe_string($market, 'id'),
                    'symbol' => $base . '/' . $quote,
                    'base' => $base,
                    'quote' => $quote,
                    'settle' => null,
                    'baseId' => $baseId,
                    'quoteId' => $quoteId,
                    'settleId' => null,
                    'type' => 'spot',
                    'spot' => true,
                    'margin' => false,
                    'swap' => false,
                    'future' => false,
                    'option' => false,
                    'active' => true,
                    'contract' => false,
                    'linear' => null,
                    'inverse' => null,
                    'contractSize' => null,
                    'expiry' => null,
                    'expiryDatetime' => null,
                    'strike' => null,
                    'optionType' => null,
                    'precision' => array(
                        'amount' => $this->parse_number($this->parse_precision($this->safe_string($market, 'base_scale'))),
                        'price' => $this->parse_number($this->parse_precision($this->safe_string($market, 'quote_scale'))),
                    ),
                    'limits' => array(
                        'leverage' => array(
                            'min' => null,
                            'max' => null,
                        ),
                        'amount' => array(
                            'min' => null,
                            'max' => null,
                        ),
                        'price' => array(
                            'min' => null,
                            'max' => null,
                        ),
                        'cost' => array(
                            'min' => $this->safe_number($market, 'min_quote_value'),
                            'max' => $this->safe_number($market, 'max_quote_value'),
                        ),
                    ),
                    'created' => null,
                    'info' => $market,
                ));
            }
            for ($i = 0; $i < count($contractResponse); $i++) {
                $market = $contractResponse[$i];
                $baseId = $this->safe_string($market, 'baseCurrency');
                $quoteId = $this->safe_string($market, 'quoteCurrency');
                $settleId = $this->safe_string($market, 'settleCurrency');
                $marketId = $this->safe_string($market, 'symbol');
                $base = $this->safe_currency_code($baseId);
                $quote = $this->safe_currency_code($quoteId);
                $settle = $this->safe_currency_code($settleId);
                $inverse = $this->safe_value($market, 'isInverse');
                $result[] = $this->safe_market_structure(array(
                    'id' => $marketId,
                    'symbol' => $base . '/' . $quote . ':' . $settle,
                    'base' => $base,
                    'quote' => $quote,
                    'settle' => $settle,
                    'baseId' => $baseId,
                    'quoteId' => $quoteId,
                    'settleId' => $settleId,
                    'type' => 'swap',
                    'spot' => false,
                    'margin' => false,
                    'swap' => true,
                    'future' => false,
                    'option' => false,
                    'active' => $this->safe_value($market, 'enable'),
                    'contract' => true,
                    'linear' => !$inverse,
                    'inverse' => $inverse,
                    'contractSize' => $this->safe_number($market, 'multiplier'),
                    'expiry' => null,
                    'expiryDatetime' => null,
                    'strike' => null,
                    'optionType' => null,
                    'precision' => array(
                        'amount' => $this->parse_number($this->parse_precision($this->safe_string($market, 'valuePrecision'))),
                        'price' => $this->parse_number($this->parse_precision($this->safe_string($market, 'pricePrecision'))),
                    ),
                    'limits' => array(
                        'leverage' => array(
                            'min' => null,
                            'max' => null,
                        ),
                        'amount' => array(
                            'min' => null,
                            'max' => null,
                        ),
                        'price' => array(
                            'min' => $this->safe_number($market, 'priceMin'),
                            'max' => $this->safe_number($market, 'priceMax'),
                        ),
                        'cost' => array(
                            'min' => $this->safe_number($market, 'initialMargin'),
                            'max' => null,
                        ),
                    ),
                    'info' => $market,
                ));
            }
            return $result;
        }) ();
    }

    public function parse_ticker($ticker, ?array $market = null): array {
        //
        // spot
        //
        //    {
        //        "asset_pair_name" => "ETH-BTC",
        //        "bid" => array(
        //            "price" => "0.021593",
        //            "order_count" => 1,
        //            "quantity" => "0.20936"
        //        ),
        //        "ask" => array(
        //            "price" => "0.021613",
        //            "order_count" => 1,
        //            "quantity" => "2.87064"
        //        ),
        //        "open" => "0.021795",
        //        "high" => "0.021795",
        //        "low" => "0.021471",
        //        "close" => "0.021613",
        //        "volume" => "117078.90431",
        //        "daily_change" => "-0.000182"
        //    }
        //
        // contract
        //
        //    {
        //        "usdtPrice" => 1.00031998,
        //        "symbol" => "BTCUSD",
        //        "btcPrice" => 34700.4,
        //        "ethPrice" => 1787.83,
        //        "nextFundingRate" => 0.00010,
        //        "fundingRate" => 0.00010,
        //        "latestPrice" => 34708.5,
        //        "last24hPriceChange" => 0.0321,
        //        "indexPrice" => 34700.4,
        //        "volume24h" => 261319063,
        //        "turnover24h" => 8204.129380685496,
        //        "nextFundingTime" => 1698285600000,
        //        "markPrice" => 34702.4646738,
        //        "last24hMaxPrice" => 35127.5,
        //        "volume24hInUsd" => 0.0,
        //        "openValue" => 32.88054722085945,
        //        "last24hMinPrice" => 33552.0,
        //        "openInterest" => 1141372.0
        //    }
        //
        $marketType = (is_array($ticker) && array_key_exists('asset_pair_name', $ticker)) ? 'spot' : 'swap';
        $marketId = $this->safe_string_2($ticker, 'asset_pair_name', 'symbol');
        $symbol = $this->safe_symbol($marketId, $market, '-', $marketType);
        $close = $this->safe_string_2($ticker, 'close', 'latestPrice');
        $bid = $this->safe_value($ticker, 'bid', array());
        $ask = $this->safe_value($ticker, 'ask', array());
        return $this->safe_ticker(array(
            'symbol' => $symbol,
            'timestamp' => null,
            'datetime' => null,
            'high' => $this->safe_string_2($ticker, 'high', 'last24hMaxPrice'),
            'low' => $this->safe_string_2($ticker, 'low', 'last24hMinPrice'),
            'bid' => $this->safe_string($bid, 'price'),
            'bidVolume' => $this->safe_string($bid, 'quantity'),
            'ask' => $this->safe_string($ask, 'price'),
            'askVolume' => $this->safe_string($ask, 'quantity'),
            'vwap' => null,
            'open' => $this->safe_string($ticker, 'open'),
            'close' => $close,
            'last' => $close,
            'previousClose' => null,
            'change' => $this->safe_string_2($ticker, 'daily_change', 'last24hPriceChange'),
            'percentage' => null,
            'average' => null,
            'baseVolume' => $this->safe_string_2($ticker, 'volume', 'volume24h'),
            'quoteVolume' => $this->safe_string($ticker, 'volume24hInUsd'),
            'info' => $ticker,
        ), $market);
    }

    public function fetch_ticker(string $symbol, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $params) {
            /**
             * fetches a price $ticker, a statistical calculation with the information calculated over the past 24 hours for a specific $market
             * @param {string} $symbol unified $symbol of the $market to fetch the $ticker for
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} a ~@link https://docs.ccxt.com/#/?id=$ticker-structure $ticker structure~
             */
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $type = null;
            list($type, $params) = $this->handle_market_type_and_params('fetchTicker', $market, $params);
            if ($type === 'spot') {
                $request = array(
                    'asset_pair_name' => $market['id'],
                );
                $response = Async\await($this->publicGetAssetPairsAssetPairNameTicker (array_merge($request, $params)));
                //
                //     {
                //         "code":0,
                //         "data":{
                //             "asset_pair_name":"ETH-BTC",
                //             "bid":array("price":"0.021593","order_count":1,"quantity":"0.20936"),
                //             "ask":array("price":"0.021613","order_count":1,"quantity":"2.87064"),
                //             "open":"0.021795",
                //             "high":"0.021795",
                //             "low":"0.021471",
                //             "close":"0.021613",
                //             "volume":"117078.90431",
                //             "daily_change":"-0.000182"
                //         }
                //     }
                //
                $ticker = $this->safe_value($response, 'data', array());
                return $this->parse_ticker($ticker, $market);
            } else {
                $tickers = Async\await($this->fetch_tickers(array( $symbol ), $params));
                return $this->safe_value($tickers, $symbol);
            }
        }) ();
    }

    public function fetch_tickers(?array $symbols = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbols, $params) {
            /**
             * fetches price $tickers for multiple markets, statistical information calculated over the past 24 hours for each $market
             * @param {string[]} [$symbols] unified $symbols of the markets to fetch the ticker for, all $market $tickers are returned if not assigned
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} a dictionary of ~@link https://docs.ccxt.com/#/?id=ticker-structure ticker structures~
             */
            Async\await($this->load_markets());
            $market = null;
            $symbol = $this->safe_string($symbols, 0);
            if ($symbol !== null) {
                $market = $this->market($symbol);
            }
            $type = null;
            list($type, $params) = $this->handle_market_type_and_params('fetchTickers', $market, $params);
            $isSpot = $type === 'spot';
            $request = array();
            $symbols = $this->market_symbols($symbols);
            $data = null;
            if ($isSpot) {
                if ($symbols !== null) {
                    $ids = $this->market_ids($symbols);
                    $request['pair_names'] = implode(',', $ids);
                }
                $response = Async\await($this->publicGetAssetPairsTickers (array_merge($request, $params)));
                //
                //    {
                //        "code" => 0,
                //        "data" => array(
                //            array(
                //                "asset_pair_name" => "PCX-BTC",
                //                "bid" => array(
                //                    "price" => "0.000234",
                //                    "order_count" => 1,
                //                    "quantity" => "0.518"
                //                ),
                //                "ask" => array(
                //                    "price" => "0.0002348",
                //                    "order_count" => 1,
                //                    "quantity" => "2.348"
                //                ),
                //                "open" => "0.0002343",
                //                "high" => "0.0002348",
                //                "low" => "0.0002162",
                //                "close" => "0.0002348",
                //                "volume" => "12887.016",
                //                "daily_change" => "0.0000005"
                //            ),
                //            ...
                //        )
                //    }
                //
                $data = $this->safe_value($response, 'data', array());
            } else {
                $data = Async\await($this->contractPublicGetInstruments ($params));
                //
                //    array(
                //        {
                //            "usdtPrice" => 1.00031998,
                //            "symbol" => "BTCUSD",
                //            "btcPrice" => 34700.4,
                //            "ethPrice" => 1787.83,
                //            "nextFundingRate" => 0.00010,
                //            "fundingRate" => 0.00010,
                //            "latestPrice" => 34708.5,
                //            "last24hPriceChange" => 0.0321,
                //            "indexPrice" => 34700.4,
                //            "volume24h" => 261319063,
                //            "turnover24h" => 8204.129380685496,
                //            "nextFundingTime" => 1698285600000,
                //            "markPrice" => 34702.4646738,
                //            "last24hMaxPrice" => 35127.5,
                //            "volume24hInUsd" => 0.0,
                //            "openValue" => 32.88054722085945,
                //            "last24hMinPrice" => 33552.0,
                //            "openInterest" => 1141372.0
                //        }
                //        ...
                //    )
                //
            }
            $tickers = $this->parse_tickers($data, $symbols);
            return $this->filter_by_array_tickers($tickers, 'symbol', $symbols);
        }) ();
    }

    public function fetch_time($params = array ()) {
        return Async\async(function () use ($params) {
            /**
             * fetches the current integer $timestamp in milliseconds from the exchange server
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {int} the current integer $timestamp in milliseconds from the exchange server
             */
            $response = Async\await($this->publicGetPing ($params));
            //
            //     {
            //         "data" => {
            //             "timestamp" => 1527665262168391000
            //         }
            //     }
            //
            $data = $this->safe_value($response, 'data', array());
            $timestamp = $this->safe_integer($data, 'Timestamp');
            return $this->parse_to_int($timestamp / 1000000);
        }) ();
    }

    public function fetch_order_book(string $symbol, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $limit, $params) {
            /**
             * fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
             * @param {string} $symbol unified $symbol of the $market to fetch the order book for
             * @param {int} [$limit] the maximum amount of order book entries to return
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} A dictionary of ~@link https://docs.ccxt.com/#/?id=order-book-structure order book structures~ indexed by $market symbols
             */
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $response = null;
            if ($market['contract']) {
                $request = array(
                    'symbol' => $market['id'],
                );
                $response = Async\await($this->contractPublicGetDepthSymbolSnapshot (array_merge($request, $params)));
                //
                //    {
                //        bids => array(
                //            '20000' => '20',
                //            ...
                //            '34552' => '64851',
                //            '34526.5' => '59594',
                //            ...
                //            '34551.5' => '29711'
                //        ),
                //        asks => array(
                //            '34557' => '34395',
                //            ...
                //            '40000' => '20',
                //            '34611.5' => '56024',
                //            ...
                //            '34578.5' => '66367'
                //        ),
                //        to => '59737174',
                //        lastPrice => '34554.5',
                //        bestPrices => array(
                //            ask => '34557.0',
                //            bid => '34552.0'
                //        ),
                //        from => '0'
                //    }
                //
                return $this->parse_contract_order_book($response, $market['symbol'], $limit);
            } else {
                $request = array(
                    'asset_pair_name' => $market['id'],
                );
                if ($limit !== null) {
                    $request['limit'] = $limit; // default 50, max 200
                }
                $response = Async\await($this->publicGetAssetPairsAssetPairNameDepth (array_merge($request, $params)));
                //
                //     {
                //         "code":0,
                //         "data" => {
                //             "asset_pair_name" => "EOS-BTC",
                //             "bids" => array(
                //                 array( "price" => "42", "order_count" => 4, "quantity" => "23.33363711" )
                //             ),
                //             "asks" => array(
                //                 array( "price" => "45", "order_count" => 2, "quantity" => "4193.3283464" )
                //             )
                //         }
                //     }
                //
                $orderbook = $this->safe_value($response, 'data', array());
                return $this->parse_order_book($orderbook, $market['symbol'], null, 'bids', 'asks', 'price', 'quantity');
            }
        }) ();
    }

    public function parse_contract_bids_asks($bidsAsks) {
        $bidsAsksKeys = is_array($bidsAsks) ? array_keys($bidsAsks) : array();
        $result = array();
        for ($i = 0; $i < count($bidsAsksKeys); $i++) {
            $price = $bidsAsksKeys[$i];
            $amount = $bidsAsks[$price];
            $result[] = array( $this->parse_number($price), $this->parse_number($amount) );
        }
        return $result;
    }

    public function parse_contract_order_book(array $orderbook, string $symbol, ?int $limit = null): array {
        $responseBids = $this->safe_value($orderbook, 'bids');
        $responseAsks = $this->safe_value($orderbook, 'asks');
        $bids = $this->parse_contract_bids_asks($responseBids);
        $asks = $this->parse_contract_bids_asks($responseAsks);
        return array(
            'symbol' => $symbol,
            'bids' => $this->filter_by_limit($this->sort_by($bids, 0, true), $limit),
            'asks' => $this->filter_by_limit($this->sort_by($asks, 0), $limit),
            'timestamp' => null,
            'datetime' => null,
            'nonce' => null,
        );
    }

    public function parse_trade($trade, ?array $market = null): array {
        //
        // fetchTrades (public)
        //
        //     {
        //         "id" => 38199941,
        //         "price" => "3378.67",
        //         "amount" => "0.019812",
        //         "taker_side" => "ASK",
        //         "created_at" => "2019-01-29T06:05:56Z"
        //     }
        //
        // fetchMyTrades (private)
        //
        //     array(
        //         "id" => 10854280,
        //         "asset_pair_name" => "XIN-USDT",
        //         "price" => "70",
        //         "amount" => "1",
        //         "taker_side" => "ASK",
        //         "maker_order_id" => 58284908,
        //         "taker_order_id" => 58284909,
        //         "maker_fee" => "0.0008",
        //         "taker_fee" => "0.07",
        //         "side" => "SELF_TRADING",
        //         "inserted_at" => "2019-04-16T12:00:01Z"
        //     ),
        //
        //     {
        //         "id" => 10854263,
        //         "asset_pair_name" => "XIN-USDT",
        //         "price" => "75.7",
        //         "amount" => "12.743149",
        //         "taker_side" => "BID",
        //         "maker_order_id" => null,
        //         "taker_order_id" => 58284888,
        //         "maker_fee" => null,
        //         "taker_fee" => "0.0025486298",
        //         "side" => "BID",
        //         "inserted_at" => "2019-04-15T06:20:57Z"
        //     }
        //
        $timestamp = $this->parse8601($this->safe_string_2($trade, 'created_at', 'inserted_at'));
        $priceString = $this->safe_string($trade, 'price');
        $amountString = $this->safe_string($trade, 'amount');
        $marketId = $this->safe_string($trade, 'asset_pair_name');
        $market = $this->safe_market($marketId, $market, '-');
        $side = $this->safe_string($trade, 'side');
        $takerSide = $this->safe_string($trade, 'taker_side');
        $takerOrMaker = null;
        if (($takerSide !== null) && ($side !== null) && ($side !== 'SELF_TRADING')) {
            $takerOrMaker = ($takerSide === $side) ? 'taker' : 'maker';
        }
        if ($side === null) {
            // taker $side is not related to buy/sell $side
            // the following code is probably a mistake
            $side = ($takerSide === 'ASK') ? 'sell' : 'buy';
        } else {
            if ($side === 'BID') {
                $side = 'buy';
            } elseif ($side === 'ASK') {
                $side = 'sell';
            }
        }
        $makerOrderId = $this->safe_string($trade, 'maker_order_id');
        $takerOrderId = $this->safe_string($trade, 'taker_order_id');
        $orderId = null;
        if ($makerOrderId !== null) {
            $orderId = $makerOrderId;
        } elseif ($takerOrderId !== null) {
            $orderId = $takerOrderId;
        }
        $id = $this->safe_string($trade, 'id');
        $result = array(
            'id' => $id,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'symbol' => $market['symbol'],
            'order' => $orderId,
            'type' => 'limit',
            'side' => $side,
            'takerOrMaker' => $takerOrMaker,
            'price' => $priceString,
            'amount' => $amountString,
            'cost' => null,
            'info' => $trade,
        );
        $makerCurrencyCode = null;
        $takerCurrencyCode = null;
        if ($takerOrMaker !== null) {
            if ($side === 'buy') {
                if ($takerOrMaker === 'maker') {
                    $makerCurrencyCode = $market['base'];
                    $takerCurrencyCode = $market['quote'];
                } else {
                    $makerCurrencyCode = $market['quote'];
                    $takerCurrencyCode = $market['base'];
                }
            } else {
                if ($takerOrMaker === 'maker') {
                    $makerCurrencyCode = $market['quote'];
                    $takerCurrencyCode = $market['base'];
                } else {
                    $makerCurrencyCode = $market['base'];
                    $takerCurrencyCode = $market['quote'];
                }
            }
        } elseif ($side === 'SELF_TRADING') {
            if ($takerSide === 'BID') {
                $makerCurrencyCode = $market['quote'];
                $takerCurrencyCode = $market['base'];
            } elseif ($takerSide === 'ASK') {
                $makerCurrencyCode = $market['base'];
                $takerCurrencyCode = $market['quote'];
            }
        }
        $makerFeeCost = $this->safe_string($trade, 'maker_fee');
        $takerFeeCost = $this->safe_string($trade, 'taker_fee');
        if ($makerFeeCost !== null) {
            if ($takerFeeCost !== null) {
                $result['fees'] = array(
                    array( 'cost' => $makerFeeCost, 'currency' => $makerCurrencyCode ),
                    array( 'cost' => $takerFeeCost, 'currency' => $takerCurrencyCode ),
                );
            } else {
                $result['fee'] = array( 'cost' => $makerFeeCost, 'currency' => $makerCurrencyCode );
            }
        } elseif ($takerFeeCost !== null) {
            $result['fee'] = array( 'cost' => $takerFeeCost, 'currency' => $takerCurrencyCode );
        } else {
            $result['fee'] = null;
        }
        return $this->safe_trade($result, $market);
    }

    public function fetch_trades(string $symbol, ?int $since = null, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            /**
             * get the list of most recent $trades for a particular $symbol
             * @param {string} $symbol unified $symbol of the $market to fetch $trades for
             * @param {int} [$since] timestamp in ms of the earliest trade to fetch
             * @param {int} [$limit] the maximum amount of $trades to fetch
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {Trade[]} a list of ~@link https://docs.ccxt.com/#/?id=public-$trades trade structures~
             */
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            if ($market['contract']) {
                throw new BadRequest($this->id . ' fetchTrades () can only fetch $trades for spot markets');
            }
            $request = array(
                'asset_pair_name' => $market['id'],
            );
            $response = Async\await($this->publicGetAssetPairsAssetPairNameTrades (array_merge($request, $params)));
            //
            //     {
            //         "code" => 0,
            //         "data" => array(
            //             array(
            //                 "id" => 38199941,
            //                 "price" => "3378.67",
            //                 "amount" => "0.019812",
            //                 "taker_side" => "ASK",
            //                 "created_at" => "2019-01-29T06:05:56Z"
            //             ),
            //             {
            //                 "id" => 38199934,
            //                 "price" => "3376.14",
            //                 "amount" => "0.019384",
            //                 "taker_side" => "ASK",
            //                 "created_at" => "2019-01-29T06:05:40Z"
            //             }
            //         )
            //     }
            //
            $trades = $this->safe_value($response, 'data', array());
            return $this->parse_trades($trades, $market, $since, $limit);
        }) ();
    }

    public function parse_ohlcv($ohlcv, ?array $market = null): array {
        //
        //     {
        //         "close" => "0.021562",
        //         "high" => "0.021563",
        //         "low" => "0.02156",
        //         "open" => "0.021563",
        //         "time" => "2019-11-21T07:54:00Z",
        //         "volume" => "59.84376"
        //     }
        //
        return array(
            $this->parse8601($this->safe_string($ohlcv, 'time')),
            $this->safe_number($ohlcv, 'open'),
            $this->safe_number($ohlcv, 'high'),
            $this->safe_number($ohlcv, 'low'),
            $this->safe_number($ohlcv, 'close'),
            $this->safe_number($ohlcv, 'volume'),
        );
    }

    public function fetch_ohlcv(string $symbol, $timeframe = '1m', ?int $since = null, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $timeframe, $since, $limit, $params) {
            /**
             * fetches historical candlestick $data containing the open, high, low, and close price, and the volume of a $market
             * @param {string} $symbol unified $symbol of the $market to fetch OHLCV $data for
             * @param {string} $timeframe the length of time each candle represents
             * @param {int} [$since] timestamp in ms of the earliest candle to fetch
             * @param {int} [$limit] the maximum amount of candles to fetch
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {int[][]} A list of candles ordered, open, high, low, close, volume
             */
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            if ($market['contract']) {
                throw new BadRequest($this->id . ' fetchOHLCV () can only fetch ohlcvs for spot markets');
            }
            if ($limit === null) {
                $limit = 100; // default 100, max 500
            }
            $request = array(
                'asset_pair_name' => $market['id'],
                'period' => $this->safe_string($this->timeframes, $timeframe, $timeframe),
                'limit' => $limit,
            );
            if ($since !== null) {
                // $start = $this->parse_to_int($since / 1000);
                $duration = $this->parse_timeframe($timeframe);
                $end = $this->sum($since, $limit * $duration * 1000);
                $request['time'] = $this->iso8601($end);
            }
            $response = Async\await($this->publicGetAssetPairsAssetPairNameCandles (array_merge($request, $params)));
            //
            //     {
            //         "code" => 0,
            //         "data" => array(
            //             array(
            //                 "close" => "0.021656",
            //                 "high" => "0.021658",
            //                 "low" => "0.021652",
            //                 "open" => "0.021652",
            //                 "time" => "2019-11-21T09:30:00Z",
            //                 "volume" => "53.08664"
            //             ),
            //             array(
            //                 "close" => "0.021652",
            //                 "high" => "0.021656",
            //                 "low" => "0.021652",
            //                 "open" => "0.021656",
            //                 "time" => "2019-11-21T09:29:00Z",
            //                 "volume" => "88.39861"
            //             ),
            //         )
            //     }
            //
            $data = $this->safe_value($response, 'data', array());
            return $this->parse_ohlcvs($data, $market, $timeframe, $since, $limit);
        }) ();
    }

    public function parse_balance($response): array {
        $result = array(
            'info' => $response,
            'timestamp' => null,
            'datetime' => null,
        );
        $balances = $this->safe_value($response, 'data', array());
        for ($i = 0; $i < count($balances); $i++) {
            $balance = $balances[$i];
            $symbol = $this->safe_string($balance, 'asset_symbol');
            $code = $this->safe_currency_code($symbol);
            $account = $this->account();
            $account['total'] = $this->safe_string($balance, 'balance');
            $account['used'] = $this->safe_string($balance, 'locked_balance');
            $result[$code] = $account;
        }
        return $this->safe_balance($result);
    }

    public function fetch_balance($params = array ()): PromiseInterface {
        return Async\async(function () use ($params) {
            /**
             * query for balance and get the amount of funds available for trading or funds locked in orders
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} a ~@link https://docs.ccxt.com/#/?id=balance-structure balance structure~
             */
            Async\await($this->load_markets());
            $type = $this->safe_string($params, 'type', '');
            $params = $this->omit($params, 'type');
            $response = null;
            if ($type === 'funding' || $type === 'fund') {
                $response = Async\await($this->privateGetFundAccounts ($params));
            } else {
                $response = Async\await($this->privateGetAccounts ($params));
            }
            //
            //     {
            //         "code":0,
            //         "data":array(
            //             array("asset_symbol":"NKC","balance":"0","locked_balance":"0"),
            //             array("asset_symbol":"UBTC","balance":"0","locked_balance":"0"),
            //             array("asset_symbol":"READ","balance":"0","locked_balance":"0"),
            //         ),
            //     }
            //
            return $this->parse_balance($response);
        }) ();
    }

    public function parse_type(string $type) {
        $types = array(
            'STOP_LIMIT' => 'limit',
            'STOP_MARKET' => 'market',
            'LIMIT' => 'limit',
            'MARKET' => 'market',
        );
        return $this->safe_string($types, $type, $type);
    }

    public function parse_order($order, ?array $market = null): array {
        //
        //    {
        //        "id" => "42154072251",
        //        "asset_pair_name" => "SOL-USDT",
        //        "price" => "20",
        //        "amount" => "0.5",
        //        "filled_amount" => "0",
        //        "avg_deal_price" => "0",
        //        "side" => "ASK",
        //        "state" => "PENDING",
        //        "created_at" => "2023-09-13T03:42:00Z",
        //        "updated_at" => "2023-09-13T03:42:00Z",
        //        "type" => "LIMIT",
        //        "stop_price" => "0",
        //        "immediate_or_cancel" => false,
        //        "post_only" => false,
        //        "client_order_id" => ''
        //    }
        //
        $id = $this->safe_string($order, 'id');
        $marketId = $this->safe_string($order, 'asset_pair_name');
        $symbol = $this->safe_symbol($marketId, $market, '-');
        $timestamp = $this->parse8601($this->safe_string($order, 'created_at'));
        $side = $this->safe_string($order, 'side');
        if ($side === 'BID') {
            $side = 'buy';
        } else {
            $side = 'sell';
        }
        $triggerPrice = $this->safe_string($order, 'stop_price');
        if (Precise::string_eq($triggerPrice, '0')) {
            $triggerPrice = null;
        }
        $immediateOrCancel = $this->safe_value($order, 'immediate_or_cancel');
        $timeInForce = null;
        if ($immediateOrCancel) {
            $timeInForce = 'IOC';
        }
        $type = $this->parse_type($this->safe_string($order, 'type'));
        $price = $this->safe_string($order, 'price');
        $amount = null;
        $filled = null;
        $cost = null;
        if ($type === 'market' && $side === 'buy') {
            $cost = $this->safe_string($order, 'filled_amount');
        } else {
            $amount = $this->safe_string($order, 'amount');
            $filled = $this->safe_string($order, 'filled_amount');
        }
        return $this->safe_order(array(
            'info' => $order,
            'id' => $id,
            'clientOrderId' => $this->safe_string($order, 'client_order_id'),
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'lastTradeTimestamp' => $this->parse8601($this->safe_string($order, 'updated_at')),
            'symbol' => $symbol,
            'type' => $type,
            'timeInForce' => $timeInForce,
            'postOnly' => $this->safe_value($order, 'post_only'),
            'side' => $side,
            'price' => $price,
            'stopPrice' => $triggerPrice,
            'triggerPrice' => $triggerPrice,
            'amount' => $amount,
            'cost' => $cost,
            'average' => $this->safe_string($order, 'avg_deal_price'),
            'filled' => $filled,
            'remaining' => null,
            'status' => $this->parse_order_status($this->safe_string($order, 'state')),
            'fee' => null,
            'trades' => null,
        ), $market);
    }

    public function create_market_buy_order_with_cost(string $symbol, $cost, $params = array ()) {
        return Async\async(function () use ($symbol, $cost, $params) {
            /**
             * create a $market buy order by providing the $symbol and $cost
             * @see https://open.big.one/docs/spot_orders.html#create-order
             * @param {string} $symbol unified $symbol of the $market to create an order in
             * @param {float} $cost how much you want to trade in units of the quote currency
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} an ~@link https://docs.ccxt.com/#/?id=order-structure order structure~
             */
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            if (!$market['spot']) {
                throw new NotSupported($this->id . ' createMarketBuyOrderWithCost() supports spot orders only');
            }
            $params['createMarketBuyOrderRequiresPrice'] = false;
            return Async\await($this->create_order($symbol, 'market', 'buy', $cost, null, $params));
        }) ();
    }

    public function create_order(string $symbol, string $type, string $side, $amount, $price = null, $params = array ()) {
        return Async\async(function () use ($symbol, $type, $side, $amount, $price, $params) {
            /**
             * create a trade $order
             * @see https://open.big.one/docs/spot_orders.html#create-$order
             * @param {string} $symbol unified $symbol of the $market to create an $order in
             * @param {string} $type 'market' or 'limit'
             * @param {string} $side 'buy' or 'sell'
             * @param {float} $amount how much of currency you want to trade in units of base currency
             * @param {float} [$price] the $price at which the $order is to be fullfilled, in units of the quote currency, ignored in $market orders
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @param {float} [$params->triggerPrice] the $price at which a trigger $order is triggered at
             * @param {bool} [$params->postOnly] if true, the $order will only be posted to the $order book and not executed immediately
             * @param {string} [$params->timeInForce] "GTC", "IOC", or "PO"
             * @param {float} [$params->cost] *spot $market buy only* the quote quantity that can be used alternative for the $amount
             *
             * EXCHANGE SPECIFIC PARAMETERS
             * @param {string} operator *stop $order only* GTE or LTE (default)
             * @param {string} client_order_id must match ^[a-zA-Z0-9-_]array(1,36)$ this regex. client_order_id is unique in 24 hours, If created 24 hours later and the $order closed, it will be released and can be reused
             * @return {array} an ~@link https://docs.ccxt.com/#/?id=$order-structure $order structure~
             */
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $isBuy = ($side === 'buy');
            $requestSide = $isBuy ? 'BID' : 'ASK';
            $uppercaseType = strtoupper($type);
            $isLimit = $uppercaseType === 'LIMIT';
            $exchangeSpecificParam = $this->safe_value($params, 'post_only', false);
            $postOnly = null;
            list($postOnly, $params) = $this->handle_post_only(($uppercaseType === 'MARKET'), $exchangeSpecificParam, $params);
            $triggerPrice = $this->safe_string_n($params, array( 'triggerPrice', 'stopPrice', 'stop_price' ));
            $request = array(
                'asset_pair_name' => $market['id'], // asset pair name BTC-USDT, required
                'side' => $requestSide, // $order $side one of "ASK"/"BID", required
                'amount' => $this->amount_to_precision($symbol, $amount), // $order $amount, string, required
                // "price" => $this->price_to_precision($symbol, $price), // $order $price, string, required
                // "operator" => "GTE", // stop orders only, GTE greater than and equal, LTE less than and equal
                // "immediate_or_cancel" => false, // limit orders only, must be false when post_only is true
                // "post_only" => false, // limit orders only, must be false when immediate_or_cancel is true
            );
            if ($isLimit || ($uppercaseType === 'STOP_LIMIT')) {
                $request['price'] = $this->price_to_precision($symbol, $price);
                if ($isLimit) {
                    $timeInForce = $this->safe_string($params, 'timeInForce');
                    if ($timeInForce === 'IOC') {
                        $request['immediate_or_cancel'] = true;
                    }
                    if ($postOnly) {
                        $request['post_only'] = true;
                    }
                }
                $request['amount'] = $this->amount_to_precision($symbol, $amount);
            } else {
                if ($isBuy) {
                    $createMarketBuyOrderRequiresPrice = true;
                    list($createMarketBuyOrderRequiresPrice, $params) = $this->handle_option_and_params($params, 'createOrder', 'createMarketBuyOrderRequiresPrice', true);
                    $cost = $this->safe_number($params, 'cost');
                    $params = $this->omit($params, 'cost');
                    if ($createMarketBuyOrderRequiresPrice) {
                        if (($price === null) && ($cost === null)) {
                            throw new InvalidOrder($this->id . ' createOrder() requires the $price argument for $market buy orders to calculate the total $cost to spend ($amount * $price), alternatively set the $createMarketBuyOrderRequiresPrice option or param to false and pass the $cost to spend in the $amount argument');
                        } else {
                            $amountString = $this->number_to_string($amount);
                            $priceString = $this->number_to_string($price);
                            $quoteAmount = $this->parse_to_numeric(Precise::string_mul($amountString, $priceString));
                            $costRequest = ($cost !== null) ? $cost : $quoteAmount;
                            $request['amount'] = $this->cost_to_precision($symbol, $costRequest);
                        }
                    } else {
                        $request['amount'] = $this->cost_to_precision($symbol, $amount);
                    }
                } else {
                    $request['amount'] = $this->amount_to_precision($symbol, $amount);
                }
            }
            if ($triggerPrice !== null) {
                $request['stop_price'] = $this->price_to_precision($symbol, $triggerPrice);
                $request['operator'] = $isBuy ? 'GTE' : 'LTE';
                if ($isLimit) {
                    $uppercaseType = 'STOP_LIMIT';
                } elseif ($uppercaseType === 'MARKET') {
                    $uppercaseType = 'STOP_MARKET';
                }
            }
            $request['type'] = $uppercaseType;
            $params = $this->omit($params, array( 'stop_price', 'stopPrice', 'triggerPrice', 'timeInForce' ));
            $response = Async\await($this->privatePostOrders (array_merge($request, $params)));
            //
            //    {
            //        "id" => 10,
            //        "asset_pair_name" => "EOS-BTC",
            //        "price" => "10.00",
            //        "amount" => "10.00",
            //        "filled_amount" => "9.0",
            //        "avg_deal_price" => "12.0",
            //        "side" => "ASK",
            //        "state" => "FILLED",
            //        "created_at":"2019-01-29T06:05:56Z",
            //        "updated_at":"2019-01-29T06:05:56Z"
            //    }
            //
            $order = $this->safe_value($response, 'data');
            return $this->parse_order($order, $market);
        }) ();
    }

    public function cancel_order(string $id, ?string $symbol = null, $params = array ()) {
        return Async\async(function () use ($id, $symbol, $params) {
            /**
             * cancels an open $order
             * @param {string} $id $order $id
             * @param {string} $symbol Not used by bigone cancelOrder ()
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} An ~@link https://docs.ccxt.com/#/?$id=$order-structure $order structure~
             */
            Async\await($this->load_markets());
            $request = array( 'id' => $id );
            $response = Async\await($this->privatePostOrdersIdCancel (array_merge($request, $params)));
            //    {
            //        "id" => 10,
            //        "asset_pair_name" => "EOS-BTC",
            //        "price" => "10.00",
            //        "amount" => "10.00",
            //        "filled_amount" => "9.0",
            //        "avg_deal_price" => "12.0",
            //        "side" => "ASK",
            //        "state" => "CANCELLED",
            //        "created_at":"2019-01-29T06:05:56Z",
            //        "updated_at":"2019-01-29T06:05:56Z"
            //    }
            $order = $this->safe_value($response, 'data');
            return $this->parse_order($order);
        }) ();
    }

    public function cancel_all_orders(?string $symbol = null, $params = array ()) {
        return Async\async(function () use ($symbol, $params) {
            /**
             * cancel all open orders
             * @param {string} $symbol unified $market $symbol, only orders in the $market of this $symbol are cancelled when $symbol is not null
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array[]} a list of ~@link https://docs.ccxt.com/#/?id=order-structure order structures~
             */
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $request = array(
                'asset_pair_name' => $market['id'],
            );
            $response = Async\await($this->privatePostOrdersCancel (array_merge($request, $params)));
            //
            //     {
            //         "code":0,
            //         "data" => {
            //             "cancelled":array(
            //                 58272370,
            //                 58272377
            //             ),
            //             "failed" => array()
            //         }
            //     }
            //
            return $response;
        }) ();
    }

    public function fetch_order(string $id, ?string $symbol = null, $params = array ()) {
        return Async\async(function () use ($id, $symbol, $params) {
            /**
             * fetches information on an $order made by the user
             * @param {string} $symbol not used by bigone fetchOrder
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} An ~@link https://docs.ccxt.com/#/?$id=$order-structure $order structure~
             */
            Async\await($this->load_markets());
            $request = array( 'id' => $id );
            $response = Async\await($this->privateGetOrdersId (array_merge($request, $params)));
            $order = $this->safe_value($response, 'data', array());
            return $this->parse_order($order);
        }) ();
    }

    public function fetch_orders(?string $symbol = null, ?int $since = null, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            /**
             * fetches information on multiple $orders made by the user
             * @param {string} $symbol unified $market $symbol of the $market $orders were made in
             * @param {int} [$since] the earliest time in ms to fetch $orders for
             * @param {int} [$limit] the maximum number of order structures to retrieve
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {Order[]} a list of ~@link https://docs.ccxt.com/#/?id=order-structure order structures~
             */
            if ($symbol === null) {
                throw new ArgumentsRequired($this->id . ' fetchOrders() requires a $symbol argument');
            }
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $request = array(
                'asset_pair_name' => $market['id'],
                // 'page_token' => 'dxzef', // $request page after this page token
                // 'side' => 'ASK', // 'ASK' or 'BID', optional
                // 'state' => 'FILLED', // 'CANCELLED', 'FILLED', 'PENDING'
                // 'limit' 20, // default 20, max 200
            );
            if ($limit !== null) {
                $request['limit'] = $limit; // default 20, max 200
            }
            $response = Async\await($this->privateGetOrders (array_merge($request, $params)));
            //
            //    {
            //        "code":0,
            //        "data" => array(
            //             array(
            //                 "id" => 10,
            //                 "asset_pair_name" => "ETH-BTC",
            //                 "price" => "10.00",
            //                 "amount" => "10.00",
            //                 "filled_amount" => "9.0",
            //                 "avg_deal_price" => "12.0",
            //                 "side" => "ASK",
            //                 "state" => "FILLED",
            //                 "created_at":"2019-01-29T06:05:56Z",
            //                 "updated_at":"2019-01-29T06:05:56Z",
            //             ),
            //         ),
            //        "page_token":"dxzef",
            //    }
            //
            $orders = $this->safe_value($response, 'data', array());
            return $this->parse_orders($orders, $market, $since, $limit);
        }) ();
    }

    public function fetch_my_trades(?string $symbol = null, ?int $since = null, ?int $limit = null, $params = array ()) {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            /**
             * fetch all $trades made by the user
             * @param {string} $symbol unified $market $symbol
             * @param {int} [$since] the earliest time in ms to fetch $trades for
             * @param {int} [$limit] the maximum number of $trades structures to retrieve
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {Trade[]} a list of ~@link https://docs.ccxt.com/#/?id=trade-structure trade structures~
             */
            if ($symbol === null) {
                throw new ArgumentsRequired($this->id . ' fetchMyTrades() requires a $symbol argument');
            }
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $request = array(
                'asset_pair_name' => $market['id'],
                // 'page_token' => 'dxzef', // $request page after this page token
            );
            if ($limit !== null) {
                $request['limit'] = $limit; // default 20, max 200
            }
            $response = Async\await($this->privateGetTrades (array_merge($request, $params)));
            //
            //     {
            //         "code" => 0,
            //         "data" => array(
            //             array(
            //                 "id" => 10854280,
            //                 "asset_pair_name" => "XIN-USDT",
            //                 "price" => "70",
            //                 "amount" => "1",
            //                 "taker_side" => "ASK",
            //                 "maker_order_id" => 58284908,
            //                 "taker_order_id" => 58284909,
            //                 "maker_fee" => "0.0008",
            //                 "taker_fee" => "0.07",
            //                 "side" => "SELF_TRADING",
            //                 "inserted_at" => "2019-04-16T12:00:01Z"
            //             ),
            //             {
            //                 "id" => 10854263,
            //                 "asset_pair_name" => "XIN-USDT",
            //                 "price" => "75.7",
            //                 "amount" => "12.743149",
            //                 "taker_side" => "BID",
            //                 "maker_order_id" => null,
            //                 "taker_order_id" => 58284888,
            //                 "maker_fee" => null,
            //                 "taker_fee" => "0.0025486298",
            //                 "side" => "BID",
            //                 "inserted_at" => "2019-04-15T06:20:57Z"
            //             }
            //         ),
            //         "page_token":"dxfv"
            //     }
            //
            $trades = $this->safe_value($response, 'data', array());
            return $this->parse_trades($trades, $market, $since, $limit);
        }) ();
    }

    public function parse_order_status($status) {
        $statuses = array(
            'PENDING' => 'open',
            'FILLED' => 'closed',
            'CANCELLED' => 'canceled',
        );
        return $this->safe_string($statuses, $status);
    }

    public function fetch_open_orders(?string $symbol = null, ?int $since = null, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            /**
             * fetch all unfilled currently open orders
             * @param {string} $symbol unified market $symbol
             * @param {int} [$since] the earliest time in ms to fetch open orders for
             * @param {int} [$limit] the maximum number of  open orders structures to retrieve
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {Order[]} a list of ~@link https://docs.ccxt.com/#/?id=order-structure order structures~
             */
            $request = array(
                'state' => 'PENDING',
            );
            return Async\await($this->fetch_orders($symbol, $since, $limit, array_merge($request, $params)));
        }) ();
    }

    public function fetch_closed_orders(?string $symbol = null, ?int $since = null, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            /**
             * fetches information on multiple closed orders made by the user
             * @param {string} $symbol unified market $symbol of the market orders were made in
             * @param {int} [$since] the earliest time in ms to fetch orders for
             * @param {int} [$limit] the maximum number of order structures to retrieve
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {Order[]} a list of ~@link https://docs.ccxt.com/#/?id=order-structure order structures~
             */
            $request = array(
                'state' => 'FILLED',
            );
            return Async\await($this->fetch_orders($symbol, $since, $limit, array_merge($request, $params)));
        }) ();
    }

    public function nonce() {
        $exchangeTimeCorrection = $this->safe_integer($this->options, 'exchangeMillisecondsCorrection', 0) * 1000000;
        return $this->sum($this->microseconds() * 1000, $exchangeTimeCorrection);
    }

    public function sign($path, $api = 'public', $method = 'GET', $params = array (), $headers = null, $body = null) {
        $query = $this->omit($params, $this->extract_params($path));
        $baseUrl = $this->implode_hostname($this->urls['api'][$api]);
        $url = $baseUrl . '/' . $this->implode_params($path, $params);
        $headers = array();
        if ($api === 'public' || $api === 'webExchange' || $api === 'contractPublic') {
            if ($query) {
                $url .= '?' . $this->urlencode($query);
            }
        } else {
            $this->check_required_credentials();
            $nonce = (string) $this->nonce();
            $request = array(
                'type' => 'OpenAPIV2',
                'sub' => $this->apiKey,
                'nonce' => $nonce,
                // 'recv_window' => '30', // default 30
            );
            $token = $this->jwt($request, $this->encode($this->secret), 'sha256');
            $headers['Authorization'] = 'Bearer ' . $token;
            if ($method === 'GET') {
                if ($query) {
                    $url .= '?' . $this->urlencode($query);
                }
            } elseif ($method === 'POST') {
                $headers['Content-Type'] = 'application/json';
                $body = $query;
            }
        }
        $headers['User-Agent'] = 'ccxt/' . $this->id . '-' . $this->version;
        return array( 'url' => $url, 'method' => $method, 'body' => $body, 'headers' => $headers );
    }

    public function fetch_deposit_address(string $code, $params = array ()) {
        return Async\async(function () use ($code, $params) {
            /**
             * fetch the deposit $address for a $currency associated with this account
             * @param {string} $code unified $currency $code
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} an ~@link https://docs.ccxt.com/#/?id=$address-structure $address structure~
             */
            Async\await($this->load_markets());
            $currency = $this->currency($code);
            $request = array(
                'asset_symbol' => $currency['id'],
            );
            list($networkCode, $paramsOmitted) = $this->handle_network_code_and_params($params);
            $response = Async\await($this->privateGetAssetsAssetSymbolAddress (array_merge($request, $paramsOmitted)));
            //
            // the actual $response format is not the same documented one
            // the $data key contains an array in the actual $response
            //
            //     {
            //         "code":0,
            //         "message":"",
            //         "data":array(
            //             {
            //                 "id":5521878,
            //                 "chain":"Bitcoin",
            //                 "value":"1GbmyKoikhpiQVZ1C9sbF17mTyvBjeobVe",
            //                 "memo":""
            //             }
            //         )
            //     }
            //
            $data = $this->safe_value($response, 'data', array());
            $dataLength = count($data);
            if ($dataLength < 1) {
                throw new ExchangeError($this->id . ' fetchDepositAddress() returned empty $address response');
            }
            $chainsIndexedById = $this->index_by($data, 'chain');
            $selectedNetworkId = $this->select_network_id_from_raw_networks($code, $networkCode, $chainsIndexedById);
            $addressObject = $this->safe_value($chainsIndexedById, $selectedNetworkId, array());
            $address = $this->safe_string($addressObject, 'value');
            $tag = $this->safe_string($addressObject, 'memo');
            $this->check_address($address);
            return array(
                'currency' => $code,
                'address' => $address,
                'tag' => $tag,
                'network' => $this->network_id_to_code($selectedNetworkId),
                'info' => $response,
            );
        }) ();
    }

    public function parse_transaction_status($status) {
        $statuses = array(
            // what are other $statuses here?
            'WITHHOLD' => 'ok', // deposits
            'UNCONFIRMED' => 'pending',
            'CONFIRMED' => 'ok', // withdrawals
            'COMPLETED' => 'ok',
            'PENDING' => 'pending',
        );
        return $this->safe_string($statuses, $status, $status);
    }

    public function parse_transaction($transaction, ?array $currency = null): array {
        //
        // fetchDeposits
        //
        //     {
        //         "amount" => "25.0",
        //         "asset_symbol" => "BTS"
        //         "confirms" => 100,
        //         "id" => 5,
        //         "inserted_at" => "2018-02-16T11:39:58.000Z",
        //         "is_internal" => false,
        //         "kind" => "default",
        //         "memo" => "",
        //         "state" => "WITHHOLD",
        //         "txid" => "72e03037d144dae3d32b68b5045462b1049a0755",
        //         "updated_at" => "2018-11-09T10:20:09.000Z",
        //     }
        //
        // fetchWithdrawals
        //
        //     {
        //         "amount" => "5",
        //         "asset_symbol" => "ETH",
        //         "completed_at" => "2018-03-15T16:13:45.610463Z",
        //         "customer_id" => "10",
        //         "id" => 10,
        //         "inserted_at" => "2018-03-15T16:13:45.610463Z",
        //         "is_internal" => true,
        //         "note" => "2018-03-15T16:13:45.610463Z",
        //         "state" => "CONFIRMED",
        //         "target_address" => "0x4643bb6b393ac20a6175c713175734a72517c63d6f7"
        //         "txid" => "0x4643bb6b393ac20a6175c713175734a72517c63d6f73a3ca90a15356f2e967da0",
        //     }
        //
        // withdraw
        //
        //     {
        //         "id":1077391,
        //         "customer_id":1082679,
        //         "amount":"21.9000000000000000",
        //         "txid":"",
        //         "is_internal":false,
        //         "kind":"on_chain",
        //         "state":"PENDING",
        //         "inserted_at":"2020-06-03T00:50:57+00:00",
        //         "updated_at":"2020-06-03T00:50:57+00:00",
        //         "memo":"",
        //         "target_address":"rDYtYT3dBeuw376rvHqoZBKW3UmvguoBAf",
        //         "fee":"0.1000000000000000",
        //         "asset_symbol":"XRP"
        //     }
        //
        $currencyId = $this->safe_string($transaction, 'asset_symbol');
        $code = $this->safe_currency_code($currencyId);
        $id = $this->safe_string($transaction, 'id');
        $amount = $this->safe_number($transaction, 'amount');
        $status = $this->parse_transaction_status($this->safe_string($transaction, 'state'));
        $timestamp = $this->parse8601($this->safe_string($transaction, 'inserted_at'));
        $updated = $this->parse8601($this->safe_string_2($transaction, 'updated_at', 'completed_at'));
        $txid = $this->safe_string($transaction, 'txid');
        $address = $this->safe_string($transaction, 'target_address');
        $tag = $this->safe_string($transaction, 'memo');
        $type = (is_array($transaction) && array_key_exists('customer_id', $transaction)) ? 'withdrawal' : 'deposit';
        $internal = $this->safe_value($transaction, 'is_internal');
        return array(
            'info' => $transaction,
            'id' => $id,
            'txid' => $txid,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'network' => null,
            'addressFrom' => null,
            'address' => null,
            'addressTo' => $address,
            'tagFrom' => null,
            'tag' => $tag,
            'tagTo' => null,
            'type' => $type,
            'amount' => $amount,
            'currency' => $code,
            'status' => $status,
            'updated' => $updated,
            'fee' => null,
            'comment' => null,
            'internal' => $internal,
        );
    }

    public function fetch_deposits(?string $code = null, ?int $since = null, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($code, $since, $limit, $params) {
            /**
             * fetch all $deposits made to an account
             * @param {string} $code unified $currency $code
             * @param {int} [$since] the earliest time in ms to fetch $deposits for
             * @param {int} [$limit] the maximum number of $deposits structures to retrieve
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array[]} a list of ~@link https://docs.ccxt.com/#/?id=transaction-structure transaction structures~
             */
            Async\await($this->load_markets());
            $request = array(
                // 'page_token' => 'dxzef', // $request page after this page token
                // 'limit' => 50, // optional, default 50
                // 'kind' => 'string', // optional - air_drop, big_holder_dividend, default, eosc_to_eos, internal, equally_airdrop, referral_mining, one_holder_dividend, single_customer, snapshotted_airdrop, trade_mining
                // 'asset_symbol' => 'BTC', // optional
            );
            $currency = null;
            if ($code !== null) {
                $currency = $this->currency($code);
                $request['asset_symbol'] = $currency['id'];
            }
            if ($limit !== null) {
                $request['limit'] = $limit; // default 50
            }
            $response = Async\await($this->privateGetDeposits (array_merge($request, $params)));
            //
            //     {
            //         "code" => 0,
            //         "page_token" => "NQ==",
            //         "data" => array(
            //             {
            //                 "id" => 5,
            //                 "amount" => "25.0",
            //                 "confirms" => 100,
            //                 "txid" => "72e03037d144dae3d32b68b5045462b1049a0755",
            //                 "is_internal" => false,
            //                 "inserted_at" => "2018-02-16T11:39:58.000Z",
            //                 "updated_at" => "2018-11-09T10:20:09.000Z",
            //                 "kind" => "default",
            //                 "memo" => "",
            //                 "state" => "WITHHOLD",
            //                 "asset_symbol" => "BTS"
            //             }
            //         )
            //     }
            //
            $deposits = $this->safe_value($response, 'data', array());
            return $this->parse_transactions($deposits, $currency, $since, $limit);
        }) ();
    }

    public function fetch_withdrawals(?string $code = null, ?int $since = null, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($code, $since, $limit, $params) {
            /**
             * fetch all $withdrawals made from an account
             * @param {string} $code unified $currency $code
             * @param {int} [$since] the earliest time in ms to fetch $withdrawals for
             * @param {int} [$limit] the maximum number of $withdrawals structures to retrieve
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array[]} a list of ~@link https://docs.ccxt.com/#/?id=transaction-structure transaction structures~
             */
            Async\await($this->load_markets());
            $request = array(
                // 'page_token' => 'dxzef', // $request page after this page token
                // 'limit' => 50, // optional, default 50
                // 'kind' => 'string', // optional - air_drop, big_holder_dividend, default, eosc_to_eos, internal, equally_airdrop, referral_mining, one_holder_dividend, single_customer, snapshotted_airdrop, trade_mining
                // 'asset_symbol' => 'BTC', // optional
            );
            $currency = null;
            if ($code !== null) {
                $currency = $this->currency($code);
                $request['asset_symbol'] = $currency['id'];
            }
            if ($limit !== null) {
                $request['limit'] = $limit; // default 50
            }
            $response = Async\await($this->privateGetWithdrawals (array_merge($request, $params)));
            //
            //     {
            //         "code" => 0,
            //         "data" => array(
            //             {
            //                 "id" => 10,
            //                 "customer_id" => "10",
            //                 "asset_symbol" => "ETH",
            //                 "amount" => "5",
            //                 "state" => "CONFIRMED",
            //                 "note" => "2018-03-15T16:13:45.610463Z",
            //                 "txid" => "0x4643bb6b393ac20a6175c713175734a72517c63d6f73a3ca90a15356f2e967da0",
            //                 "completed_at" => "2018-03-15T16:13:45.610463Z",
            //                 "inserted_at" => "2018-03-15T16:13:45.610463Z",
            //                 "is_internal" => true,
            //                 "target_address" => "0x4643bb6b393ac20a6175c713175734a72517c63d6f7"
            //             }
            //         ),
            //         "page_token":"dxvf"
            //     }
            //
            $withdrawals = $this->safe_value($response, 'data', array());
            return $this->parse_transactions($withdrawals, $currency, $since, $limit);
        }) ();
    }

    public function transfer(string $code, $amount, $fromAccount, $toAccount, $params = array ()) {
        return Async\async(function () use ($code, $amount, $fromAccount, $toAccount, $params) {
            /**
             * $transfer $currency internally between wallets on the same account
             * @see https://open.big.one/docs/spot_transfer.html#$transfer-of-user
             * @param {string} $code unified $currency $code
             * @param {float} $amount amount to $transfer
             * @param {string} $fromAccount 'SPOT', 'FUND', or 'CONTRACT'
             * @param {string} $toAccount 'SPOT', 'FUND', or 'CONTRACT'
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} a ~@link https://docs.ccxt.com/#/?id=$transfer-structure $transfer structure~
             */
            Async\await($this->load_markets());
            $currency = $this->currency($code);
            $accountsByType = $this->safe_value($this->options, 'accountsByType', array());
            $fromId = $this->safe_string($accountsByType, $fromAccount, $fromAccount);
            $toId = $this->safe_string($accountsByType, $toAccount, $toAccount);
            $guid = $this->safe_string($params, 'guid', $this->uuid());
            $request = array(
                'symbol' => $currency['id'],
                'amount' => $this->currency_to_precision($code, $amount),
                'from' => $fromId,
                'to' => $toId,
                'guid' => $guid,
                // 'type' => type, // NORMAL, MASTER_TO_SUB, SUB_TO_MASTER, SUB_INTERNAL, default is NORMAL
                // 'sub_acccunt' => '', // when type is NORMAL, it should be empty, and when type is others it is required
            );
            $response = Async\await($this->privatePostTransfer (array_merge($request, $params)));
            //
            //     {
            //         "code" => 0,
            //         "data" => null
            //     }
            //
            $transfer = $this->parse_transfer($response, $currency);
            $transferOptions = $this->safe_value($this->options, 'transfer', array());
            $fillResponseFromRequest = $this->safe_value($transferOptions, 'fillResponseFromRequest', true);
            if ($fillResponseFromRequest) {
                $transfer['fromAccount'] = $fromAccount;
                $transfer['toAccount'] = $toAccount;
                $transfer['amount'] = $amount;
                $transfer['id'] = $guid;
            }
            return $transfer;
        }) ();
    }

    public function parse_transfer($transfer, ?array $currency = null) {
        //
        //     {
        //         "code" => 0,
        //         "data" => null
        //     }
        //
        $code = $this->safe_number($transfer, 'code');
        return array(
            'info' => $transfer,
            'id' => null,
            'timestamp' => null,
            'datetime' => null,
            'currency' => $code,
            'amount' => null,
            'fromAccount' => null,
            'toAccount' => null,
            'status' => $this->parse_transfer_status($code),
        );
    }

    public function parse_transfer_status($status) {
        $statuses = array(
            '0' => 'ok',
        );
        return $this->safe_string($statuses, $status, 'failed');
    }

    public function withdraw(string $code, $amount, $address, $tag = null, $params = array ()) {
        return Async\async(function () use ($code, $amount, $address, $tag, $params) {
            /**
             * make a withdrawal
             * @param {string} $code unified $currency $code
             * @param {float} $amount the $amount to withdraw
             * @param {string} $address the $address to withdraw to
             * @param {string} $tag
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} a ~@link https://docs.ccxt.com/#/?id=transaction-structure transaction structure~
             */
            list($tag, $params) = $this->handle_withdraw_tag_and_params($tag, $params);
            Async\await($this->load_markets());
            $currency = $this->currency($code);
            $request = array(
                'symbol' => $currency['id'],
                'target_address' => $address,
                'amount' => $this->currency_to_precision($code, $amount),
            );
            if ($tag !== null) {
                $request['memo'] = $tag;
            }
            $networkCode = null;
            list($networkCode, $params) = $this->handle_network_code_and_params($params);
            if ($networkCode !== null) {
                $request['gateway_name'] = $this->network_code_to_id($networkCode);
            }
            // requires write permission on the wallet
            $response = Async\await($this->privatePostWithdrawals (array_merge($request, $params)));
            //
            //     {
            //         "code":0,
            //         "message":"",
            //         "data":{
            //             "id":1077391,
            //             "customer_id":1082679,
            //             "amount":"21.9000000000000000",
            //             "txid":"",
            //             "is_internal":false,
            //             "kind":"on_chain",
            //             "state":"PENDING",
            //             "inserted_at":"2020-06-03T00:50:57+00:00",
            //             "updated_at":"2020-06-03T00:50:57+00:00",
            //             "memo":"",
            //             "target_address":"rDYtYT3dBeuw376rvHqoZBKW3UmvguoBAf",
            //             "fee":"0.1000000000000000",
            //             "asset_symbol":"XRP"
            //         }
            //     }
            //
            $data = $this->safe_value($response, 'data', array());
            return $this->parse_transaction($data, $currency);
        }) ();
    }

    public function handle_errors($httpCode, $reason, $url, $method, $headers, $body, $response, $requestHeaders, $requestBody) {
        if ($response === null) {
            return null; // fallback to default error handler
        }
        //
        //      array("code":10013,"message":"Resource not found")
        //      array("code":40004,"message":"invalid jwt")
        //
        $code = $this->safe_string($response, 'code');
        $message = $this->safe_string($response, 'message');
        if (($code !== '0') && ($code !== null)) {
            $feedback = $this->id . ' ' . $body;
            $this->throw_exactly_matched_exception($this->exceptions['exact'], $message, $feedback);
            $this->throw_exactly_matched_exception($this->exceptions['exact'], $code, $feedback);
            $this->throw_broadly_matched_exception($this->exceptions['broad'], $message, $feedback);
            throw new ExchangeError($feedback); // unknown $message
        }
        return null;
    }
}
