<?php

namespace ccxt\async;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

use Exception; // a common import
use ccxt\async\abstract\astralx as Exchange;
use ccxt\ExchangeError;
use ccxt\ArgumentsRequired;
use ccxt\Precise;
use \React\Async;
use \React\Promise\PromiseInterface;

class astralx extends Exchange {

    public function describe(): mixed {
        return $this->deep_extend(parent::describe(), array(
            'id' => 'astralx',
            'name' => 'Astralx',
            'countries' => array( 'SG' ),
            'rateLimit' => 100,
            'pro' => false,
            'timezone' => 'UTC',
            'has' => array(
                'CORS' => null,
                'spot' => false,
                'margin' => false,
                'swap' => true,
                'future' => false,
                'option' => false,
                'addMargin' => false,
                'cancelAllOrders' => true,
                'cancelOrder' => true,
                'cancelOrders' => true,
                'createOrder' => true,
                'createStopLimitOrder' => false,
                'createStopMarketOrder' => false,
                'createStopOrder' => false,
                'editOrder' => false,
                'fetchBalance' => true,
                'fetchBorrowInterest' => false,
                'fetchBorrowRateHistories' => false,
                'fetchBorrowRateHistory' => false,
                'fetchClosedOrders' => true,
                'fetchCrossBorrowRate' => false,
                'fetchCrossBorrowRates' => false,
                'fetchDepositAddress' => false,
                'fetchDeposits' => false,
                'fetchFundingHistory' => true,
                'fetchFundingRate' => true,
                'fetchFundingRateHistory' => true,
                'fetchFundingRates' => false,
                'fetchIndexOHLCV' => false,
                'fetchIsolatedBorrowRate' => false,
                'fetchIsolatedBorrowRates' => false,
                'fetchLeverage' => true,
                'fetchLeverageTiers' => true,
                'fetchMarkets' => true,
                'fetchMarkOHLCV' => false,
                'fetchMyTrades' => true,
                'fetchOHLCV' => true,
                'fetchOpenInterest' => true,
                'fetchOpenInterestHistory' => false,
                'fetchOpenOrders' => true,
                'fetchOrder' => true,
                'fetchOrderBook' => true,
                'fetchOrders' => true,
                'fetchPosition' => true,
                'fetchPositionHistory' => true,
                'fetchPositions' => true,
                'fetchPremiumIndexOHLCV' => false,
                'fetchTicker' => true,
                'fetchTickers' => false,
                'fetchTrades' => true,
                'fetchTradingFee' => false,
                'fetchTradingFees' => false,
                'fetchTransfer' => true,
                'fetchTransfers' => false,
                'fetchWithdrawals' => false,
                'reduceMargin' => false,
                'setLeverage' => true,
                'setMarginMode' => false,
                'setPositionMode' => false,
                'transfer' => false,
                'withdraw' => false,
            ),
            'urls' => array(
                'logo' => 'https://user-images.githubusercontent.com/1294454/000000000-0000000000000000000000000000000000000000000000000000000000000000.png',
                'api' => array(
                    'public' => 'https://www.astralx.com',
                    'private' => 'https://www.astralx.com',
                ),
                'www' => 'https://www.astralx.com',
                'doc' => array(
                    'https://docs.astralx.com',
                ),
                'fees' => 'https://www.astralx.com/fees',
            ),
            'timeframes' => array(
                '1m' => '1m',
                '3m' => '3m',
                '5m' => '5m',
                '15m' => '15m',
                '30m' => '30m',
                '1h' => '1h',
                '2h' => '2h',
                '4h' => '4h',
                '6h' => '6h',
                '12h' => '12h',
                '1d' => '1d',
                '1w' => '1w',
                '1M' => '1M',
            ),
            'api' => array(
                'public' => array(
                    'get' => array(
                        'openapi/time' => 1,
                        'openapi/symbol' => 1,
                        'openapi/quote/depth' => 1,
                        'openapi/quote/trades' => 1,
                        'openapi/quote/ticker' => 1,
                        'openapi/quote/klines' => 1,
                        'openapi/contract/fundingRate' => 1,
                        'openapi/contract/fundingRate/history' => 1,
                        'openapi/quote/openInterest' => 1,
                        'openapi/quote/indexPrice' => 1,
                        'openapi/quote/markPrice' => 1,
                        'openapi/quote/riskLimit' => 1,
                        'openapi/quote/insurance' => 1,
                        'openapi/quote/liquidationOrders' => 1,
                    ),
                ),
                'private' => array(
                    'get' => array(
                        'openapi/contract/account' => 1,
                        'openapi/contract/order' => 1,
                        'openapi/contract/openOrders' => 1,
                        'openapi/contract/order/history' => 1,
                        'openapi/contract/myTrades' => 1,
                        'openapi/contract/positions' => 1,
                        'openapi/contract/position/history' => 1,
                        'openapi/contract/asset' => 1,
                        'openapi/contract/transfer' => 1,
                        'openapi/contract/income' => 1,
                        'openapi/contract/leverage' => 1,
                        'openapi/contract/forceOrders' => 1,
                        'openapi/contract/adlQuantile' => 1,
                    ),
                    'post' => array(
                        'openapi/contract/order' => 1,
                        'openapi/contract/batchOrders' => 1,
                        'openapi/contract/leverage' => 1,
                        'openapi/contract/position/margin' => 1,
                        'openapi/contract/position/riskLimit' => 1,
                    ),
                    'delete' => array(
                        'openapi/contract/order/cancel' => 1,
                        'openapi/contract/batchOrders' => 1,
                        'openapi/contract/allOpenOrders' => 1,
                    ),
                ),
            ),
            'fees' => array(
                'trading' => array(
                    'tierBased' => false,
                    'percentage' => true,
                    'taker' => $this->parse_number('0.0006'),
                    'maker' => $this->parse_number('0.0002'),
                ),
            ),
            'requiredCredentials' => array(
                'apiKey' => true,
                'secret' => true,
            ),
            'precisionMode' => TICK_SIZE,
            'exceptions' => array(
                'exact' => array(),
                'broad' => array(),
            ),
            'options' => array(
                'defaultType' => 'swap', // 'swap' for USD-M perpetual contracts
            ),
            'features' => array(
                'swap' => array(
                    'linear' => array(
                        'sandbox' => false,
                        'createOrder' => array(
                            'marginMode' => false,
                            'triggerPrice' => false,
                            'triggerPriceType' => array(
                                'mark' => false,
                                'last' => false,
                                'index' => false,
                            ),
                            'stopLossPrice' => false,
                            'takeProfitPrice' => false,
                            'attachedStopLossTakeProfit' => array(
                                'triggerPriceType' => array(
                                    'last' => false,
                                    'mark' => false,
                                    'index' => false,
                                ),
                                'price' => false,
                            ),
                            'timeInForce' => array(
                                'GTC' => false,
                                'IOC' => false,
                                'FOK' => false,
                                'PO' => false,
                                'GTD' => false,
                            ),
                            'hedged' => false,
                            'trailing' => false,
                        ),
                        'createOrders' => array(
                            'max' => 5,
                        ),
                        'fetchMyTrades' => array(
                            'marginMode' => false,
                            'daysBack' => 0,
                            'limit' => 0,
                            'untilDays' => 0,
                            'symbolRequired' => false,
                        ),
                        'fetchOrder' => array(
                            'marginMode' => false,
                            'trigger' => false,
                            'trailing' => false,
                            'symbolRequired' => false,
                        ),
                        'fetchOpenOrders' => array(
                            'marginMode' => false,
                            'limit' => 0,
                            'trigger' => false,
                            'trailing' => false,
                            'symbolRequired' => false,
                        ),
                        'fetchOrders' => array(
                            'marginMode' => false,
                            'limit' => 0,
                            'daysBack' => 0,
                            'untilDays' => 0,
                            'trigger' => false,
                            'trailing' => false,
                            'symbolRequired' => false,
                        ),
                        'fetchClosedOrders' => array(
                            'marginMode' => false,
                            'limit' => 0,
                            'daysBack' => 0,
                            'daysBackCanceled' => 0,
                            'untilDays' => 0,
                            'trigger' => false,
                            'trailing' => false,
                            'symbolRequired' => false,
                        ),
                        'fetchOHLCV' => array(
                            'limit' => 0,
                        ),
                    ),
                    'inverse' => array(
                        'sandbox' => false,
                        'createOrder' => array(
                            'marginMode' => false,
                            'triggerPrice' => false,
                            'triggerPriceType' => array(
                                'mark' => false,
                                'last' => false,
                                'index' => false,
                            ),
                            'stopLossPrice' => false,
                            'takeProfitPrice' => false,
                            'attachedStopLossTakeProfit' => array(
                                'triggerPriceType' => array(
                                    'last' => false,
                                    'mark' => false,
                                    'index' => false,
                                ),
                                'price' => false,
                            ),
                            'timeInForce' => array(
                                'GTC' => false,
                                'IOC' => false,
                                'FOK' => false,
                                'PO' => false,
                                'GTD' => false,
                            ),
                            'hedged' => false,
                            'trailing' => false,
                        ),
                        'createOrders' => array(
                            'max' => 5,
                        ),
                        'fetchMyTrades' => array(
                            'marginMode' => false,
                            'daysBack' => 0,
                            'limit' => 0,
                            'untilDays' => 0,
                            'symbolRequired' => false,
                        ),
                        'fetchOrder' => array(
                            'marginMode' => false,
                            'trigger' => false,
                            'trailing' => false,
                            'symbolRequired' => false,
                        ),
                        'fetchOpenOrders' => array(
                            'marginMode' => false,
                            'limit' => 0,
                            'trigger' => false,
                            'trailing' => false,
                            'symbolRequired' => false,
                        ),
                        'fetchOrders' => array(
                            'marginMode' => false,
                            'limit' => 0,
                            'daysBack' => 0,
                            'untilDays' => 0,
                            'trigger' => false,
                            'trailing' => false,
                            'symbolRequired' => false,
                        ),
                        'fetchClosedOrders' => array(
                            'marginMode' => false,
                            'limit' => 0,
                            'daysBack' => 0,
                            'daysBackCanceled' => 0,
                            'untilDays' => 0,
                            'trigger' => false,
                            'trailing' => false,
                            'symbolRequired' => false,
                        ),
                        'fetchOHLCV' => array(
                            'limit' => 0,
                        ),
                    ),
                ),
            ),
        ));
    }

    public function fetch_markets($params = array ()): PromiseInterface {
        return Async\async(function () use ($params) {
            /**
             * retrieves data on all $markets for astralx
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {Market[]} an array of objects representing $market data
             */
            $response = Async\await($this->publicGetOpenapiSymbol ($params));
            // API直接返回数组，没有'data'字段
            $markets = $response;
            $result = array();
            for ($i = 0; $i < count($markets); $i++) {
                $market = $markets[$i];
                $category = $this->safe_integer($market, 'category');
                // 根据API文档，只处理$category=4的swap类型市场
                if ($category !== 4) {
                    continue;
                }
                $id = $this->safe_string($market, 'symbolId');
                $baseId = $this->safe_string($market, 'baseTokenId');
                $quoteId = $this->safe_string($market, 'quoteTokenId');
                // 对于永续合约市场（$category=4），使用$tokenFutures->displayUnderlyingId作为baseTokenId
                $tokenFutures = $this->safe_dict($market, 'tokenFutures');
                if ($tokenFutures !== null) {
                    $displayUnderlyingId = $this->safe_string($tokenFutures, 'displayUnderlyingId');
                    if ($displayUnderlyingId !== null) {
                        $baseId = $displayUnderlyingId;
                    }
                }
                $base = $this->safe_currency_code($baseId);
                $quote = $this->safe_currency_code($quoteId);
                $symbol = $base . '/' . $quote . ':' . $quote;
                $active = $this->safe_value($market, 'canTrade') === true;
                // 获取$tokenFutures中的合约相关信息
                $contractSize = 1; // 默认值
                $maxLeverage = null;
                $minLeverage = null;
                $leverageLimits = null;
                if ($tokenFutures !== null) {
                    $contractSize = $this->safe_number($tokenFutures, 'contractMultiplier', 1);
                    $maxLeverage = $this->safe_number($tokenFutures, 'maxLeverage');
                    // 处理杠杆范围
                    $levers = $this->safe_value($tokenFutures, 'levers', array());
                    if (strlen($levers) > 0) {
                        $minLever = null;
                        $maxLever = null;
                        for ($j = 0; $j < count($levers); $j++) {
                            $lever = $this->safe_number($levers, $j);
                            if ($lever !== null) {
                                if ($minLever === null || $lever < $minLever) {
                                    $minLever = $lever;
                                }
                                if ($maxLever === null || $lever > $maxLever) {
                                    $maxLever = $lever;
                                }
                            }
                        }
                        if ($minLever !== null && $maxLever !== null) {
                            $minLeverage = $minLever;
                            $maxLeverage = $maxLever;
                            $leverageLimits = array(
                                'min' => $minLeverage,
                                'max' => $maxLeverage,
                            );
                        }
                    }
                }
                $result[] = array(
                    'id' => $id,
                    'symbol' => $symbol,
                    'base' => $base,
                    'quote' => $quote,
                    'baseId' => $baseId,
                    'quoteId' => $quoteId,
                    'active' => $active,
                    'type' => 'swap',
                    'spot' => false,
                    'margin' => false,
                    'swap' => true,
                    'future' => false,
                    'option' => false,
                    'contract' => true,
                    'settle' => $quote,
                    'settleId' => $quoteId,
                    'contractSize' => $contractSize, // 使用API返回的contractMultiplier
                    'linear' => true,
                    'inverse' => false,
                    'taker' => $this->parse_number('0.0006'), // 使用默认费率
                    'maker' => $this->parse_number('0.0002'), // 使用默认费率
                    'percentage' => true,
                    'tierBased' => false,
                    'maxLeverage' => $maxLeverage, // 添加最大杠杆信息
                    'limits' => array(
                        'amount' => array(
                            'min' => $this->safe_number($market, 'minTradeQuantity') * $contractSize,
                            'max' => null,
                        ),
                        'price' => array(
                            'min' => $this->safe_number($market, 'minPricePrecision'),
                            'max' => null,
                        ),
                        'cost' => array(
                            'min' => $this->safe_number($market, 'minTradeAmount'),
                            'max' => null,
                        ),
                        'leverage' => $leverageLimits,
                    ),
                    'precision' => array(
                        'amount' => $this->safe_number($market, 'basePrecision') * $contractSize,
                        'price' => $this->safe_number($market, 'quotePrecision'),
                        'cost' => null,
                        'base' => null,
                        'quote' => null,
                    ),
                    'info' => $market,
                );
            }
            return $result;
        }) ();
    }

    public function fetch_ticker(string $symbol, $params = array ()) {
        return Async\async(function () use ($symbol, $params) {
            /**
             * fetches a price $ticker for a trading $symbol
             * @param {string} $symbol unified $symbol of the $market to fetch the $ticker for
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} a ~@link https://docs.ccxt.com/#/?id=$ticker-structure $ticker structure~
             */
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $response = Async\await($this->publicGetOpenapiQuoteTicker ($params));
            // 根据API测试结果，响应是一个对象，键为交易对ID
            // 需要将市场ID转换为API使用的格式（如AAVEUSDT_PERP -> AAVE_USDT）
            $marketIdForTicker = $market['id'];
            // 如果市场ID包含_PERP后缀，需要转换为下划线格式
            if (str_ends_with($marketIdForTicker, '_PERP')) {
                $baseSymbol = str_replace('_PERP', '', $marketIdForTicker);
                // 将AAVEUSDT格式转换为AAVE_USDT格式
                if (strlen($baseSymbol) > 3) {
                    $quoteCurrency = mb_substr($baseSymbol, -4); // 取最后4个字符（USDT）
                    $baseCurrency = mb_substr($baseSymbol, 0, -4 - 0); // 取除了USDT之外的部分
                    $marketIdForTicker = $baseCurrency . '_' . $quoteCurrency;
                }
            }
            $ticker = $this->safe_value($response, $marketIdForTicker, array());
            return $this->parse_ticker($ticker, $market);
        }) ();
    }

    public function parse_ticker($ticker, $market = null) {
        /**
         * parses a $ticker structure from the exchange response
         * @param {array} $ticker the $ticker data from the exchange
         * @param {array} [$market] the $market to which the $ticker belongs
         * @return {array} a ~@link https://docs.ccxt.com/#/?id=$ticker-structure $ticker structure~
         */
        // 使用当前时间作为时间戳，因为API返回的数据中可能没有时间戳
        $timestamp = $this->milliseconds();
        $marketId = $this->safe_string($ticker, 'symbol');
        $symbol = $this->safe_symbol($marketId, $market);
        $last = $this->safe_number($ticker, 'lastPrice');
        // 根据API测试结果，$ticker数据只包含lastPrice、$baseVolume、$quoteVolume
        // 其他字段如open、high、low、bid、ask等可能不存在
        $baseVolume = $this->safe_number($ticker, 'baseVolume');
        $quoteVolume = $this->safe_number($ticker, 'quoteVolume');
        return $this->safe_ticker(array(
            'symbol' => $symbol,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'high' => null, // API可能不提供最高价
            'low' => null,   // API可能不提供最低价
            'bid' => null,   // API可能不提供买价
            'bidVolume' => null,
            'ask' => null,   // API可能不提供卖价
            'askVolume' => null,
            'vwap' => null,
            'open' => null, // API可能不提供开盘价
            'close' => $last,
            'last' => $last,
            'previousClose' => null,
            'change' => null, // 由于缺少开盘价，无法计算涨跌
            'percentage' => null,
            'average' => null,
            'baseVolume' => $baseVolume,
            'quoteVolume' => $quoteVolume,
            'info' => $ticker,
        ), $market);
    }

    public function fetch_order_book(string $symbol, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $limit, $params) {
            /**
             * fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
             * @param {string} $symbol unified $symbol of the $market to fetch the order book for
             * @param {int} [$limit] the maximum amount of order book entries to return
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {OrderBook} A dictionary of ~@link https://docs.ccxt.com/#/?id=order-book-structure order book structures~ indexed by $market symbols
             */
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $request = array(
                'symbol' => $market['id'],
            );
            if ($limit !== null) {
                $request['limit'] = $limit;
            }
            $response = Async\await($this->publicGetOpenapiQuoteDepth ($this->extend($request, $params)));
            $timestamp = $this->safe_integer($response, 'time');
            return $this->parse_order_book($response, $symbol, $timestamp, 'bids', 'asks', 0, 1);
        }) ();
    }

    public function fetch_ohlcv(string $symbol, $timeframe = '1m', ?int $since = null, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $timeframe, $since, $limit, $params) {
            /**
             * fetches historical candlestick data containing the open, high, low, and close price, and the volume of a $market
             * @param {string} $symbol unified $symbol of the $market to fetch OHLCV data for
             * @param {string} $timeframe the length of time each candle represents
             * @param {int} [$since] timestamp in ms of the earliest candle to fetch
             * @param {int} [$limit] the maximum amount of candles to fetch
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {OHLCV[]} A list of candles ordered, open, high, low, close, volume
             */
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $request = array(
                'symbol' => $market['id'],
                'interval' => $this->timeframes[$timeframe],
            );
            if ($since !== null) {
                $request['startTime'] = $since;
            }
            if ($limit !== null) {
                $request['limit'] = $limit;
            }
            $response = Async\await($this->publicGetOpenapiQuoteKlines ($this->extend($request, $params)));
            // API直接返回K线数据数组，不需要额外的处理
            return $this->parse_ohlcvs($response, $market, $timeframe, $since, $limit);
        }) ();
    }

    public function parse_ohlcv($ohlcv, ?array $market = null): array {
        /**
         * parses OHLCV data from the exchange response
         * @param {number[]} $ohlcv the OHLCV data from the exchange
         * @param {array} [$market] the $market to which the OHLCV data belongs
         * @return {number[]} [timestamp, open, high, low, close, volume]
         */
        return array(
            $this->safe_integer($ohlcv, 0),
            $this->safe_number($ohlcv, 1),
            $this->safe_number($ohlcv, 2),
            $this->safe_number($ohlcv, 3),
            $this->safe_number($ohlcv, 4),
            $this->safe_number($ohlcv, 5),
        );
    }

    public function fetch_time($params = array ()) {
        return Async\async(function () use ($params) {
            /**
             * fetches the current integer timestamp in milliseconds from the exchange server
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {int} the current integer timestamp in milliseconds from the exchange server
             */
            $response = Async\await($this->publicGetOpenapiTime ($params));
            return $this->safe_integer($response, 'serverTime');
        }) ();
    }

    public function fetch_funding_rate(string $symbol, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $params) {
            /**
             * fetches the current funding rate
             * @param {string} $symbol unified $symbol of the $market to fetch the funding rate for
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} a ~@link https://docs.ccxt.com/#/?id=funding-rate-structure funding rate structure~
             */
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $request = array(
                'symbol' => $market['id'],
            );
            $response = Async\await($this->publicGetOpenapiContractFundingRate ($this->extend($request, $params)));
            // API直接返回资金费率数组，取第一个元素
            $fundingRateData = $this->safe_value($response, 0, array());
            return $this->parse_funding_rate($fundingRateData, $market);
        }) ();
    }

    public function parse_funding_rate($contract, $market = null) {
        /**
         * parses a funding rate structure from the exchange response
         * @param {array} $contract the funding rate data from the exchange
         * @param {array} [$market] the $market to which the funding rate belongs
         * @return {array} a ~@link https://docs.ccxt.com/#/?id=funding-rate-structure funding rate structure~
         */
        $marketId = $this->safe_string($contract, 'symbol');
        $symbol = $this->safe_symbol($marketId, $market);
        $fundingRate = $this->safe_number($contract, 'rate'); // API返回的是rate字段
        $intervalStart = $this->safe_integer($contract, 'intervalStart');
        $intervalEnd = $this->safe_integer($contract, 'intervalEnd');
        // 使用$intervalEnd作为$fundingTimestamp，$intervalStart作为$previousFundingTimestamp
        $fundingTimestamp = $intervalEnd;
        $previousFundingTimestamp = $intervalStart;
        $nextFundingTimestamp = $intervalEnd ? $intervalEnd . ($intervalEnd - $intervalStart) : null;
        // 处理None值的时间戳
        $fundingDatetime = null;
        $previousFundingDatetime = null;
        $nextFundingDatetime = null;
        if ($fundingTimestamp !== null) {
            $fundingDatetime = $this->iso8601($fundingTimestamp);
        }
        if ($previousFundingTimestamp !== null) {
            $previousFundingDatetime = $this->iso8601($previousFundingTimestamp);
        }
        if ($nextFundingTimestamp !== null) {
            $nextFundingDatetime = $this->iso8601($nextFundingTimestamp);
        }
        return array(
            'info' => $contract,
            'symbol' => $symbol,
            'markPrice' => null, // API没有提供标记价格
            'indexPrice' => null, // API没有提供指数价格
            'interestRate' => null,
            'estimatedSettlePrice' => null,
            'timestamp' => $fundingTimestamp,
            'datetime' => $fundingDatetime,
            'fundingRate' => $fundingRate,
            'fundingTimestamp' => $fundingTimestamp,
            'fundingDatetime' => $fundingDatetime,
            'nextFundingRate' => null,
            'nextFundingTimestamp' => $nextFundingTimestamp,
            'nextFundingDatetime' => $nextFundingDatetime,
            'previousFundingRate' => $fundingRate, // 假设前一个资金费率相同
            'previousFundingTimestamp' => $previousFundingTimestamp,
            'previousFundingDatetime' => $previousFundingDatetime,
        );
    }

    public function fetch_trades(string $symbol, ?int $since = null, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            /**
             * get the list of most recent trades for a particular $symbol
             * @param {string} $symbol unified $symbol of the $market to fetch trades for
             * @param {int} [$since] timestamp in ms of the earliest trade to fetch
             * @param {int} [$limit] the maximum amount of trades to fetch
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {Trade[]} a list of ~@link https://docs.ccxt.com/#/?id=public-trades trade structures~
             */
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $request = array(
                'symbol' => $market['id'],
            );
            if ($limit !== null) {
                $request['limit'] = $limit;
            }
            $response = Async\await($this->publicGetOpenapiQuoteTrades ($this->extend($request, $params)));
            return $this->parse_trades($response, $market, $since, $limit);
        }) ();
    }

    public function parse_trade($trade, $market = null) {
        /**
         * parses a $trade structure from the exchange response
         * @param {array} $trade the $trade data from the exchange
         * @param {array} [$market] the $market to which the $trade belongs
         * @return {array} a ~@link https://docs.ccxt.com/#/?$id=public-trades $trade structure~
         */
        $timestamp = $this->safe_integer($trade, 'time');
        // 处理不同的$marketId字段名
        $marketId = $this->safe_string_2($trade, 'symbolId', 'symbol');
        $symbol = $this->safe_symbol($marketId, $market);
        // 处理不同的tradeId字段名
        $id = $this->safe_string_2($trade, 'tradeId', 'id');
        $orderId = $this->safe_string($trade, 'orderId');
        $priceString = $this->safe_string($trade, 'price');
        // 处理不同的数量字段名
        $amountString = $this->safe_string_2($trade, 'quantity', 'qty');
        $price = $this->parse_number($priceString);
        $amount = $this->parse_number($amountString);
        $cost = $this->parse_number(Precise::string_mul($priceString, $amountString));
        // 处理方向信息
        $side = $this->safe_string($trade, 'side');
        if ($side === 'BUY_OPEN' || $side === 'BUY_CLOSE') {
            $side = 'buy';
        } elseif ($side === 'SELL_OPEN' || $side === 'SELL_CLOSE') {
            $side = 'sell';
        } elseif ($side === null) {
            // 公共交易接口可能使用$isBuyerMaker字段
            $isBuyerMaker = $this->safe_value($trade, 'isBuyerMaker');
            if ($isBuyerMaker !== null) {
                $side = $isBuyerMaker ? 'sell' : 'buy';
            }
        }
        $takerOrMaker = null; // API响应中没有maker/taker信息
        // 处理手续费信息
        $fee = null;
        $feeCost = $this->safe_number_2($trade, 'fee', 'commission');
        if ($feeCost !== null) {
            $feeCurrencyId = $this->safe_string_2($trade, 'feeTokenId', 'commissionAsset');
            $feeCurrencyCode = $this->safe_currency_code($feeCurrencyId);
            $fee = array(
                'cost' => $feeCost,
                'currency' => $feeCurrencyCode,
            );
        }
        return $this->safe_trade(array(
            'info' => $trade,
            'id' => $id,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'symbol' => $symbol,
            'order' => $orderId,
            'type' => $this->safe_string_2($trade, 'orderType', 'type'),
            'side' => $side,
            'takerOrMaker' => $takerOrMaker,
            'price' => $price,
            'amount' => $amount,
            'cost' => $cost,
            'fee' => $fee,
        ), $market);
    }

    public function fetch_currencies($params = array ()): PromiseInterface {
        return Async\async(function () use ($params) {
            /**
             * fetches all available $currencies on an exchange
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} an associative dictionary of $currencies
             */
            Async\await($this->load_markets());
            $response = Async\await($this->publicGetOpenapiSymbol ($params));
            $currencies = array();
            for ($i = 0; $i < count($response); $i++) {
                $market = $response[$i];
                $category = $this->safe_integer($market, 'category');
                // 根据API文档，只处理$category=4的swap类型市场
                if ($category !== 4) {
                    continue;
                }
                $baseId = $this->safe_string($market, 'baseTokenId');
                $quoteId = $this->safe_string($market, 'quoteTokenId');
                // 对于永续合约市场（$category=4），使用$tokenFutures->displayUnderlyingId作为baseTokenId
                $tokenFutures = $this->safe_dict($market, 'tokenFutures');
                if ($tokenFutures !== null) {
                    $displayUnderlyingId = $this->safe_string($tokenFutures, 'displayUnderlyingId');
                    if ($displayUnderlyingId !== null) {
                        $baseId = $displayUnderlyingId;
                    }
                }
                if ($baseId !== null && !(is_array($currencies) && array_key_exists($baseId, $currencies))) {
                    $code = $this->safe_currency_code($baseId);
                    $currencies[$baseId] = array(
                        'id' => $baseId,
                        'code' => $code,
                        'name' => $baseId,
                        'active' => true,
                        'fee' => null,
                        'precision' => null,
                        'limits' => array(
                            'amount' => array(
                                'min' => null,
                                'max' => null,
                            ),
                            'withdraw' => array(
                                'min' => null,
                                'max' => null,
                            ),
                            'deposit' => array(
                                'min' => null,
                                'max' => null,
                            ),
                        ),
                        'networks' => array(),
                        'info' => $market,
                    );
                    // 为USDT、BTC和ETH设置withdraw和deposit标志
                    if ($code === 'USDT' || $code === 'BTC' || $code === 'ETH') {
                        $currencies[$baseId]['withdraw'] = true;
                        $currencies[$baseId]['deposit'] = true;
                    }
                }
                if ($quoteId !== null && !(is_array($currencies) && array_key_exists($quoteId, $currencies))) {
                    $code = $this->safe_currency_code($quoteId);
                    $currencies[$quoteId] = array(
                        'id' => $quoteId,
                        'code' => $code,
                        'name' => $quoteId,
                        'active' => true,
                        'fee' => null,
                        'precision' => null,
                        'limits' => array(
                            'amount' => array(
                                'min' => null,
                                'max' => null,
                            ),
                            'withdraw' => array(
                                'min' => null,
                                'max' => null,
                            ),
                            'deposit' => array(
                                'min' => null,
                                'max' => null,
                            ),
                        ),
                        'networks' => array(),
                        'info' => $market,
                    );
                    // 为USDT、BTC和ETH设置withdraw和deposit标志
                    if ($code === 'USDT' || $code === 'BTC' || $code === 'ETH') {
                        $currencies[$quoteId]['withdraw'] = true;
                        $currencies[$quoteId]['deposit'] = true;
                    }
                }
            }
            return $currencies;
        }) ();
    }

    public function fetch_balance($params = array ()) {
        return Async\async(function () use ($params) {
            /**
             * query for $balance and get the amount of funds available for trading or funds locked in orders
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} a ~@link https://docs.ccxt.com/#/?id=$balance-structure $balance structure~
             */
            Async\await($this->load_markets());
            $response = Async\await($this->privateGetOpenapiContractAccount ($params));
            // API直接返回币种余额对象，如：array("USDT" => array(...))
            // 如果API没有返回时间戳，使用当前时间
            $timestamp = $this->milliseconds();
            $datetime = $this->iso8601($timestamp);
            $result = array(
                'info' => $response,
                'timestamp' => $timestamp,
                'datetime' => $datetime,
            );
            $currencyIds = is_array($response) ? array_keys($response) : array();
            for ($i = 0; $i < count($currencyIds); $i++) {
                $currencyId = $currencyIds[$i];
                $balance = $response[$currencyId];
                $code = $this->safe_currency_code($currencyId);
                $account = $this->account();
                // 正确计算free、$used和$total余额
                $availableMargin = $this->safe_string($balance, 'availableMargin');
                $orderMargin = $this->safe_string($balance, 'orderMargin');
                $positionMargin = $this->safe_string($balance, 'positionMargin');
                $total = $this->safe_string($balance, 'total');
                $account['free'] = $availableMargin;
                // $used余额应该是$orderMargin . $positionMargin
                $used = Precise::string_add($orderMargin, $positionMargin);
                // 如果$used为0，则强制计算$used = $total - free
                if (Precise::string_equals($used, '0')) {
                    $used = Precise::string_sub($total, $availableMargin);
                }
                $account['used'] = $used;
                $account['total'] = $total;
                $result[$code] = $account;
            }
            return $this->safe_balance($result);
        }) ();
    }

    public function create_order(string $symbol, string $type, string $side, float $amount, ?float $price = null, $params = array ()) {
        return Async\async(function () use ($symbol, $type, $side, $amount, $price, $params) {
            /**
             * create a trade order
             * @param {string} $symbol unified $symbol of the $market to create an order in
             * @param {string} $type 'market' or 'limit'
             * @param {string} $side 'buy' or 'sell'
             * @param {float} $amount how much of currency you want to trade in units of base currency
             * @param {float} [$price] the $price at which the order is to be fulfilled, in units of the quote currency, ignored in $market orders
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} an ~@link https://docs.ccxt.com/#/?id=order-structure order structure~
             */
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            // 处理$side参数映射：buy/sell -> BUY_OPEN/SELL_OPEN
            $apiSide = strtoupper($side);
            if ($apiSide === 'BUY') {
                $apiSide = 'BUY_OPEN';
            } elseif ($apiSide === 'SELL') {
                $apiSide = 'SELL_OPEN';
            }
            // 处理$type参数映射：market/limit -> MARKET/LIMIT
            $apiType = strtoupper($type);
            $priceType = 'INPUT';
            if ($apiType === 'MARKET') {
                $priceType = 'MARKET';
            } elseif ($apiType === 'LIMIT') {
                $priceType = 'INPUT';
            }
            $request = array(
                'symbol' => $market['id'],
                'side' => $apiSide,
                'orderType' => 'LIMIT',
                'quantity' => $this->parse_number($this->amount_to_precision($symbol, $amount)) / $market['contractSize'],
                'priceType' => $priceType, // 默认输入价格类型
                'leverage' => '10',     // 默认10倍杠杆
                'timeInForce' => 'GTC', // 默认取消前有效
                'isCross' => 'true',    // 默认全仓模式
            );
            // 限价单需要价格参数
            if ($type === 'limit') {
                $request['price'] = $this->price_to_precision($symbol, $price);
            }
            // 处理额外参数
            $clientOrderId = $this->safe_string($params, 'clientOrderId');
            if ($clientOrderId === null) {
                $request['clientOrderId'] = (string) $this->milliseconds();
            }
            $response = Async\await($this->privatePostOpenapiContractOrder ($this->extend($request, $params)));
            // API响应直接返回订单数据，不需要提取data字段
            return $this->parse_order($response, $market);
        }) ();
    }

    public function cancel_order(string $id, ?string $symbol = null, $params = array ()) {
        return Async\async(function () use ($id, $symbol, $params) {
            /**
             * cancels an open $order
             * @param {string} $id $order $id
             * @param {string} $symbol unified $symbol of the $market the $order was made in
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} An ~@link https://docs.ccxt.com/#/?$id=$order-structure $order structure~
             */
            Async\await($this->load_markets());
            if ($symbol === null) {
                throw new ArgumentsRequired($this->id . ' cancelOrder() requires a $symbol argument');
            }
            $market = $this->market($symbol);
            $request = array(
                'orderId' => $id,
                'symbol' => $market['id'],
                'orderType' => 'LIMIT', // 根据API文档，必需参数，默认LIMIT
            );
            $response = Async\await($this->privateDeleteOpenapiContractOrderCancel ($this->extend($request, $params)));
            $order = $this->safe_value($response, 'data', $response);
            return $this->parse_order($order, $market);
        }) ();
    }

    public function fetch_order(string $id, ?string $symbol = null, $params = array ()) {
        return Async\async(function () use ($id, $symbol, $params) {
            /**
             * fetches information on an $order made by the user
             * @param {string} $id the $order $id
             * @param {string} $symbol unified $symbol of the $market the $order was made in
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} An ~@link https://docs.ccxt.com/#/?$id=$order-structure $order structure~
             */
            Async\await($this->load_markets());
            $request = array(
                'orderId' => $id,
            );
            if ($symbol !== null) {
                $market = $this->market($symbol);
                $request['symbol'] = $market['id'];
            }
            $response = Async\await($this->privateGetOpenapiContractOrder ($this->extend($request, $params)));
            $order = $this->safe_value($response, 'data', array());
            return $this->parse_order($order);
        }) ();
    }

    public function fetch_open_orders(?string $symbol = null, ?int $since = null, ?int $limit = null, $params = array ()) {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            /**
             * fetches information on all open $orders made by the user
             * @param {string} $symbol unified $market $symbol of the $market $orders were made in
             * @param {int} [$since] the earliest time in ms to fetch $orders for
             * @param {int} [$limit] the maximum number of order structures to retrieve
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {Order[]} a list of ~@link https://docs.ccxt.com/#/?id=order-structure order structures~
             */
            Async\await($this->load_markets());
            $request = array();
            if ($symbol !== null) {
                $market = $this->market($symbol);
                $request['symbol'] = $market['id'];
            }
            $response = Async\await($this->privateGetOpenapiContractOpenOrders ($this->extend($request, $params)));
            // API直接返回订单数组，没有data字段包装
            $orders = $this->safe_value($response, 'data', $response);
            return $this->parse_orders($orders, null, $since, $limit);
        }) ();
    }

    public function fetch_my_trades(?string $symbol = null, ?int $since = null, ?int $limit = null, $params = array ()) {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            /**
             * fetch all $trades made by the user
             * @param {string} $symbol unified $market $symbol
             * @param {int} [$since] the earliest time in ms to fetch $trades for
             * @param {int} [$limit] the maximum number of $trades structures to retrieve
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {Trade[]} a list of ~@link https://docs.ccxt.com/#/?id=trade-structure trade structures~
             */
            Async\await($this->load_markets());
            $request = array();
            if ($symbol !== null) {
                $market = $this->market($symbol);
                $request['symbol'] = $market['id'];
            }
            if ($since !== null) {
                $request['startTime'] = $since;
            }
            if ($limit !== null) {
                $request['limit'] = $limit;
            }
            $response = Async\await($this->privateGetOpenapiContractMyTrades ($this->extend($request, $params)));
            // API直接返回交易数组，没有data字段包装
            $trades = $this->safe_value($response, 'data', $response);
            return $this->parse_trades($trades, null, $since, $limit);
        }) ();
    }

    public function fetch_positions(?array $symbols = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbols, $params) {
            /**
             * fetch all open $positions
             * @param {string[]} [$symbols] list of unified market $symbols
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {Position[]} a list of ~@link https://docs.ccxt.com/#/?id=$position-structure $position structure~
             */
            Async\await($this->load_markets());
            $response = Async\await($this->privateGetOpenapiContractPositions ($params));
            // API直接返回数组格式的仓位数据
            $positions = $response;
            $result = array();
            for ($i = 0; $i < count($positions); $i++) {
                $position = $this->parse_position($positions[$i]);
                $result[] = $position;
            }
            return $result;
        }) ();
    }

    public function parse_position($position, $marketParam = null) {
        /**
         * parse a $position structure from the exchange response
         * @param {array} $position the $position data from the exchange
         * @param {array} [$marketParam] the $market to which the $position belongs
         * @return {array} a ~@link https://docs.ccxt.com/#/?id=$position-structure $position structure~
         */
        $marketId = $this->safe_string($position, 'symbol');
        $market = $this->safe_market($marketId, $marketParam);
        $symbol = $market['symbol'];
        // 根据API文档解析仓位方向
        $side = $this->safe_string_lower($position, 'side');
        $positionSide = null;
        if ($side === 'long') {
            $positionSide = 'long';
        } elseif ($side === 'short') {
            $positionSide = 'short';
        }
        $amount = $this->safe_number($position, 'position');
        $entryPrice = $this->safe_number($position, 'avgPrice');
        $unrealizedPnl = $this->safe_number($position, 'unrealizedPnL');
        $leverage = $this->safe_number($position, 'leverage');
        $liquidationPriceRaw = $this->safe_number($position, 'flp');
        $liquidationPrice = null;
        if ($liquidationPriceRaw !== 0) {
            $liquidationPrice = $liquidationPriceRaw;
        }
        $markPrice = $this->safe_number($position, 'lastPrice');
        $margin = $this->safe_number($position, 'margin');
        $positionValue = $this->safe_number($position, 'positionValue');
        $timestamp = $this->milliseconds(); // 使用当前时间作为时间戳
        $marginRate = $this->safe_number($position, 'marginRate');
        return $this->safe_position(array(
            'info' => $position,
            'symbol' => $symbol,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'initialMargin' => $margin,
            'initialMarginPercentage' => null,
            'maintenanceMargin' => null,
            'maintenanceMarginPercentage' => null,
            'entryPrice' => $entryPrice,
            'notional' => $positionValue,
            'leverage' => $leverage,
            'unrealizedPnl' => $unrealizedPnl,
            'contracts' => $amount,
            'contractSize' => $market['contractSize'],
            'realizedPnl' => $this->safe_number($position, 'realizedPnL'),
            'side' => $positionSide,
            'hedged' => null,
            'marginMode' => 'cross',
            'liquidationPrice' => $liquidationPrice,
            'markPrice' => $markPrice,
            'collateral' => $margin,
            'initialCollateral' => $margin,
            'percentage' => $this->safe_number($position, 'profitRate'),
            'marginRatio' => $marginRate,
        ));
    }

    public function parse_order($order, $marketParam = null) {
        /**
         * parse an $order structure from the exchange response
         * @param {array} $order the $order data from the exchange
         * @param {array} [$marketParam] the $market to which the $order belongs
         * @return {array} an ~@link https://docs.ccxt.com/#/?$id=$order-structure $order structure~
         */
        // 直接使用传入的$market参数，避免重新查找
        $market = $marketParam !== null ? $marketParam : $this->safe_market($this->safe_string($order, 'symbol'));
        $symbol = $market['symbol'];
        $timestamp = $this->safe_integer($order, 'time');
        $price = $this->safe_number($order, 'price');
        // 需要将$origQty乘以contractSize来还原实际数量
        $origQtyString = $this->safe_string($order, 'origQty');
        $amount = null;
        if ($origQtyString !== null) {
            $origQty = floatval($origQtyString);
            $amount = $origQty * $market['contractSize'];
        }
        $executedQtyString = $this->safe_string($order, 'executedQty');
        $filled = null;
        if ($executedQtyString !== null) {
            $executedQty = floatval($executedQtyString);
            $filled = $executedQty * $market['contractSize'];
        }
        $remaining = null;
        if ($amount !== null && $filled !== null) {
            $remaining = max (0, $amount - $filled);
        }
        $status = $this->safe_string($order, 'status');
        if ($status === 'NEW') {
            $status = 'open';
        } elseif ($status === 'FILLED') {
            $status = 'closed';
        } elseif ($status === 'CANCELED') {
            $status = 'canceled';
        } elseif ($status === 'PARTIALLY_FILLED') {
            $status = 'open';
        }
        // Astralx使用BUY_OPEN/SELL_OPEN等方向值，需要映射到标准的buy/sell
        $side = $this->safe_string($order, 'side');
        if ($side === 'BUY_OPEN' || $side === 'BUY_CLOSE') {
            $side = 'buy';
        } elseif ($side === 'SELL_OPEN' || $side === 'SELL_CLOSE') {
            $side = 'sell';
        }
        // 根据$priceType确定订单类型：INPUT -> limit, MARKET -> $market
        $priceType = $this->safe_string($order, 'priceType');
        $type = 'limit'; // 默认限价单
        if ($priceType === 'MARKET') {
            $type = 'market';
        } elseif ($priceType === 'INPUT') {
            $type = 'limit';
        }
        $id = $this->safe_string($order, 'orderId');
        $clientOrderId = $this->safe_string($order, 'clientOrderId');
        $average = $this->safe_number($order, 'avgPrice');
        return $this->safe_order(array(
            'info' => $order,
            'id' => $id,
            'clientOrderId' => $clientOrderId,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'lastTradeTimestamp' => null,
            'symbol' => $symbol,
            'type' => $type,
            'timeInForce' => $this->safe_string($order, 'timeInForce'),
            'postOnly' => null,
            'side' => $side,
            'price' => $price,
            'triggerPrice' => null,
            'amount' => $amount,
            'cost' => null,
            'average' => $average,
            'filled' => $filled,
            'remaining' => $remaining,
            'status' => $status,
            'fee' => null,
            'trades' => null,
        ));
    }

    public function sign($path, $api = 'public', $method = 'GET', $params = array (), $headers = null, $body = null) {
        /**
         * signs the request with HMAC-SHA256
         * @param {string} $path the API endpoint $path
         * @param {string} $api 'public' or 'private'
         * @param {string} $method 'GET', 'POST', 'DELETE'
         * @param {array} $params the parameters to include in the request
         * @param {array} [$headers] additional $headers to include
         * @param {array} [$body] the request $body
         * @return {array} the signed request parameters
         */
        $url = $this->urls['api'][$api];
        $url .= '/' . $path;
        $query = $this->omit($params, $this->extract_params($path));
        if ($api === 'private') {
            $this->check_required_credentials();
            $timestamp = $this->milliseconds();
            $query['timestamp'] = (string) $timestamp;
            $signature = $this->hmac($this->encode($this->urlencode($query)), $this->encode($this->secret), 'sha256');
            $query['signature'] = $signature;
            $headers = array(
                'APIKEY-HEADER' => $this->apiKey,
            );
        }
        if ($query) {
            $url .= '?' . $this->urlencode($query);
        }
        return array( 'url' => $url, 'method' => $method, 'body' => $body, 'headers' => $headers );
    }

    public function handle_errors(int $code, string $reason, string $url, string $method, array $headers, string $body, $response, $requestHeaders, $requestBody) {
        /**
         * handles exchange errors
         * @param {int} $code the HTTP status $code
         * @param {string} $reason the HTTP $reason phrase
         * @param {string} $url the URL of the request
         * @param {string} $method the HTTP $method used
         * @param {array} $headers the HTTP $headers
         * @param {string} $body the $response $body
         * @param {array} $response the parsed $response
         * @param {array} $requestHeaders the original request $headers
         * @param {array} $requestBody the original request $body
         * @return {void}
         */
        if ($response === null) {
            return null;
        }
        $errorCode = $this->safe_string($response, 'code');
        if ($errorCode !== null) {
            $message = $this->safe_string($response, 'msg', '');
            $feedback = $this->id . ' ' . $body;
            $this->throw_exactly_matched_exception($this->exceptions['exact'], $errorCode, $feedback);
            $this->throw_broadly_matched_exception($this->exceptions['broad'], $message, $feedback);
            throw new ExchangeError($feedback);
        }
        return null;
    }
}
