<?php

namespace ccxt\async;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

use Exception; // a common import
use \ccxt\ExchangeError;
use \ccxt\ArgumentsRequired;
use \ccxt\BadRequest;
use \ccxt\InvalidOrder;
use \ccxt\Precise;

class gateio extends Exchange {

    public function describe() {
        return $this->deep_extend(parent::describe (), array(
            'id' => 'gateio',
            'name' => 'Gate.io',
            'countries' => array( 'KR' ),
            'rateLimit' => 10 / 3, // 300 requests per second or 3.33ms
            'version' => 'v4',
            'certified' => true,
            'pro' => true,
            'urls' => array(
                'logo' => 'https://user-images.githubusercontent.com/1294454/31784029-0313c702-b509-11e7-9ccc-bc0da6a0e435.jpg',
                'doc' => 'https://www.gate.io/docs/apiv4/en/index.html',
                'www' => 'https://gate.io/',
                'api' => array(
                    'public' => 'https://api.gateio.ws/api/v4',
                    'private' => 'https://api.gateio.ws/api/v4',
                ),
                'referral' => array(
                    'url' => 'https://www.gate.io/ref/2436035',
                    'discount' => 0.2,
                ),
            ),
            'has' => array(
                'CORS' => null,
                'spot' => true,
                'margin' => true,
                'swap' => true,
                'future' => true,
                'option' => null,
                'cancelAllOrders' => true,
                'cancelOrder' => true,
                'createMarketOrder' => false,
                'createOrder' => true,
                'fetchBalance' => true,
                'fetchBorrowRate' => false,
                'fetchBorrowRateHistory' => false,
                'fetchBorrowRates' => false,
                'fetchClosedOrders' => true,
                'fetchCurrencies' => true,
                'fetchDepositAddress' => true,
                'fetchDeposits' => true,
                'fetchFundingFees' => true,
                'fetchFundingHistory' => true,
                'fetchFundingRate' => true,
                'fetchFundingRateHistory' => true,
                'fetchFundingRates' => true,
                'fetchIndexOHLCV' => true,
                'fetchMarkets' => true,
                'fetchMarkOHLCV' => true,
                'fetchMyTrades' => true,
                'fetchNetworkDepositAddress' => true,
                'fetchOHLCV' => true,
                'fetchOpenOrders' => true,
                'fetchOrder' => true,
                'fetchOrderBook' => true,
                'fetchPositions' => true,
                'fetchPremiumIndexOHLCV' => false,
                'fetchTicker' => true,
                'fetchTickers' => true,
                'fetchTime' => false,
                'fetchTrades' => true,
                'fetchTradingFees' => true,
                'fetchWithdrawals' => true,
                'setLeverage' => true,
                'transfer' => true,
                'withdraw' => true,
            ),
            'api' => array(
                'public' => array(
                    'spot' => array(
                        'get' => array(
                            'currencies' => 1,
                            'currencies/{currency}' => 1,
                            'currency_pairs' => 1,
                            'currency_pairs/{currency_pair}' => 1,
                            'tickers' => 1,
                            'order_book' => 1,
                            'trades' => 1,
                            'candlesticks' => 1,
                        ),
                    ),
                    'margin' => array(
                        'get' => array(
                            'currency_pairs' => 1,
                            'currency_pairs/{currency_pair}' => 1,
                            'cross/currencies' => 1,
                            'cross/currencies/{currency}' => 1,
                            'funding_book' => 1,
                        ),
                    ),
                    'futures' => array(
                        'get' => array(
                            '{settle}/contracts' => 1.5,
                            '{settle}/contracts/{contract}' => 1.5,
                            '{settle}/order_book' => 1.5,
                            '{settle}/trades' => 1.5,
                            '{settle}/candlesticks' => 1.5,
                            '{settle}/tickers' => 1.5,
                            '{settle}/funding_rate' => 1.5,
                            '{settle}/insurance' => 1.5,
                            '{settle}/contract_stats' => 1.5,
                            '{settle}/liq_orders' => 1.5,
                        ),
                    ),
                    'delivery' => array(
                        'get' => array(
                            '{settle}/contracts' => 1.5,
                            '{settle}/contracts/{contract}' => 1.5,
                            '{settle}/order_book' => 1.5,
                            '{settle}/trades' => 1.5,
                            '{settle}/candlesticks' => 1.5,
                            '{settle}/tickers' => 1.5,
                            '{settle}/insurance' => 1.5,
                        ),
                    ),
                    'options' => array(
                        'get' => array(
                            'underlyings' => 1.5,
                            'expirations' => 1.5,
                            'contracts' => 1.5,
                            'contracts/{contract}' => 1.5,
                            'settlements' => 1.5,
                            'settlements/{contract}' => 1.5,
                            'order_book' => 1.5,
                            'tickers' => 1.5,
                            'underlying/tickers/{underlying}' => 1.5,
                            'candlesticks' => 1.5,
                            'underlying/candlesticks' => 1.5,
                            'trades' => 1.5,
                        ),
                    ),
                ),
                'private' => array(
                    'withdrawals' => array(
                        'post' => array(
                            '' => 3000, // 3000 = 10 seconds
                        ),
                        'delete' => array(
                            '{withdrawal_id}' => 300,
                        ),
                    ),
                    'wallet' => array(
                        'get' => array(
                            'deposit_address' => 300,
                            'withdrawals' => 300,
                            'deposits' => 300,
                            'sub_account_transfers' => 300,
                            'withdraw_status' => 300,
                            'sub_account_balances' => 300,
                            'fee' => 300,
                        ),
                        'post' => array(
                            'transfers' => 300,
                            'sub_account_transfers' => 300,
                        ),
                    ),
                    'spot' => array(
                        'get' => array(
                            'accounts' => 1,
                            'open_orders' => 1,
                            'orders' => 1,
                            'orders/{order_id}' => 1,
                            'my_trades' => 1,
                            'price_orders' => 1,
                            'price_orders/{order_id}' => 1,
                        ),
                        'post' => array(
                            'batch_orders' => 1,
                            'orders' => 1,
                            'cancel_batch_orders' => 1,
                            'price_orders' => 1,
                        ),
                        'delete' => array(
                            'orders' => 1,
                            'orders/{order_id}' => 1,
                            'price_orders' => 1,
                            'price_orders/{order_id}' => 1,
                        ),
                    ),
                    'margin' => array(
                        'get' => array(
                            'accounts' => 1.5,
                            'account_book' => 1.5,
                            'funding_accounts' => 1.5,
                            'loans' => 1.5,
                            'loans/{loan_id}' => 1.5,
                            'loans/{loan_id}/repayment' => 1.5,
                            'loan_records' => 1.5,
                            'loan_records/{load_record_id}' => 1.5,
                            'auto_repay' => 1.5,
                            'transferable' => 1.5,
                            'cross/accounts' => 1.5,
                            'cross/account_book' => 1.5,
                            'cross/loans' => 1.5,
                            'cross/loans/{loan_id}' => 1.5,
                            'cross/loans/repayments' => 1.5,
                            'cross/transferable' => 1.5,
                        ),
                        'post' => array(
                            'loans' => 1.5,
                            'merged_loans' => 1.5,
                            'loans/{loan_id}/repayment' => 1.5,
                            'auto_repay' => 1.5,
                            'cross/loans' => 1.5,
                            'cross/loans/repayments' => 1.5,
                        ),
                        'patch' => array(
                            'loans/{loan_id}' => 1.5,
                            'loan_records/{loan_record_id}' => 1.5,
                        ),
                        'delete' => array(
                            'loans/{loan_id}' => 1.5,
                        ),
                    ),
                    'futures' => array(
                        'get' => array(
                            '{settle}/accounts' => 1.5,
                            '{settle}/account_book' => 1.5,
                            '{settle}/positions' => 1.5,
                            '{settle}/positions/{contract}' => 1.5,
                            '{settle}/orders' => 1.5,
                            '{settle}/orders/{order_id}' => 1.5,
                            '{settle}/my_trades' => 1.5,
                            '{settle}/position_close' => 1.5,
                            '{settle}/liquidates' => 1.5,
                            '{settle}/price_orders' => 1.5,
                            '{settle}/price_orders/{order_id}' => 1.5,
                        ),
                        'post' => array(
                            '{settle}/positions/{contract}/margin' => 1.5,
                            '{settle}/positions/{contract}/leverage' => 1.5,
                            '{settle}/positions/{contract}/risk_limit' => 1.5,
                            '{settle}/dual_mode' => 1.5,
                            '{settle}/dual_comp/positions/{contract}' => 1.5,
                            '{settle}/dual_comp/positions/{contract}/margin' => 1.5,
                            '{settle}/dual_comp/positions/{contract}/leverage' => 1.5,
                            '{settle}/dual_comp/positions/{contract}/risk_limit' => 1.5,
                            '{settle}/orders' => 1.5,
                            '{settle}/price_orders' => 1.5,
                        ),
                        'delete' => array(
                            '{settle}/orders' => 1.5,
                            '{settle}/orders/{order_id}' => 1.5,
                            '{settle}/price_orders' => 1.5,
                            '{settle}/price_orders/{order_id}' => 1.5,
                        ),
                    ),
                    'delivery' => array(
                        'get' => array(
                            '{settle}/accounts' => 1.5,
                            '{settle}/account_book' => 1.5,
                            '{settle}/positions' => 1.5,
                            '{settle}/positions/{contract}' => 1.5,
                            '{settle}/orders' => 1.5,
                            '{settle}/orders/{order_id}' => 1.5,
                            '{settle}/my_trades' => 1.5,
                            '{settle}/position_close' => 1.5,
                            '{settle}/liquidates' => 1.5,
                            '{settle}/price_orders' => 1.5,
                            '{settle}/price_orders/{order_id}' => 1.5,
                        ),
                        'post' => array(
                            '{settle}/positions/{contract}/margin' => 1.5,
                            '{settle}/positions/{contract}/leverage' => 1.5,
                            '{settle}/positions/{contract}/risk_limit' => 1.5,
                            '{settle}/orders' => 1.5,
                            '{settle}/price_orders' => 1.5,
                        ),
                        'delete' => array(
                            '{settle}/orders' => 1.5,
                            '{settle}/orders/{order_id}' => 1.5,
                            '{settle}/price_orders' => 1.5,
                            '{settle}/price_orders/{order_id}' => 1.5,
                        ),
                    ),
                    'options' => array(
                        'get' => array(
                            'accounts' => 1.5,
                            'account_book' => 1.5,
                            'positions' => 1.5,
                            'positions/{contract}' => 1.5,
                            'position_close' => 1.5,
                            'orders' => 1.5,
                            'orders/{order_id}' => 1.5,
                            'my_trades' => 1.5,
                        ),
                        'post' => array(
                            'orders' => 1.5,
                        ),
                        'delete' => array(
                            'orders' => 1.5,
                            'orders/{order_id}' => 1.5,
                        ),
                    ),
                ),
            ),
            'timeframes' => array(
                '10s' => '10s',
                '1m' => '1m',
                '5m' => '5m',
                '15m' => '15m',
                '30m' => '30m',
                '1h' => '1h',
                '4h' => '4h',
                '8h' => '8h',
                '1d' => '1d',
                '7d' => '7d',
                '1w' => '7d',
            ),
            // copied from gateiov2
            'commonCurrencies' => array(
                '88MPH' => 'MPH',
                'BIFI' => 'Bitcoin File',
                'BOX' => 'DefiBox',
                'BTCBEAR' => 'BEAR',
                'BTCBULL' => 'BULL',
                'BYN' => 'BeyondFi',
                'EGG' => 'Goose Finance',
                'GTC' => 'Game.com', // conflict with Gitcoin and Gastrocoin
                'GTC_HT' => 'Game.com HT',
                'GTC_BSC' => 'Game.com BSC',
                'HIT' => 'HitChain',
                'MM' => 'Million', // conflict with MilliMeter
                'MPH' => 'Morpher', // conflict with 88MPH
                'RAI' => 'Rai Reflex Index', // conflict with RAI Finance
                'SBTC' => 'Super Bitcoin',
                'TNC' => 'Trinity Network Credit',
                'TON' => 'TONToken',
                'VAI' => 'VAIOT',
            ),
            'requiredCredentials' => array(
                'apiKey' => true,
                'secret' => true,
            ),
            'options' => array(
                'createOrder' => array(
                    'expiration' => 86400, // for conditional orders
                ),
                'networks' => array(
                    'TRC20' => 'TRX',
                    'ERC20' => 'ETH',
                    'BEP20' => 'BSC',
                ),
                'accountsByType' => array(
                    'spot' => 'spot',
                    'margin' => 'margin',
                    'future' => 'futures',
                    'futures' => 'futures',
                    'delivery' => 'delivery',
                ),
                'defaultType' => 'spot',
                'swap' => array(
                    'fetchMarkets' => array(
                        'settlementCurrencies' => array( 'usdt', 'btc' ),
                    ),
                ),
                'future' => array(
                    'fetchMarkets' => array(
                        'settlementCurrencies' => array( 'usdt', 'btc' ),
                    ),
                ),
            ),
            'precisionMode' => TICK_SIZE,
            'fees' => array(
                'trading' => array(
                    'tierBased' => true,
                    'feeSide' => 'get',
                    'percentage' => true,
                    'maker' => $this->parse_number('0.002'),
                    'taker' => $this->parse_number('0.002'),
                    'tiers' => array(
                        // volume is in BTC
                        'maker' => array(
                            array( $this->parse_number('0'), $this->parse_number('0.002') ),
                            array( $this->parse_number('1.5'), $this->parse_number('0.00185') ),
                            array( $this->parse_number('3'), $this->parse_number('0.00175') ),
                            array( $this->parse_number('6'), $this->parse_number('0.00165') ),
                            array( $this->parse_number('12.5'), $this->parse_number('0.00155') ),
                            array( $this->parse_number('25'), $this->parse_number('0.00145') ),
                            array( $this->parse_number('75'), $this->parse_number('0.00135') ),
                            array( $this->parse_number('200'), $this->parse_number('0.00125') ),
                            array( $this->parse_number('500'), $this->parse_number('0.00115') ),
                            array( $this->parse_number('1250'), $this->parse_number('0.00105') ),
                            array( $this->parse_number('2500'), $this->parse_number('0.00095') ),
                            array( $this->parse_number('3000'), $this->parse_number('0.00085') ),
                            array( $this->parse_number('6000'), $this->parse_number('0.00075') ),
                            array( $this->parse_number('11000'), $this->parse_number('0.00065') ),
                            array( $this->parse_number('20000'), $this->parse_number('0.00055') ),
                            array( $this->parse_number('40000'), $this->parse_number('0.00055') ),
                            array( $this->parse_number('75000'), $this->parse_number('0.00055') ),
                        ),
                        'taker' => array(
                            array( $this->parse_number('0'), $this->parse_number('0.002') ),
                            array( $this->parse_number('1.5'), $this->parse_number('0.00195') ),
                            array( $this->parse_number('3'), $this->parse_number('0.00185') ),
                            array( $this->parse_number('6'), $this->parse_number('0.00175') ),
                            array( $this->parse_number('12.5'), $this->parse_number('0.00165') ),
                            array( $this->parse_number('25'), $this->parse_number('0.00155') ),
                            array( $this->parse_number('75'), $this->parse_number('0.00145') ),
                            array( $this->parse_number('200'), $this->parse_number('0.00135') ),
                            array( $this->parse_number('500'), $this->parse_number('0.00125') ),
                            array( $this->parse_number('1250'), $this->parse_number('0.00115') ),
                            array( $this->parse_number('2500'), $this->parse_number('0.00105') ),
                            array( $this->parse_number('3000'), $this->parse_number('0.00095') ),
                            array( $this->parse_number('6000'), $this->parse_number('0.00085') ),
                            array( $this->parse_number('11000'), $this->parse_number('0.00075') ),
                            array( $this->parse_number('20000'), $this->parse_number('0.00065') ),
                            array( $this->parse_number('40000'), $this->parse_number('0.00065') ),
                            array( $this->parse_number('75000'), $this->parse_number('0.00065') ),
                        ),
                    ),
                ),
                'swap' => array(
                    'tierBased' => true,
                    'feeSide' => 'base',
                    'percentage' => true,
                    'maker' => $this->parse_number('0.0'),
                    'taker' => $this->parse_number('0.0005'),
                    'tiers' => array(
                        'maker' => array(
                            array( $this->parse_number('0'), $this->parse_number('0.0000') ),
                            array( $this->parse_number('1.5'), $this->parse_number('-0.00005') ),
                            array( $this->parse_number('3'), $this->parse_number('-0.00005') ),
                            array( $this->parse_number('6'), $this->parse_number('-0.00005') ),
                            array( $this->parse_number('12.5'), $this->parse_number('-0.00005') ),
                            array( $this->parse_number('25'), $this->parse_number('-0.00005') ),
                            array( $this->parse_number('75'), $this->parse_number('-0.00005') ),
                            array( $this->parse_number('200'), $this->parse_number('-0.00005') ),
                            array( $this->parse_number('500'), $this->parse_number('-0.00005') ),
                            array( $this->parse_number('1250'), $this->parse_number('-0.00005') ),
                            array( $this->parse_number('2500'), $this->parse_number('-0.00005') ),
                            array( $this->parse_number('3000'), $this->parse_number('-0.00008') ),
                            array( $this->parse_number('6000'), $this->parse_number('-0.01000') ),
                            array( $this->parse_number('11000'), $this->parse_number('-0.01002') ),
                            array( $this->parse_number('20000'), $this->parse_number('-0.01005') ),
                            array( $this->parse_number('40000'), $this->parse_number('-0.02000') ),
                            array( $this->parse_number('75000'), $this->parse_number('-0.02005') ),
                        ),
                        'taker' => array(
                            array( $this->parse_number('0'), $this->parse_number('0.00050') ),
                            array( $this->parse_number('1.5'), $this->parse_number('0.00048') ),
                            array( $this->parse_number('3'), $this->parse_number('0.00046') ),
                            array( $this->parse_number('6'), $this->parse_number('0.00044') ),
                            array( $this->parse_number('12.5'), $this->parse_number('0.00042') ),
                            array( $this->parse_number('25'), $this->parse_number('0.00040') ),
                            array( $this->parse_number('75'), $this->parse_number('0.00038') ),
                            array( $this->parse_number('200'), $this->parse_number('0.00036') ),
                            array( $this->parse_number('500'), $this->parse_number('0.00034') ),
                            array( $this->parse_number('1250'), $this->parse_number('0.00032') ),
                            array( $this->parse_number('2500'), $this->parse_number('0.00030') ),
                            array( $this->parse_number('3000'), $this->parse_number('0.00030') ),
                            array( $this->parse_number('6000'), $this->parse_number('0.00030') ),
                            array( $this->parse_number('11000'), $this->parse_number('0.00030') ),
                            array( $this->parse_number('20000'), $this->parse_number('0.00030') ),
                            array( $this->parse_number('40000'), $this->parse_number('0.00030') ),
                            array( $this->parse_number('75000'), $this->parse_number('0.00030') ),
                        ),
                    ),
                ),
            ),
            // https://www.gate.io/docs/apiv4/en/index.html#label-list
            'exceptions' => array(
                'exact' => array(
                    'INVALID_PARAM_VALUE' => '\\ccxt\\BadRequest',
                    'INVALID_PROTOCOL' => '\\ccxt\\BadRequest',
                    'INVALID_ARGUMENT' => '\\ccxt\\BadRequest',
                    'INVALID_REQUEST_BODY' => '\\ccxt\\BadRequest',
                    'MISSING_REQUIRED_PARAM' => '\\ccxt\\ArgumentsRequired',
                    'BAD_REQUEST' => '\\ccxt\\BadRequest',
                    'INVALID_CONTENT_TYPE' => '\\ccxt\\BadRequest',
                    'NOT_ACCEPTABLE' => '\\ccxt\\BadRequest',
                    'METHOD_NOT_ALLOWED' => '\\ccxt\\BadRequest',
                    'NOT_FOUND' => '\\ccxt\\ExchangeError',
                    'INVALID_CREDENTIALS' => '\\ccxt\\AuthenticationError',
                    'INVALID_KEY' => '\\ccxt\\AuthenticationError',
                    'IP_FORBIDDEN' => '\\ccxt\\AuthenticationError',
                    'READ_ONLY' => '\\ccxt\\PermissionDenied',
                    'INVALID_SIGNATURE' => '\\ccxt\\AuthenticationError',
                    'MISSING_REQUIRED_HEADER' => '\\ccxt\\AuthenticationError',
                    'REQUEST_EXPIRED' => '\\ccxt\\AuthenticationError',
                    'ACCOUNT_LOCKED' => '\\ccxt\\AccountSuspended',
                    'FORBIDDEN' => '\\ccxt\\PermissionDenied',
                    'SUB_ACCOUNT_NOT_FOUND' => '\\ccxt\\ExchangeError',
                    'SUB_ACCOUNT_LOCKED' => '\\ccxt\\AccountSuspended',
                    'MARGIN_BALANCE_EXCEPTION' => '\\ccxt\\ExchangeError',
                    'MARGIN_TRANSFER_FAILED' => '\\ccxt\\ExchangeError',
                    'TOO_MUCH_FUTURES_AVAILABLE' => '\\ccxt\\ExchangeError',
                    'FUTURES_BALANCE_NOT_ENOUGH' => '\\ccxt\\InsufficientFunds',
                    'ACCOUNT_EXCEPTION' => '\\ccxt\\ExchangeError',
                    'SUB_ACCOUNT_TRANSFER_FAILED' => '\\ccxt\\ExchangeError',
                    'ADDRESS_NOT_USED' => '\\ccxt\\ExchangeError',
                    'TOO_FAST' => '\\ccxt\\RateLimitExceeded',
                    'WITHDRAWAL_OVER_LIMIT' => '\\ccxt\\ExchangeError',
                    'API_WITHDRAW_DISABLED' => '\\ccxt\\ExchangeNotAvailable',
                    'INVALID_WITHDRAW_ID' => '\\ccxt\\ExchangeError',
                    'INVALID_WITHDRAW_CANCEL_STATUS' => '\\ccxt\\ExchangeError',
                    'INVALID_PRECISION' => '\\ccxt\\InvalidOrder',
                    'INVALID_CURRENCY' => '\\ccxt\\BadSymbol',
                    'INVALID_CURRENCY_PAIR' => '\\ccxt\\BadSymbol',
                    'POC_FILL_IMMEDIATELY' => '\\ccxt\\ExchangeError',
                    'ORDER_NOT_FOUND' => '\\ccxt\\OrderNotFound',
                    'CLIENT_ID_NOT_FOUND' => '\\ccxt\\OrderNotFound',
                    'ORDER_CLOSED' => '\\ccxt\\InvalidOrder',
                    'ORDER_CANCELLED' => '\\ccxt\\InvalidOrder',
                    'QUANTITY_NOT_ENOUGH' => '\\ccxt\\InvalidOrder',
                    'BALANCE_NOT_ENOUGH' => '\\ccxt\\InsufficientFunds',
                    'MARGIN_NOT_SUPPORTED' => '\\ccxt\\InvalidOrder',
                    'MARGIN_BALANCE_NOT_ENOUGH' => '\\ccxt\\InsufficientFunds',
                    'AMOUNT_TOO_LITTLE' => '\\ccxt\\InvalidOrder',
                    'AMOUNT_TOO_MUCH' => '\\ccxt\\InvalidOrder',
                    'REPEATED_CREATION' => '\\ccxt\\InvalidOrder',
                    'LOAN_NOT_FOUND' => '\\ccxt\\OrderNotFound',
                    'LOAN_RECORD_NOT_FOUND' => '\\ccxt\\OrderNotFound',
                    'NO_MATCHED_LOAN' => '\\ccxt\\ExchangeError',
                    'NOT_MERGEABLE' => '\\ccxt\\ExchangeError',
                    'NO_CHANGE' => '\\ccxt\\ExchangeError',
                    'REPAY_TOO_MUCH' => '\\ccxt\\ExchangeError',
                    'TOO_MANY_CURRENCY_PAIRS' => '\\ccxt\\InvalidOrder',
                    'TOO_MANY_ORDERS' => '\\ccxt\\InvalidOrder',
                    'MIXED_ACCOUNT_TYPE' => '\\ccxt\\InvalidOrder',
                    'AUTO_BORROW_TOO_MUCH' => '\\ccxt\\ExchangeError',
                    'TRADE_RESTRICTED' => '\\ccxt\\InsufficientFunds',
                    'USER_NOT_FOUND' => '\\ccxt\\ExchangeError',
                    'CONTRACT_NO_COUNTER' => '\\ccxt\\ExchangeError',
                    'CONTRACT_NOT_FOUND' => '\\ccxt\\BadSymbol',
                    'RISK_LIMIT_EXCEEDED' => '\\ccxt\\ExchangeError',
                    'INSUFFICIENT_AVAILABLE' => '\\ccxt\\InsufficientFunds',
                    'LIQUIDATE_IMMEDIATELY' => '\\ccxt\\InvalidOrder',
                    'LEVERAGE_TOO_HIGH' => '\\ccxt\\InvalidOrder',
                    'LEVERAGE_TOO_LOW' => '\\ccxt\\InvalidOrder',
                    'ORDER_NOT_OWNED' => '\\ccxt\\ExchangeError',
                    'ORDER_FINISHED' => '\\ccxt\\ExchangeError',
                    'POSITION_CROSS_MARGIN' => '\\ccxt\\ExchangeError',
                    'POSITION_IN_LIQUIDATION' => '\\ccxt\\ExchangeError',
                    'POSITION_IN_CLOSE' => '\\ccxt\\ExchangeError',
                    'POSITION_EMPTY' => '\\ccxt\\InvalidOrder',
                    'REMOVE_TOO_MUCH' => '\\ccxt\\ExchangeError',
                    'RISK_LIMIT_NOT_MULTIPLE' => '\\ccxt\\ExchangeError',
                    'RISK_LIMIT_TOO_HIGH' => '\\ccxt\\ExchangeError',
                    'RISK_LIMIT_TOO_lOW' => '\\ccxt\\ExchangeError',
                    'PRICE_TOO_DEVIATED' => '\\ccxt\\InvalidOrder',
                    'SIZE_TOO_LARGE' => '\\ccxt\\InvalidOrder',
                    'SIZE_TOO_SMALL' => '\\ccxt\\InvalidOrder',
                    'PRICE_OVER_LIQUIDATION' => '\\ccxt\\InvalidOrder',
                    'PRICE_OVER_BANKRUPT' => '\\ccxt\\InvalidOrder',
                    'ORDER_POC_IMMEDIATE' => '\\ccxt\\InvalidOrder',
                    'INCREASE_POSITION' => '\\ccxt\\InvalidOrder',
                    'CONTRACT_IN_DELISTING' => '\\ccxt\\ExchangeError',
                    'INTERNAL' => '\\ccxt\\ExchangeError',
                    'SERVER_ERROR' => '\\ccxt\\ExchangeError',
                    'TOO_BUSY' => '\\ccxt\\ExchangeNotAvailable',
                ),
            ),
            'broad' => array(),
        ));
    }

    public function fetch_markets($params = array ()) {
        // :param $params['type'] => 'spot', 'margin', 'future' or 'delivery'
        // :param $params['settle'] => The $quote currency
        list($type, $query) = $this->handle_market_type_and_params('fetchMarkets', null, $params);
        $spot = ($type === 'spot');
        $margin = ($type === 'margin');
        $future = ($type === 'future');
        $swap = ($type === 'swap');
        $option = ($type === 'option');
        if (!$spot && !$margin && !$future && !$swap) {
            throw new ExchangeError($this->id . " does not support '" . $type . "' $type, set exchange.options['defaultType'] to " . "'spot', 'margin', 'swap' or 'future'"); // eslint-disable-line quotes
        }
        $response = null;
        $result = array();
        $method = $this->get_supported_mapping($type, array(
            'spot' => 'publicSpotGetCurrencyPairs',
            'margin' => 'publicMarginGetCurrencyPairs',
            'swap' => 'publicFuturesGetSettleContracts',
            'future' => 'publicDeliveryGetSettleContracts',
        ));
        if ($swap || $future || $option) {
            $settlementCurrencies = $this->get_settlement_currencies($type, 'fetchMarkets');
            for ($c = 0; $c < count($settlementCurrencies); $c++) {
                $settleId = $settlementCurrencies[$c];
                $query['settle'] = $settleId;
                $response = yield $this->$method ($query);
                //  Perpetual $swap
                //      array(
                //          {
                //              "name" => "BTC_USDT",
                //              "type" => "direct",
                //              "quanto_multiplier" => "0.0001",
                //              "ref_discount_rate" => "0",
                //              "order_price_deviate" => "0.5",
                //              "maintenance_rate" => "0.005",
                //              "mark_type" => "index",
                //              "last_price" => "38026",
                //              "mark_price" => "37985.6",
                //              "index_price" => "37954.92",
                //              "funding_rate_indicative" => "0.000219",
                //              "mark_price_round" => "0.01",
                //              "funding_offset" => 0,
                //              "in_delisting" => false,
                //              "risk_limit_base" => "1000000",
                //              "interest_rate" => "0.0003",
                //              "order_price_round" => "0.1",
                //              "order_size_min" => 1,
                //              "ref_rebate_rate" => "0.2",
                //              "funding_interval" => 28800,
                //              "risk_limit_step" => "1000000",
                //              "leverage_min" => "1",
                //              "leverage_max" => "100",
                //              "risk_limit_max" => "8000000",
                //              "maker_fee_rate" => "-0.00025",
                //              "taker_fee_rate" => "0.00075",
                //              "funding_rate" => "0.002053",
                //              "order_size_max" => 1000000,
                //              "funding_next_apply" => 1610035200,
                //              "short_users" => 977,
                //              "config_change_time" => 1609899548,
                //              "trade_size" => 28530850594,
                //              "position_size" => 5223816,
                //              "long_users" => 455,
                //              "funding_impact_value" => "60000",
                //              "orders_limit" => 50,
                //              "trade_id" => 10851092,
                //              "orderbook_id" => 2129638396
                //          }
                //      )
                //
                //  Delivery Futures
                //      array(
                //          {
                //            "name" => "BTC_USDT_20200814",
                //            "underlying" => "BTC_USDT",
                //            "cycle" => "WEEKLY",
                //            "type" => "direct",
                //            "quanto_multiplier" => "0.0001",
                //            "mark_type" => "index",
                //            "last_price" => "9017",
                //            "mark_price" => "9019",
                //            "index_price" => "9005.3",
                //            "basis_rate" => "0.185095",
                //            "basis_value" => "13.7",
                //            "basis_impact_value" => "100000",
                //            "settle_price" => "0",
                //            "settle_price_interval" => 60,
                //            "settle_price_duration" => 1800,
                //            "settle_fee_rate" => "0.0015",
                //            "expire_time" => 1593763200,
                //            "order_price_round" => "0.1",
                //            "mark_price_round" => "0.1",
                //            "leverage_min" => "1",
                //            "leverage_max" => "100",
                //            "maintenance_rate" => "1000000",
                //            "risk_limit_base" => "140.726652109199",
                //            "risk_limit_step" => "1000000",
                //            "risk_limit_max" => "8000000",
                //            "maker_fee_rate" => "-0.00025",
                //            "taker_fee_rate" => "0.00075",
                //            "ref_discount_rate" => "0",
                //            "ref_rebate_rate" => "0.2",
                //            "order_price_deviate" => "0.5",
                //            "order_size_min" => 1,
                //            "order_size_max" => 1000000,
                //            "orders_limit" => 50,
                //            "orderbook_id" => 63,
                //            "trade_id" => 26,
                //            "trade_size" => 435,
                //            "position_size" => 130,
                //            "config_change_time" => 1593158867,
                //            "in_delisting" => false
                //          }
                //        )
                //
                for ($i = 0; $i < count($response); $i++) {
                    $market = $response[$i];
                    $id = $this->safe_string($market, 'name');
                    $parts = explode('_', $id);
                    $baseId = $this->safe_string($parts, 0);
                    $quoteId = $this->safe_string($parts, 1);
                    $date = $this->safe_string($parts, 2);
                    $base = $this->safe_currency_code($baseId);
                    $quote = $this->safe_currency_code($quoteId);
                    $settle = $this->safe_currency_code($settleId);
                    $linear = $quote === $settle;
                    $inverse = $base === $settle;
                    $expiry = $this->safe_timestamp($market, 'expire_time');
                    $symbol = '';
                    if ($date !== null) {
                        $symbol = $base . '/' . $quote . ':' . $settle . '-' . $this->yymmdd($expiry, '');
                    } else {
                        $symbol = $base . '/' . $quote . ':' . $settle;
                    }
                    $priceDeviate = $this->safe_string($market, 'order_price_deviate');
                    $markPrice = $this->safe_string($market, 'mark_price');
                    $minMultiplier = Precise::string_sub('1', $priceDeviate);
                    $maxMultiplier = Precise::string_add('1', $priceDeviate);
                    $minPrice = Precise::string_mul($minMultiplier, $markPrice);
                    $maxPrice = Precise::string_mul($maxMultiplier, $markPrice);
                    $takerPercent = $this->safe_string($market, 'taker_fee_rate');
                    $makerPercent = $this->safe_string($market, 'maker_fee_rate', $takerPercent);
                    $pricePrecision = $this->safe_number($market, 'order_price_round');
                    // Fee is in %, so divide by 100
                    $taker = $this->parse_number(Precise::string_div($takerPercent, '100'));
                    $maker = $this->parse_number(Precise::string_div($makerPercent, '100'));
                    $result[] = array(
                        'info' => $market,
                        'id' => $id,
                        'symbol' => $symbol,
                        'base' => $base,
                        'quote' => $quote,
                        'settle' => $settle,
                        'baseId' => $baseId,
                        'quoteId' => $quoteId,
                        'settleId' => $settleId,
                        'type' => $type,
                        'spot' => $spot,
                        'margin' => $margin,
                        'swap' => $swap,
                        'future' => $future,
                        'option' => $option,
                        'active' => true,
                        'contract' => true,
                        'linear' => $linear,
                        'inverse' => $inverse,
                        'taker' => $taker,
                        'maker' => $maker,
                        'contractSize' => $this->safe_number($market, 'quanto_multiplier'),
                        'expiry' => $expiry,
                        'expiryDatetime' => $this->iso8601($expiry),
                        'strike' => null,
                        'optionType' => null,
                        'precision' => array(
                            'amount' => $this->parse_number('1'),
                            'price' => $pricePrecision,
                        ),
                        'limits' => array(
                            'leverage' => array(
                                'min' => $this->safe_number($market, 'leverage_min'),
                                'max' => $this->safe_number($market, 'leverage_max'),
                            ),
                            'amount' => array(
                                'min' => $this->safe_number($market, 'order_size_min'),
                                'max' => $this->safe_number($market, 'order_size_max'),
                            ),
                            'price' => array(
                                'min' => $minPrice,
                                'max' => $maxPrice,
                            ),
                            'cost' => array(
                                'min' => null,
                                'max' => null,
                            ),
                        ),
                    );
                }
            }
        } else {
            $response = yield $this->$method ($query);
            //
            //  Spot
            //      array(
            //           {
            //             "id" => "DEGO_USDT",
            //             "base" => "DEGO",
            //             "quote" => "USDT",
            //             "fee" => "0.2",
            //             "min_quote_amount" => "1",
            //             "amount_precision" => "4",
            //             "precision" => "4",
            //             "trade_status" => "tradable",
            //             "sell_start" => "0",
            //             "buy_start" => "0"
            //           }
            //      )
            //
            //  Margin
            //      array(
            //         {
            //           "id" => "ETH_USDT",
            //           "base" => "ETH",
            //           "quote" => "USDT",
            //           "leverage" => 3,
            //           "min_base_amount" => "0.01",
            //           "min_quote_amount" => "100",
            //           "max_quote_amount" => "1000000"
            //         }
            //       )
            //
            for ($i = 0; $i < count($response); $i++) {
                $market = $response[$i];
                $id = $this->safe_string($market, 'id');
                $spot = ($type === 'spot');
                list($baseId, $quoteId) = explode('_', $id);
                $base = $this->safe_currency_code($baseId);
                $quote = $this->safe_currency_code($quoteId);
                $symbol = $base . '/' . $quote;
                $takerPercent = $this->safe_string($market, 'fee');
                $makerPercent = $this->safe_string($market, 'maker_fee_rate', $takerPercent);
                $amountPrecisionString = $this->safe_string($market, 'amount_precision');
                $pricePrecisionString = $this->safe_string($market, 'precision');
                $amountPrecision = $this->parse_number($this->parse_precision($amountPrecisionString));
                $pricePrecision = $this->parse_number($this->parse_precision($pricePrecisionString));
                $tradeStatus = $this->safe_string($market, 'trade_status');
                $result[] = array(
                    'id' => $id,
                    'symbol' => $symbol,
                    'base' => $base,
                    'quote' => $quote,
                    'settle' => null,
                    'baseId' => $baseId,
                    'quoteId' => $quoteId,
                    'settleId' => null,
                    'type' => $type,
                    'spot' => $spot,
                    'margin' => $margin,
                    'swap' => false,
                    'future' => false,
                    'option' => false,
                    'active' => $tradeStatus === 'tradable',
                    'contract' => false,
                    'linear' => null,
                    'inverse' => null,
                    // Fee is in %, so divide by 100
                    'taker' => $this->parse_number(Precise::string_div($takerPercent, '100')),
                    'maker' => $this->parse_number(Precise::string_div($makerPercent, '100')),
                    'contractSize' => null,
                    'expiry' => null,
                    'expiryDatetime' => null,
                    'strike' => null,
                    'optionType' => null,
                    'precision' => array(
                        'amount' => $amountPrecision,
                        'price' => $pricePrecision,
                    ),
                    'limits' => array(
                        'leverage' => array(
                            'min' => $this->parse_number('1'),
                            'max' => $this->safe_number($market, 'lever', 1),
                        ),
                        'amount' => array(
                            'min' => $amountPrecision,
                            'max' => null,
                        ),
                        'price' => array(
                            'min' => $pricePrecision,
                            'max' => null,
                        ),
                        'cost' => array(
                            'min' => $this->safe_number($market, 'min_quote_amount'),
                            'max' => null,
                        ),
                    ),
                    'info' => $market,
                );
            }
        }
        return $result;
    }

    public function prepare_request($market) {
        if ($market['contract']) {
            return array(
                'contract' => $market['id'],
                'settle' => $market['settleId'],
            );
        } else {
            return array(
                'currency_pair' => $market['id'],
            );
        }
    }

    public function get_settlement_currencies($type, $method) {
        $options = $this->safe_value($this->options, $type, array()); // array( 'BTC', 'USDT' ) unified codes
        $fetchMarketsContractOptions = $this->safe_value($options, $method, array());
        $defaultSettle = ($type === 'swap') ? array( 'usdt' ) : array( 'btc' );
        return $this->safe_value($fetchMarketsContractOptions, 'settlementCurrencies', $defaultSettle);
    }

    public function fetch_currencies($params = array ()) {
        $response = yield $this->publicSpotGetCurrencies ($params);
        //
        //     {
        //       "currency" => "BCN",
        //       "delisted" => false,
        //       "withdraw_disabled" => true,
        //       "withdraw_delayed" => false,
        //       "deposit_disabled" => true,
        //       "trade_disabled" => false
        //     }
        //
        $result = array();
        // TODO => remove magic constants
        $amountPrecision = $this->parse_number('1e-6');
        for ($i = 0; $i < count($response); $i++) {
            $entry = $response[$i];
            $currencyId = $this->safe_string($entry, 'currency');
            $currencyIdLower = $this->safe_string_lower($entry, 'currency');
            $code = $this->safe_currency_code($currencyId);
            $delisted = $this->safe_value($entry, 'delisted');
            $withdrawDisabled = $this->safe_value($entry, 'withdraw_disabled', false);
            $depositDisabled = $this->safe_value($entry, 'deposit_disabled', false);
            $tradeDisabled = $this->safe_value($entry, 'trade_disabled', false);
            $withdrawEnabled = !$withdrawDisabled;
            $depositEnabled = !$depositDisabled;
            $tradeEnabled = !$tradeDisabled;
            $listed = !$delisted;
            $active = $listed && $tradeEnabled && $withdrawEnabled && $depositEnabled;
            $result[$code] = array(
                'id' => $currencyId,
                'lowerCaseId' => $currencyIdLower,
                'name' => null,
                'code' => $code,
                'precision' => $amountPrecision,
                'info' => $entry,
                'active' => $active,
                'deposit' => $depositEnabled,
                'withdraw' => $withdrawEnabled,
                'fee' => null,
                'fees' => array(),
                'limits' => $this->limits,
            );
        }
        return $result;
    }

    public function fetch_funding_rate($symbol, $params = array ()) {
        yield $this->load_markets();
        $market = $this->market($symbol);
        if (!$market['swap']) {
            throw new BadRequest('Funding rates only exist for swap contracts');
        }
        $request = $this->prepare_request($market);
        $response = yield $this->publicFuturesGetSettleContractsContract (array_merge($request, $params));
        //
        // array(
        //     {
        //       "name" => "BTC_USDT",
        //       "type" => "direct",
        //       "quanto_multiplier" => "0.0001",
        //       "ref_discount_rate" => "0",
        //       "order_price_deviate" => "0.5",
        //       "maintenance_rate" => "0.005",
        //       "mark_type" => "index",
        //       "last_price" => "38026",
        //       "mark_price" => "37985.6",
        //       "index_price" => "37954.92",
        //       "funding_rate_indicative" => "0.000219",
        //       "mark_price_round" => "0.01",
        //       "funding_offset" => 0,
        //       "in_delisting" => false,
        //       "risk_limit_base" => "1000000",
        //       "interest_rate" => "0.0003",
        //       "order_price_round" => "0.1",
        //       "order_size_min" => 1,
        //       "ref_rebate_rate" => "0.2",
        //       "funding_interval" => 28800,
        //       "risk_limit_step" => "1000000",
        //       "leverage_min" => "1",
        //       "leverage_max" => "100",
        //       "risk_limit_max" => "8000000",
        //       "maker_fee_rate" => "-0.00025",
        //       "taker_fee_rate" => "0.00075",
        //       "funding_rate" => "0.002053",
        //       "order_size_max" => 1000000,
        //       "funding_next_apply" => 1610035200,
        //       "short_users" => 977,
        //       "config_change_time" => 1609899548,
        //       "trade_size" => 28530850594,
        //       "position_size" => 5223816,
        //       "long_users" => 455,
        //       "funding_impact_value" => "60000",
        //       "orders_limit" => 50,
        //       "trade_id" => 10851092,
        //       "orderbook_id" => 2129638396
        //     }
        //   )
        //
        return $this->parse_funding_rate($response);
    }

    public function fetch_funding_rates($symbols = null, $params = array ()) {
        yield $this->load_markets();
        $settle = $this->safe_string_lower($params, 'settle');
        $request = array(
            'settle' => $settle,
        );
        $response = yield $this->publicFuturesGetSettleContracts (array_merge($request, $params));
        //
        // array(
        //     {
        //       "name" => "BTC_USDT",
        //       "type" => "direct",
        //       "quanto_multiplier" => "0.0001",
        //       "ref_discount_rate" => "0",
        //       "order_price_deviate" => "0.5",
        //       "maintenance_rate" => "0.005",
        //       "mark_type" => "index",
        //       "last_price" => "38026",
        //       "mark_price" => "37985.6",
        //       "index_price" => "37954.92",
        //       "funding_rate_indicative" => "0.000219",
        //       "mark_price_round" => "0.01",
        //       "funding_offset" => 0,
        //       "in_delisting" => false,
        //       "risk_limit_base" => "1000000",
        //       "interest_rate" => "0.0003",
        //       "order_price_round" => "0.1",
        //       "order_size_min" => 1,
        //       "ref_rebate_rate" => "0.2",
        //       "funding_interval" => 28800,
        //       "risk_limit_step" => "1000000",
        //       "leverage_min" => "1",
        //       "leverage_max" => "100",
        //       "risk_limit_max" => "8000000",
        //       "maker_fee_rate" => "-0.00025",
        //       "taker_fee_rate" => "0.00075",
        //       "funding_rate" => "0.002053",
        //       "order_size_max" => 1000000,
        //       "funding_next_apply" => 1610035200,
        //       "short_users" => 977,
        //       "config_change_time" => 1609899548,
        //       "trade_size" => 28530850594,
        //       "position_size" => 5223816,
        //       "long_users" => 455,
        //       "funding_impact_value" => "60000",
        //       "orders_limit" => 50,
        //       "trade_id" => 10851092,
        //       "orderbook_id" => 2129638396
        //     }
        //   )
        //
        $result = $this->parse_funding_rates($response);
        return $this->filter_by_array($result, 'symbol', $symbols);
    }

    public function parse_funding_rate($contract, $market = null) {
        //
        //     {
        //       "name" => "BTC_USDT",
        //       "type" => "direct",
        //       "quanto_multiplier" => "0.0001",
        //       "ref_discount_rate" => "0",
        //       "order_price_deviate" => "0.5",
        //       "maintenance_rate" => "0.005",
        //       "mark_type" => "index",
        //       "last_price" => "38026",
        //       "mark_price" => "37985.6",
        //       "index_price" => "37954.92",
        //       "funding_rate_indicative" => "0.000219",
        //       "mark_price_round" => "0.01",
        //       "funding_offset" => 0,
        //       "in_delisting" => false,
        //       "risk_limit_base" => "1000000",
        //       "interest_rate" => "0.0003",
        //       "order_price_round" => "0.1",
        //       "order_size_min" => 1,
        //       "ref_rebate_rate" => "0.2",
        //       "funding_interval" => 28800,
        //       "risk_limit_step" => "1000000",
        //       "leverage_min" => "1",
        //       "leverage_max" => "100",
        //       "risk_limit_max" => "8000000",
        //       "maker_fee_rate" => "-0.00025",
        //       "taker_fee_rate" => "0.00075",
        //       "funding_rate" => "0.002053",
        //       "order_size_max" => 1000000,
        //       "funding_next_apply" => 1610035200,
        //       "short_users" => 977,
        //       "config_change_time" => 1609899548,
        //       "trade_size" => 28530850594,
        //       "position_size" => 5223816,
        //       "long_users" => 455,
        //       "funding_impact_value" => "60000",
        //       "orders_limit" => 50,
        //       "trade_id" => 10851092,
        //       "orderbook_id" => 2129638396
        //     }
        //
        $marketId = $this->safe_string($contract, 'name');
        $symbol = $this->safe_symbol($marketId, $market);
        $markPrice = $this->safe_number($contract, 'mark_price');
        $indexPrice = $this->safe_number($contract, 'index_price');
        $interestRate = $this->safe_number($contract, 'interest_rate');
        $fundingRate = $this->safe_number($contract, 'funding_rate');
        $fundingTime = $this->safe_integer($contract, 'funding_next_apply') * 1000;
        $fundingRateIndicative = $this->safe_number($contract, 'funding_rate_indicative');
        return array(
            'info' => $contract,
            'symbol' => $symbol,
            'markPrice' => $markPrice,
            'indexPrice' => $indexPrice,
            'interestRate' => $interestRate,
            'estimatedSettlePrice' => null,
            'timestamp' => null,
            'datetime' => null,
            'fundingRate' => $fundingRate,
            'fundingTimestamp' => $fundingTime,
            'fundingDatetime' => $this->iso8601($fundingTime),
            'nextFundingRate' => $fundingRateIndicative,
            'nextFundingTimestamp' => null,
            'nextFundingDatetime' => null,
            'previousFundingRate' => null,
            'previousFundingTimestamp' => null,
            'previousFundingDatetime' => null,
        );
    }

    public function fetch_network_deposit_address($code, $params = array ()) {
        yield $this->load_markets();
        $currency = $this->currency($code);
        $request = array(
            'currency' => $currency['id'],
        );
        $response = yield $this->privateWalletGetDepositAddress (array_merge($request, $params));
        $addresses = $this->safe_value($response, 'multichain_addresses');
        $currencyId = $this->safe_string($response, 'currency');
        $code = $this->safe_currency_code($currencyId);
        $result = array();
        for ($i = 0; $i < count($addresses); $i++) {
            $entry = $addresses[$i];
            //
            //     {
            //       "chain" => "ETH",
            //       "address" => "0x359a697945E79C7e17b634675BD73B33324E9408",
            //       "payment_id" => "",
            //       "payment_name" => "",
            //       "obtain_failed" => "0"
            //     }
            //
            $obtainFailed = $this->safe_integer($entry, 'obtain_failed');
            if ($obtainFailed) {
                continue;
            }
            $network = $this->safe_string($entry, 'chain');
            $address = $this->safe_string($entry, 'address');
            $tag = $this->safe_string($entry, 'payment_id');
            $tagLength = is_array($tag) ? count($tag) : 0;
            $tag = $tagLength ? $tag : null;
            $result[$network] = array(
                'info' => $entry,
                'code' => $code,
                'address' => $address,
                'tag' => $tag,
            );
        }
        return $result;
    }

    public function fetch_deposit_address($code, $params = array ()) {
        yield $this->load_markets();
        $currency = $this->currency($code);
        $request = array(
            'currency' => $currency['id'],
        );
        $response = yield $this->privateWalletGetDepositAddress (array_merge($request, $params));
        //
        //     {
        //       "currency" => "XRP",
        //       "address" => "rHcFoo6a9qT5NHiVn1THQRhsEGcxtYCV4d 391331007",
        //       "multichain_addresses" => array(
        //         {
        //           "chain" => "XRP",
        //           "address" => "rHcFoo6a9qT5NHiVn1THQRhsEGcxtYCV4d",
        //           "payment_id" => "391331007",
        //           "payment_name" => "Tag",
        //           "obtain_failed" => 0
        //         }
        //       )
        //     }
        //
        $currencyId = $this->safe_string($response, 'currency');
        $code = $this->safe_currency_code($currencyId);
        $addressField = $this->safe_string($response, 'address');
        $tag = null;
        $address = null;
        if (mb_strpos($addressField, ' ') !== false) {
            $splitted = explode(' ', $addressField);
            $address = $splitted[0];
            $tag = $splitted[1];
        } else {
            $address = $addressField;
        }
        return array(
            'info' => $response,
            'code' => $code,
            'address' => $address,
            'tag' => $tag,
            'network' => null,
        );
    }

    public function fetch_trading_fees($params = array ()) {
        yield $this->load_markets();
        $response = yield $this->privateWalletGetFee ($params);
        //
        //     {
        //       "user_id" => 1486602,
        //       "taker_fee" => "0.002",
        //       "maker_fee" => "0.002",
        //       "gt_discount" => true,
        //       "gt_taker_fee" => "0.0015",
        //       "gt_maker_fee" => "0.0015",
        //       "loan_fee" => "0.18",
        //       "point_type" => "0",
        //       "futures_taker_fee" => "0.0005",
        //       "futures_maker_fee" => "0"
        //     }
        //
        $result = array();
        $taker = $this->safe_number($response, 'taker_fee');
        $maker = $this->safe_number($response, 'maker_fee');
        for ($i = 0; $i < count($this->symbols); $i++) {
            $symbol = $this->symbols[$i];
            $result[$symbol] = array(
                'maker' => $maker,
                'taker' => $taker,
                'info' => $response,
                'symbol' => $symbol,
            );
        }
        return $result;
    }

    public function fetch_funding_fees($params = array ()) {
        yield $this->load_markets();
        $response = yield $this->privateWalletGetWithdrawStatus ($params);
        //
        //     {
        //       "currency" => "MTN",
        //       "name" => "Medicalchain",
        //       "name_cn" => "Medicalchain",
        //       "deposit" => "0",
        //       "withdraw_percent" => "0%",
        //       "withdraw_fix" => "900",
        //       "withdraw_day_limit" => "500000",
        //       "withdraw_day_limit_remain" => "500000",
        //       "withdraw_amount_mini" => "900.1",
        //       "withdraw_eachtime_limit" => "90000000000",
        //       "withdraw_fix_on_chains" => {
        //         "ETH" => "900"
        //       }
        //     }
        //
        $withdrawFees = array();
        for ($i = 0; $i < count($response); $i++) {
            $entry = $response[$i];
            $currencyId = $this->safe_string($entry, 'currency');
            $code = $this->safe_currency_code($currencyId);
            $withdrawFees[$code] = array();
            $withdrawFix = $this->safe_value($entry, 'withdraw_fix_on_chains');
            if ($withdrawFix === null) {
                $withdrawFix = array();
                $withdrawFix[$code] = $this->safe_number($entry, 'withdraw_fix');
            }
            $keys = is_array($withdrawFix) ? array_keys($withdrawFix) : array();
            for ($i = 0; $i < count($keys); $i++) {
                $key = $keys[$i];
                $withdrawFees[$code][$key] = $this->parse_number($withdrawFix[$key]);
            }
        }
        return array(
            'info' => $response,
            'withdraw' => $withdrawFees,
            'deposit' => array(),
        );
    }

    public function fetch_funding_history($symbol = null, $since = null, $limit = null, $params = array ()) {
        if ($symbol === null) {
            throw new ArgumentsRequired($this->id . ' fetchFundingHistory() requires a $symbol argument');
        }
        yield $this->load_markets();
        // $defaultType = 'future';
        $market = $this->market($symbol);
        $request = $this->prepare_request($market);
        $request['type'] = 'fund';  // 'dnw' 'pnl' 'fee' 'refr' 'fund' 'point_dnw' 'point_fee' 'point_refr'
        if ($since !== null) {
            $request['from'] = $since;
        }
        if ($limit !== null) {
            $request['limit'] = $limit;
        }
        $method = $this->get_supported_mapping($market['type'], array(
            'swap' => 'privateFuturesGetSettleAccountBook',
            'future' => 'privateDeliveryGetSettleAccountBook',
        ));
        $response = yield $this->$method (array_merge($request, $params));
        $result = array();
        for ($i = 0; $i < count($response); $i++) {
            $entry = $response[$i];
            $timestamp = $this->safe_timestamp($entry, 'time');
            $result[] = array(
                'info' => $entry,
                'symbol' => $symbol,
                'code' => $this->safe_currency_code($this->safe_string($entry, 'text')),
                'timestamp' => $timestamp,
                'datetime' => $this->iso8601($timestamp),
                'id' => null,
                'amount' => $this->safe_number($entry, 'change'),
            );
        }
        $sorted = $this->sort_by($result, 'timestamp');
        return $this->filter_by_symbol_since_limit($sorted, $symbol, $since, $limit);
    }

    public function fetch_order_book($symbol, $limit = null, $params = array ()) {
        yield $this->load_markets();
        $market = $this->market($symbol);
        //
        //     $request = array(
        //         'currency_pair' => $market['id'],
        //         'interval' => '0', // depth, 0 means no aggregation is applied, default to 0
        //         'limit' => $limit, // maximum number of order depth data in asks or bids
        //         'with_id' => true, // return order book ID
        //     );
        //
        $request = $this->prepare_request($market);
        $spotOrMargin = $market['spot'] || $market['margin'];
        $method = $this->get_supported_mapping($market['type'], array(
            'spot' => 'publicSpotGetOrderBook',
            'margin' => 'publicSpotGetOrderBook',
            'swap' => 'publicFuturesGetSettleOrderBook',
            'future' => 'publicDeliveryGetSettleOrderBook',
        ));
        if ($limit !== null) {
            $request['limit'] = $limit; // default 10, max 100
        }
        $response = yield $this->$method (array_merge($request, $params));
        //
        // SPOT
        //
        //     {
        //         "current" => 1634345973275,
        //         "update" => 1634345973271,
        //         "asks" => [
        //             ["2.2241","12449.827"],
        //             ["2.2242","200"],
        //             ["2.2244","826.931"],
        //             ["2.2248","3876.107"],
        //             ["2.225","2377.252"],
        //             ["2.22509","439.484"],
        //             ["2.2251","1489.313"],
        //             ["2.2253","714.582"],
        //             ["2.2254","1349.784"],
        //             ["2.2256","234.701"]],
        //          "bids":[
        //             ["2.2236","32.465"],
        //             ["2.2232","243.983"],
        //             ["2.2231","32.207"],
        //             ["2.223","449.827"],
        //             ["2.2228","7.918"],
        //             ["2.2227","12703.482"],
        //             ["2.2226","143.033"],
        //             ["2.2225","143.027"],
        //             ["2.2224","1369.352"],
        //             ["2.2223","756.063"]
        //         ]
        //     }
        //
        // Perpetual Swap
        //
        //     {
        //         "current" => 1634350208.745,
        //         "asks" => array(
        //             array("s":24909,"p" => "61264.8"),
        //             array("s":81,"p" => "61266.6"),
        //             array("s":2000,"p" => "61267.6"),
        //             array("s":490,"p" => "61270.2"),
        //             array("s":12,"p" => "61270.4"),
        //             array("s":11782,"p" => "61273.2"),
        //             array("s":14666,"p" => "61273.3"),
        //             array("s":22541,"p" => "61273.4"),
        //             array("s":33,"p" => "61273.6"),
        //             array("s":11980,"p" => "61274.5")
        //         ),
        //         "bids" => array(
        //             array("s":41844,"p" => "61264.7"),
        //             array("s":13783,"p" => "61263.3"),
        //             array("s":1143,"p" => "61259.8"),
        //             array("s":81,"p" => "61258.7"),
        //             array("s":2471,"p" => "61257.8"),
        //             array("s":2471,"p" => "61257.7"),
        //             array("s":2471,"p" => "61256.5"),
        //             array("s":3,"p" => "61254.2"),
        //             array("s":114,"p" => "61252.4"),
        //             array("s":14372,"p" => "61248.6")
        //         ),
        //         "update" => 1634350208.724
        //     }
        //
        $timestamp = $this->safe_integer($response, 'current');
        if (!$spotOrMargin) {
            $timestamp = $timestamp * 1000;
        }
        $priceKey = $spotOrMargin ? 0 : 'p';
        $amountKey = $spotOrMargin ? 1 : 's';
        return $this->parse_order_book($response, $symbol, $timestamp, 'bids', 'asks', $priceKey, $amountKey);
    }

    public function fetch_ticker($symbol, $params = array ()) {
        yield $this->load_markets();
        $market = $this->market($symbol);
        $request = $this->prepare_request($market);
        $method = $this->get_supported_mapping($market['type'], array(
            'spot' => 'publicSpotGetTickers',
            'margin' => 'publicSpotGetTickers',
            'swap' => 'publicFuturesGetSettleTickers',
            'future' => 'publicDeliveryGetSettleTickers',
        ));
        $response = yield $this->$method (array_merge($request, $params));
        $ticker = $this->safe_value($response, 0);
        return $this->parse_ticker($ticker, $market);
    }

    public function parse_ticker($ticker, $market = null) {
        //
        //  SPOT
        //
        //     {
        //         "currency_pair" => "KFC_USDT",
        //         "last" => "7.255",
        //         "lowest_ask" => "7.298",
        //         "highest_bid" => "7.218",
        //         "change_percentage" => "-1.18",
        //         "base_volume" => "1219.053687865",
        //         "quote_volume" => "8807.40299875455",
        //         "high_24h" => "7.262",
        //         "low_24h" => "7.095"
        //     }
        //
        //  LINEAR/DELIVERY
        //
        //     {
        //         "contract" => "BTC_USDT",
        //         "last" => "6432",
        //         "low_24h" => "6278",
        //         "high_24h" => "6790",
        //         "change_percentage" => "4.43",
        //         "total_size" => "32323904",
        //         "volume_24h" => "184040233284",
        //         "volume_24h_btc" => "28613220",
        //         "volume_24h_usd" => "184040233284",
        //         "volume_24h_base" => "28613220",
        //         "volume_24h_quote" => "184040233284",
        //         "volume_24h_settle" => "28613220",
        //         "mark_price" => "6534",
        //         "funding_rate" => "0.0001",
        //         "funding_rate_indicative" => "0.0001",
        //         "index_price" => "6531"
        //     }
        //
        $marketId = $this->safe_string_2($ticker, 'currency_pair', 'contract');
        $symbol = $this->safe_symbol($marketId, $market);
        $last = $this->safe_string($ticker, 'last');
        $ask = $this->safe_string($ticker, 'lowest_ask');
        $bid = $this->safe_string($ticker, 'highest_bid');
        $high = $this->safe_string($ticker, 'high_24h');
        $low = $this->safe_string($ticker, 'low_24h');
        $baseVolume = $this->safe_string_2($ticker, 'base_volume', 'volume_24h_base');
        $quoteVolume = $this->safe_string_2($ticker, 'quote_volume', 'volume_24h_quote');
        $percentage = $this->safe_string($ticker, 'change_percentage');
        return $this->safe_ticker(array(
            'symbol' => $symbol,
            'timestamp' => null,
            'datetime' => null,
            'high' => $high,
            'low' => $low,
            'bid' => $bid,
            'bidVolume' => null,
            'ask' => $ask,
            'askVolume' => null,
            'vwap' => null,
            'open' => null,
            'close' => $last,
            'last' => $last,
            'previousClose' => null,
            'change' => null,
            'percentage' => $percentage,
            'average' => null,
            'baseVolume' => $baseVolume,
            'quoteVolume' => $quoteVolume,
            'info' => $ticker,
        ), $market, false);
    }

    public function fetch_tickers($symbols = null, $params = array ()) {
        yield $this->load_markets();
        $type = null;
        list($type, $params) = $this->handle_market_type_and_params('fetchTickers', null, $params);
        $method = $this->get_supported_mapping($type, array(
            'spot' => 'publicSpotGetTickers',
            'margin' => 'publicSpotGetTickers',
            'swap' => 'publicFuturesGetSettleTickers',
            'future' => 'publicDeliveryGetSettleTickers',
        ));
        $request = array();
        $future = $type === 'future';
        $swap = $type === 'swap';
        $defaultSettle = $swap ? 'usdt' : 'btc';
        $settle = $this->safe_string_lower($params, 'settle', $defaultSettle);
        if ($swap || $future) {
            $request['settle'] = $settle;
        }
        $response = yield $this->$method (array_merge($request, $params));
        return $this->parse_tickers($response, $symbols);
    }

    public function fetch_balance_helper($entry) {
        $account = $this->account();
        $account['used'] = $this->safe_string_2($entry, 'locked', 'position_margin');
        $account['free'] = $this->safe_string($entry, 'available');
        return $account;
    }

    public function fetch_balance($params = array ()) {
        // :param $params->type => spot, $margin, crossMargin, $swap or $future
        // :param $params->settle => Settle currency (usdt or btc) for perpetual $swap and $future
        yield $this->load_markets();
        $type = null;
        list($type, $params) = $this->handle_market_type_and_params('fetchBalance', null, $params);
        $swap = $type === 'swap';
        $future = $type === 'future';
        $method = $this->get_supported_mapping($type, array(
            'spot' => 'privateSpotGetAccounts',
            'margin' => 'privateMarginGetAccounts',
            'swap' => 'privateFuturesGetSettleAccounts',
            'future' => 'privateDeliveryGetSettleAccounts',
        ));
        $request = array();
        $response = array();
        if ($swap || $future) {
            $defaultSettle = $swap ? 'usdt' : 'btc';
            $request['settle'] = $this->safe_string_lower($params, 'settle', $defaultSettle);
            $response_item = yield $this->$method (array_merge($request, $params));
            $response = array( $response_item );
        } else {
            $response = yield $this->$method (array_merge($request, $params));
        }
        // Spot
        //
        //     array(
        //         array(
        //             "currency" => "DBC",
        //             "available" => "0",
        //             "locked" => "0"
        //         ),
        //         ...
        //     )
        //
        //  Margin
        //
        //    array(
        //         {
        //             "currency_pair":"DOGE_USDT",
        //             "locked":false,
        //             "risk":"9999.99",
        //             "base" => array(
        //               "currency":"DOGE",
        //               "available":"0",
        //               "locked":"0",
        //               "borrowed":"0",
        //               "interest":"0"
        //             ),
        //             "quote" => array(
        //               "currency":"USDT",
        //               "available":"0.73402",
        //               "locked":"0",
        //               "borrowed":"0",
        //               "interest":"0"
        //             }
        //         ),
        //         ...
        //    )
        //
        //  Perpetual Swap
        //
        //    {
        //       order_margin => "0",
        //       point => "0",
        //       bonus => "0",
        //       history => array(
        //         dnw => "2.1321",
        //         pnl => "11.5351",
        //         refr => "0",
        //         point_fee => "0",
        //         fund => "-0.32340576684",
        //         bonus_dnw => "0",
        //         point_refr => "0",
        //         bonus_offset => "0",
        //         fee => "-0.20132775",
        //         point_dnw => "0",
        //       ),
        //       unrealised_pnl => "13.315100000006",
        //       total => "12.51345151332",
        //       available => "0",
        //       in_dual_mode => false,
        //       currency => "USDT",
        //       position_margin => "12.51345151332",
        //       user => "6333333",
        //     }
        //
        //   Delivery Future
        //
        //     {
        //       order_margin => "0",
        //       point => "0",
        //       history => array(
        //         dnw => "1",
        //         pnl => "0",
        //         refr => "0",
        //         point_fee => "0",
        //         point_dnw => "0",
        //         settle => "0",
        //         settle_fee => "0",
        //         point_refr => "0",
        //         fee => "0",
        //       ),
        //       unrealised_pnl => "0",
        //       total => "1",
        //       available => "1",
        //       currency => "USDT",
        //       position_margin => "0",
        //       user => "6333333",
        //     }
        //
        $margin = $type === 'margin';
        $result = array(
            'info' => $response,
        );
        for ($i = 0; $i < count($response); $i++) {
            $entry = $response[$i];
            if ($margin) {
                $marketId = $this->safe_string($entry, 'currency_pair');
                $symbol = $this->safe_symbol($marketId, null, '_');
                $base = $this->safe_value($entry, 'base', array());
                $quote = $this->safe_value($entry, 'quote', array());
                $baseCode = $this->safe_currency_code($this->safe_string($base, 'currency', array()));
                $quoteCode = $this->safe_currency_code($this->safe_string($quote, 'currency', array()));
                $subResult = array();
                $subResult[$baseCode] = $this->fetch_balance_helper($base);
                $subResult[$quoteCode] = $this->fetch_balance_helper($quote);
                $result[$symbol] = $this->safe_balance($subResult);
            } else {
                $code = $this->safe_currency_code($this->safe_string($entry, 'currency', array()));
                $result[$code] = $this->fetch_balance_helper($entry);
            }
        }
        return $margin ? $result : $this->safe_balance($result);
    }

    public function fetch_ohlcv($symbol, $timeframe = '1m', $since = null, $limit = null, $params = array ()) {
        yield $this->load_markets();
        $market = $this->market($symbol);
        $price = $this->safe_string($params, 'price');
        $request = $this->prepare_request($market);
        $request['interval'] = $this->timeframes[$timeframe];
        $method = 'publicSpotGetCandlesticks';
        if ($market['contract']) {
            $maxLimit = 1999;
            $limit = ($limit === null) ? $maxLimit : min ($limit, $maxLimit);
            if ($market['future']) {
                $method = 'publicDeliveryGetSettleCandlesticks';
            } else if ($market['swap']) {
                $method = 'publicFuturesGetSettleCandlesticks';
            }
            $isMark = ($price === 'mark');
            $isIndex = ($price === 'index');
            if ($isMark || $isIndex) {
                $request['contract'] = $price . '_' . $market['id'];
                $params = $this->omit($params, 'price');
            }
        } else {
            $maxLimit = 1000;
            $limit = ($limit === null) ? $maxLimit : min ($limit, $maxLimit);
            $request['limit'] = $limit;
        }
        if ($since !== null) {
            $duration = $this->parse_timeframe($timeframe);
            $request['from'] = intval($since / 1000);
            $toTimestamp = $this->sum($request['from'], $limit * $duration - 1);
            $currentTimestamp = $this->seconds();
            $request['to'] = min ($toTimestamp, $currentTimestamp);
        }
        $response = yield $this->$method (array_merge($request, $params));
        return $this->parse_ohlcvs($response, $market, $timeframe, $since, $limit);
    }

    public function fetch_mark_ohlcv($symbol, $timeframe = '1m', $since = null, $limit = null, $params = array ()) {
        $request = array(
            'price' => 'mark',
        );
        return yield $this->fetch_ohlcv($symbol, $timeframe, $since, $limit, array_merge($request, $params));
    }

    public function fetch_funding_rate_history($symbol = null, $since = null, $limit = null, $params = array ()) {
        if ($symbol === null) {
            throw new ArgumentsRequired($this->id . ' fetchFundingRateHistory() requires a $symbol argument');
        }
        yield $this->load_markets();
        $market = $this->market($symbol);
        if (!$market['swap']) {
            throw new BadRequest('Funding $rates only exist for swap contracts');
        }
        $request = array(
            'contract' => $market['id'],
            'settle' => $market['settleId'],
        );
        if ($limit !== null) {
            $request['limit'] = $limit;
        }
        $method = 'publicFuturesGetSettleFundingRate';
        $response = yield $this->$method (array_merge($request, $params));
        //
        //     {
        //         "r" => "0.00063521",
        //         "t" => "1621267200000",
        //     }
        //
        $rates = array();
        for ($i = 0; $i < count($response); $i++) {
            $entry = $response[$i];
            $timestamp = $this->safe_timestamp($entry, 't');
            $rates[] = array(
                'info' => $entry,
                'symbol' => $symbol,
                'fundingRate' => $this->safe_number($entry, 'r'),
                'timestamp' => $timestamp,
                'datetime' => $this->iso8601($timestamp),
            );
        }
        $sorted = $this->sort_by($rates, 'timestamp');
        return $this->filter_by_symbol_since_limit($sorted, $symbol, $since, $limit);
    }

    public function fetch_index_ohlcv($symbol, $timeframe = '1m', $since = null, $limit = null, $params = array ()) {
        $request = array(
            'price' => 'index',
        );
        return yield $this->fetch_ohlcv($symbol, $timeframe, $since, $limit, array_merge($request, $params));
    }

    public function parse_ohlcv($ohlcv, $market = null) {
        //
        // Spot $market candles
        //
        //     array(
        //         "1626163200",           // Unix timestamp in seconds
        //         "346711.933138181617",  // Trading volume
        //         "33165.23",             // Close price
        //         "33260",                // Highest price
        //         "33117.6",              // Lowest price
        //         "33184.47"              // Open price
        //     )
        //
        // Mark and Index price candles
        //
        //     {
        //          "t":1632873600,         // Unix timestamp in seconds
        //          "o" => "41025",           // Open price
        //          "h" => "41882.17",         // Highest price
        //          "c" => "41776.92",         // Close price
        //          "l" => "40783.94"          // Lowest price
        //     }
        //
        if (gettype($ohlcv) === 'array' && count(array_filter(array_keys($ohlcv), 'is_string')) == 0) {
            return array(
                $this->safe_timestamp($ohlcv, 0),   // unix timestamp in seconds
                $this->safe_number($ohlcv, 5),      // open price
                $this->safe_number($ohlcv, 3),      // highest price
                $this->safe_number($ohlcv, 4),      // lowest price
                $this->safe_number($ohlcv, 2),      // close price
                $this->safe_number($ohlcv, 1),      // trading volume
            );
        } else {
            // Mark and Index price candles
            return array(
                $this->safe_timestamp($ohlcv, 't'), // unix timestamp in seconds
                $this->safe_number($ohlcv, 'o'),    // open price
                $this->safe_number($ohlcv, 'h'),    // highest price
                $this->safe_number($ohlcv, 'l'),    // lowest price
                $this->safe_number($ohlcv, 'c'),    // close price
                $this->safe_number($ohlcv, 'v'),    // trading volume, null for mark or index price
            );
        }
    }

    public function fetch_trades($symbol, $since = null, $limit = null, $params = array ()) {
        yield $this->load_markets();
        $market = $this->market($symbol);
        //
        // spot
        //
        //     $request = array(
        //         'currency_pair' => $market['id'],
        //         'limit' => $limit, // maximum number of records to be returned in a single list
        //         'last_id' => 'id', // specify list staring point using the id of last record in previous list-query results
        //         'reverse' => false, // true to retrieve records where id is smaller than the specified last_id, false to retrieve records where id is larger than the specified last_id
        //     );
        //
        // swap, future
        //
        //     $request = array(
        //         'settle' => $market['settleId'],
        //         'contract' => $market['id'],
        //         'limit' => $limit, // maximum number of records to be returned in a single list
        //         'last_id' => 'id', // specify list staring point using the id of last record in previous list-query results
        //         'from' => $since / 1000), // starting time in seconds, if not specified, to and $limit will be used to $limit $response items
        //         'to' => $this->seconds(), // end time in seconds, default to current time
        //     );
        //
        $request = $this->prepare_request($market);
        $method = $this->get_supported_mapping($market['type'], array(
            'spot' => 'publicSpotGetTrades',
            'margin' => 'publicSpotGetTrades',
            'swap' => 'publicFuturesGetSettleTrades',
            'future' => 'publicDeliveryGetSettleTrades',
        ));
        if ($limit !== null) {
            $request['limit'] = $limit; // default 100, max 1000
        }
        if ($since !== null && ($market['contract'])) {
            $request['from'] = intval($since / 1000);
        }
        $response = yield $this->$method (array_merge($request, $params));
        //
        // spot
        //
        //     array(
        //         {
        //             id => "1852958144",
        //             create_time => "1634673259",
        //             create_time_ms => "1634673259378.105000",
        //             currency_pair => "ADA_USDT",
        //             side => "sell",
        //             amount => "307.078",
        //             price => "2.104",
        //         }
        //     )
        //
        // perpetual swap
        //
        //     array(
        //         {
        //              size => "2",
        //              id => "2522911",
        //              create_time_ms => "1634673380.182",
        //              create_time => "1634673380.182",
        //              contract => "ADA_USDT",
        //              price => "2.10486",
        //         }
        //     )
        //
        return $this->parse_trades($response, $market, $since, $limit);
    }

    public function fetch_my_trades($symbol = null, $since = null, $limit = null, $params = array ()) {
        if ($symbol === null) {
            throw new ArgumentsRequired($this->id . ' fetchMyTrades() requires a $symbol argument');
        }
        yield $this->load_markets();
        $market = $this->market($symbol);
        //
        //     $request = array(
        //         'currency_pair' => $market['id'],
        //         // 'limit' => $limit,
        //         // 'page' => 0,
        //         // 'order_id' => 'Order ID',
        //         // 'account' => 'spot', // default to spot and margin account if not specified, set to cross_margin to operate against margin account
        //         // 'from' => $since, // default to 7 days before current time
        //         // 'to' => $this->milliseconds(), // default to current time
        //     );
        //
        $request = $this->prepare_request($market);
        if ($limit !== null) {
            $request['limit'] = $limit; // default 100, max 1000
        }
        if ($since !== null) {
            $request['from'] = intval($since / 1000);
            // $request['to'] = $since + 7 * 24 * 60 * 60;
        }
        $method = $this->get_supported_mapping($market['type'], array(
            'spot' => 'privateSpotGetMyTrades',
            'margin' => 'privateSpotGetMyTrades',
            'swap' => 'privateFuturesGetSettleMyTrades',
            'future' => 'privateDeliveryGetSettleMyTrades',
        ));
        $response = yield $this->$method (array_merge($request, $params));
        // SPOT
        // [array(
        //     id => "1851927191",
        //     create_time => "1634333360",
        //     create_time_ms => "1634333360359.901000",
        //     currency_pair => "BTC_USDT",
        //     side => "buy",
        //     role => "taker",
        //     amount => "0.0001",
        //     price => "62547.51",
        //     order_id => "93475897349",
        //     fee => "2e-07",
        //     fee_currency => "BTC",
        //     point_fee => "0",
        //     gt_fee => "0",
        //   )]
        // Perpetual Swap
        // [array(
        //   size => "-13",
        //   order_id => "79723658958",
        //   id => "47612669",
        //   role => "taker",
        //   create_time => "1634600263.326",
        //   contract => "BTC_USDT",
        //   price => "61987.8",
        // )]
        return $this->parse_trades($response, $market, $since, $limit);
    }

    public function parse_trade($trade, $market = null) {
        //
        // public
        //
        //     {
        //         "id" => "1334253759",
        //         "create_time" => "1626342738",
        //         "create_time_ms" => "1626342738331.497000",
        //         "currency_pair" => "BTC_USDT",
        //         "side" => "sell",
        //         "amount" => "0.0022",
        //         "price" => "32452.16"
        //     }
        //
        // private
        //
        //     {
        //         "id" => "218087755",
        //         "create_time" => "1578958740",
        //         "create_time_ms" => "1578958740122.710000",
        //         "currency_pair" => "BTC_USDT",
        //         "side" => "sell",
        //         "role" => "taker",
        //         "amount" => "0.0004",
        //         "price" => "8112.77",
        //         "order_id" => "8445563839",
        //         "fee" => "0.006490216",
        //         "fee_currency" => "USDT",
        //         "point_fee" => "0",
        //         "gt_fee" => "0"
        //     }
        //
        $id = $this->safe_string($trade, 'id');
        $timestampStringContract = $this->safe_string($trade, 'create_time');
        $timestampString = $this->safe_string_2($trade, 'create_time_ms', 'time', $timestampStringContract);
        $timestamp = null;
        if (mb_strpos($timestampString, '.') > 0) {
            $milliseconds = explode('.', $timestampString);
            $timestamp = intval($milliseconds[0]);
        }
        if ($market['contract']) {
            $timestamp = $timestamp * 1000;
        }
        $marketId = $this->safe_string_2($trade, 'currency_pair', 'contract');
        $symbol = $this->safe_symbol($marketId, $market);
        $amountString = $this->safe_string_2($trade, 'amount', 'size');
        $priceString = $this->safe_string($trade, 'price');
        $contractSide = Precise::string_lt($amountString, '0') ? 'sell' : 'buy';
        $amountString = Precise::string_abs($amountString);
        $side = $this->safe_string($trade, 'side', $contractSide);
        $orderId = $this->safe_string($trade, 'order_id');
        $gtFee = $this->safe_string($trade, 'gt_fee');
        $feeCurrency = null;
        $feeCostString = null;
        if ($gtFee === '0') {
            $feeCurrency = $this->safe_string($trade, 'fee_currency');
            $feeCostString = $this->safe_string($trade, 'fee');
        } else {
            $feeCurrency = 'GT';
            $feeCostString = $gtFee;
        }
        $fee = array(
            'cost' => $feeCostString,
            'currency' => $feeCurrency,
        );
        $takerOrMaker = $this->safe_string($trade, 'role');
        return $this->safe_trade(array(
            'info' => $trade,
            'id' => $id,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'symbol' => $symbol,
            'order' => $orderId,
            'type' => null,
            'side' => $side,
            'takerOrMaker' => $takerOrMaker,
            'price' => $priceString,
            'amount' => $amountString,
            'cost' => null,
            'fee' => $fee,
        ), $market);
    }

    public function fetch_deposits($code = null, $since = null, $limit = null, $params = array ()) {
        yield $this->load_markets();
        $request = array();
        $currency = null;
        if ($code !== null) {
            $currency = $this->currency($code);
            $request['currency'] = $currency['id'];
        }
        if ($limit !== null) {
            $request['limit'] = $limit;
        }
        if ($since !== null) {
            $request['from'] = intval($since / 1000);
            $request['to'] = $since + 30 * 24 * 60 * 60;
        }
        $response = yield $this->privateWalletGetDeposits (array_merge($request, $params));
        return $this->parse_transactions($response, $currency);
    }

    public function fetch_withdrawals($code = null, $since = null, $limit = null, $params = array ()) {
        yield $this->load_markets();
        $request = array();
        $currency = null;
        if ($code !== null) {
            $currency = $this->currency($code);
            $request['currency'] = $currency['id'];
        }
        if ($limit !== null) {
            $request['limit'] = $limit;
        }
        if ($since !== null) {
            $request['from'] = intval($since / 1000);
            $request['to'] = $since + 30 * 24 * 60 * 60;
        }
        $response = yield $this->privateWalletGetWithdrawals (array_merge($request, $params));
        return $this->parse_transactions($response, $currency);
    }

    public function withdraw($code, $amount, $address, $tag = null, $params = array ()) {
        list($tag, $params) = $this->handle_withdraw_tag_and_params($tag, $params);
        $this->check_address($address);
        yield $this->load_markets();
        $currency = $this->currency($code);
        $request = array(
            'currency' => $currency['id'],
            'address' => $address,
            'amount' => $this->currency_to_precision($code, $amount),
        );
        if ($tag !== null) {
            $request['memo'] = $tag;
        }
        $networks = $this->safe_value($this->options, 'networks', array());
        $network = $this->safe_string_upper($params, 'network'); // this line allows the user to specify either ERC20 or ETH
        $network = $this->safe_string_lower($networks, $network, $network); // handle ETH>ERC20 alias
        if ($network !== null) {
            $request['chain'] = $network;
            $params = $this->omit($params, 'network');
        }
        $response = yield $this->privateWithdrawalsPost (array_merge($request, $params));
        //
        //     {
        //       "id" => "w13389675",
        //       "currency" => "USDT",
        //       "amount" => "50",
        //       "address" => "TUu2rLFrmzUodiWfYki7QCNtv1akL682p1",
        //       "memo" => null
        //     }
        //
        $currencyId = $this->safe_string($response, 'currency');
        $id = $this->safe_string($response, 'id');
        return array(
            'info' => $response,
            'id' => $id,
            'code' => $this->safe_currency_code($currencyId),
            'amount' => $this->safe_number($response, 'amount'),
            'address' => $this->safe_string($response, 'address'),
            'tag' => $this->safe_string($response, 'memo'),
        );
    }

    public function parse_transaction_status($status) {
        $statuses = array(
            'PEND' => 'pending',
            'REQUEST' => 'pending',
            'DMOVE' => 'pending',
            'CANCEL' => 'failed',
            'DONE' => 'ok',
        );
        return $this->safe_string($statuses, $status, $status);
    }

    public function parse_transaction_type($type) {
        $types = array(
            'd' => 'deposit',
            'w' => 'withdrawal',
        );
        return $this->safe_string($types, $type, $type);
    }

    public function parse_transaction($transaction, $currency = null) {
        //
        // deposits
        //
        //     {
        //       "id" => "d33361395",
        //       "currency" => "USDT_TRX",
        //       "address" => "TErdnxenuLtXfnMafLbfappYdHtnXQ5U4z",
        //       "amount" => "100",
        //       "txid" => "ae9374de34e558562fe18cbb1bf9ab4d9eb8aa7669d65541c9fa2a532c1474a0",
        //       "timestamp" => "1626345819",
        //       "status" => "DONE",
        //       "memo" => ""
        //     }
        //
        // withdrawals
        $id = $this->safe_string($transaction, 'id');
        $type = null;
        if ($id !== null) {
            $type = $this->parse_transaction_type($id[0]);
        }
        $currencyId = $this->safe_string($transaction, 'currency');
        $code = $this->safe_currency_code($currencyId);
        $amount = $this->safe_number($transaction, 'amount');
        $txid = $this->safe_string($transaction, 'txid');
        $rawStatus = $this->safe_string($transaction, 'status');
        $status = $this->parse_transaction_status($rawStatus);
        $address = $this->safe_string($transaction, 'address');
        $fee = $this->safe_number($transaction, 'fee');
        $tag = $this->safe_string($transaction, 'memo');
        if ($tag === '') {
            $tag = null;
        }
        $timestamp = $this->safe_timestamp($transaction, 'timestamp');
        return array(
            'info' => $transaction,
            'id' => $id,
            'txid' => $txid,
            'currency' => $code,
            'amount' => $amount,
            'network' => null,
            'address' => $address,
            'addressTo' => null,
            'addressFrom' => null,
            'tag' => $tag,
            'tagTo' => null,
            'tagFrom' => null,
            'status' => $status,
            'type' => $type,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'updated' => null,
            'fee' => $fee,
        );
    }

    public function create_order($symbol, $type, $side, $amount, $price = null, $params = array ()) {
        yield $this->load_markets();
        $market = $this->market($symbol);
        $contract = $market['contract'];
        $stopPrice = $this->safe_number($params, 'stopPrice');
        $methodTail = 'Orders';
        $reduceOnly = $this->safe_value_2($params, 'reduce_only', 'reduceOnly');
        $defaultTimeInForce = $this->safe_value_2($params, 'tif', 'time_in_force', 'gtc');
        $timeInForce = $this->safe_value($params, 'timeInForce', $defaultTimeInForce);
        $params = $this->omit($params, array( 'stopPrice', 'reduce_only', 'reduceOnly', 'tif', 'time_in_force', 'timeInForce' ));
        $isLimitOrder = ($type === 'limit');
        $isMarketOrder = ($type === 'market');
        if ($isLimitOrder && $price === null) {
            throw new ArgumentsRequired($this->id . ' createOrder() requires a $price argument for ' . $type . ' orders');
        }
        if ($contract) {
            $amountToPrecision = $this->amount_to_precision($symbol, $amount);
            $signedAmount = ($side === 'sell') ? Precise::string_neg($amountToPrecision) : $amountToPrecision;
            $amount = intval($signedAmount);
            if ($isMarketOrder) {
                $timeInForce = 'ioc';
                $price = 0;
            }
        } else if (!$isLimitOrder) {
            // Gateio doesn't have $market orders for spot
            throw new InvalidOrder($this->id . ' createOrder() does not support ' . $type . ' orders for ' . $market['type'] . ' markets');
        }
        $request = null;
        $trigger = $this->safe_value($params, 'trigger');
        if ($stopPrice === null && $trigger === null) {
            if ($contract) {
                // $contract order
                $request = array(
                    'contract' => $market['id'], // filled in prepareRequest above
                    'size' => $amount, // int64, positive = bid, negative = ask
                    // 'iceberg' => 0, // int64, display size for iceberg order, 0 for non-iceberg, note that you will have to pay the taker fee for the hidden size
                    'price' => $this->price_to_precision($symbol, $price), // 0 for $market order with tif set as ioc
                    // 'close' => false, // true to close the position, with size set to 0
                    // 'reduce_only' => false, // St as true to be reduce-only order
                    // 'tif' => 'gtc', // gtc, ioc, poc PendingOrCancelled == postOnly order
                    // 'text' => $clientOrderId, // 't-abcdef1234567890',
                    // 'auto_size' => '', // close_long, close_short, note size also needs to be set to 0
                    'settle' => $market['settleId'], // filled in prepareRequest above
                );
                if ($reduceOnly !== null) {
                    $request['reduce_only'] = $reduceOnly;
                }
                if ($timeInForce !== null) {
                    $request['tif'] = $timeInForce;
                }
            } else {
                $options = $this->safe_value($this->options, 'createOrder', array());
                $defaultAccount = $this->safe_string($options, 'account', 'spot');
                $account = $this->safe_string($params, 'account', $defaultAccount);
                $params = $this->omit($params, 'account');
                // spot order
                $request = array(
                    // 'text' => $clientOrderId, // 't-abcdef1234567890',
                    'currency_pair' => $market['id'], // filled in prepareRequest above
                    'type' => $type,
                    'account' => $account, // 'spot', 'margin', 'cross_margin'
                    'side' => $side,
                    'amount' => $this->amount_to_precision($symbol, $amount),
                    'price' => $this->price_to_precision($symbol, $price),
                    // 'time_in_force' => 'gtc', // gtc, ioc, poc PendingOrCancelled == postOnly order
                    // 'iceberg' => 0, // $amount to display for the iceberg order, null or 0 for normal orders, set to -1 to hide the order completely
                    // 'auto_borrow' => false, // used in margin or cross margin trading to allow automatic loan of insufficient $amount if balance is not enough
                    // 'auto_repay' => false, // automatic repayment for automatic borrow loan generated by cross margin order, diabled by default
                );
                if ($timeInForce !== null) {
                    $request['time_in_force'] = $timeInForce;
                }
            }
            $clientOrderId = $this->safe_string_2($params, 'text', 'clientOrderId');
            if ($clientOrderId !== null) {
                // user-defined, must follow the rules if not empty
                //     prefixed with t-
                //     no longer than 28 bytes without t- prefix
                //     can only include 0-9, A-Z, a-z, underscores (_), hyphens (-) or dots (.)
                if (strlen($clientOrderId) > 28) {
                    throw new BadRequest($this->id . ' createOrder() $clientOrderId or text param must be up to 28 characters');
                }
                $params = $this->omit($params, array( 'text', 'clientOrderId' ));
                if ($clientOrderId[0] !== 't') {
                    $clientOrderId = 't-' . $clientOrderId;
                }
                $request['text'] = $clientOrderId;
            }
        } else {
            if ($contract) {
                // $contract conditional order
                $rule = ($side === 'sell') ? 1 : 2;
                $request = array(
                    'initial' => array(
                        'contract' => $market['id'],
                        'size' => $amount, // positive = buy, negative = sell, set to 0 to close the position
                        'price' => $this->price_to_precision($symbol, $price), // set to 0 to use $market $price
                        // 'close' => false, // set to true if trying to close the position
                        // 'tif' => 'gtc', // gtc, ioc, if using $market $price, only ioc is supported
                        // 'text' => $clientOrderId, // web, api, app
                        // 'reduce_only' => false,
                    ),
                    'trigger' => array(
                        // 'strategy_type' => 0, // 0 = by $price, 1 = by $price gap, only 0 is supported currently
                        // 'price_type' => 0, // 0 latest deal $price, 1 mark $price, 2 index $price
                        'price' => $this->price_to_precision($symbol, $stopPrice), // $price or gap
                        'rule' => $rule, // 1 means price_type >= $price, 2 means price_type <= $price
                        // 'expiration' => $expiration, how many seconds to wait for the condition to be triggered before cancelling the order
                    ),
                    'settle' => $market['settleId'],
                );
                $expiration = $this->safe_integer($params, 'expiration');
                if ($expiration !== null) {
                    $request['trigger']['expiration'] = $expiration;
                    $params = $this->omit($params, 'expiration');
                }
                if ($reduceOnly !== null) {
                    $request['initial']['reduce_only'] = $reduceOnly;
                }
                if ($timeInForce !== null) {
                    $request['initial']['tif'] = $timeInForce;
                }
            } else {
                // spot conditional order
                $options = $this->safe_value($this->options, 'createOrder', array());
                $defaultAccount = $this->safe_string($options, 'account', 'normal');
                $account = $this->safe_string($params, 'account', $defaultAccount);
                $params = $this->omit($params, 'account');
                $defaultExpiration = $this->safe_integer($options, 'expiration');
                $expiration = $this->safe_integer($params, 'expiration', $defaultExpiration);
                $rule = ($side === 'sell') ? '>=' : '<=';
                $triggerPrice = $this->safe_value($trigger, 'price', $stopPrice);
                $request = array(
                    'trigger' => array(
                        'price' => $this->price_to_precision($symbol, $triggerPrice),
                        'rule' => $rule, // >= triggered when $market $price larger than or equal to $price field, <= triggered when $market $price less than or equal to $price field
                        'expiration' => $expiration, // required, how long (in seconds) to wait for the condition to be triggered before cancelling the order
                    ),
                    'put' => array(
                        'type' => $type,
                        'side' => $side,
                        'price' => $this->price_to_precision($symbol, $price),
                        'amount' => $this->amount_to_precision($symbol, $amount),
                        'account' => $account, // normal, margin
                        'time_in_force' => $timeInForce, // gtc, ioc for taker only
                    ),
                    'market' => $market['id'],
                );
            }
            $methodTail = 'PriceOrders';
        }
        $method = $this->get_supported_mapping($market['type'], array(
            'spot' => 'privateSpotPost' . $methodTail,
            'margin' => 'privateSpotPost' . $methodTail,
            'swap' => 'privateFuturesPostSettle' . $methodTail,
            'future' => 'privateDeliveryPostSettle' . $methodTail,
        ));
        $response = yield $this->$method ($this->deep_extend($request, $params));
        //
        // spot
        //
        //     {
        //         "id":"95282841887",
        //         "text":"apiv4",
        //         "create_time":"1637383156",
        //         "update_time":"1637383156",
        //         "create_time_ms":1637383156017,
        //         "update_time_ms":1637383156017,
        //         "status":"open",
        //         "currency_pair":"ETH_USDT",
        //         "type":"limit",
        //         "account":"spot",
        //         "side":"buy",
        //         "amount":"0.01",
        //         "price":"3500",
        //         "time_in_force":"gtc",
        //         "iceberg":"0",
        //         "left":"0.01",
        //         "fill_price":"0",
        //         "filled_total":"0",
        //         "fee":"0",
        //         "fee_currency":"ETH",
        //         "point_fee":"0",
        //         "gt_fee":"0",
        //         "gt_discount":false,
        //         "rebated_fee":"0",
        //         "rebated_fee_currency":"USDT"
        //     }
        //
        // spot conditional
        //
        //     array("id":5891843)
        //
        // future and perpetual swaps
        //
        //     {
        //         "id":95938572327,
        //         "contract":"ETH_USDT",
        //         "mkfr":"0",
        //         "tkfr":"0.0005",
        //         "tif":"gtc",
        //         "is_reduce_only":false,
        //         "create_time":1637384600.08,
        //         "price":"3000",
        //         "size":1,
        //         "refr":"0",
        //         "left":1,
        //         "text":"api",
        //         "fill_price":"0",
        //         "user":2436035,
        //         "status":"open",
        //         "is_liq":false,
        //         "refu":0,
        //         "is_close":false,
        //         "iceberg":0
        //     }
        //
        // futures and perpetual swaps conditionals
        //
        //     array("id":7615567)
        //
        return $this->parse_order($response, $market);
    }

    public function parse_order_status($status) {
        $statuses = array(
            'filled' => 'closed',
            'cancelled' => 'canceled',
            'liquidated' => 'closed',
        );
        return $this->safe_string($statuses, $status, $status);
    }

    public function parse_order($order, $market = null) {
        //
        // createOrder, spot
        //
        //     {
        //       "id" => "62364648575",
        //       "text" => "apiv4",
        //       "create_time" => "1626354834",
        //       "update_time" => "1626354834",
        //       "create_time_ms" => "1626354833544",
        //       "update_time_ms" => "1626354833544",
        //       "status" => "open",
        //       "currency_pair" => "BTC_USDT",
        //       "type" => "limit",
        //       "account" => "spot",
        //       "side" => "buy",
        //       "amount" => "0.0001",
        //       "price" => "30000",
        //       "time_in_force" => "gtc",
        //       "iceberg" => "0",
        //       "left" => "0.0001",
        //       "fill_price" => "0",
        //       "filled_total" => "0",
        //       "fee" => "0",
        //       "fee_currency" => "BTC",
        //       "point_fee" => "0",
        //       "gt_fee" => "0",
        //       "gt_discount" => true,
        //       "rebated_fee" => "0",
        //       "rebated_fee_currency" => "USDT"
        //     }
        //
        //
        $id = $this->safe_string($order, 'id');
        $clientOrderId = $this->safe_string($order, 'text');
        $marketId = $this->safe_string_2($order, 'currency_pair', 'contract');
        $symbol = $this->safe_symbol($marketId, $market);
        $timestamp = $this->safe_timestamp($order, 'create_time');
        $timestamp = $this->safe_integer($order, 'create_time_ms', $timestamp);
        $lastTradeTimestamp = $this->safe_timestamp($order, 'update_time');
        $lastTradeTimestamp = $this->safe_integer($order, 'update_time_ms', $lastTradeTimestamp);
        $amountRaw = $this->safe_string_2($order, 'amount', 'size');
        $amount = Precise::string_abs($amountRaw);
        $price = $this->safe_string($order, 'price');
        // $average = $this->safe_string($order, 'fill_price');
        $remaining = $this->safe_string($order, 'left');
        $cost = $this->safe_string($order, 'filled_total'); // same as filled_price
        $rawStatus = null;
        $side = null;
        $contract = $this->safe_value($market, 'contract');
        if ($contract) {
            if ($amount) {
                $side = Precise::string_gt($amountRaw, '0') ? 'buy' : 'sell';
            } else {
                $side = null;
            }
            $rawStatus = $this->safe_string($order, 'finish_as', 'open');
        } else {
            // open, closed, cancelled - almost already ccxt unified!
            $rawStatus = $this->safe_string($order, 'status');
            $side = $this->safe_string($order, 'side');
        }
        $status = $this->parse_order_status($rawStatus);
        $timeInForce = $this->safe_string_upper_2($order, 'time_in_force', 'tif');
        if ($timeInForce === 'POC') {
            $timeInForce = 'PO';
        }
        $type = $this->safe_string($order, 'type');
        if ($type === null) {
            // response for swaps doesn't include the $type information
            if ($timeInForce === 'PO' || $timeInForce === 'GTC' || $timeInForce === 'IOC' || $timeInForce === 'FOK') {
                $type = 'limit';
            } else {
                $type = 'market';
            }
        }
        $fees = array();
        $gtFee = $this->safe_number($order, 'gt_fee');
        if ($gtFee) {
            $fees[] = array(
                'currency' => 'GT',
                'cost' => $gtFee,
            );
        }
        $fee = $this->safe_number($order, 'fee');
        if ($fee) {
            $fees[] = array(
                'currency' => $this->safe_currency_code($this->safe_string($order, 'fee_currency')),
                'cost' => $fee,
            );
        }
        $rebate = $this->safe_string($order, 'rebated_fee');
        if ($rebate) {
            $fees[] = array(
                'currency' => $this->safe_currency_code($this->safe_string($order, 'rebated_fee_currency')),
                'cost' => $this->parse_number(Precise::string_neg($rebate)),
            );
        }
        $mkfr = $this->safe_number($order, 'mkfr');
        $tkfr = $this->safe_number($order, 'tkfr');
        if ($mkfr) {
            $fees[] = array(
                'currency' => $this->safe_currency_code($this->safe_string($order, 'settleId')),
                'cost' => $mkfr,
            );
        }
        if ($tkfr) {
            $fees[] = array(
                'currency' => $this->safe_currency_code($this->safe_string($market, 'settleId')),
                'cost' => $tkfr,
            );
        }
        return $this->safe_order(array(
            'id' => $id,
            'clientOrderId' => $clientOrderId,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'lastTradeTimestamp' => $lastTradeTimestamp,
            'status' => $status,
            'symbol' => $symbol,
            'type' => $type,
            'timeInForce' => $timeInForce,
            'postOnly' => null,
            'side' => $side,
            'price' => $price,
            'stopPrice' => null,
            'average' => null,
            'amount' => $amount,
            'cost' => $cost,
            'filled' => null,
            'remaining' => $remaining,
            'fee' => null,
            'fees' => $fees,
            'trades' => null,
            'info' => $order,
        ), $market);
    }

    public function fetch_order($id, $symbol = null, $params = array ()) {
        if ($symbol === null) {
            throw new ArgumentsRequired($this->id . ' fetchOrder() requires a $symbol argument');
        }
        yield $this->load_markets();
        $market = $this->market($symbol);
        $request = array(
            'order_id' => $id,
        );
        if ($market['spot'] || $market['margin']) {
            $request['currency_pair'] = $market['id'];
        } else {
            $request['settle'] = $market['settleId'];
        }
        $method = $this->get_supported_mapping($market['type'], array(
            'spot' => 'privateSpotGetOrdersOrderId',
            'margin' => 'privateSpotGetOrdersOrderId',
            'swap' => 'privateFuturesGetSettleOrdersOrderId',
            'future' => 'privateDeliveryGetSettlePriceOrdersOrderId',
        ));
        $response = yield $this->$method (array_merge($request, $params));
        return $this->parse_order($response, $market);
    }

    public function fetch_open_orders($symbol = null, $since = null, $limit = null, $params = array ()) {
        yield $this->load_markets();
        $type = null;
        list($type, $params) = $this->handle_market_type_and_params('fetchOpenOrders', null, $params);
        if ($symbol === null && ($type === 'spot') || $type === 'margin' || $type === 'cross_margin') {
            $request = array(
                // 'page' => 1,
                // 'limit' => $limit,
                'account' => $type, // spot/margin (default), cross_margin
            );
            if ($limit !== null) {
                $request['limit'] = $limit;
            }
            $response = yield $this->privateSpotGetOpenOrders (array_merge($request, $params));
            //
            //     array(
            //         {
            //             "currency_pair" => "ETH_BTC",
            //             "total" => 1,
            //             "orders" => array(
            //                 array(
            //                     "id" => "12332324",
            //                     "text" => "t-123456",
            //                     "create_time" => "1548000000",
            //                     "update_time" => "1548000100",
            //                     "currency_pair" => "ETH_BTC",
            //                     "status" => "open",
            //                     "type" => "limit",
            //                     "account" => "spot",
            //                     "side" => "buy",
            //                     "amount" => "1",
            //                     "price" => "5.00032",
            //                     "time_in_force" => "gtc",
            //                     "left" => "0.5",
            //                     "filled_total" => "2.50016",
            //                     "fee" => "0.005",
            //                     "fee_currency" => "ETH",
            //                     "point_fee" => "0",
            //                     "gt_fee" => "0",
            //                     "gt_discount" => false,
            //                     "rebated_fee" => "0",
            //                     "rebated_fee_currency" => "BTC"
            //                 }
            //             )
            //         ),
            //         ...
            //     )
            //
            $allOrders = array();
            for ($i = 0; $i < count($response); $i++) {
                $entry = $response[$i];
                $orders = $this->safe_value($entry, 'orders', array());
                $parsed = $this->parse_orders($orders, null, $since, $limit);
                $allOrders = $this->array_concat($allOrders, $parsed);
            }
            return $this->filter_by_since_limit($allOrders, $since, $limit);
        }
        return yield $this->fetch_orders_by_status('open', $symbol, $since, $limit, $params);
    }

    public function fetch_closed_orders($symbol = null, $since = null, $limit = null, $params = array ()) {
        return yield $this->fetch_orders_by_status('finished', $symbol, $since, $limit, $params);
    }

    public function fetch_orders_by_status($status, $symbol = null, $since = null, $limit = null, $params = array ()) {
        if ($symbol === null) {
            throw new ArgumentsRequired($this->id . ' fetchOrdersByStatus requires a $symbol argument');
        }
        yield $this->load_markets();
        $market = $this->market($symbol);
        $request = $this->prepare_request($market);
        $request['status'] = $status;
        if ($limit !== null) {
            $request['limit'] = $limit;
        }
        if ($since !== null && ($market['spot'] || $market['margin'])) {
            $request['start'] = intval($since / 1000);
        }
        $method = $this->get_supported_mapping($market['type'], array(
            'spot' => 'privateSpotGetOrders',
            'margin' => 'privateSpotGetOrders',
            'swap' => 'privateFuturesGetSettleOrders',
            'future' => 'privateDeliveryGetSettleOrders',
        ));
        if ($market['type'] === 'margin' || $market['type'] === 'cross_margin') {
            $request['account'] = $market['type'];
        }
        $response = yield $this->$method (array_merge($request, $params));
        // SPOT
        // {
        //     "id":"8834234273",
        //     "text" => "3",
        //     "create_time" => "1635406193",
        //     "update_time" => "1635406193",
        //     "create_time_ms" => 1635406193361,
        //     "update_time_ms" => 1635406193361,
        //     "status" => "closed",
        //     "currency_pair" => "BTC_USDT",
        //     "type" => "limit",
        //     "account" => "spot",
        //     "side" => "sell",
        //     "amount" => "0.0002",
        //     "price" => "58904.01",
        //     "time_in_force":"gtc",
        //     "iceberg" => "0",
        //     "left" => "0.0000",
        //     "fill_price" => "11.790516",
        //     "filled_total" => "11.790516",
        //     "fee" => "0.023581032",
        //     "fee_currency" => "USDT",
        //     "point_fee" => "0",
        //     "gt_fee" => "0",
        //     "gt_discount" => false,
        //     "rebated_fee_currency" => "BTC"
        // }
        // Perpetual Swap
        // {
        //     "status" => "finished",
        //     "size":-1,
        //     "left":0,
        //     "id":82750739203,
        //     "is_liq":false,
        //     "is_close":false,
        //     "contract" => "BTC_USDT",
        //     "text" => "web",
        //     "fill_price" => "60721.3",
        //     "finish_as" => "filled",
        //     "iceberg":0,
        //     "tif" => "ioc",
        //     "is_reduce_only":true,
        //     "create_time" => 1635403475.412,
        //     "finish_time" => 1635403475.4127,
        //     "price" => "0"
        // }
        return $this->parse_orders($response, $market, $since, $limit);
    }

    public function cancel_order($id, $symbol = null, $params = array ()) {
        if ($symbol === null) {
            throw new ArgumentsRequired($this->id . ' cancelOrder() requires a $symbol argument');
        }
        yield $this->load_markets();
        $market = $this->market($symbol);
        $request = array(
            'order_id' => $id,
        );
        if ($market['contract']) {
            $request['settle'] = $market['settleId'];
        } else {
            $request['currency_pair'] = $market['id'];
        }
        $method = $this->get_supported_mapping($market['type'], array(
            'spot' => 'privateSpotDeleteOrdersOrderId',
            'margin' => 'privateSpotDeleteOrdersOrderId',
            'swap' => 'privateFuturesDeleteSettleOrdersOrderId',
            'future' => 'privateDeliveryDeleteSettleOrdersOrderId',
        ));
        $response = yield $this->$method (array_merge($request, $params));
        //
        // spot
        //
        //     {
        //         "id":"95282841887",
        //         "text":"apiv4",
        //         "create_time":"1637383156",
        //         "update_time":"1637383235",
        //         "create_time_ms":1637383156017,
        //         "update_time_ms":1637383235085,
        //         "status":"cancelled",
        //         "currency_pair":"ETH_USDT",
        //         "type":"limit",
        //         "account":"spot",
        //         "side":"buy",
        //         "amount":"0.01",
        //         "price":"3500",
        //         "time_in_force":"gtc",
        //         "iceberg":"0",
        //         "left":"0.01",
        //         "fill_price":"0",
        //         "filled_total":"0",
        //         "fee":"0",
        //         "fee_currency":"ETH",
        //         "point_fee":"0",
        //         "gt_fee":"0",
        //         "gt_discount":false,
        //         "rebated_fee":"0",
        //         "rebated_fee_currency":"USDT"
        //     }
        //
        // spot conditional
        //
        //     {
        //         "market":"ETH_USDT",
        //         "user":2436035,
        //         "trigger":array(
        //             "price":"3500",
        //             "rule":"\u003c=",
        //             "expiration":86400
        //         ),
        //         "put":array(
        //             "type":"limit",
        //             "side":"buy",
        //             "price":"3500",
        //             "amount":"0.01000000000000000000",
        //             "account":"normal",
        //             "time_in_force":"gtc"
        //         ),
        //         "id":5891843,
        //         "ctime":1637382379,
        //         "ftime":1637382673,
        //         "status":"canceled"
        //     }
        //
        // perpetual swaps
        //
        //     {
        //         $id => "82241928192",
        //         contract => "BTC_USDT",
        //         mkfr => "0",
        //         tkfr => "0.0005",
        //         tif => "gtc",
        //         is_reduce_only => false,
        //         create_time => "1635196145.06",
        //         finish_time => "1635196233.396",
        //         price => "61000",
        //         size => "4",
        //         refr => "0",
        //         left => "4",
        //         text => "web",
        //         fill_price => "0",
        //         user => "6693577",
        //         finish_as => "cancelled",
        //         status => "finished",
        //         is_liq => false,
        //         refu => "0",
        //         is_close => false,
        //         iceberg => "0",
        //     }
        //
        return $this->parse_order($response, $market);
    }

    public function cancel_all_orders($symbol = null, $params = array ()) {
        yield $this->load_markets();
        $request = array();
        $market = null;
        if ($symbol !== null) {
            $market = $this->market($symbol);
            $request['symbol'] = $market['id'];
        }
        return yield $this->privateSpotDeleteOrders (array_merge($request, $params));
    }

    public function transfer($code, $amount, $fromAccount, $toAccount, $params = array ()) {
        yield $this->load_markets();
        $currency = $this->currency($code);
        $accountsByType = $this->safe_value($this->options, 'accountsByType', array());
        $fromId = $this->safe_string($accountsByType, $fromAccount, $fromAccount);
        $toId = $this->safe_string($accountsByType, $toAccount, $toAccount);
        if ($fromId === null) {
            $keys = is_array($accountsByType) ? array_keys($accountsByType) : array();
            throw new ExchangeError($this->id . ' $fromAccount must be one of ' . implode(', ', $keys));
        }
        if ($toId === null) {
            $keys = is_array($accountsByType) ? array_keys($accountsByType) : array();
            throw new ExchangeError($this->id . ' $toAccount must be one of ' . implode(', ', $keys));
        }
        $truncated = $this->currency_to_precision($code, $amount);
        $request = array(
            'currency' => $currency['id'],
            'from' => $fromId,
            'to' => $toId,
            'amount' => $truncated,
        );
        if (($toId === 'futures') || ($toId === 'delivery') || ($fromId === 'futures') || ($fromId === 'delivery')) {
            $request['settle'] = $currency['lowerCaseId'];
        }
        $response = yield $this->privateWalletPostTransfers (array_merge($request, $params));
        //
        // according to the docs
        //
        //     {
        //       "currency" => "BTC",
        //       "from" => "spot",
        //       "to" => "margin",
        //       "amount" => "1",
        //       "currency_pair" => "BTC_USDT"
        //     }
        //
        // actual $response
        //
        //  POST https://api.gateio.ws/api/v4/wallet/transfers 204 No Content
        //
        return array(
            'info' => $response,
            'from' => $fromId,
            'to' => $toId,
            'amount' => $truncated,
            'code' => $code,
        );
    }

    public function set_leverage($leverage, $symbol = null, $params = array ()) {
        if ($symbol === null) {
            throw new ArgumentsRequired($this->id . ' setLeverage() requires a $symbol argument');
        }
        // WARNING => THIS WILL INCREASE LIQUIDATION PRICE FOR OPEN ISOLATED LONG POSITIONS
        // AND DECREASE LIQUIDATION PRICE FOR OPEN ISOLATED SHORT POSITIONS
        if (($leverage < 0) || ($leverage > 100)) {
            throw new BadRequest($this->id . ' $leverage should be between 1 and 100');
        }
        yield $this->load_markets();
        $market = $this->market($symbol);
        $method = $this->get_supported_mapping($market['type'], array(
            'swap' => 'privateFuturesPostSettlePositionsContractLeverage',
            'future' => 'privateDeliveryPostSettlePositionsContractLeverage',
        ));
        $request = $this->prepare_request($market);
        $request['query'] = array(
            'leverage' => (string) $leverage,
        );
        if (is_array($params) && array_key_exists('cross_leverage_limit', $params)) {
            if ($leverage !== 0) {
                throw new BadRequest($this->id . ' cross margin $leverage(valid only when $leverage is 0)');
            }
            $request['cross_leverage_limit'] = (string) $params['cross_leverage_limit'];
            $params = $this->omit($params, 'cross_leverage_limit');
        }
        $response = yield $this->$method (array_merge($request, $params));
        //
        //     {
        //         "value":"0",
        //         "leverage":"5",
        //         "mode":"single",
        //         "realised_point":"0",
        //         "contract":"BTC_USDT",
        //         "entry_price":"0",
        //         "mark_price":"62035.86",
        //         "history_point":"0",
        //         "realised_pnl":"0",
        //         "close_order":null,
        //         "size":0,
        //         "cross_leverage_limit":"0",
        //         "pending_orders":0,
        //         "adl_ranking":6,
        //         "maintenance_rate":"0.005",
        //         "unrealised_pnl":"0",
        //         "user":2436035,
        //         "leverage_max":"100",
        //         "history_pnl":"0",
        //         "risk_limit":"1000000",
        //         "margin":"0",
        //         "last_close_pnl":"0",
        //         "liq_price":"0"
        //     }
        //
        return $response;
    }

    public function parse_position($position, $market = null) {
        //
        //     {
        //         value => "12.475572",
        //         $leverage => "0",
        //         mode => "single",
        //         realised_point => "0",
        //         $contract => "BTC_USDT",
        //         entry_price => "62422.6",
        //         mark_price => "62377.86",
        //         history_point => "0",
        //         realised_pnl => "-0.00624226",
        //         close_order =>  null,
        //         $size => "2",
        //         cross_leverage_limit => "25",
        //         pending_orders => "0",
        //         adl_ranking => "5",
        //         maintenance_rate => "0.005",
        //         unrealised_pnl => "-0.008948",
        //         user => "663337",
        //         leverage_max => "100",
        //         history_pnl => "14.98868396636",
        //         risk_limit => "1000000",
        //         margin => "0.740721495056",
        //         last_close_pnl => "-0.041996015",
        //         liq_price => "59058.58"
        //     }
        //
        $contract = $this->safe_string($position, 'contract');
        $market = $this->safe_market($contract, $market);
        $size = $this->safe_string($position, 'size');
        $side = null;
        if (Precise::string_gt($size, '0')) {
            $side = 'long';
        } else if (Precise::string_lt($size, '0')) {
            $side = 'short';
        }
        $maintenanceRate = $this->safe_string($position, 'maintenance_rate');
        $notional = $this->safe_string($position, 'value');
        $leverage = $this->safe_string($position, 'leverage');
        $marginType = null;
        if ($leverage === '0') {
            $marginType = 'cross';
        } else {
            $marginType = 'isolated';
        }
        $unrealisedPnl = $this->safe_string($position, 'unrealised_pnl');
        // Initial Position Margin = ( Position Value / Leverage ) . Close Position Fee
        // *The default $leverage under the full $position is the highest $leverage in the $market->
        // *Trading fee is charged as Taker Fee Rate (0.075%).
        $takerFee = '0.00075';
        $feePaid = Precise::string_mul($takerFee, $notional);
        $initialMarginString = Precise::string_add(Precise::string_div($notional, $leverage), $feePaid);
        $percentage = Precise::string_mul(Precise::string_div($unrealisedPnl, $initialMarginString), '100');
        return array(
            'info' => $position,
            'symbol' => $this->safe_string($market, 'symbol'),
            'timestamp' => null,
            'datetime' => null,
            'initialMargin' => $this->parse_number($initialMarginString),
            'initialMarginPercentage' => $this->parse_number(Precise::string_div($initialMarginString, $notional)),
            'maintenanceMargin' => $this->parse_number(Precise::string_mul($maintenanceRate, $notional)),
            'maintenanceMarginPercentage' => $this->parse_number($maintenanceRate),
            'entryPrice' => $this->safe_number($position, 'entry_price'),
            'notional' => $this->parse_number($notional),
            'leverage' => $this->safe_number($position, 'leverage'),
            'unrealizedPnl' => $this->parse_number($unrealisedPnl),
            'contracts' => $this->parse_number($size),
            'contractSize' => $this->safe_value($market, 'contractSize'),
            //     realisedPnl => $position['realised_pnl'],
            'marginRatio' => null,
            'liquidationPrice' => $this->safe_number($position, 'liq_price'),
            'markPrice' => $this->safe_number($position, 'mark_price'),
            'collateral' => $this->safe_number($position, 'margin'),
            'marginType' => $marginType,
            'side' => $side,
            'percentage' => $this->parse_number($percentage),
        );
    }

    public function parse_positions($positions) {
        $result = array();
        for ($i = 0; $i < count($positions); $i++) {
            $result[] = $this->parse_position($positions[$i]);
        }
        return $result;
    }

    public function fetch_positions($symbols = null, $params = array ()) {
        // :param $symbols => Not used by Gateio
        // :param $params:
        //    $settle => The currency that derivative contracts are settled in
        //    Other exchange specific $params
        //
        yield $this->load_markets();
        $defaultType = $this->safe_string_2($this->options, 'fetchPositions', 'defaultType', 'swap');
        $type = $this->safe_string($params, 'type', $defaultType);
        $method = $this->get_supported_mapping($type, array(
            'swap' => 'privateFuturesGetSettlePositions',
            'future' => 'privateDeliveryGetSettlePositions',
        ));
        $defaultSettle = ($type === 'swap') ? 'usdt' : 'btc';
        $settle = $this->safe_string_lower($params, 'settle', $defaultSettle);
        $request = array(
            'settle' => $settle,
        );
        $response = yield $this->$method ($request);
        //
        //     array(
        //         {
        //             value => "12.475572",
        //             leverage => "0",
        //             mode => "single",
        //             realised_point => "0",
        //             contract => "BTC_USDT",
        //             entry_price => "62422.6",
        //             mark_price => "62377.86",
        //             history_point => "0",
        //             realised_pnl => "-0.00624226",
        //             close_order =>  null,
        //             size => "2",
        //             cross_leverage_limit => "25",
        //             pending_orders => "0",
        //             adl_ranking => "5",
        //             maintenance_rate => "0.005",
        //             unrealised_pnl => "-0.008948",
        //             user => "6693577",
        //             leverage_max => "100",
        //             history_pnl => "14.98868396636",
        //             risk_limit => "1000000",
        //             margin => "0.740721495056",
        //             last_close_pnl => "-0.041996015",
        //             liq_price => "59058.58"
        //         }
        //     )
        //
        $result = $this->parse_positions($response);
        return $this->filter_by_array($result, 'symbol', $symbols, false);
    }

    public function sign($path, $api = [], $method = 'GET', $params = array (), $headers = null, $body = null) {
        $authentication = $api[0]; // public, private
        $type = $api[1]; // spot, margin, future, delivery
        $query = $this->omit($params, $this->extract_params($path));
        $path = $this->implode_params($path, $params);
        $endPart = ($path === '') ? '' : ('/' . $path);
        $entirePath = '/' . $type . $endPart;
        $url = $this->urls['api'][$authentication] . $entirePath;
        if ($authentication === 'public') {
            if ($query) {
                $url .= '?' . $this->urlencode($query);
            }
        } else {
            $queryString = '';
            if (($method === 'GET') || ($method === 'DELETE')) {
                if ($query) {
                    $queryString = $this->urlencode($query);
                    $url .= '?' . $queryString;
                }
            } else {
                $urlQueryParams = $this->safe_value($query, 'query', array());
                if ($urlQueryParams) {
                    $queryString = $this->urlencode($urlQueryParams);
                    $url .= '?' . $queryString;
                }
                $query = $this->omit($query, 'query');
                $body = $this->json($query);
            }
            $bodyPayload = ($body === null) ? '' : $body;
            $bodySignature = $this->hash($this->encode($bodyPayload), 'sha512');
            $timestamp = $this->seconds();
            $timestampString = (string) $timestamp;
            $signaturePath = '/api/' . $this->version . $entirePath;
            $payloadArray = array( strtoupper($method), $signaturePath, $queryString, $bodySignature, $timestampString );
            // eslint-disable-next-line quotes
            $payload = implode("\n", $payloadArray);
            $signature = $this->hmac($this->encode($payload), $this->encode($this->secret), 'sha512');
            $headers = array(
                'KEY' => $this->apiKey,
                'Timestamp' => $timestampString,
                'SIGN' => $signature,
                'Content-Type' => 'application/json',
            );
        }
        return array( 'url' => $url, 'method' => $method, 'body' => $body, 'headers' => $headers );
    }

    public function handle_errors($code, $reason, $url, $method, $headers, $body, $response, $requestHeaders, $requestBody) {
        if ($response === null) {
            return;
        }
        //
        //     array("label":"ORDER_NOT_FOUND","message":"Order not found")
        //     array("label":"INVALID_PARAM_VALUE","message":"invalid argument => status")
        //     array("label":"INVALID_PARAM_VALUE","message":"invalid argument => Trigger.rule")
        //     array("label":"INVALID_PARAM_VALUE","message":"invalid argument => trigger.expiration invalid range")
        //     array("label":"INVALID_ARGUMENT","detail":"invalid size")
        //
        $label = $this->safe_string($response, 'label');
        if ($label !== null) {
            $feedback = $this->id . ' ' . $body;
            $this->throw_exactly_matched_exception($this->exceptions['exact'], $label, $feedback);
            throw new ExchangeError($feedback);
        }
    }
}
