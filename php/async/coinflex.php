<?php

namespace ccxt\async;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

use Exception; // a common import
use \ccxt\ExchangeError;
use \ccxt\ArgumentsRequired;
use \ccxt\InvalidOrder;
use \ccxt\OrderNotFound;
use \ccxt\NotSupported;
use \ccxt\Precise;

class coinflex extends Exchange {

    public function describe() {
        return $this->deep_extend(parent::describe (), array(
            'id' => 'coinflex',
            'name' => 'CoinFLEX',
            'countries' => array( 'SC' ), // Seychelles
            'rateLimit' => 120, // 2500 requests per 5 minutes, 100 requests per minute
            'version' => 'v3',
            'certified' => false,
            'userAgent' => $this->userAgents['chrome100'],
            'has' => array(
                'CORS' => null,
                'spot' => true,
                'margin' => null,
                'swap' => true,
                'future' => true,
                'option' => null,
                'addMargin' => null,
                'cancelAllOrders' => true,
                'cancelOrder' => true,
                'cancelOrders' => true,
                'createDepositAddress' => null,
                'createLimitOrder' => true,
                'createMarketOrder' => true,
                'createOrder' => true,
                'createPostOnlyOrder' => null,
                'createStopLimitOrder' => true,
                'createStopMarketOrder' => true,
                'createStopOrder' => true,
                'editOrder' => 'emulated',
                'fetchAccounts' => true,
                'fetchBalance' => true,
                'fetchBidsAsks' => null,
                'fetchBorrowInterest' => null,
                'fetchBorrowRate' => null,
                'fetchBorrowRateHistory' => null,
                'fetchBorrowRates' => null,
                'fetchBorrowRatesPerSymbol' => null,
                'fetchCanceledOrders' => false,
                'fetchClosedOrder' => null,
                'fetchClosedOrders' => false,
                'fetchCurrencies' => true,
                'fetchDeposit' => null,
                'fetchDepositAddress' => true,
                'fetchDepositAddresses' => false,
                'fetchDepositAddressesByNetwork' => false,
                'fetchDeposits' => true,
                'fetchFundingFee' => true,
                'fetchFundingFees' => false,
                'fetchFundingHistory' => true,
                'fetchFundingRate' => 'emulated',
                'fetchFundingRateHistory' => 'emulated',
                'fetchFundingRates' => true,
                'fetchFundingRatesHistory' => true,
                'fetchIndexOHLCV' => null,
                'fetchL2OrderBook' => null,
                'fetchLedger' => null,
                'fetchLedgerEntry' => null,
                'fetchLeverageTiers' => null,
                'fetchMarketLeverageTiers' => null,
                'fetchMarkets' => true,
                'fetchMarkOHLCV' => null,
                'fetchMyTrades' => true,
                'fetchOHLCV' => true,
                'fetchOpenOrder' => null,
                'fetchOpenOrders' => true,
                'fetchOrder' => true, // or maybe emulated, actually getting it from fetchOrders
                'fetchOrderBook' => true,
                'fetchOrderBooks' => null,
                'fetchOrders' => true,
                'fetchOrderTrades' => null,
                'fetchPermissions' => null,
                'fetchPosition' => true,
                'fetchPositions' => true,
                'fetchPositionsRisk' => null,
                'fetchPremiumIndexOHLCV' => null,
                'fetchStatus' => true,
                'fetchTicker' => true,
                'fetchTickers' => true,
                'fetchTime' => null,
                'fetchTrades' => true,
                'fetchTradingFee' => null,
                'fetchTradingFees' => null,
                'fetchTradingLimits' => null,
                'fetchTransactions' => null,
                'fetchTransfers' => true,
                'fetchWithdrawal' => true,
                'fetchWithdrawals' => true,
                'loadMarkets' => true,
                'privateAPI' => true,
                'publicAPI' => true,
                'reduceMargin' => null,
                'setLeverage' => null,
                'setMarginMode' => null,
                'setPositionMode' => null,
                'signIn' => null,
                'transfer' => true,
                'withdraw' => true,
            ),
            'timeframes' => array(
                '1m' => '60s',
                '5m' => '300s',
                '15m' => '900s',
                '30m' => '1800s',
                '1h' => '3600s',
                '2h' => '7200s',
                '4h' => '14400s',
                '1d' => '86400s',
            ),
            'urls' => array(
                'logo' => 'https://user-images.githubusercontent.com/1294454/168937923-80d6af4a-43b5-4ed9-9d53-31065656be4f.jpg',
                'api' => array(
                    'public' => 'https://v2api.coinflex.com',
                    'private' => 'https://v2api.coinflex.com',
                ),
                'www' => 'https://coinflex.com/',
                'doc' => array(
                    'https://docs.coinflex.com/',
                ),
                'fees' => array(
                    'https://coinflex.com/fees/',
                ),
                'test' => array(
                    'public' => 'https://v2stgapi.coinflex.com',
                    'private' => 'https://v2stgapi.coinflex.com',
                ),
                'referral' => 'https://coinflex.com/user-console/register?shareAccountId=S6Y87a8P',
            ),
            'api' => array(
                'public' => array(
                    'get' => array(
                        'v2/all/markets' => 1, // superceded by v3/markets
                        'v2/all/assets' => 1, // superceded by v3/assets
                        'v2/publictrades/{marketCode}' => 1,
                        'v2/ticker' => 1, // superceded by v3/tickers
                        'v2/delivery/public/funding' => 1, // superceded by v3/funding-rates
                        'v2.1/deliver-auction/{instrumentId}' => 1,
                        'v2/candles/{marketCode}' => 1, // superceded by v3/candles
                        'v2/funding-rates/{marketCode}' => 1, // historical funding rates only for 'REPO' symbols (i.e. BTC-USD-REPO-LIN )
                        'v2/depth/{marketCode}/{level}' => 1, // superceded by v3/depth
                        'v2/ping' => 1,
                        'v2/flex-protocol/balances/{flexProtocol}' => 1,
                        'v2/flex-protocol/positions/{flexProtocol}' => 1,
                        'v2/flex-protocol/orders/{flexProtocol}' => 1,
                        'v2/flex-protocol/trades/{flexProtocol}/{marketCode}' => 1,
                        'v2/flex-protocol/delivery/orders/{flexProtocol}' => 1,
                        'v3/markets' => 1,
                        'v3/assets' => 1,
                        'v3/tickers' => 1,
                        'v3/auction' => 1,
                        'v3/funding-rates' => 1,
                        'v3/candles' => 1,
                        'v3/depth' => 1,
                        'v3/flexasset/balances' => 1,
                        'v3/flexasset/positions' => 1,
                        'v3/flexasset/yields' => 1,
                    ),
                    'post' => array(
                        'v3/flexasset/redeem' => 1,
                        'v3/AMM/redeem' => 1,
                    ),
                ),
                'private' => array(
                    'get' => array(
                        'v2/accountinfo' => 1, // superceded by v3/account
                        'v2/balances' => 1, // superceded by v3/account
                        'v2/balances/{instrumentId}' => 1, // superceded by v3/account
                        'v2/positions' => 1,
                        'v2/positions/{instrumentId}' => 1,
                        'v2/trades/{marketCode}' => 1,
                        'v2/orders' => 1,
                        'v2.1/orders' => 1,
                        'v2.1/delivery/orders' => 1,
                        'v2/mint/{asset}' => 1,
                        'v2/redeem/{asset}' => 1,
                        'v2/funding-payments' => 1,
                        'v2/AMM' => 1,
                        'v3/account' => 1,
                        'v3/deposit-addresses' => 1,
                        'v3/deposit' => 1,
                        'v3/withdrawal-addresses' => 1,
                        'v3/withdrawal' => 1,
                        'v3/withdrawal-fee' => 1,
                        'v3/transfer' => 1,
                        'v3/flexasset/mint' => 1,
                        'v3/flexasset/redeem' => 1,
                        'v3/flexasset/earned' => 1,
                        'v3/AMM' => 1,
                        'v3/AMM/balances' => 1,
                        'v3/AMM/positions' => 1,
                        'v3/AMM/orders' => 1,
                        'v3/AMM/trades' => 1,
                        'v3/AMM/hash-token' => 1,
                        'v2/borrow/{asset}' => 1, // TO_DO : Get borrow history by asset (but doesn't match directly to any unified method)
                        'v2/repay/{asset}' => 1, // TO_DO => Get repay history by asset (but doesn't match directly to any unified method)
                        'v2/borrowingSummary' => 1, // TO_DO : Get borrowing summary
                    ),
                    'post' => array(
                        'v2.1/delivery/orders' => 1,
                        'v2/orders/place' => 1, // Note => supports batch/bulk orders
                        'v2/orders/modify' => 1,
                        'v2/mint' => 1,
                        'v2/redeem' => 1,
                        'v2/borrow' => 1, // TO_DO
                        'v2/repay' => 1, // TO_DO
                        'v2/borrow/close' => 1, // TO_DO
                        'v2/AMM/create' => 1,
                        'v2/AMM/redeem' => 1,
                        'v3/withdrawal' => 1,
                        'v3/transfer' => 1,
                        'v3/flexasset/mint' => 1,
                        'v3/AMM/create' => 1,
                    ),
                    'delete' => array(
                        'v2/cancel/orders' => 1,
                        'v2/cancel/orders/{marketCode}' => 1,
                        'v2.1/delivery/orders/{deliveryOrderId}' => 1,
                        'v2/orders/cancel' => 1,
                    ),
                ),
            ),
            'fees' => array(
                'trading' => array(
                    'tierBased' => false,
                    'percentage' => true,
                    'maker' => $this->parse_number('0.000'),
                    'taker' => $this->parse_number('0.008'),
                ),
            ),
            'precisionMode' => TICK_SIZE,
            'options' => array(
                'baseApiDomain' => 'v2api.coinflex.com',
                'defaultType' => 'spot', // spot, swap
                'networks' => array(
                    // 'SOLANA' => 'SPL',
                    'BTC' => 'BTC',
                    'ERC20' => 'ERC20',
                    'BEP20' => 'BEP20',
                ),
                'networksByIds' => array(
                    // 'SPL' => 'SOLANA',
                    'BTC' => 'BTC',
                    'ERC20' => 'ERC20',
                    'BEP20' => 'BEP20',
                ),
            ),
            'commonCurrencies' => array(
            ),
            'exceptions' => array(
                'exact' => array(
                    '40001' => '\\ccxt\\BadRequest',
                    '710003' => '\\ccxt\\InvalidOrder',
                    '25009' => '\\ccxt\\PermissionDenied',
                    '710006' => '\\ccxt\\InsufficientFunds',
                    '40035' => '\\ccxt\\OrderNotFound',
                    '20001' => '\\ccxt\\BadRequest',
                    '25030' => '\\ccxt\\BadRequest',
                    '35034' => '\\ccxt\\BadRequest',
                    '05001' => '\\ccxt\\PermissionDenied',
                    '20020' => '\\ccxt\\InvalidOrder',
                ),
                'broad' => array(
                    'no result, please check your parameters' => '\\ccxt\\BadRequest', // 40001
                    'sanity bound check as price' => '\\ccxt\\InvalidOrder', // 710003
                    '2FA is not turned on' => '\\ccxt\\PermissionDenied', // 25009
                    'balance check as balance' => '\\ccxt\\InsufficientFunds', // 710006
                    'Open order not found with clientOrderId or orderId' => '\\ccxt\\OrderNotFound', // 40035
                    'result not found, please check your parameters' => '\\ccxt\\BadRequest', // 20001
                    'Invalid Code' => '\\ccxt\\BadRequest', // 25030
                    'Wallet API is abnormal, please try again or contact customer service' => '\\ccxt\\BadRequest', // 35034
                    'Unauthorized' => '\\ccxt\\PermissionDenied', // 05001
                    'stopPrice or limitPrice is invalid' => '\\ccxt\\InvalidOrder', // 20020
                ),
            ),
        ));
    }

    public function fetch_status($params = array ()) {
        $response = yield $this->publicGetV2Ping ($params);
        //
        //     array( "success" => "true" )
        //
        $statusRaw = $this->safe_string($response, 'success');
        $status = $this->safe_string(array( 'true' => 'ok', 'false' => 'maintenance' ), $statusRaw, $statusRaw);
        return array(
            'status' => $status,
            'updated' => $this->milliseconds(),
            'eta' => null,
            'url' => null,
            'info' => $response,
        );
    }

    public function fetch_markets($params = array ()) {
        // v3 markets has a few less fields available for $market-objects, but still enough to precede.
        $response = yield $this->publicGetV3Markets ($params);
        //
        //     {
        //         "success" => true,
        //         "data" => array(
        //             array(
        //                 "marketCode" => "BTC-USD",
        //                 "name" => "BTC/USD",
        //                 "referencePair" => "BTC/USD",
        //                 "base" => "BTC",
        //                 "counter" => "USD",
        //                 "type" => "SPOT", // SPOT, FUTURE, REPO, SPREAD
        //                 "tickSize" => "1",
        //                 "minSize" => "0.001",
        //                 "listedAt" => "1593316800000",
        //                 "upperPriceBound" => "40632",
        //                 "lowerPriceBound" => "37506",
        //                 "markPrice" => "39069",
        //                 "lastUpdatedAt" => "1651240365178"
        //             ),
        //
        //         futures/spreads/repo markets just have the same structure, but different namings
        //
        //             array(
        //                 "marketCode" => "BTC-USD-SWAP-LIN",
        //                 "name" => "BTC/USD Perp",
        //                 "referencePair" => "BTC/USD",
        //                 "base" => "BTC",
        //                 "counter" => "USD",
        //                 "type" => "FUTURE",
        //                 ...
        //             ),
        //             array(
        //                 "marketCode" => "BTC-USD-220624-LIN",
        //                 "name" => "BTC/USD Q220624",
        //                 "referencePair" => "BTC/USD",
        //                 "base" => "BTC",
        //                 "counter" => "USD",
        //                 "type" => "FUTURE",
        //                 "settlementAt" => "1656072000000",
        //                 ...
        //             ),
        //             array(
        //                 "marketCode" => "BTC-USD-REPO-LIN",
        //                 "name" => "BTC/USD Repo",
        //                 "referencePair" => "BTC/USD",
        //                 "base" => "BTC-USD",
        //                 "counter" => "BTC-USD-SWAP-LIN",
        //                 "type" => "REPO",
        //                 ...
        //             ),
        //             array(
        //                 "marketCode" => "BTC-USD-SPR-220624P-LIN",
        //                 "name" => "BTC/USD SPR Q220624",
        //                 "referencePair" => "BTC/USD",
        //                 "base" => "BTC-USD-220624-LIN",
        //                 "counter" => "BTC-USD-SWAP-LIN",
        //                 "type" => "SPREAD",
        //                 "settlementAt" => "1656072000000",
        //                 ...
        //             ),
        //         ),
        //     }
        //
        $data = $this->safe_value($response, 'data');
        $result = array();
        for ($i = 0; $i < count($data); $i++) {
            $market = $data[$i];
            $id = $this->safe_string($market, 'marketCode');
            $baseId = $this->safe_string($market, 'base');
            $quoteId = $this->safe_string($market, 'counter');
            $settleId = $this->safe_string($market, 'counter');
            $base = $this->safe_currency_code($baseId);
            $quote = $this->safe_currency_code($quoteId);
            $settle = $this->safe_currency_code($settleId);
            $type = $this->safe_string($market, 'type');
            $settlementTime = $this->safe_integer($market, 'settlementAt');
            $symbol = $base . '/' . $quote;
            $marketType = null;
            $linear = null;
            $inverse = null;
            if ($type === 'SPOT') {
                $marketType = 'spot';
            } else if ($type === 'FUTURE') {
                $inverse = false;
                $linear = true;
                if ($settlementTime === null) {
                    $marketType = 'swap';
                    $symbol .= ':' . $settle;
                } else {
                    $marketType = 'future';
                    $symbol .= ':' . $settle . '-' . $this->yymmdd($settlementTime);
                }
            } else if ($type === 'SPREAD' || $type === 'REPO') {
                $symbol = $id;
            }
            $result[] = array(
                'id' => $id,
                'symbol' => $symbol,
                'base' => $base,
                'quote' => $quote,
                'settle' => $settle,
                'baseId' => $baseId,
                'quoteId' => $quoteId,
                'settleId' => $settleId,
                'type' => $marketType,
                'spot' => $marketType === 'spot',
                'margin' => false,
                'future' => $marketType === 'future',
                'swap' => $marketType === 'swap',
                'option' => false,
                'active' => true,
                'contract' => ($marketType === 'future' || $marketType === 'swap'),
                'linear' => $linear,
                'inverse' => $inverse,
                'contractSize' => null,
                'expiry' => $settlementTime,
                'expiryDatetime' => $this->iso8601($settlementTime),
                'strike' => null,
                'optionType' => null,
                'precision' => array(
                    'amount' => $this->safe_number($market, 'minSize'),
                    'price' => $this->safe_number($market, 'tickSize'),
                ),
                'limits' => array(
                    'leverage' => array(
                        'min' => null,
                        'max' => null,
                    ),
                    'amount' => array(
                        'min' => null,
                        'max' => null,
                    ),
                    'price' => array(
                        'min' => $this->safe_number($market, 'upperPriceBound'),
                        'max' => $this->safe_number($market, 'lowerPriceBound'),
                    ),
                    'cost' => array(
                        'min' => null,
                        'max' => null,
                    ),
                ),
                'info' => $market,
            );
        }
        return $result;
    }

    public function fetch_currencies($params = array ()) {
        $response = yield $this->publicGetV3Assets ($params);
        //
        //     {
        //         "success" => true,
        //         "data" => array(
        //           {
        //             "asset" => "BTC",
        //             "isCollateral" => true,
        //             "loanToValue" => "0.950000000",
        //             "networkList" => array(
        //               array(
        //                 "network" => "BTC",
        //                 "transactionPrecision" => "8",
        //                 "isWithdrawalFeeChargedToUser" => true,
        //                 "canDeposit" => true,
        //                 "canWithdraw" => true,
        //                 "minDeposit" => "0.00010",
        //                 "minWithdrawal" => "0.00010",
        //                 // "tokenId" => "730136783b0cb167727361cd3cbe47bfe3a327e2e91850948d1cb5e2ca8ce7de", // some coins have this prop
        //               }
        //             )
        //           ),
        //         )
        //     }
        //
        $data = $this->safe_value($response, 'data');
        $result = array();
        for ($i = 0; $i < count($data); $i++) {
            $entry = $data[$i];
            $id = $this->safe_string($entry, 'asset');
            $code = $this->safe_currency_code($id);
            $isWithdrawEnabled = true;
            $isDepositEnabled = true;
            $fees = array();
            $networks = array();
            $networkList = $this->safe_value($entry, 'networkList', array());
            $precision = null;
            for ($j = 0; $j < count($networkList); $j++) {
                $networkItem = $networkList[$j];
                $networkId = $this->safe_string($networkItem, 'network');
                // $name = $this->safe_string($networkItem, 'name');
                $depositEnable = $this->safe_value($networkItem, 'canDeposit');
                $withdrawEnable = $this->safe_value($networkItem, 'canWithdraw');
                $isDepositEnabled = $isDepositEnabled || $depositEnable;
                $isWithdrawEnabled = $isWithdrawEnabled || $withdrawEnable;
                $fees[$networkId] = null;
                $precision = $this->safe_string($networkItem, 'transactionPrecision');
                $precision = $this->parse_number($this->parse_precision($precision));
                $networks[$networkId] = array(
                    'id' => $networkId,
                    'network' => $networkId,
                    'active' => $isDepositEnabled && $isWithdrawEnabled,
                    'deposit' => $isDepositEnabled,
                    'withdraw' => $isWithdrawEnabled,
                    'fee' => null,
                    'precision' => $precision,
                    'limits' => array(
                        'deposit' => array(
                            'min' => $this->safe_number($networkItem, 'minDeposit'),
                            'max' => null,
                        ),
                        'withdraw' => array(
                            'min' => $this->safe_number($networkItem, 'minWithdrawal'),
                            'max' => null,
                        ),
                    ),
                    'info' => $networkItem,
                );
            }
            $result[$code] = array(
                'id' => $id,
                'name' => $code,
                'code' => $code,
                'precision' => $precision, // TODO => this need codebase changes, as $precision is network specific, but currencyToPrecision bugs in that case
                'info' => $entry,
                'active' => $isWithdrawEnabled && $isDepositEnabled,
                'deposit' => $isDepositEnabled,
                'withdraw' => $isWithdrawEnabled,
                'fee' => null,
                'fees' => null,
                'limits' => array(
                    'amount' => array(
                        'min' => null,
                        'max' => null,
                    ),
                ),
                'networks' => $networks,
            );
        }
        return $result;
    }

    public function set_start_end_times($request, $since) {
        // exchange has 7 days maximum allowed $distance between start/end times across its api endpoints
        $distance = 7 * 24 * 60 * 60 * 1000; // 7 days
        if ($since === null) {
            $since = $this->sum($this->milliseconds(), $this->timeout) - $distance; // don't directly set 7 days ago from this moment, as when $request arrives at exchange, it will be more than 7 days from 'current time'. so, add timeout seconds to make sure we have enough time to reach exchange.
        }
        $request['startTime'] = $since;
        $currentTs = $this->milliseconds();
        $sinceWithAddedDistance = $this->sum($since, $distance);
        if ($sinceWithAddedDistance < $currentTs) {
            $request['endTime'] = $sinceWithAddedDistance;
        }
        return $request;
    }

    public function fetch_trades($symbol, $since = null, $limit = null, $params = array ()) {
        yield $this->load_markets();
        $market = $this->market($symbol);
        $request = array(
            'marketCode' => $market['id'],
        );
        if ($limit !== null) {
            $request['limit'] = $limit;
        }
        $request = $this->set_start_end_times($request, $since);
        $response = yield $this->publicGetV2PublictradesMarketCode (array_merge($request, $params));
        //
        //     {
        //         "event" => "publicTrades",
        //         "timestamp" => "1651312416050",
        //         "marketCode" => "BTC-USD",
        //         "data" => array(
        //             array(
        //                 "matchId" => "304734619669458401",
        //                 "matchQuantity" => "0.012",
        //                 "matchPrice" => "38673",
        //                 "side" => "BUY",
        //                 "matchTimestamp" => "1651281046230"
        //             ),
        //         )
        //     }
        //
        $trades = $this->safe_value($response, 'data', array());
        return $this->parse_trades($trades, $market, $since, $limit, $params);
    }

    public function fetch_my_trades($symbol = null, $since = null, $limit = null, $params = array ()) {
        if ($symbol === null) {
            throw new ArgumentsRequired($this->id . ' fetchMyTrades() requires a $symbol argument');
        }
        yield $this->load_markets();
        $market = $this->market($symbol);
        $request = array(
            'marketCode' => $market['id'],
        );
        if ($limit !== null) {
            $request['limit'] = $limit;
        }
        $request = $this->set_start_end_times($request, $since);
        $response = yield $this->privateGetV2TradesMarketCode (array_merge($request, $params));
        //
        //     {
        //         "event" => "trades",
        //         "timestamp" => "1651402298537",
        //         "accountId" => "38432",
        //         "data" => array(
        //             {
        //                 "matchId" => "8375163007067643787",
        //                 "matchTimestamp" => "1651342025862",
        //                 "marketCode" => "SHIB-USD-SWAP-LIN",
        //                 "matchQuantity" => "313546",
        //                 "matchPrice" => "0.00002161",
        //                 "total" => "6.77572906",
        //                 "orderMatchType" => "TAKER",
        //                 "fees" => "0.00542058",
        //                 "feeInstrumentId" => "USD",
        //                 "orderId" => "1002109741555",
        //                 "side" => "BUY",
        //                 "clientOrderId" => "1651342025382"
        //             }
        //         )
        //     }
        //
        $trades = $this->safe_value($response, 'data', array());
        return $this->parse_trades($trades, $market, $since, $limit, $params);
    }

    public function parse_trade($trade, $market = null) {
        //
        // fetchTrades
        //
        //     {
        //         "matchId" => "304734619669458401",
        //         "matchQuantity" => "0.012",
        //         "matchPrice" => "38673",
        //         "side" => "BUY",
        //         "matchTimestamp" => "1651281046230"
        //     }
        //
        // fetchMyTrades
        //
        //     {
        //         "matchId" => "8375163007067643787",
        //         "matchQuantity" => "313546",
        //         "matchPrice" => "0.00002161",
        //         "side" => "BUY",
        //         "matchTimestamp" => "1651342025862",
        //         "marketCode" => "SHIB-USD-SWAP-LIN",
        //         "total" => "6.77572906",
        //         "orderMatchType" => "TAKER",
        //         "fees" => "0.00542058",
        //         "feeInstrumentId" => "USD",
        //         "orderId" => "1002109741555",
        //         "clientOrderId" => "1651342025382"
        //     }
        //
        // trades from order-object
        //
        //     {
        //         "8375163007067827477" => {
        //             "matchQuantity" => "334016",
        //             "matchPrice" => "0.00002089",
        //             "timestamp" => "1651410712318",
        //             "orderMatchType" => "TAKER"
        //         }
        //     }
        //
        $marketId = $this->safe_string($trade, 'marketCode');
        $market = $this->safe_market($marketId, $market);
        $id = null;
        $timestamp = null;
        $priceString = null;
        $amountString = null;
        $side = null;
        $cost = null;
        $fee = null;
        $takerOrMakerRaw = null;
        $keys = is_array($trade) ? array_keys($trade) : array();
        $length = is_array($keys) ? count($keys) : 0;
        if ($length === 1) {
            $id = $keys[0];
            $tradeData = $trade[$id];
            $amountString = $this->safe_string($tradeData, 'matchQuantity');
            $priceString = $this->safe_string($tradeData, 'matchPrice');
            $timestamp = $this->safe_integer($tradeData, 'timestamp');
            $takerOrMakerRaw = $this->safe_string($trade, 'orderMatchType');
        } else {
            $id = $this->safe_string($trade, 'matchId');
            $timestamp = $this->safe_integer($trade, 'matchTimestamp');
            $priceString = $this->safe_string($trade, 'matchPrice');
            $amountString = $this->safe_string($trade, 'matchQuantity');
            $side = $this->safe_string_lower($trade, 'side');
            $takerOrMakerRaw = $this->safe_string($trade, 'orderMatchType');
            $cost = $this->safe_number($trade, 'total');
            $feeAmount = $this->safe_string($trade, 'fees');
            if ($feeAmount !== null) {
                $feeCurrency = $this->safe_string($trade, 'feeInstrumentId');
                $fee = array(
                    'currency' => $this->safe_currency_code($feeCurrency, null),
                    'cost' => $feeAmount,
                );
            }
        }
        $takerOrMaker = $this->safe_string(array( 'TAKER' => 'taker', 'MAKER' => 'maker' ), $takerOrMakerRaw, 'taker');
        return $this->safe_trade(array(
            'id' => $id,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'symbol' => $market['symbol'],
            'order' => $this->safe_string($trade, 'orderId'),
            'type' => null,
            'takerOrMaker' => $takerOrMaker,
            'side' => $side,
            'price' => $priceString,
            'amount' => $amountString,
            'cost' => $cost,
            'fee' => $fee,
            'info' => $trade,
        ), $market);
    }

    public function convert_order_side($side) {
        $sides = array(
            'buy' => 'BUY',
            'sell' => 'SELL',
        );
        return $this->safe_string($sides, $side, $side);
    }

    public function parse_order_type($type) {
        $types = array(
            'MARKET' => 'market',
            'LIMIT' => 'limit',
            // 'STOP_LIMIT' => 'stop_limit',
        );
        return $this->safe_string($types, $type, $type);
    }

    public function convert_order_type($type) {
        $types = array(
            'market' => 'MARKET',
            'limit' => 'LIMIT',
        );
        return $this->safe_string($types, $type, $type);
    }

    public function parse_time_in_force($status) {
        $statuses = array(
            'FOK' => 'FOK',
            'IOC' => 'IOC',
            'GTC' => 'GTC',
            'MAKER_ONLY' => 'PO',
            'MAKER_ONLY_REPRICE' => 'PO',
        );
        return $this->safe_string($statuses, $status, $status);
    }

    public function parse_order_status($status) {
        $statuses = array(
            // fetchOrders
            'OrderOpened' => 'open',
            'OrderMatched' => 'closed',
            'OrderClosed' => 'canceled',
            // cancelOrder
            'CANCELED_BY_USER' => 'canceled',
            'CANCELED_ALL_BY_IOC' => 'canceled',
            'CANCELED_BY_MAKER_ONLY' => 'canceled',
            'CANCELED_BY_FOK' => 'canceled',
            'CANCELED_PARTIAL_BY_IOC' => 'canceled',
            'CANCELED_BY_AMEND' => 'canceled',
            // createOrder (during createOrder, cancelation $statuses might also happen)
            'OPEN' => 'open',
            'FILLED' => 'closed',
        );
        return $this->safe_string($statuses, $status, $status);
    }

    public function fetch_tickers($symbols = null, $params = array ()) {
        yield $this->load_markets();
        $response = yield $this->publicGetV3Tickers ($params);
        //
        //     {
        //         "success" => true,
        //         "data" => array(
        //             {
        //                 "marketCode" => "BTC-USD",
        //                 "markPrice" => "38649",
        //                 "open24h" => "38799",
        //                 "high24h" => "39418.0",
        //                 "low24h" => "38176.0",
        //                 "volume24h" => "18650098.7500",
        //                 "currencyVolume24h" => "481.898",
        //                 "openInterest" => "0",
        //                 "lastTradedPrice" => "38632.0",
        //                 "lastTradedQuantity" => "0.001",
        //                 "lastUpdatedAt" => "1651314699020"
        //             }
        //         )
        //     }
        //
        $data = $this->safe_value($response, 'data', array());
        return $this->parse_tickers($data, $symbols, $params);
    }

    public function fetch_ticker($symbol, $params = array ()) {
        yield $this->load_markets();
        $market = $this->market($symbol);
        $request = array(
            'marketCode' => $market['id'],
        );
        $response = yield $this->publicGetV3Tickers (array_merge($request, $params));
        //
        //     {
        //         "success" => true,
        //         "data" => array(
        //             {
        //                 "marketCode" => "BTC-USD",
        //                 "markPrice" => "38649",
        //                 "open24h" => "38799",
        //                 "high24h" => "39418.0",
        //                 "low24h" => "38176.0",
        //                 "volume24h" => "18650098.7500",
        //                 "currencyVolume24h" => "481.898",
        //                 "openInterest" => "0",
        //                 "lastTradedPrice" => "38632.0",
        //                 "lastTradedQuantity" => "0.001",
        //                 "lastUpdatedAt" => "1651314699020"
        //             }
        //         )
        //     }
        //
        $data = $this->safe_value($response, 'data', array());
        $ticker = $this->safe_value($data, 0, array());
        return $this->parse_ticker($ticker, $market);
    }

    public function parse_ticker($ticker, $market = null) {
        //
        //     {
        //         "marketCode" => "BTC-USD",
        //         "markPrice" => "38649",
        //         "open24h" => "38799",
        //         "high24h" => "39418.0",
        //         "low24h" => "38176.0",
        //         "volume24h" => "18650098.7500",
        //         "currencyVolume24h" => "481.898",
        //         "openInterest" => "0",
        //         "lastTradedPrice" => "38632.0",
        //         "lastTradedQuantity" => "0.001",
        //         "lastUpdatedAt" => "1651314699020"
        //     }
        //
        $timestamp = $this->safe_integer($ticker, 'lastUpdatedAt');
        $marketId = $this->safe_string($ticker, 'marketCode');
        $market = $this->safe_market($marketId, $market);
        $close = $this->safe_string($ticker, 'lastTradedPrice');
        $open = $this->safe_string($ticker, 'open24h');
        return $this->safe_ticker(array(
            'symbol' => $market['symbol'],
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'high' => $this->safe_string($ticker, 'high24h'),
            'low' => $this->safe_string($ticker, 'low24h'),
            'bid' => null,
            'bidVolume' => null,
            'ask' => null,
            'askVolume' => null,
            'vwap' => null,
            'open' => $open,
            'close' => $close,
            'last' => $close,
            'previousClose' => null,
            'change' => null,
            'percentage' => null,
            'average' => null,
            'baseVolume' => $this->safe_string($ticker, 'currencyVolume24h'),
            'quoteVolume' => null,
            'info' => $ticker,
        ), $market, false);
    }

    public function fetch_funding_history($symbol = null, $since = null, $limit = null, $params = array ()) {
        yield $this->load_markets();
        $request = array();
        $market = null;
        if ($symbol !== null) {
            $market = $this->market($symbol);
            $request['marketCode'] = $market['id'];
        }
        $request = $this->set_start_end_times($request, $since);
        if ($limit !== null) {
            $request['limit'] = $limit;
        }
        if ($since !== null) {
            $request['startTime'] = $since;
        }
        $response = yield $this->privateGetV2FundingPayments (array_merge($request, $params));
        //
        //     {
        //         "event" => "fundingPayments",
        //         "timestamp" => "1651750925903",
        //         "accountId" => "38422",
        //         "data" => array(
        //             array(
        //                 "marketCode" => "SHIB-USD-SWAP-LIN",
        //                 "payment" => "-0.00007112",
        //                 "rate" => "0.000005",
        //                 "position" => "661287",
        //                 "markPrice" => "0.00002151",
        //                 "timestamp" => "1651420807679"
        //             ),
        //         )
        //     }
        //
        $data = $this->safe_value($response, 'data', array());
        $result = array();
        for ($i = 0; $i < count($data); $i++) {
            $entry = $data[$i];
            $marketId = $this->safe_string($entry, 'marketCode');
            $timestamp = $this->safe_string($entry, 'timestamp');
            $result[] = array(
                'symbol' => $this->safe_symbol($marketId, $market),
                'code' => null,
                'timestamp' => $this->parse8601($timestamp),
                'datetime' => $timestamp,
                'id' => null,
                'amount' => $this->safe_number($entry, 'payment'),
                'info' => $entry,
            );
        }
        $sorted = $this->sort_by($result, 'timestamp');
        return $this->filter_by_symbol_since_limit($sorted, $symbol, $since, $limit);
    }

    public function fetch_funding_rate($symbol, $params = array ()) {
        // TODO => this can be moved as emulated into base
        if ($this->has['fetchFundingRates']) {
            $response = yield $this->fetch_funding_rates(array( $symbol ), $params);
            return $this->safe_value($response, $symbol);
        } else {
            throw new NotSupported($this->id . ' fetchFundingRate() not supported yet');
        }
    }

    public function fetch_funding_rates($symbols = null, $params = array ()) {
        yield $this->load_markets();
        $request = array();
        $market = null;
        if (gettype($symbols) === 'array' && count(array_filter(array_keys($symbols), 'is_string')) == 0 && strlen($symbols) === 1) {
            $market = $this->market($symbols[0]);
            $request['marketCode'] = $market['id'];
        }
        $response = yield $this->publicGetV3FundingRates (array_merge($request, $params));
        //
        //     {
        //         "success" => true,
        //         "data" => array(
        //             array(
        //                 "marketCode" => "BTC-USD-SWAP-LIN",
        //                 "fundingRate" => "0.000005000",
        //                 "netDelivered" => "-18.676",
        //                 "createdAt" => "1651312802926"
        //             ),
        //             array(
        //                 "marketCode" => "BTC-USD-SWAP-LIN",
        //                 "fundingRate" => "0.000005000",
        //                 "netDelivered" => "-19.402",
        //                 "createdAt" => "1651309202926"
        //             ),
        //          )
        //      }
        //
        $data = $this->safe_value($response, 'data', array());
        $latestRates = array();
        $resultedArray = array();
        for ($i = 0; $i < count($data); $i++) {
            $entry = $data[$i];
            $marketId = $this->safe_string($entry, 'marketCode');
            if (!(is_array($latestRates) && array_key_exists($marketId, $latestRates))) {
                $latestRates[$marketId] = true;
                $resultedArray[] = $entry;
            }
        }
        return $this->parse_funding_rates($resultedArray, $market);
    }

    public function fetch_funding_rate_history($symbol, $since = null, $limit = null, $params = array ()) {
        // TODO => this can be moved as emulated into base
        if ($this->has['fetchFundingRatesHistory']) {
            $response = yield $this->fetch_funding_rates_history(array( $symbol ), $since, $limit, $params);
            return $this->filter_by_symbol_since_limit($response, $symbol, $since, $limit);
        } else {
            throw new NotSupported($this->id . ' fetchFundingRateHistory() not supported yet');
        }
    }

    public function fetch_funding_rates_history($symbols = null, $since = null, $limit = null, $params = array ()) {
        yield $this->load_markets();
        $request = array();
        $market = null;
        if (gettype($symbols) === 'array' && count(array_filter(array_keys($symbols), 'is_string')) == 0 && strlen($symbols) === 1) {
            $market = $this->market($symbols[0]);
            $request['marketCode'] = $market['id'];
        }
        $request = $this->set_start_end_times($request, $since);
        if ($limit !== null) {
            $request['limit'] = $limit;
        }
        $response = yield $this->publicGetV3FundingRates (array_merge($request, $params));
        // same response/endtpoint as in fetchFundingRates
        $data = $this->safe_value($response, 'data', array());
        return $this->parse_funding_rate_histories($data, $market, $since, $limit);
    }

    public function parse_funding_rate_histories($response, $market = null, $since = null, $limit = null) {
        $rates = array();
        for ($i = 0; $i < count($response); $i++) {
            $parsed = $this->parse_funding_rate($response[$i], $market);
            $rates[] = $parsed;
        }
        $sorted = $this->sort_by($rates, 'timestamp');
        $symbol = $this->safe_string($market, 'symbol');
        return $this->filter_by_symbol_since_limit($sorted, $symbol, $since, $limit);
    }

    public function parse_funding_rate($contract, $market = null) {
        //
        // fetchFundingRate, fetchFundingRates, fetchFundingRateHistory
        //
        //     {
        //         "marketCode" => "BTC-USD-SWAP-LIN",
        //         "fundingRate" => "0.000005000",
        //         "netDelivered" => "-18.676",
        //         "createdAt" => "1651312802926"
        //     }
        //
        $marketId = $this->safe_string($contract, 'marketCode');
        $fundingDatetime = $this->safe_string($contract, 'createdAt');
        return array(
            'symbol' => $this->safe_symbol($marketId, $market),
            'markPrice' => null,
            'indexPrice' => null,
            'interestRate' => null,
            'estimatedSettlePrice' => null,
            'timestamp' => null,
            'datetime' => null,
            'fundingRate' => $this->safe_number($contract, 'fundingRate'),
            'fundingTimestamp' => $fundingDatetime,
            'fundingDatetime' => $this->iso8601($fundingDatetime),
            'nextFundingRate' => null,
            'nextFundingTimestamp' => null,
            'nextFundingDatetime' => null,
            'previousFundingRate' => null,
            'previousFundingTimestamp' => null,
            'previousFundingDatetime' => null,
            'info' => $contract,
        );
    }

    public function fetch_ohlcv($symbol, $timeframe = '1m', $since = null, $limit = null, $params = array ()) {
        yield $this->load_markets();
        $market = $this->market($symbol);
        $request = array(
            'marketCode' => $market['id'],
            'timeframe' => $this->timeframes[$timeframe],
        );
        if ($limit !== null) {
            $request['limit'] = $limit;
        }
        $request = $this->set_start_end_times($request, $since);
        $response = yield $this->publicGetV3Candles (array_merge($request, $params));
        //
        //     {
        //         "success" => true,
        //         "timeframe" => "3600s",
        //         "data" => array(
        //             array(
        //                 "open" => "38571.00000000",
        //                 "high" => "38604.00000000",
        //                 "low" => "38570.00000000",
        //                 "close" => "38602.00000000",
        //                 "volume" => "722820.88000000",
        //                 "currencyVolume" => "18.74000000",
        //                 "openedAt" => "1651316400000"
        //             ),
        //         )
        //     }
        //
        $data = $this->safe_value($response, 'data', array());
        return $this->parse_ohlcvs($data, $market, $timeframe, $since, $limit);
    }

    public function parse_ohlcv($ohlcv, $market = null) {
        //
        //     {
        //         "open" => "38571.00000000",
        //         "high" => "38604.00000000",
        //         "low" => "38570.00000000",
        //         "close" => "38602.00000000",
        //         "volume" => "722820.88000000",
        //         "currencyVolume" => "18.74000000",
        //         "openedAt" => "1651316400000"
        //     }
        //
        return array(
            $this->safe_integer($ohlcv, 'openedAt'),
            $this->safe_number($ohlcv, 'open'),
            $this->safe_number($ohlcv, 'high'),
            $this->safe_number($ohlcv, 'low'),
            $this->safe_number($ohlcv, 'close'),
            $this->safe_number($ohlcv, 'currencyVolume'),
        );
    }

    public function fetch_order_book($symbol, $limit = null, $params = array ()) {
        yield $this->load_markets();
        $market = $this->market($symbol);
        $request = array(
            'marketCode' => $market['id'],
        );
        if ($limit !== null) {
            $request['level'] = $limit;
        }
        $response = yield $this->publicGetV3Depth (array_merge($request, $params));
        //
        //     {
        //         "success" => true,
        //         "level" => "5",
        //         "data" => {
        //             "marketCode" => "BTC-USD-SWAP-LIN",
        //             "lastUpdatedAt" => "1651322410296",
        //             "asks" => [[38563, 0.312], [38568, 0.001], [38570, 0.001], [38572, 0.002], [38574, 0.001]],
        //             "bids" => [[38562, 0.001], [38558, 0.001], [38556, 0.1], [38555, 0.003], [38554, 0.445]]
        //         }
        //     }
        //
        $orderbook = $this->safe_value($response, 'data', array());
        $timestamp = $this->safe_integer($orderbook, 'lastUpdatedAt');
        return $this->parse_order_book($orderbook, $symbol, $timestamp);
    }

    public function get_account_data($params = array ()) {
        $response = yield $this->privateGetV3Account ($params);
        //
        //     {
        //         "success" => true,
        //         "data" => array(
        //             {
        //                 "accountId" => "38432",
        //                 "name" => "main",
        //                 "accountType" => "LINEAR",
        //                 "balances" => array(
        //                     array(
        //                         "asset" => "USDT",
        //                         "total" => "0.33",
        //                         "available" => "0.33",
        //                         "reserved" => "0",
        //                         "lastUpdatedAt" => "1651233586761"
        //                     ),
        //                 ),
        //                 "positions" => array(
        //                     array(
        //                         "marketCode" => "SHIB-USD-SWAP-LIN",
        //                         "baseAsset" => "SHIB",
        //                         "counterAsset" => "USD",
        //                         "position" => "313546.0",
        //                         "entryPrice" => "0.00002161",
        //                         "markPrice" => "0.00002158",
        //                         "positionPnl" => "-0.009406380",
        //                         "estLiquidationPrice" => "0",
        //                         "lastUpdatedAt" => "1651342025876"
        //                     ),
        //                 ),
        //                 "collateral" => "28.297558",
        //                 "notionalPositionSize" => "6.82903188",
        //                 "portfolioVarMargin" => "0.682589",
        //                 "riskRatio" => "41.5216",
        //                 "maintenanceMargin" => "0.34129450",
        //                 "marginRatio" => "1.20",
        //                 "liquidating" => false,
        //                 "feeTier" => "0",
        //                 "createdAt" => "1651232948406"
        //             }
        //         )
        //     }
        //
        return $this->safe_value($response, 'data', array());
    }

    public function fetch_accounts($params = array ()) {
        yield $this->load_markets();
        $data = yield $this->get_account_data($params);
        $result = array();
        for ($i = 0; $i < count($data); $i++) {
            $account = $data[$i];
            $result[] = array(
                'id' => $this->safe_string($account, 'accountId'),
                'type' => null,
                'code' => null,
                'info' => $account,
            );
        }
        return $result;
    }

    public function fetch_balance($params = array ()) {
        yield $this->load_markets();
        $data = yield $this->get_account_data($params);
        $targetAccount = $this->safe_value($data, 0);
        return $this->parse_balance($targetAccount);
    }

    public function parse_balance($data) {
        $balances = $this->safe_value($data, 'balances');
        $result = array();
        for ($i = 0; $i < count($balances); $i++) {
            $balance = $balances[$i];
            //
            //     {
            //         "asset" => "USDT",
            //         "total" => "0.33",
            //         "available" => "0.33",
            //         "reserved" => "0",
            //         "lastUpdatedAt" => "1651233586761"
            //     }
            //
            $currencyId = $this->safe_string($balance, 'asset');
            $code = $this->safe_currency_code($currencyId);
            $account = $this->account();
            $account['free'] = $this->safe_string($balance, 'available');
            $account['total'] = $this->safe_string($balance, 'total');
            $result[$code] = $account;
        }
        $timestamp = $this->safe_integer($data, 'createdAt');
        $result['timestamp'] = $timestamp;
        $result['datetime'] = $this->iso8601($timestamp);
        return $this->safe_balance($result);
    }

    public function fetch_order($id, $symbol = null, $params = array ()) {
        if ($symbol === null) {
            throw new ArgumentsRequired($this->id . ' fetchOrder() requires a $symbol argument');
        }
        $request = array(
            'orderId' => $id,
        );
        $results = yield $this->fetch_orders($symbol, null, null, array_merge($request, $params));
        $order = $this->safe_value($results, 0);
        if ($order === null) {
            throw new OrderNotFound($this->id . ' $order ' . $id . ' not found');
        }
        return $order;
    }

    public function fetch_orders($symbol = null, $since = null, $limit = null, $params = array ()) {
        yield $this->load_markets();
        $request = array();
        $market = null;
        if ($symbol !== null) {
            $market = $this->market($symbol);
            $request['marketCode'] = $market['id'];
        }
        if ($limit !== null) {
            $request['limit'] = $limit;
        }
        $request = $this->set_start_end_times($request, $since);
        $response = yield $this->privateGetV21Orders (array_merge($request, $params));
        //
        //     {
        //         "event" => "orders",
        //         "timestamp" => "1651410725892",
        //         "accountId" => "38432",
        //         "data" => array(
        //             {
        //                 "status" => "OrderMatched",
        //                 "orderId" => "1002113333774",
        //                 "clientOrderId" => "1651410682769",
        //                 "marketCode" => "SHIB-USD-SWAP-LIN",
        //                 "side" => "BUY",
        //                 "orderType" => "STOP_LIMIT",
        //                 "price" => "0.00002100",
        //                 "lastTradedPrice" => "0.00002089",
        //                 "avgFillPrice" => "0.00002089",
        //                 "stopPrice" => "0.00002055",
        //                 "limitPrice" => "0.00002100",
        //                 "quantity" => "334016",
        //                 "filledQuantity" => "334016",
        //                 "remainQuantity" => "0",
        //                 "matchIds" => array(
        //                     {
        //                         "8375163007067827477" => array(
        //                             "matchQuantity" => "334016",
        //                             "matchPrice" => "0.00002089",
        //                             "timestamp" => "1651410712318",
        //                             "orderMatchType" => "TAKER"
        //                         }
        //                     }
        //                 ),
        //                 "fees" => array(
        //                     "USD" => "-0.00558207"
        //                 ),
        //                 "timeInForce" => "GTC",
        //                 "isTriggered" => "false"
        //             ),
        //         )
        //     }
        $data = $this->safe_value($response, 'data', array());
        return $this->parse_orders($data, $market, $since, $limit, $params);
    }

    public function fetch_open_orders($symbol = null, $since = null, $limit = null, $params = array ()) {
        yield $this->load_markets();
        $market = ($symbol !== null) ? $this->market($symbol) : null;
        $response = yield $this->privateGetV2Orders ($params);
        //
        //     {
        //         "event" => "orders",
        //         "timestamp" => "1651423023567",
        //         "accountId" => "38432",
        //         "data" => array(
        //             {
        //                 "orderId" => "1002114041607",
        //                 "marketCode" => "SHIB-USD-SWAP-LIN",
        //                 "clientOrderId" => "1651422991501",
        //                 "side" => "BUY",
        //                 "orderType" => "LIMIT",
        //                 "quantity" => "400575.0",
        //                 "remainingQuantity" => "400575.0",
        //                 "price" => "0.000019",
        //                 "stopPrice" => null,
        //                 "limitPrice" => "0.000019",
        //                 "orderCreated" => "1651422991179",
        //                 "lastModified" => "1651422991186",
        //                 "lastTradeTimestamp" => "1651422991181",
        //                 "timeInForce" => "MAKER_ONLY"
        //             }
        //         )
        //     }
        //
        $data = $this->safe_value($response, 'data', array());
        return $this->parse_orders($data, $market, $since, $limit, $params);
    }

    public function parse_order($order, $market = null) {
        //
        // fetchOrders
        //
        //     {
        //         "orderId" => "1002113333774",
        //         "clientOrderId" => "1651410682769",
        //         "marketCode" => "SHIB-USD-SWAP-LIN",
        //         "side" => "BUY",
        //         "orderType" => "STOP_LIMIT", // MARKET, STOP_LIMIT, LIMIT
        //         "quantity" => "334016",
        //         "price" => "0.00002100",
        //         "limitPrice" => "0.00002100", // only available for limit types
        //         "stopPrice" => "0.00002055", // only available for stop types
        //         "timeInForce" => "GTC",
        //         "lastTradedPrice" => "0.00002089",
        //         "avgFillPrice" => "0.00002089",
        //         "status" => "OrderMatched", // OrderOpened, OrderMatched, OrderClosed
        //         "filledQuantity" => "334016",
        //         "remainQuantity" => "0",
        //         "matchIds" => array( // only available for filled $order
        //             {
        //                 "8375163007067827477" => {
        //                     "matchQuantity" => "334016",
        //                     "matchPrice" => "0.00002089",
        //                     "timestamp" => "1651410712318",
        //                     "orderMatchType" => "TAKER"
        //                 }
        //             }
        //         ),
        //         "fees" => array(
        //             "USD" => "-0.00558207"
        //         ),
        //         "isTriggered" => "false"
        //     }
        //
        // fetchOpenOrders (last few props are different)
        //
        //     {
        //         "orderId" => "1002114041607",
        //         "clientOrderId" => "1651422991501",
        //         "marketCode" => "SHIB-USD-SWAP-LIN",
        //         "side" => "BUY",
        //         "orderType" => "LIMIT",
        //         "quantity" => "400575.0",
        //         "price" => "0.000019",
        //         "limitPrice" => "0.000019",
        //         "stopPrice" => null,
        //         "timeInForce" => "MAKER_ONLY"
        //         "lastTradeTimestamp" => "1651422991181",
        //         "lastModified" => "1651422991186",
        //         "orderCreated" => "1651422991179",
        //         "remainingQuantity" => "400575.0",
        //      }
        //
        // createOrder
        //
        //     {
        //         "success" => "true",
        //         "timestamp" => "1651620006856",
        //         "clientOrderId" => "1651620006827000",
        //         "orderId" => "1002124426084",
        //         "price" => "0.65",
        //         "quantity" => "8.0",
        //         "side" => "BUY",
        //         "status" => "FILLED", // OPEN, FILLED
        //         "marketCode" => "XRP-USD",
        //         "timeInForce" => "GTC",
        //         "matchId" => "5636974433720947783", // zero if not filled
        //         "lastTradedPrice" => "0.6028", // field not present if $order doesn't have any fills
        //         "matchQuantity" => "8.0", // field not present if $order doesn't have any fills
        //         "orderMatchType" => "TAKER", // field not present if $order doesn't have any fills
        //         "remainQuantity" => "0.0", // field not present if $order doesn't have any fills
        //         "notice" => "OrderMatched",
        //         "orderType" => "LIMIT",
        //         "fees" => "0.003857920", // field not present if $order doesn't have any fills
        //         "feeInstrumentId" => "USD", // field not present if $order doesn't have any fills
        //         "isTriggered" => "false"
        //     }
        //
        // cancelAllOrders
        //
        //     {
        //         "marketCode" => "XRP-USD",
        //         "msg" => "All open orders for the specified $market have been queued for cancellation"
        //     }
        //
        $marketId = $this->safe_string($order, 'marketCode');
        $market = $this->safe_market($marketId, $market);
        $isCreateOrder = (is_array($order) && array_key_exists('timestamp', $order));
        $symbol = $market['symbol'];
        $timestamp = $this->safe_integer_2($order, 'timestamp', 'orderCreated');
        $orderId = $this->safe_string($order, 'orderId');
        $clientOrderId = $this->safe_string($order, 'clientOrderId');
        $statusRaw = $this->safe_string($order, 'status');
        $status = $this->parse_order_status($statusRaw);
        $orderTypeRaw = $this->safe_string($order, 'orderType');
        $orderType = $this->parse_order_type($orderTypeRaw);
        $filledQuantityRaw = $this->safe_string($order, 'filledQuantity');
        if ($isCreateOrder) {
            $filledQuantityRaw = $this->safe_string($order, 'matchQuantity', '0');
        }
        $avgPriceRaw = $this->safe_string($order, 'avgFillPrice');
        $timeInForceRaw = $this->safe_string($order, 'timeInForce');
        $timeInForce = $this->parse_time_in_force($timeInForceRaw);
        $price = $this->safe_string($order, 'price');
        $limitPrice = $this->safe_string($order, 'limitPrice');
        $finalLimitPrice = null;
        if ($isCreateOrder) {
            $finalLimitPrice = $price;
        } else {
            $finalLimitPrice = $limitPrice;
        }
        $trades = $this->safe_value($order, 'matchIds');
        $cost = null;
        if ($avgPriceRaw !== null && $filledQuantityRaw !== null) {
            $cost = Precise::string_mul($avgPriceRaw, $filledQuantityRaw);
        }
        $feesRaw = $this->safe_value($order, 'fees');
        $fees = null;
        if ($feesRaw !== null) {
            if ($isCreateOrder) {
                $fees = array(
                    'currency' => $this->safe_string($order, 'feeInstrumentId'),
                    'fee' => $this->safe_string($order, 'fees'),
                );
            } else {
                $feeKeys = is_array($feesRaw) ? array_keys($feesRaw) : array();
                if (strlen($feeKeys) > 0) {
                    $firstCurrencyId = $feeKeys[0];
                    $fees = array(
                        'currency' => $this->safe_currency($firstCurrencyId),
                        'fee' => $feesRaw[$firstCurrencyId],
                    );
                }
            }
        }
        return $this->safe_order(array(
            'id' => $orderId,
            'symbol' => $symbol,
            'clientOrderId' => $clientOrderId,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'lastTradeTimestamp' => $this->safe_integer($order, 'lastTradeTimestamp'),
            'timeInForce' => $timeInForce,
            'postOnly' => $timeInForce === 'PO',
            'status' => $status,
            'side' => $this->safe_string_lower($order, 'side'),
            'price' => $finalLimitPrice,
            'type' => $orderType,
            'stopPrice' => $this->safe_number($order, 'stopPrice'),
            'amount' => $this->safe_number($order, 'quantity'),
            'filled' => $this->parse_number($filledQuantityRaw),
            'remaining' => $this->safe_number_2($order, 'remainQuantity', 'remainingQuantity'),
            'average' => $this->parse_number($avgPriceRaw),
            'cost' => $this->parse_number($cost),
            'fee' => $fees,
            'trades' => $trades,
            'info' => $order,
        ), $market);
    }

    public function fetch_position($symbol, $params = array ()) {
        yield $this->load_markets();
        $positions = yield $this->fetch_positions(null, $params);
        $array = $this->filter_by_symbol($positions, $symbol);
        return $this->safe_value($array, 0); // exchange doesn't seem to have hedge mode, so the $array will contain only one position per symbol
    }

    public function fetch_positions($symbols = null, $params = array ()) {
        $data = yield $this->get_account_data($params);
        // response sample inside `getAccountData` method
        $this->targetAccount = $this->safe_value($data, 0);
        $positions = $this->safe_value($this->targetAccount, 'positions', array());
        return $this->parse_positions($positions);
    }

    public function parse_positions($positions) {
        $result = array();
        for ($i = 0; $i < count($positions); $i++) {
            $result[] = $this->parse_position($positions[$i]);
        }
        return $result;
    }

    public function parse_position($position, $market = null) {
        //
        //     {
        //         "marketCode" => "SHIB-USD-SWAP-LIN",
        //         "baseAsset" => "SHIB",
        //         "counterAsset" => "USD",
        //         "position" => "313546.0",
        //         "entryPrice" => "0.00002161",
        //         "markPrice" => "0.00002158",
        //         "positionPnl" => "-0.009406380",
        //         "estLiquidationPrice" => "0",
        //         "lastUpdatedAt" => "1651342025876"
        //     }
        //
        //    but $this->targetAccount has also like:
        //
        //     {
        //         "collateral" => "28.297558",
        //         "notionalPositionSize" => "6.82903188",
        //         "portfolioVarMargin" => "0.682589",
        //         "riskRatio" => "41.5216",
        //         "maintenanceMargin" => "0.34129450",
        //         "marginRatio" => "1.20",
        //         "liquidating" => false,
        //         "feeTier" => "0",
        //         "createdAt" => "1651232948406"
        //     }
        //
        $marketId = $this->safe_string($position, 'marketCode');
        $market = $this->safe_market($marketId, $market);
        $contractsString = $this->safe_string($position, 'position');
        $timestamp = null; // $this->safe_integer($position, 'lastUpdatedAt');
        $side = Precise::string_gt($contractsString, '0') ? 'long' : 'short';
        $liquidationPriceString = $this->safe_string($position, 'estLiquidationPrice');
        $entryPriceString = $this->safe_string($position, 'entryPrice');
        $unrealizedPnlString = $this->safe_string($position, 'positionPnl');
        $markPriceString = $this->safe_string($position, 'markPrice');
        return array(
            'id' => null,
            'symbol' => $market['symbol'],
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'initialMargin' => null,
            'initialMarginPercentage' => null,
            'maintenanceMargin' => null,
            'maintenanceMarginPercentage' => null,
            'entryPrice' => $this->parse_number($entryPriceString),
            'notional' => null,
            'leverage' => null,
            'unrealizedPnl' => $this->parse_number($unrealizedPnlString),
            'contracts' => $this->parse_number($contractsString),
            'contractSize' => null,
            'marginRatio' => null,
            'liquidationPrice' => $this->parse_number($liquidationPriceString),
            'markPrice' => $this->parse_number($markPriceString),
            'collateral' => null,
            'marginType' => 'cross', // each account is cross : https://coinflex.com/support/3-4-margin-and-risk-management/
            'side' => $side,
            'percentage' => null,
            'info' => $position,
        );
    }

    public function fetch_deposit_address($code, $params = array ()) {
        yield $this->load_markets();
        $currency = $this->currency($code);
        $request = array(
            'asset' => $currency['id'],
        );
        $networks = $this->safe_value($this->options, 'networks', array());
        $network = $this->safe_string_upper($params, 'network');
        $params = $this->omit($params, 'network');
        $networkId = $this->safe_string($networks, $network, $network);
        if ($networkId === null) {
            throw new ExchangeError($this->id . ' fetchDepositAddress() requires a `$network` parameter');
        }
        $request['network'] = $networkId;
        $response = yield $this->privateGetV3DepositAddresses (array_merge($request, $params));
        //
        //     {
        //         "success" => true,
        //         "data" => {
        //             "address" => "0x5D561479d9665E490894822896c9c45Ea63007EE"
        //         }
        //     }
        //
        $data = $this->safe_value($response, 'data');
        $address = $this->safe_value($data, 'address');
        $this->check_address($address);
        return array(
            'currency' => $code,
            'address' => $address,
            'tag' => null,
            'network' => $network,
            'info' => $response,
        );
    }

    public function fetch_deposits($code = null, $since = null, $limit = null, $params = array ()) {
        yield $this->load_markets();
        $currency = null;
        $request = array();
        if ($code !== null) {
            $currency = $this->currency($code);
            $request['asset'] = $currency['id'];
        }
        if ($limit !== null) {
            $request['limit'] = $limit;
        }
        $request = $this->set_start_end_times($request, $since);
        $data = null;
        try {
            $response = yield $this->privateGetV3Deposit (array_merge($request, $params));
            //
            //     {
            //         "success" => true,
            //         "data" => array(
            //             {
            //                 "id" => "757475245433389059",
            //                 "asset" => "USDT",
            //                 "network" => "ERC20",
            //                 "address" => "0x5D561479d9665E490894822896c9c45Ea63007EE",
            //                 "quantity" => "28.33",
            //                 "status" => "COMPLETED",
            //                 "txId" => "0x6a92c8190b4b56a56fed2f9a8d0d7afd01843c28d0c0a8a5607b974b2fab8b4a",
            //                 "creditedAt" => "1651233499800"
            //             }
            //         )
            //     }
            //
            // Note, when there are no deposit records, you might get:
            //
            //     {
            //         "success" => false,
            //         "code" => "20001",
            //         "message" => "result not found, please check your parameters"
            //     }
            //
            $data = $this->safe_value($response, 'data', array());
        } catch (Exception $e) {
            //
            // Note, when there are no deposit records, you might get:
            //
            //     {
            //         "success" => false,
            //         "code" => "20001", // the $code is not documented, so might be different
            //         "message" => "result not found, please check your parameters"
            //     }
            //
            if ($this->last_json_response) {
                $code = $this->safe_string($this->last_json_response, 'code');
                $message = $this->safe_string($this->last_json_response, 'message');
                if ($code === '20001' || mb_strpos($message, 'result not found') !== false) {
                    $data = array();
                }
            }
        }
        return $this->parse_transactions($data, $currency, $since, $limit, $params);
    }

    public function fetch_withdrawals($code = null, $since = null, $limit = null, $params = array ()) {
        yield $this->load_markets();
        $currency = null;
        $request = array();
        if ($code !== null) {
            $currency = $this->currency($code);
            $request['asset'] = $currency['id'];
        }
        if ($limit !== null) {
            $request['limit'] = $limit;
        }
        $request = $this->set_start_end_times($request, $since);
        $data = null;
        try {
            $response = yield $this->privateGetV3Withdrawal (array_merge($request, $params));
            //
            //     {
            //         "success" => true,
            //         "data" => array(
            //             {
            //                 "id" => "759031388269150209",
            //                 "asset" => "USDT",
            //                 "network" => "ERC20",
            //                 "address" => "0xe8c2d75e0392e32f36e541b868D8AC3148A4DDf8",
            //                 "quantity" => "18",
            //                 "fee" => "8.799600000",
            //                 "status" => "COMPLETED",
            //                 "txId" => "0xc071cd34cb2f60135e709c26219b39523addbb3599818d98dcd5db2bf0115c17",
            //                 "requestedAt" => "1651708397398",
            //                 "completedAt" => "1651708835000"
            //             }
            //         )
            //     }
            //
            $data = $this->safe_value($response, 'data', array());
        } catch (Exception $e) {
            //
            // Note, when there are no withdrawal records, you might get:
            //
            //     {
            //         "success" => false,
            //         "code" => "20001",
            //         "message" => "result not found, please check your parameters"
            //     }
            //
            if ($this->last_json_response) {
                $code = $this->safe_string($this->last_json_response, 'code');
                if ($code === '20001') {
                    $data = array();
                }
            }
        }
        return $this->parse_transactions($data, $currency, $since, $limit, $params);
    }

    public function fetch_withdrawal($id, $code = null, $params = array ()) {
        $request = array(
            'id' => $id,
        );
        $withdrawals = yield $this->fetch_withdrawals($code, null, null, array_merge($request, $params));
        return $this->safe_value($withdrawals, 0); // the target transaction will be the only in array
    }

    public function parse_transaction($transaction, $currency = null) {
        //
        // fetchDeposits
        //
        //     {
        //         "id" => "757475245433389059",
        //         "txId" => "0x6a92c8190b4b56a56fed2f9a8d0d7afd01843c28d0c0a8a5607b974b2fab8b5a",
        //         "asset" => "USDT",
        //         "network" => "ERC20",
        //         "address" => "0x5D561479d9665E490894822896c9c45Ea63007EE",
        //         "quantity" => "28.33",
        //         "status" => "COMPLETED",
        //         "creditedAt" => "1651233499800"
        //    }
        //
        // fetchWithdrawals
        //
        //     {
        //         "id" => "651573911056351237",
        //         "txId" => "38c09755bff75d33304a3cb6ee839fcb78bbb38b6e3e16586f20852cdec4883d",
        //         "asset" => "USDT",
        //         "network" => "ERC20",
        //         "address" => "0x5D561479d9665E490899382896c9c45Ea63007EE",
        //         "quantity" => "36",
        //         "fee" => "5.2324",
        //         "status" => "COMPLETED",
        //         "requestedAt" => "1617940893000",
        //         "completedAt" => "1617940921123"
        //     }
        //
        // withdraw
        //
        //     {
        //         "id" => "759031388269150209",
        //         "asset" => "USDT",
        //         "network" => "ERC20",
        //         "address" => "0xe8c2d73e0312e32f98e541b813D8EC3148A4BAd5",
        //         "quantity" => "18",
        //         "externalFee" => false,
        //         "fee" => "8.7996",
        //         "status" => "PENDING",
        //         "requestedAt" => "1651708397366"
        //     }
        //
        $isDeposit = (is_array($transaction) && array_key_exists('creditedAt', $transaction));
        $id = $this->safe_string($transaction, 'id');
        $txId = $this->safe_string($transaction, 'txId');
        $currencyId = $this->safe_string($transaction, 'asset');
        $currency = $this->safe_currency($currencyId, $currency);
        $networkId = $this->safe_string($transaction, 'network');
        $networkCode = $this->safe_string($this->options['networksByIds'], $networkId, $networkId);
        $addressTo = $this->safe_string($transaction, 'address');
        $statusRaw = $this->safe_string($transaction, 'status');
        $status = $this->parse_transaction_status($statusRaw);
        $timestamp = $this->safe_integer_2($transaction, 'creditedAt', 'requestedAt');
        $type = $isDeposit ? 'deposit' : 'withdrawal';
        return array(
            'id' => $id,
            'txid' => $txId,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'network' => $networkCode,
            'address' => null,
            'addressTo' => $addressTo,
            'addressFrom' => null,
            'tag' => null,
            'tagTo' => null,
            'tagFrom' => null,
            'type' => $type,
            'amount' => $this->safe_number($transaction, 'quantity'),
            'currency' => $currency['code'],
            'status' => $status,
            'updated' => $this->safe_integer($transaction, 'completedAt'),
            'internal' => null,
            'fee' => $this->safe_number($transaction, 'fee'),
            'info' => $transaction,
        );
    }

    public function parse_transaction_status($status) {
        $statuses = array(
            'PROCESSING' => 'pending',
            'PENDING' => 'pending',
            'COMPLETED' => 'ok',
            'FAILED' => 'failed',
            'CANCELED' => 'canceled',
            // 'ON HOLD' => 'pending',
        );
        return $this->safe_string($statuses, $status, $status);
    }

    public function fetch_transfers($code = null, $since = null, $limit = null, $params = array ()) {
        yield $this->load_markets();
        $currency = null;
        $request = array();
        if ($code !== null) {
            $currency = $this->currency($code);
            $request['asset'] = $currency['id'];
        }
        if ($limit !== null) {
            $request['limit'] = $limit;
        }
        $request = $this->set_start_end_times($request, $since);
        $response = yield $this->privateGetV3Transfer (array_merge($request, $params));
        //
        //     {
        //         "success" => true,
        //         "data" => array(
        //             {
        //                 "asset" => "USDT",
        //                 "quantity" => "5",
        //                 "fromAccount" => "38432",
        //                 "toAccount" => "38774",
        //                 "id" => "758113170128764931",
        //                 "status" => "COMPLETED",
        //                 "transferredAt" => "1651428178967"
        //              }
        //          )
        //     }
        //
        $transfers = $this->safe_value($response, 'data', array());
        return $this->parse_transfers($transfers, $currency, $since, $limit);
    }

    public function parse_transfer($transfer, $currency = null) {
        //
        // fetchTransfers
        //
        //     {
        //         "asset" => "USDT",
        //         "quantity" => "5",
        //         "fromAccount" => "38432",
        //         "toAccount" => "38774",
        //         "id" => "758113170128764931",
        //         "status" => "COMPLETED",
        //         "transferredAt" => "1651428178967"
        //      }
        //
        // $transfer
        //
        //     {
        //         "asset" => "USDT",
        //         "quantity" => "5",
        //         "fromAccount" => "38422",
        //         "toAccount" => "38776",
        //         "transferredAt" => "1651704762775"
        //     }
        //
        $currencyId = $this->safe_string($transfer, 'asset');
        $timestamp = $this->safe_string($transfer, 'transferredAt');
        $fromAccount = $this->safe_string($transfer, 'fromAccount');
        $toAccount = $this->safe_string($transfer, 'toAccount');
        $status = $this->parse_transaction_status($this->safe_string($transfer, 'status'));
        // if case of 'transfer', as $status field is not available, 'transferredAt' prop should mean that $transfer was done
        if ($status === null && $timestamp !== null) {
            $status = 'ok';
        }
        return array(
            'id' => $this->safe_string($transfer, 'id'),
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'currency' => $this->safe_currency_code($currencyId, $currency),
            'amount' => $this->safe_number($transfer, 'quantity'),
            'fromAccount' => $fromAccount,
            'toAccount' => $toAccount,
            'status' => $status,
            'info' => $transfer,
        );
    }

    public function build_order_request($market, $type, $side, $amount, $price = null, $params = array ()) {
        $clientOrderId = $this->safe_string($params, 'clientOrderId');
        $maxCOI = '9223372036854775807';
        if (($clientOrderId !== null) && Precise::string_gt($clientOrderId, $maxCOI)) {
            throw new InvalidOrder($this->id . ' createOrder() param $clientOrderId should not exceed ' . $maxCOI);
        }
        $orderType = $this->convert_order_type($type);
        $stopPrice = $this->safe_number($params, 'stopPrice');
        $limitPrice = $this->safe_number($params, 'limitPrice');
        $stopPriceIsDefined = $stopPrice !== null;
        $orderTypeIsStop = $orderType === 'STOP';
        $isStopOrder = $stopPriceIsDefined || $orderTypeIsStop;
        if ($orderTypeIsStop) {
            if (!$stopPriceIsDefined) {
                throw new ArgumentsRequired($this->id . ' createOrder() requires $params["stopPrice"] for stop orders');
            } else if ($limitPrice === null && $price === null) {
                throw new ArgumentsRequired($this->id . ' createOrder() requires "price" argument or $params["limitPrice"] as a limit $price for stop orders, as stop-$market orders are not supported on this exchange');
            }
        }
        yield $this->load_markets();
        $order = array(
            'marketCode' => $market['id'],
            'side' => $this->convert_order_side($side),
            'orderType' => $this->convert_order_type($type),
            'quantity' => $this->amount_to_precision($market['symbol'], $amount),
        );
        if ($isStopOrder) {
            $order['stopPrice'] = $this->price_to_precision($market['symbol'], $stopPrice);
            $params = $this->omit($params, 'stopPrice');
            $order['orderType'] = 'STOP';
        }
        // stop orders have separate field for limit $price, so make further checks
        if ($type === 'limit' || $isStopOrder) {
            if ($isStopOrder) {
                if ($limitPrice === null) {
                    $order['limitPrice'] = $this->price_to_precision($market['symbol'], $price);
                }
            } else {
                $order['price'] = $this->price_to_precision($market['symbol'], $price);
            }
        }
        $request = array(
            'responseType' => 'FULL', // FULL, ACK
            'orders' => array( $order ),
        );
        return array( $request, $params );
    }

    public function check_order_response_for_exception($response, $firstResult) {
        $success = $this->safe_value($firstResult, 'success');
        if ($success === 'false') {
            $message = $this->safe_string($firstResult, 'message');
            $code = $this->safe_string($firstResult, 'code');
            $body = $this->id . ' ' . $this->json($response);
            $this->throw_exactly_matched_exception($this->exceptions['exact'], $code, $body);
            $this->throw_broadly_matched_exception($this->exceptions['broad'], $message, $body);
            throw new ExchangeError($body);
        }
    }

    public function create_order($symbol, $type, $side, $amount, $price = null, $params = array ()) {
        $market = $this->market($symbol);
        $this->check_order_arguments($market, $type, $side, $amount, $price, $params);
        list($request, $query) = yield $this->build_order_request($market, $type, $side, $amount, $price, $params);
        $response = yield $this->privatePostV2OrdersPlace (array_merge($request, $query));
        //
        //     {
        //         "event" => "placeOrder",
        //         "timestamp" => "1651619029297",
        //         "accountId" => "38422",
        //         "data" => array(
        //           {
        //             "success" => "true",
        //             "timestamp" => "1651620006856",
        //             "clientOrderId" => "1651620006827000",
        //             "orderId" => "1002124426084",
        //             "price" => "0.65",
        //             "quantity" => "8.0",
        //             "side" => "BUY",
        //             "status" => "FILLED", // OPEN, FILLED
        //             "marketCode" => "XRP-USD",
        //             "timeInForce" => "GTC",
        //             "matchId" => "5636974433720947783", // zero if not filled
        //             "lastTradedPrice" => "0.6028", // field not present if order doesn't have any fills
        //             "matchQuantity" => "8.0", // field not present if order doesn't have any fills
        //             "orderMatchType" => "TAKER", // field not present if order doesn't have any fills
        //             "remainQuantity" => "0.0", // field not present if order doesn't have any fills
        //             "notice" => "OrderMatched",
        //             "orderType" => "LIMIT",
        //             "fees" => "0.003857920", // field not present if order doesn't have any fills
        //             "feeInstrumentId" => "USD", // field not present if order doesn't have any fills
        //             "isTriggered" => "false"
        //           }
        //         )
        //     }
        //
        // Note, for failed order, the order-object might be like:
        //
        //     {
        //          "success" => "false",
        //          "timestamp" => "1651619029297",
        //          "code" => "710003",
        //          "message" => "FAILED sanity bound check as $price (5.2) >  upper bound (4.1)",
        //          "price" => "4.000",
        //          "quantity" => "3.0",
        //          "side" => "BUY",
        //          "marketCode" => "BAND-USD",
        //          "orderType" => "LIMIT"
        //     }
        //
        $data = $this->safe_value($response, 'data', array());
        $firstOrder = $this->safe_value($data, 0, array());
        $this->check_order_response_for_exception($response, $firstOrder);
        return $this->parse_order($firstOrder, $market);
    }

    public function edit_order($id, $symbol, $type, $side, $amount = null, $price = null, $params = array ()) {
        $market = $this->market($symbol);
        list($request, $query) = yield $this->build_order_request($market, $type, $side, $amount, $price, $params);
        $request['orders'][0]['orderId'] = $id;
        $response = yield $this->privatePostV2OrdersModify (array_merge($request, $query));
        //
        //     {
        //         "event" => "modifyOrder",
        //         "timestamp" => "1651695117070",
        //         "accountId" => "38422",
        //         "data" => array(
        //             {
        //                 "success" => "true",
        //                 "timestamp" => "1651696843859",
        //                 "clientOrderId" => "1651692616185",
        //                 "orderId" => "1002128500938",
        //                 "price" => "0.5600",
        //                 "quantity" => "8.0",
        //                 "side" => "BUY",
        //                 "marketCode" => "XRP-USD",
        //                 "timeInForce" => "GTC",
        //                 "notice" => "OrderModified",
        //                 "orderType" => "LIMIT"
        //             }
        //         )
        //     }
        //
        //
        // Note, for inexistent order-$id, the order-object might be like:
        //
        //             {
        //                 "success" => "false",
        //                 "timestamp" => "1651695117070",
        //                 "code" => "40035",
        //                 "message" => "Open order not found with clientOrderId or orderId",
        //                 "price" => "0.56",
        //                 "quantity" => "8",
        //                 "side" => "BUY",
        //                 "marketCode" => "XRP-USD",
        //                 "orderType" => "LIMIT"
        //             }
        //
        $data = $this->safe_value($response, 'data', array());
        $firstOrder = $this->safe_value($data, 0, array());
        $this->check_order_response_for_exception($response, $firstOrder);
        return $this->parse_order($firstOrder, $market);
    }

    public function cancel_orders($ids, $symbol = null, $params = array ()) {
        if ($symbol === null) {
            throw new ArgumentsRequired($this->id . ' cancelOrders() requires a $symbol argument');
        }
        $market = $this->market($symbol);
        yield $this->load_markets();
        $request = array(
            'responseType' => 'FULL', // FULL, ACK
            'orders' => array(),
        );
        for ($i = 0; $i < count($ids); $i++) {
            $request['orders'][] = array(
                'marketCode' => $market['id'],
                'orderId' => $ids[$i],
            );
        }
        $response = yield $this->privateDeleteV2OrdersCancel (array_merge($request, $params));
        //
        //     {
        //         "event" => "cancelOrder",
        //         "timestamp" => "1651697925019",
        //         "accountId" => "38422",
        //         "data" => array(
        //             {
        //                 "success" => "true",
        //                 "timestamp" => "1651699447397",
        //                 "clientOrderId" => "1651692616185",
        //                 "orderId" => "1002128500938",
        //                 "price" => "0.56",
        //                 "quantity" => "8.0",
        //                 "side" => "BUY",
        //                 "status" => "CANCELED_BY_USER",
        //                 "marketCode" => "XRP-USD",
        //                 "timeInForce" => "GTC",
        //                 "matchId" => "0",
        //                 "remainQuantity" => "8.0",
        //                 "notice" => "OrderClosed",
        //                 "orderType" => "LIMIT",
        //                 "isTriggered" => "false"
        //             }
        //         )
        //     }
        //
        // Note, for inexistent order-id, the order-object might be like:
        //
        //             {
        //                 "success" => "false",
        //                 "timestamp" => "1651697925019",
        //                 "code" => "40035",
        //                 "message" => "Open order not found with clientOrderId or orderId",
        //                 "orderId" => "1002128500938",
        //                 "marketCode" => "XRP/USD"
        //             }
        //
        $data = $this->safe_value($response, 'data', array());
        return $this->parse_orders($data, $market);
    }

    public function cancel_order($id, $symbol = null, $params = array ()) {
        $orders = yield $this->cancel_orders(array( $id ), $symbol, $params);
        return $this->safe_value($orders, 0);
    }

    public function cancel_all_orders($symbol = null, $params = array ()) {
        yield $this->load_markets();
        $market = null;
        $request = array();
        $method = 'privateDeleteV2CancelOrders';
        if ($symbol !== null) {
            $market = $this->market($symbol);
            $request['marketCode'] = $market['id'];
            $method = 'privateDeleteV2CancelOrdersMarketCode';
        }
        $response = yield $this->$method (array_merge($request, $params));
        //
        //     {
        //         "event" => "orders",
        //         "timestamp" => "1651651758625",
        //         "accountId" => "38422",
        //         "data" => {
        //             "marketCode" => "XRP-USD",
        //             "msg" => "All open orders for the specified $market have been queued for cancellation"
        //         }
        //     }
        //
        // Note1 => when fired without $symbol, the 'data' object only contains a msg property with 'array("msg":"All open orders for the account have been queued for cancellation")'
        // Note2 => if there has been no orders pending, then data property will be null.
        //
        return $response;
    }

    public function transfer($code, $amount, $fromAccount, $toAccount, $params = array ()) {
        yield $this->load_markets();
        $currency = $this->currency($code);
        $request = array(
            'asset' => $currency['id'],
            'quantity' => $amount,
            'fromAccount' => $fromAccount,
            'toAccount' => $toAccount,
        );
        $response = yield $this->privatePostV3Transfer (array_merge($request, $params));
        //
        //     {
        //         "success" => true,
        //         "data" => {
        //             "asset" => "USDT",
        //             "quantity" => "5",
        //             "fromAccount" => "38422",
        //             "toAccount" => "38776",
        //             "transferredAt" => "1651704762775"
        //         }
        //     }
        //
        $data = $this->safe_value($response, 'data', array());
        return $this->parse_transfer($data, $currency);
    }

    public function withdraw($code, $amount, $address, $tag = null, $params = array ()) {
        yield $this->load_markets();
        $currency = $this->currency($code);
        $twoFaCode = $this->safe_string($params, 'code');
        if ($twoFaCode === null) {
            throw new ArgumentsRequired($this->id . ' withdraw() requires two-factor "code" parameter for withdrawals');
        }
        $networks = $this->safe_value($this->options, 'networks', array());
        $networkName = $this->safe_string_upper($params, 'network');
        $networkId = $this->safe_string_upper($networks, $networkName, $networkName);
        $request = array(
            'asset' => $currency['id'],
            'network' => $networkId,
            'quantity' => $this->currency_to_precision($code, $amount),
            'address' => $address,
            // below are required $params by this time
            'externalFee' => false,
        );
        if ($this->twofa !== null) {
            $request['tfaType'] = 'GOOGLE';
            $request['code'] = $this->oath();
        }
        $response = yield $this->privatePostV3Withdrawal (array_merge($request, $params));
        //
        //     {
        //         "success" => true,
        //         "data" => {
        //             "id" => "759031388269150209",
        //             "asset" => "USDT",
        //             "network" => "ERC20",
        //             "address" => "0xe8c2d73e0312e32f98e541b813D8EC3148A4BAd5",
        //             "quantity" => "18",
        //             "externalFee" => false,
        //             "fee" => "8.7996",
        //             "status" => "PENDING",
        //             "requestedAt" => "1651708397366"
        //         }
        //     }
        //
        $data = $this->safe_value($response, 'data');
        return $this->parse_transaction($data, $currency);
    }

    public function fetch_funding_fee($code, $params = array ()) {
        $networkName = $this->safe_string_upper($params, 'network');
        if ($networkName === null) {
            throw new ArgumentsRequired($this->id . ' fetchFundingFee() requires "network"  parameter');
        }
        $address = $this->safe_string($params, 'address');
        if ($address === null) {
            throw new ArgumentsRequired($this->id . ' fetchFundingFee() requires recipient "address"  param to calculate fee');
        }
        $amount = $this->safe_number($params, 'quantity');
        $params = $this->omit($params, 'quantity');
        if ($address === null) {
            throw new ArgumentsRequired($this->id . ' fetchFundingFee() requires "quantity"  param to calculate fee');
        }
        yield $this->load_markets();
        $currency = $this->currency($code);
        $networks = $this->safe_value($this->options, 'networks', array());
        $networkId = $this->safe_string_upper($networks, $networkName, $networkName);
        $request = array(
            'asset' => $currency['id'],
            'network' => $networkId,
            'quantity' => $this->currency_to_precision($code, $amount),
        );
        $response = yield $this->privateGetV3WithdrawalFee (array_merge($request, $params));
        //
        //     {
        //         "success" => true,
        //         "data" => {
        //             "asset" => "USDT",
        //             "network" => "ERC20",
        //             "address" => "0x811bFBd9CfBB503c592842c11b89D2b1D65db32F",
        //             "quantity" => "30",
        //             "externalFee" => false,
        //             "estimatedFee" => "9.2985"
        //         }
        //     }
        //
        $data = $this->safe_value($response, 'data', array());
        $withdrawFees = array();
        $withdrawFees[$code] = $this->safe_number($data, 'estimatedFee');
        return array(
            'withdraw' => $withdrawFees,
            'deposit' => array(),
            'info' => $response,
        );
    }

    public function nonce() {
        return $this->milliseconds();
    }

    public function sign($path, $api = 'public', $method = 'GET', $params = array (), $headers = null, $body = null) {
        list($finalPath, $query) = $this->resolve_path($path, $params);
        $url = $this->urls['api'][$api] . '/' . $finalPath;
        $encodedParams = '';
        $isGetRequest = ($method === 'GET');
        if ($query) {
            $encodedParams = $this->rawencode($query);
            if ($isGetRequest) {
                $url .= '?' . $encodedParams;
            }
        }
        if ($api === 'private') {
            $this->check_required_credentials();
            $nonce = (string) $this->nonce();
            $datetime = $this->ymdhms($this->milliseconds(), 'T');
            $auth = $datetime . "\n" . $nonce . "\n" . $method . "\n" . $this->options['baseApiDomain'] . "\n" . '/' . $finalPath . "\n"; // eslint-disable-line quotes
            if ($isGetRequest) {
                $auth .= $encodedParams;
            } else {
                $jsonified = $this->json($query);
                $auth .= $jsonified;
                $body = $jsonified;
            }
            $signature = $this->hmac($this->encode($auth), $this->encode($this->secret), 'sha256', 'base64');
            $headers = array();
            $headers['Content-Type'] = 'application/json';
            $headers['AccessKey'] = $this->apiKey;
            $headers['Timestamp'] = $datetime;
            $headers['Signature'] = $signature;
            $headers['Nonce'] = $nonce;
        }
        return array( 'url' => $url, 'method' => $method, 'body' => $body, 'headers' => $headers );
    }

    public function handle_errors($code, $reason, $url, $method, $headers, $body, $response, $requestHeaders, $requestBody) {
        if ($response === null) {
            return;
        }
        //
        // Success
        //
        //     {
        //         "success" => "true"
        //     }
        //
        //   or
        //
        //     {
        //         "success":true,
        //         "data":[...]
        //     }
        //
        //   or
        //
        //     {
        //         "event" => "publicTrades",
        //         "timestamp" => "1651312416050",
        //         "marketCode" => "BTC-USD",
        //         "data" => array(
        //             array(
        //                 "matchId" => "304734619669458401",
        //                 "matchQuantity" => "0.012",
        //                 "matchPrice" => "38673",
        //                 "side" => "BUY",
        //                 "matchTimestamp" => "1651281046230"
        //             ),
        //         )
        //     }
        //
        // Error
        //
        //     {
        //         "success":false,
        //         "code":"40001",
        //         "message":"no result, please check your parameters"
        //     }
        //
        $responseCode = $this->safe_string($response, 'code');
        if ($responseCode !== null && $responseCode !== '0') {
            $feedback = $this->id . ' ' . $body;
            $this->throw_exactly_matched_exception($this->exceptions['exact'], $responseCode, $feedback);
            $this->throw_broadly_matched_exception($this->exceptions['broad'], $body, $feedback);
            throw new ExchangeError($feedback);
        }
    }
}
