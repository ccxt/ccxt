<?php

namespace ccxt\async;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

use Exception; // a common import
use ccxt\async\abstract\hyperliquid as Exchange;
use ccxt\ExchangeError;
use ccxt\ArgumentsRequired;
use ccxt\BadRequest;
use ccxt\NotSupported;
use ccxt\Precise;
use React\Async;
use React\Promise;
use React\Promise\PromiseInterface;

class hyperliquid extends Exchange {

    public function describe() {
        return $this->deep_extend(parent::describe(), array(
            'id' => 'hyperliquid',
            'name' => 'Hyperliquid',
            'countries' => [ ],
            'version' => 'v1',
            'rateLimit' => 50, // 1200 requests per minute, 20 request per second
            'certified' => false,
            'pro' => true,
            'has' => array(
                'CORS' => null,
                'spot' => true,
                'margin' => false,
                'swap' => true,
                'future' => true,
                'option' => false,
                'addMargin' => true,
                'borrowCrossMargin' => false,
                'borrowIsolatedMargin' => false,
                'cancelAllOrders' => false,
                'cancelAllOrdersAfter' => true,
                'cancelOrder' => true,
                'cancelOrders' => true,
                'cancelOrdersForSymbols' => true,
                'closeAllPositions' => false,
                'closePosition' => false,
                'createMarketBuyOrderWithCost' => false,
                'createMarketOrderWithCost' => false,
                'createMarketSellOrderWithCost' => false,
                'createOrder' => true,
                'createOrders' => true,
                'createReduceOnlyOrder' => true,
                'editOrder' => true,
                'fetchAccounts' => false,
                'fetchBalance' => true,
                'fetchBorrowInterest' => false,
                'fetchBorrowRateHistories' => false,
                'fetchBorrowRateHistory' => false,
                'fetchCanceledOrders' => false,
                'fetchClosedOrders' => true,
                'fetchCrossBorrowRate' => false,
                'fetchCrossBorrowRates' => false,
                'fetchCurrencies' => true,
                'fetchDepositAddress' => false,
                'fetchDepositAddresses' => false,
                'fetchDeposits' => false,
                'fetchDepositWithdrawFee' => 'emulated',
                'fetchDepositWithdrawFees' => false,
                'fetchFundingHistory' => false,
                'fetchFundingRate' => false,
                'fetchFundingRateHistory' => true,
                'fetchFundingRates' => false,
                'fetchIndexOHLCV' => false,
                'fetchIsolatedBorrowRate' => false,
                'fetchIsolatedBorrowRates' => false,
                'fetchLedger' => false,
                'fetchLeverage' => false,
                'fetchLeverageTiers' => false,
                'fetchLiquidations' => false,
                'fetchMarginMode' => null,
                'fetchMarketLeverageTiers' => false,
                'fetchMarkets' => true,
                'fetchMarkOHLCV' => false,
                'fetchMyLiquidations' => false,
                'fetchMyTrades' => true,
                'fetchOHLCV' => true,
                'fetchOpenInterest' => false,
                'fetchOpenInterestHistory' => false,
                'fetchOpenOrders' => true,
                'fetchOrder' => true,
                'fetchOrderBook' => true,
                'fetchOrders' => false,
                'fetchOrderTrades' => false,
                'fetchPosition' => true,
                'fetchPositionMode' => false,
                'fetchPositions' => true,
                'fetchPositionsRisk' => false,
                'fetchPremiumIndexOHLCV' => false,
                'fetchTicker' => false,
                'fetchTickers' => false,
                'fetchTime' => false,
                'fetchTrades' => true,
                'fetchTradingFee' => false,
                'fetchTradingFees' => false,
                'fetchTransfer' => false,
                'fetchTransfers' => false,
                'fetchWithdrawal' => false,
                'fetchWithdrawals' => false,
                'reduceMargin' => true,
                'repayCrossMargin' => false,
                'repayIsolatedMargin' => false,
                'sandbox' => true,
                'setLeverage' => true,
                'setMarginMode' => true,
                'setPositionMode' => false,
                'transfer' => true,
                'withdraw' => true,
            ),
            'timeframes' => array(
                '1m' => '1m',
                '3m' => '3m',
                '5m' => '5m',
                '15m' => '15m',
                '30m' => '30m',
                '1h' => '1h',
                '2h' => '2h',
                '4h' => '4h',
                '6h' => '6h',
                '12h' => '12h',
                '1d' => '1d',
                '3d' => '3d',
                '1w' => '1w',
                '1M' => '1m',
            ),
            'hostname' => 'hyperliquid.xyz',
            'urls' => array(
                'logo' => 'https://github.com/ccxt/ccxt/assets/43336371/b371bc6c-4a8c-489f-87f4-20a913dd8d4b',
                'api' => array(
                    'public' => 'https://api.{hostname}',
                    'private' => 'https://api.{hostname}',
                ),
                'test' => array(
                    'public' => 'https://api.hyperliquid-testnet.xyz',
                    'private' => 'https://api.hyperliquid-testnet.xyz',
                ),
                'www' => 'https://hyperliquid.xyz',
                'doc' => 'https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api',
                'fees' => 'https://hyperliquid.gitbook.io/hyperliquid-docs/trading/fees',
                'referral' => 'https://app.hyperliquid.xyz/',
            ),
            'api' => array(
                'public' => array(
                    'post' => array(
                        'info' => 1,
                    ),
                ),
                'private' => array(
                    'post' => array(
                        'exchange' => 1,
                    ),
                ),
            ),
            'fees' => array(
                'swap' => array(
                    'taker' => $this->parse_number('0.00035'),
                    'maker' => $this->parse_number('0.0001'),
                ),
                'spot' => array(
                    'taker' => $this->parse_number('0.00035'),
                    'maker' => $this->parse_number('0.0001'),
                ),
            ),
            'requiredCredentials' => array(
                'apiKey' => false,
                'secret' => false,
                'walletAddress' => true,
                'privateKey' => true,
            ),
            'exceptions' => array(
                'exact' => array(
                ),
                'broad' => array(
                    'Price must be divisible by tick size.' => '\\ccxt\\InvalidOrder',
                    'Order must have minimum value of $10' => '\\ccxt\\InvalidOrder',
                    'Insufficient margin to place order.' => '\\ccxt\\InvalidOrder',
                    'Reduce only order would increase position.' => '\\ccxt\\InvalidOrder',
                    'Post only order would have immediately matched,' => '\\ccxt\\InvalidOrder',
                    'Order could not immediately match against any resting orders.' => '\\ccxt\\InvalidOrder',
                    'Invalid TP/SL price.' => '\\ccxt\\InvalidOrder',
                    'No liquidity available for market order.' => '\\ccxt\\InvalidOrder',
                    'Order was never placed, already canceled, or filled.' => '\\ccxt\\OrderNotFound',
                    'User or API Wallet ' => '\\ccxt\\InvalidOrder',
                ),
            ),
            'precisionMode' => TICK_SIZE,
            'commonCurrencies' => array(
            ),
            'options' => array(
                'defaultType' => 'swap',
                'sandboxMode' => false,
                'defaultSlippage' => 0.05,
                'zeroAddress' => '0x0000000000000000000000000000000000000000',
            ),
        ));
    }

    public function set_sandbox_mode($enabled) {
        parent::set_sandbox_mode($enabled);
        $this->options['sandboxMode'] = $enabled;
    }

    public function fetch_currencies($params = array ()): PromiseInterface {
        return Async\async(function () use ($params) {
            /**
             * fetches all available currencies on an exchange
             * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/info-endpoint#retrieve-exchange-metadata
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} an associative dictionary of currencies
             */
            $request = array(
                'type' => 'meta',
            );
            $response = Async\await($this->publicPostInfo (array_merge($request, $params)));
            //
            //     array(
            //         {
            //             "universe" => array(
            //                 {
            //                     "maxLeverage" => 50,
            //                     "name" => "SOL",
            //                     "onlyIsolated" => false,
            //                     "szDecimals" => 2
            //                 }
            //             )
            //         }
            //     )
            //
            $meta = $this->safe_list($response, 'universe', array());
            $result = array();
            for ($i = 0; $i < count($meta); $i++) {
                $data = $this->safe_dict($meta, $i, array());
                $id = $i;
                $name = $this->safe_string($data, 'name');
                $code = $this->safe_currency_code($name);
                $result[$code] = array(
                    'id' => $id,
                    'name' => $name,
                    'code' => $code,
                    'precision' => null,
                    'info' => $data,
                    'active' => null,
                    'deposit' => null,
                    'withdraw' => null,
                    'networks' => null,
                    'fee' => null,
                    // 'fees' => fees,
                    'limits' => null,
                );
            }
            return $result;
        }) ();
    }

    public function fetch_markets($params = array ()): PromiseInterface {
        return Async\async(function () use ($params) {
            /**
             * retrieves data on all markets for hyperliquid
             * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/info-endpoint#retrieve-asset-contexts-includes-mark-price-current-funding-open-interest-etc
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array[]} an array of objects representing market data
             */
            $rawPromises = array(
                $this->fetch_swap_markets($params),
                $this->fetch_spot_markets($params),
            );
            $promises = Async\await(Promise\all($rawPromises));
            $swapMarkets = $promises[0];
            $spotMarkets = $promises[1];
            return $this->array_concat($swapMarkets, $spotMarkets);
        }) ();
    }

    public function fetch_swap_markets($params = array ()): PromiseInterface {
        return Async\async(function () use ($params) {
            /**
             * retrieves $data on all swap markets for hyperliquid
             * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/info-endpoint#retrieve-asset-contexts-includes-mark-price-current-funding-open-interest-etc
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array[]} an array of objects representing market $data
             */
            $request = array(
                'type' => 'metaAndAssetCtxs',
            );
            $response = Async\await($this->publicPostInfo (array_merge($request, $params)));
            //
            //     array(
            //         {
            //             "universe" => array(
            //                 array(
            //                     "maxLeverage" => 50,
            //                     "name" => "SOL",
            //                     "onlyIsolated" => false,
            //                     "szDecimals" => 2
            //                 }
            //             )
            //         ),
            //         array(
            //             {
            //                 "dayNtlVlm" => "9450588.2273",
            //                 "funding" => "0.0000198",
            //                 "impactPxs" => array(
            //                     "108.04",
            //                     "108.06"
            //                 ),
            //                 "markPx" => "108.04",
            //                 "midPx" => "108.05",
            //                 "openInterest" => "10764.48",
            //                 "oraclePx" => "107.99",
            //                 "premium" => "0.00055561",
            //                 "prevDayPx" => "111.81"
            //             }
            //         )
            //     )
            //
            //
            $meta = $this->safe_dict($response, 0, array());
            $meta = $this->safe_list($meta, 'universe', array());
            $assetCtxs = $this->safe_dict($response, 1, array());
            $result = array();
            for ($i = 0; $i < count($meta); $i++) {
                $data = array_merge(
                    $this->safe_dict($meta, $i, array()),
                    $this->safe_dict($assetCtxs, $i, array())
                );
                $data['baseId'] = $i;
                $result[] = $data;
            }
            return $this->parse_markets($result);
        }) ();
    }

    public function fetch_spot_markets($params = array ()): PromiseInterface {
        return Async\async(function () use ($params) {
            /**
             * retrieves data on all spot $markets for hyperliquid
             * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/info-endpoint#retrieve-asset-contexts-includes-mark-price-current-funding-open-interest-etc
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array[]} an array of objects representing $market data
             */
            $request = array(
                'type' => 'spotMetaAndAssetCtxs',
            );
            $response = Async\await($this->publicPostInfo (array_merge($request, $params)));
            //
            // array(
            //     array(
            //         'tokens' => array(
            //             array(
            //                 'name' => 'USDC',
            //                 'szDecimals' => '8',
            //                 'weiDecimals' => '8',
            //             ),
            //             array(
            //                 'name' => 'PURR',
            //                 'szDecimals' => '0',
            //                 'weiDecimals' => '5',
            //             ),
            //         ),
            //         'universe' => array(
            //             array(
            //                 'name' => 'PURR/USDC',
            //                 'tokens' => array(
            //                     1,
            //                     0,
            //                 ),
            //             ),
            //         ),
            //     ),
            //     array(
            //         array(
            //             'dayNtlVlm' => '264250385.14640012',
            //             'markPx' => '0.018314',
            //             'midPx' => '0.0182235',
            //             'prevDayPx' => '0.017427',
            //         ),
            //     ),
            // );
            // mainnet
            // array(
            //     {
            //        "canonical_tokens2":array(
            //           0,
            //           1
            //        ),
            //        "spot_infos":array(
            //           {
            //              "name":"PURR/USDC",
            //              "tokens":array(
            //                 1,
            //                 0
            //              )
            //           }
            //        ),
            //        "token_id_to_token":array(
            //           array(
            //              "0x6d1e7cde53ba9467b783cb7c530ce054",
            //              0
            //           ),
            //           array(
            //              "0xc1fb593aeffbeb02f85e0308e9956a90",
            //              1
            //           )
            //        ),
            //        "token_infos":array(
            //           array(
            //              "deployer":null,
            //              "spec":array(
            //                 "name":"USDC",
            //                 "szDecimals":"8",
            //                 "weiDecimals":"8"
            //              ),
            //              "spots":array(
            //              )
            //           ),
            //           array(
            //              "deployer":null,
            //              "spec":array(
            //                 "name":"PURR",
            //                 "szDecimals":"0",
            //                 "weiDecimals":"5"
            //              ),
            //              "spots":array(
            //                 0
            //              )
            //           }
            //        )
            //     ),
            //     array(
            //        {
            //           "dayNtlVlm":"35001170.16631",
            //           "markPx":"0.15743",
            //           "midPx":"0.157555",
            //           "prevDayPx":"0.158"
            //        }
            //     )
            // )
            //
            // $response differs depending on the environment (mainnet vs sandbox)
            $first = $this->safe_dict($response, 0, array());
            $meta = $this->safe_list_2($first, 'universe', 'spot_infos', array());
            $tokens = $this->safe_list_2($first, 'tokens', 'token_infos', array());
            $markets = array();
            for ($i = 0; $i < count($meta); $i++) {
                $market = $this->safe_dict($meta, $i, array());
                $marketName = $this->safe_string($market, 'name');
                if (mb_strpos($marketName, '/') === false) {
                    // there are some weird spot $markets in testnet, eg @2
                    continue;
                }
                $marketParts = explode('/', $marketName);
                $baseName = $this->safe_string($marketParts, 0);
                $quoteId = $this->safe_string($marketParts, 1);
                $base = $this->safe_currency_code($baseName);
                $quote = $this->safe_currency_code($quoteId);
                $symbol = $base . '/' . $quote;
                $fees = $this->safe_dict($this->fees, 'spot', array());
                $taker = $this->safe_number($fees, 'taker');
                $maker = $this->safe_number($fees, 'maker');
                $tokensPos = $this->safe_list($market, 'tokens', array());
                $baseTokenPos = $this->safe_integer($tokensPos, 0);
                // $quoteTokenPos = $this->safe_integer($tokensPos, 1);
                $baseTokenInfo = $this->safe_dict($tokens, $baseTokenPos, array());
                // $quoteTokenInfo = $this->safe_dict($tokens, $quoteTokenPos, array());
                $innerBaseTokenInfo = $this->safe_dict($baseTokenInfo, 'spec', $baseTokenInfo);
                // $innerQuoteTokenInfo = $this->safe_dict($quoteTokenInfo, 'spec', $quoteTokenInfo);
                $amountPrecision = $this->parse_number($this->parse_precision($this->safe_string($innerBaseTokenInfo, 'szDecimals')));
                // $quotePrecision = $this->parse_number($this->parse_precision($this->safe_string($innerQuoteTokenInfo, 'szDecimals')));
                $baseId = $this->number_to_string($i + 10000);
                $markets[] = $this->safe_market_structure(array(
                    'id' => $marketName,
                    'symbol' => $symbol,
                    'base' => $base,
                    'quote' => $quote,
                    'settle' => null,
                    'baseId' => $baseId,
                    'quoteId' => $quoteId,
                    'settleId' => null,
                    'type' => 'spot',
                    'spot' => true,
                    'subType' => null,
                    'margin' => null,
                    'swap' => false,
                    'future' => false,
                    'option' => false,
                    'active' => true,
                    'contract' => false,
                    'linear' => null,
                    'inverse' => null,
                    'taker' => $taker,
                    'maker' => $maker,
                    'contractSize' => null,
                    'expiry' => null,
                    'expiryDatetime' => null,
                    'strike' => null,
                    'optionType' => null,
                    'precision' => array(
                        'amount' => $amountPrecision, // decimal places
                        'price' => 5, // significant digits
                    ),
                    'limits' => array(
                        'leverage' => array(
                            'min' => null,
                            'max' => null,
                        ),
                        'amount' => array(
                            'min' => null,
                            'max' => null,
                        ),
                        'price' => array(
                            'min' => null,
                            'max' => null,
                        ),
                        'cost' => array(
                            'min' => null,
                            'max' => null,
                        ),
                    ),
                    'created' => null,
                    'info' => $market,
                ));
            }
            return $markets;
        }) ();
    }

    public function parse_market($market): array {
        //
        //     {
        //         "maxLeverage" => "50",
        //         "name" => "ETH",
        //         "onlyIsolated" => false,
        //         "szDecimals" => "4",
        //         "dayNtlVlm" => "1709813.11535",
        //         "funding" => "0.00004807",
        //         "impactPxs" => array(
        //             "2369.3",
        //             "2369.6"
        //         ),
        //         "markPx" => "2369.6",
        //         "midPx" => "2369.45",
        //         "openInterest" => "1815.4712",
        //         "oraclePx" => "2367.3",
        //         "premium" => "0.00090821",
        //         "prevDayPx" => "2381.5"
        //     }
        //
        $quoteId = 'USDC';
        $base = $this->safe_string($market, 'name');
        $quote = $this->safe_currency_code($quoteId);
        $baseId = $this->safe_string($market, 'baseId');
        $settleId = 'USDC';
        $settle = $this->safe_currency_code($settleId);
        $symbol = $base . '/' . $quote;
        $contract = true;
        $swap = true;
        if ($contract) {
            if ($swap) {
                $symbol = $symbol . ':' . $settle;
            }
        }
        $fees = $this->safe_dict($this->fees, 'swap', array());
        $taker = $this->safe_number($fees, 'taker');
        $maker = $this->safe_number($fees, 'maker');
        return array(
            'id' => $baseId,
            'symbol' => $symbol,
            'base' => $base,
            'quote' => $quote,
            'settle' => $settle,
            'baseId' => $baseId,
            'quoteId' => $quoteId,
            'settleId' => $settleId,
            'type' => 'swap',
            'spot' => false,
            'margin' => null,
            'swap' => $swap,
            'future' => false,
            'option' => false,
            'active' => true,
            'contract' => $contract,
            'linear' => true,
            'inverse' => false,
            'taker' => $taker,
            'maker' => $maker,
            'contractSize' => $this->parse_number('1'),
            'expiry' => null,
            'expiryDatetime' => null,
            'strike' => null,
            'optionType' => null,
            'precision' => array(
                'amount' => $this->parse_number($this->parse_precision($this->safe_string($market, 'szDecimals'))), // decimal places
                'price' => 5, // significant digits
            ),
            'limits' => array(
                'leverage' => array(
                    'min' => null,
                    'max' => null,
                ),
                'amount' => array(
                    'min' => null,
                    'max' => null,
                ),
                'price' => array(
                    'min' => null,
                    'max' => null,
                ),
                'cost' => array(
                    'min' => null,
                    'max' => null,
                ),
            ),
            'created' => null,
            'info' => $market,
        );
    }

    public function fetch_balance($params = array ()): PromiseInterface {
        return Async\async(function () use ($params) {
            /**
             * query for $balance and get the amount of funds available for trading or funds locked in orders
             * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/info-endpoint#retrieve-a-users-state
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @param {string} [$params->user] user address, will default to $this->walletAddress if not provided
             * @param {string} [$params->type] wallet $type, ['spot', 'swap'], defaults to swap
             * @return {array} a ~@link https://docs.ccxt.com/#/?id=$balance-structure $balance structure~
             */
            $userAddress = null;
            list($userAddress, $params) = $this->handle_public_address('fetchBalance', $params);
            $type = null;
            list($type, $params) = $this->handle_market_type_and_params('fetchBalance', null, $params);
            $isSpot = ($type === 'spot');
            $reqType = ($isSpot) ? 'spotClearinghouseState' : 'clearinghouseState';
            $request = array(
                'type' => $reqType,
                'user' => $userAddress,
            );
            $response = Async\await($this->publicPostInfo (array_merge($request, $params)));
            //
            //     {
            //         "assetPositions" => array(),
            //         "crossMaintenanceMarginUsed" => "0.0",
            //         "crossMarginSummary" => array(
            //             "accountValue" => "100.0",
            //             "totalMarginUsed" => "0.0",
            //             "totalNtlPos" => "0.0",
            //             "totalRawUsd" => "100.0"
            //         ),
            //         "marginSummary" => array(
            //             "accountValue" => "100.0",
            //             "totalMarginUsed" => "0.0",
            //             "totalNtlPos" => "0.0",
            //             "totalRawUsd" => "100.0"
            //         ),
            //         "time" => "1704261007014",
            //         "withdrawable" => "100.0"
            //     }
            // spot
            //
            //     {
            //         "balances":[
            //            array(
            //               "coin":"USDC",
            //               "hold":"0.0",
            //               "total":"1481.844"
            //            ),
            //            {
            //               "coin":"PURR",
            //               "hold":"0.0",
            //               "total":"999.65004"
            //            }
            //     }
            //
            $balances = $this->safe_list($response, 'balances');
            if ($balances !== null) {
                $spotBalances = array( 'info' => $response );
                for ($i = 0; $i < count($balances); $i++) {
                    $balance = $balances[$i];
                    $code = $this->safe_currency_code($this->safe_string($balance, 'coin'));
                    $account = $this->account();
                    $total = $this->safe_string($balance, 'total');
                    $free = $this->safe_string($balance, 'hold');
                    $account['total'] = $total;
                    $account['free'] = $free;
                    $spotBalances[$code] = $account;
                }
                return $this->safe_balance($spotBalances);
            }
            $data = $this->safe_dict($response, 'marginSummary', array());
            $result = array(
                'info' => $response,
                'USDC' => array(
                    'total' => $this->safe_float($data, 'accountValue'),
                    'used' => $this->safe_float($data, 'totalMarginUsed'),
                ),
            );
            $timestamp = $this->safe_integer($response, 'time');
            $result['timestamp'] = $timestamp;
            $result['datetime'] = $this->iso8601($timestamp);
            return $this->safe_balance($result);
        }) ();
    }

    public function fetch_order_book(string $symbol, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $limit, $params) {
            /**
             * fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other $data
             * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/info-endpoint#info
             * @param {string} $symbol unified $symbol of the $market to fetch the order book for
             * @param {int} [$limit] the maximum amount of order book entries to return
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} A dictionary of ~@link https://docs.ccxt.com/#/?id=order-book-structure order book structures~ indexed by $market symbols
             */
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $request = array(
                'type' => 'l2Book',
                'coin' => $market['swap'] ? $market['base'] : $market['id'],
            );
            $response = Async\await($this->publicPostInfo (array_merge($request, $params)));
            //
            //     {
            //         "coin" => "ETH",
            //         "levels" => array(
            //             array(
            //                 {
            //                     "n" => "2",
            //                     "px" => "2216.2",
            //                     "sz" => "74.0637"
            //                 }
            //             ),
            //             array(
            //                 {
            //                     "n" => "2",
            //                     "px" => "2216.5",
            //                     "sz" => "70.5893"
            //                 }
            //             )
            //         ),
            //         "time" => "1704290104840"
            //     }
            //
            $data = $this->safe_list($response, 'levels', array());
            $result = array(
                'bids' => $this->safe_list($data, 0, array()),
                'asks' => $this->safe_list($data, 1, array()),
            );
            $timestamp = $this->safe_integer($response, 'time');
            return $this->parse_order_book($result, $market['symbol'], $timestamp, 'bids', 'asks', 'px', 'sz');
        }) ();
    }

    public function fetch_ohlcv(string $symbol, $timeframe = '1m', ?int $since = null, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $timeframe, $since, $limit, $params) {
            /**
             * fetches historical candlestick data containing the open, high, low, and close price, and the volume of a $market
             * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/info-endpoint#info-1
             * @param {string} $symbol unified $symbol of the $market to fetch OHLCV data for
             * @param {string} $timeframe the length of time each candle represents, support '1m', '15m', '1h', '1d'
             * @param {int} [$since] timestamp in ms of the earliest candle to fetch
             * @param {int} [$limit] the maximum amount of candles to fetch
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @param {int} [$params->until] timestamp in ms of the latest candle to fetch
             * @return {int[][]} A list of candles ordered, open, high, low, close, volume
             */
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $until = $this->safe_integer($params, 'until', $this->milliseconds());
            if ($since === null) {
                $since = 0;
            }
            if ($limit === null) {
                $limit = 500;
            }
            $params = $this->omit($params, array( 'until' ));
            $request = array(
                'type' => 'candleSnapshot',
                'req' => array(
                    'coin' => $market['swap'] ? $market['base'] : $market['id'],
                    'interval' => $timeframe,
                    'startTime' => $since,
                    'endTime' => $until,
                ),
            );
            $response = Async\await($this->publicPostInfo (array_merge($request, $params)));
            //
            //     array(
            //         {
            //             "T" => 1704287699999,
            //             "c" => "2226.4",
            //             "h" => "2247.9",
            //             "i" => "15m",
            //             "l" => "2224.6",
            //             "n" => 46,
            //             "o" => "2247.9",
            //             "s" => "ETH",
            //             "t" => 1704286800000,
            //             "v" => "591.6427"
            //         }
            //     )
            //
            return $this->parse_ohlcvs($response, $market, $timeframe, $since, $limit);
        }) ();
    }

    public function parse_ohlcv($ohlcv, ?array $market = null): array {
        //
        //     {
        //         "T" => 1704287699999,
        //         "c" => "2226.4",
        //         "h" => "2247.9",
        //         "i" => "15m",
        //         "l" => "2224.6",
        //         "n" => 46,
        //         "o" => "2247.9",
        //         "s" => "ETH",
        //         "t" => 1704286800000,
        //         "v" => "591.6427"
        //     }
        //
        return array(
            $this->safe_integer($ohlcv, 't'),
            $this->safe_number($ohlcv, 'o'),
            $this->safe_number($ohlcv, 'h'),
            $this->safe_number($ohlcv, 'l'),
            $this->safe_number($ohlcv, 'c'),
            $this->safe_number($ohlcv, 'v'),
        );
    }

    public function fetch_trades(?string $symbol = null, ?int $since = null, ?int $limit = null, $params = array ()) {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            /**
             * get the list of most recent trades for a particular $symbol
             * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/info-endpoint#retrieve-a-users-fills
             * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/info-endpoint#retrieve-a-users-fills-by-time
             * @param {string} $symbol unified $market $symbol
             * @param {int} [$since] the earliest time in ms to fetch trades for
             * @param {int} [$limit] the maximum number of trades structures to retrieve
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @param {int} [$params->until] timestamp in ms of the latest trade
             * @param {string} [$params->address] wallet address that made trades
             * @param {string} [$params->user] wallet address that made trades
             * @return {Trade[]} a list of ~@link https://docs.ccxt.com/#/?id=trade-structure trade structures~
             */
            $userAddress = null;
            list($userAddress, $params) = $this->handle_public_address('fetchTrades', $params);
            Async\await($this->load_markets());
            $market = $this->safe_market($symbol);
            $request = array(
                'user' => $userAddress,
            );
            if ($since !== null) {
                $request['type'] = 'userFillsByTime';
                $request['startTime'] = $since;
            } else {
                $request['type'] = 'userFills';
            }
            $until = $this->safe_integer($params, 'until');
            $params = $this->omit($params, 'until');
            if ($until !== null) {
                $request['endTime'] = $until;
            }
            $response = Async\await($this->publicPostInfo (array_merge($request, $params)));
            //
            //     array(
            //         {
            //             "closedPnl" => "0.19343",
            //             "coin" => "ETH",
            //             "crossed" => true,
            //             "dir" => "Close Long",
            //             "fee" => "0.050062",
            //             "hash" => "0x09d77c96791e98b5775a04092584ab010d009445119c71e4005c0d634ea322bc",
            //             "liquidationMarkPx" => null,
            //             "oid" => 3929354691,
            //             "px" => "2381.1",
            //             "side" => "A",
            //             "startPosition" => "0.0841",
            //             "sz" => "0.0841",
            //             "tid" => 128423918764978,
            //             "time" => 1704262888911
            //         }
            //     )
            //
            return $this->parse_trades($response, $market, $since, $limit);
        }) ();
    }

    public function amount_to_precision($symbol, $amount) {
        $market = $this->market($symbol);
        if ($market['spot']) {
            return parent::amount_to_precision($symbol, $amount);
        }
        return $this->decimal_to_precision($amount, ROUND, $this->markets[$symbol]['precision']['amount'], $this->precisionMode);
    }

    public function price_to_precision(string $symbol, $price): string {
        $market = $this->market($symbol);
        $result = $this->decimal_to_precision($price, ROUND, $market['precision']['price'], SIGNIFICANT_DIGITS, $this->paddingMode);
        $decimalParsedResult = $this->decimal_to_precision($result, ROUND, 6, DECIMAL_PLACES, $this->paddingMode);
        return $decimalParsedResult;
    }

    public function hash_message($message) {
        return '0x' . $this->hash($message, 'keccak', 'hex');
    }

    public function sign_hash($hash, $privateKey) {
        $signature = $this->ecdsa(mb_substr($hash, -64), mb_substr($privateKey, -64), 'secp256k1', null);
        return array(
            'r' => '0x' . $signature['r'],
            's' => '0x' . $signature['s'],
            'v' => $this->sum(27, $signature['v']),
        );
    }

    public function sign_message($message, $privateKey) {
        return $this->sign_hash($this->hash_message($message), mb_substr($privateKey, -64));
    }

    public function construct_phantom_agent($hash, $isTestnet = true) {
        $source = ($isTestnet) ? 'b' : 'a';
        return array(
            'source' => $source,
            'connectionId' => $hash,
        );
    }

    public function action_hash($action, $vaultAddress, $nonce) {
        $dataBinary = $this->packb($action);
        $dataHex = bin2hex($dataBinary);
        $data = $dataHex;
        $data .= '00000' . $this->int_to_base16($nonce);
        if ($vaultAddress === null) {
            $data .= '00';
        } else {
            $data .= '01';
            $data .= $vaultAddress;
        }
        return $this->hash($this->base16_to_binary($data), 'keccak', 'binary');
    }

    public function sign_l1_action($action, $nonce, $vaultAdress = null): array {
        $hash = $this->action_hash($action, $vaultAdress, $nonce);
        $isTestnet = $this->safe_bool($this->options, 'sandboxMode', false);
        $phantomAgent = $this->construct_phantom_agent($hash, $isTestnet);
        // $data = array(
        //     'domain' => array(
        //         'chainId' => 1337,
        //         'name' => 'Exchange',
        //         'verifyingContract' => '0x0000000000000000000000000000000000000000',
        //         'version' => '1',
        //     ),
        //     'types' => array(
        //         'Agent' => array(
        //             array( 'name' => 'source', 'type' => 'string' ),
        //             array( 'name' => 'connectionId', 'type' => 'bytes32' ),
        //         ),
        //         'EIP712Domain' => array(
        //             array( 'name' => 'name', 'type' => 'string' ),
        //             array( 'name' => 'version', 'type' => 'string' ),
        //             array( 'name' => 'chainId', 'type' => 'uint256' ),
        //             array( 'name' => 'verifyingContract', 'type' => 'address' ),
        //         ),
        //     ),
        //     'primaryType' => 'Agent',
        //     'message' => $phantomAgent,
        // );
        $zeroAddress = $this->safe_string($this->options, 'zeroAddress');
        $chainId = 1337; // check this out
        $domain = array(
            'chainId' => $chainId,
            'name' => 'Exchange',
            'verifyingContract' => $zeroAddress,
            'version' => '1',
        );
        $messageTypes = array(
            'Agent' => array(
                array( 'name' => 'source', 'type' => 'string' ),
                array( 'name' => 'connectionId', 'type' => 'bytes32' ),
            ),
        );
        $msg = $this->eth_encode_structured_data($domain, $messageTypes, $phantomAgent);
        $signature = $this->sign_message($msg, $this->privateKey);
        return $signature;
    }

    public function build_sig($chainId, $messageTypes, $message) {
        $zeroAddress = $this->safe_string($this->options, 'zeroAddress');
        $domain = array(
            'chainId' => $chainId,
            'name' => 'Exchange',
            'verifyingContract' => $zeroAddress,
            'version' => '1',
        );
        $msg = $this->eth_encode_structured_data($domain, $messageTypes, $message);
        $signature = $this->sign_message($msg, $this->privateKey);
        return $signature;
    }

    public function build_transfer_sig($message) {
        $isSandboxMode = $this->safe_bool($this->options, 'sandboxMode');
        $chainId = ($isSandboxMode) ? 421614 : 42161;
        $messageTypes = array(
            'UsdTransferSignPayload' => array(
                array( 'name' => 'destination', 'type' => 'string' ),
                array( 'name' => 'amount', 'type' => 'string' ),
                array( 'name' => 'time', 'type' => 'uint64' ),
            ),
        );
        return $this->build_sig($chainId, $messageTypes, $message);
    }

    public function build_withdraw_sig($message) {
        $isSandboxMode = $this->safe_bool($this->options, 'sandboxMode');
        $chainId = ($isSandboxMode) ? 421614 : 42161;
        $messageTypes = array(
            'WithdrawFromBridge2SignPayload' => array(
                array( 'name' => 'destination', 'type' => 'string' ),
                array( 'name' => 'usd', 'type' => 'string' ),
                array( 'name' => 'time', 'type' => 'uint64' ),
            ),
        );
        return $this->build_sig($chainId, $messageTypes, $message);
    }

    public function create_order(string $symbol, string $type, string $side, float $amount, ?float $price = null, $params = array ()) {
        return Async\async(function () use ($symbol, $type, $side, $amount, $price, $params) {
            /**
             * create a trade $order
             * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/exchange-endpoint#place-an-$order
             * @param {string} $symbol unified $symbol of the $market to create an $order in
             * @param {string} $type 'market' or 'limit'
             * @param {string} $side 'buy' or 'sell'
             * @param {float} $amount how much of currency you want to trade in units of base currency
             * @param {float} [$price] the $price at which the $order is to be fullfilled, in units of the quote currency, ignored in $market orders
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @param {string} [$params->timeInForce] 'Gtc', 'Ioc', 'Alo'
             * @param {bool} [$params->postOnly] true or false whether the $order is post-only
             * @param {bool} [$params->reduceOnly] true or false whether the $order is reduce-only
             * @param {float} [$params->triggerPrice] The $price at which a trigger $order is triggered at
             * @param {string} [$params->clientOrderId] client $order id, (optional 128 bit hex string e.g. 0x1234567890abcdef1234567890abcdef)
             * @param {string} [$params->slippage] the slippage for $market $order
             * @param {string} [$params->vaultAddress] the vault address for $order
             * @return {array} an ~@link https://docs.ccxt.com/#/?id=$order-structure $order structure~
             */
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $vaultAddress = $this->safe_string($params, 'vaultAddress');
            $params = $this->omit($params, 'vaultAddress');
            $symbol = $market['symbol'];
            $order = array(
                'symbol' => $symbol,
                'type' => $type,
                'side' => $side,
                'amount' => $amount,
                'price' => $price,
                'params' => $params,
            );
            $globalParams = array();
            if ($vaultAddress !== null) {
                $globalParams['vaultAddress'] = $vaultAddress;
            }
            $response = Async\await($this->create_orders(array( $order ), $globalParams));
            $first = $this->safe_dict($response, 0);
            return $first;
        }) ();
    }

    public function create_orders(array $orders, $params = array ()) {
        return Async\async(function () use ($orders, $params) {
            /**
             * create a list of trade $orders
             * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/exchange-endpoint#place-an-order
             * @param {Array} $orders list of $orders to create, each object should contain the parameters required by createOrder, namely $symbol, $type, $side, $amount, $price and $params
             * @return {array} an ~@link https://docs.ccxt.com/#/?id=order-structure order structure~
             */
            $this->check_required_credentials();
            Async\await($this->load_markets());
            $defaultSlippage = $this->safe_string($this->options, 'defaultSlippage');
            $defaultSlippage = $this->safe_string($params, 'slippage', $defaultSlippage);
            $hasClientOrderId = false;
            for ($i = 0; $i < count($orders); $i++) {
                $rawOrder = $orders[$i];
                $orderParams = $this->safe_dict($rawOrder, 'params', array());
                $clientOrderId = $this->safe_string_2($orderParams, 'clientOrderId', 'client_id');
                if ($clientOrderId !== null) {
                    $hasClientOrderId = true;
                }
            }
            if ($hasClientOrderId) {
                for ($i = 0; $i < count($orders); $i++) {
                    $rawOrder = $orders[$i];
                    $orderParams = $this->safe_dict($rawOrder, 'params', array());
                    $clientOrderId = $this->safe_string_2($orderParams, 'clientOrderId', 'client_id');
                    if ($clientOrderId === null) {
                        throw new ArgumentsRequired($this->id . ' createOrders() all $orders must have $clientOrderId if at least one has a clientOrderId');
                    }
                }
            }
            $params = $this->omit($params, array( 'slippage', 'clientOrderId', 'client_id', 'slippage', 'triggerPrice', 'stopPrice', 'stopLossPrice', 'takeProfitPrice', 'timeInForce' ));
            $nonce = $this->milliseconds();
            $orderReq = array();
            for ($i = 0; $i < count($orders); $i++) {
                $rawOrder = $orders[$i];
                $marketId = $this->safe_string($rawOrder, 'symbol');
                $market = $this->market($marketId);
                $symbol = $market['symbol'];
                $type = $this->safe_string_upper($rawOrder, 'type');
                $isMarket = ($type === 'MARKET');
                $side = $this->safe_string_upper($rawOrder, 'side');
                $isBuy = ($side === 'BUY');
                $amount = $this->safe_string($rawOrder, 'amount');
                $price = $this->safe_string($rawOrder, 'price');
                $orderParams = $this->safe_dict($rawOrder, 'params', array());
                $clientOrderId = $this->safe_string_2($orderParams, 'clientOrderId', 'client_id');
                $slippage = $this->safe_string($orderParams, 'slippage', $defaultSlippage);
                $defaultTimeInForce = ($isMarket) ? 'ioc' : 'gtc';
                $postOnly = $this->safe_bool($orderParams, 'postOnly', false);
                if ($postOnly) {
                    $defaultTimeInForce = 'alo';
                }
                $timeInForce = $this->safe_string_lower($orderParams, 'timeInForce', $defaultTimeInForce);
                $timeInForce = $this->capitalize($timeInForce);
                $triggerPrice = $this->safe_string_2($orderParams, 'triggerPrice', 'stopPrice');
                $stopLossPrice = $this->safe_string($orderParams, 'stopLossPrice', $triggerPrice);
                $takeProfitPrice = $this->safe_string($orderParams, 'takeProfitPrice');
                $isTrigger = ($stopLossPrice || $takeProfitPrice);
                $px = null;
                if ($isMarket) {
                    if ($price === null) {
                        throw new ArgumentsRequired($this->id . '  $market $orders require $price to calculate the max $slippage $price-> Default $slippage can be set in options (default is 5%).');
                    }
                    $px = ($isBuy) ? Precise::string_mul($price, Precise::string_add('1', $slippage)) : Precise::string_mul($price, Precise::string_sub('1', $slippage));
                    $px = $this->price_to_precision($symbol, $px); // round after adding $slippage
                } else {
                    $px = $this->price_to_precision($symbol, $price);
                }
                $sz = $this->amount_to_precision($symbol, $amount);
                $reduceOnly = $this->safe_bool($orderParams, 'reduceOnly', false);
                $orderType = array();
                if ($isTrigger) {
                    $isTp = false;
                    if ($takeProfitPrice !== null) {
                        $triggerPrice = $this->price_to_precision($symbol, $takeProfitPrice);
                        $isTp = true;
                    } else {
                        $triggerPrice = $this->price_to_precision($symbol, $stopLossPrice);
                    }
                    $orderType['trigger'] = array(
                        'isMarket' => $isMarket,
                        'triggerPx' => $triggerPrice,
                        'tpsl' => ($isTp) ? 'tp' : 'sl',
                    );
                } else {
                    $orderType['limit'] = array(
                        'tif' => $timeInForce,
                    );
                }
                $orderParams = $this->omit($orderParams, array( 'clientOrderId', 'slippage', 'triggerPrice', 'stopPrice', 'stopLossPrice', 'takeProfitPrice', 'timeInForce', 'client_id', 'reduceOnly', 'postOnly' ));
                $orderObj = array(
                    'a' => $this->parse_to_int($market['baseId']),
                    'b' => $isBuy,
                    'p' => $px,
                    's' => $sz,
                    'r' => $reduceOnly,
                    't' => $orderType,
                    // 'c' => $clientOrderId,
                );
                if ($clientOrderId !== null) {
                    $orderObj['c'] = $clientOrderId;
                }
                $orderReq[] = array_merge($orderObj, $orderParams);
            }
            $vaultAddress = $this->format_vault_address($this->safe_string($params, 'vaultAddress'));
            $orderAction = array(
                'type' => 'order',
                'orders' => $orderReq,
                'grouping' => 'na',
                // 'brokerCode' => 1, // cant
            );
            if ($vaultAddress === null) {
                $orderAction['brokerCode'] = 1;
            }
            $signature = $this->sign_l1_action($orderAction, $nonce, $vaultAddress);
            $request = array(
                'action' => $orderAction,
                'nonce' => $nonce,
                'signature' => $signature,
                // 'vaultAddress' => $vaultAddress,
            );
            if ($vaultAddress !== null) {
                $params = $this->omit($params, 'vaultAddress');
                $request['vaultAddress'] = $vaultAddress;
            }
            $response = Async\await($this->privatePostExchange (array_merge($request, $params)));
            //
            //     {
            //         "status" => "ok",
            //         "response" => {
            //             "type" => "order",
            //             "data" => {
            //                 "statuses" => array(
            //                     {
            //                         "resting" => {
            //                             "oid" => 5063830287
            //                         }
            //                     }
            //                 )
            //             }
            //         }
            //     }
            //
            $responseObj = $this->safe_dict($response, 'response', array());
            $data = $this->safe_dict($responseObj, 'data', array());
            $statuses = $this->safe_list($data, 'statuses', array());
            return $this->parse_orders($statuses, null);
        }) ();
    }

    public function cancel_order(string $id, ?string $symbol = null, $params = array ()) {
        return Async\async(function () use ($id, $symbol, $params) {
            /**
             * cancels an open order
             * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/exchange-endpoint#cancel-order-s
             * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/exchange-endpoint#cancel-order-s-by-cloid
             * @param {string} $id order $id
             * @param {string} $symbol unified $symbol of the market the order was made in
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @param {string} [$params->clientOrderId] client order $id, (optional 128 bit hex string e.g. 0x1234567890abcdef1234567890abcdef)
             * @param {string} [$params->vaultAddress] the vault address for order
             * @return {array} An ~@link https://docs.ccxt.com/#/?$id=order-structure order structure~
             */
            return Async\await($this->cancel_orders(array( $id ), $symbol, $params));
        }) ();
    }

    public function cancel_orders(array $ids, ?string $symbol = null, $params = array ()) {
        return Async\async(function () use ($ids, $symbol, $params) {
            /**
             * cancel multiple orders
             * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/exchange-endpoint#cancel-order-s
             * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/exchange-endpoint#cancel-order-s-by-cloid
             * @param {string[]} $ids order $ids
             * @param {string} [$symbol] unified $market $symbol
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @param {string|string[]} [$params->clientOrderId] client order $ids, (optional 128 bit hex string e.g. 0x1234567890abcdef1234567890abcdef)
             * @param {string} [$params->vaultAddress] the vault address
             * @return {array} an list of ~@link https://docs.ccxt.com/#/?id=order-structure order structures~
             */
            $this->check_required_credentials();
            if ($symbol === null) {
                throw new ArgumentsRequired($this->id . ' cancelOrders() requires a $symbol argument');
            }
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $clientOrderId = $this->safe_value_2($params, 'clientOrderId', 'client_id');
            $params = $this->omit($params, array( 'clientOrderId', 'client_id' ));
            $nonce = $this->milliseconds();
            $request = array(
                'nonce' => $nonce,
                // 'vaultAddress' => $vaultAddress,
            );
            $cancelReq = array();
            $cancelAction = array(
                'type' => '',
                'cancels' => array(),
            );
            $baseId = $this->parse_to_numeric($market['baseId']);
            if ($clientOrderId !== null) {
                if (gettype($clientOrderId) !== 'array' || array_keys($clientOrderId) !== array_keys(array_keys($clientOrderId))) {
                    $clientOrderId = array( $clientOrderId );
                }
                $cancelAction['type'] = 'cancelByCloid';
                for ($i = 0; $i < count($clientOrderId); $i++) {
                    $cancelReq[] = array(
                        'asset' => $baseId,
                        'cloid' => $clientOrderId[$i],
                    );
                }
            } else {
                $cancelAction['type'] = 'cancel';
                for ($i = 0; $i < count($ids); $i++) {
                    $cancelReq[] = array(
                        'a' => $baseId,
                        'o' => $this->parse_to_numeric($ids[$i]),
                    );
                }
            }
            $cancelAction['cancels'] = $cancelReq;
            $vaultAddress = $this->format_vault_address($this->safe_string($params, 'vaultAddress'));
            $signature = $this->sign_l1_action($cancelAction, $nonce, $vaultAddress);
            $request['action'] = $cancelAction;
            $request['signature'] = $signature;
            if ($vaultAddress !== null) {
                $params = $this->omit($params, 'vaultAddress');
                $request['vaultAddress'] = $vaultAddress;
            }
            $response = Async\await($this->privatePostExchange (array_merge($request, $params)));
            //
            //     {
            //         "status":"ok",
            //         "response":{
            //             "type":"cancel",
            //             "data":{
            //                 "statuses":array(
            //                     "success"
            //                 )
            //             }
            //         }
            //     }
            //
            return $response;
        }) ();
    }

    public function cancel_orders_for_symbols(array $orders, $params = array ()) {
        return Async\async(function () use ($orders, $params) {
            /**
             * cancel multiple $orders for multiple symbols
             * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/exchange-endpoint#cancel-$order-s
             * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/exchange-endpoint#cancel-$order-s-by-cloid
             * @param {CancellationRequest[]} $orders each $order should contain the parameters required by cancelOrder namely $id and $symbol
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @param {string} [$params->vaultAddress] the vault address
             * @return {array} an list of ~@link https://docs.ccxt.com/#/?$id=$order-structure $order structures~
             */
            $this->check_required_credentials();
            Async\await($this->load_markets());
            $nonce = $this->milliseconds();
            $request = array(
                'nonce' => $nonce,
                // 'vaultAddress' => $vaultAddress,
            );
            $cancelReq = array();
            $cancelAction = array(
                'type' => '',
                'cancels' => array(),
            );
            $cancelByCloid = false;
            for ($i = 0; $i < count($orders); $i++) {
                $order = $orders[$i];
                $clientOrderId = $this->safe_string($order, 'clientOrderId');
                if ($clientOrderId !== null) {
                    $cancelByCloid = true;
                }
                $id = $this->safe_string($order, 'id');
                $symbol = $this->safe_string($order, 'symbol');
                if ($symbol === null) {
                    throw new ArgumentsRequired($this->id . ' cancelOrdersForSymbols() requires a $symbol argument in each order');
                }
                if ($id !== null && $cancelByCloid) {
                    throw new BadRequest($this->id . ' cancelOrdersForSymbols() all $orders must have either $id or clientOrderId');
                }
                $assetKey = $cancelByCloid ? 'asset' : 'a';
                $idKey = $cancelByCloid ? 'cloid' : 'o';
                $market = $this->market($symbol);
                $cancelObj = array();
                $cancelObj[$assetKey] = $this->parse_to_numeric($market['baseId']);
                $cancelObj[$idKey] = $cancelByCloid ? $clientOrderId : $this->parse_to_numeric($id);
                $cancelReq[] = $cancelObj;
            }
            $cancelAction['type'] = $cancelByCloid ? 'cancelByCloid' : 'cancel';
            $cancelAction['cancels'] = $cancelReq;
            $vaultAddress = $this->format_vault_address($this->safe_string($params, 'vaultAddress'));
            $signature = $this->sign_l1_action($cancelAction, $nonce, $vaultAddress);
            $request['action'] = $cancelAction;
            $request['signature'] = $signature;
            if ($vaultAddress !== null) {
                $params = $this->omit($params, 'vaultAddress');
                $request['vaultAddress'] = $vaultAddress;
            }
            $response = Async\await($this->privatePostExchange (array_merge($request, $params)));
            //
            //     {
            //         "status":"ok",
            //         "response":{
            //             "type":"cancel",
            //             "data":{
            //                 "statuses":array(
            //                     "success"
            //                 )
            //             }
            //         }
            //     }
            //
            return $response;
        }) ();
    }

    public function cancel_all_orders_after(?int $timeout, $params = array ()) {
        return Async\async(function () use ($timeout, $params) {
            /**
             * dead man's switch, cancel all orders after the given $timeout
             * @param {number} $timeout time in milliseconds, 0 represents cancel the timer
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @param {string} [$params->vaultAddress] the vault address
             * @return {array} the api result
             */
            $this->check_required_credentials();
            Async\await($this->load_markets());
            $params = $this->omit($params, array( 'clientOrderId', 'client_id' ));
            $nonce = $this->milliseconds();
            $request = array(
                'nonce' => $nonce,
                // 'vaultAddress' => $vaultAddress,
            );
            $cancelAction = array(
                'type' => 'scheduleCancel',
                'time' => $nonce . $timeout,
            );
            $vaultAddress = $this->format_vault_address($this->safe_string($params, 'vaultAddress'));
            $signature = $this->sign_l1_action($cancelAction, $nonce, $vaultAddress);
            $request['action'] = $cancelAction;
            $request['signature'] = $signature;
            if ($vaultAddress !== null) {
                $params = $this->omit($params, 'vaultAddress');
                $request['vaultAddress'] = $vaultAddress;
            }
            $response = Async\await($this->privatePostExchange (array_merge($request, $params)));
            //
            //     {
            //         "status":"err",
            //         "response":"Cannot set scheduled cancel time until enough volume traded. Required => $1000000. Traded => $373.47205."
            //     }
            //
            return $response;
        }) ();
    }

    public function edit_order(string $id, string $symbol, string $type, string $side, ?float $amount = null, ?float $price = null, $params = array ()) {
        return Async\async(function () use ($id, $symbol, $type, $side, $amount, $price, $params) {
            /**
             * edit a trade order
             * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/exchange-endpoint#modify-an-order
             * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/exchange-endpoint#modify-multiple-orders
             * @param {string} $id cancel order $id
             * @param {string} $symbol unified $symbol of the $market to create an order in
             * @param {string} $type 'market' or 'limit'
             * @param {string} $side 'buy' or 'sell'
             * @param {float} $amount how much of currency you want to trade in units of base currency
             * @param {float} [$price] the $price at which the order is to be fullfilled, in units of the base currency, ignored in $market orders
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @param {string} [$params->timeInForce] 'Gtc', 'Ioc', 'Alo'
             * @param {bool} [$params->postOnly] true or false whether the order is post-only
             * @param {bool} [$params->reduceOnly] true or false whether the order is reduce-only
             * @param {float} [$params->triggerPrice] The $price at which a trigger order is triggered at
             * @param {string} [$params->clientOrderId] client order $id, (optional 128 bit hex string e.g. 0x1234567890abcdef1234567890abcdef)
             * @param {string} [$params->vaultAddress] the vault address for order
             * @return {array} an ~@link https://docs.ccxt.com/#/?$id=order-structure order structure~
             */
            $this->check_required_credentials();
            if ($id === null) {
                throw new ArgumentsRequired($this->id . ' editOrder() requires an $id argument');
            }
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $type = strtoupper($type);
            $isMarket = ($type === 'MARKET');
            $side = strtoupper($side);
            $isBuy = ($side === 'BUY');
            $defaultSlippage = $this->safe_string($this->options, 'defaultSlippage');
            $slippage = $this->safe_string($params, 'slippage', $defaultSlippage);
            $defaultTimeInForce = ($isMarket) ? 'ioc' : 'gtc';
            $postOnly = $this->safe_bool($params, 'postOnly', false);
            if ($postOnly) {
                $defaultTimeInForce = 'alo';
            }
            $timeInForce = $this->safe_string_lower($params, 'timeInForce', $defaultTimeInForce);
            $timeInForce = $this->capitalize($timeInForce);
            $clientOrderId = $this->safe_string_2($params, 'clientOrderId', 'client_id');
            $triggerPrice = $this->safe_string_2($params, 'triggerPrice', 'stopPrice');
            $stopLossPrice = $this->safe_string($params, 'stopLossPrice', $triggerPrice);
            $takeProfitPrice = $this->safe_string($params, 'takeProfitPrice');
            $isTrigger = ($stopLossPrice || $takeProfitPrice);
            $params = $this->omit($params, array( 'slippage', 'timeInForce', 'triggerPrice', 'stopLossPrice', 'takeProfitPrice', 'clientOrderId', 'client_id' ));
            $px = (string) $price;
            if ($isMarket) {
                $px = ($isBuy) ? (string) Precise::string_mul($price, Precise::string_add('1', $slippage)) : (string) Precise::string_mul($price, Precise::string_sub('1', $slippage));
            } else {
                $px = $this->price_to_precision($symbol, (string) $price);
            }
            $sz = $this->amount_to_precision($symbol, $amount);
            $reduceOnly = $this->safe_bool($params, 'reduceOnly', false);
            $orderType = array();
            if ($isTrigger) {
                $isTp = false;
                if ($takeProfitPrice !== null) {
                    $triggerPrice = $this->price_to_precision($symbol, $takeProfitPrice);
                    $isTp = true;
                } else {
                    $triggerPrice = $this->price_to_precision($symbol, $stopLossPrice);
                }
                $orderType['trigger'] = array(
                    'isMarket' => $isMarket,
                    'triggerPx' => $triggerPrice,
                    'tpsl' => ($isTp) ? 'tp' : 'sl',
                );
            } else {
                $orderType['limit'] = array(
                    'tif' => $timeInForce,
                );
            }
            if ($triggerPrice === null) {
                $triggerPrice = '0';
            }
            $nonce = $this->milliseconds();
            $orderReq = array(
                'a' => $this->parse_to_int($market['baseId']),
                'b' => $isBuy,
                'p' => $px,
                's' => $sz,
                'r' => $reduceOnly,
                't' => $orderType,
                // 'c' => $clientOrderId,
            );
            if ($clientOrderId !== null) {
                $orderReq['c'] = $clientOrderId;
            }
            $modifyReq = array(
                'oid' => $this->parse_to_int($id),
                'order' => $orderReq,
            );
            $modifyAction = array(
                'type' => 'batchModify',
                'modifies' => array( $modifyReq ),
            );
            $vaultAddress = $this->format_vault_address($this->safe_string($params, 'vaultAddress'));
            $signature = $this->sign_l1_action($modifyAction, $nonce, $vaultAddress);
            $request = array(
                'action' => $modifyAction,
                'nonce' => $nonce,
                'signature' => $signature,
                // 'vaultAddress' => $vaultAddress,
            );
            if ($vaultAddress !== null) {
                $params = $this->omit($params, 'vaultAddress');
                $request['vaultAddress'] = $vaultAddress;
            }
            $response = Async\await($this->privatePostExchange (array_merge($request, $params)));
            //
            //     {
            //         "status" => "ok",
            //         "response" => {
            //             "type" => "order",
            //             "data" => {
            //                 "statuses" => array(
            //                     {
            //                         "resting" => {
            //                             "oid" => 5063830287
            //                         }
            //                     }
            //                 )
            //             }
            //         }
            //     }
            // when the order is filled immediately
            //     {
            //         "status":"ok",
            //         "response":{
            //            "type":"order",
            //            "data":{
            //               "statuses":array(
            //                  {
            //                     "filled":{
            //                        "totalSz":"0.1",
            //                        "avgPx":"100.84",
            //                        "oid":6195281425
            //                     }
            //                  }
            //               )
            //            }
            //         }
            //     }
            //
            $responseObject = $this->safe_dict($response, 'response', array());
            $dataObject = $this->safe_dict($responseObject, 'data', array());
            $statuses = $this->safe_list($dataObject, 'statuses', array());
            $first = $this->safe_dict($statuses, 0, array());
            return $this->parse_order($first, $market);
        }) ();
    }

    public function fetch_funding_rate_history(?string $symbol = null, ?int $since = null, ?int $limit = null, $params = array ()) {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            /**
             * fetches historical funding rate prices
             * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/info-endpoint#retrieve-historical-funding-rates
             * @param {string} $symbol unified $symbol of the $market to fetch the funding rate history for
             * @param {int} [$since] $timestamp in ms of the earliest funding rate to fetch
             * @param {int} [$limit] the maximum amount of ~@link https://docs.ccxt.com/#/?id=funding-rate-history-structure funding rate structures~ to fetch
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @param {int} [$params->until] $timestamp in ms of the latest funding rate
             * @return {array[]} a list of ~@link https://docs.ccxt.com/#/?id=funding-rate-history-structure funding rate structures~
             */
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $request = array(
                'type' => 'fundingHistory',
                'coin' => $market['base'],
            );
            if ($since !== null) {
                $request['startTime'] = $since;
            } else {
                $request['startTime'] = $this->milliseconds() - 100 * 60 * 60 * 1000;
            }
            $until = $this->safe_integer($params, 'until');
            $params = $this->omit($params, 'until');
            if ($until !== null) {
                $request['endTime'] = $until;
            }
            $response = Async\await($this->publicPostInfo (array_merge($request, $params)));
            //
            //     array(
            //         {
            //             "coin" => "ETH",
            //             "fundingRate" => "0.0000125",
            //             "premium" => "0.00057962",
            //             "time" => 1704290400031
            //         }
            //     )
            //
            $result = array();
            for ($i = 0; $i < count($response); $i++) {
                $entry = $response[$i];
                $timestamp = $this->safe_integer($entry, 'time');
                $result[] = array(
                    'info' => $entry,
                    'symbol' => $this->safe_symbol(null, $market),
                    'fundingRate' => $this->safe_number($entry, 'fundingRate'),
                    'timestamp' => $timestamp,
                    'datetime' => $this->iso8601($timestamp),
                );
            }
            $sorted = $this->sort_by($result, 'timestamp');
            return $this->filter_by_symbol_since_limit($sorted, $symbol, $since, $limit);
        }) ();
    }

    public function fetch_open_orders(?string $symbol = null, ?int $since = null, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            /**
             * fetch all unfilled currently open orders
             * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/info-endpoint#retrieve-a-users-open-orders
             * @param {string} $symbol unified $market $symbol
             * @param {int} [$since] the earliest time in ms to fetch open orders for
             * @param {int} [$limit] the maximum number of open orders structures to retrieve
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @param {string} [$params->user] user address, will default to $this->walletAddress if not provided
             * @return {Order[]} a list of ~@link https://docs.ccxt.com/#/?id=order-structure order structures~
             */
            $userAddress = null;
            list($userAddress, $params) = $this->handle_public_address('fetchOpenOrders', $params);
            Async\await($this->load_markets());
            $market = $this->safe_market($symbol);
            $request = array(
                'type' => 'openOrders',
                'user' => $userAddress,
            );
            $response = Async\await($this->publicPostInfo (array_merge($request, $params)));
            //
            //     array(
            //         {
            //             "coin" => "ETH",
            //             "limitPx" => "2000.0",
            //             "oid" => 3991946565,
            //             "origSz" => "0.1",
            //             "side" => "B",
            //             "sz" => "0.1",
            //             "timestamp" => 1704346468838
            //         }
            //     )
            //
            return $this->parse_orders($response, $market, $since, $limit);
        }) ();
    }

    public function fetch_closed_orders(?string $symbol = null, ?int $since = null, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            /**
             * fetch all unfilled currently closed orders
             * @param {string} $symbol unified $market $symbol
             * @param {int} [$since] the earliest time in ms to fetch open orders for
             * @param {int} [$limit] the maximum number of open orders structures to retrieve
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @param {string} [$params->user] user address, will default to $this->walletAddress if not provided
             * @return {Order[]} a list of ~@link https://docs.ccxt.com/#/?id=order-structure order structures~
             */
            $userAddress = null;
            list($userAddress, $params) = $this->handle_public_address('fetchClosedOrders', $params);
            Async\await($this->load_markets());
            $market = $this->safe_market($symbol);
            $request = array(
                'type' => 'historicalOrders',
                'user' => $userAddress,
            );
            $response = Async\await($this->publicPostInfo (array_merge($request, $params)));
            //
            //     array(
            //         {
            //             "coin" => "ETH",
            //             "limitPx" => "2000.0",
            //             "oid" => 3991946565,
            //             "origSz" => "0.1",
            //             "side" => "B",
            //             "sz" => "0.1",
            //             "timestamp" => 1704346468838
            //         }
            //     )
            //
            return $this->parse_orders($response, $market, $since, $limit);
        }) ();
    }

    public function fetch_order(string $id, ?string $symbol = null, $params = array ()) {
        return Async\async(function () use ($id, $symbol, $params) {
            /**
             * fetches information on an order made by the user
             * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/info-endpoint#query-order-status-by-oid-or-cloid
             * @param {string} $symbol unified $symbol of the $market the order was made in
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @param {string} [$params->user] user address, will default to $this->walletAddress if not provided
             * @return {array} An ~@link https://docs.ccxt.com/#/?$id=order-structure order structure~
             */
            $userAddress = null;
            list($userAddress, $params) = $this->handle_public_address('fetchOrder', $params);
            Async\await($this->load_markets());
            $market = $this->safe_market($symbol);
            $request = array(
                'type' => 'orderStatus',
                'oid' => $this->parse_to_numeric($id),
                'user' => $userAddress,
            );
            $response = Async\await($this->publicPostInfo (array_merge($request, $params)));
            //
            //     {
            //         "order" => array(
            //             "order" => array(
            //                 "children" => array(),
            //                 "cloid" => null,
            //                 "coin" => "ETH",
            //                 "isPositionTpsl" => false,
            //                 "isTrigger" => false,
            //                 "limitPx" => "2000.0",
            //                 "oid" => "3991946565",
            //                 "orderType" => "Limit",
            //                 "origSz" => "0.1",
            //                 "reduceOnly" => false,
            //                 "side" => "B",
            //                 "sz" => "0.1",
            //                 "tif" => "Gtc",
            //                 "timestamp" => "1704346468838",
            //                 "triggerCondition" => "N/A",
            //                 "triggerPx" => "0.0"
            //             ),
            //             "status" => "open",
            //             "statusTimestamp" => "1704346468838"
            //         ),
            //         "status" => "order"
            //     }
            //
            $data = $this->safe_dict($response, 'order');
            return $this->parse_order($data, $market);
        }) ();
    }

    public function parse_order($order, ?array $market = null): array {
        //
        //  fetchOpenOrders
        //
        //     {
        //         "coin" => "ETH",
        //         "limitPx" => "2000.0",
        //         "oid" => 3991946565,
        //         "origSz" => "0.1",
        //         "side" => "B",
        //         "sz" => "0.1",
        //         "timestamp" => 1704346468838
        //     }
        // fetchClosedorders
        //    {
        //        "cloid" => null,
        //        "closedPnl" => "0.0",
        //        "coin" => "SOL",
        //        "crossed" => true,
        //        "dir" => "Open Long",
        //        "fee" => "0.003879",
        //        "hash" => "0x4a2647998682b7f07bc5040ab531e1011400f9a51bfa0346a0b41ebe510e8875",
        //        "liquidationMarkPx" => null,
        //        "oid" => "6463280784",
        //        "px" => "110.83",
        //        "side" => "B",
        //        "startPosition" => "1.64",
        //        "sz" => "0.1",
        //        "tid" => "232174667018988",
        //        "time" => "1709142268394"
        //    }
        //
        //  fetchOrder
        //
        //     {
        //         "order" => array(
        //             "children" => array(),
        //             "cloid" => null,
        //             "coin" => "ETH",
        //             "isPositionTpsl" => false,
        //             "isTrigger" => false,
        //             "limitPx" => "2000.0",
        //             "oid" => "3991946565",
        //             "orderType" => "Limit",
        //             "origSz" => "0.1",
        //             "reduceOnly" => false,
        //             "side" => "B",
        //             "sz" => "0.1",
        //             "tif" => "Gtc",
        //             "timestamp" => "1704346468838",
        //             "triggerCondition" => "N/A",
        //             "triggerPx" => "0.0"
        //         ),
        //         "status" => "open",
        //         "statusTimestamp" => "1704346468838"
        //     }
        //
        // createOrder
        //
        //     {
        //         "resting" => {
        //             "oid" => 5063830287
        //         }
        //     }
        //
        //     {
        //        "filled":{
        //           "totalSz":"0.1",
        //           "avgPx":"100.84",
        //           "oid":6195281425
        //        }
        //     }
        //
        $entry = $this->safe_dict_n($order, array( 'order', 'resting', 'filled' ));
        if ($entry === null) {
            $entry = $order;
        }
        $coin = $this->safe_string($entry, 'coin');
        $marketId = null;
        if ($coin !== null) {
            if (mb_strpos($coin, '/') > -1) {
                $marketId = $coin;
            } else {
                $marketId = $coin . '/USDC:USDC';
            }
        }
        if ($this->safe_string($entry, 'id') === null) {
            $market = $this->safe_market($marketId, null);
        } else {
            $market = $this->safe_market($marketId, $market);
        }
        $symbol = $market['symbol'];
        $timestamp = $this->safe_integer_2($order, 'timestamp', 'statusTimestamp');
        $status = $this->safe_string($order, 'status');
        $side = $this->safe_string($entry, 'side');
        if ($side !== null) {
            $side = ($side === 'A') ? 'sell' : 'buy';
        }
        return $this->safe_order(array(
            'info' => $order,
            'id' => $this->safe_string($entry, 'oid'),
            'clientOrderId' => $this->safe_string($entry, 'cloid'),
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'lastTradeTimestamp' => null,
            'lastUpdateTimestamp' => null,
            'symbol' => $symbol,
            'type' => $this->safe_string_lower($entry, 'orderType'),
            'timeInForce' => $this->safe_string_upper($entry, 'tif'),
            'postOnly' => null,
            'reduceOnly' => $this->safe_bool($entry, 'reduceOnly'),
            'side' => $side,
            'price' => $this->safe_number($entry, 'limitPx'),
            'triggerPrice' => $this->safe_bool($entry, 'isTrigger') ? $this->safe_number($entry, 'triggerPx') : null,
            'amount' => $this->safe_number_2($entry, 'sz', 'totalSz'),
            'cost' => null,
            'average' => $this->safe_number($entry, 'avgPx'),
            'filled' => null,
            'remaining' => null,
            'status' => $this->parse_order_status($status),
            'fee' => null,
            'trades' => null,
        ), $market);
    }

    public function parse_order_status($status) {
        $statuses = array(
            'triggered' => 'open',
            'filled' => 'closed',
        );
        return $this->safe_string($statuses, $status, $status);
    }

    public function parse_order_type($status) {
        $statuses = array(
            'stop limit' => 'limit',
            'stop market' => 'market',
        );
        return $this->safe_string($statuses, $status, $status);
    }

    public function fetch_my_trades(?string $symbol = null, ?int $since = null, ?int $limit = null, $params = array ()) {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            /**
             * fetch all trades made by the user
             * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/info-endpoint#retrieve-a-users-fills
             * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/info-endpoint#retrieve-a-users-fills-by-time
             * @param {string} $symbol unified $market $symbol
             * @param {int} [$since] the earliest time in ms to fetch trades for
             * @param {int} [$limit] the maximum number of trades structures to retrieve
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @param {int} [$params->until] timestamp in ms of the latest trade
             * @return {Trade[]} a list of ~@link https://docs.ccxt.com/#/?id=trade-structure trade structures~
             */
            $userAddress = null;
            list($userAddress, $params) = $this->handle_public_address('fetchMyTrades', $params);
            Async\await($this->load_markets());
            $market = $this->safe_market($symbol);
            $request = array(
                'user' => $userAddress,
            );
            if ($since !== null) {
                $request['type'] = 'userFillsByTime';
                $request['startTime'] = $since;
            } else {
                $request['type'] = 'userFills';
            }
            $until = $this->safe_integer($params, 'until');
            $params = $this->omit($params, 'until');
            if ($until !== null) {
                $request['endTime'] = $until;
            }
            $response = Async\await($this->publicPostInfo (array_merge($request, $params)));
            //
            //     array(
            //         {
            //             "closedPnl" => "0.19343",
            //             "coin" => "ETH",
            //             "crossed" => true,
            //             "dir" => "Close Long",
            //             "fee" => "0.050062",
            //             "hash" => "0x09d77c96791e98b5775a04092584ab010d009445119c71e4005c0d634ea322bc",
            //             "liquidationMarkPx" => null,
            //             "oid" => 3929354691,
            //             "px" => "2381.1",
            //             "side" => "A",
            //             "startPosition" => "0.0841",
            //             "sz" => "0.0841",
            //             "tid" => 128423918764978,
            //             "time" => 1704262888911
            //         }
            //     )
            //
            return $this->parse_trades($response, $market, $since, $limit);
        }) ();
    }

    public function parse_trade($trade, ?array $market = null): array {
        //
        //     {
        //         "closedPnl" => "0.19343",
        //         "coin" => "ETH",
        //         "crossed" => true,
        //         "dir" => "Close Long",
        //         "fee" => "0.050062",
        //         "hash" => "0x09d77c96791e98b5775a04092584ab010d009445119c71e4005c0d634ea322bc",
        //         "liquidationMarkPx" => null,
        //         "oid" => 3929354691,
        //         "px" => "2381.1",
        //         "side" => "A",
        //         "startPosition" => "0.0841",
        //         "sz" => "0.0841",
        //         "tid" => 128423918764978,
        //         "time" => 1704262888911
        //     }
        //
        $timestamp = $this->safe_integer($trade, 'time');
        $price = $this->safe_string($trade, 'px');
        $amount = $this->safe_string($trade, 'sz');
        $coin = $this->safe_string($trade, 'coin');
        $marketId = $coin . '/USDC:USDC';
        $market = $this->safe_market($marketId, null);
        $symbol = $market['symbol'];
        $id = $this->safe_string($trade, 'tid');
        $side = $this->safe_string($trade, 'side');
        if ($side !== null) {
            $side = ($side === 'A') ? 'sell' : 'buy';
        }
        $fee = $this->safe_string($trade, 'fee');
        return $this->safe_trade(array(
            'info' => $trade,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'symbol' => $symbol,
            'id' => $id,
            'order' => $this->safe_string($trade, 'oid'),
            'type' => null,
            'side' => $side,
            'takerOrMaker' => null,
            'price' => $price,
            'amount' => $amount,
            'cost' => null,
            'fee' => array( 'cost' => $fee, 'currency' => 'USDC' ),
        ), $market);
    }

    public function fetch_position(string $symbol, $params = array ()) {
        return Async\async(function () use ($symbol, $params) {
            /**
             * fetch data on an open position
             * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/info-endpoint#retrieve-a-users-state
             * @param {string} $symbol unified market $symbol of the market the position is held in
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @param {string} [$params->user] user address, will default to $this->walletAddress if not provided
             * @return {array} a ~@link https://docs.ccxt.com/#/?id=position-structure position structure~
             */
            $positions = Async\await($this->fetch_positions(array( $symbol ), $params));
            return $this->safe_dict($positions, 0, array());
        }) ();
    }

    public function fetch_positions(?array $symbols = null, $params = array ()) {
        return Async\async(function () use ($symbols, $params) {
            /**
             * fetch all open positions
             * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/info-endpoint#retrieve-a-users-state
             * @param {string[]} [$symbols] list of unified market $symbols
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @param {string} [$params->user] user address, will default to $this->walletAddress if not provided
             * @return {array[]} a list of ~@link https://docs.ccxt.com/#/?id=position-structure position structure~
             */
            Async\await($this->load_markets());
            $userAddress = null;
            list($userAddress, $params) = $this->handle_public_address('fetchPositions', $params);
            $symbols = $this->market_symbols($symbols);
            $request = array(
                'type' => 'clearinghouseState',
                'user' => $userAddress,
            );
            $response = Async\await($this->publicPostInfo (array_merge($request, $params)));
            //
            //     {
            //         "assetPositions" => array(
            //             {
            //                 "position" => array(
            //                     "coin" => "ETH",
            //                     "cumFunding" => array(
            //                         "allTime" => "0.0",
            //                         "sinceChange" => "0.0",
            //                         "sinceOpen" => "0.0"
            //                     ),
            //                     "entryPx" => "2213.9",
            //                     "leverage" => array(
            //                         "rawUsd" => "-475.23904",
            //                         "type" => "isolated",
            //                         "value" => "20"
            //                     ),
            //                     "liquidationPx" => "2125.00856238",
            //                     "marginUsed" => "24.88097",
            //                     "maxLeverage" => "50",
            //                     "positionValue" => "500.12001",
            //                     "returnOnEquity" => "0.0",
            //                     "szi" => "0.2259",
            //                     "unrealizedPnl" => "0.0"
            //                 ),
            //                 "type" => "oneWay"
            //             }
            //         ),
            //         "crossMaintenanceMarginUsed" => "0.0",
            //         "crossMarginSummary" => array(
            //             "accountValue" => "100.0",
            //             "totalMarginUsed" => "0.0",
            //             "totalNtlPos" => "0.0",
            //             "totalRawUsd" => "100.0"
            //         ),
            //         "marginSummary" => array(
            //             "accountValue" => "100.0",
            //             "totalMarginUsed" => "0.0",
            //             "totalNtlPos" => "0.0",
            //             "totalRawUsd" => "100.0"
            //         ),
            //         "time" => "1704261007014",
            //         "withdrawable" => "100.0"
            //     }
            //
            $data = $this->safe_list($response, 'assetPositions', array());
            $result = array();
            for ($i = 0; $i < count($data); $i++) {
                $result[] = $this->parse_position($data[$i], null);
            }
            return $this->filter_by_array_positions($result, 'symbol', $symbols, false);
        }) ();
    }

    public function parse_position($position, ?array $market = null) {
        //
        //     {
        //         "position" => array(
        //             "coin" => "ETH",
        //             "cumFunding" => array(
        //                 "allTime" => "0.0",
        //                 "sinceChange" => "0.0",
        //                 "sinceOpen" => "0.0"
        //             ),
        //             "entryPx" => "2213.9",
        //             "leverage" => array(
        //                 "rawUsd" => "-475.23904",
        //                 "type" => "isolated",
        //                 "value" => "20"
        //             ),
        //             "liquidationPx" => "2125.00856238",
        //             "marginUsed" => "24.88097",
        //             "maxLeverage" => "50",
        //             "positionValue" => "500.12001",
        //             "returnOnEquity" => "0.0",
        //             "szi" => "0.2259",
        //             "unrealizedPnl" => "0.0"
        //         ),
        //         "type" => "oneWay"
        //     }
        //
        $entry = $this->safe_dict($position, 'position', array());
        $coin = $this->safe_string($entry, 'coin');
        $marketId = $coin . '/USDC:USDC';
        $market = $this->safe_market($marketId, null);
        $symbol = $market['symbol'];
        $leverage = $this->safe_dict($entry, 'leverage', array());
        $isIsolated = ($this->safe_string($leverage, 'type') === 'isolated');
        $quantity = $this->safe_number($leverage, 'rawUsd');
        $side = null;
        if ($quantity !== null) {
            $side = ($quantity > 0) ? 'short' : 'long';
        }
        $unrealizedPnl = $this->safe_number($entry, 'unrealizedPnl');
        $initialMargin = $this->safe_number($entry, 'marginUsed');
        $percentage = $unrealizedPnl / $initialMargin * 100;
        return $this->safe_position(array(
            'info' => $position,
            'id' => null,
            'symbol' => $symbol,
            'timestamp' => null,
            'datetime' => null,
            'isolated' => $isIsolated,
            'hedged' => null,
            'side' => $side,
            'contracts' => $this->safe_number($entry, 'szi'),
            'contractSize' => null,
            'entryPrice' => $this->safe_number($entry, 'entryPx'),
            'markPrice' => null,
            'notional' => $this->safe_number($entry, 'positionValue'),
            'leverage' => $this->safe_number($leverage, 'value'),
            'collateral' => null,
            'initialMargin' => $initialMargin,
            'maintenanceMargin' => null,
            'initialMarginPercentage' => null,
            'maintenanceMarginPercentage' => null,
            'unrealizedPnl' => $unrealizedPnl,
            'liquidationPrice' => $this->safe_number($entry, 'liquidationPx'),
            'marginMode' => null,
            'percentage' => $percentage,
        ));
    }

    public function set_margin_mode(string $marginMode, ?string $symbol = null, $params = array ()) {
        return Async\async(function () use ($marginMode, $symbol, $params) {
            /**
             * set margin mode ($symbol)
             * @param {string} $marginMode margin mode must be either [isolated, cross]
             * @param {string} $symbol unified $market $symbol of the $market the position is held in, default is null
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @param {string} [$params->leverage] the rate of $leverage, is required if setting trade mode ($symbol)
             * @return {array} $response from the exchange
             */
            if ($symbol === null) {
                throw new ArgumentsRequired($this->id . ' setMarginMode() requires a $symbol argument');
            }
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $leverage = $this->safe_integer($params, 'leverage');
            if ($leverage === null) {
                throw new ArgumentsRequired($this->id . ' setMarginMode() requires a $leverage parameter');
            }
            $asset = $this->parse_to_int($market['baseId']);
            $isCross = ($marginMode === 'cross');
            $nonce = $this->milliseconds();
            $params = $this->omit($params, array( 'leverage' ));
            $updateAction = array(
                'type' => 'updateLeverage',
                'asset' => $asset,
                'isCross' => $isCross,
                'leverage' => $leverage,
            );
            $vaultAddress = $this->safe_string($params, 'vaultAddress');
            if ($vaultAddress !== null) {
                $params = $this->omit($params, 'vaultAddress');
                if (str_starts_with($vaultAddress, '0x')) {
                    $vaultAddress = str_replace('0x', '', $vaultAddress);
                }
            }
            $extendedAction = array_merge($updateAction, $params);
            $signature = $this->sign_l1_action($extendedAction, $nonce, $vaultAddress);
            $request = array(
                'action' => $extendedAction,
                'nonce' => $nonce,
                'signature' => $signature,
                // 'vaultAddress' => $vaultAddress,
            );
            if ($vaultAddress !== null) {
                $request['vaultAddress'] = $vaultAddress;
            }
            $response = Async\await($this->privatePostExchange ($request));
            //
            //     {
            //         'response' => array(
            //             'type' => 'default'
            //         ),
            //         'status' => 'ok'
            //     }
            //
            return $response;
        }) ();
    }

    public function set_leverage(?int $leverage, ?string $symbol = null, $params = array ()) {
        return Async\async(function () use ($leverage, $symbol, $params) {
            /**
             * set the level of $leverage for a $market
             * @param {float} $leverage the rate of $leverage
             * @param {string} $symbol unified $market $symbol
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @param {string} [$params->marginMode] margin mode must be either [isolated, cross], default is cross
             * @return {array} $response from the exchange
             */
            if ($symbol === null) {
                throw new ArgumentsRequired($this->id . ' setLeverage() requires a $symbol argument');
            }
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $marginMode = $this->safe_string($params, 'marginMode', 'cross');
            $isCross = ($marginMode === 'cross');
            $asset = $this->parse_to_int($market['baseId']);
            $nonce = $this->milliseconds();
            $params = $this->omit($params, 'marginMode');
            $updateAction = array(
                'type' => 'updateLeverage',
                'asset' => $asset,
                'isCross' => $isCross,
                'leverage' => $leverage,
            );
            $vaultAddress = $this->format_vault_address($this->safe_string($params, 'vaultAddress'));
            $signature = $this->sign_l1_action($updateAction, $nonce, $vaultAddress);
            $request = array(
                'action' => $updateAction,
                'nonce' => $nonce,
                'signature' => $signature,
                // 'vaultAddress' => $vaultAddress,
            );
            if ($vaultAddress !== null) {
                $params = $this->omit($params, 'vaultAddress');
                $request['vaultAddress'] = $vaultAddress;
            }
            $response = Async\await($this->privatePostExchange (array_merge($request, $params)));
            //
            //     {
            //         'response' => array(
            //             'type' => 'default'
            //         ),
            //         'status' => 'ok'
            //     }
            //
            return $response;
        }) ();
    }

    public function add_margin(string $symbol, float $amount, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $amount, $params) {
            /**
             * add margin
             * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/exchange-endpoint#update-isolated-margin
             * @param {string} $symbol unified market $symbol
             * @param {float} $amount amount of margin to add
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} a ~@link https://docs.ccxt.com/#/?id=add-margin-structure margin structure~
             */
            return Async\await($this->modify_margin_helper($symbol, $amount, 'add', $params));
        }) ();
    }

    public function reduce_margin(string $symbol, float $amount, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $amount, $params) {
            /**
             * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/exchange-endpoint#update-isolated-margin
             * remove margin from a position
             * @param {string} $symbol unified market $symbol
             * @param {float} $amount the $amount of margin to remove
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} a ~@link https://docs.ccxt.com/#/?id=reduce-margin-structure margin structure~
             */
            return Async\await($this->modify_margin_helper($symbol, $amount, 'reduce', $params));
        }) ();
    }

    public function modify_margin_helper(string $symbol, $amount, $type, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $amount, $type, $params) {
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $asset = $this->parse_to_int($market['baseId']);
            $sz = $this->parse_to_int(Precise::string_mul($this->amount_to_precision($symbol, $amount), '1000000'));
            if ($type === 'reduce') {
                $sz = -$sz;
            }
            $nonce = $this->milliseconds();
            $updateAction = array(
                'type' => 'updateIsolatedMargin',
                'asset' => $asset,
                'isBuy' => true,
                'ntli' => $sz,
            );
            $vaultAddress = $this->format_vault_address($this->safe_string($params, 'vaultAddress'));
            $signature = $this->sign_l1_action($updateAction, $nonce, $vaultAddress);
            $request = array(
                'action' => $updateAction,
                'nonce' => $nonce,
                'signature' => $signature,
                // 'vaultAddress' => $vaultAddress,
            );
            if ($vaultAddress !== null) {
                $params = $this->omit($params, 'vaultAddress');
                $request['vaultAddress'] = $vaultAddress;
            }
            $response = Async\await($this->privatePostExchange (array_merge($request, $params)));
            //
            //     {
            //         'response' => array(
            //             'type' => 'default'
            //         ),
            //         'status' => 'ok'
            //     }
            //
            return array_merge($this->parse_margin_modification($response, $market), array(
                'code' => $this->safe_string($response, 'status'),
            ));
        }) ();
    }

    public function parse_margin_modification($data, ?array $market = null): array {
        //
        //    {
        //        'type' => 'default'
        //    }
        //
        return array(
            'info' => $data,
            'symbol' => $this->safe_symbol(null, $market),
            'type' => null,
            'marginMode' => 'isolated',
            'amount' => null,
            'total' => null,
            'code' => $this->safe_string($market, 'settle'),
            'status' => null,
            'timestamp' => null,
            'datetime' => null,
        );
    }

    public function transfer(string $code, float $amount, string $fromAccount, string $toAccount, $params = array ()): PromiseInterface {
        return Async\async(function () use ($code, $amount, $fromAccount, $toAccount, $params) {
            /**
             * transfer currency internally between wallets on the same account
             * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/exchange-endpoint#l1-usdc-transfer
             * @param {string} $code unified currency $code
             * @param {float} $amount amount to transfer
             * @param {string} $fromAccount account to transfer from *spot, swap*
             * @param {string} $toAccount account to transfer to *swap, spot or address*
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @param {string} [$params->vaultAddress] the vault address for order
             * @return {array} a ~@link https://docs.ccxt.com/#/?id=transfer-structure transfer structure~
             */
            $this->check_required_credentials();
            Async\await($this->load_markets());
            $isSandboxMode = $this->safe_bool($this->options, 'sandboxMode');
            $nonce = $this->milliseconds();
            if ($this->in_array($fromAccount, array( 'spot', 'swap', 'perp' ))) {
                // handle swap <> spot account transfer
                if (!$this->in_array($toAccount, array( 'spot', 'swap', 'perp' ))) {
                    throw new NotSupported($this->id . 'transfer() only support spot <> swap transfer');
                }
                $vaultAddress = $this->format_vault_address($this->safe_string($params, 'vaultAddress'));
                $params = $this->omit($params, 'vaultAddress');
                $toPerp = ($toAccount === 'perp') || ($toAccount === 'swap');
                $action = array(
                    'type' => 'spotUser',
                    'classTransfer' => array(
                        'usdc' => $amount,
                        'toPerp' => $toPerp,
                    ),
                );
                $signature = $this->sign_l1_action($action, $nonce, $vaultAddress);
                $innerRequest = array(
                    'action' => array_merge($action, $params),
                    'nonce' => $nonce,
                    'signature' => $signature,
                );
                if ($vaultAddress !== null) {
                    $innerRequest['vaultAddress'] = $vaultAddress;
                }
                $transferResponse = Async\await($this->privatePostExchange ($innerRequest));
                return $transferResponse;
            }
            // handle sub-account/different account transfer
            $this->check_address($toAccount);
            if ($code !== null) {
                $code = strtoupper($code);
                if ($code !== 'USDC') {
                    throw new NotSupported($this->id . 'withdraw() only support USDC');
                }
            }
            $payload = array(
                'destination' => $toAccount,
                'amount' => $this->number_to_string($amount),
                'time' => $nonce,
            );
            $sig = $this->build_transfer_sig($payload);
            $request = array(
                'action' => array(
                    'chain' => ($isSandboxMode) ? 'ArbitrumTestnet' : 'Arbitrum',
                    'payload' => $payload,
                    'type' => 'usdTransfer',
                ),
                'nonce' => $nonce,
                'signature' => $sig,
            );
            $response = Async\await($this->privatePostExchange (array_merge($request, $params)));
            return $response;
        }) ();
    }

    public function withdraw(string $code, $amount, $address, $tag = null, $params = array ()) {
        return Async\async(function () use ($code, $amount, $address, $tag, $params) {
            /**
             * make a withdrawal (only support USDC)
             * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/exchange-endpoint#initiate-a-withdrawal-$request
             * @param {string} $code unified currency $code
             * @param {float} $amount the $amount to withdraw
             * @param {string} $address the $address to withdraw to
             * @param {string} $tag
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} a ~@link https://docs.ccxt.com/#/?id=transaction-structure transaction structure~
             */
            $this->check_required_credentials();
            Async\await($this->load_markets());
            $this->check_address($address);
            if ($code !== null) {
                $code = strtoupper($code);
                if ($code !== 'USDC') {
                    throw new NotSupported($this->id . 'withdraw() only support USDC');
                }
            }
            $isSandboxMode = $this->safe_bool($this->options, 'sandboxMode');
            $nonce = $this->milliseconds();
            $payload = array(
                'destination' => $address,
                'usd' => (string) $amount,
                'time' => $nonce,
            );
            $sig = $this->build_withdraw_sig($payload);
            $request = array(
                'action' => array(
                    'chain' => ($isSandboxMode) ? 'ArbitrumTestnet' : 'Arbitrum',
                    'payload' => $payload,
                    'type' => 'withdraw2',
                ),
                'nonce' => $nonce,
                'signature' => $sig,
            );
            $response = Async\await($this->privatePostExchange (array_merge($request, $params)));
            return $response;
        }) ();
    }

    public function format_vault_address(?string $address = null) {
        if ($address === null) {
            return null;
        }
        if (str_starts_with($address, '0x')) {
            return str_replace('0x', '', $address);
        }
        return $address;
    }

    public function handle_public_address(string $methodName, array $params) {
        $userAux = null;
        list($userAux, $params) = $this->handle_option_and_params($params, $methodName, 'user');
        $user = $userAux;
        list($user, $params) = $this->handle_option_and_params($params, $methodName, 'address', $userAux);
        if (($user !== null) && ($user !== '')) {
            return array( $user, $params );
        }
        if (($this->walletAddress !== null) && ($this->walletAddress !== '')) {
            return array( $this->walletAddress, $params );
        }
        throw new ArgumentsRequired($this->id . ' ' . $methodName . '() requires a $user parameter inside \'params\' or the wallet address set');
    }

    public function coin_to_market_id(?string $coin) {
        if (mb_strpos($coin, '/') > -1) {
            return $coin; // spot
        }
        return $coin . '/USDC:USDC';
    }

    public function handle_errors($code, $reason, $url, $method, $headers, $body, $response, $requestHeaders, $requestBody) {
        if (!$response) {
            return null; // fallback to default error handler
        }
        // array("status":"err","response":"User or API Wallet 0xb8a6f8b26223de27c31938d56e470a5b832703a5 does not exist.")
        //
        //     {
        //         $status => 'ok',
        //         $response => array( type => 'order', $data => array( $statuses => array( array( error => 'Insufficient margin to place order. asset=4' ) ) ) )
        //     }
        //
        $status = $this->safe_string($response, 'status', '');
        $message = null;
        if ($status === 'err') {
            $message = $this->safe_string($response, 'response');
        } else {
            $responsePayload = $this->safe_dict($response, 'response', array());
            $data = $this->safe_dict($responsePayload, 'data', array());
            $statuses = $this->safe_list($data, 'statuses', array());
            $firstStatus = $this->safe_dict($statuses, 0);
            $message = $this->safe_string($firstStatus, 'error');
        }
        $feedback = $this->id . ' ' . $body;
        $nonEmptyMessage = (($message !== null) && ($message !== ''));
        if ($nonEmptyMessage) {
            $this->throw_exactly_matched_exception($this->exceptions['exact'], $message, $feedback);
            $this->throw_broadly_matched_exception($this->exceptions['broad'], $message, $feedback);
        }
        if ($nonEmptyMessage) {
            throw new ExchangeError($feedback); // unknown $message
        }
        return null;
    }

    public function sign($path, $api = 'public', $method = 'GET', $params = array (), $headers = null, $body = null) {
        $url = $this->implode_hostname($this->urls['api'][$api]) . '/' . $path;
        if ($method === 'POST') {
            $headers = array(
                'Content-Type' => 'application/json',
            );
            $body = $this->json($params);
        }
        return array( 'url' => $url, 'method' => $method, 'body' => $body, 'headers' => $headers );
    }
}
