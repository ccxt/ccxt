<?php

namespace ccxt\async;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

use Exception; // a common import
use ccxt\async\abstract\dydx as Exchange;
use ccxt\ExchangeError;
use ccxt\ArgumentsRequired;
use ccxt\InvalidOrder;
use ccxt\NotSupported;
use ccxt\Precise;
use \React\Async;
use \React\Promise\PromiseInterface;

class dydx extends Exchange {

    public function describe(): mixed {
        return $this->deep_extend(parent::describe(), array(
            'id' => 'dydx',
            'name' => 'dYdX',
            'countries' => array( 'US' ),
            'rateLimit' => 100,
            'version' => 'v4',
            'certified' => false,
            'dex' => true,
            'pro' => true,
            'has' => array(
                'CORS' => null,
                'spot' => false,
                'margin' => false,
                'swap' => true,
                'future' => false,
                'option' => false,
                'addMargin' => false,
                'cancelAllOrders' => false,
                'cancelAllOrdersAfter' => false,
                'cancelOrder' => true,
                'cancelOrders' => true,
                'cancelWithdraw' => false,
                'closeAllPositions' => false,
                'closePosition' => false,
                'createConvertTrade' => false,
                'createDepositAddress' => false,
                'createMarketBuyOrderWithCost' => false,
                'createMarketOrder' => false,
                'createMarketOrderWithCost' => false,
                'createMarketSellOrderWithCost' => false,
                'createOrder' => true,
                'createOrderWithTakeProfitAndStopLoss' => false,
                'createReduceOnlyOrder' => false,
                'createStopLimitOrder' => false,
                'createStopLossOrder' => false,
                'createStopMarketOrder' => false,
                'createStopOrder' => false,
                'createTakeProfitOrder' => false,
                'createTrailingAmountOrder' => false,
                'createTrailingPercentOrder' => false,
                'createTriggerOrder' => false,
                'fetchAccounts' => true,
                'fetchBalance' => true,
                'fetchCanceledOrders' => false,
                'fetchClosedOrder' => false,
                'fetchClosedOrders' => true,
                'fetchConvertCurrencies' => false,
                'fetchConvertQuote' => false,
                'fetchConvertTrade' => false,
                'fetchConvertTradeHistory' => false,
                'fetchCurrencies' => false,
                'fetchDepositAddress' => false,
                'fetchDepositAddresses' => false,
                'fetchDepositAddressesByNetwork' => false,
                'fetchDeposits' => true,
                'fetchDepositsWithdrawals' => true,
                'fetchFundingHistory' => false,
                'fetchFundingInterval' => false,
                'fetchFundingIntervals' => false,
                'fetchFundingRate' => false,
                'fetchFundingRateHistory' => true,
                'fetchFundingRates' => false,
                'fetchIndexOHLCV' => false,
                'fetchLedger' => true,
                'fetchLeverage' => false,
                'fetchMarginAdjustmentHistory' => false,
                'fetchMarginMode' => false,
                'fetchMarkets' => true,
                'fetchMarkOHLCV' => false,
                'fetchMyTrades' => false,
                'fetchOHLCV' => true,
                'fetchOpenInterestHistory' => false,
                'fetchOpenOrder' => false,
                'fetchOpenOrders' => true,
                'fetchOrder' => true,
                'fetchOrderBook' => true,
                'fetchOrders' => true,
                'fetchOrderTrades' => false,
                'fetchPosition' => true,
                'fetchPositionHistory' => false,
                'fetchPositionMode' => false,
                'fetchPositions' => true,
                'fetchPositionsHistory' => false,
                'fetchPremiumIndexOHLCV' => false,
                'fetchStatus' => false,
                'fetchTicker' => false,
                'fetchTickers' => false,
                'fetchTime' => true,
                'fetchTrades' => true,
                'fetchTradingFee' => false,
                'fetchTradingFees' => false,
                'fetchTransactions' => false,
                'fetchTransfers' => true,
                'fetchWithdrawals' => true,
                'reduceMargin' => false,
                'sandbox' => false,
                'setLeverage' => false,
                'setMargin' => false,
                'setPositionMode' => false,
                'transfer' => true,
                'withdraw' => true,
            ),
            'timeframes' => array(
                '1m' => '1MIN',
                '5m' => '5MINS',
                '15m' => '15MINS',
                '30m' => '30MINS',
                '1h' => '1HOUR',
                '4h' => '4HOURS',
                '1d' => '1DAY',
            ),
            'urls' => array(
                'logo' => 'https://github.com/user-attachments/assets/617ea0c1-f05a-4d26-9fcb-a0d1d4091ae1',
                'api' => array(
                    'indexer' => 'https://indexer.dydx.trade/v4',
                    'nodeRpc' => 'https://dydx-ops-rpc.kingnodes.com',
                    'nodeRest' => 'https://dydx-rest.publicnode.com',
                ),
                'test' => array(
                    'indexer' => 'https://indexer.v4testnet.dydx.exchange/v4',
                    'nodeRpc' => 'https://test-dydx-rpc.kingnodes.com',
                    'nodeRest' => 'https://test-dydx-rest.kingnodes.com',
                ),
                'www' => 'https://www.dydx.xyz',
                'doc' => array(
                    'https://docs.dydx.xyz',
                ),
                'fees' => array(
                    'https://docs.dydx.exchange/introduction-trading_fees',
                ),
                'referral' => 'dydx.trade?ref=ccxt',
            ),
            'api' => array(
                'indexer' => array(
                    'get' => array(
                        'addresses/{address}' => 1,
                        'addresses/{address}/parentSubaccountNumber/{number}' => 1,
                        'addresses/{address}/subaccountNumber/{subaccountNumber}' => 1,
                        'assetPositions' => 1,
                        'assetPositions/parentSubaccountNumber' => 1,
                        'candles/perpetualMarkets/{market}' => 1,
                        'compliance/screen/{address}' => 1,
                        'fills' => 1,
                        'fills/parentSubaccountNumber' => 1,
                        'fundingPayments' => 1,
                        'fundingPayments/parentSubaccount' => 1,
                        'height' => 0.1,
                        'historical-pnl' => 1,
                        'historical-pnl/parentSubaccountNumber' => 1,
                        'historicalBlockTradingRewards/{address}' => 1,
                        'historicalFunding/{market}' => 1,
                        'historicalTradingRewardAggregations/{address}' => 1,
                        'orderbooks/perpetualMarket/{market}' => 1,
                        'orders' => 1,
                        'orders/parentSubaccountNumber' => 1,
                        'orders/{orderId}' => 1,
                        'perpetualMarkets' => 1,
                        'perpetualPositions' => 1,
                        'perpetualPositions/parentSubaccountNumber' => 1,
                        'screen' => 1,
                        'sparklines' => 1,
                        'time' => 1,
                        'trades/perpetualMarket/{market}' => 1,
                        'transfers' => 1,
                        'transfers/between' => 1,
                        'transfers/parentSubaccountNumber' => 1,
                        'vault/v1/megavault/historicalPnl' => 1,
                        'vault/v1/megavault/positions' => 1,
                        'vault/v1/vaults/historicalPnl' => 1,
                        //
                        'perpetualMarketSparklines' => 1,
                        'perpetualMarkets/{ticker}' => 1,
                        'perpetualMarkets/{ticker}/orderbook' => 1,
                        'trades/perpetualMarket/{ticker}' => 1,
                        'historicalFunding/{ticker}' => 1,
                        'candles/{ticker}/{resolution}' => 1,
                        'addresses/{address}/subaccounts' => 1,
                        'addresses/{address}/subaccountNumber/{subaccountNumber}/assetPositions' => 1,
                        'addresses/{address}/subaccountNumber/{subaccountNumber}/perpetualPositions' => 1,
                        'addresses/{address}/subaccountNumber/{subaccountNumber}/orders' => 1,
                        'fills/parentSubaccount' => 1,
                        'historical-pnl/parentSubaccount' => 1,
                    ),
                ),
                'nodeRpc' => array(
                    'get' => array(
                        'abci_info' => 1,
                        'block' => 1,
                        'broadcast_tx_async' => 1,
                        'broadcast_tx_sync' => 1,
                        'tx' => 1,
                    ),
                ),
                'nodeRest' => array(
                    'get' => array(
                        'cosmos/auth/v1beta1/account_info/{dydxAddress}' => 1,
                    ),
                    'post' => array(
                        'cosmos/tx/v1beta1/encode' => 1,
                        'cosmos/tx/v1beta1/simulate' => 1,
                    ),
                ),
            ),
            'fees' => array(
                'trading' => array(
                    'tierBased' => true,
                    'percentage' => true,
                    'maker' => $this->parse_number('0.0001'),
                    'taker' => $this->parse_number('0.0005'),
                ),
            ),
            'requiredCredentials' => array(
                'apiKey' => false,
                'secret' => false,
                'privateKey' => false,
            ),
            'options' => array(
                'mnemonic' => null, // specify mnemonic, copy secret phrase from UI
                'chainName' => 'dydx-mainnet-1',
                'chainId' => 1,
                'sandboxMode' => false,
                'defaultFeeDenom' => 'uusdc',
                'defaultFeeMultiplier' => '1.6',
                'feeDenom' => array(
                    'USDC_DENOM' => 'ibc/8E27BA2D5493AF5636760E354E46004562C46AB7EC0CC4C1CA14E9E20E2545B5',
                    'USDC_GAS_DENOM' => 'uusdc',
                    'USDC_DECIMALS' => 6,
                    'USDC_GAS_PRICE' => '0.025',
                    'CHAINTOKEN_DENOM' => 'adydx',
                    'CHAINTOKEN_DECIMALS' => 18,
                    'CHAINTOKEN_GAS_PRICE' => '25000000000',
                ),
            ),
            'features' => array(
                'default' => array(
                    'sandbox' => true,
                    'createOrder' => array(
                        'marginMode' => false,
                        'triggerPrice' => true,
                        'triggerPriceType' => array(
                            'last' => true,
                            'mark' => true,
                            'index' => false,
                        ),
                        'triggerDirection' => false,
                        'stopLossPrice' => false, // todo by triggerPrice
                        'takeProfitPrice' => false, // todo by triggerPrice
                        'attachedStopLossTakeProfit' => null,
                        'timeInForce' => array(
                            'IOC' => true,
                            'FOK' => true,
                            'PO' => true,
                            'GTD' => true,
                        ),
                        'hedged' => false,
                        'trailing' => false,
                        'leverage' => false,
                        'marketBuyByCost' => false,
                        'marketBuyRequiresPrice' => false,
                        'selfTradePrevention' => false,
                        'iceberg' => false,
                    ),
                    'createOrders' => null,
                    'fetchMyTrades' => array(
                        'marginMode' => false,
                        'limit' => 500,
                        'daysBack' => 90,
                        'untilDays' => 10000,
                        'symbolRequired' => false,
                    ),
                    'fetchOrder' => array(
                        'marginMode' => false,
                        'trigger' => true,
                        'trailing' => false,
                        'symbolRequired' => false,
                    ),
                    'fetchOpenOrders' => array(
                        'marginMode' => false,
                        'limit' => 500,
                        'trigger' => true,
                        'trailing' => true,
                        'symbolRequired' => false,
                    ),
                    'fetchOrders' => array(
                        'marginMode' => false,
                        'limit' => 500,
                        'daysBack' => null,
                        'untilDays' => 100000,
                        'trigger' => true,
                        'trailing' => true,
                        'symbolRequired' => false,
                    ),
                    'fetchClosedOrders' => array(
                        'marginMode' => false,
                        'limit' => 500,
                        'daysBack' => null,
                        'daysBackCanceled' => null,
                        'untilDays' => 100000,
                        'trigger' => true,
                        'trailing' => true,
                        'symbolRequired' => false,
                    ),
                    'fetchOHLCV' => array(
                        'limit' => 1000,
                    ),
                ),
                'forSwap' => array(
                    'extends' => 'default',
                    'createOrder' => array(
                        'hedged' => true,
                    ),
                ),
                'swap' => array(
                    'linear' => array(
                        'extends' => 'forSwap',
                    ),
                    'inverse' => null,
                ),
                'future' => array(
                    'linear' => null,
                    'inverse' => null,
                ),
            ),
            'commonCurrencies' => array(),
            'exceptions' => array(
                'exact' => array(
                    // error collision for clob and sending modules from 2 - 8
                    // https://github.com/dydxprotocol/v4-chain/blob/5f9f6c9b95cc87d732e23de764909703b81a6e8b/protocol/x/clob/types/errors.go#L320
                    // https://github.com/dydxprotocol/v4-chain/blob/5f9f6c9b95cc87d732e23de764909703b81a6e8b/protocol/x/sending/types/errors.go
                    '9' => '\\ccxt\\InvalidOrder', // A cancel already exists in the memclob for this order with a greater than or equal GoodTilBlock
                    '10' => '\\ccxt\\InvalidOrder', // The next block height is greater than the GoodTilBlock of the message
                    '11' => '\\ccxt\\InvalidOrder', // The GoodTilBlock of the message is further than ShortBlockWindow blocks into the future
                    '12' => '\\ccxt\\InvalidOrder', // MsgPlaceOrder is invalid
                    '13' => '\\ccxt\\InvalidOrder', // MsgProposedMatchOrders is invalid
                    '14' => '\\ccxt\\InvalidOrder', // State filled amount cannot be unchanged
                    '15' => '\\ccxt\\InvalidOrder', // State filled amount cannot decrease
                    '16' => '\\ccxt\\InvalidOrder', // Cannot prune state fill amount that does not exist
                    '17' => '\\ccxt\\InvalidOrder', // Subaccount cannot open more than 20 orders on a given CLOB and side
                    '18' => '\\ccxt\\InvalidOrder', // `FillAmount` is not divisible by `StepBaseQuantums` of the specified `ClobPairId`
                    '19' => '\\ccxt\\InvalidOrder', // The provided perpetual ID does not have any associated CLOB pairs
                    '20' => '\\ccxt\\InvalidOrder', // Replacing an existing order failed
                    '21' => '\\ccxt\\InvalidOrder', // Clob pair and perpetual ids do not match
                    '22' => '\\ccxt\\InvalidOrder', // Matched order has negative fee
                    '23' => '\\ccxt\\InvalidOrder', // Subaccounts updated for a matched order, but fee transfer to fee-collector failed
                    '24' => '\\ccxt\\InvalidOrder', // Order is fully filled
                    '25' => '\\ccxt\\InvalidOrder', // Attempting to get price premium with a non-perpetual CLOB pair
                    '26' => '\\ccxt\\InvalidOrder', // Index price is zero when calculating price premium
                    '27' => '\\ccxt\\InvalidOrder', // Invalid ClobPair parameter
                    '28' => '\\ccxt\\InvalidOrder', // Oracle price must be > 0.
                    '29' => '\\ccxt\\InvalidOrder', // Invalid stateful order cancellation
                    '30' => '\\ccxt\\InvalidOrder', // An order with the same `OrderId` and `OrderHash` has already been processed for this CLOB
                    '31' => '\\ccxt\\InvalidOrder', // Missing mid price for ClobPair
                    '32' => '\\ccxt\\InvalidOrder', // Existing stateful order cancellation has higher-or-equal priority than the new one
                    '33' => '\\ccxt\\InvalidOrder', // ClobPair with id already exists
                    '34' => '\\ccxt\\InvalidOrder', // Order conflicts with ClobPair status
                    '35' => '\\ccxt\\InvalidOrder', // Invalid ClobPair status transition
                    '36' => '\\ccxt\\InvalidOrder', // Operation conflicts with ClobPair status
                    '37' => '\\ccxt\\InvalidOrder', // Perpetual does not exist in state
                    '39' => '\\ccxt\\InvalidOrder', // ClobPair update is invalid
                    '40' => '\\ccxt\\InvalidOrder', // Authority is invalid
                    '41' => '\\ccxt\\InvalidOrder', // perpetual ID is already associated with an existing CLOB pair
                    '42' => '\\ccxt\\InvalidOrder', // Unexpected time in force
                    '43' => '\\ccxt\\InvalidOrder', // Order has remaining size
                    '44' => '\\ccxt\\InvalidOrder', // invalid time in force
                    '45' => '\\ccxt\\InvalidOrder', // Invalid batch cancel message
                    '46' => '\\ccxt\\InvalidOrder', // Batch cancel has failed
                    '47' => '\\ccxt\\InvalidOrder', // CLOB has not been initialized
                    '48' => '\\ccxt\\InvalidOrder', // This field has been deprecated
                    '49' => '\\ccxt\\InvalidOrder', // Invalid TWAP order placement
                    '50' => '\\ccxt\\InvalidOrder', // Invalid builder code
                    '1000' => '\\ccxt\\BadRequest', // Proposed LiquidationsConfig is invalid
                    '1001' => '\\ccxt\\BadRequest', // Subaccount has no perpetual positions to liquidate
                    '1002' => '\\ccxt\\BadRequest', // Subaccount is not liquidatable
                    '1003' => '\\ccxt\\InvalidOrder', // Subaccount does not have an open position for perpetual
                    '1004' => '\\ccxt\\InvalidOrder', // Liquidation order has invalid size
                    '1005' => '\\ccxt\\InvalidOrder', // Liquidation order is on the wrong side
                    '1006' => '\\ccxt\\InvalidOrder', // Total fills amount exceeds size of liquidation order
                    '1007' => '\\ccxt\\InvalidOrder', // Liquidation order does not contain any fills
                    '1008' => '\\ccxt\\InvalidOrder', // Subaccount has previously liquidated this perpetual in the current block
                    '1009' => '\\ccxt\\InvalidOrder', // Liquidation order has size smaller than min position notional specified in the liquidation config
                    '1010' => '\\ccxt\\InvalidOrder', // Liquidation order has size greater than max position notional specified in the liquidation config
                    '1011' => '\\ccxt\\InvalidOrder', // Liquidation exceeds the maximum notional amount that a single subaccount can have liquidated per block
                    '1012' => '\\ccxt\\InvalidOrder', // Liquidation exceeds the maximum insurance fund payout amount for a given subaccount per block
                    '1013' => '\\ccxt\\InvalidOrder', // Insurance fund does not have sufficient funds to cover liquidation losses
                    '1014' => '\\ccxt\\InvalidOrder', // Invalid perpetual position size delta
                    '1015' => '\\ccxt\\InvalidOrder', // Invalid delta base and/or quote quantums for insurance fund delta calculation
                    '1017' => '\\ccxt\\InvalidOrder', // Cannot deleverage subaccount against itself
                    '1018' => '\\ccxt\\InvalidOrder', // Deleveraging match cannot have fills with same id
                    '1019' => '\\ccxt\\InvalidOrder', // Deleveraging match cannot have fills with zero amount
                    '1020' => '\\ccxt\\InvalidOrder', // Position cannot be fully offset
                    '1021' => '\\ccxt\\InvalidOrder', // Deleveraging match has incorrect value for isFinalSettlement flag
                    '1022' => '\\ccxt\\InvalidOrder', // Liquidation conflicts with ClobPair status
                    '2000' => '\\ccxt\\InvalidOrder', // FillOrKill order could not be fully filled
                    '2001' => '\\ccxt\\InvalidOrder', // Reduce-only orders cannot increase the position size
                    '2002' => '\\ccxt\\InvalidOrder', // Reduce-only orders cannot change the position side
                    '2003' => '\\ccxt\\InvalidOrder', // Post-only order would cross one or more maker orders
                    '2004' => '\\ccxt\\InvalidOrder', // IOC order is already filled, remaining size is cancelled.
                    '2005' => '\\ccxt\\InvalidOrder', // Order would violate isolated subaccount constraints.
                    '3000' => '\\ccxt\\InvalidOrder', // Invalid order flags
                    '3001' => '\\ccxt\\InvalidOrder', // Invalid order goodTilBlockTime
                    '3002' => '\\ccxt\\InvalidOrder', // Stateful orders cannot require immediate execution
                    '3003' => '\\ccxt\\InvalidOrder', // The block time is greater than the GoodTilBlockTime of the message
                    '3004' => '\\ccxt\\InvalidOrder', // The GoodTilBlockTime of the message is further than StatefulOrderTimeWindow into the future
                    '3005' => '\\ccxt\\InvalidOrder', // Existing stateful order has higher-or-equal priority than the new one
                    '3006' => '\\ccxt\\InvalidOrder', // Stateful order does not exist
                    '3007' => '\\ccxt\\InvalidOrder', // Stateful order collateralization check failed
                    '3008' => '\\ccxt\\InvalidOrder', // Stateful order was previously cancelled and therefore cannot be placed
                    '3009' => '\\ccxt\\InvalidOrder', // Stateful order was previously removed and therefore cannot be placed
                    '3010' => '\\ccxt\\InvalidOrder', // Stateful order cancellation failed because the order was already removed from state
                    '4000' => '\\ccxt\\InvalidOrder', // MsgProposedOperations is invalid
                    '4001' => '\\ccxt\\InvalidOrder', // Match Order is invalid
                    '4002' => '\\ccxt\\InvalidOrder', // Order was not previously placed in operations queue
                    '4003' => '\\ccxt\\InvalidOrder', // Fill amount cannot be zero
                    '4004' => '\\ccxt\\InvalidOrder', // Deleveraging fill is invalid
                    '4005' => '\\ccxt\\InvalidOrder', // Deleveraged subaccount in proposed deleveraged operation failed deleveraging validation
                    '4006' => '\\ccxt\\InvalidOrder', // Order Removal is invalid
                    '4007' => '\\ccxt\\InvalidOrder', // Order Removal reason is invalid
                    '4008' => '\\ccxt\\InvalidOrder', // Zero-fill deleveraging operation included in block for non-negative TNC subaccount
                    '5000' => '\\ccxt\\InvalidOrder', // Proposed BlockRateLimitConfig is invalid
                    '5001' => '\\ccxt\\InvalidOrder', // Block rate limit exceeded
                    '6000' => '\\ccxt\\InvalidOrder', // Conditional type is invalid
                    '6001' => '\\ccxt\\InvalidOrder', // Conditional order trigger subticks is invalid
                    '6002' => '\\ccxt\\InvalidOrder', // Conditional order is untriggered
                    '9000' => '\\ccxt\\InvalidOrder', // Asset orders are not implemented
                    '9001' => '\\ccxt\\InvalidOrder', // Updates for assets other than USDC are not implemented
                    '9002' => '\\ccxt\\InvalidOrder', // This function is not implemented
                    '9003' => '\\ccxt\\InvalidOrder', // Reduce-only is currently disabled for non-IOC orders
                    '10000' => '\\ccxt\\InvalidOrder', // Proposed EquityTierLimitConfig is invalid
                    '10001' => '\\ccxt\\InvalidOrder', // Subaccount cannot open more orders due to equity tier limit.
                    '11000' => '\\ccxt\\InvalidOrder', // Invalid order router address
                ),
                'broad' => array(
                    'insufficient funds' => '\\ccxt\\InsufficientFunds',
                ),
            ),
            'precisionMode' => TICK_SIZE,
        ));
    }

    public function fetch_time($params = array ()): PromiseInterface {
        return Async\async(function () use ($params) {
            /**
             * fetches the current integer timestamp in milliseconds from the exchange server
             *
             * @see https://docs.dydx.xyz/indexer-client/http#get-time
             *
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {int} the current integer timestamp in milliseconds from the exchange server
             */
            $response = Async\await($this->indexerGetTime ($params));
            //
            // {
            //     "iso" => "2025-07-20T15:12:13.466Z",
            //     "epoch" => 1753024333.466
            // }
            //
            return $this->safe_integer($response, 'epoch');
        }) ();
    }

    public function parse_market(array $market): array {
        //
        // {
        //     "clobPairId" => "0",
        //     "ticker" => "BTC-USD",
        //     "status" => "ACTIVE",
        //     "oraclePrice" => "118976.5376",
        //     "priceChange24H" => "659.9736",
        //     "volume24H" => "1292729.3605",
        //     "trades24H" => 9387,
        //     "nextFundingRate" => "0",
        //     "initialMarginFraction" => "0.02",
        //     "maintenanceMarginFraction" => "0.012",
        //     "openInterest" => "52.0691",
        //     "atomicResolution" => -10,
        //     "quantumConversionExponent" => -9,
        //     "tickSize" => "1",
        //     "stepSize" => "0.0001",
        //     "stepBaseQuantums" => 1000000,
        //     "subticksPerTick" => 100000,
        //     "marketType" => "CROSS",
        //     "openInterestLowerCap" => "0",
        //     "openInterestUpperCap" => "0",
        //     "baseOpenInterest" => "50.3776",
        //     "defaultFundingRate1H" => "0"
        // }
        //
        $quoteId = 'USDC';
        $marketId = $this->safe_string($market, 'ticker');
        $parts = explode('-', $marketId);
        $baseName = $this->safe_string($parts, 0);
        $base = $this->safe_currency_code($baseName);
        $quote = $this->safe_currency_code($quoteId);
        $baseId = $this->safe_string($market, 'baseId');
        $settleId = 'USDC';
        $settle = $this->safe_currency_code($settleId);
        $symbol = $base . '/' . $quote . ':' . $settle;
        $contract = true;
        $swap = true;
        $amountPrecisionStr = $this->safe_string($market, 'stepSize');
        $pricePrecisionStr = $this->safe_string($market, 'tickSize');
        $status = $this->safe_string($market, 'status');
        $active = true;
        if ($status !== 'ACTIVE') {
            $active = false;
        }
        return $this->safe_market_structure(array(
            'id' => $this->safe_string($market, 'ticker'),
            'symbol' => $symbol,
            'base' => $base,
            'quote' => $quote,
            'settle' => $settle,
            'baseId' => $baseId,
            'baseName' => $baseName,
            'quoteId' => $quoteId,
            'settleId' => $settleId,
            'type' => 'swap',
            'spot' => false,
            'margin' => null,
            'swap' => $swap,
            'future' => false,
            'option' => false,
            'active' => $active,
            'contract' => $contract,
            'linear' => true,
            'inverse' => false,
            'taker' => null,
            'maker' => null,
            'contractSize' => null,
            'expiry' => null,
            'expiryDatetime' => null,
            'strike' => null,
            'optionType' => null,
            'precision' => array(
                'amount' => $this->parse_number($amountPrecisionStr),
                'price' => $this->parse_number($pricePrecisionStr),
            ),
            'limits' => array(
                'leverage' => array(
                    'min' => null,
                    'max' => null,
                ),
                'amount' => array(
                    'min' => null,
                    'max' => null,
                ),
                'price' => array(
                    'min' => null,
                    'max' => null,
                ),
                'cost' => array(
                    'min' => null,
                    'max' => null,
                ),
            ),
            'created' => null,
            'info' => $market,
        ));
    }

    public function fetch_markets($params = array ()): PromiseInterface {
        return Async\async(function () use ($params) {
            /**
             * retrieves $data on all $markets for hyperliquid
             *
             * @see https://docs.dydx.xyz/indexer-client/http#get-perpetual-$markets
             *
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array[]} an array of objects representing market $data
             */
            $request = array(
                // 'limit' => 1000,
            );
            $response = Async\await($this->indexerGetPerpetualMarkets ($this->extend($request, $params)));
            //
            // {
            //     "markets" => {
            //         "BTC-USD" => {
            //             "clobPairId" => "0",
            //             "ticker" => "BTC-USD",
            //             "status" => "ACTIVE",
            //             "oraclePrice" => "118976.5376",
            //             "priceChange24H" => "659.9736",
            //             "volume24H" => "1292729.3605",
            //             "trades24H" => 9387,
            //             "nextFundingRate" => "0",
            //             "initialMarginFraction" => "0.02",
            //             "maintenanceMarginFraction" => "0.012",
            //             "openInterest" => "52.0691",
            //             "atomicResolution" => -10,
            //             "quantumConversionExponent" => -9,
            //             "tickSize" => "1",
            //             "stepSize" => "0.0001",
            //             "stepBaseQuantums" => 1000000,
            //             "subticksPerTick" => 100000,
            //             "marketType" => "CROSS",
            //             "openInterestLowerCap" => "0",
            //             "openInterestUpperCap" => "0",
            //             "baseOpenInterest" => "50.3776",
            //             "defaultFundingRate1H" => "0"
            //         }
            //     }
            // }
            //
            $data = $this->safe_dict($response, 'markets', array());
            $markets = is_array($data) ? array_values($data) : array();
            return $this->parse_markets($markets);
        }) ();
    }

    public function parse_trade(array $trade, ?array $market = null): array {
        //
        // {
        //     "id" => "02ac5b1f0000000200000002",
        //     "side" => "BUY",
        //     "size" => "0.0501",
        //     "price" => "115732",
        //     "type" => "LIMIT",
        //     "createdAt" => "2025-07-25T05:11:09.800Z",
        //     "createdAtHeight" => "44849951"
        // }
        //
        $timestamp = $this->parse8601($this->safe_string($trade, 'createdAt'));
        $symbol = $market['symbol'];
        $price = $this->safe_string($trade, 'price');
        $amount = $this->safe_string($trade, 'size');
        $side = $this->safe_string_lower($trade, 'side');
        $id = $this->safe_string($trade, 'id');
        return $this->safe_trade(array(
            'id' => $id,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'symbol' => $symbol,
            'side' => $side,
            'price' => $price,
            'amount' => $amount,
            'cost' => null,
            'order' => null,
            'takerOrMaker' => null,
            'type' => null,
            'fee' => null,
            'info' => $trade,
        ), $market);
    }

    public function fetch_trades(string $symbol, ?int $since = null, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            /**
             * get the list of most recent trades for a particular $symbol
             *
             * @see https://developer.woox.io/api-reference/endpoint/public_data/marketTrades
             *
             * @param {string} $symbol unified $symbol of the $market to fetch trades for
             * @param {int} [$since] timestamp in ms of the earliest trade to fetch
             * @param {int} [$limit] the maximum amount of trades to fetch
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {Trade[]} a list of ~@link https://docs.ccxt.com/?id=public-trades trade structures~
             */
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $request = array(
                'market' => $market['id'],
            );
            if ($limit !== null) {
                $request['limit'] = $limit;
            }
            $response = Async\await($this->indexerGetTradesPerpetualMarketMarket ($this->extend($request, $params)));
            //
            // {
            //     "trades" => array(
            //         {
            //             "id" => "02ac5b1f0000000200000002",
            //             "side" => "BUY",
            //             "size" => "0.0501",
            //             "price" => "115732",
            //             "type" => "LIMIT",
            //             "createdAt" => "2025-07-25T05:11:09.800Z",
            //             "createdAtHeight" => "44849951"
            //         }
            //     )
            // }
            //
            $rows = $this->safe_list($response, 'trades', array());
            return $this->parse_trades($rows, $market, $since, $limit);
        }) ();
    }

    public function parse_ohlcv($ohlcv, ?array $market = null): array {
        //
        // {
        //     "startedAt" => "2025-07-25T09:47:00.000Z",
        //     "ticker" => "BTC-USD",
        //     "resolution" => "1MIN",
        //     "low" => "116099",
        //     "high" => "116099",
        //     "open" => "116099",
        //     "close" => "116099",
        //     "baseTokenVolume" => "0",
        //     "usdVolume" => "0",
        //     "trades" => 0,
        //     "startingOpenInterest" => "54.0594",
        //     "orderbookMidPriceOpen" => "115845.5",
        //     "orderbookMidPriceClose" => "115845.5"
        // }
        //
        return array(
            $this->parse8601($this->safe_string($ohlcv, 'startedAt')),
            $this->safe_number($ohlcv, 'open'),
            $this->safe_number($ohlcv, 'high'),
            $this->safe_number($ohlcv, 'low'),
            $this->safe_number($ohlcv, 'close'),
            $this->safe_number($ohlcv, 'baseTokenVolume'),
        );
    }

    public function fetch_ohlcv(string $symbol, $timeframe = '1m', ?int $since = null, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $timeframe, $since, $limit, $params) {
            /**
             *
             * @see https://docs.dydx.xyz/indexer-client/http#get-candles
             *
             * fetches historical candlestick data containing the open, high, low, and close price, and the volume of a $market
             * @param {string} $symbol unified $symbol of the $market to fetch OHLCV data for
             * @param {string} $timeframe the length of time each candle represents
             * @param {int} [$since] timestamp in ms of the earliest candle to fetch
             * @param {int} [$limit] the maximum amount of candles to fetch
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @param {int} [$params->until] the latest time in ms to fetch entries for
             * @return {int[][]} A list of candles ordered, open, high, low, close, volume
             */
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $request = array(
                'market' => $market['id'],
                'resolution' => $this->safe_string($this->timeframes, $timeframe, $timeframe),
            );
            if ($limit !== null) {
                $request['limit'] = min ($limit, 1000);
            }
            if ($since !== null) {
                $request['fromIso'] = $this->iso8601($since);
            }
            $until = $this->safe_integer($params, 'until');
            $params = $this->omit($params, 'until');
            if ($until !== null) {
                $request['toIso'] = $this->iso8601($until);
            }
            $response = Async\await($this->indexerGetCandlesPerpetualMarketsMarket ($this->extend($request, $params)));
            //
            // {
            //     "candles" => array(
            //         {
            //             "startedAt" => "2025-07-25T09:47:00.000Z",
            //             "ticker" => "BTC-USD",
            //             "resolution" => "1MIN",
            //             "low" => "116099",
            //             "high" => "116099",
            //             "open" => "116099",
            //             "close" => "116099",
            //             "baseTokenVolume" => "0",
            //             "usdVolume" => "0",
            //             "trades" => 0,
            //             "startingOpenInterest" => "54.0594",
            //             "orderbookMidPriceOpen" => "115845.5",
            //             "orderbookMidPriceClose" => "115845.5"
            //         }
            //     )
            // }
            //
            $rows = $this->safe_list($response, 'candles', array());
            return $this->parse_ohlcvs($rows, $market, $timeframe, $since, $limit);
        }) ();
    }

    public function fetch_funding_rate_history(?string $symbol = null, ?int $since = null, ?int $limit = null, $params = array ()) {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            /**
             * fetches historical funding rate prices
             *
             * @see https://docs.dydx.xyz/indexer-client/http#get-historical-funding
             *
             * @param {string} $symbol unified $symbol of the $market to fetch the funding rate history for
             * @param {int} [$since] $timestamp in ms of the earliest funding rate to fetch
             * @param {int} [$limit] the maximum amount of ~@link https://docs.ccxt.com/?id=funding-rate-history-structure funding rate structures~ to fetch
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @param {int} [$params->until] $timestamp in ms of the latest funding rate
             * @return {array[]} a list of ~@link https://docs.ccxt.com/?id=funding-rate-history-structure funding rate structures~
             */
            if ($symbol === null) {
                throw new ArgumentsRequired($this->id . ' fetchFundingRateHistory() requires a $symbol argument');
            }
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $request = array(
                'market' => $market['id'],
            );
            if ($limit !== null) {
                $request['limit'] = $limit;
            }
            $until = $this->safe_integer($params, 'until');
            if ($until !== null) {
                $request['effectiveBeforeOrAt'] = $this->iso8601($until);
            }
            $response = Async\await($this->indexerGetHistoricalFundingMarket ($this->extend($request, $params)));
            //
            // {
            //     "historicalFunding" => array(
            //         {
            //             "ticker" => "BTC-USD",
            //             "rate" => "0",
            //             "price" => "116302.62419",
            //             "effectiveAtHeight" => "44865196",
            //             "effectiveAt" => "2025-07-25T11:00:00.013Z"
            //         }
            //     )
            // }
            //
            $rates = array();
            $rows = $this->safe_list($response, 'historicalFunding', array());
            for ($i = 0; $i < count($rows); $i++) {
                $entry = $rows[$i];
                $timestamp = $this->parse8601($this->safe_string($entry, 'effectiveAt'));
                $marketId = $this->safe_string($entry, 'ticker');
                $rates[] = array(
                    'info' => $entry,
                    'symbol' => $this->safe_symbol($marketId, $market),
                    'fundingRate' => $this->safe_number($entry, 'rate'),
                    'timestamp' => $timestamp,
                    'datetime' => $this->iso8601($timestamp),
                );
            }
            $sorted = $this->sort_by($rates, 'timestamp');
            return $this->filter_by_symbol_since_limit($sorted, $symbol, $since, $limit);
        }) ();
    }

    public function handle_public_address(string $methodName, array $params) {
        $userAux = null;
        list($userAux, $params) = $this->handle_option_and_params($params, $methodName, 'user');
        $user = $userAux;
        list($user, $params) = $this->handle_option_and_params($params, $methodName, 'address', $userAux);
        if (($user !== null) && ($user !== '')) {
            return array( $user, $params );
        }
        if (($this->walletAddress !== null) && ($this->walletAddress !== '')) {
            return array( $this->walletAddress, $params );
        }
        throw new ArgumentsRequired($this->id . ' ' . $methodName . '() requires a $user parameter inside \'params\' or the walletAddress set');
    }

    public function parse_order(array $order, ?array $market = null): array {
        //
        // {
        //     "id" => "dad46410-3444-5566-a129-19a619300fb7",
        //     "subaccountId" => "8586bcf6-1f58-5ec9-a0bc-e53db273e7b0",
        //     "clientId" => "716238006",
        //     "clobPairId" => "0",
        //     "side" => "BUY",
        //     "size" => "0.001",
        //     "totalFilled" => "0.001",
        //     "price" => "400000",
        //     "type" => "LIMIT",
        //     "status" => "FILLED",
        //     "timeInForce" => "GTT",
        //     "reduceOnly" => false,
        //     "orderFlags" => "64",
        //     "goodTilBlockTime" => "2025-07-28T12:07:33.000Z",
        //     "createdAtHeight" => "45058325",
        //     "clientMetadata" => "2",
        //     "updatedAt" => "2025-07-28T12:06:35.330Z",
        //     "updatedAtHeight" => "45058326",
        //     "postOnly" => false,
        //     "ticker" => "BTC-USD",
        //     "subaccountNumber" => 0
        // }
        //
        $status = $this->parse_order_status($this->safe_string_upper($order, 'status'));
        $marketId = $this->safe_string($order, 'ticker');
        $symbol = $this->safe_symbol($marketId, $market);
        $filled = $this->safe_string($order, 'totalFilled');
        $timestamp = $this->parse8601($this->safe_string($order, 'updatedAt'));
        $price = $this->safe_string($order, 'price');
        $amount = $this->safe_string($order, 'size');
        $type = $this->parse_order_type($this->safe_string_upper($order, 'type'));
        $side = $this->safe_string_lower($order, 'side');
        $timeInForce = $this->safe_string_upper($order, 'timeInForce');
        return $this->safe_order(array(
            'info' => $order,
            'id' => $this->safe_string($order, 'id'),
            'clientOrderId' => $this->safe_string($order, 'clientId'),
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'lastTradeTimestamp' => null,
            'lastUpdateTimestamp' => $timestamp,
            'symbol' => $symbol,
            'type' => $type,
            'timeInForce' => $timeInForce,
            'postOnly' => $this->safe_bool($order, 'postOnly'),
            'reduceOnly' => $this->safe_bool($order, 'reduceOnly'),
            'side' => $side,
            'price' => $price,
            'triggerPrice' => null,
            'amount' => $amount,
            'cost' => null,
            'average' => null,
            'filled' => $filled,
            'remaining' => null,
            'status' => $status,
            'fee' => null,
            'trades' => null,
        ), $market);
    }

    public function parse_order_status(?string $status) {
        $statuses = array(
            'UNTRIGGERED' => 'open',
            'OPEN' => 'open',
            'FILLED' => 'closed',
            'CANCELED' => 'canceled',
            'BEST_EFFORT_CANCELED' => 'canceling',
        );
        return $this->safe_string($statuses, $status, $status);
    }

    public function parse_order_type(?string $type) {
        $types = array(
            'LIMIT' => 'LIMIT',
            'STOP_LIMIT' => 'LIMIT',
            'TAKE_PROFIT_LIMIT' => 'LIMIT',
            'MARKET' => 'MARKET',
            'STOP_MARKET' => 'MARKET',
            'TAKE_PROFIT_MARKET' => 'MARKET',
            'TRAILING_STOP' => 'MARKET',
        );
        return $this->safe_string_upper($types, $type, $type);
    }

    public function fetch_order(string $id, ?string $symbol = null, $params = array ()) {
        return Async\async(function () use ($id, $symbol, $params) {
            /**
             * fetches information on an $order made by the user
             *
             * @see https://docs.dydx.xyz/indexer-client/http#get-$order
             *
             * @param {string} $id the $order $id
             * @param {string} $symbol unified $symbol of the market the $order was made in
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} An ~@link https://docs.ccxt.com/?$id=$order-structure $order structure~
             */
            Async\await($this->load_markets());
            $request = array(
                'orderId' => $id,
            );
            $order = Async\await($this->indexerGetOrdersOrderId ($this->extend($request, $params)));
            return $this->parse_order($order);
        }) ();
    }

    public function fetch_orders(?string $symbol = null, ?int $since = null, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            /**
             * fetches information on multiple orders made by the user
             *
             * @see https://docs.dydx.xyz/indexer-client/http#list-orders
             *
             * @param {string} $symbol unified $market $symbol of the $market orders were made in
             * @param {int} [$since] the earliest time in ms to fetch orders for
             * @param {int} [$limit] the maximum number of order structures to retrieve
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @param {string} [$params->address] wallet address that made trades
             * @param {string} [$params->subAccountNumber] sub account number
             * @return {Order[]} a list of ~@link https://docs.ccxt.com/?id=order-structure order structures~
             */
            $userAddress = null;
            $subAccountNumber = null;
            list($userAddress, $params) = $this->handle_public_address('fetchOrders', $params);
            list($subAccountNumber, $params) = $this->handle_option_and_params($params, 'fetchOrders', 'subAccountNumber', '0');
            Async\await($this->load_markets());
            $request = array(
                'address' => $userAddress,
                'subaccountNumber' => $subAccountNumber,
            );
            $market = null;
            if ($symbol !== null) {
                $market = $this->market($symbol);
                $request['ticker'] = $market['id'];
            }
            if ($limit !== null) {
                $request['limit'] = $limit;
            }
            $response = Async\await($this->indexerGetOrders ($this->extend($request, $params)));
            //
            // array(
            //     {
            //         "id" => "dad46410-3444-5566-a129-19a619300fb7",
            //         "subaccountId" => "8586bcf6-1f58-5ec9-a0bc-e53db273e7b0",
            //         "clientId" => "716238006",
            //         "clobPairId" => "0",
            //         "side" => "BUY",
            //         "size" => "0.001",
            //         "totalFilled" => "0.001",
            //         "price" => "400000",
            //         "type" => "LIMIT",
            //         "status" => "FILLED",
            //         "timeInForce" => "GTT",
            //         "reduceOnly" => false,
            //         "orderFlags" => "64",
            //         "goodTilBlockTime" => "2025-07-28T12:07:33.000Z",
            //         "createdAtHeight" => "45058325",
            //         "clientMetadata" => "2",
            //         "updatedAt" => "2025-07-28T12:06:35.330Z",
            //         "updatedAtHeight" => "45058326",
            //         "postOnly" => false,
            //         "ticker" => "BTC-USD",
            //         "subaccountNumber" => 0
            //     }
            // )
            //
            return $this->parse_orders($response, $market, $since, $limit);
        }) ();
    }

    public function fetch_open_orders(?string $symbol = null, ?int $since = null, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            /**
             * fetch all unfilled currently open orders
             *
             * @see https://docs.dydx.xyz/indexer-client/http#list-orders
             *
             * @param {string} $symbol unified market $symbol of the market orders were made in
             * @param {int} [$since] the earliest time in ms to fetch orders for
             * @param {int} [$limit] the maximum number of order structures to retrieve
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @param {string} [$params->address] wallet address that made trades
             * @param {string} [$params->subAccountNumber] sub account number
             * @return {Order[]} a list of ~@link https://docs.ccxt.com/?id=order-structure order structures~
             */
            $request = array(
                'status' => 'OPEN', // ['OPEN', 'FILLED', 'CANCELED', 'BEST_EFFORT_CANCELED', 'UNTRIGGERED', 'BEST_EFFORT_OPENED']
            );
            return Async\await($this->fetch_orders($symbol, $since, $limit, $this->extend($request, $params)));
        }) ();
    }

    public function fetch_closed_orders(?string $symbol = null, ?int $since = null, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            /**
             * fetches information on multiple closed orders made by the user
             *
             * @see https://docs.dydx.xyz/indexer-client/http#list-orders
             *
             * @param {string} $symbol unified market $symbol of the market orders were made in
             * @param {int} [$since] the earliest time in ms to fetch orders for
             * @param {int} [$limit] the maximum number of order structures to retrieve
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @param {string} [$params->address] wallet address that made trades
             * @param {string} [$params->subAccountNumber] sub account number
             * @return {Order[]} a list of ~@link https://docs.ccxt.com/?id=order-structure order structures~
             */
            $request = array(
                'status' => 'FILLED', // ['OPEN', 'FILLED', 'CANCELED', 'BEST_EFFORT_CANCELED', 'UNTRIGGERED', 'BEST_EFFORT_OPENED']
            );
            return Async\await($this->fetch_orders($symbol, $since, $limit, $this->extend($request, $params)));
        }) ();
    }

    public function parse_position(array $position, ?array $market = null) {
        //
        // {
        //     "market" => "BTC-USD",
        //     "status" => "OPEN",
        //     "side" => "SHORT",
        //     "size" => "-0.407",
        //     "maxSize" => "-0.009",
        //     "entryPrice" => "118692.04840909090909090909",
        //     "exitPrice" => "119526.565625",
        //     "realizedPnl" => "476.42665909090909090909088",
        //     "unrealizedPnl" => "-57.26681734000000000000037",
        //     "createdAt" => "2025-07-14T07:53:55.631Z",
        //     "createdAtHeight" => "44140908",
        //     "closedAt" => null,
        //     "sumOpen" => "0.44",
        //     "sumClose" => "0.032",
        //     "netFunding" => "503.13121",
        //     "subaccountNumber" => 0
        // }
        //
        $marketId = $this->safe_string($position, 'market');
        $market = $this->safe_market($marketId, $market);
        $symbol = $market['symbol'];
        $side = $this->safe_string_lower($position, 'side');
        $quantity = $this->safe_string($position, 'size');
        if ($side !== 'long') {
            $quantity = Precise::string_mul('-1', $quantity);
        }
        $timestamp = $this->parse8601($this->safe_string($position, 'createdAt'));
        return $this->safe_position(array(
            'info' => $position,
            'id' => null,
            'symbol' => $symbol,
            'entryPrice' => $this->safe_number($position, 'entryPrice'),
            'markPrice' => null,
            'notional' => null,
            'collateral' => null,
            'unrealizedPnl' => $this->safe_number($position, 'unrealizedPnl'),
            'side' => $side,
            'contracts' => $this->parse_number($quantity),
            'contractSize' => null,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'hedged' => null,
            'maintenanceMargin' => null,
            'maintenanceMarginPercentage' => null,
            'initialMargin' => null,
            'initialMarginPercentage' => null,
            'leverage' => null,
            'liquidationPrice' => null,
            'marginRatio' => null,
            'marginMode' => null,
            'percentage' => null,
        ));
    }

    public function fetch_position(string $symbol, $params = array ()) {
        return Async\async(function () use ($symbol, $params) {
            /**
             * fetch data on an open position
             *
             * @see https://docs.dydx.xyz/indexer-client/http#list-$positions
             *
             * @param {string} $symbol unified market $symbol of the market the position is held in
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @param {string} [$params->address] wallet address that made trades
             * @param {string} [$params->subAccountNumber] sub account number
             * @return {array} a ~@link https://docs.ccxt.com/?id=position-structure position structure~
             */
            $positions = Async\await($this->fetch_positions(array( $symbol ), $params));
            return $this->safe_dict($positions, 0, array());
        }) ();
    }

    public function fetch_positions(?array $symbols = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbols, $params) {
            /**
             * fetch all open positions
             *
             * @see https://docs.dydx.xyz/indexer-client/http#list-positions
             *
             * @param {string[]} [$symbols] list of unified market $symbols
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @param {string} [$params->address] wallet address that made trades
             * @param {string} [$params->subAccountNumber] sub account number
             * @return {array[]} a list of ~@link https://docs.ccxt.com/?id=position-structure position structure~
             */
            $userAddress = null;
            $subAccountNumber = null;
            list($userAddress, $params) = $this->handle_public_address('fetchPositions', $params);
            list($subAccountNumber, $params) = $this->handle_option_and_params($params, 'fetchOrders', 'subAccountNumber', '0');
            Async\await($this->load_markets());
            $request = array(
                'address' => $userAddress,
                'subaccountNumber' => $subAccountNumber,
                'status' => 'OPEN', // ['OPEN', 'CLOSED', 'LIQUIDATED']
            );
            $response = Async\await($this->indexerGetPerpetualPositions ($this->extend($request, $params)));
            //
            // {
            //     "positions" => array(
            //         {
            //             "market" => "BTC-USD",
            //             "status" => "OPEN",
            //             "side" => "SHORT",
            //             "size" => "-0.407",
            //             "maxSize" => "-0.009",
            //             "entryPrice" => "118692.04840909090909090909",
            //             "exitPrice" => "119526.565625",
            //             "realizedPnl" => "476.42665909090909090909088",
            //             "unrealizedPnl" => "-57.26681734000000000000037",
            //             "createdAt" => "2025-07-14T07:53:55.631Z",
            //             "createdAtHeight" => "44140908",
            //             "closedAt" => null,
            //             "sumOpen" => "0.44",
            //             "sumClose" => "0.032",
            //             "netFunding" => "503.13121",
            //             "subaccountNumber" => 0
            //         }
            //     )
            // }
            //
            $rows = $this->safe_list($response, 'positions', array());
            return $this->parse_positions($rows, $symbols);
        }) ();
    }

    public function hash_message($message) {
        return $this->hash($message, 'keccak', 'hex');
    }

    public function sign_hash($hash, $privateKey) {
        $signature = $this->ecdsa(mb_substr($hash, -64), mb_substr($privateKey, -64), 'secp256k1', null);
        $r = $signature['r'];
        $s = $signature['s'];
        return array(
            'r' => str_pad($r, 64, '0', STR_PAD_LEFT),
            's' => str_pad($s, 64, '0', STR_PAD_LEFT),
            'v' => $this->sum(27, $signature['v']),
        );
    }

    public function sign_message($message, $privateKey) {
        return $this->sign_hash($this->hash_message($message), mb_substr($privateKey, -64));
    }

    public function sign_onboarding_action(): array {
        $message = array( 'action' => 'dYdX Chain Onboarding' );
        $chainId = $this->options['chainId'];
        $domain = array(
            'chainId' => $chainId,
            'name' => 'dYdX Chain',
        );
        $messageTypes = array(
            'dYdX' => array(
                array( 'name' => 'action', 'type' => 'string' ),
            ),
        );
        $msg = $this->eth_encode_structured_data($domain, $messageTypes, $message);
        if ($this->privateKey === null || $this->privateKey === '') {
            throw new ArgumentsRequired($this->id . ' signOnboardingAction() requires a privateKey to be set.');
        }
        $signature = $this->sign_message($msg, $this->privateKey);
        return $signature;
    }

    public function sign_dydx_tx(string $privateKey, mixed $message, string $memo, string $chainId, mixed $account, mixed $authenticators, $fee = null): string {
        list($encodedTx, $signDoc) = $this->encode_dydx_tx_for_signing($message, $memo, $chainId, $account, $authenticators, $fee);
        $signature = $this->sign_hash($encodedTx, $privateKey);
        return $this->encode_dydx_tx_raw($signDoc, $signature['r'] . $signature['s']);
    }

    public function retrieve_credentials(): mixed {
        $credentials = $this->safe_dict($this->options, 'dydxCredentials');
        if ($credentials !== null) {
            return $credentials;
        }
        $entropy = $this->safe_string($this->options, 'mnemonic');
        if ($entropy === null) {
            $signature = $this->sign_onboarding_action();
            $entropy = $this->hash_message($this->base16_to_binary($signature['r'] . $signature['s']));
        }
        $credentials = $this->retrieve_dydx_credentials($entropy);
        $credentials['privateKey'] = bin2hex($credentials['privateKey']);
        $credentials['publicKey'] = bin2hex($credentials['publicKey']);
        $this->options['dydxCredentials'] = $credentials;
        return $credentials;
    }

    public function fetch_dydx_account() {
        return Async\async(function ()  {
            // required in js
            Async\await($this->load_dydx_protos());
            $dydxAccount = $this->safe_dict($this->options, 'dydxAccount');
            if ($dydxAccount !== null) {
                return $dydxAccount;
            }
            if ($this->walletAddress === null) {
                throw new ArgumentsRequired($this->id . ' fetchDydxAccount() requires the walletAddress to be set using the dydx chain address eg => dydx1cpb4tedmwq304c2kc9pwzjwq0sc6z2a4tasxrz');
            }
            if (str_starts_with(!$this->walletAddress, 'dydx')) {
                throw new ArgumentsRequired($this->id . ' fetchDydxAccount() requires a valid dydx chain address, starting with dydx, not the l1 address.');
            }
            $request = array(
                'dydxAddress' => $this->walletAddress,
            );
            //
            // {
            //     "info" => {
            //         "address" => "string",
            //         "pub_key" => array(
            //             "type_url" => "string",
            //             "key" => "string"
            //         ),
            //         "account_number" => "string",
            //         "sequence" => "string"
            //     }
            // }
            //
            $response = Async\await($this->nodeRestGetCosmosAuthV1beta1AccountInfoDydxAddress ($request));
            $account = $this->safe_dict($response, 'info');
            $account['pub_key'] = array(
                // encode with binary key would fail in python
                'key' => $account['pub_key']['key'],
            );
            $this->options['dydxAccount'] = $account;
            return $account;
        }) ();
    }

    public function pow(string $n, string $m) {
        $r = Precise::string_mul($n, '1');
        $c = $this->parse_to_int($m);
        // TODO => cap
        for ($i = 1; $i < $c; $i++) {
            $r = Precise::string_mul($r, $n);
        }
        return $r;
    }

    public function create_order_request(string $symbol, string $type, string $side, float $amount, ?float $price = null, $params = array ()) {
        $reduceOnly = $this->safe_bool_2($params, 'reduceOnly', 'reduce_only', false);
        $orderType = strtoupper($type);
        $market = $this->market($symbol);
        $orderSide = strtoupper($side);
        $subaccountId = 0;
        list($subaccountId, $params) = $this->handle_option_and_params($params, 'createOrder', 'subAccountId', $subaccountId);
        $triggerPrice = $this->safe_string_2($params, 'triggerPrice', 'stopPrice');
        $stopLossPrice = $this->safe_value($params, 'stopLossPrice', $triggerPrice);
        $takeProfitPrice = $this->safe_value($params, 'takeProfitPrice');
        $isConditional = $triggerPrice !== null || $stopLossPrice !== null || $takeProfitPrice !== null;
        $isMarket = $orderType === 'MARKET';
        $timeInForce = $this->safe_string_upper($params, 'timeInForce', 'GTT');
        $postOnly = $this->is_post_only($isMarket, null, $params);
        $amountStr = $this->amount_to_precision($symbol, $amount);
        $priceStr = $this->price_to_precision($symbol, $price);
        $marketInfo = $this->safe_dict($market, 'info');
        $atomicResolution = $marketInfo['atomicResolution'];
        $quantumScale = $this->pow('10', Precise::string_neg($atomicResolution));
        $quantums = Precise::string_mul($amountStr, $quantumScale);
        $quantumConversionExponent = $marketInfo['quantumConversionExponent'];
        $priceScale = $this->pow('10', Precise::string_sub(Precise::string_sub($atomicResolution, $quantumConversionExponent), '-6'));
        $subticks = Precise::string_mul($priceStr, $priceScale);
        $clientMetadata = 0;
        $conditionalType = 0;
        $conditionalOrderTriggerSubticks = '0';
        $orderFlag = null;
        $timeInForceNumber = null;
        if ($timeInForce === 'FOK') {
            throw new InvalidOrder($this->id . ' $timeInForce fok has been deprecated');
        }
        if ($orderType === 'MARKET') {
            // short-term
            $orderFlag = 0;
            $clientMetadata = 1; // STOP_MARKET / TAKE_PROFIT_MARKET
            if ($timeInForce !== null) {
                // default is ioc
                $timeInForceNumber = 1;
            }
        } elseif ($orderType === 'LIMIT') {
            if ($timeInForce === 'GTT') {
                // long-term
                $orderFlag = 64;
                if ($postOnly) {
                    $timeInForceNumber = 2;
                } else {
                    $timeInForceNumber = 0;
                }
            } else {
                $orderFlag = 0;
                if ($timeInForce === 'IOC') {
                    $timeInForceNumber = 1;
                } else {
                    throw new InvalidOrder('unexpected code path => timeInForce');
                }
            }
        }
        if ($isConditional) {
            // conditional
            $orderFlag = 32;
            if ($stopLossPrice !== null) {
                $conditionalType = 1;
                $conditionalOrderTriggerSubticks = $this->price_to_precision($symbol, $stopLossPrice);
            } elseif ($takeProfitPrice !== null) {
                $conditionalType = 2;
                $conditionalOrderTriggerSubticks = $this->price_to_precision($symbol, $takeProfitPrice);
            }
            $conditionalOrderTriggerSubticks = Precise::string_mul($conditionalOrderTriggerSubticks, $priceScale);
        }
        $latestBlockHeight = $this->safe_integer($params, 'latestBlockHeight');
        $goodTillBlock = $this->safe_integer($params, 'goodTillBlock');
        $goodTillBlockTime = null;
        $goodTillBlockTimeInSeconds = 2592000;
        list($goodTillBlockTimeInSeconds, $params) = $this->handle_option_and_params($params, 'createOrder', 'goodTillBlockTimeInSeconds', $goodTillBlockTimeInSeconds); // default is 30 days
        if ($orderFlag === 0) {
            if ($goodTillBlock === null) {
                // short term order
                $goodTillBlock = $latestBlockHeight + 20;
            }
        } else {
            if ($goodTillBlockTimeInSeconds === null) {
                throw new ArgumentsRequired('goodTillBlockTimeInSeconds is required.');
            }
            $goodTillBlockTime = $this->seconds() . $goodTillBlockTimeInSeconds;
        }
        $sideNumber = ($orderSide === 'BUY') ? 1 : 2;
        $defaultClientOrderId = $this->rand_number(9); // 2**32 - 1 is 10 digits, but it may overflow with 10
        $clientOrderId = $this->safe_integer($params, 'clientOrderId', $defaultClientOrderId);
        $orderPayload = array(
            'order' => array(
                'orderId' => array(
                    'subaccountId' => array(
                        'owner' => $this->get_wallet_address(),
                        'number' => $subaccountId,
                    ),
                    'clientId' => $clientOrderId,
                    'orderFlags' => $orderFlag,
                    'clobPairId' => $marketInfo['clobPairId'],
                ),
                'side' => $sideNumber,
                'quantums' => $this->to_dydx_long($quantums),
                'subticks' => $this->to_dydx_long($subticks),
                'goodTilBlock' => $goodTillBlock,
                'goodTilBlockTime' => $goodTillBlockTime,
                'timeInForce' => $timeInForceNumber,
                'reduceOnly' => $reduceOnly,
                'clientMetadata' => $clientMetadata,
                'conditionType' => $conditionalType,
                'conditionalOrderTriggerSubticks' => $this->to_dydx_long($conditionalOrderTriggerSubticks),
                'orderRouterAddress' => $this->safe_string($this->options, 'routerAddress', 'dydx165sfn2k3vucvq7gklauy2r3agyjw4c3m60ascn'),
            ),
        );
        $signingPayload = array(
            'typeUrl' => '/dydxprotocol.clob.MsgPlaceOrder',
            'value' => $orderPayload,
        );
        $params = $this->omit($params, array( 'reduceOnly', 'reduce_only', 'clientOrderId', 'postOnly', 'timeInForce', 'stopPrice', 'triggerPrice', 'stopLoss', 'takeProfit', 'latestBlockHeight', 'goodTillBlock', 'goodTillBlockTimeInSeconds', 'subaccountId' ));
        $orderId = $this->create_order_id_from_parts($this->get_wallet_address(), $subaccountId, $clientOrderId, $orderFlag, $marketInfo['clobPairId']);
        return array( $orderId, $this->extend($signingPayload, $params) );
    }

    public function create_order_id_from_parts(string $address, float $subAccountNumber, float $clientOrderId, float $orderFlags, float $clobPairId): string {
        $nameSp = $this->safe_string($this->options, 'namespace', '0f9da948-a6fb-4c45-9edc-4685c3f3317d');
        $prefixAddress = $address . '-' . (string) $subAccountNumber;
        $prefix = $this->uuid5($nameSp, $prefixAddress);
        $orderInfo = $prefix . '-' . $this->number_to_string($clientOrderId) . '-' . $this->number_to_string($clobPairId) . '-' . $this->number_to_string($orderFlags);
        return $this->uuid5($nameSp, $orderInfo);
    }

    public function fetch_latest_block_height($params = array ()): PromiseInterface {
        return Async\async(function () use ($params) {
            $response = Async\await($this->nodeRpcGetAbciInfo ($params));
            //
            // {
            //     "jsonrpc" => "2.0",
            //     "id" => -1,
            //     "result" => {
            //         "response" => {
            //             "data" => "dydxprotocol",
            //             "version" => "9.1.0-rc0",
            //             "last_block_height" => "49157714",
            //             "last_block_app_hash" => "9LHAcDDI5zmWiC6bGiiGtxuWPlKJV+/fTBZk/WQ/Y4U="
            //         }
            //     }
            // }
            //
            $result = $this->safe_dict($response, 'result');
            $info = $this->safe_dict($result, 'response');
            return $this->safe_integer($info, 'last_block_height');
        }) ();
    }

    public function create_order(string $symbol, string $type, string $side, float $amount, ?float $price = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $type, $side, $amount, $price, $params) {
            /**
             *
             * @see https://docs.dydx.xyz/interaction/trading#place-an-order
             *
             * create a trade order
             * @param {string} $symbol unified $symbol of the market to create an order in
             * @param {string} $type 'market' or 'limit'
             * @param {string} $side 'buy' or 'sell'
             * @param {float} $amount how much of currency you want to trade in units of base currency
             * @param {float} [$price] the $price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @param {string} [$params->timeInForce] "GTT", "IOC", or "PO"
             * @param {float} [$params->triggerPrice] The $price a trigger order is triggered at
             * @param {float} [$params->stopLossPrice] $price for a stoploss order
             * @param {float} [$params->takeProfitPrice] $price for a takeprofit order
             * @param {string} [$params->clientOrderId] a unique id for the order
             * @param {bool} [$params->postOnly] true or false whether the order is post-only
             * @param {bool} [$params->reduceOnly] true or false whether the order is reduce-only
             * @param {float} [$params->goodTillBlock] expired block number for the order, required for market order and non limit GTT order, default value is latestBlockHeight + 20
             * @param {float} [$params->goodTillBlockTimeInSeconds] expired time elapsed for the order, required for limit GTT order and conditional, default value is 30 days
             * @return {array} an ~@link https://docs.ccxt.com/?id=order-structure order structure~
             */
            Async\await($this->load_markets());
            $credentials = $this->retrieve_credentials();
            $account = Async\await($this->fetch_dydx_account());
            $lastBlockHeight = Async\await($this->fetch_latest_block_height());
            // $params['latestBlockHeight'] = $lastBlockHeight;
            $newParams = $this->extend($params, array( 'latestBlockHeight' => $lastBlockHeight ));
            $orderRequestRes = $this->create_order_request($symbol, $type, $side, $amount, $price, $newParams);
            $orderId = $orderRequestRes[0];
            $orderRequest = $orderRequestRes[1];
            $chainName = $this->options['chainName'];
            $signedTx = $this->sign_dydx_tx($credentials['privateKey'], $orderRequest, '', $chainName, $account, null);
            $request = array(
                'tx' => $signedTx,
            );
            // nodeRpcGetBroadcastTxAsync
            $response = Async\await($this->nodeRpcGetBroadcastTxSync ($request));
            //
            // {
            //     "jsonrpc" => "2.0",
            //     "id" => -1,
            //     "result" => {
            //         "code" => 0,
            //         "data" => "",
            //         "log" => "array()",
            //         "codespace" => "",
            //         "hash" => "CBEDB0603E57E5CE21FA6954770A9403D2A81BED02E608C860356152D0AA1A81"
            //     }
            // }
            //
            $result = $this->safe_dict($response, 'result');
            return $this->safe_order(array(
                'info' => $result,
                'id' => $orderId,
                'clientOrderId' => $orderRequest['value']['order']['orderId']['clientId'],
            ));
        }) ();
    }

    public function cancel_order(string $id, ?string $symbol = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($id, $symbol, $params) {
            /**
             * cancels an open order
             *
             * @see https://docs.dydx.xyz/interaction/trading/#cancel-an-order
             *
             * @param {string} $id it should be the property_exists($this, $clientOrderId) case
             * @param {string} $symbol unified $symbol of the $market the order was made in
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @param {string} [$params->clientOrderId] client order $id used when creating the order
             * @param {boolean} [$params->trigger] whether the order is a trigger/algo order
             * @param {float} [$params->orderFlags] default is 64, $orderFlags for the order, $market order and non limit GTT order is 0, limit GTT order is 64 and conditional order is 32
             * @param {float} [$params->goodTillBlock] expired block number for the order, required for $market order and non limit GTT order ($orderFlags = 0), default value is $latestBlockHeight + 20
             * @param {float} [$params->goodTillBlockTimeInSeconds] expired time elapsed for the order, required for limit GTT order and conditional (orderFlagss > 0), default value is 30 days
             * @param {int} [$params->subAccountId] sub $account $id, default is 0
             * @return {array} An ~@link https://docs.ccxt.com/?$id=order-structure order structure~
             */
            $isTrigger = $this->safe_bool_2($params, 'trigger', 'stop', false);
            $params = $this->omit($params, array( 'trigger', 'stop' ));
            if (!$isTrigger && ($symbol === null)) {
                throw new ArgumentsRequired($this->id . ' cancelOrder() requires a $symbol argument');
            }
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $clientOrderId = $this->safe_string_2($params, 'clientOrderId', 'clientId', $id);
            if ($clientOrderId === null) {
                throw new ArgumentsRequired($this->id . ' cancelOrder() requires a $clientOrderId parameter, cancelling using $id is not currently supported.');
            }
            $idString = (string) $id;
            if ($id !== null && mb_strpos($idString, '-') > -1) {
                throw new NotSupported($this->id . ' cancelOrder() cancelling using $id is not currently supported, please use provide the $clientOrderId parameter.');
            }
            $goodTillBlock = $this->safe_integer($params, 'goodTillBlock');
            $goodTillBlockTimeInSeconds = 2592000;
            list($goodTillBlockTimeInSeconds, $params) = $this->handle_option_and_params($params, 'cancelOrder', 'goodTillBlockTimeInSeconds', $goodTillBlockTimeInSeconds); // default is 30 days
            $goodTillBlockTime = null;
            $defaultOrderFlags = ($isTrigger) ? 32 : 64;
            $orderFlags = $this->safe_integer($params, 'orderFlags', $defaultOrderFlags);
            $subAccountId = 0;
            list($subAccountId, $params) = $this->handle_option_and_params($params, 'cancelOrder', 'subAccountId', $subAccountId);
            $params = $this->omit($params, array( 'clientOrderId', 'orderFlags', 'goodTillBlock', 'goodTillBlockTime', 'goodTillBlockTimeInSeconds', 'subaccountId', 'clientId' ));
            if ($orderFlags !== 0 && $orderFlags !== 64 && $orderFlags !== 32) {
                throw new InvalidOrder($this->id . ' invalid $orderFlags, allowed values are (0, 64, 32).');
            }
            if ($orderFlags > 0) {
                if ($goodTillBlockTimeInSeconds === null) {
                    throw new ArgumentsRequired($this->id . ' $goodTillBlockTimeInSeconds is required in $params for long term or conditional order.');
                }
                if ($goodTillBlock !== null && $goodTillBlock > 0) {
                    throw new InvalidOrder($this->id . ' $goodTillBlock should be 0 for long term or conditional order.');
                }
                $goodTillBlockTime = $this->seconds() . $goodTillBlockTimeInSeconds;
            } else {
                if ($goodTillBlock === null) {
                    $latestBlockHeight = Async\await($this->fetch_latest_block_height());
                    $goodTillBlock = $latestBlockHeight + 20;
                }
            }
            $credentials = $this->retrieve_credentials();
            $account = Async\await($this->fetch_dydx_account());
            $cancelPayload = array(
                'orderId' => array(
                    'subaccountId' => array(
                        'owner' => $this->get_wallet_address(),
                        'number' => $subAccountId,
                    ),
                    'clientId' => $clientOrderId,
                    'orderFlags' => $orderFlags,
                    'clobPairId' => $market['info']['clobPairId'],
                ),
                'goodTilBlock' => $goodTillBlock,
                'goodTilBlockTime' => $goodTillBlockTime,
            );
            $signingPayload = array(
                'typeUrl' => '/dydxprotocol.clob.MsgCancelOrder',
                'value' => $cancelPayload,
            );
            $chainName = $this->options['chainName'];
            $signedTx = $this->sign_dydx_tx($credentials['privateKey'], $signingPayload, '', $chainName, $account, null);
            $request = array(
                'tx' => $signedTx,
            );
            // nodeRpcGetBroadcastTxAsync
            $response = Async\await($this->nodeRpcGetBroadcastTxSync ($request));
            //
            // {
            //     "jsonrpc" => "2.0",
            //     "id" => -1,
            //     "result" => {
            //         "code" => 0,
            //         "data" => "",
            //         "log" => "array()",
            //         "codespace" => "",
            //         "hash" => "CBEDB0603E57E5CE21FA6954770A9403D2A81BED02E608C860356152D0AA1A81"
            //     }
            // }
            //
            $result = $this->safe_dict($response, 'result');
            return $this->safe_order(array(
                'info' => $result,
            ));
        }) ();
    }

    public function cancel_orders(array $ids, ?string $symbol = null, $params = array ()) {
        return Async\async(function () use ($ids, $symbol, $params) {
            /**
             * cancel multiple orders
             * @param {string[]} $ids order $ids
             * @param {string} [$symbol] unified $market $symbol
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @param {string[]} [$params->clientOrderIds] max length 10 e.g. ["my_id_1","my_id_2"], encode the double quotes. No space after comma
             * @param {int} [$params->subAccountId] sub $account id, default is 0
             * @return {array} an list of ~@link https://docs.ccxt.com/?id=order-structure order structures~
             */
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $clientOrderIds = $this->safe_list($params, 'clientOrderIds');
            if (!$clientOrderIds) {
                throw new NotSupported($this->id . ' $cancelOrders only support $clientOrderIds->');
            }
            $subAccountId = 0;
            list($subAccountId, $params) = $this->handle_option_and_params($params, 'cancelOrders', 'subAccountId', $subAccountId);
            $goodTillBlock = $this->safe_integer($params, 'goodTillBlock');
            if ($goodTillBlock === null) {
                $latestBlockHeight = Async\await($this->fetch_latest_block_height());
                $goodTillBlock = $latestBlockHeight + 20;
            }
            $params = $this->omit($params, array( 'clientOrderIds', 'goodTillBlock', 'subaccountId' ));
            $credentials = $this->retrieve_credentials();
            $account = Async\await($this->fetch_dydx_account());
            $cancelOrders = array(
                'clientIds' => $clientOrderIds,
                'clobPairId' => $market['info']['clobPairId'],
            );
            $cancelPayload = array(
                'subaccountId' => array(
                    'owner' => $this->get_wallet_address(),
                    'number' => $subAccountId,
                ),
                'shortTermCancels' => array( $cancelOrders ),
                'goodTilBlock' => $goodTillBlock,
            );
            $signingPayload = array(
                'typeUrl' => '/dydxprotocol.clob.MsgBatchCancel',
                'value' => $cancelPayload,
            );
            $chainName = $this->options['chainName'];
            $signedTx = $this->sign_dydx_tx($credentials['privateKey'], $signingPayload, '', $chainName, $account, null);
            $request = array(
                'tx' => $signedTx,
            );
            // nodeRpcGetBroadcastTxAsync
            $response = Async\await($this->nodeRpcGetBroadcastTxSync ($request));
            //
            // {
            //     "jsonrpc" => "2.0",
            //     "id" => -1,
            //     "result" => {
            //         "code" => 0,
            //         "data" => "",
            //         "log" => "array()",
            //         "codespace" => "",
            //         "hash" => "CBEDB0603E57E5CE21FA6954770A9403D2A81BED02E608C860356152D0AA1A81"
            //     }
            // }
            //
            $result = $this->safe_dict($response, 'result');
            return array( $this->safe_order(array(
                'info' => $result,
            )) );
        }) ();
    }

    public function fetch_order_book(string $symbol, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $limit, $params) {
            /**
             * fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
             *
             * @see https://docs.dydx.xyz/indexer-client/http#get-perpetual-$market-orderbook
             *
             * @param {string} $symbol unified $symbol of the $market to fetch the order book for
             * @param {int} [$limit] the maximum amount of order book entries to return
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} A dictionary of ~@link https://docs.ccxt.com/?id=order-book-structure order book structures~ indexed by $market symbols
             */
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $request = array(
                'market' => $market['id'],
            );
            $response = Async\await($this->indexerGetOrderbooksPerpetualMarketMarket ($this->extend($request, $params)));
            //
            // {
            //     "bids" => array(
            //         {
            //             "price" => "118267",
            //             "size" => "0.3182"
            //         }
            //     ),
            //     "asks" => array(
            //         {
            //             "price" => "118485",
            //             "size" => "0.0001"
            //         }
            //     )
            // }
            //
            return $this->parse_order_book($response, $market['symbol'], null, 'bids', 'asks', 'price', 'size');
        }) ();
    }

    public function parse_ledger_entry(array $item, ?array $currency = null): array {
        //
        // {
        //     "id" => "6a6075bc-7183-5fd9-bc9d-894e238aa527",
        //     "sender" => array(
        //         "address" => "dydx14zzueazeh0hj67cghhf9jypslcf9sh2n5k6art",
        //         "subaccountNumber" => 0
        //     ),
        //     "recipient" => array(
        //         "address" => "dydx1slanxj8x9ntk9knwa6cvfv2tzlsq5gk3dshml0",
        //         "subaccountNumber" => 1
        //     ),
        //     "size" => "0.000001",
        //     "createdAt" => "2025-07-29T09:43:02.105Z",
        //     "createdAtHeight" => "45116125",
        //     "symbol" => "USDC",
        //     "type" => "TRANSFER_OUT",
        //     "transactionHash" => "92B4744BA1B783CF37C79A50BEBC47FFD59C8D5197D62A8485D3DCCE9AF220AF"
        // }
        //
        $currencyId = $this->safe_string($item, 'symbol');
        $code = $this->safe_currency_code($currencyId, $currency);
        $currency = $this->safe_currency($currencyId, $currency);
        $type = $this->safe_string_upper($item, 'type');
        $direction = null;
        if ($type !== null) {
            if ($type === 'TRANSFER_IN' || $type === 'DEPOSIT') {
                $direction = 'in';
            } elseif ($type === 'TRANSFER_OUT' || $type === 'WITHDRAWAL') {
                $direction = 'out';
            }
        }
        $amount = $this->safe_string($item, 'size');
        $timestamp = $this->parse8601($this->safe_string($item, 'createdAt'));
        $sender = $this->safe_dict($item, 'sender');
        $recipient = $this->safe_dict($item, 'recipient');
        return $this->safe_ledger_entry(array(
            'info' => $item,
            'id' => $this->safe_string($item, 'id'),
            'direction' => $direction,
            'account' => $this->safe_string($sender, 'address'),
            'referenceAccount' => $this->safe_string($recipient, 'address'),
            'referenceId' => $this->safe_string($item, 'transactionHash'),
            'type' => $this->parse_ledger_entry_type($type),
            'currency' => $code,
            'amount' => $this->parse_number($amount),
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'before' => null,
            'after' => null,
            'status' => null,
            'fee' => null,
        ), $currency);
    }

    public function parse_ledger_entry_type($type) {
        $ledgerType = array(
            'TRANSFER_IN' => 'transfer',
            'TRANSFER_OUT' => 'transfer',
            'DEPOSIT' => 'deposit',
            'WITHDRAWAL' => 'withdrawal',
        );
        return $this->safe_string($ledgerType, $type, $type);
    }

    public function fetch_ledger(?string $code = null, ?int $since = null, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($code, $since, $limit, $params) {
            /**
             * fetch the history of changes, actions done by the user or operations that altered balance of the user
             *
             * @see https://docs.dydx.xyz/indexer-client/http#get-transfers
             *
             * @param {string} [$code] unified $currency $code, default is null
             * @param {int} [$since] timestamp in ms of the earliest ledger entry, default is null
             * @param {int} [$limit] max number of ledger entries to return, default is null
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @param {string} [$params->address] wallet address that made trades
             * @param {string} [$params->subAccountNumber] sub account number
             * @return {array} a ~@link https://docs.ccxt.com/?id=ledger ledger structure~
             */
            Async\await($this->load_markets());
            $currency = null;
            if ($code !== null) {
                $currency = $this->currency($code);
            }
            $response = Async\await($this->fetch_transactions_helper($code, $since, $limit, $this->extend($params, array( 'methodName' => 'fetchLedger' ))));
            return $this->parse_ledger($response, $currency, $since, $limit);
        }) ();
    }

    public function estimate_tx_fee(mixed $message, string $memo, mixed $account): PromiseInterface {
        return Async\async(function () use ($message, $memo, $account) {
            $txBytes = $this->encode_dydx_tx_for_simulation($message, $memo, $account['sequence'], $account['pub_key']);
            $request = array(
                'txBytes' => $txBytes,
            );
            $response = Async\await($this->nodeRestPostCosmosTxV1beta1Simulate ($request));
            //
            // {
            //     gas_info => array( gas_wanted => '18446744073709551615', gas_used => '86055' ),
            //     result => {
            //         ...
            //     }
            // }
            //
            $gasInfo = $this->safe_dict($response, 'gas_info');
            if ($gasInfo === null) {
                throw new ExchangeError($this->id . ' failed to simulate transaction.');
            }
            $gasUsed = $this->safe_string($gasInfo, 'gas_used');
            if ($gasUsed === null) {
                throw new ExchangeError($this->id . ' failed to simulate transaction.');
            }
            $defaultFeeDenom = $this->safe_string($this->options, 'defaultFeeDenom');
            $defaultFeeMultiplier = $this->safe_string($this->options, 'defaultFeeMultiplier');
            $feeDenom = $this->safe_dict($this->options, 'feeDenom');
            $gasPrice = null;
            $denom = null;
            if ($defaultFeeDenom === 'uusdc') {
                $gasPrice = $feeDenom['USDC_GAS_PRICE'];
                $denom = $feeDenom['USDC_DENOM'];
            } else {
                $gasPrice = $feeDenom['CHAINTOKEN_GAS_PRICE'];
                $denom = $feeDenom['CHAINTOKEN_DENOM'];
            }
            $gasLimit = (int) ceil($this->parse_to_numeric(Precise::string_mul($gasUsed, $defaultFeeMultiplier)));
            $feeAmount = Precise::string_mul($this->number_to_string($gasLimit), $gasPrice);
            if (mb_strpos($feeAmount, '.') !== false) {
                $feeAmount = $this->number_to_string((int) ceil($this->parse_to_numeric($feeAmount)));
            }
            $feeObj = array(
                'amount' => $feeAmount,
                'denom' => $denom,
            );
            return array(
                'amount' => array( $feeObj ),
                'gasLimit' => $gasLimit,
            );
        }) ();
    }

    public function transfer(string $code, float $amount, string $fromAccount, string $toAccount, $params = array ()): PromiseInterface {
        return Async\async(function () use ($code, $amount, $fromAccount, $toAccount, $params) {
            /**
             * transfer currency internally between wallets on the same $account
             * @param {string} $code unified currency $code
             * @param {float} $amount amount to transfer
             * @param {string} $fromAccount $account to transfer from *main, subaccount*
             * @param {string} $toAccount $account to transfer to *subaccount, address*
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @param {string} [$params->vaultAddress] the vault address for order
             * @return {array} a ~@link https://docs.ccxt.com/?id=transfer-structure transfer structure~
             */
            if ($code !== 'USDC') {
                throw new NotSupported($this->id . ' transfer() only support USDC');
            }
            Async\await($this->load_markets());
            $fromSubaccountId = $this->safe_integer($params, 'fromSubaccountId');
            $toSubaccountId = $this->safe_integer($params, 'toSubaccountId');
            if ($fromAccount !== 'main') {
                // throw error if from subaccount id is undefind
                if ($fromAccount === null) {
                    throw new NotSupported($this->id . ' transfer only support main > subaccount and subaccount <> subaccount.');
                }
                if ($fromSubaccountId === null || $toSubaccountId === null) {
                    throw new ArgumentsRequired($this->id . ' transfer requires $fromSubaccountId and $toSubaccountId->');
                }
            }
            $params = $this->omit($params, array( 'fromSubaccountId', 'toSubaccountId' ));
            $credentials = $this->retrieve_credentials();
            $account = Async\await($this->fetch_dydx_account());
            $usd = $this->parse_to_int(Precise::string_mul($this->number_to_string($amount), '1000000'));
            $payload = null;
            $signingPayload = null;
            if ($fromAccount === 'main') {
                // deposit to subaccount
                if ($toSubaccountId === null) {
                    throw new ArgumentsRequired($this->id . ' transfer() requeire toSubaccoutnId.');
                }
                $payload = array(
                    'sender' => $this->get_wallet_address(),
                    'recipient' => array(
                        'owner' => $this->get_wallet_address(),
                        'number' => $toSubaccountId,
                    ),
                    'assetId' => 0,
                    'quantums' => $usd,
                );
                $signingPayload = array(
                    'typeUrl' => '/dydxprotocol.sending.MsgDepositToSubaccount',
                    'value' => $payload,
                );
            } else {
                $payload = array(
                    'transfer' => array(
                        'sender' => array(
                            'owner' => $fromAccount,
                            'number' => $fromSubaccountId,
                        ),
                        'recipient' => array(
                            'owner' => $toAccount,
                            'number' => $toSubaccountId,
                        ),
                        'assetId' => 0,
                        'amount' => $usd,
                    ),
                );
                $signingPayload = array(
                    'typeUrl' => '/dydxprotocol.sending.MsgCreateTransfer',
                    'value' => $payload,
                );
            }
            $txFee = Async\await($this->estimate_tx_fee($signingPayload, '', $account));
            $chainName = $this->options['chainName'];
            $signedTx = $this->sign_dydx_tx($credentials['privateKey'], $signingPayload, '', $chainName, $account, null, $txFee);
            $request = array(
                'tx' => $signedTx,
            );
            // nodeRpcGetBroadcastTxAsync
            $response = Async\await($this->nodeRpcGetBroadcastTxSync ($request));
            //
            // {
            //     "jsonrpc" => "2.0",
            //     "id" => -1,
            //     "result" => {
            //         "code" => 0,
            //         "data" => "",
            //         "log" => "array()",
            //         "codespace" => "",
            //         "hash" => "CBEDB0603E57E5CE21FA6954770A9403D2A81BED02E608C860356152D0AA1A81"
            //     }
            // }
            //
            return $this->parse_transfer($response);
        }) ();
    }

    public function parse_transfer(array $transfer, ?array $currency = null): array {
        //
        // {
        //     "id" => "6a6075bc-7183-5fd9-bc9d-894e238aa527",
        //     "sender" => array(
        //         "address" => "dydx14zzueazeh0hj67cghhf9jypslcf9sh2n5k6art",
        //         "subaccountNumber" => 0
        //     ),
        //     "recipient" => array(
        //         "address" => "dydx1slanxj8x9ntk9knwa6cvfv2tzlsq5gk3dshml0",
        //         "subaccountNumber" => 1
        //     ),
        //     "size" => "0.000001",
        //     "createdAt" => "2025-07-29T09:43:02.105Z",
        //     "createdAtHeight" => "45116125",
        //     "symbol" => "USDC",
        //     "type" => "TRANSFER_OUT",
        //     "transactionHash" => "92B4744BA1B783CF37C79A50BEBC47FFD59C8D5197D62A8485D3DCCE9AF220AF"
        // }
        //
        $id = $this->safe_string($transfer, 'id');
        $currencyId = $this->safe_string($transfer, 'symbol');
        $code = $this->safe_currency_code($currencyId, $currency);
        $amount = $this->safe_number($transfer, 'size');
        $sender = $this->safe_dict($transfer, 'sender');
        $recipient = $this->safe_dict($transfer, 'recipient');
        $fromAccount = $this->safe_string($sender, 'address');
        $toAccount = $this->safe_string($recipient, 'address');
        $timestamp = $this->parse8601($this->safe_string($transfer, 'createdAt'));
        return array(
            'info' => $transfer,
            'id' => $id,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'currency' => $code,
            'amount' => $amount,
            'fromAccount' => $fromAccount,
            'toAccount' => $toAccount,
            'status' => null,
        );
    }

    public function fetch_transfers(?string $code = null, ?int $since = null, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($code, $since, $limit, $params) {
            /**
             * fetch a history of internal transfers made on an account
             *
             * @see https://docs.dydx.xyz/indexer-client/http#get-transfers
             *
             * @param {string} $code unified $currency $code of the $currency transferred
             * @param {int} [$since] the earliest time in ms to fetch transfers for
             * @param {int} [$limit] the maximum number of transfers structures to retrieve
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @param {string} [$params->address] wallet address that made trades
             * @param {string} [$params->subAccountNumber] sub account number
             * @return {array[]} a list of ~@link https://docs.ccxt.com/?id=transfer-structure transfer structures~
             */
            Async\await($this->load_markets());
            $currency = null;
            if ($code !== null) {
                $currency = $this->currency($code);
            }
            $response = Async\await($this->fetch_transactions_helper($code, $since, $limit, $this->extend($params, array( 'methodName' => 'fetchTransfers' ))));
            $transferIn = $this->filter_by($response, 'type', 'TRANSFER_IN');
            $transferOut = $this->filter_by($response, 'type', 'TRANSFER_OUT');
            $rows = $this->array_concat($transferIn, $transferOut);
            return $this->parse_transfers($rows, $currency, $since, $limit);
        }) ();
    }

    public function parse_transaction(array $transaction, ?array $currency = null): array {
        //
        // {
        //     "id" => "6a6075bc-7183-5fd9-bc9d-894e238aa527",
        //     "sender" => array(
        //         "address" => "dydx14zzueazeh0hj67cghhf9jypslcf9sh2n5k6art",
        //         "subaccountNumber" => 0
        //     ),
        //     "recipient" => array(
        //         "address" => "dydx1slanxj8x9ntk9knwa6cvfv2tzlsq5gk3dshml0",
        //         "subaccountNumber" => 1
        //     ),
        //     "size" => "0.000001",
        //     "createdAt" => "2025-07-29T09:43:02.105Z",
        //     "createdAtHeight" => "45116125",
        //     "symbol" => "USDC",
        //     "type" => "TRANSFER_OUT",
        //     "transactionHash" => "92B4744BA1B783CF37C79A50BEBC47FFD59C8D5197D62A8485D3DCCE9AF220AF"
        // }
        //
        $id = $this->safe_string($transaction, 'id');
        $sender = $this->safe_dict($transaction, 'sender');
        $recipient = $this->safe_dict($transaction, 'recipient');
        $addressTo = $this->safe_string($recipient, 'address');
        $addressFrom = $this->safe_string($sender, 'address');
        $txid = $this->safe_string($transaction, 'transactionHash');
        $currencyId = $this->safe_string($transaction, 'symbol');
        $code = $this->safe_currency_code($currencyId, $currency);
        $timestamp = $this->parse8601($this->safe_string($transaction, 'createdAt'));
        $amount = $this->safe_number($transaction, 'size');
        return array(
            'info' => $transaction,
            'id' => $id,
            'txid' => $txid,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'network' => null,
            'address' => $addressTo,
            'addressTo' => $addressTo,
            'addressFrom' => $addressFrom,
            'tag' => null,
            'tagTo' => null,
            'tagFrom' => null,
            'type' => $this->safe_string_lower($transaction, 'type'), // 'deposit', 'withdrawal'
            'amount' => $amount,
            'currency' => $code,
            'status' => null,
            'updated' => null,
            'internal' => null,
            'comment' => null,
            'fee' => null,
        );
    }

    public function withdraw(string $code, float $amount, string $address, ?string $tag = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($code, $amount, $address, $tag, $params) {
            /**
             * make a withdrawal
             * @param {string} $code unified $currency $code
             * @param {float} $amount the $amount to withdraw
             * @param {string} $address the $address to withdraw to
             * @param {string} $tag
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} a ~@link https://docs.ccxt.com/?id=transaction-structure transaction structure~
             */
            if ($code !== 'USDC') {
                throw new NotSupported($this->id . ' withdraw() only support USDC');
            }
            Async\await($this->load_markets());
            $this->check_address($address);
            $subaccountId = $this->safe_integer($params, 'subaccountId');
            if ($subaccountId === null) {
                throw new ArgumentsRequired($this->id . ' withdraw requires $subaccountId->');
            }
            $params = $this->omit($params, array( 'subaccountId' ));
            $currency = $this->currency($code);
            $credentials = $this->retrieve_credentials();
            $account = Async\await($this->fetch_dydx_account());
            $usd = $this->parse_to_int(Precise::string_mul($this->number_to_string($amount), '1000000'));
            $payload = array(
                'sender' => array(
                    'owner' => $this->get_wallet_address(),
                    'number' => $subaccountId,
                ),
                'recipient' => $address,
                'assetId' => 0,
                'quantums' => $usd,
            );
            $signingPayload = array(
                'typeUrl' => '/dydxprotocol.sending.MsgWithdrawFromSubaccount',
                'value' => $payload,
            );
            $txFee = Async\await($this->estimate_tx_fee($signingPayload, $tag, $account));
            $chainName = $this->options['chainName'];
            $signedTx = $this->sign_dydx_tx($credentials['privateKey'], $signingPayload, $tag, $chainName, $account, null, $txFee);
            $request = array(
                'tx' => $signedTx,
            );
            // nodeRpcGetBroadcastTxAsync
            $response = Async\await($this->nodeRpcGetBroadcastTxSync ($request));
            //
            // {
            //     "jsonrpc" => "2.0",
            //     "id" => -1,
            //     "result" => {
            //         "code" => 0,
            //         "data" => "",
            //         "log" => "array()",
            //         "codespace" => "",
            //         "hash" => "CBEDB0603E57E5CE21FA6954770A9403D2A81BED02E608C860356152D0AA1A81"
            //     }
            // }
            //
            $data = $this->safe_dict($response, 'result', array());
            return $this->parse_transaction($data, $currency);
        }) ();
    }

    public function fetch_withdrawals(?string $code = null, ?int $since = null, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($code, $since, $limit, $params) {
            /**
             * fetch all withdrawals made from an account
             *
             * @see https://docs.dydx.xyz/indexer-client/http#get-transfers
             *
             * @param {string} $code unified $currency $code
             * @param {int} [$since] the earliest time in ms to fetch withdrawals for
             * @param {int} [$limit] the maximum number of withdrawals structures to retrieve
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @param {string} [$params->address] wallet address that made trades
             * @param {string} [$params->subAccountNumber] sub account number
             * @return {array[]} a list of ~@link https://docs.ccxt.com/?id=transaction-structure transaction structures~
             */
            Async\await($this->load_markets());
            $currency = null;
            if ($code !== null) {
                $currency = $this->currency($code);
            }
            $response = Async\await($this->fetch_transactions_helper($code, $since, $limit, $this->extend($params, array( 'methodName' => 'fetchWithdrawals' ))));
            $rows = $this->filter_by($response, 'type', 'WITHDRAWAL');
            return $this->parse_transactions($rows, $currency, $since, $limit);
        }) ();
    }

    public function fetch_deposits(?string $code = null, ?int $since = null, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($code, $since, $limit, $params) {
            /**
             * fetch all deposits made to an account
             *
             * @see https://docs.dydx.xyz/indexer-client/http#get-transfers
             *
             * @param {string} $code unified $currency $code
             * @param {int} [$since] the earliest time in ms to fetch deposits for
             * @param {int} [$limit] the maximum number of deposits structures to retrieve
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @param {string} [$params->address] wallet address that made trades
             * @param {string} [$params->subAccountNumber] sub account number
             * @return {array[]} a list of ~@link https://docs.ccxt.com/?id=transaction-structure transaction structures~
             */
            Async\await($this->load_markets());
            $currency = null;
            if ($code !== null) {
                $currency = $this->currency($code);
            }
            $response = Async\await($this->fetch_transactions_helper($code, $since, $limit, $this->extend($params, array( 'methodName' => 'fetchDeposits' ))));
            $rows = $this->filter_by($response, 'type', 'DEPOSIT');
            return $this->parse_transactions($rows, $currency, $since, $limit);
        }) ();
    }

    public function fetch_deposits_withdrawals(?string $code = null, ?int $since = null, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($code, $since, $limit, $params) {
            /**
             * fetch history of $deposits and $withdrawals
             *
             * @see https://docs.dydx.xyz/indexer-client/http#get-transfers
             *
             * @param {string} [$code] unified $currency $code for the $currency of the deposit/withdrawals, default is null
             * @param {int} [$since] timestamp in ms of the earliest deposit/withdrawal, default is null
             * @param {int} [$limit] max number of deposit/withdrawals to return, default is null
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @param {string} [$params->address] wallet address that made trades
             * @param {string} [$params->subAccountNumber] sub account number
             * @return {array} a list of ~@link https://docs.ccxt.com/?id=transaction-structure transaction structure~
             */
            Async\await($this->load_markets());
            $currency = null;
            if ($code !== null) {
                $currency = $this->currency($code);
            }
            $response = Async\await($this->fetch_transactions_helper($code, $since, $limit, $this->extend($params, array( 'methodName' => 'fetchDepositsWithdrawals' ))));
            $withdrawals = $this->filter_by($response, 'type', 'WITHDRAWAL');
            $deposits = $this->filter_by($response, 'type', 'DEPOSIT');
            $rows = $this->array_concat($withdrawals, $deposits);
            return $this->parse_transactions($rows, $currency, $since, $limit);
        }) ();
    }

    public function fetch_transactions_helper(?string $code = null, ?int $since = null, ?int $limit = null, $params = array ()) {
        return Async\async(function () use ($code, $since, $limit, $params) {
            $methodName = $this->safe_string($params, 'methodName');
            $params = $this->omit($params, 'methodName');
            $userAddress = null;
            $subAccountNumber = null;
            list($userAddress, $params) = $this->handle_public_address($methodName, $params);
            list($subAccountNumber, $params) = $this->handle_option_and_params($params, $methodName, 'subAccountNumber', '0');
            $request = array(
                'address' => $userAddress,
                'subaccountNumber' => $subAccountNumber,
            );
            $response = Async\await($this->indexerGetTransfers ($this->extend($request, $params)));
            //
            // {
            //     "transfers" => array(
            //         {
            //             "id" => "6a6075bc-7183-5fd9-bc9d-894e238aa527",
            //             "sender" => array(
            //                 "address" => "dydx14zzueazeh0hj67cghhf9jypslcf9sh2n5k6art",
            //                 "subaccountNumber" => 0
            //             ),
            //             "recipient" => array(
            //                 "address" => "dydx1slanxj8x9ntk9knwa6cvfv2tzlsq5gk3dshml0",
            //                 "subaccountNumber" => 1
            //             ),
            //             "size" => "0.000001",
            //             "createdAt" => "2025-07-29T09:43:02.105Z",
            //             "createdAtHeight" => "45116125",
            //             "symbol" => "USDC",
            //             "type" => "TRANSFER_OUT",
            //             "transactionHash" => "92B4744BA1B783CF37C79A50BEBC47FFD59C8D5197D62A8485D3DCCE9AF220AF"
            //         }
            //     )
            // }
            //
            return $this->safe_list($response, 'transfers', array());
        }) ();
    }

    public function fetch_accounts($params = array ()): PromiseInterface {
        return Async\async(function () use ($params) {
            /**
             * fetch all the accounts associated with a profile
             *
             * @see https://docs.dydx.xyz/indexer-client/http#get-subaccounts
             *
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @param {string} [$params->address] wallet address that made trades
             * @return {array} a dictionary of ~@link https://docs.ccxt.com/?id=$account-structure $account structures~ indexed by the $account type
             */
            $userAddress = null;
            list($userAddress, $params) = $this->handle_public_address('fetchAccounts', $params);
            $request = array(
                'address' => $userAddress,
            );
            $response = Async\await($this->indexerGetAddressesAddress ($this->extend($request, $params)));
            //
            // {
            //     "subaccounts" => array(
            //         {
            //             "address" => "dydx14zzueazeh0hj67cghhf9jypslcf9sh2n5k6art",
            //             "subaccountNumber" => 0,
            //             "equity" => "25346.73993597",
            //             "freeCollateral" => "24207.8530595294",
            //             "openPerpetualPositions" => {
            //                 "BTC-USD" => array(
            //                     "market" => "BTC-USD",
            //                     "status" => "OPEN",
            //                     "side" => "SHORT",
            //                     "size" => "-0.491",
            //                     "maxSize" => "-0.009",
            //                     "entryPrice" => "118703.60811320754716981132",
            //                     "exitPrice" => "119655.95",
            //                     "realizedPnl" => "3075.17994830188679245283016",
            //                     "unrealizedPnl" => "1339.12776155490566037735812",
            //                     "createdAt" => "2025-07-14T07:53:55.631Z",
            //                     "createdAtHeight" => "44140908",
            //                     "closedAt" => null,
            //                     "sumOpen" => "0.53",
            //                     "sumClose" => "0.038",
            //                     "netFunding" => "3111.36894",
            //                     "subaccountNumber" => 0
            //                 }
            //             ),
            //             "assetPositions" => {
            //                 "USDC" => array(
            //                     "size" => "82291.083758",
            //                     "symbol" => "USDC",
            //                     "side" => "LONG",
            //                     "assetId" => "0",
            //                     "subaccountNumber" => 0
            //                 }
            //             ),
            //             "marginEnabled" => true,
            //             "updatedAtHeight" => "45234659",
            //             "latestProcessedBlockHeight" => "45293477"
            //         }
            //     )
            // }
            //
            $rows = $this->safe_list($response, 'subaccounts', array());
            $result = array();
            for ($i = 0; $i < count($rows); $i++) {
                $account = $rows[$i];
                $accountId = $this->safe_string($account, 'subaccountNumber');
                $result[] = array(
                    'id' => $accountId,
                    'type' => null,
                    'currency' => null,
                    'info' => $account,
                    'code' => null,
                );
            }
            return $result;
        }) ();
    }

    public function fetch_balance($params = array ()): PromiseInterface {
        return Async\async(function () use ($params) {
            /**
             * query for balance and get the amount of funds available for trading or funds locked in orders
             *
             * @see https://docs.dydx.xyz/indexer-client/http#get-subaccount
             *
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} a ~@link https://docs.ccxt.com/?id=balance-structure balance structure~
             */
            Async\await($this->load_markets());
            $userAddress = null;
            list($userAddress, $params) = $this->handle_public_address('fetchAccounts', $params);
            $subaccountNumber = null;
            list($subaccountNumber, $params) = $this->handle_option_and_params($params, 'fetchAccounts', 'subaccountNumber', 0);
            $request = array(
                'address' => $userAddress,
                'subaccountNumber' => $subaccountNumber,
            );
            $response = Async\await($this->indexerGetAddressesAddressSubaccountNumberSubaccountNumber ($this->extend($request, $params)));
            //
            // {
            //     "subaccount" => {
            //         "address" => "dydx14zzueazeh0hj67cghhf9jypslcf9sh2n5k6art",
            //         "subaccountNumber" => 0,
            //         "equity" => "161451.040416029",
            //         "freeCollateral" => "152508.28819133578",
            //         "openPerpetualPositions" => {
            //             "ETH-USD" => array(
            //                 "market" => "ETH-USD",
            //                 "status" => "OPEN",
            //                 "side" => "LONG",
            //                 "size" => "0.001",
            //                 "maxSize" => "0.002",
            //                 "entryPrice" => "3894.7",
            //                 "exitPrice" => "3864.5",
            //                 "realizedPnl" => "-0.034847",
            //                 "unrealizedPnl" => "-0.044675155",
            //                 "createdAt" => "2025-10-22T08:34:05.883Z",
            //                 "createdAtHeight" => "52228825",
            //                 "closedAt" => null,
            //                 "sumOpen" => "0.002",
            //                 "sumClose" => "0.001",
            //                 "netFunding" => "-0.004647",
            //                 "subaccountNumber" => 0
            //             ),
            //             "BTC-USD" => array(
            //                 "market" => "BTC-USD",
            //                 "status" => "OPEN",
            //                 "side" => "SHORT",
            //                 "size" => "-4.1368",
            //                 "maxSize" => "-0.009",
            //                 "entryPrice" => "112196.87848803433219017636",
            //                 "exitPrice" => "113885.21872652924977050823",
            //                 "realizedPnl" => "-15180.426770788459736511679821",
            //                 "unrealizedPnl" => "17002.285719484425404321566048",
            //                 "createdAt" => "2025-07-14T07:53:55.631Z",
            //                 "createdAtHeight" => "44140908",
            //                 "closedAt" => null,
            //                 "sumOpen" => "5.3361",
            //                 "sumClose" => "1.1983",
            //                 "netFunding" => "-13157.288663",
            //                 "subaccountNumber" => 0
            //             }
            //         ),
            //         "assetPositions" => {
            //             "USDC" => array(
            //                 "size" => "608580.951601",
            //                 "symbol" => "USDC",
            //                 "side" => "LONG",
            //                 "assetId" => "0",
            //                 "subaccountNumber" => 0
            //             }
            //         ),
            //         "marginEnabled" => true,
            //         "updatedAtHeight" => "52228833",
            //         "latestProcessedBlockHeight" => "52246761"
            //     }
            // }
            //
            $data = $this->safe_dict($response, 'subaccount');
            return $this->parse_balance($data);
        }) ();
    }

    public function parse_balance($response): array {
        $account = $this->account();
        $account['free'] = $this->safe_string($response, 'freeCollateral');
        $result = array(
            'info' => $response,
            'USDC' => $account,
        );
        return $this->safe_balance($result);
    }

    public function nonce() {
        return $this->milliseconds() - $this->options['timeDifference'];
    }

    public function get_wallet_address() {
        if ($this->walletAddress !== null && $this->walletAddress !== '') {
            return $this->walletAddress;
        }
        $dydxAccount = $this->safe_dict($this->options, 'dydxAccount');
        if ($dydxAccount !== null) {
            // return $dydxAccount;
            $wallet = $this->safe_string($dydxAccount, 'address');
            if ($wallet !== null) {
                return $wallet;
            }
        }
        throw new ArgumentsRequired($this->id . ' getWalletAddress() requires a $wallet address. Set `walletAddress` or `$dydxAccount` in exchange options.');
    }

    public function sign($path, $section = 'public', $method = 'GET', $params = array (), $headers = null, $body = null) {
        $pathWithParams = $this->implode_params($path, $params);
        $url = $this->implode_hostname($this->urls['api'][$section]);
        $params = $this->omit($params, $this->extract_params($path));
        $params = $this->keysort($params);
        $url .= '/' . $pathWithParams;
        if ($method === 'GET') {
            if ($params) {
                $url .= '?' . $this->urlencode($params);
            }
        } else {
            $body = $this->json($params);
            $headers = array(
                'Content-type' => 'application/json',
            );
        }
        return array( 'url' => $url, 'method' => $method, 'body' => $body, 'headers' => $headers );
    }

    public function handle_errors(int $httpCode, string $reason, string $url, string $method, array $headers, string $body, $response, $requestHeaders, $requestBody) {
        if (!$response) {
            return null; // fallback to default error handler
        }
        //
        // abci $response
        // array( "result" => array( "code" => 0 ) )
        //
        // rest $response
        // array( "code" => 123 )
        //
        $result = $this->safe_dict($response, 'result');
        $errorCode = $this->safe_string($result, 'code');
        if (!$errorCode) {
            $errorCode = $this->safe_string($response, 'code');
        }
        if ($errorCode) {
            $errorCodeNum = $this->parse_to_numeric($errorCode);
            if ($errorCodeNum > 0) {
                $feedback = $this->id . ' ' . $this->json($response);
                $this->throw_exactly_matched_exception($this->exceptions['exact'], $errorCode, $feedback);
                $this->throw_broadly_matched_exception($this->exceptions['broad'], $body, $feedback);
                throw new ExchangeError($feedback);
            }
        }
        return null;
    }

    public function set_sandbox_mode(bool $enable) {
        parent::set_sandbox_mode($enable);
        // rewrite testnet parameters
        $this->options['chainName'] = 'dydx-testnet-4';
        $this->options['chainId'] = 11155111;
        $this->options['feeDenom']['CHAINTOKEN_DENOM'] = 'adv4tnt';
    }
}
