<?php

namespace ccxt\async;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

use Exception; // a common import
use \ccxt\ArgumentsRequired;
use \ccxt\BadRequest;
use \ccxt\InvalidOrder;
use \ccxt\Precise;

class kucoinfutures extends kucoin {

    public function describe() {
        return $this->deep_extend(parent::describe (), array(
            'id' => 'kucoinfutures',
            'name' => 'KuCoin Futures',
            'countries' => array( 'SC' ),
            'rateLimit' => 75,
            'version' => 'v1',
            'certified' => false,
            'pro' => false,
            'comment' => 'Platform 2.0',
            'quoteJsonNumbers' => false,
            'has' => array(
                'spot' => false,
                'margin' => false,
                'swap' => true,
                'future' => true,
                'option' => false,
                'cancelAllOrders' => true,
                'cancelOrder' => true,
                'CORS' => null,
                'createDepositAddress' => true,
                'createOrder' => true,
                'fetchAccounts' => true,
                'fetchBalance' => true,
                'fetchBorrowRate' => false,
                'fetchBorrowRates' => false,
                'fetchBorrowRatesPerSymbol' => false,
                'fetchClosedOrders' => true,
                'fetchCurrencies' => false,
                'fetchDepositAddress' => true,
                'fetchDeposits' => true,
                'fetchFundingFee' => true,
                'fetchFundingHistory' => true,
                'fetchFundingRate' => true,
                'fetchFundingRateHistory' => false,
                'fetchIndexOHLCV' => false,
                'fetchL3OrderBook' => true,
                'fetchLedger' => true,
                'fetchMarkets' => true,
                'fetchMarkOHLCV' => false,
                'fetchMyTrades' => true,
                'fetchOHLCV' => true,
                'fetchOpenOrders' => true,
                'fetchOrder' => true,
                'fetchOrderBook' => true,
                'fetchPositions' => true,
                'fetchPremiumIndexOHLCV' => false,
                'fetchStatus' => true,
                'fetchTicker' => true,
                'fetchTickers' => false,
                'fetchTime' => true,
                'fetchTrades' => true,
                'fetchWithdrawals' => true,
                'setMarginMode' => false,
                'transfer' => true,
                'transferOut' => true,
                'withdraw' => null,
                'addMargin' => true,
            ),
            'urls' => array(
                'logo' => 'https://user-images.githubusercontent.com/1294454/147508995-9e35030a-d046-43a1-a006-6fabd981b554.jpg',
                'doc' => array(
                    'https://docs.kucoin.com/futures',
                    'https://docs.kucoin.com',
                ),
                'www' => 'https://futures.kucoin.com/',
                'referral' => 'https://futures.kucoin.com/?rcode=E5wkqe',
                'api' => array(
                    'public' => 'https://openapi-v2.kucoin.com',
                    'private' => 'https://openapi-v2.kucoin.com',
                    'futuresPrivate' => 'https://api-futures.kucoin.com',
                    'futuresPublic' => 'https://api-futures.kucoin.com',
                ),
                'test' => array(
                    'public' => 'https://openapi-sandbox.kucoin.com',
                    'private' => 'https://openapi-sandbox.kucoin.com',
                    'futuresPrivate' => 'https://api-sandbox-futures.kucoin.com',
                    'futuresPublic' => 'https://api-sandbox-futures.kucoin.com',
                ),
            ),
            'requiredCredentials' => array(
                'apiKey' => true,
                'secret' => true,
                'password' => true,
            ),
            'api' => array(
                'futuresPublic' => array(
                    'get' => array(
                        'contracts/active' => 1,
                        'contracts/{symbol}' => 1,
                        'ticker' => 1,
                        'level2/snapshot' => 1.33,
                        'level2/depth{limit}' => 1,
                        'level2/message/query' => 1,
                        'level3/message/query' => 1, // deprecatedï¼Œlevel3/snapshot is suggested
                        'level3/snapshot' => 1, // v2
                        'trade/history' => 1,
                        'interest/query' => 1,
                        'index/query' => 1,
                        'mark-price/{symbol}/current' => 1,
                        'premium/query' => 1,
                        'funding-rate/{symbol}/current' => 1,
                        'timestamp' => 1,
                        'status' => 1,
                        'kline/query' => 1,
                    ),
                    'post' => array(
                        'bullet-public' => 1,
                    ),
                ),
                'futuresPrivate' => array(
                    'get' => array(
                        'account-overview' => 1.33,
                        'transaction-history' => 4.44,
                        'deposit-address' => 1,
                        'deposit-list' => 1,
                        'withdrawals/quotas' => 1,
                        'withdrawal-list' => 1,
                        'transfer-list' => 1,
                        'orders' => 1.33,
                        'stopOrders' => 1,
                        'recentDoneOrders' => 1,
                        'orders/{orderId}' => 1, // ?clientOid={client-order-id} // get order by orderId
                        'orders/byClientOid' => 1, // ?clientOid=eresc138b21023a909e5ad59 // get order by clientOid
                        'fills' => 4.44,
                        'recentFills' => 4.44,
                        'openOrderStatistics' => 1,
                        'position' => 1,
                        'positions' => 4.44,
                        'funding-history' => 4.44,
                    ),
                    'post' => array(
                        'withdrawals' => 1,
                        'transfer-out' => 1, // v2
                        'orders' => 1.33,
                        'position/margin/auto-deposit-status' => 1,
                        'position/margin/deposit-margin' => 1,
                        'bullet-private' => 1,
                    ),
                    'delete' => array(
                        'withdrawals/{withdrawalId}' => 1,
                        'cancel/transfer-out' => 1,
                        'orders/{orderId}' => 1,
                        'orders' => 4.44,
                        'stopOrders' => 1,
                    ),
                ),
            ),
            'precisionMode' => TICK_SIZE,
            'exceptions' => array(
                'exact' => array(
                    '400' => '\\ccxt\\BadRequest', // Bad Request -- Invalid request format
                    '401' => '\\ccxt\\AuthenticationError', // Unauthorized -- Invalid API Key
                    '403' => '\\ccxt\\NotSupported', // Forbidden -- The request is forbidden
                    '404' => '\\ccxt\\NotSupported', // Not Found -- The specified resource could not be found
                    '405' => '\\ccxt\\NotSupported', // Method Not Allowed -- You tried to access the resource with an invalid method.
                    '415' => '\\ccxt\\BadRequest',  // Content-Type -- application/json
                    '429' => '\\ccxt\\RateLimitExceeded', // Too Many Requests -- Access limit breached
                    '500' => '\\ccxt\\ExchangeNotAvailable', // Internal Server Error -- We had a problem with our server. Try again later.
                    '503' => '\\ccxt\\ExchangeNotAvailable', // Service Unavailable -- We're temporarily offline for maintenance. Please try again later.
                    '100001' => '\\ccxt\\InvalidOrder',     // array("code":"100001","msg":"Unavailable to enable both \"postOnly\" and \"hidden\"")
                    '100004' => '\\ccxt\\BadRequest',       // array("code":"100004","msg":"Order is in not cancelable state")
                    '101030' => '\\ccxt\\PermissionDenied', // array("code":"101030","msg":"You haven't yet enabled the margin trading")
                    '200004' => '\\ccxt\\InsufficientFunds',
                    '230003' => '\\ccxt\\InsufficientFunds', // array("code":"230003","msg":"Balance insufficient!")
                    '260100' => '\\ccxt\\InsufficientFunds', // array("code":"260100","msg":"account.noBalance")
                    '300003' => '\\ccxt\\InsufficientFunds',
                    '300012' => '\\ccxt\\InvalidOrder',
                    '400001' => '\\ccxt\\AuthenticationError', // Any of KC-API-KEY, KC-API-SIGN, KC-API-TIMESTAMP, KC-API-PASSPHRASE is missing in your request header.
                    '400002' => '\\ccxt\\InvalidNonce', // KC-API-TIMESTAMP Invalid -- Time differs from server time by more than 5 seconds
                    '400003' => '\\ccxt\\AuthenticationError', // KC-API-KEY not exists
                    '400004' => '\\ccxt\\AuthenticationError', // KC-API-PASSPHRASE error
                    '400005' => '\\ccxt\\AuthenticationError', // Signature error -- Please check your signature
                    '400006' => '\\ccxt\\AuthenticationError', // The IP address is not in the API whitelist
                    '400007' => '\\ccxt\\AuthenticationError', // Access Denied -- Your API key does not have sufficient permissions to access the URI
                    '404000' => '\\ccxt\\NotSupported', // URL Not Found -- The requested resource could not be found
                    '400100' => '\\ccxt\\BadRequest', // Parameter Error -- You tried to access the resource with invalid parameters
                    '411100' => '\\ccxt\\AccountSuspended', // User is frozen -- Please contact us via support center
                    '500000' => '\\ccxt\\ExchangeNotAvailable', // Internal Server Error -- We had a problem with our server. Try again later.
                ),
            ),
            'fees' => array(
                'trading' => array(
                    'tierBased' => true,
                    'percentage' => true,
                    'taker' => $this->parse_number('0.0006'),
                    'maker' => $this->parse_number('0.0002'),
                    'tiers' => array(
                        'taker' => array(
                            array( $this->parse_number('0'), $this->parse_number('0.0006') ),
                            array( $this->parse_number('50'), $this->parse_number('0.0006') ),
                            array( $this->parse_number('200'), $this->parse_number('0.0006') ),
                            array( $this->parse_number('500'), $this->parse_number('0.0005') ),
                            array( $this->parse_number('1000'), $this->parse_number('0.0004') ),
                            array( $this->parse_number('2000'), $this->parse_number('0.0004') ),
                            array( $this->parse_number('4000'), $this->parse_number('0.00038') ),
                            array( $this->parse_number('8000'), $this->parse_number('0.00035') ),
                            array( $this->parse_number('15000'), $this->parse_number('0.00032') ),
                            array( $this->parse_number('25000'), $this->parse_number('0.0003') ),
                            array( $this->parse_number('40000'), $this->parse_number('0.0003') ),
                            array( $this->parse_number('60000'), $this->parse_number('0.0003') ),
                            array( $this->parse_number('80000'), $this->parse_number('0.0003') ),
                        ),
                        'maker' => array(
                            array( $this->parse_number('0'), $this->parse_number('0.02') ),
                            array( $this->parse_number('50'), $this->parse_number('0.015') ),
                            array( $this->parse_number('200'), $this->parse_number('0.01') ),
                            array( $this->parse_number('500'), $this->parse_number('0.01') ),
                            array( $this->parse_number('1000'), $this->parse_number('0.01') ),
                            array( $this->parse_number('2000'), $this->parse_number('0') ),
                            array( $this->parse_number('4000'), $this->parse_number('0') ),
                            array( $this->parse_number('8000'), $this->parse_number('0') ),
                            array( $this->parse_number('15000'), $this->parse_number('-0.003') ),
                            array( $this->parse_number('25000'), $this->parse_number('-0.006') ),
                            array( $this->parse_number('40000'), $this->parse_number('-0.009') ),
                            array( $this->parse_number('60000'), $this->parse_number('-0.012') ),
                            array( $this->parse_number('80000'), $this->parse_number('-0.015') ),
                        ),
                    ),
                ),
                'funding' => array(
                    'tierBased' => false,
                    'percentage' => false,
                    'withdraw' => array(),
                    'deposit' => array(),
                ),
            ),
            'commonCurrencies' => array(
                'HOT' => 'HOTNOW',
                'EDGE' => 'DADI', // https://github.com/ccxt/ccxt/issues/5756
                'WAX' => 'WAXP',
                'TRY' => 'Trias',
                'VAI' => 'VAIOT',
                'XBT' => 'BTC',
            ),
            'timeframes' => array(
                '1m' => 1,
                '3m' => null,
                '5m' => 5,
                '15m' => 15,
                '30m' => 30,
                '1h' => 60,
                '2h' => 120,
                '4h' => 240,
                '6h' => null,
                '8h' => 480,
                '12h' => 720,
                '1d' => 1440,
                '1w' => 10080,
            ),
            'options' => array(
                'version' => 'v1',
                'symbolSeparator' => '-',
                'defaultType' => 'swap',
                'marginTypes' => array(),
                // endpoint versions
                'versions' => array(
                    'futuresPrivate' => array(
                        'POST' => array(
                            'transfer-out' => 'v2',
                        ),
                    ),
                    'futuresPublic' => array(
                        'GET' => array(
                            'level3/snapshot' => 'v2',
                        ),
                    ),
                ),
                'networks' => array(
                    'OMNI' => 'omni',
                    'ERC20' => 'eth',
                    'TRC20' => 'trx',
                ),
            ),
        ));
    }

    public function fetch_accounts($params = array ()) {
        throw new BadRequest($this->id . ' has no method fetchAccounts');
    }

    public function fetch_status($params = array ()) {
        $response = yield $this->futuresPublicGetStatus ($params);
        //
        //     {
        //         "code":"200000",
        //         "data":{
        //             "msg":"",
        //             "status":"open"
        //         }
        //     }
        //
        $data = $this->safe_value($response, 'data', array());
        $status = $this->safe_value($data, 'status');
        if ($status !== null) {
            $status = ($status === 'open') ? 'ok' : 'maintenance';
            $this->status = array_merge($this->status, array(
                'status' => $status,
                'updated' => $this->milliseconds(),
            ));
        }
        return $this->status;
    }

    public function fetch_markets($params = array ()) {
        $response = yield $this->futuresPublicGetContractsActive ($params);
        //
        //    {
        //        "code" => "200000",
        //        "data" => {
        //            "symbol" => "ETHUSDTM",
        //            "rootSymbol" => "USDT",
        //            "type" => "FFWCSX",
        //            "firstOpenDate" => 1591086000000,
        //            "expireDate" => null,
        //            "settleDate" => null,
        //            "baseCurrency" => "ETH",
        //            "quoteCurrency" => "USDT",
        //            "settleCurrency" => "USDT",
        //            "maxOrderQty" => 1000000,
        //            "maxPrice" => 1000000.0000000000,
        //            "lotSize" => 1,
        //            "tickSize" => 0.05,
        //            "indexPriceTickSize" => 0.01,
        //            "multiplier" => 0.01,
        //            "initialMargin" => 0.01,
        //            "maintainMargin" => 0.005,
        //            "maxRiskLimit" => 1000000,
        //            "minRiskLimit" => 1000000,
        //            "riskStep" => 500000,
        //            "makerFeeRate" => 0.00020,
        //            "takerFeeRate" => 0.00060,
        //            "takerFixFee" => 0.0000000000,
        //            "makerFixFee" => 0.0000000000,
        //            "settlementFee" => null,
        //            "isDeleverage" => true,
        //            "isQuanto" => true,
        //            "isInverse" => false,
        //            "markMethod" => "FairPrice",
        //            "fairMethod" => "FundingRate",
        //            "fundingBaseSymbol" => ".ETHINT8H",
        //            "fundingQuoteSymbol" => ".USDTINT8H",
        //            "fundingRateSymbol" => ".ETHUSDTMFPI8H",
        //            "indexSymbol" => ".KETHUSDT",
        //            "settlementSymbol" => "",
        //            "status" => "Open",
        //            "fundingFeeRate" => 0.000535,
        //            "predictedFundingFeeRate" => 0.002197,
        //            "openInterest" => "8724443",
        //            "turnoverOf24h" => 341156641.03354263,
        //            "volumeOf24h" => 74833.54000000,
        //            "markPrice" => 4534.07,
        //            "indexPrice":4531.92,
        //            "lastTradePrice" => 4545.4500000000,
        //            "nextFundingRateTime" => 25481884,
        //            "maxLeverage" => 100,
        //            "sourceExchanges" =>  array(
        //                "huobi",
        //                "Okex",
        //                "Binance",
        //                "Kucoin",
        //                "Poloniex",
        //                "Hitbtc"
        //            ),
        //            "premiumsSymbol1M" => ".ETHUSDTMPI",
        //            "premiumsSymbol8H" => ".ETHUSDTMPI8H",
        //            "fundingBaseSymbol1M" => ".ETHINT",
        //            "fundingQuoteSymbol1M" => ".USDTINT",
        //            "lowPrice" => 4456.90,
        //            "highPrice" =>  4674.25,
        //            "priceChgPct" => 0.0046,
        //            "priceChg" => 21.15
        //        }
        //    }
        //
        $result = array();
        $data = $this->safe_value($response, 'data');
        for ($i = 0; $i < count($data); $i++) {
            $market = $data[$i];
            $id = $this->safe_string($market, 'symbol');
            $expiry = $this->safe_integer($market, 'expireDate');
            $future = $expiry ? true : false;
            $swap = !$future;
            $baseId = $this->safe_string($market, 'baseCurrency');
            $quoteId = $this->safe_string($market, 'quoteCurrency');
            $settleId = $this->safe_string($market, 'settleCurrency');
            $base = $this->safe_currency_code($baseId);
            $quote = $this->safe_currency_code($quoteId);
            $settle = $this->safe_currency_code($settleId);
            $symbol = $base . '/' . $quote . ':' . $settle;
            $type = 'swap';
            if ($future) {
                $symbol = $symbol . '-' . $this->yymmdd($expiry, '');
                $type = 'future';
            }
            $baseMaxSize = $this->safe_number($market, 'baseMaxSize');
            $baseMinSizeString = $this->safe_string($market, 'baseMinSize');
            $quoteMaxSizeString = $this->safe_string($market, 'quoteMaxSize');
            $baseMinSize = $this->parse_number($baseMinSizeString);
            $quoteMaxSize = $this->parse_number($quoteMaxSizeString);
            $quoteMinSize = $this->safe_number($market, 'quoteMinSize');
            $inverse = $this->safe_value($market, 'isInverse');
            $status = $this->safe_string($market, 'status');
            $active = $status === 'Open';
            $result[] = array(
                'id' => $id,
                'symbol' => $symbol,
                'baseId' => $baseId,
                'quoteId' => $quoteId,
                'settleId' => $settleId,
                'base' => $base,
                'quote' => $quote,
                'settle' => $settle,
                'type' => $type,
                'spot' => false,
                'margin' => false,
                'swap' => $swap,
                'future' => $future,
                'option' => false,
                'active' => $active,
                'contract' => true,
                'linear' => !$inverse,
                'inverse' => $inverse,
                'taker' => $this->safe_number($market, 'takerFeeRate'),
                'maker' => $this->safe_number($market, 'makerFeeRate'),
                'contractSize' => $this->parse_number(Precise::string_abs($this->safe_string($market, 'multiplier'))),
                'expiry' => $expiry,
                'expiryDatetime' => $this->iso8601($expiry),
                'precision' => array(
                    'amount' => $this->safe_number($market, 'lotSize'),
                    'price' => $this->safe_number($market, 'tickSize'),
                ),
                'limits' => array(
                    'leverage' => array(
                        'min' => null,
                        'max' => $this->safe_number($market, 'maxLeverage'),
                    ),
                    'amount' => array(
                        'min' => $baseMinSize,
                        'max' => $baseMaxSize,
                    ),
                    'price' => array(
                        'min' => null,
                        'max' => $this->parse_number(Precise::string_div($quoteMaxSizeString, $baseMinSizeString)),
                    ),
                    'cost' => array(
                        'min' => $quoteMinSize,
                        'max' => $quoteMaxSize,
                    ),
                ),
                'info' => $market,
            );
        }
        return $result;
    }

    public function fetch_time($params = array ()) {
        $response = yield $this->futuresPublicGetTimestamp ($params);
        //
        //    {
        //        code => "200000",
        //        data => 1637385119302,
        //    }
        //
        return $this->safe_number($response, 'data');
    }

    public function fetch_ohlcv($symbol, $timeframe = '15m', $since = null, $limit = null, $params = array ()) {
        yield $this->load_markets();
        $market = $this->market($symbol);
        $marketId = $market['id'];
        $request = array(
            'symbol' => $marketId,
            'granularity' => $this->timeframes[$timeframe],
        );
        $duration = $this->parse_timeframe($timeframe) * 1000;
        $endAt = $this->milliseconds();
        if ($since !== null) {
            $request['from'] = $since;
            if ($limit === null) {
                $limit = $this->safe_integer($this->options, 'fetchOHLCVLimit', 200);
            }
            $endAt = $this->sum($since, $limit * $duration);
        } else if ($limit !== null) {
            $since = $endAt - $limit * $duration;
            $request['from'] = $since;
        }
        $request['to'] = $endAt;
        $response = yield $this->futuresPublicGetKlineQuery (array_merge($request, $params));
        //
        //    {
        //        "code" => "200000",
        //        "data" => [
        //            [1636459200000, 4779.3, 4792.1, 4768.7, 4770.3, 78051],
        //            [1636460100000, 4770.25, 4778.55, 4757.55, 4777.25, 80164],
        //            [1636461000000, 4777.25, 4791.45, 4774.5, 4791.3, 51555]
        //        ]
        //    }
        //
        $data = $this->safe_value($response, 'data', array());
        return $this->parse_ohlcvs($data, $market, $timeframe, $since, $limit);
    }

    public function parse_ohlcv($ohlcv, $market = null) {
        //
        //    array(
        //        "1545904980000",          // Start time of the candle cycle
        //        "0.058",                  // opening price
        //        "0.049",                  // closing price
        //        "0.058",                  // highest price
        //        "0.049",                  // lowest price
        //        "0.018",                  // base volume
        //        "0.000945",               // quote volume
        //    )
        //
        return array(
            $this->safe_integer($ohlcv, 0),
            $this->safe_number($ohlcv, 1),
            $this->safe_number($ohlcv, 2),
            $this->safe_number($ohlcv, 3),
            $this->safe_number($ohlcv, 4),
            $this->safe_number($ohlcv, 5),
        );
    }

    public function create_deposit_address($code, $params = array ()) {
        throw new BadRequest($this->id . ' has no method createDepositAddress');
    }

    public function fetch_deposit_address($code, $params = array ()) {
        yield $this->load_markets();
        $currency = $this->currency($code);
        $currencyId = $currency['id'];
        $request = array(
            'currency' => $currencyId, // Currency,including XBT,USDT
        );
        $response = yield $this->futuresPrivateGetDepositAddress (array_merge($request, $params));
        //
        //    {
        //        "code" => "200000",
        //        "data" => {
        //            "address" => "0x78d3ad1c0aa1bf068e19c94a2d7b16c9c0fcd8b1",//Deposit $address
        //            "memo" => null//Address tag. If the returned value is null, it means that the requested token has no memo. If you are to transfer funds from another platform to KuCoin Futures and if the token to be //transferred has memo(tag), you need to fill in the memo to ensure the transferred funds will be sent //to the $address you specified.
        //        }
        //    }
        //
        $data = $this->safe_value($response, 'data', array());
        $address = $this->safe_string($data, 'address');
        if ($currencyId !== 'NIM') {
            // contains spaces
            $this->check_address($address);
        }
        return array(
            'info' => $response,
            'currency' => $currencyId,
            'address' => $address,
            'tag' => $this->safe_string($data, 'memo'),
            'network' => $this->safe_string($data, 'chain'),
        );
    }

    public function fetch_order_book($symbol, $limit = null, $params = array ()) {
        yield $this->load_markets();
        $level = $this->safe_number($params, 'level');
        if ($level !== 2 && $level !== null) {
            throw new BadRequest($this->id . ' fetchOrderBook can only return $level 2');
        }
        $market = $this->market($symbol);
        $request = array(
            'symbol' => $market['id'],
        );
        if ($limit !== null) {
            if (($limit === 20) || ($limit === 100)) {
                $request['limit'] = $limit;
            } else {
                throw new BadRequest($this->id . ' fetchOrderBook $limit argument must be 20 or 100');
            }
        } else {
            $request['limit'] = 20;
        }
        $response = yield $this->futuresPublicGetLevel2DepthLimit (array_merge($request, $params));
        //
        //     {
        //         "code" => "200000",
        //         "data" => {
        //           "symbol" => "XBTUSDM",      //Symbol
        //           "sequence" => 100,          //Ticker sequence number
        //           "asks" => [
        //                 ["5000.0", 1000],   //Price, quantity
        //                 ["6000.0", 1983]    //Price, quantity
        //           ],
        //           "bids" => [
        //                 ["3200.0", 800],    //Price, quantity
        //                 ["3100.0", 100]     //Price, quantity
        //           ],
        //           "ts" => 1604643655040584408  // $timestamp
        //         }
        //     }
        //
        $data = $this->safe_value($response, 'data', array());
        $timestamp = intval($this->safe_integer($data, 'ts') / 1000000);
        $orderbook = $this->parse_order_book($data, $symbol, $timestamp, 'bids', 'asks', 0, 1);
        $orderbook['nonce'] = $this->safe_integer($data, 'sequence');
        return $orderbook;
    }

    public function fetch_l3_order_book($symbol, $limit = null, $params = array ()) {
        throw new BadRequest($this->id . ' only can only fetch the L2 order book');
    }

    public function fetch_ticker($symbol, $params = array ()) {
        yield $this->load_markets();
        $market = $this->market($symbol);
        $request = array(
            'symbol' => $market['id'],
        );
        $response = yield $this->futuresPublicGetTicker (array_merge($request, $params));
        //
        //    {
        //        "code" => "200000",
        //        "data" => {
        //            "sequence" => 1638444978558,
        //            "symbol" => "ETHUSDTM",
        //            "side" => "sell",
        //            "size" => 4,
        //            "price" => "4229.35",
        //            "bestBidSize" => 2160,
        //            "bestBidPrice" => "4229.0",
        //            "bestAskPrice" => "4229.05",
        //            "tradeId" => "61aaa8b777a0c43055fe4851",
        //            "ts" => 1638574296209786785,
        //            "bestAskSize" => 36,
        //        }
        //    }
        //
        return $this->parse_ticker($response['data'], $market);
    }

    public function parse_ticker($ticker, $market = null) {
        //
        //     {
        //         "code" => "200000",
        //         "data" => {
        //             "sequence" =>  1629930362547,
        //             "symbol" => "ETHUSDTM",
        //             "side" => "buy",
        //             "size" =>  130,
        //             "price" => "4724.7",
        //             "bestBidSize" =>  5,
        //             "bestBidPrice" => "4724.6",
        //             "bestAskPrice" => "4724.65",
        //             "tradeId" => "618d2a5a77a0c4431d2335f4",
        //             "ts" =>  1636641371963227600,
        //             "bestAskSize" =>  1789
        //          }
        //     }
        //
        $last = $this->safe_number($ticker, 'price');
        $marketId = $this->safe_string($ticker, 'symbol');
        $market = $this->safe_market($marketId, $market, '-');
        $timestamp = Precise::string_div($this->safe_string($ticker, 'ts'), '1000000');
        return $this->safe_ticker(array(
            'symbol' => $market['symbol'],
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'high' => null,
            'low' => null,
            'bid' => $this->safe_number($ticker, 'bestBidPrice'),
            'bidVolume' => $this->safe_number($ticker, 'bestBidSize'),
            'ask' => $this->safe_number($ticker, 'bestAskPrice'),
            'askVolume' => $this->safe_number($ticker, 'bestAskSize'),
            'vwap' => null,
            'open' => null,
            'close' => $last,
            'last' => $last,
            'previousClose' => null,
            'change' => null,
            'percentage' => null,
            'average' => null,
            'baseVolume' => null,
            'quoteVolume' => null,
            'info' => $ticker,
        ), $market);
    }

    public function fetch_funding_history($symbol = null, $since = null, $limit = null, $params = array ()) {
        //
        // Private
        // @param $symbol (string) => The pair for which the contract was traded
        // @param $since (number) => The unix start time of the first funding payment requested
        // @param $limit (number) => The number of results to return
        // @param $params (dict) => Additional parameters to send to the API
        // @param return => Data for the history of the accounts funding payments for futures contracts
        //
        if ($symbol === null) {
            throw new ArgumentsRequired($this->id . ' fetchFundingHistory() requires a $symbol argument');
        }
        yield $this->load_markets();
        $market = $this->market($symbol);
        $request = array(
            'symbol' => $market['id'],
        );
        if ($since !== null) {
            $request['startAt'] = $since;
        }
        if ($limit !== null) {
            // * Since is ignored if $limit is defined
            $request['maxCount'] = $limit;
        }
        $response = yield $this->futuresPrivateGetFundingHistory (array_merge($request, $params));
        //
        //    {
        //        "code" => "200000",
        //        "data" => {
        //            "dataList" => array(
        //                array(
        //                    "id" => 239471298749817,
        //                    "symbol" => "ETHUSDTM",
        //                    "timePoint" => 1638532800000,
        //                    "fundingRate" => 0.000100,
        //                    "markPrice" => 4612.8300000000,
        //                    "positionQty" => 12,
        //                    "positionCost" => 553.5396000000,
        //                    "funding" => -0.0553539600,
        //                    "settleCurrency" => "USDT"
        //                ),
        //                ...
        //            ),
        //            "hasMore" => true
        //        }
        //    }
        //
        $data = $this->safe_value($response, 'data');
        $dataList = $this->safe_value($data, 'dataList');
        $fees = array();
        for ($i = 0; $i < count($dataList); $i++) {
            $listItem = $dataList[$i];
            $timestamp = $this->safe_integer($listItem, 'timePoint');
            $fees[] = array(
                'info' => $listItem,
                'symbol' => $symbol,
                'code' => $this->safe_currency_code($this->safe_string($listItem, 'settleCurrency')),
                'timestamp' => $timestamp,
                'datetime' => $this->iso8601($timestamp),
                'id' => $this->safe_number($listItem, 'id'),
                'amount' => $this->safe_number($listItem, 'funding'),
                'fundingRate' => $this->safe_number($listItem, 'fundingRate'),
                'markPrice' => $this->safe_number($listItem, 'markPrice'),
                'positionQty' => $this->safe_number($listItem, 'positionQty'),
                'positionCost' => $this->safe_number($listItem, 'positionCost'),
            );
        }
        return $fees;
    }

    public function fetch_positions($symbols = null, $params = array ()) {
        yield $this->load_markets();
        $response = yield $this->futuresPrivateGetPositions ($params);
        //
        //    {
        //        "code" => "200000",
        //        "data" => array(
        //            {
        //                "id" => "615ba79f83a3410001cde321",
        //                "symbol" => "ETHUSDTM",
        //                "autoDeposit" => false,
        //                "maintMarginReq" => 0.005,
        //                "riskLimit" => 1000000,
        //                "realLeverage" => 18.61,
        //                "crossMode" => false,
        //                "delevPercentage" => 0.86,
        //                "openingTimestamp" => 1638563515618,
        //                "currentTimestamp" => 1638576872774,
        //                "currentQty" => 2,
        //                "currentCost" => 83.64200000,
        //                "currentComm" => 0.05018520,
        //                "unrealisedCost" => 83.64200000,
        //                "realisedGrossCost" => 0.00000000,
        //                "realisedCost" => 0.05018520,
        //                "isOpen" => true,
        //                "markPrice" => 4225.01,
        //                "markValue" => 84.50020000,
        //                "posCost" => 83.64200000,
        //                "posCross" => 0.0000000000,
        //                "posInit" => 3.63660870,
        //                "posComm" => 0.05236717,
        //                "posLoss" => 0.00000000,
        //                "posMargin" => 3.68897586,
        //                "posMaint" => 0.50637594,
        //                "maintMargin" => 4.54717586,
        //                "realisedGrossPnl" => 0.00000000,
        //                "realisedPnl" => -0.05018520,
        //                "unrealisedPnl" => 0.85820000,
        //                "unrealisedPnlPcnt" => 0.0103,
        //                "unrealisedRoePcnt" => 0.2360,
        //                "avgEntryPrice" => 4182.10,
        //                "liquidationPrice" => 4023.00,
        //                "bankruptPrice" => 4000.25,
        //                "settleCurrency" => "USDT",
        //                "isInverse" => false
        //            }
        //        )
        //    }
        //
        return $this->parse_positions($this->safe_value($response, 'data'));
    }

    public function parse_positions($positions) {
        $result = array();
        for ($i = 0; $i < count($positions); $i++) {
            $result[] = $this->parse_position($positions[$i]);
        }
        return $result;
    }

    public function parse_position($position, $market = null) {
        //
        //    {
        //        "code" => "200000",
        //        "data" => array(
        //            {
        //                "id" => "615ba79f83a3410001cde321",         // Position ID
        //                "symbol" => "ETHUSDTM",                     // Symbol
        //                "autoDeposit" => false,                     // Auto deposit margin or not
        //                "maintMarginReq" => 0.005,                  // Maintenance margin requirement
        //                "riskLimit" => 1000000,                     // Risk limit
        //                "realLeverage" => 25.92,                    // Leverage of the order
        //                "crossMode" => false,                       // Cross mode or not
        //                "delevPercentage" => 0.76,                  // ADL ranking percentile
        //                "openingTimestamp" => 1638578546031,        // Open time
        //                "currentTimestamp" => 1638578563580,        // Current $timestamp
        //                "currentQty" => 2,                          // Current postion quantity
        //                "currentCost" => 83.787,                    // Current postion value
        //                "currentComm" => 0.0167574,                 // Current commission
        //                "unrealisedCost" => 83.787,                 // Unrealised value
        //                "realisedGrossCost" => 0.0,                 // Accumulated realised gross profit value
        //                "realisedCost" => 0.0167574,                // Current realised $position value
        //                "isOpen" => true,                           // Opened $position or not
        //                "markPrice" => 4183.38,                     // Mark price
        //                "markValue" => 83.6676,                     // Mark value
        //                "posCost" => 83.787,                        // Position value
        //                "posCross" => 0.0,                          // added margin
        //                "posInit" => 3.35148,                       // Leverage margin
        //                "posComm" => 0.05228309,                    // Bankruptcy cost
        //                "posLoss" => 0.0,                           // Funding fees paid out
        //                "posMargin" => 3.40376309,                  // Position margin
        //                "posMaint" => 0.50707892,                   // Maintenance margin
        //                "maintMargin" => 3.28436309,                // Position margin
        //                "realisedGrossPnl" => 0.0,                  // Accumulated realised gross profit value
        //                "realisedPnl" => -0.0167574,                // Realised profit and loss
        //                "unrealisedPnl" => -0.1194,                 // Unrealised profit and loss
        //                "unrealisedPnlPcnt" => -0.0014,             // Profit-loss ratio of the $position
        //                "unrealisedRoePcnt" => -0.0356,             // Rate of return on investment
        //                "avgEntryPrice" => 4189.35,                 // Average entry price
        //                "liquidationPrice" => 4044.55,              // Liquidation price
        //                "bankruptPrice" => 4021.75,                 // Bankruptcy price
        //                "settleCurrency" => "USDT",                 // Currency used to clear and settle the trades
        //                "isInverse" => false
        //            }
        //        )
        //    }
        //
        $symbol = $this->safe_string($position, 'symbol');
        $market = $this->safe_market($symbol, $market);
        $timestamp = $this->safe_number($position, 'currentTimestamp');
        $size = $this->safe_string($position, 'currentQty');
        $side = null;
        if (Precise::string_gt($size, '0')) {
            $side = 'buy';
        } else if (Precise::string_lt($size, '0')) {
            $side = 'sell';
        }
        $notional = Precise::string_abs($this->safe_string($position, 'posCost'));
        $initialMargin = $this->safe_string($position, 'posInit');
        $initialMarginPercentage = Precise::string_div($initialMargin, $notional);
        // $marginRatio = Precise::string_div(maintenanceRate, collateral);
        $unrealisedPnl = $this->safe_string($position, 'unrealisedPnl');
        $crossMode = $this->safe_value($position, 'crossMode');
        // currently $crossMode is always set to false and only isolated positions are supported
        $marginType = $crossMode ? 'cross' : 'isolated';
        return array(
            'info' => $position,
            'symbol' => $this->safe_string($market, 'symbol'),
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'initialMargin' => $this->parse_number($initialMargin),
            'initialMarginPercentage' => $this->parse_number($initialMarginPercentage),
            'maintenanceMargin' => $this->safe_number($position, 'posMaint'),
            'maintenanceMarginPercentage' => $this->safe_number($position, 'maintMarginReq'),
            'entryPrice' => $this->safe_number($position, 'avgEntryPrice'),
            'notional' => $this->parse_number($notional),
            'leverage' => $this->safe_number($position, 'realLeverage'),
            'unrealizedPnl' => $this->parse_number($unrealisedPnl),
            'contracts' => $this->parse_number(Precise::string_abs($size)),
            'contractSize' => $this->safe_value($market, 'contractSize'),
            //     realisedPnl => $position['realised_pnl'],
            'marginRatio' => null,
            'liquidationPrice' => $this->safe_number($position, 'liquidationPrice'),
            'markPrice' => $this->safe_number($position, 'markPrice'),
            'collateral' => $this->safe_number($position, 'maintMargin'),
            'marginType' => $marginType,
            'side' => $side,
            'percentage' => $this->parse_number(Precise::string_div($unrealisedPnl, $initialMargin)),
        );
    }

    public function create_order($symbol, $type, $side, $amount, $price = null, $params = array ()) {
        yield $this->load_markets();
        $market = $this->market($symbol);
        // required param, cannot be used twice
        $clientOrderId = $this->safe_string_2($params, 'clientOid', 'clientOrderId', $this->uuid());
        $params = $this->omit($params, array( 'clientOid', 'clientOrderId' ));
        if ($amount < 1) {
            throw new InvalidOrder($this->id . ' createOrder() minimum contract order $amount is 1');
        }
        $preciseAmount = intval($this->amount_to_precision($symbol, $amount));
        $request = array(
            'clientOid' => $clientOrderId,
            'side' => $side,
            'symbol' => $market['id'],
            'type' => $type, // limit or $market
            'size' => $preciseAmount,
            'leverage' => 1,
            // 'remark' => '', // optional remark for the order, length cannot exceed 100 utf8 characters
            // 'tradeType' => 'TRADE', // TRADE, MARGIN_TRADE // not used with margin orders
            // limit orders ---------------------------------------------------
            // 'timeInForce' => 'GTC', // GTC, GTT, IOC, or FOK (default is GTC), limit orders only
            // 'cancelAfter' => long, // cancel after n seconds, requires $timeInForce to be GTT
            // 'postOnly' => false, // Post only flag, invalid when $timeInForce is IOC or FOK
            // 'hidden' => false, // Order will not be displayed in the order book
            // 'iceberg' => false, // Only a portion of the order is displayed in the order book
            // 'visibleSize' => $this->amount_to_precision($symbol, $visibleSize), // The maximum visible size of an $iceberg order
            // $market orders --------------------------------------------------
            // 'funds' => $this->cost_to_precision($symbol, cost), // Amount of quote currency to use
            // stop orders ----------------------------------------------------
            // 'stop' => 'loss', // loss or entry, the default is loss, requires $stopPrice
            // 'stopPrice' => $this->price_to_precision($symbol, $amount), // need to be defined if stop is specified
            // 'stopPriceType' // Either TP, IP or MP, Need to be defined if stop is specified.
            // margin orders --------------------------------------------------
            // 'marginMode' => 'cross', // cross (cross mode) and isolated (isolated mode), set to cross by default, the isolated mode will be released soon, stay tuned
            // 'autoBorrow' => false, // The system will first borrow you funds at the optimal interest rate and then place an order for you
            // futures orders -------------------------------------------------
            // reduceOnly // (boolean) A mark to reduce the position size only. Set to false by default. Need to set the position size when reduceOnly is true.
            // closeOrder // (boolean) A mark to close the position. Set to false by default. It will close all the positions when closeOrder is true.
            // forceHold // (boolean) A mark to forcely hold the funds for an order, even though it's an order to reduce the position size. This helps the order stay on the order book and not get canceled when the position size changes. Set to false by default.
        );
        $stopPrice = $this->safe_number($params, 'stopPrice');
        if ($stopPrice) {
            $request['stop'] = ($side === 'buy') ? 'down' : 'up';
            $stopPriceType = $this->safe_string($params, 'stopPriceType');
            if (!$stopPriceType) {
                throw new ArgumentsRequired($this->id . ' createOrder() trigger orders require a $stopPriceType parameter to be set to TP, IP or MP (Trade Price, Index Price or Mark Price)');
            }
        }
        $uppercaseType = strtoupper($type);
        $timeInForce = $this->safe_string($params, 'timeInForce');
        if ($uppercaseType === 'LIMIT') {
            if ($price === null) {
                throw new ArgumentsRequired($this->id . ' createOrder() requires a $price argument for limit orders');
            } else {
                $request['price'] = $this->price_to_precision($symbol, $price);
            }
            if ($timeInForce !== null) {
                $timeInForce = strtoupper($timeInForce);
                $request['timeInForce'] = $timeInForce;
            }
        }
        $postOnly = $this->safe_value($params, 'postOnly', false);
        $hidden = $this->safe_value($params, 'hidden');
        if ($postOnly && $hidden !== null) {
            throw new BadRequest($this->id . ' createOrder() does not support the $postOnly parameter together with a $hidden parameter');
        }
        $iceberg = $this->safe_value($params, 'iceberg');
        if ($iceberg) {
            $visibleSize = $this->safe_value($params, 'visibleSize');
            if ($visibleSize === null) {
                throw new ArgumentsRequired($this->id . ' createOrder() requires a $visibleSize parameter for $iceberg orders');
            }
        }
        $params = $this->omit($params, 'timeInForce'); // Time in force only valid for limit orders, exchange error when gtc for $market orders
        $response = yield $this->futuresPrivatePostOrders (array_merge($request, $params));
        //
        //    {
        //        code => "200000",
        //        $data => array(
        //            orderId => "619717484f1d010001510cde",
        //        ),
        //    }
        //
        $data = $this->safe_value($response, 'data', array());
        return array(
            'id' => $this->safe_string($data, 'orderId'),
            'clientOrderId' => null,
            'timestamp' => null,
            'datetime' => null,
            'lastTradeTimestamp' => null,
            'symbol' => null,
            'type' => null,
            'side' => null,
            'price' => null,
            'amount' => null,
            'cost' => null,
            'average' => null,
            'filled' => null,
            'remaining' => null,
            'status' => null,
            'fee' => null,
            'trades' => null,
            'timeInForce' => null,
            'postOnly' => null,
            'stopPrice' => null,
            'info' => $response,
        );
    }

    public function cancel_order($id, $symbol = null, $params = array ()) {
        yield $this->load_markets();
        $request = array(
            'orderId' => $id,
        );
        $response = yield $this->futuresPrivateDeleteOrdersOrderId (array_merge($request, $params));
        //
        //   {
        //       code => "200000",
        //       data => array(
        //           cancelledOrderIds => array(
        //                "619714b8b6353000014c505a",
        //           ),
        //       ),
        //   }
        //
        return $this->safe_value($response, 'data');
    }

    public function cancel_all_orders($symbol = null, $params = array ()) {
        yield $this->load_markets();
        $request = array();
        if ($symbol !== null) {
            $request['symbol'] = $this->market_id($symbol);
        }
        $response = yield $this->futuresPrivateDeleteOrders (array_merge($request, $params));
        // ? futuresPrivateDeleteStopOrders
        //   {
        //       code => "200000",
        //       data => array(
        //           cancelledOrderIds => array(
        //                "619714b8b6353000014c505a",
        //           ),
        //       ),
        //   }
        //
        return $this->safe_value($response, 'data');
    }

    public function add_margin($symbol, $amount, $params = array ()) {
        yield $this->load_markets();
        $market = $this->market($symbol);
        $uuid = $this->uuid();
        $request = array(
            'symbol' => $market['id'],
            'margin' => $amount,
            'bizNo' => $uuid,
        );
        return yield $this->futuresPrivatePostPositionMarginDepositMargin (array_merge($request, $params));
    }

    public function fetch_orders_by_status($status, $symbol = null, $since = null, $limit = null, $params = array ()) {
        yield $this->load_markets();
        $request = array(
            'status' => $status,
        );
        $market = null;
        if ($symbol !== null) {
            $market = $this->market($symbol);
            $request['symbol'] = $market['id'];
        }
        if ($since !== null) {
            $request['startAt'] = $since;
        }
        $response = yield $this->futuresPrivateGetOrders (array_merge($request, $params));
        $responseData = $this->safe_value($response, 'data', array());
        $orders = $this->safe_value($responseData, 'items', array());
        return $this->parse_orders($orders, $market, $since, $limit);
    }

    public function fetch_order($id = null, $symbol = null, $params = array ()) {
        yield $this->load_markets();
        $request = array();
        $method = 'futuresPrivateGetOrdersOrderId';
        if ($id === null) {
            $clientOrderId = $this->safe_string_2($params, 'clientOid', 'clientOrderId');
            if ($clientOrderId === null) {
                throw new InvalidOrder($this->id . ' fetchOrder() requires parameter $id or $params->clientOid');
            }
            $request['clientOid'] = $clientOrderId;
            $method = 'futuresPrivateGetOrdersByClientOid';
            $params = $this->omit($params, array( 'clientOid', 'clientOrderId' ));
        } else {
            $request['orderId'] = $id;
        }
        $response = yield $this->$method (array_merge($request, $params));
        $market = ($symbol !== null) ? $this->market($symbol) : null;
        $responseData = $this->safe_value($response, 'data');
        return $this->parse_order($responseData, $market);
    }

    public function parse_order($order, $market = null) {
        $marketId = $this->safe_string($order, 'symbol');
        $market = $this->safe_market($marketId, $market);
        $symbol = $market['symbol'];
        $orderId = $this->safe_string($order, 'id');
        $type = $this->safe_string($order, 'type');
        $timestamp = $this->safe_integer($order, 'createdAt');
        $datetime = $this->iso8601($timestamp);
        $price = $this->safe_string($order, 'price');
        // $price is zero for $market $order
        // omitZero is called in safeOrder2
        $side = $this->safe_string($order, 'side');
        $feeCurrencyId = $this->safe_string($order, 'feeCurrency');
        $feeCurrency = $this->safe_currency_code($feeCurrencyId);
        $feeCost = $this->safe_number($order, 'fee');
        $amount = $this->safe_string($order, 'size');
        $filled = $this->safe_string($order, 'dealSize');
        $rawCost = $this->safe_string_2($order, 'dealFunds', 'filledValue');
        $leverage = $this->safe_string($order, 'leverage');
        $cost = Precise::string_div($rawCost, $leverage);
        $average = null;
        if (Precise::string_gt($filled, '0')) {
            if ($market['linear']) {
                $average = Precise::string_div($rawCost, Precise::string_mul($market['contractSize'], $filled));
            } else {
                $average = Precise::string_div(Precise::string_mul($market['contractSize'], $filled), $rawCost);
            }
        }
        // precision reported by their api is 8 d.p.
        // $average = Precise::string_div($rawCost, Precise::string_mul($filled, $market['contractSize']));
        // bool
        $isActive = $this->safe_value($order, 'isActive', false);
        $cancelExist = $this->safe_value($order, 'cancelExist', false);
        $status = $isActive ? 'open' : 'closed';
        $status = $cancelExist ? 'canceled' : $status;
        $fee = array(
            'currency' => $feeCurrency,
            'cost' => $feeCost,
        );
        $clientOrderId = $this->safe_string($order, 'clientOid');
        $timeInForce = $this->safe_string($order, 'timeInForce');
        $stopPrice = $this->safe_number($order, 'stopPrice');
        $postOnly = $this->safe_value($order, 'postOnly');
        return $this->safe_order(array(
            'id' => $orderId,
            'clientOrderId' => $clientOrderId,
            'symbol' => $symbol,
            'type' => $type,
            'timeInForce' => $timeInForce,
            'postOnly' => $postOnly,
            'side' => $side,
            'amount' => $amount,
            'price' => $price,
            'stopPrice' => $stopPrice,
            'cost' => $cost,
            'filled' => $filled,
            'remaining' => null,
            'timestamp' => $timestamp,
            'datetime' => $datetime,
            'fee' => $fee,
            'status' => $status,
            'info' => $order,
            'lastTradeTimestamp' => null,
            'average' => $average,
            'trades' => null,
        ), $market);
    }

    public function fetch_funding_rate($symbol, $params = array ()) {
        yield $this->load_markets();
        $request = array(
            'symbol' => $this->market_id($symbol),
        );
        $response = yield $this->futuresPublicGetFundingRateSymbolCurrent (array_merge($request, $params));
        //
        //    {
        //        code => "200000",
        //        $data => array(
        //            $symbol => ".ETHUSDTMFPI8H",
        //            granularity => 28800000,
        //            timePoint => 1637380800000,
        //            value => 0.0001,
        //            predictedValue => 0.0001,
        //        ),
        //    }
        //
        $data = $this->safe_value($response, 'data');
        $timestamp = $this->safe_number($data, 'timePoint');
        return array(
            'info' => $data,
            'symbol' => $symbol,
            'markPrice' => null,
            'indexPrice' => null,
            'interestRate' => null,
            'estimatedSettlePrice' => null,
            'timestamp' => null,
            'datetime' => null,
            'previousFundingRate' => $this->safe_number($data, 'value'),
            'nextFundingRate' => $this->safe_number($data, 'predictedValue'),
            'previousFundingTimestamp' => $timestamp,
            'nextFundingTimestamp' => null,
            'previousFundingDatetime' => $this->iso8601($timestamp),
            'nextFundingDatetime' => null,
        );
    }

    public function parse_balance($response) {
        $result = array(
            'info' => $response,
            'timestamp' => null,
            'datetime' => null,
        );
        $data = $this->safe_value($response, 'data');
        $currencyId = $this->safe_string($data, 'currency');
        $code = $this->safe_currency_code($currencyId);
        $account = $this->account();
        $account['free'] = $this->safe_string($data, 'availableBalance');
        $account['total'] = $this->safe_string($data, 'accountEquity');
        $result[$code] = $account;
        return $this->safe_balance($result);
    }

    public function fetch_balance($params = array ()) {
        yield $this->load_markets();
        // only fetches one balance at a time
        // by default it will only fetch the BTC balance of the futures account
        // you can send 'currency' in $params to fetch other currencies
        // fetchBalance (array( 'type' => 'futures', 'currency' => 'USDT' ))
        $response = yield $this->futuresPrivateGetAccountOverview ($params);
        //
        //     {
        //         code => '200000',
        //         data => {
        //             accountEquity => 0.00005,
        //             unrealisedPNL => 0,
        //             marginBalance => 0.00005,
        //             positionMargin => 0,
        //             orderMargin => 0,
        //             frozenFunds => 0,
        //             availableBalance => 0.00005,
        //             currency => 'XBT'
        //         }
        //     }
        //
        return $this->parse_balance($response);
    }

    public function transfer($code, $amount, $fromAccount, $toAccount, $params = array ()) {
        if (($toAccount !== 'spot' && $toAccount !== 'trade' && $toAccount !== 'trading') || ($fromAccount !== 'futures' && $fromAccount !== 'contract')) {
            throw new BadRequest($this->id . ' only supports transfers from contract(futures) account to trade(spot) account');
        }
        return $this->transfer_out($code, $amount, $params);
    }

    public function transfer_out($code, $amount, $params = array ()) {
        yield $this->load_markets();
        $currency = $this->currency($code);
        $request = array(
            'currency' => $this->safe_string($currency, 'id'), // Currency,including XBT,USDT
            'amount' => $amount,
        );
        // transfer from usdm futures wallet to spot wallet
        $response = yield $this->futuresPrivatePostTransferOut (array_merge($request, $params));
        //
        //    {
        //        "code" => "200000",
        //        "data" => {
        //            "applyId" => "5bffb63303aa675e8bbe18f9" // Transfer-out $request ID
        //        }
        //    }
        //
        $data = $this->safe_value($response, 'data');
        $timestamp = $this->safe_string($data, 'updatedAt');
        return array(
            'info' => $response,
            'id' => $this->safe_string($data, 'applyId'),
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'currency' => $code,
            'amount' => $amount,
            'fromAccount' => 'futures',
            'toAccount' => 'spot',
            'status' => $this->safe_string($data, 'status'),
        );
    }

    public function fetch_my_trades($symbol = null, $since = null, $limit = null, $params = array ()) {
        yield $this->load_markets();
        $request = array(
            // orderId (String) [optional] Fills for a specific order (other parameters can be ignored if specified)
            // $symbol (String) [optional] Symbol of the contract
            // side (String) [optional] buy or sell
            // type (String) [optional] $limit, $market, limit_stop or market_stop
            // startAt (long) [optional] Start time (milisecond)
            // endAt (long) [optional] End time (milisecond)
        );
        $market = null;
        if ($symbol !== null) {
            $market = $this->market($symbol);
            $request['symbol'] = $market['id'];
        }
        if ($since !== null) {
            $request['startAt'] = $since;
        }
        $response = yield $this->futuresPrivateGetFills (array_merge($request, $params));
        //
        //    {
        //        "code" => "200000",
        //        "data" => {
        //          "currentPage" => 1,
        //          "pageSize" => 1,
        //          "totalNum" => 251915,
        //          "totalPage" => 251915,
        //          "items" => array(
        //              {
        //                  "symbol" => "XBTUSDM",  // Ticker $symbol of the contract
        //                  "tradeId" => "5ce24c1f0c19fc3c58edc47c",  // Trade ID
        //                  "orderId" => "5ce24c16b210233c36ee321d",  // Order ID
        //                  "side" => "sell",  // Transaction side
        //                  "liquidity" => "taker",  // Liquidity- taker or maker
        //                  "price" => "8302",  // Filled price
        //                  "size" => 10,  // Filled amount
        //                  "value" => "0.001204529",  // Order value
        //                  "feeRate" => "0.0005",  // Floating fees
        //                  "fixFee" => "0.00000006",  // Fixed fees
        //                  "feeCurrency" => "XBT",  // Charging currency
        //                  "stop" => "",  // A mark to the stop order type
        //                  "fee" => "0.0000012022",  // Transaction fee
        //                  "orderType" => "limit",  // Order type
        //                  "tradeType" => "trade",  // Trade type (trade, liquidation, ADL or settlement)
        //                  "createdAt" => 1558334496000,  // Time the order created
        //                  "settleCurrency" => "XBT", // settlement currency
        //                  "tradeTime" => 1558334496000000000 // trade time in nanosecond
        //              }
        //            )
        //        }
        //    }
        //
        $data = $this->safe_value($response, 'data', array());
        $trades = $this->safe_value($data, 'items', array());
        return $this->parse_trades($trades, $market, $since, $limit);
    }

    public function fetch_trades($symbol, $since = null, $limit = null, $params = array ()) {
        yield $this->load_markets();
        $market = $this->market($symbol);
        $request = array(
            'symbol' => $market['id'],
        );
        $response = yield $this->futuresPublicGetTradeHistory (array_merge($request, $params));
        //
        //      {
        //          "code" => "200000",
        //          "data" => array(
        //              {
        //                  "sequence" => 32114961,
        //                  "side" => "buy",
        //                  "size" => 39,
        //                  "price" => "4001.6500000000",
        //                  "takerOrderId" => "61c20742f172110001e0ebe4",
        //                  "makerOrderId" => "61c2073fcfc88100010fcb5d",
        //                  "tradeId" => "61c2074277a0c473e69029b8",
        //                  "ts" => 1640105794099993896   // filled time
        //              }
        //          )
        //      }
        //
        $trades = $this->safe_value($response, 'data', array());
        return $this->parse_trades($trades, $market, $since, $limit);
    }

    public function parse_trade($trade, $market = null) {
        //
        // fetchTrades (public)
        //
        //     {
        //         "sequence" => 32114961,
        //         "side" => "buy",
        //         "size" => 39,
        //         "price" => "4001.6500000000",
        //         "takerOrderId" => "61c20742f172110001e0ebe4",
        //         "makerOrderId" => "61c2073fcfc88100010fcb5d",
        //         "tradeId" => "61c2074277a0c473e69029b8",
        //         "ts" => 1640105794099993896   // filled time
        //     }
        //
        // fetchMyTrades (private) v2
        //
        //     {
        //         "symbol":"BTC-USDT",
        //         "tradeId":"5c35c02709e4f67d5266954e",
        //         "orderId":"5c35c02703aa673ceec2a168",
        //         "counterOrderId":"5c1ab46003aa676e487fa8e3",
        //         "side":"buy",
        //         "liquidity":"taker",
        //         "forceTaker":true,
        //         "price":"0.083",
        //         "size":"0.8424304",
        //         "funds":"0.0699217232",
        //         "fee":"0",
        //         "feeRate":"0",
        //         "feeCurrency":"USDT",
        //         "stop":"",
        //         "type":"limit",
        //         "createdAt":1547026472000
        //     }
        //
        $marketId = $this->safe_string($trade, 'symbol');
        $symbol = $this->safe_symbol($marketId, $market, '-');
        $id = $this->safe_string_2($trade, 'tradeId', 'id');
        $orderId = $this->safe_string($trade, 'orderId');
        $takerOrMaker = $this->safe_string($trade, 'liquidity');
        $timestamp = $this->safe_integer($trade, 'time');
        if ($timestamp !== null) {
            $timestamp = intval($timestamp / 1000000);
        } else {
            $timestamp = $this->safe_integer($trade, 'createdAt');
            // if it's a historical v1 $trade, the exchange returns $timestamp in seconds
            if ((is_array($trade) && array_key_exists('dealValue', $trade)) && ($timestamp !== null)) {
                $timestamp = $timestamp * 1000;
            }
        }
        $priceString = $this->safe_string_2($trade, 'price', 'dealPrice');
        $amountString = $this->safe_string_2($trade, 'size', 'amount');
        $price = $this->parse_number($priceString);
        $amount = $this->parse_number($amountString);
        $side = $this->safe_string($trade, 'side');
        $fee = null;
        $feeCost = $this->safe_number($trade, 'fee');
        if ($feeCost !== null) {
            $feeCurrencyId = $this->safe_string($trade, 'feeCurrency');
            $feeCurrency = $this->safe_currency_code($feeCurrencyId);
            if ($feeCurrency === null) {
                if ($market !== null) {
                    $feeCurrency = ($side === 'sell') ? $market['quote'] : $market['base'];
                }
            }
            $fee = array(
                'cost' => $feeCost,
                'currency' => $feeCurrency,
                'rate' => $this->safe_number($trade, 'feeRate'),
            );
        }
        $type = $this->safe_string_2($trade, 'type', 'orderType');
        if ($type === 'match') {
            $type = null;
        }
        $cost = $this->safe_number_2($trade, 'funds', 'dealValue');
        if ($cost === null) {
            $market = $this->market($symbol);
            $contractSize = $this->safe_string($market, 'contractSize');
            $contractCost = Precise::string_mul($priceString, $amountString);
            if ($contractSize && $contractCost) {
                $cost = $this->parse_number(Precise::string_mul($contractCost, $contractSize));
            }
        }
        return array(
            'info' => $trade,
            'id' => $id,
            'order' => $orderId,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'symbol' => $symbol,
            'type' => $type,
            'takerOrMaker' => $takerOrMaker,
            'side' => $side,
            'price' => $price,
            'amount' => $amount,
            'cost' => $cost,
            'fee' => $fee,
        );
    }

    public function fetch_deposits($code = null, $since = null, $limit = null, $params = array ()) {
        yield $this->load_markets();
        $request = array();
        $currency = null;
        if ($code !== null) {
            $currency = $this->currency($code);
            $request['currency'] = $currency['id'];
        }
        if ($limit !== null) {
            $request['pageSize'] = $limit;
        }
        if ($since !== null) {
            $request['startAt'] = $since;
        }
        $response = yield $this->futuresPrivateGetDepositList (array_merge($request, $params));
        //
        //     {
        //         $code => '200000',
        //         data => {
        //             "currentPage" => 1,
        //             "pageSize" => 5,
        //             "totalNum" => 2,
        //             "totalPage" => 1,
        //             "items" => array(
        //                 array(
        //                     "address" => "0x5f047b29041bcfdbf0e4478cdfa753a336ba6989",
        //                     "memo" => "5c247c8a03aa677cea2a251d",
        //                     "amount" => 1,
        //                     "fee" => 0.0001,
        //                     "currency" => "KCS",
        //                     "isInner" => false,
        //                     "walletTxId" => "5bbb57386d99522d9f954c5a@test004",
        //                     "status" => "SUCCESS",
        //                     "createdAt" => 1544178843000,
        //                     "updatedAt" => 1544178891000
        //                     "remark":"foobar"
        //                 ),
        //                 ...
        //             )
        //         }
        //     }
        //
        $responseData = $response['data']['items'];
        return $this->parse_transactions($responseData, $currency, $since, $limit, array( 'type' => 'deposit' ));
    }

    public function fetch_withdrawals($code = null, $since = null, $limit = null, $params = array ()) {
        yield $this->load_markets();
        $request = array();
        $currency = null;
        if ($code !== null) {
            $currency = $this->currency($code);
            $request['currency'] = $currency['id'];
        }
        if ($limit !== null) {
            $request['pageSize'] = $limit;
        }
        if ($since !== null) {
            $request['startAt'] = $since;
        }
        $response = yield $this->futuresPrivateGetWithdrawalList (array_merge($request, $params));
        //
        //     {
        //         $code => '200000',
        //         data => {
        //             "currentPage" => 1,
        //             "pageSize" => 5,
        //             "totalNum" => 2,
        //             "totalPage" => 1,
        //             "items" => array(
        //                 array(
        //                     "id" => "5c2dc64e03aa675aa263f1ac",
        //                     "address" => "0x5bedb060b8eb8d823e2414d82acce78d38be7fe9",
        //                     "memo" => "",
        //                     "currency" => "ETH",
        //                     "amount" => 1.0000000,
        //                     "fee" => 0.0100000,
        //                     "walletTxId" => "3e2414d82acce78d38be7fe9",
        //                     "isInner" => false,
        //                     "status" => "FAILURE",
        //                     "createdAt" => 1546503758000,
        //                     "updatedAt" => 1546504603000
        //                 ),
        //                 ...
        //             )
        //         }
        //     }
        //
        $responseData = $response['data']['items'];
        return $this->parse_transactions($responseData, $currency, $since, $limit, array( 'type' => 'withdrawal' ));
    }

    public function fetch_funding_fee($code, $params = array ()) {
        throw new BadRequest($this->id . ' has no method fetchFundingFee');
    }

    public function fetch_ledger($code = null, $since = null, $limit = null, $params = array ()) {
        throw new BadRequest($this->id . ' has no method fetchLedger');
    }
}
