<?php

namespace ccxt\async;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

use Exception; // a common import
use ccxt\async\abstract\ellipx as Exchange;
use ccxt\ExchangeError;
use ccxt\ArgumentsRequired;
use ccxt\NotSupported;
use ccxt\Precise;
use React\Async;
use React\Promise\PromiseInterface;

class ellipx extends Exchange {

    public function describe() {
        return $this->deep_extend(parent::describe(), array(
            'id' => 'ellipx',
            'name' => 'Ellipx',
            'countries' => array( 'PL' ),
            'rateLimit' => 200, // todo check
            'version' => 'v1',
            'certified' => false,
            'pro' => false,
            'has' => array(
                'CORS' => null,
                'spot' => true,
                'margin' => false,
                'swap' => false,
                'future' => false,
                'option' => false,
                'addMargin' => false,
                'cancelAllOrders' => false,
                'cancelAllOrdersAfter' => false,
                'cancelOrder' => true,
                'cancelOrders' => false,
                'cancelWithdraw' => false,
                'closePosition' => false,
                'createConvertTrade' => false,
                'createDepositAddress' => false,
                'createMarketBuyOrderWithCost' => false,
                'createMarketOrder' => false,
                'createMarketOrderWithCost' => false,
                'createMarketSellOrderWithCost' => false,
                'createOrder' => true,
                'createOrderWithTakeProfitAndStopLoss' => false,
                'createReduceOnlyOrder' => false,
                'createStopLimitOrder' => false,
                'createStopLossOrder' => false,
                'createStopMarketOrder' => false,
                'createStopOrder' => false,
                'createTakeProfitOrder' => false,
                'createTrailingAmountOrder' => false,
                'createTrailingPercentOrder' => false,
                'createTriggerOrder' => false,
                'fetchAccounts' => false,
                'fetchBalance' => true,
                'fetchCanceledAndClosedOrders' => false,
                'fetchCanceledOrders' => false,
                'fetchClosedOrder' => false,
                'fetchClosedOrders' => false,
                'fetchConvertCurrencies' => false,
                'fetchConvertQuote' => false,
                'fetchConvertTrade' => false,
                'fetchConvertTradeHistory' => false,
                'fetchCurrencies' => true,
                'fetchDepositAddress' => true,
                'fetchDeposits' => false,
                'fetchDepositsWithdrawals' => false,
                'fetchFundingHistory' => false,
                'fetchFundingRate' => false,
                'fetchFundingRateHistory' => false,
                'fetchFundingRates' => false,
                'fetchIndexOHLCV' => false,
                'fetchLedger' => false,
                'fetchLeverage' => false,
                'fetchLeverageTiers' => false,
                'fetchMarginAdjustmentHistory' => false,
                'fetchMarginMode' => false,
                'fetchMarkets' => true,
                'fetchMarkOHLCV' => false,
                'fetchMyTrades' => false,
                'fetchOHLCV' => true,
                'fetchOpenInterestHistory' => false,
                'fetchOpenOrder' => false,
                'fetchOpenOrders' => true,
                'fetchOrder' => true,
                'fetchOrderBook' => true,
                'fetchOrders' => true,
                'fetchOrderTrades' => true,
                'fetchPosition' => false,
                'fetchPositionHistory' => false,
                'fetchPositionMode' => false,
                'fetchPositions' => false,
                'fetchPositionsForSymbol' => false,
                'fetchPositionsHistory' => false,
                'fetchPremiumIndexOHLCV' => false,
                'fetchStatus' => false,
                'fetchTicker' => true,
                'fetchTickers' => false,
                'fetchTime' => false,
                'fetchTrades' => true,
                'fetchTradingFee' => true,
                'fetchTradingFees' => false,
                'fetchTransactions' => false,
                'fetchTransfers' => false,
                'fetchWithdrawals' => false,
                'reduceMargin' => false,
                'sandbox' => false,
                'setLeverage' => false,
                'setMargin' => false,
                'setPositionMode' => false,
                'transfer' => false,
                'withdraw' => true,
            ),
            'timeframes' => array(
                '1m' => '1m',
                '5m' => '5m',
                '10m' => '10m',
                '1h' => '1h',
                '6h' => '6h',
                '12h' => '12h',
                '1d' => '1d',
            ),
            'urls' => array(
                'logo' => 'https://github.com/user-attachments/assets/e07c3f40-281c-4cdf-bacf-fa1c58218a2c',
                'api' => array(
                    'public' => 'https://data.ellipx.com',
                    'private' => 'https://app.ellipx.com/_rest',
                    '_rest' => 'https://app.ellipx.com/_rest',
                ),
                'www' => 'https://www.ellipx.com',
                'doc' => 'https://docs.google.com/document/d/1ZXzTQYffKE_EglTaKptxGQERRnunuLHEMmar7VC9syM',
                'fees' => 'https://www.ellipx.com/pages/pricing',
                'referral' => '', // todo
            ),
            'api' => array(
                '_rest' => array(
                    'get' => array(
                        'Market' => 1,
                        'Market/{currencyPair}' => 1,
                        'Crypto/Token/Info' => 1,
                    ),
                ),
                'public' => array(
                    'get' => array(
                        'Market/{currencyPair}:getDepth' => 1,
                        'Market/{currencyPair}:ticker' => 1,
                        'Market/{currencyPair}:getTrades' => 1,
                        'Market/{currencyPair}:getGraph' => 1,
                        'CMC:summary' => 1,
                        'CMC/{currencyPair}:ticker' => 1,
                    ),
                ),
                'private' => array(
                    'get' => array(
                        'User/Wallet' => 1,
                        'Market/{currencyPair}/Order' => 1,
                        'Market/Order/{orderUuid}' => 1,
                        'Market/{currencyPair}/Trade' => 1,
                        'Market/TradeFee:query' => 1,
                        'Unit/{currency}' => 1,
                        'Crypto/Token/{currency}' => 1,
                        'Crypto/Token/{currency}:chains' => 1,
                    ),
                    'post' => array(
                        'Market/{currencyPair}/Order' => 1,
                        'Crypto/Address:fetch' => 1,
                        'Crypto/Disbursement:withdraw' => 1,
                    ),
                    'delete' => array(
                        'Market/Order/{orderUuid}' => 1,
                    ),
                ),
            ),
            'fees' => array(
                'trading' => array(
                    'tierBased' => true,
                    'feeSide' => 'get',
                    'percentage' => true,
                    'maker' => $this->parse_number('0.0025'),  // default 25bps
                    'taker' => $this->parse_number('0.0030'),  // default 30bps
                    'tiers' => array(
                        // volume in USDT
                        'maker' => array(
                            array( $this->parse_number('0'), $this->parse_number('0.0025') ),     // 0-10k => 25bps
                            array( $this->parse_number('10000'), $this->parse_number('0.0020') ), // 10k-50k => 20bps
                            array( $this->parse_number('50000'), $this->parse_number('0.0015') ), // 50k-100k => 15bps
                            array( $this->parse_number('100000'), $this->parse_number('0.0010') ), // 100k-1M => 10bps
                            array( $this->parse_number('1000000'), $this->parse_number('0.0008') ), // 1M-5M => 8bps
                            array( $this->parse_number('5000000'), $this->parse_number('0.0003') ), // 5M-15M => 3bps
                            array( $this->parse_number('15000000'), $this->parse_number('0.0000') ), // 15M-75M => 0bps
                            array( $this->parse_number('75000000'), $this->parse_number('0.0000') ), // 75M-100M => 0bps
                            array( $this->parse_number('100000000'), $this->parse_number('0.0000') ), // 100M+ => 0bps
                        ),
                        'taker' => array(
                            array( $this->parse_number('0'), $this->parse_number('0.0030') ),     // 0-10k => 30bps
                            array( $this->parse_number('10000'), $this->parse_number('0.0025') ), // 10k-50k => 25bps
                            array( $this->parse_number('50000'), $this->parse_number('0.0020') ), // 50k-100k => 20bps
                            array( $this->parse_number('100000'), $this->parse_number('0.0015') ), // 100k-1M => 15bps
                            array( $this->parse_number('1000000'), $this->parse_number('0.0012') ), // 1M-5M => 12bps
                            array( $this->parse_number('5000000'), $this->parse_number('0.0010') ), // 5M-15M => 10bps
                            array( $this->parse_number('15000000'), $this->parse_number('0.0008') ), // 15M-75M => 8bps
                            array( $this->parse_number('75000000'), $this->parse_number('0.0005') ), // 75M-100M => 5bps
                            array( $this->parse_number('100000000'), $this->parse_number('0.0003') ), // 100M+ => 3bps
                        ),
                    ),
                ),
                'stablecoin' => array(
                    'tierBased' => false,
                    'percentage' => true,
                    'maker' => $this->parse_number('0.0000'),  // 0%
                    'taker' => $this->parse_number('0.000015'), // 0.0015%
                ),
            ),
            'options' => array(
                'defaultType' => 'spot',
                'recvWindow' => 5 * 1000,
                'broker' => 'CCXT',
                'networks' => array(
                    'Bitcoin' => 'Bitcoin',
                    'Ethereum' => 'ERC20',
                ),
                'defaultNetwork' => 'defaultNetwork',
                'defaultNetworkCodeReplacements' => array(
                    'BTC' => 'Bitcoin',
                    'ETH' => 'Ethereum',
                ),
            ),
            'features' => array(
                'spot' => array(
                    'sandbox' => false,
                    'createOrder' => array(
                        'marginMode' => false,
                        'triggerPrice' => false,
                        'triggerPriceType' => null,
                        'triggerDirection' => false,
                        'stopLossPrice' => false,
                        'takeProfitPrice' => false,
                        'attachedStopLossTakeProfit' => null,
                        'timeInForce' => array(
                            'IOC' => false,
                            'FOK' => false,
                            'PO' => false,
                            'GTD' => false,
                        ),
                        'hedged' => false,
                        'selfTradePrevention' => false,
                        'trailing' => false,
                        'leverage' => false,
                        'marketBuyByCost' => true,
                        'marketBuyRequiresPrice' => false,
                        'iceberg' => false,
                    ),
                    'createOrders' => null,
                    'fetchMyTrades' => null,
                    'fetchOrder' => array(
                        'marginMode' => false,
                        'trigger' => false,
                        'trailing' => false,
                    ),
                    'fetchOpenOrders' => array(
                        'marginMode' => false,
                        'limit' => null,
                        'trigger' => false,
                        'trailing' => false,
                    ),
                    'fetchOrders' => array(
                        'marginMode' => false,
                        'limit' => null, // todo
                        'daysBack' => null, // todo
                        'untilDays' => null, // todo
                        'trigger' => false,
                        'trailing' => false,
                    ),
                    'fetchClosedOrders' => null,
                    'fetchOHLCV' => array(
                        'limit' => 100,
                    ),
                ),
                'swap' => array(
                    'linear' => null,
                    'inverse' => null,
                ),
                'future' => array(
                    'linear' => null,
                    'inverse' => null,
                ),
            ),
            'commonCurrencies' => array(),
            'exceptions' => array(
                'exact' => array(
                    // todo
                    '400' => '\\ccxt\\BadRequest',
                    '401' => '\\ccxt\\AuthenticationError',
                    '403' => '\\ccxt\\PermissionDenied',
                    '404' => '\\ccxt\\BadRequest',
                    '429' => '\\ccxt\\DDoSProtection',
                    '418' => '\\ccxt\\PermissionDenied',
                    '500' => '\\ccxt\\ExchangeError',
                    '504' => '\\ccxt\\ExchangeError',
                ),
                'broad' => array(),
            ),
            'precisionMode' => TICK_SIZE,
        ));
    }

    public function sign($path, $api = 'public', $method = 'GET', $params = array (), $headers = null, $body = null) {
        $path = $this->implode_params($path, $params);
        $url = $this->urls['api'][$api] . '/' . $path;
        if ($api === 'private') {
            $this->check_required_credentials();
            $nonce = $this->uuid();
            $timestamp = (string) $this->seconds();
            if ($method === 'GET') {
                $body = '';
            } else {
                $body = $this->json($params);
            }
            $params = $this->extend(array(
                '_key' => $this->apiKey,
                '_time' => $timestamp,
                '_nonce' => $nonce,
            ), $params);
            $query = $this->urlencode($params);
            $bodyHash = $this->hash($this->encode($body), 'sha256');
            // Create sign string $components
            $bodyHashBytes = $this->base16_to_binary($bodyHash);
            $nulByte = $this->number_to_be(0, 1);
            $components = array(
                $this->encode($method),
                $nulByte,
                $this->encode($path),
                $nulByte,
                $this->encode($query),
                $nulByte,
                $bodyHashBytes,
            );
            // Join with null byte separator using encode
            $signString = $this->binary_concat_array($components);
            $sec = $this->secret;
            $remainder = $this->calculate_mod(strlen($sec), 4);
            $paddingLength = $remainder ? 4 - $remainder : 0;
            $secretWithPadding = str_replace('-', '+', $this->secret);
            $secretWithPadding = str_replace('_', '/', $secretWithPadding);
            $secretWithPadding = str_pad($secretWithPadding, strlen($this->secret) . $paddingLength, '=', STR_PAD_RIGHT);
            $secretBytes = base64_decode($secretWithPadding);
            $seed = $this->array_slice($secretBytes, 0, 32); // Extract first 32 bytes
            $signature = $this->eddsa($signString, $seed, 'ed25519');
            $params['_sign'] = $signature;
        }
        if ($params) {
            $url .= '?' . $this->urlencode($params);
        }
        if ($method === 'GET') {
            $body = null;
        } else {
            $headers = array(
                'Content-Type' => 'application/json',
            );
        }
        return array( 'url' => $url, 'method' => $method, 'body' => $body, 'headers' => $headers );
    }

    public function calculate_mod($a, $b) {
        // trick to fix php transpiling error
        return fmod($a, $b);
    }

    public function fetch_markets($params = array ()): PromiseInterface {
        return Async\async(function () use ($params) {
            /**
             * Fetches market information from the exchange.
             *
             * @see https://docs.ccxt.com/en/latest/manual.html#$markets
             * @see https://docs.google.com/document/d/1ZXzTQYffKE_EglTaKptxGQERRnunuLHEMmar7VC9syM/edit?tab=t.0#heading=h.1a1t05wpgfof
             *
             * @param {array} [$params] - Extra parameters specific to the exchange API endpoint
             * @return array(Promise<Marketarray()>) An array of market structures.
             */
            $response = Async\await($this->_restGetMarket ($params));
            // {
            //     Market__ => "mkt-lrnp2e-eaor-eobj-ua73-75j6sjxe",
            //     Primary_Unit__ => "unit-aebkye-u35b-e5zm-zt22-2qvwhsqa",
            //     Secondary_Unit__ => "unit-jcevlk-soxf-fepb-yjwm-b32q5bom",
            //     Primary_Step => null,
            //     Secondary_Step => null,
            //     Status => "active",
            //     Default_Scale => "5",
            //     Priority => "100",
            //     Created => array(
            //       unix => "1728113809",
            //       us => "0",
            //       iso => "2024-10-05 07:36:49.000000",
            //       tz => "UTC",
            //       full => "1728113809000000",
            //       unixms => "1728113809000",
            //     ),
            //     Start => array(
            //       unix => "1728295200",
            //       us => "0",
            //       iso => "2024-10-07 10:00:00.000000",
            //       tz => "UTC",
            //       full => "1728295200000000",
            //       unixms => "1728295200000",
            //     ),
            //     Key => "BTC_USDC",
            //     Primary => array(
            //       Unit__ => "unit-aebkye-u35b-e5zm-zt22-2qvwhsqa",
            //       Currency__ => "BTC",
            //       Crypto_Token__ => "crtok-c5v3mh-grfn-hl5d-lmel-fvggbf4i",
            //       Key => "BTC",
            //       Symbol => "BTC",
            //       Symbol_Position => "after",
            //       Name => "Bitcoin",
            //       Decimals => "8",
            //       Display_Decimals => "8",
            //       Legacy_Decimals => null,
            //       Type => "crypto_token",
            //       Visible => "Y",
            //       Created => array(
            //         unix => "1495247415",
            //         us => "0",
            //         iso => "2017-05-20 02:30:15.000000",
            //         tz => "UTC",
            //         full => "1495247415000000",
            //         unixms => "1495247415000",
            //       ),
            //     ),
            //     Secondary => array(
            //       Unit__ => "unit-jcevlk-soxf-fepb-yjwm-b32q5bom",
            //       Currency__ => null,
            //       Crypto_Token__ => "crtok-ptabkh-ra4r-anbd-cqra-bqfbtnba",
            //       Key => "USDC",
            //       Symbol => null,
            //       Symbol_Position => "before",
            //       Name => "Circle USD",
            //       Decimals => "6",
            //       Display_Decimals => "6",
            //       Legacy_Decimals => null,
            //       Type => "crypto_token",
            //       Visible => "Y",
            //       Created => array(
            //         unix => "1694859829",
            //         us => "0",
            //         iso => "2023-09-16 10:23:49.000000",
            //         tz => "UTC",
            //         full => "1694859829000000",
            //         unixms => "1694859829000",
            //       ),
            //     ),
            //   }
            $markets = $this->safe_value($response, 'data', array());
            return $this->parse_markets($markets);
        }) ();
    }

    public function parse_market(array $market): array {
        $id = $this->safe_string($market, 'Key');
        $base = $this->safe_string($market['Primary'], 'Key');
        $quote = $this->safe_string($market['Secondary'], 'Key');
        $baseId = $this->safe_string($market['Primary'], 'Crypto_Token__');
        $quoteId = $this->safe_string($market['Secondary'], 'Crypto_Token__');
        $status = $this->safe_string($market, 'Status') === 'active';
        $created = $this->safe_timestamp($market['Created'], 'unix');
        $amountPrecision = $this->parse_number($this->parse_precision($this->safe_string($market['Primary'], 'Decimals')));
        $pricePrecision = $this->parse_number($this->parse_precision($this->safe_string($market['Secondary'], 'Decimals')));
        $fees = $this->fees; // should use fetchTradingFees
        return $this->safe_market_structure(array(
            'id' => $id,
            'symbol' => $base . '/' . $quote,
            'base' => $base,
            'quote' => $quote,
            'settle' => null,
            'baseId' => $baseId,
            'quoteId' => $quoteId,
            'settleId' => null,
            'type' => 'spot',
            'spot' => true,
            'margin' => false,
            'swap' => false,
            'future' => false,
            'option' => false,
            'active' => $status,
            'contract' => false,
            'linear' => null,
            'inverse' => null,
            'taker' => $fees['trading']['taker'],
            'maker' => $fees['trading']['maker'],
            'contractSize' => null,
            'expiry' => null,
            'expiryDatetime' => null,
            'strike' => null,
            'optionType' => null,
            'precision' => array(
                'amount' => $amountPrecision,
                'price' => $pricePrecision,
            ),
            'limits' => array(
                'amount' => array(
                    'min' => null,
                    'max' => null,
                ),
                'price' => array(
                    'min' => null,
                    'max' => null,
                ),
                'cost' => array(
                    'min' => null,
                    'max' => null,
                ),
            ),
            'info' => $market,
            'created' => $created,
        ));
    }

    public function fetch_ticker(string $symbol, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $params) {
            /**
             * fetches a price $ticker, a statistical calculation with the information calculated over the past 24 hours for a specific $market
             *
             * @see https://docs.google.com/document/d/1ZXzTQYffKE_EglTaKptxGQERRnunuLHEMmar7VC9syM/edit?tab=t.0#heading=h.d2jylz4u6pmu
             *
             * @param {string} $symbol unified $symbol of the $market to fetch the $ticker for
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} a ~@link https://docs.ccxt.com/#/?id=$ticker-structure $ticker structure~
             */
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $marketId = $market['id'];
            $request = array(
                'currencyPair' => $marketId,
            );
            $response = Async\await($this->publicGetMarketCurrencyPairTicker ($this->extend($request, $params)));
            //
            //     {
            //         "data" => {
            //             "market" => "BTC_USDC",
            //             "ticker" => {
            //                 "time" => 1730814600,
            //                 "count" => 2135,
            //                 "high" => array(
            //                     "v" => "74766990000",
            //                     "e" => 6,
            //                     "f" => 74766.99
            //                 ),
            //                 "low" => array(
            //                     "v" => "68734020000",
            //                     "e" => 6,
            //                     "f" => 68734.02
            //                 ),
            //                 "avg" => array(
            //                     "v" => "72347941430",
            //                     "e" => 6,
            //                     "f" => 72347.94143
            //                 ),
            //                 "vwap" => array(
            //                     "v" => "73050064447",
            //                     "e" => 6,
            //                     "f" => 73050.064447
            //                 ),
            //                 "vol" => array(
            //                     "v" => "4885361",
            //                     "e" => 8,
            //                     "f" => 0.04885361
            //                 ),
            //                 "secvol" => array(
            //                     "v" => "3568759346",
            //                     "e" => 6,
            //                     "f" => 3568.759346
            //                 ),
            //                 "open" => array(
            //                     "v" => "68784020000",
            //                     "e" => 6,
            //                     "f" => 68784.02
            //                 ),
            //                 "close" => array(
            //                     "v" => "73955570000",
            //                     "e" => 6,
            //                     "f" => 73955.57
            //                 }
            //             }
            //         ),
            //         "request_id" => "cbf183e0-7a62-4674-838c-6693031fa240",
            //         "result" => "success",
            //         "time" => 0.015463566
            //     }
            //
            $ticker = $this->safe_value($response['data'], 'ticker', array());
            return $this->parse_ticker($ticker, $market);
        }) ();
    }

    public function parse_ticker(array $ticker, ?array $market = null): array {
        $timestamp = $this->safe_integer_product($ticker, 'time', 1000);
        $open = $this->parse_amount($this->safe_value($ticker, 'open'));
        $high = $this->parse_amount($this->safe_value($ticker, 'high'));
        $low = $this->parse_amount($this->safe_value($ticker, 'low'));
        $close = $this->parse_amount($this->safe_value($ticker, 'close'));
        $avg = $this->parse_amount($this->safe_value($ticker, 'avg'));
        $vwap = $this->parse_amount($this->safe_value($ticker, 'vwap'));
        $baseVolume = $this->parse_amount($this->safe_value($ticker, 'vol'));
        $quoteVolume = $this->parse_amount($this->safe_value($ticker, 'secvol'));
        // $count = $this->safe_integer($ticker, 'count'); not used
        return $this->safe_ticker(array(
            'symbol' => $this->safe_symbol(null, $market),
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'high' => $high,
            'low' => $low,
            'bid' => null,
            'bidVolume' => null,
            'ask' => null,
            'askVolume' => null,
            'vwap' => $vwap,
            'open' => $open,
            'close' => $close,
            'last' => $close,
            'previousClose' => null,
            'change' => null,
            'percentage' => null,
            'average' => $avg,
            'baseVolume' => $baseVolume,
            'quoteVolume' => $quoteVolume,
            'info' => $ticker,
        ), $market);
    }

    public function fetch_order_book(string $symbol, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $limit, $params) {
            /**
             * fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other $data
             *
             * @see https://docs.google.com/document/d/1ZXzTQYffKE_EglTaKptxGQERRnunuLHEMmar7VC9syM/edit?tab=t.0#heading=h.bqmucewhkpdz
             *
             * @param {string} $symbol unified $symbol of the $market to fetch the order book for
             * @param {int} [$limit] the maximum amount of order book entries to return the exchange not supported yet.
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} A dictionary of ~@link https://docs.ccxt.com/#/?id=order-book-structure order book structures~ indexed by $market symbols
             */
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $marketId = $market['id'];
            $request = array(
                'currencyPair' => $marketId,
            );
            $response = Async\await($this->publicGetMarketCurrencyPairGetDepth ($this->extend($request, $params)));
            // {
            //     "data" => {
            //         "asks" => array(
            //             {
            //                 "price" => array(
            //                     "v" => "74941875231",
            //                     "e" => 6,
            //                     "f" => 74941.875231
            //                 ),
            //                 "amount" => array(
            //                     "v" => "149",
            //                     "e" => 8,
            //                     "f" => 0.00000149
            //                 }
            //             ),
            //             {
            //                 "price" => array(
            //                     "v" => "75063426037",
            //                     "e" => 6,
            //                     "f" => 75063.426037
            //                 ),
            //                 "amount" => {
            //                     "v" => "335",
            //                     "e" => 8,
            //                     "f" => 0.00000335
            //                 }
            //             }
            //         ),
            //         "bids" => array(
            //             {
            //                 "price" => array(
            //                     "v" => "64518711040",
            //                     "e" => 6,
            //                     "f" => 64518.71104
            //                 ),
            //                 "amount" => array(
            //                     "v" => "132",
            //                     "e" => 8,
            //                     "f" => 0.00000132
            //                 }
            //             ),
            //             {
            //                 "price" => array(
            //                     "v" => "64263569273",
            //                     "e" => 6,
            //                     "f" => 64263.569273
            //                 ),
            //                 "amount" => array(
            //                     "v" => "210",
            //                     "e" => 8,
            //                     "f" => 0.0000021
            //                 }
            //             }
            //         ),
            //         "market" => "BTC_USDC"
            //     ),
            //     "request_id" => "71b7dffc-3120-4e46-a0bb-49ece5aea7e1",
            //     "result" => "success",
            //     "time" => 0.000074661
            // }
            $data = $this->safe_value($response, 'data', array()); // exchange specific v e f $params
            $timestamp = $this->milliseconds(); // the exchange does not provide $timestamp for $this->
            $dataBidsLength = count($data['bids']);
            $dataAsksLength = count($data['asks']);
            for ($i = 0; $i < $dataBidsLength; $i++) {
                $data['bids'][$i]['price'] = $this->parse_amount($data['bids'][$i]['price']);
                $data['bids'][$i]['amount'] = $this->parse_amount($data['bids'][$i]['amount']);
            }
            for ($i = 0; $i < $dataAsksLength; $i++) {
                $data['asks'][$i]['price'] = $this->parse_amount($data['asks'][$i]['price']);
                $data['asks'][$i]['amount'] = $this->parse_amount($data['asks'][$i]['amount']);
            }
            return $this->parse_order_book($data, $symbol, $timestamp, 'bids', 'asks', 'price', 'amount');
        }) ();
    }

    public function fetch_ohlcv(string $symbol, $timeframe = '1m', ?int $since = null, ?int $limit = null, $params = array ()) {
        return Async\async(function () use ($symbol, $timeframe, $since, $limit, $params) {
            /**
             * fetches historical candlestick $data containing the open, high, low, and close price, and the volume of a $market, default will return the last 24h period.
             *
             * @see https://docs.google.com/document/d/1ZXzTQYffKE_EglTaKptxGQERRnunuLHEMmar7VC9syM/edit?tab=t.0#heading=h.w65baeuhxwt8
             *
             * @param {string} $symbol unified $symbol of the $market to fetch OHLCV $data for
             * @param {string} $timeframe the length of time each candle represents
             * @param {int} [$since] timestamp in ms of the earliest candle to fetch
             * @param {int} [$limit] the maximum amount of candles to fetch
             * @param {array} [$params] extra parameters specific to the API endpoint
             * @param {int} [$params->until] timestamp in ms of the earliest candle to fetch
             * @return {OHLCV[]} A list of candles ordered, open, high, low, close, volume
             */
            Async\await($this->load_markets());
            $methodName = 'fetchOHLCV';
            $paginate = false;
            list($paginate, $params) = $this->handle_option_and_params($params, $methodName, 'paginate');
            if ($paginate) {
                return Async\await($this->fetch_paginated_call_deterministic('fetchOHLCV', $symbol, $since, $limit, $timeframe, $params, 1000));
            }
            $market = $this->market($symbol);
            $marketId = $market['id'];
            $time_frame = $this->safe_string($this->timeframes, $timeframe, null);
            $request = array(
                'currencyPair' => $marketId,
                'interval' => $time_frame,
            );
            if ($since !== null) {
                $request['start'] = (int) floor($since / 1000);
            }
            $until = null;
            list($until, $params) = $this->handle_option_and_params($params, $methodName, 'until');
            if ($until !== null) {
                $request['end'] = $until;
            }
            // {
            //     "data" => {
            //         "market" => "BTC_USDC",
            //         "real_end" => 1730970780,
            //         "requested_end" => 1730970784,
            //         "start" => 1730884200,
            //         "stats" => array(
            //             {
            //                 "time" => 1730884200,
            //                 "count" => 48,
            //                 "high" => array("v" => "73898950000", "e" => 6, "f" => 73898.95),
            //                 "low" => array("v" => "73642930000", "e" => 6, "f" => 73642.93),
            //                 "open" => array("v" => "73830990000", "e" => 6, "f" => 73830.99),
            //                 "close" => array("v" => "73682510000", "e" => 6, "f" => 73682.51),
            //                 "vol" => array("v" => "88159", "e" => 8, "f" => 0.00088159)
            //             }
            //         )
            //     }
            // }
            // No $limit parameter supported by the API
            $response = Async\await($this->publicGetMarketCurrencyPairGetGraph ($this->extend($request, $params)));
            $data = $this->safe_dict($response, 'data', array());
            $ohlcv = $this->safe_list($data, 'stats', array());
            return $this->parse_ohlcvs($ohlcv, $market, $timeframe, $since, $limit);
        }) ();
    }

    public function parse_ohlcv($ohlcv, ?array $market = null): array {
        return array(
            $this->safe_integer($ohlcv, 'time') * 1000,  // timestamp
            $this->parse_number($this->parse_amount($this->safe_dict($ohlcv, 'open'))),      // open
            $this->parse_number($this->parse_amount($this->safe_dict($ohlcv, 'high'))),      // high
            $this->parse_number($this->parse_amount($this->safe_dict($ohlcv, 'low'))),       // low
            $this->parse_number($this->parse_amount($this->safe_dict($ohlcv, 'close'))),     // close
            $this->parse_number($this->parse_amount($this->safe_dict($ohlcv, 'vol'))),       // volume
        );
    }

    public function fetch_currencies($params = array ()): PromiseInterface {
        return Async\async(function () use ($params) {
            /**
             * fetches information on all $currencies from the exchange, including deposit/withdrawal details and available chains
             *
             * @see https://docs.google.com/document/d/1ZXzTQYffKE_EglTaKptxGQERRnunuLHEMmar7VC9syM/edit?tab=t.0#heading=h.x65f9s9j74jf
             *
             * @param {array} [$params] extra parameters specific to the ellipx API endpoint
             * @param {string} [$params->Can_Deposit] filter $currencies by deposit availability, Y for available
             * @param {number} [$params->results_per_page] number of results per page, default 100
             * @param {string} [$params->_expand] additional fields to expand in $response, default '/Crypto_Token,/Crypto_Chain'
             * @return array(Promise<Currencies>) An object of $currency structures indexed by $currency codes
             */
            $response = Async\await($this->_restGetCryptoTokenInfo ($this->extend(array(
                'Can_Deposit' => 'Y',
                'results_per_page' => 100,
                '_expand' => '/Crypto_Token,/Crypto_Chain',
            ), $params)));
            $currencies = array();
            $data = $this->safe_value($response, 'data', array());
            for ($i = 0; $i < count($data); $i++) {
                $currency = $this->parse_currency($data[$i]);
                $code = $this->safe_string($currency, 'code');
                if ($code !== null) {
                    $currencies[$code] = $currency;
                }
            }
            return $currencies;
        }) ();
    }

    public function parse_currency($currency): array {
        $id = $this->safe_string($currency, 'Crypto_Token__');
        $token = $this->safe_value($currency, 'Crypto_Token', array());
        $code = $this->safe_currency_code($this->safe_string($token, 'Symbol'));
        $name = $this->safe_string($token, 'Name');
        $active = $this->safe_string($currency, 'Status') === 'valid';
        $deposit = $this->safe_string($currency, 'Can_Deposit') === 'Y';
        $withdraw = $this->safe_string($currency, 'Status') === 'valid';
        $fee = null;
        if ($currency['Withdraw_Fee'] !== null) {
            $fee = $this->parse_number($this->parse_amount($currency['Withdraw_Fee']));
        }
        $precision = $this->parse_number($this->parse_precision($this->safe_string($token, 'Decimals')));
        $minDeposit = null;
        if ($currency['Minimum_Deposit'] !== null) {
            $minDeposit = $this->parse_amount($currency['Minimum_Deposit']);
        }
        $minWithdraw = null;
        if ($currency['Minimum_Withdraw'] !== null) {
            $minWithdraw = $this->parse_amount($currency['Minimum_Withdraw']);
        }
        $networkId = $this->safe_string($currency, 'Crypto_Chain__');
        $networkData = $this->safe_value($currency, 'Crypto_Chain', array());
        $networkCode = $this->safe_string($networkData, 'Type', 'default');
        $networks = array(
            'string' => null,
            'info' => $networkCode === 'default' ? array() : $networkData,
            'id' => $networkId || $id || '',
            'network' => $networkCode,
            'active' => $active,
            'deposit' => $deposit,
            'withdraw' => $withdraw,
            'fee' => $fee,
            'precision' => $precision,
            'limits' => array(
                'deposit' => array(
                    'min' => $minDeposit,
                    'max' => null,
                ),
                'withdraw' => array(
                    'min' => $minWithdraw,
                    'max' => null,
                ),
            ),
        );
        $result = array(
            'info' => $currency,
            'id' => $id,
            'code' => $code,
            'name' => $name,
            'active' => $active,
            'deposit' => $deposit,
            'withdraw' => $withdraw,
            'fee' => $fee,
            'precision' => $precision,
            'type' => null,
            'limits' => array(
                'amount' => array(
                    'min' => null,
                    'max' => null,
                ),
                'withdraw' => array(
                    'min' => $minWithdraw,
                    'max' => null,
                ),
            ),
            'networks' => $networks,
        );
        return $result;
    }

    public function fetch_trades(string $symbol, ?int $since = null, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            /**
             * fetches all completed $trades for a particular market/symbol
             * @param {string} $symbol unified $market $symbol (e.g. 'BTC/USDT')
             * @param {int} [$since] timestamp in ms of the earliest trade to fetch
             * @param {int} [$limit] the maximum amount of $trades to fetch
             * @param {array} [$params] extra parameters specific to the EllipX API endpoint
             * @param {string} [$params->before] get $trades before the given trade ID
             * @return {Trade[]} a list of ~@link https://docs.ccxt.com/#/?id=trade-structure trade structures~
             */
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $marketId = $market['id'];
            $request = array(
                'currencyPair' => $marketId,
            );
            // endpoint support before trade id.
            // The actual endpoint URL will be => https://data->ellipx.com/Market/{currencyPair}:getTrades
            // {
            //     "id" => "BTC_USDC:1731053859:914141972:0",
            //     "pair" => array(
            //         "BTC",
            //         "USDC"
            //     ),
            //     "bid" => array(
            //         "id" => "mktor-swishf-uv6n-hrzj-63ye-bdqnk33q",
            //         "iss" => "ellipx:beta",
            //         "uniq" => "order:1731053859:914141972:0"
            //     ),
            //     "ask" => array(
            //         "id" => "mktor-p3ozvt-qurz-gmzo-bf5n-g4rcuy6u",
            //         "iss" => "ellipx:beta",
            //         "uniq" => "order:1731053859:874659786:0"
            //     ),
            //     "type" => "bid",
            //     "amount" => array(
            //         "v" => "412",
            //         "e" => 8,
            //         "f" => 0.00000412
            //     ),
            //     "price" => array(
            //         "v" => "75878090000",
            //         "e" => 6,
            //         "f" => 75878.09
            //     ),
            //     "date" => "2024-11-08T08:17:39.914141972Z"
            // }
            $response = Async\await($this->publicGetMarketCurrencyPairGetTrades ($this->extend($request, $params)));
            $data = $this->safe_dict($response, 'data', array());
            $trades = $this->safe_list($data, 'trades', array());
            return $this->parse_trades($trades, $market, $since, $limit);
        }) ();
    }

    public function parse_trade($trade, $market = null): array {
        // Format of $trade ID => "BTC_USDC:1731053859:914141972:0"
        $id = $this->safe_string($trade, 'id');
        // fetchTrades and fetchMyTrades return different $trade structures
        $date = $this->safe_dict($trade, 'date');
        $timestamp = null;
        if ($date === null) {
            $timestamp = $this->parse8601($this->safe_string($trade, 'date'));
        } else {
            $timestamp = $this->safe_integer($date, 'unixms');
        }
        $type = $this->safe_string($trade, 'type');
        $side = ($type === 'bid') ? 'buy' : 'sell';
        $amount = $this->safe_dict($trade, 'amount');
        $price = $this->safe_dict($trade, 'price');
        $amountFloat = $this->parse_amount($amount);
        $priceFloat = $this->parse_amount($price);
        // fetchTrades and fetchMyTrades return different $trade structures
        $pair = $this->safe_list($trade, 'pair');
        $marketSymbol = null;
        if ($pair === null) {
            $symbol = $this->safe_string($trade, 'pair');
            list($base, $quote) = explode('_', $symbol);
            $marketSymbol = $base . '/' . $quote;
        } else {
            $marketSymbol = $this->safe_string($pair, 0) . '/' . $this->safe_string($pair, 1);
        }
        $bidOrder = $this->safe_dict($trade, 'bid');
        $askOrder = $this->safe_dict($trade, 'ask');
        $isBuy = ($side === 'buy');
        $orderId = $isBuy ? $this->safe_string($bidOrder, 'id') : $this->safe_string($askOrder, 'id');
        return $this->safe_trade(array(
            'id' => $id,
            'info' => $trade,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'symbol' => $marketSymbol,
            'type' => null,
            'side' => $side,
            'order' => $orderId,
            'takerOrMaker' => null,
            'price' => $priceFloat,
            'amount' => $amountFloat,
            'cost' => null,
            'fee' => null,
        ));
    }

    public function fetch_balance($params = array ()): PromiseInterface {
        return Async\async(function () use ($params) {
            /**
             * query for $balance and get the amount of funds available for trading or funds locked in orders
             *
             * @see https://docs.google.com/document/d/1ZXzTQYffKE_EglTaKptxGQERRnunuLHEMmar7VC9syM/edit?tab=t.0#heading=h.ihrjov144txg
             *
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} a ~@link https://docs.ccxt.com/#/?id=$balance-structure $balance structure~
             */
            Async\await($this->load_markets());
            $response = Async\await($this->privateGetUserWallet ($params));
            // {
            //     "User_Wallet__" => "usw-vv7hzo-qel5-gupk-neqi-7f3wz5pq",
            //     "User__" => "usr-...",
            //     "Realm__" => "usrr-cb3c7n-qvxv-fdrb-uc2q-gpja2foi",
            //     "Unit__" => "unit-aebkye-u35b-e5zm-zt22-2qvwhsqa",
            //     "Balance" => array(
            //         "value" => "0.00006394",
            //         "value_int" => "6394",
            //         "value_disp" => "0.00006394",
            //         "value_xint" => array(
            //             "v" => "6394",
            //             "e" => 8,
            //             "f" => 0.00006394
            //         ),
            //         "display" => "0.00006394BTC",
            //         "display_short" => "0.00006394BTC",
            //         "currency" => "BTC",
            //         "unit" => "BTC",
            //         "has_vat" => false,
            //         "tax_profile" => null
            //     ),
            //     "Balance_Date" => array(
            //         "unix" => 1731128270,
            //         "us" => 426208,
            //         "iso" => "2024-11-09 04:57:50.426208",
            //         "tz" => "UTC",
            //         "full" => "1731128270426208",
            //         "unixms" => "1731128270426"
            //     ),
            //     "Liabilities" => array(
            //         "value" => "0.00000000",
            //         "value_int" => "0",
            //         "value_disp" => "0.00000000",
            //         "value_xint" => array(
            //             "v" => "0",
            //             "e" => 8,
            //             "f" => 0
            //         ),
            //         "display" => "0.00000000BTC",
            //         "display_short" => "0.00000000BTC",
            //         "currency" => "BTC",
            //         "unit" => "BTC",
            //         "has_vat" => false,
            //         "tax_profile" => null
            //     ),
            //     "Index" => "5",
            //     "Backend" => "virtual",
            //     "Disable_Limits" => "N",
            //     "Unencumbered_Balance" => {
            //         "value" => "0.00006394",
            //         "value_int" => "6394",
            //         "value_disp" => "0.00006394",
            //         "value_xint" => array(
            //             "v" => "6394",
            //             "e" => 8,
            //             "f" => 0.00006394
            //         ),
            //         "display" => "0.00006394BTC",
            //         "display_short" => "0.00006394BTC",
            //         "currency" => "BTC",
            //         "unit" => "BTC",
            //         "has_vat" => false,
            //         "tax_profile" => null
            //     }
            // }
            $result = array(
                'info' => $response,
                'timestamp' => null,
                'datetime' => null,
            );
            $dataArray = $this->safe_list($response, 'data', array());
            // Use first item's timestamp if available
            $dataArrayLength = count($dataArray);
            if ($dataArrayLength > 0) {
                $firstItem = $dataArray[0];
                $balanceDate = $this->safe_dict($firstItem, 'Balance_Date', array());
                $result['timestamp'] = $this->safe_integer($balanceDate, 'unixms');
                $result['datetime'] = $this->iso8601($result['timestamp']);
            }
            // Process each $balance $entry
            for ($i = 0; $i < count($dataArray); $i++) {
                $entry = $dataArray[$i];
                $balance = $this->safe_dict($entry, 'Balance', array());
                $currency = $this->safe_string($balance, 'currency');
                if ($currency !== null) {
                    $account = array(
                        'free' => $this->parse_amount($entry['Unencumbered_Balance']['value_xint']),
                        'used' => $this->parse_amount($entry['Liabilities']['value_xint']),
                        'total' => $this->parse_amount($balance['value_xint']),
                    );
                    $result[$currency] = $account;
                }
            }
            return $this->safe_balance($result);
        }) ();
    }

    public function create_order(string $symbol, string $type, string $side, float $amount, ?float $price = null, $params = array ()) {
        return Async\async(function () use ($symbol, $type, $side, $amount, $price, $params) {
            /**
             * create a new $order in a $market
             *
             * @see https://docs.google.com/document/d/1ZXzTQYffKE_EglTaKptxGQERRnunuLHEMmar7VC9syM/edit?tab=t.0#heading=h.yzfak2n2bwpo
             *
             * @param {string} $symbol unified $market $symbol (e.g. 'BTC/USDT')
             * @param {string} $type $order $type - the exchange automatically sets $type to 'limit' if $price defined, 'market' if null
             * @param {string} $side 'buy' or 'sell'
             * @param {float} [$amount] $amount of base currency to trade (can be null if using Spend_Limit)
             * @param {float} [$price] $price per unit of base currency for limit orders
             * @param {array} [$params] extra parameters specific to the EllipX API endpoint
             * @param {float} [$params->cost] maximum $amount to spend in quote currency (required for $market orders if $amount null)
             * @return {array} an ~@link https://docs.ccxt.com/#/?id=$order-structure $order structure~
             */
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            // the exchange automatically sets the $type to 'limit' if the $price is defined and to 'market' if it is not
            $marketId = $market['id'];
            $orderType = 'bid';
            if ($side === 'buy') {
                $orderType = 'bid';
            } else {
                $orderType = 'ask';
            }
            $request = array(
                'currencyPair' => $marketId,
                'Type' => $orderType,
            );
            if ($amount !== null) {
                $request['Amount'] = $this->amount_to_precision($symbol, $amount);
            }
            if ($price !== null) {
                $request['Price'] = $this->price_to_precision($symbol, $price);
            }
            $cost = $this->safe_string($params, 'cost');
            if ($cost !== null) {
                $params = $this->omit($params, 'cost');
                $request['Spend_Limit'] = $this->price_to_precision($symbol, $cost);
            }
            $response = Async\await($this->privatePostMarketCurrencyPairOrder ($this->extend($request, $params)));
            // {
            //     "result" => "success",
            //     "data" => {
            //         "Market_Order__" => "mktor-x2grmu-zwo5-fyxc-4gue-vd4ouvsa",
            //         "Market__" => "mkt-lrnp2e-eaor-eobj-ua73-75j6sjxe",
            //         "User__" => "usr-...",
            //         "Uniq" => "order:1728719021:583795548:0",
            //         "Type" => "bid",
            //         "Status" => "pending",
            //         "Flags" => array(),
            //         "Amount" => array(
            //             "v" => "100000000",
            //             "e" => 8,
            //             "f" => 1
            //         ),
            //         "Price" => null,
            //         "Spend_Limit" => array(
            //             "v" => "1000000",
            //             "e" => 6,
            //             "f" => 1
            //         ),
            //         "Executed" => array(
            //             "v" => "0",
            //             "e" => 0,
            //             "f" => 0
            //         ),
            //         "Secured" => array(
            //             "v" => "1000000",
            //             "e" => 6,
            //             "f" => 1
            //         ),
            //         "Version" => "0",
            //         "Created" => array(
            //             "unix" => 1728719020,
            //             "us" => 315195,
            //             "iso" => "2024-10-12 07:43:40.315195",
            //             "tz" => "UTC",
            //             "full" => "1728719020315195",
            //             "unixms" => "1728719020315"
            //         ),
            //         "Updated" => {
            //             "unix" => 1728719020,
            //             "us" => 315195,
            //             "iso" => "2024-10-12 07:43:40.315195",
            //             "tz" => "UTC",
            //             "full" => "1728719020315195",
            //             "unixms" => "1728719020315"
            //         }
            //     }
            // }
            $order = $this->safe_dict($response, 'data', array());
            return $this->parse_order($order, $market);
        }) ();
    }

    public function fetch_order(string $id, ?string $symbol = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($id, $symbol, $params) {
            /**
             * fetches information on an order made by the user
             * @param {string} $id the order ID by createOrder or fetchOrders
             * @param {string|null} $symbol not used by ellipx.fetchOrder
             * @param {array} [$params] extra parameters specific to the EllipX API endpoint
             * @return {array} An ~@link https://docs.ccxt.com/#/?$id=order-structure order structure~
             */
            Async\await($this->load_markets());
            $request = array(
                'orderUuid' => $id,
            );
            $response = Async\await($this->privateGetMarketOrderOrderUuid ($this->extend($request, $params)));
            $data = $this->safe_dict($response, 'data', array());
            return $this->parse_order($data, null);
        }) ();
    }

    public function fetch_orders_by_status($status, ?string $symbol = null, ?int $since = null, ?int $limit = null, $params = array ()) {
        return Async\async(function () use ($status, $symbol, $since, $limit, $params) {
            /**
             * fetches a list of orders placed on the exchange
             *
             * @see https://docs.google.com/document/d/1ZXzTQYffKE_EglTaKptxGQERRnunuLHEMmar7VC9syM/edit?tab=t.0#heading=h.5z2nh2b5s81n
             *
             * @param {string} $status 'open' or 'closed', omit for all orders
             * @param {string} $symbol unified $market $symbol
             * @param {int} [$since] timestamp in ms of the earliest order
             * @param {int} [$limit] the maximum amount of orders to fetch
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array[]} a list of ~@link https://docs.ccxt.com/#/?id=order-structure order structures~
             */
            Async\await($this->load_markets());
            $market = null;
            $request = array();
            if ($symbol !== null) {
                $market = $this->market($symbol);
                $marketId = $market['id'];
                $request['currencyPair'] = $marketId;
            }
            if ($status !== null) {
                $request['Status'] = $status;
            }
            $response = Async\await($this->privateGetMarketCurrencyPairOrder ($this->extend($request, $params)));
            // {
            //     "result" => "success",
            //     "data" => array(
            //         {
            //             "Market_Order__" => "mktor-aglvd2-iy5v-enbj-nwrb-scqsnosa",
            //             "Market__" => "mkt-lrnp2e-eaor-eobj-ua73-75j6sjxe",
            //             "User__" => "usr-...",
            //             "Uniq" => "order:1728712511:964332600:0",
            //             "Type" => "ask",
            //             "Status" => "open",
            //             "Flags" => array(),
            //             "Amount" => array(
            //                 "v" => "1",
            //                 "e" => 8,
            //                 "f" => 1.0e-8
            //             ),
            //             "Price" => array(
            //                 "v" => "63041306872",
            //                 "e" => 6,
            //                 "f" => 63041.306872
            //             ),
            //             "Spend_Limit" => null,
            //             "Executed" => array(
            //                 "v" => "892",
            //                 "e" => 8,
            //                 "f" => 8.92e-6
            //             ),
            //             "Secured" => null,
            //             "Version" => "3",
            //             "Created" => array(
            //                 "unix" => 1728712510,
            //                 "us" => 669096,
            //                 "iso" => "2024-10-12 05:55:10.669096",
            //                 "tz" => "UTC",
            //                 "full" => "1728712510669096",
            //                 "unixms" => "1728712510669"
            //             ),
            //             "Updated" => {
            //                 "unix" => 1728712510,
            //                 "us" => 669096,
            //                 "iso" => "2024-10-12 05:55:10.669096",
            //                 "tz" => "UTC",
            //                 "full" => "1728712510669096",
            //                 "unixms" => "1728712510669"
            //             }
            //         }
            //     ),
            //     "paging" => {
            //         "page_no" => 1,
            //         "count" => "1",
            //         "page_max" => 1,
            //         "results_per_page" => 20
            //     }
            // }
            $data = $this->safe_value($response, 'data', array());
            return $this->parse_orders($data, $market, $since, $limit);
        }) ();
    }

    public function fetch_orders(?string $symbol = null, ?int $since = null, ?int $limit = null, $params = array ()) {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            /**
             * fetches information on multiple orders made by the user
             *
             * @see https://docs.google.com/document/d/1ZXzTQYffKE_EglTaKptxGQERRnunuLHEMmar7VC9syM/edit?tab=t.0#heading=h.5z2nh2b5s81n
             *
             * @param {string} $symbol unified market $symbol of the market orders were made in
             * @param {int|null} $since timestamp in ms of the earliest order
             * @param {int|null} $limit the maximum amount of orders to fetch
             * @param {array} $params extra parameters specific to the exchange API endpoint
             * @return {Order[]} a list of ~@link https://docs.ccxt.com/#/?id=order-structure order structures~
             */
            if ($symbol === null) {
                throw new ArgumentsRequired($this->id . ' fetchOrders requires a $symbol parameter');
            }
            return Async\await($this->fetch_orders_by_status(null, $symbol, $since, $limit, $params));
        }) ();
    }

    public function fetch_open_orders(?string $symbol = null, ?int $since = null, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            /**
             * fetches information on open orders made by the user
             *
             * @see https://docs.google.com/document/d/1ZXzTQYffKE_EglTaKptxGQERRnunuLHEMmar7VC9syM/edit?tab=t.0#heading=h.5z2nh2b5s81n
             *
             * @param {string} $symbol unified market $symbol of the market orders were made in
             * @param {int|null} $since timestamp in ms of the earliest order
             * @param {int|null} $limit the maximum amount of orders to fetch
             * @param {array} $params extra parameters specific to the exchange API endpoint
             * @return {Order[]} a list of ~@link https://docs.ccxt.com/#/?id=order-structure order structures~
             */
            if ($symbol === null) {
                throw new ArgumentsRequired($this->id . ' fetchOpenOrders requires a $symbol parameter');
            }
            return Async\await($this->fetch_orders_by_status('open', $symbol, $since, $limit, $params));
        }) ();
    }

    public function parse_order($order, $market = null): array {
        $id = $this->safe_string($order, 'Market_Order__');
        $timestamp = $this->safe_integer($this->safe_dict($order, 'Created'), 'unixms');
        $orderType = $this->safe_string($order, 'Type');
        $side = 'sell';
        if ($orderType === 'bid') {
            $side = 'buy';
        }
        $status = $this->parse_order_status($this->safe_string($order, 'Status'));
        $amount = $this->parse_number($this->parse_amount($this->safe_dict($order, 'Amount')));
        $price = $this->parse_number($this->parse_amount($this->safe_dict($order, 'Price')));
        $type = ($price === null) ? 'market' : 'limit';
        $executed = $this->parse_number($this->parse_amount($this->safe_dict($order, 'Executed')));
        $filled = $executed;
        $remaining = $this->parse_number($this->parse_amount($this->safe_dict($order, 'Secured')));
        $cost = $this->parse_number($this->parse_amount($this->safe_dict($order, 'Total_Spent')));
        $symbol = $market ? $market['symbol'] : null;
        $clientOrderId = null;
        $timeInForce = 'GTC'; // default to Good Till Cancelled
        $postOnly = false;
        $updated = $this->safe_dict($order, 'Updated', array());
        $lastTradeTimestamp = $this->safe_integer($updated, 'unixms', null);
        return $this->safe_order(array(
            'id' => $id,
            'clientOrderId' => $clientOrderId,
            'info' => $order,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'lastTradeTimestamp' => $lastTradeTimestamp,
            'status' => $this->parse_order_status($status),
            'symbol' => $symbol,
            'type' => $type,
            'timeInForce' => $timeInForce,
            'postOnly' => $postOnly,
            'side' => $side,
            'price' => $price,
            'triggerPrice' => null,
            'average' => null,
            'cost' => $cost,
            'amount' => $amount,
            'filled' => $filled,
            'remaining' => $remaining,
            'fee' => null,
            'trades' => null,
        ), $market);
    }

    public function cancel_order(string $id, ?string $symbol = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($id, $symbol, $params) {
            /**
             * Cancels an open order on the exchange
             *
             * @see https://docs.google.com/document/d/1ZXzTQYffKE_EglTaKptxGQERRnunuLHEMmar7VC9syM/edit?tab=t.0#heading=h.f1qu1pb1rebn
             *
             * @param {string} $id - The order ID to cancel (format => mktor-xxxxx-xxxx-xxxx-xxxx-xxxxxxxx)
             * @param {string} [$symbol] - ellipx.cancelOrder does not use the $symbol parameter
             * @param {array} [$params] - Extra parameters specific to the exchange API
             * @return array(Promise<object>) A Promise that resolves to the canceled order info
             */
            Async\await($this->load_markets());
            $request = array(
                'orderUuid' => $id,
            );
            $response = Async\await($this->privateDeleteMarketOrderOrderUuid ($this->extend($request, $params)));
            // {
            //     result => "success",
            //     request_id => "887dba33-d11b-43f0-8034-dd7890882cc5",
            //     time => "0.8975801467895508",
            //     data => true,
            //     access => array(
            //       "mktor-rf5k5b-5fhf-dmde-wxqj-3y23jeii" => array(
            //         required => "A",
            //         available => "O",
            //       ),
            //     ),
            //   }
            // this endpoint always returns true and a warning message if the order cancelled before.
            $warningResponse = $this->safe_value($response, 'warning', null);
            $statusResponse = $this->safe_bool($response, 'data');
            $status = 'canceled';
            if ($statusResponse !== true || $warningResponse !== null) {
                $status = 'closed';
            }
            return $this->safe_order(array(
                'id' => $id,
                'clientOrderId' => null,
                'info' => $this->json($response), // original $response
                'timestamp' => null,
                'datetime' => null,
                'lastTradeTimestamp' => null,
                'status' => $status,
                'symbol' => null,
                'type' => null,
                'timeInForce' => null,
                'postOnly' => null,
                'side' => null,
                'price' => null,
                'triggerPrice' => null,
                'average' => null,
                'cost' => null,
                'amount' => null,
                'filled' => null,
                'remaining' => null,
                'fee' => null,
                'trades' => null,
            ), null);
        }) ();
    }

    public function fetch_order_trades(string $id, ?string $symbol = null, ?int $since = null, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($id, $symbol, $since, $limit, $params) {
            /**
             * fetch all the trades made from a single order
             * @param {string} $id order $id
             * @param {string} $symbol unified $market $symbol
             * @param {int} [$since] the earliest time in ms to fetch trades for
             * @param {int} [$limit] the maximum number of trades to retrieve
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array[]} a list of ~@link https://docs.ccxt.com/#/?$id=trade-structure trade structures~
             */
            if ($symbol === null) {
                throw new ArgumentsRequired('fetchMyTrades requires a $symbol parameter');
            }
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $currencyPair = $market['id'];
            $request = array(
                'Market_Order__' => $id,
                'currencyPair' => $currencyPair,
            );
            $response = Async\await($this->privateGetMarketCurrencyPairTrade ($this->extend($request, $params)));
            // {
            //     "result" => "success",
            //     "request_id" => "fc5be99d-d085-46f8-9228-e46d0996f112",
            //     "time" => 0.030913114547729492,
            //     "data" => array(
            //         {
            //             "id" => "DOGE_USDC:1731505789:911642994:0",
            //             "pair" => "DOGE_USDC",
            //             "bid" => array(
            //                 "id" => "mktor-xb3ne5-emm5-fx7e-xggk-fyfoiye4"
            //             ),
            //             "ask" => array(
            //                 "id" => "mktor-oxmac4-mtkf-gi3o-mamg-u2cboqe4"
            //             ),
            //             "type" => "bid",
            //             "amount" => array(
            //                 "v" => "334609419",
            //                 "e" => 8,
            //                 "f" => 3.34609419
            //             ),
            //             "price" => array(
            //                 "v" => "410673",
            //                 "e" => 6,
            //                 "f" => 0.410673
            //             ),
            //             "date" => array(
            //                 "unix" => 1731505789,
            //                 "us" => 911642,
            //                 "iso" => "2024-11-13 13:49:49.911642",
            //                 "tz" => "UTC",
            //                 "full" => "1731505789911642",
            //                 "unixms" => "1731505789911"
            //             }
            //         ),
            //         {
            //             "id" => "DOGE_USDC:1731505789:911642994:4",
            //             "pair" => "DOGE_USDC",
            //             "bid" => array(
            //                 "id" => "mktor-xb3ne5-emm5-fx7e-xggk-fyfoiye4"
            //             ),
            //             "ask" => array(
            //                 "id" => "mktor-cmtztk-3z3n-gupp-uqdg-74g4wjfq"
            //             ),
            //             "type" => "bid",
            //             "amount" => array(
            //                 "v" => "145453950",
            //                 "e" => 8,
            //                 "f" => 1.4545395
            //             ),
            //             "price" => array(
            //                 "v" => "412589",
            //                 "e" => 6,
            //                 "f" => 0.412589
            //             ),
            //             "date" => array(
            //                 "unix" => 1731505789,
            //                 "us" => 911642,
            //                 "iso" => "2024-11-13 13:49:49.911642",
            //                 "tz" => "UTC",
            //                 "full" => "1731505789911642",
            //                 "unixms" => "1731505789911"
            //             }
            //         ),
            //         {
            //             "id" => "DOGE_USDC:1731505789:911642994:2",
            //             "pair" => "DOGE_USDC",
            //             "bid" => array(
            //                 "id" => "mktor-xb3ne5-emm5-fx7e-xggk-fyfoiye4"
            //             ),
            //             "ask" => array(
            //                 "id" => "mktor-6tyslh-b33b-flnm-2ata-acjkco4y"
            //             ),
            //             "type" => "bid",
            //             "amount" => array(
            //                 "v" => "587627076",
            //                 "e" => 8,
            //                 "f" => 5.87627076
            //             ),
            //             "price" => array(
            //                 "v" => "411005",
            //                 "e" => 6,
            //                 "f" => 0.411005
            //             ),
            //             "date" => array(
            //                 "unix" => 1731505789,
            //                 "us" => 911642,
            //                 "iso" => "2024-11-13 13:49:49.911642",
            //                 "tz" => "UTC",
            //                 "full" => "1731505789911642",
            //                 "unixms" => "1731505789911"
            //             }
            //         ),
            //         {
            //             "id" => "DOGE_USDC:1731505789:911642994:1",
            //             "pair" => "DOGE_USDC",
            //             "bid" => array(
            //                 "id" => "mktor-xb3ne5-emm5-fx7e-xggk-fyfoiye4"
            //             ),
            //             "ask" => array(
            //                 "id" => "mktor-ihpjlj-5ufj-dm5l-fmud-oftkqcgu"
            //             ),
            //             "type" => "bid",
            //             "amount" => array(
            //                 "v" => "475845734",
            //                 "e" => 8,
            //                 "f" => 4.75845734
            //             ),
            //             "price" => array(
            //                 "v" => "410830",
            //                 "e" => 6,
            //                 "f" => 0.41083
            //             ),
            //             "date" => array(
            //                 "unix" => 1731505789,
            //                 "us" => 911642,
            //                 "iso" => "2024-11-13 13:49:49.911642",
            //                 "tz" => "UTC",
            //                 "full" => "1731505789911642",
            //                 "unixms" => "1731505789911"
            //             }
            //         ),
            //         {
            //             "id" => "DOGE_USDC:1731505789:911642994:3",
            //             "pair" => "DOGE_USDC",
            //             "bid" => array(
            //                 "id" => "mktor-xb3ne5-emm5-fx7e-xggk-fyfoiye4"
            //             ),
            //             "ask" => array(
            //                 "id" => "mktor-d2uyb3-nzsj-aevn-dikr-tq3sxhre"
            //             ),
            //             "type" => "bid",
            //             "amount" => array(
            //                 "v" => "641013461",
            //                 "e" => 8,
            //                 "f" => 6.41013461
            //             ),
            //             "price" => array(
            //                 "v" => "411846",
            //                 "e" => 6,
            //                 "f" => 0.411846
            //             ),
            //             "date" => {
            //                 "unix" => 1731505789,
            //                 "us" => 911642,
            //                 "iso" => "2024-11-13 13:49:49.911642",
            //                 "tz" => "UTC",
            //                 "full" => "1731505789911642",
            //                 "unixms" => "1731505789911"
            //             }
            //         }
            //     ),
            //     "access" => {
            //         "mkt-xrkg5l-akjz-cxxl-3a2e-mul5gfo4" => array(
            //             "required" => "r",
            //             "available" => "?"
            //         ),
            //         "mktor-xb3ne5-emm5-fx7e-xggk-fyfoiye4" => array(
            //             "required" => "R",
            //             "available" => "O"
            //         }
            //     ),
            //     "paging" => {
            //         "page_no" => 1,
            //         "count" => "5",
            //         "page_max" => 1,
            //         "results_per_page" => 20
            //     }
            // }
            $data = $this->safe_list($response, 'data');
            return $this->parse_trades($data, $market, $since, $limit);
        }) ();
    }

    public function fetch_deposit_address(string $code, $params = array ()): PromiseInterface {
        return Async\async(function () use ($code, $params) {
            /**
             * fetches a crypto deposit $address for a specific $currency
             *
             * @see https://docs.google.com/document/d/1ZXzTQYffKE_EglTaKptxGQERRnunuLHEMmar7VC9syM/edit?tab=t.0#heading=h.k7qe5aricayh
             *
             * @param {string} $code unified $currency $code (e.g. "BTC", "ETH", "USDT")
             * @param {array} [$params] extra parameters specific to the EllipX API endpoint
             * @return {array} an $address structure {
             *     'currency' => string, // unified $currency $code
             *     'address' => string, // the $address for deposits
             *     'tag' => string|null, // tag/memo for deposits if needed
             *     'network' => object, // $network object from $currency info
             *     'info' => object // raw $response from exchange
             * }
             * @throws {ExchangeError} if $currency does not support deposits
             */
            Async\await($this->load_markets());
            $currency = $this->currency($code);
            $network = $this->safe_value($currency['info'], 'Crypto_Chain', null);
            $request = array(
                'Crypto_Token__' => $this->safe_string($network, 'Crypto_Token__'),
                'Crypto_Chain__' => $this->safe_string($network, 'Crypto_Chain__'),
            );
            $response = Async\await($this->privatePostCryptoAddressFetch ($this->extend($request, $params)));
            $data = $this->safe_value($response, 'data', array());
            $address = $this->safe_string($data, 'Address');
            $tag = $this->safe_string($data, 'memo');
            $this->check_address($address);
            return array(
                'currency' => $code,
                'address' => $address,
                'tag' => $tag,
                'network' => $network,
                'info' => $response,
            );
        }) ();
    }

    public function fetch_trading_fee(?string $symbol = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $params) {
            /**
             * Fetches the current trading fees ($maker and $taker) applicable to the user.
             *
             * @see https://docs.google.com/document/d/1ZXzTQYffKE_EglTaKptxGQERRnunuLHEMmar7VC9syM/edit?tab=t.0#heading=h.kki5jay2c8it
             *
             * @param {string} [$symbol] Not used by EllipX are not $symbol-specific.
             * @param {array} [$params] Extra parameters specific to the EllipX API endpoint.
             * @return array(Promise<object>) A promise resolving to a unified trading fee structure:
             * {
             *     'info' => object,        // the raw $response from the exchange
             *     'symbol' => null,   // $symbol is not used for this exchange
             *     'maker' => number,       // $maker fee rate in decimal form
             *     'taker' => number,       // $taker fee rate in decimal form
             *     'percentage' => true,    // indicates fees are in percentage
             *     'tierBased' => false,    // indicates fees do not vary by volume tiers
             * }
             */
            Async\await($this->load_markets());
            $response = Async\await($this->privateGetMarketTradeFeeQuery ($params));
            //
            // Example $response:
            // {
            //     "result" => "success",
            //     "data" => {
            //         "maker" => 15.0,      // in basis points
            //         "taker" => 25.0,      // in basis points
            //         "volume" => 123456.78,
            //         "promo" => {
            //             // promotional discounts if any
            //         }
            //     }
            // }
            //
            $data = $this->safe_value($response, 'data', array());
            $maker = $this->safe_number($data, 'maker');  // in basis points
            $taker = $this->safe_number($data, 'taker');  // in basis points
            $makerFee = ($maker !== null) ? $maker / 10000 : null;
            $takerFee = ($taker !== null) ? $taker / 10000 : null;
            return array(
                'info' => $response,
                'symbol' => null, // the exchange only have separate fees for stablecoin pairs
                'maker' => $makerFee,
                'taker' => $takerFee,
                'percentage' => true, // fees are expressed in percentages
                'tierBased' => true,  // fees can vary based on volume tiers
            );
        }) ();
    }

    public function withdraw(string $code, float $amount, string $address, $tag = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($code, $amount, $address, $tag, $params) {
            /**
             * Make a withdrawal $request
             *
             * @see https://docs.google.com/document/d/1ZXzTQYffKE_EglTaKptxGQERRnunuLHEMmar7VC9syM/edit?tab=t.0#heading=h.zegupoa8g4t9
             *
             * @param {string} $code Currency $code
             * @param {number} $amount Amount to withdraw
             * @param {string} $address Destination wallet $address
             * @param {string} [$tag] Additional tag/memo for currencies that require it
             * @param {array} $params Extra parameters specific to the EllipX API endpoint (Crypto_Chain__, Unit__)
             * @return {array} a ~@link https://docs.ccxt.com/#/?id=transaction-structure transaction structure~
             */
            $this->check_address($address);
            Async\await($this->load_markets());
            $currency = $this->currency($code);
            $networks = $this->safe_value($currency, 'networks');
            if ($networks === null) {
                throw new NotSupported($this->id . ' withdraw() for ' . $code . ' is not supported');
            }
            $chainsResponse = Async\await($this->privateGetUnitCurrency (array( 'currency' => $currency['code'] ))); // fetch Unit__ $params for $currency
            $chainsData = $this->safe_value($chainsResponse, 'data', array());
            $unit = $this->safe_string($chainsData, 'Unit__');
            // check $params again and omit $params
            $this->omit($params, 'Unit__');
            $this->omit($params, 'Crypto_Chain__');
            $amountString = (string) $amount;
            $request = array(
                'Unit__' => $unit,
                'amount' => $amountString,
                'address' => $address,
                'Crypto_Chain__' => $networks['id'],
            );
            if ($tag !== null) {
                $request['memo'] = $tag;
            }
            $response = Async\await($this->privatePostCryptoDisbursementWithdraw ($this->extend($request, $params)));
            // {
            //     Crypto_Disbursement__ => "crdsb-4pw3kg-ipn5-amvb-da4n-6xncy4r4",
            //     Crypto_Token__ => "crtok-dnehz4-wbgv-bunf-iyd3-m7gtsz2q",
            //     Crypto_Chain__ => "chain-kjfvwn-l2xn-eclc-ul5d-mb6fu5hm",
            //     User__ => "usr-5oint6-ozpr-alfp-2wxi-zgbm4osy",
            //     Value => array(
            //       v => "1000000000",
            //       e => "8",
            //       f => "10",
            //     ),
            //     Value_USD => "4.08723",
            //     Address => "D6z62LUwyNBi3QbPkzW8C4m7VDAgu9wb2Z",
            //     Status => "pending",
            //     Transaction => null,
            //     Requested => array(
            //       unix => "1731570982",
            //       us => "203569",
            //       iso => "2024-11-14 07:56:22.203569",
            //       tz => "UTC",
            //       full => "1731570982203569",
            //       unixms => "1731570982203",
            //     ),
            //     Scheduled => null,
            //     Processed => null,
            //     Amount => array(
            //       value => "10.00000000",
            //       value_int => "1000000000",
            //       value_disp => "10.00000000",
            //       value_xint => array(
            //         v => "1000000000",
            //         e => "8",
            //         f => "10",
            //       ),
            //       display => "10.00000000DOGE",
            //       display_short => "10.00000000DOGE",
            //       $currency => "DOGE",
            //       $unit => "DOGE",
            //       has_vat => false,
            //       tax_profile => null,
            //       raw => array(
            //         value => "10.00000000",
            //         value_int => "1000000000",
            //         value_disp => "10.00000000",
            //         value_xint => array(
            //           v => "1000000000",
            //           e => "8",
            //           f => "10",
            //         ),
            //         display => "10.00000000DOGE",
            //         display_short => "10.00000000DOGE",
            //         $currency => "DOGE",
            //         $unit => "DOGE",
            //         has_vat => false,
            //         tax_profile => null,
            //       ),
            //       tax => array(
            //         value => "10.00000000",
            //         value_int => "1000000000",
            //         value_disp => "10.00000000",
            //         value_xint => array(
            //           v => "1000000000",
            //           e => "8",
            //           f => "10",
            //         ),
            //         display => "10.00000000DOGE",
            //         display_short => "10.00000000DOGE",
            //         $currency => "DOGE",
            //         $unit => "DOGE",
            //         has_vat => true,
            //         tax_profile => null,
            //       ),
            //       tax_only => array(
            //         value => "0.000",
            //         value_int => "0",
            //         value_disp => "0",
            //         value_xint => array(
            //           v => "0",
            //           e => "3",
            //           f => "0",
            //         ),
            //         display => "¥0",
            //         display_short => "¥0",
            //         $currency => "JPY",
            //         $unit => "JPY",
            //         has_vat => false,
            //         tax_profile => null,
            //       ),
            //       tax_rate => "0",
            //     ),
            //   }
            $data = $this->safe_dict($response, 'data');
            $amountResponse = $this->safe_dict($data, 'Amount');
            $requested = $this->safe_dict($data, 'Requested');
            $processed = $this->safe_dict($data, 'Processed');
            $withdrawId = $this->safe_string($data, 'Crypto_Disbursement__');
            $timestamp = $this->safe_integer($requested, 'unixms');
            return array(
                'info' => $response,
                'id' => $withdrawId,
                'txid' => null,
                'timestamp' => $timestamp,
                'datetime' => $this->iso8601($timestamp),
                'network' => $this->safe_string($data, 'Crypto_Chain__'),
                'address' => $this->safe_string($data, 'Address'),
                'addressTo' => $this->safe_string($data, 'Address'),
                'addressFrom' => null,
                'tag' => $tag,
                'tagTo' => $tag,
                'tagFrom' => null,
                'type' => 'withdrawal',
                'amount' => $this->safe_number($amountResponse, 'value'),
                'currency' => $code,
                'status' => $this->parse_transaction_status($this->safe_string($data, 'Status')),
                'updated' => $this->safe_timestamp($processed, 'unix'),
                'internal' => false,
                'comment' => null,
                'fee' => array(
                    'currency' => $code,
                    'cost' => null,  // Fee information not provided in $response
                    'rate' => null,
                ),
            );
        }) ();
    }

    public function parse_transaction_status(string $status): string {
        $statuses = array(
            'pending' => 'pending',
            'completed' => 'ok',
            'failed' => 'failed',
            'cancelled' => 'canceled',
        );
        return $this->safe_string($statuses, $status, $status);
    }

    public function parse_order_status($status) {
        $statuses = array(
            'pending' => 'open', // starting state of all orders
            'running' => 'open', // when order is being executed
            'post-pending' => 'open', // post-only order waiting to be placed
            'open' => 'open', // active order in the orderbook
            'stop' => 'open', // when stop order not yet triggered
            'invalid' => 'rejected', // order rejected
            'done' => 'closed', // order fully executed
            'cancel' => 'canceled', // order canceled by user
            'canceled' => 'canceled', // alternative spelling
        );
        return $this->safe_string($statuses, $status, $status);
    }

    public function parse_amount($amount): ?string {
        $v = $this->safe_string($amount, 'v', null);
        $e = $this->safe_integer($amount, 'e', null);
        if ($v === null || $e === null) {
            return null;
        }
        $preciseAmount = new Precise ($v);
        $preciseAmount->decimals = $e;
        $preciseAmount->reduce ();
        return (string) $preciseAmount;
    }

    public function to_amount(float $amount, float $precision): array {
        $v = (string) $amount;
        $e = $precision;
        return array(
            'v' => $v,
            'e' => $e,
        );
    }

    public function handle_errors(int $code, string $reason, string $url, string $method, array $headers, string $body, $response, $requestHeaders, $requestBody) {
        // {
        //     "code" => 404,
        //     "error" => "Not Found => Crypto\\Token(US)",
        //     "exception" => "Exception\\NotFound",
        //     "message" => "[I18N:error_not_found]",
        //     "request" => "cc83738a-2438-4f53-ae44-f15306c07f32",
        //     "result" => "error",
        //     "time" => 0.0089569091796875,
        //     "token" => "error_not_found"
        // }
        $errorCode = $this->safe_string($response, 'code');
        $message = $this->safe_string($response, 'message');
        if ($errorCode !== null) {
            $this->throw_exactly_matched_exception($this->exceptions['exact'], $errorCode, $message);
            throw new ExchangeError($this->id . ' ' . $message);
        }
        return null;
    }
}
