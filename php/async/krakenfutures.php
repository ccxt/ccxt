<?php

namespace ccxt\async;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

use Exception; // a common import
use ccxt\async\abstract\krakenfutures as Exchange;
use ccxt\ExchangeError;
use ccxt\ArgumentsRequired;
use ccxt\BadRequest;
use ccxt\DDoSProtection;
use ccxt\Precise;
use React\Async;

class krakenfutures extends Exchange {

    public function describe() {
        return $this->deep_extend(parent::describe(), array(
            'id' => 'krakenfutures',
            'name' => 'Kraken Futures',
            'countries' => array( 'US' ),
            'version' => 'v3',
            'userAgent' => null,
            'rateLimit' => 600,
            'pro' => true,
            'has' => array(
                'CORS' => null,
                'spot' => false,
                'margin' => false,
                'swap' => true,
                'future' => true,
                'option' => false,
                'cancelAllOrders' => true,
                'cancelOrder' => true,
                'createMarketOrder' => false,
                'createOrder' => true,
                'editOrder' => true,
                'fetchBalance' => true,
                'fetchBorrowRate' => false,
                'fetchBorrowRateHistories' => false,
                'fetchBorrowRateHistory' => false,
                'fetchBorrowRates' => false,
                'fetchBorrowRatesPerSymbol' => false,
                'fetchClosedOrders' => null, // https://support.kraken.com/hc/en-us/articles/360058243651-Historical-orders
                'fetchFundingHistory' => null,
                'fetchFundingRate' => false,
                'fetchFundingRateHistory' => true,
                'fetchFundingRates' => false,
                'fetchIndexOHLCV' => false,
                'fetchIsolatedPositions' => false,
                'fetchLeverageTiers' => true,
                'fetchMarketLeverageTiers' => 'emulated',
                'fetchMarkets' => true,
                'fetchMarkOHLCV' => true,
                'fetchMyTrades' => true,
                'fetchOHLCV' => true,
                'fetchOpenOrders' => true,
                'fetchOrder' => false,
                'fetchOrderBook' => true,
                'fetchOrders' => false,
                'fetchPositions' => true,
                'fetchPremiumIndexOHLCV' => false,
                'fetchTickers' => true,
                'fetchTrades' => true,
                'setLeverage' => false,
                'setMarginMode' => false,
                'transfer' => true,
            ),
            'urls' => array(
                'test' => array(
                    'public' => 'https://demo-futures.kraken.com/derivatives/api/',
                    'private' => 'https://demo-futures.kraken.com/derivatives/api/',
                    'www' => 'https://demo-futures.kraken.com',
                ),
                'logo' => 'https://user-images.githubusercontent.com/24300605/81436764-b22fd580-9172-11ea-9703-742783e6376d.jpg',
                'api' => array(
                    'charts' => 'https://futures.kraken.com/api/charts/',
                    'history' => 'https://futures.kraken.com/api/history/',
                    'feeschedules' => 'https://futures.kraken.com/api/feeschedules/',
                    'public' => 'https://futures.kraken.com/derivatives/api/',
                    'private' => 'https://futures.kraken.com/derivatives/api/',
                ),
                'www' => 'https://futures.kraken.com/',
                'doc' => array(
                    'https://support.kraken.com/hc/en-us/categories/360001806372-Futures-API',
                ),
                'fees' => 'https://support.kraken.com/hc/en-us/articles/360022835771-Transaction-fees-and-rebates-for-Kraken-Futures',
                'referral' => null,
            ),
            'api' => array(
                'public' => array(
                    'get' => array(
                        'instruments',
                        'orderbook',
                        'tickers',
                        'history',
                        'historicalfundingrates',
                    ),
                ),
                'private' => array(
                    'get' => array(
                        'openpositions',
                        'notifications',
                        'accounts',
                        'openorders',
                        'recentorders',
                        'fills',
                        'transfers',
                    ),
                    'post' => array(
                        'sendorder',
                        'editorder',
                        'cancelorder',
                        'transfer',
                        'batchorder',
                        'cancelallorders',
                        'cancelallordersafter',
                        'withdrawal',                              // for futures wallet -> kraken spot wallet
                    ),
                ),
                'charts' => array(
                    'get' => array(
                        '{price_type}/{symbol}/{interval}',
                    ),
                ),
                'history' => array(
                    'get' => array(
                        'orders',
                        'executions',
                        'triggers',
                        'accountlogcsv',
                        'market/{symbol}/orders',
                        'market/{symbol}/executions',
                    ),
                ),
                'feeschedules' => array(
                    'get' => array(
                        'volumes',
                    ),
                ),
            ),
            'fees' => array(
                'trading' => array(
                    'tierBased' => false,
                    'percentage' => true,
                    'maker' => $this->parse_number('-0.0002'),
                    'taker' => $this->parse_number('0.00075'),
                ),
            ),
            'exceptions' => array(
                'exact' => array(
                    'apiLimitExceeded' => '\\ccxt\\RateLimitExceeded',
                    'marketUnavailable' => '\\ccxt\\ExchangeNotAvailable',
                    'requiredArgumentMissing' => '\\ccxt\\BadRequest',
                    'unavailable' => '\\ccxt\\ExchangeNotAvailable',
                    'authenticationError' => '\\ccxt\\AuthenticationError',
                    'accountInactive' => '\\ccxt\\ExchangeError',              // When account has no trade history / no order history. Should this error be ignored in some cases?
                    'invalidAccount' => '\\ccxt\\BadRequest',                  // the fromAccount or the toAccount are invalid
                    'invalidAmount' => '\\ccxt\\BadRequest',
                    'insufficientFunds' => '\\ccxt\\InsufficientFunds',
                    'Bad Request' => '\\ccxt\\BadRequest',                     // The URL contains invalid characters. (Please encode the json URL parameter)
                    'Unavailable' => '\\ccxt\\InsufficientFunds',              // Insufficient funds in Futures account [withdraw]
                ),
                'broad' => array(
                    'invalidArgument' => '\\ccxt\\BadRequest',
                    'nonceBelowThreshold' => '\\ccxt\\InvalidNonce',
                    'nonceDuplicate' => '\\ccxt\\InvalidNonce',
                ),
            ),
            'precisionMode' => TICK_SIZE,
            'options' => array(
                'access' => array(
                    'history' => array(
                        'GET' => array(
                            'orders' => 'private',
                            'executions' => 'private',
                            'triggers' => 'private',
                            'accountlogcsv' => 'private',
                        ),
                    ),
                ),
                'settlementCurrencies' => array(
                    'flex' => array( 'USDT', 'BTC', 'USD', 'GBP', 'EUR', 'USDC' ),
                ),
                'symbol' => array(
                    'quoteIds' => array( 'USD', 'XBT' ),
                    'reversed' => false,
                ),
                'versions' => array(
                    'public' => array(
                        'GET' => array(
                            'historicalfundingrates' => 'v4',
                        ),
                    ),
                    'charts' => array(
                        'GET' => array(
                            '{price_type}/{symbol}/{interval}' => 'v1',
                        ),
                    ),
                    'history' => array(
                        'GET' => array(
                            'orders' => 'v2',
                            'executions' => 'v2',
                            'triggers' => 'v2',
                            'accountlogcsv' => 'v2',
                        ),
                    ),
                ),
            ),
            'timeframes' => array(
                '1m' => '1m',
                '5m' => '5m',
                '15m' => '15m',
                '30m' => '30m',
                '1h' => '1h',
                '4h' => '4h',
                '12h' => '12h',
                '1d' => '1d',
                '1w' => '1w',
            ),
        ));
    }

    public function fetch_markets($params = array ()) {
        return Async\async(function () use ($params) {
            /**
             * Fetches the available trading markets from the exchange, Multi-collateral markets are returned markets, but can be settled in multiple $currencies
             * @see https://docs.futures.kraken.com/#http-api-trading-v3-api-instrument-details-get-$instruments
             * @param {array} $params exchange specific $params
             * @return An array of $market structures
             */
            $response = Async\await($this->publicGetInstruments ($params));
            //
            //    {
            //        "result" => "success",
            //        "instruments" => array(
            //            {
            //                "symbol" => "fi_ethusd_180928",
            //                "type" => "futures_inverse", // futures_vanilla  // spot $index
            //                "underlying" => "rr_ethusd",
            //                "lastTradingTime" => "2018-09-28T15:00:00.000Z",
            //                "tickSize" => 0.1,
            //                "contractSize" => 1,
            //                "tradeable" => true,
            //                "marginLevels" => array(
            //                    array(
            //                        "contracts":0,
            //                        "initialMargin":0.02,
            //                        "maintenanceMargin":0.01
            //                    ),
            //                    array(
            //                        "contracts":250000,
            //                        "initialMargin":0.04,
            //                        "maintenanceMargin":0.02
            //                    ),
            //                    ...
            //                ),
            //                "isin" => "GB00JVMLMP88",
            //                "retailMarginLevels" => array(
            //                    array(
            //                        "contracts" => 0,
            //                        "initialMargin" => 0.5,
            //                        "maintenanceMargin" => 0.25
            //                    }
            //                ),
            //                "tags" => array(),
            //            ),
            //            {
            //                "symbol" => "in_xbtusd",
            //                "type" => "spot $index",
            //                "tradeable":false
            //            }
            //        )
            //        "serverTime" => "2018-07-19T11:32:39.433Z"
            //    }
            //
            $instruments = $this->safe_value($response, 'instruments', array());
            $result = array();
            for ($i = 0; $i < count($instruments); $i++) {
                $market = $instruments[$i];
                $id = $this->safe_string($market, 'symbol');
                $marketType = $this->safe_string($market, 'type');
                $type = null;
                $index = (mb_strpos($marketType, ' index') !== false);
                $linear = null;
                $inverse = null;
                $expiry = null;
                if (!$index) {
                    $linear = (mb_strpos($marketType, '_vanilla') !== false);
                    $inverse = !$linear;
                    $settleTime = $this->safe_string($market, 'lastTradingTime');
                    $type = ($settleTime === null) ? 'swap' : 'future';
                    $expiry = $this->parse8601($settleTime);
                } else {
                    $type = 'index';
                }
                $swap = ($type === 'swap');
                $future = ($type === 'future');
                $symbol = $id;
                $split = explode('_', $id);
                $splitMarket = $this->safe_string($split, 1);
                $baseId = mb_substr($splitMarket, 0, strlen($splitMarket) - 3 - 0);
                $quoteId = 'usd'; // always USD
                $base = $this->safe_currency_code($baseId);
                $quote = $this->safe_currency_code($quoteId);
                // $swap == perpetual
                $settle = null;
                $settleId = null;
                $amountPrecision = $this->parse_number($this->parse_precision($this->safe_string($market, 'contractValueTradePrecision', '0')));
                $pricePrecision = $this->safe_number($market, 'tickSize');
                $contract = ($swap || $future || $index);
                $swapOrFutures = ($swap || $future);
                if ($swapOrFutures) {
                    $exchangeType = $this->safe_string($market, 'type');
                    if ($exchangeType === 'futures_inverse') {
                        $settle = $base;
                        $settleId = $baseId;
                        $inverse = true;
                    } else {
                        $settle = $quote;
                        $settleId = $quoteId;
                        $inverse = false;
                    }
                    $linear = !$inverse;
                    $symbol = $base . '/' . $quote . ':' . $settle;
                    if ($future) {
                        $symbol = $symbol . '-' . $this->yymmdd($expiry);
                    }
                }
                $result[] = array(
                    'id' => $id,
                    'symbol' => $symbol,
                    'base' => $base,
                    'quote' => $quote,
                    'settle' => $settle,
                    'baseId' => $baseId,
                    'quoteId' => $quoteId,
                    'settleId' => $settleId,
                    'type' => $type,
                    'spot' => false,
                    'margin' => false,
                    'swap' => $swap,
                    'future' => $future,
                    'option' => false,
                    'index' => $index,
                    'active' => null,
                    'contract' => $contract,
                    'linear' => $linear,
                    'inverse' => $inverse,
                    'contractSize' => $this->safe_number($market, 'contractSize'),
                    'maintenanceMarginRate' => null,
                    'expiry' => $expiry,
                    'expiryDatetime' => $this->iso8601($expiry),
                    'strike' => null,
                    'optionType' => null,
                    'precision' => array(
                        'amount' => $amountPrecision,
                        'price' => $pricePrecision,
                    ),
                    'limits' => array(
                        'leverage' => array(
                            'min' => null,
                            'max' => null,
                        ),
                        'amount' => array(
                            'min' => null,
                            'max' => null,
                        ),
                        'price' => array(
                            'min' => null,
                            'max' => null,
                        ),
                        'cost' => array(
                            'min' => null,
                            'max' => null,
                        ),
                    ),
                    'info' => $market,
                );
            }
            $settlementCurrencies = $this->options['settlementCurrencies']['flex'];
            $currencies = array();
            for ($i = 0; $i < count($settlementCurrencies); $i++) {
                $code = $settlementCurrencies[$i];
                $currencies[] = array(
                    'id' => strtolower($code),
                    'numericId' => null,
                    'code' => $code,
                    'precision' => null,
                );
            }
            $this->currencies = $this->deep_extend($currencies, $this->currencies);
            return $result;
        }) ();
    }

    public function fetch_order_book(string $symbol, ?int $limit = null, $params = array ()) {
        return Async\async(function () use ($symbol, $limit, $params) {
            /**
             * Fetches a list of open orders in a $market
             * @param {string} $symbol Unified $market $symbol
             * @param {int|null} $limit Not used by krakenfutures
             * @param {array} $params exchange specific $params
             * @return An ~@link https://docs.ccxt.com/#/?id=order-book-structure order book structure~
             */
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $request = array(
                'symbol' => $market['id'],
            );
            $response = Async\await($this->publicGetOrderbook (array_merge($request, $params)));
            //
            //    {
            //       "result" => "success",
            //       "serverTime" => "2016-02-25T09:45:53.818Z",
            //       "orderBook" => array(
            //          "bids" => array(
            //                array(
            //                    4213,
            //                    2000,
            //                ),
            //                array(
            //                    4210,
            //                    4000,
            //                ),
            //                ...
            //            ),
            //            "asks" => array(
            //                array(
            //                    4218,
            //                    4000,
            //                ),
            //                array(
            //                    4220,
            //                    5000,
            //                ),
            //                ...
            //            ),
            //        ),
            //    }
            //
            $timestamp = $this->parse8601($response['serverTime']);
            return $this->parse_order_book($response['orderBook'], $symbol, $timestamp);
        }) ();
    }

    public function fetch_tickers(?array $symbols = null, $params = array ()) {
        return Async\async(function () use ($symbols, $params) {
            Async\await($this->load_markets());
            $response = Async\await($this->publicGetTickers ($params));
            //
            //    {
            //        result => 'success',
            //        $tickers => array(
            //            array(
            //                tag => 'semiannual',  // 'month', 'quarter', 'perpetual', 'semiannual',
            //                pair => 'ETH:USD',
            //                symbol => 'fi_ethusd_220624',
            //                markPrice => '2925.72',
            //                bid => '2923.8',
            //                bidSize => '16804',
            //                ask => '2928.65',
            //                askSize => '1339',
            //                vol24h => '860493',
            //                openInterest => '3023363.00000000',
            //                open24h => '3021.25',
            //                indexPrice => '2893.71',
            //                last => '2942.25',
            //                lastTime => '2022-02-18T14:08:15.578Z',
            //                lastSize => '151',
            //                suspended => false
            //            ),
            //            array(
            //                symbol => 'in_xbtusd', // 'rr_xbtusd',
            //                last => '40411',
            //                lastTime => '2022-02-18T14:16:28.000Z'
            //            ),
            //            ...
            //        ),
            //        serverTime => '2022-02-18T14:16:29.440Z'
            //    }
            //
            $tickers = $this->safe_value($response, 'tickers');
            return $this->parse_tickers($tickers, $symbols);
        }) ();
    }

    public function parse_ticker($ticker, $market = null) {
        //
        //    {
        //        tag => 'semiannual',  // 'month', 'quarter', 'perpetual', 'semiannual',
        //        pair => 'ETH:USD',
        //        $symbol => 'fi_ethusd_220624',
        //        markPrice => '2925.72',
        //        bid => '2923.8',
        //        bidSize => '16804',
        //        ask => '2928.65',
        //        askSize => '1339',
        //        vol24h => '860493',
        //        openInterest => '3023363.00000000',
        //        open24h => '3021.25',
        //        indexPrice => '2893.71',
        //        $last => '2942.25',
        //        lastTime => '2022-02-18T14:08:15.578Z',
        //        lastSize => '151',
        //        suspended => false
        //    }
        //
        //    {
        //        $symbol => 'in_xbtusd', // 'rr_xbtusd',
        //        $last => '40411',
        //        lastTime => '2022-02-18T14:16:28.000Z'
        //    }
        //
        $marketId = $this->safe_string($ticker, 'symbol');
        $market = $this->safe_market($marketId, $market);
        $symbol = $market['symbol'];
        $timestamp = $this->parse8601($this->safe_string($ticker, 'lastTime'));
        $open = $this->safe_string($ticker, 'open24h');
        $last = $this->safe_string($ticker, 'last');
        $change = Precise::string_sub($last, $open);
        $percentage = Precise::string_mul(Precise::string_div($change, $open), '100');
        $average = Precise::string_div(Precise::string_add($open, $last), '2');
        $volume = $this->safe_string($ticker, 'vol24h');
        $baseVolume = null;
        $quoteVolume = null;
        $isIndex = $this->safe_value($market, 'index', false);
        if (!$isIndex) {
            if ($market['linear']) {
                $baseVolume = $volume;
            } elseif ($market['inverse']) {
                $quoteVolume = $volume;
            }
        }
        return $this->safe_ticker(array(
            'symbol' => $symbol,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'high' => null,
            'low' => null,
            'bid' => $this->safe_string($ticker, 'bid'),
            'bidVolume' => $this->safe_string($ticker, 'bidSize'),
            'ask' => $this->safe_string($ticker, 'ask'),
            'askVolume' => $this->safe_string($ticker, 'askSize'),
            'vwap' => null,
            'open' => $open,
            'close' => $last,
            'last' => $last,
            'previousClose' => null,
            'change' => $change,
            'percentage' => $percentage,
            'average' => $average,
            'baseVolume' => $baseVolume,
            'quoteVolume' => $quoteVolume,
            'info' => $ticker,
        ));
    }

    public function fetch_ohlcv(string $symbol, $timeframe = '1m', ?int $since = null, ?int $limit = null, $params = array ()) {
        return Async\async(function () use ($symbol, $timeframe, $since, $limit, $params) {
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $request = array(
                'symbol' => $market['id'],
                'price_type' => $this->safe_string($params, 'price', 'trade'),
                'interval' => $this->timeframes[$timeframe],
            );
            $params = $this->omit($params, 'price');
            if ($since !== null) {
                $duration = $this->parse_timeframe($timeframe);
                $request['from'] = $this->parse_to_int($since / 1000);
                if ($limit === null) {
                    $limit = 5000;
                } elseif ($limit > 5000) {
                    throw new BadRequest($this->id . ' fetchOHLCV() $limit cannot exceed 5000');
                }
                $toTimestamp = $this->sum($request['from'], $limit * $duration - 1);
                $currentTimestamp = $this->seconds();
                $request['to'] = min ($toTimestamp, $currentTimestamp);
            } elseif ($limit !== null) {
                if ($limit > 5000) {
                    throw new BadRequest($this->id . ' fetchOHLCV() $limit cannot exceed 5000');
                }
                $duration = $this->parse_timeframe($timeframe);
                $request['to'] = $this->seconds();
                $request['from'] = $this->parse_to_int($request['to'] - ($duration * $limit));
            }
            $response = Async\await($this->chartsGetPriceTypeSymbolInterval (array_merge($request, $params)));
            //
            //    {
            //        "candles" => array(
            //            {
            //                "time" => 1645198500000,
            //                "open" => "309.15000000000",
            //                "high" => "309.15000000000",
            //                "low" => "308.70000000000",
            //                "close" => "308.85000000000",
            //                "volume" => 0
            //            }
            //        ),
            //        "more_candles" => true
            //    }
            //
            $candles = $this->safe_value($response, 'candles');
            return $this->parse_ohlcvs($candles, $market, $timeframe, $since, $limit);
        }) ();
    }

    public function parse_ohlcv($ohlcv, $market = null) {
        //
        //    {
        //        "time" => 1645198500000,
        //        "open" => "309.15000000000",
        //        "high" => "309.15000000000",
        //        "low" => "308.70000000000",
        //        "close" => "308.85000000000",
        //        "volume" => 0
        //    }
        //
        return array(
            $this->safe_integer($ohlcv, 'time'),       // unix timestamp in milliseconds
            $this->safe_number($ohlcv, 'open'),        // open price
            $this->safe_number($ohlcv, 'high'),        // highest price
            $this->safe_number($ohlcv, 'low'),         // lowest price
            $this->safe_number($ohlcv, 'close'),       // close price
            $this->safe_number($ohlcv, 'volume'),      // trading volume, null for mark or index price
        );
    }

    public function fetch_trades(string $symbol, ?int $since = null, ?int $limit = null, $params = array ()) {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            /**
             * @descriptions Fetch a $history of filled trades that this account has made
             * @param {string} $symbol Unified CCXT $market $symbol
             * @param {int|null} $since Timestamp in ms of earliest trade. Not used by krakenfutures except in combination with $params->until
             * @param {int|null} $limit Total number of trades, cannot exceed 100
             * @param {array} $params Exchange specific $params
             * @param {int|null} $params->until Timestamp in ms of latest trade
             * @return An array of ~@link https://docs.ccxt.com/#/?id=trade-structure trade structures~
             */
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $request = array(
                'symbol' => $market['id'],
            );
            $until = $this->safe_integer($params, 'until');
            if ($until !== null) {
                $request['lastTime'] = $this->iso8601($until);
            }
            //
            //    {
            //        "result" => "success",
            //        "history" => array(
            //            array(
            //                "time" => "2022-03-18T04:55:37.692Z",
            //                "trade_id" => 100,
            //                "price" => 0.7921,
            //                "size" => 1068,
            //                "side" => "sell",
            //                "type" => "fill",
            //                "uid" => "6c5da0b0-f1a8-483f-921f-466eb0388265"
            //            ),
            //            ...
            //        ),
            //        "serverTime" => "2022-03-18T06:39:18.056Z"
            //    }
            //
            $response = Async\await($this->publicGetHistory (array_merge($request, $params)));
            $history = $this->safe_value($response, 'history');
            return $this->parse_trades($history, $market, $since, $limit);
        }) ();
    }

    public function parse_trade($trade, $market = null) {
        //
        // fetchTrades (public)
        //
        //    {
        //        "time" => "2019-02-14T09:25:33.920Z",
        //        "trade_id" => 100,
        //        "price" => 3574,
        //        "size" => 100,
        //        "side" => "buy",
        //        "type" => "fill"                                          // fill, liquidation, assignment, termination
        //        "uid" => "11c3d82c-9e70-4fe9-8115-f643f1b162d4"
        //    }
        //
        // fetchMyTrades (private)
        //
        //    {
        //        "fillTime" => "2016-02-25T09:47:01.000Z",
        //        "order_id" => "c18f0c17-9971-40e6-8e5b-10df05d422f0",
        //        "fill_id" => "522d4e08-96e7-4b44-9694-bfaea8fe215e",
        //        "cliOrdId" => "d427f920-ec55-4c18-ba95-5fe241513b30",     // OPTIONAL
        //        "symbol" => "fi_xbtusd_180615",
        //        "side" => "buy",
        //        "size" => 2000,
        //        "price" => 4255,
        //        "fillType" => "maker"                                     // taker, takerAfterEdit, maker, liquidation, assignee
        //    }
        //
        // execution report (createOrder, editOrder)
        //
        //    {
        //        "executionId" => "e1ec9f63-2338-4c44-b40a-43486c6732d7",
        //        "price" => 7244.5,
        //        "amount" => 10,
        //        "orderPriorEdit" => null,
        //        "orderPriorExecution" => array(
        //            "orderId" => "61ca5732-3478-42fe-8362-abbfd9465294",
        //            "cliOrdId" => null,
        //            "type" => "lmt",
        //            "symbol" => "pi_xbtusd",
        //            "side" => "buy",
        //            "quantity" => 10,
        //            "filled" => 0,
        //            "limitPrice" => 7500,
        //            "reduceOnly" => false,
        //            "timestamp" => "2019-12-11T17:17:33.888Z",
        //            "lastUpdateTimestamp" => "2019-12-11T17:17:33.888Z"
        //        ),
        //        "takerReducedQuantity" => null,
        //        "type" => "EXECUTION"
        //    }
        //
        $timestamp = $this->parse8601($this->safe_string_2($trade, 'time', 'fillTime'));
        $price = $this->safe_string($trade, 'price');
        $amount = $this->safe_string_2($trade, 'size', 'amount', '0.0');
        $id = $this->safe_string_2($trade, 'uid', 'fill_id');
        if ($id === null) {
            $id = $this->safe_string($trade, 'executionId');
        }
        $order = $this->safe_string($trade, 'order_id');
        $symbolId = $this->safe_string($trade, 'symbol');
        $side = $this->safe_string($trade, 'side');
        $type = null;
        $priorEdit = $this->safe_value($trade, 'orderPriorEdit');
        $priorExecution = $this->safe_value($trade, 'orderPriorExecution');
        if ($priorExecution !== null) {
            $order = $this->safe_string($priorExecution, 'orderId');
            $symbolId = $this->safe_string($priorExecution, 'symbol');
            $side = $this->safe_string($priorExecution, 'side');
            $type = $this->safe_string($priorExecution, 'type');
        } elseif ($priorEdit !== null) {
            $order = $this->safe_string($priorEdit, 'orderId');
            $symbolId = $this->safe_string($priorEdit, 'symbol');
            $side = $this->safe_string($priorEdit, 'type');
            $type = $this->safe_string($priorEdit, 'type');
        }
        if ($type !== null) {
            $type = $this->parse_order_type($type);
        }
        $symbol = null;
        if ($symbolId !== null) {
            $market = $this->safe_value($this->markets_by_id, $symbolId);
            if ($market === null) {
                $symbol = $symbolId;
            }
        }
        $symbol = $this->safe_string($market, 'symbol', $symbol);
        $cost = null;
        if (($amount !== null) && ($price !== null) && ($market !== null)) {
            $linear = $this->safe_value($market, 'linear');
            if ($linear) {
                $cost = Precise::string_mul($amount, $price); // in quote
            } else {
                $cost = Precise::string_div($amount, $price); // in base
            }
            $contractSize = $this->safe_string($market, 'contractSize');
            $cost = Precise::string_mul($cost, $contractSize);
        }
        $takerOrMaker = null;
        $fillType = $this->safe_string($trade, 'fillType');
        if ($fillType !== null) {
            if (mb_strpos($fillType, 'taker') !== false) {
                $takerOrMaker = 'taker';
            } elseif (mb_strpos($fillType, 'maker') !== false) {
                $takerOrMaker = 'maker';
            }
        }
        return $this->safe_trade(array(
            'info' => $trade,
            'id' => $id,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'symbol' => $symbol,
            'order' => $order,
            'type' => $type,
            'side' => $side,
            'takerOrMaker' => $takerOrMaker,
            'price' => $price,
            'amount' => $amount,
            'cost' => $cost,
            'fee' => null,
        ));
    }

    public function create_order(string $symbol, string $type, string $side, $amount, $price = null, $params = array ()) {
        return Async\async(function () use ($symbol, $type, $side, $amount, $price, $params) {
            /**
             * Create an order on the exchange
             * @param {string} $symbol market $symbol
             * @param {string} $type One of 'limit', 'market', 'take_profit'
             * @param {string} $side buy or sell
             * @param {int} $amount Contract quantity
             * @param {float} $price Limit order $price
             * @param {float|null} $params->stopPrice The stop $price associated with a stop or take profit order, Required if orderType is stp or take_profit, Must not have more than 2 decimal places, Note that for stop orders, limitPrice denotes the worst $price at which the stop or take_profit order can get filled at. If no limitPrice is provided the stop or take_profit order will trigger a market order,
             * @param {bool|null} $params->reduceOnly Set if you wish the order to only reduce an existing position, Any order which increases an existing position will be rejected, Default false,
             * @param {bool|null} $params->postOnly Set if you wish to make a $postOnly order, Default false
             * @param {string|null} $params->triggerSignal If placing a stp or take_profit, the signal used for trigger, One of => 'mark', 'index', 'last', last is market $price
             * @param {string|null} $params->cliOrdId UUID The order identity that is specified from the user, It must be globally unique
             * @param {string|null} $params->clientOrderId UUID The order identity that is specified from the user, It must be globally unique
             */
            Async\await($this->load_markets());
            $type = $this->safe_string($params, 'orderType', $type);
            $timeInForce = $this->safe_string($params, 'timeInForce');
            $stopPrice = $this->safe_string($params, 'stopPrice');
            $postOnly = false;
            list($postOnly, $params) = $this->handle_post_only($type === 'market', $type === 'post', $params);
            $clientOrderId = $this->safe_string_2($params, 'clientOrderId', 'cliOrdId');
            $params = $this->omit($params, array( 'clientOrderId', 'cliOrdId' ));
            if (($type === 'stp' || $type === 'take_profit') && $stopPrice === null) {
                throw new ArgumentsRequired($this->id . ' createOrder requires $params->stopPrice when $type is ' . $type);
            }
            if ($stopPrice !== null && $type !== 'take_profit') {
                $type = 'stp';
            } elseif ($postOnly) {
                $type = 'post';
            } elseif ($timeInForce === 'ioc') {
                $type = 'ioc';
            } elseif ($type === 'limit') {
                $type = 'lmt';
            } elseif ($type === 'market') {
                $type = 'mkt';
            }
            $request = array(
                'orderType' => $type,
                'symbol' => $this->market_id($symbol),
                'side' => $side,
                'size' => $amount,
            );
            if ($price !== null) {
                $request['limitPrice'] = $price;
            }
            if ($clientOrderId !== null) {
                $request['cliOrdId'] = $clientOrderId;
            }
            $response = Async\await($this->privatePostSendorder (array_merge($request, $params)));
            //
            //    {
            //        "result" => "success",
            //        "sendStatus" => {
            //            "order_id" => "salf320-e337-47ac-b345-30sdfsalj",
            //            "status" => "placed",
            //            "receivedTime" => "2022-02-28T19:32:17.122Z",
            //            "orderEvents" => array(
            //                array(
            //                    "order" => array(
            //                        "orderId" => "salf320-e337-47ac-b345-30sdfsalj",
            //                        "cliOrdId" => null,
            //                        "type" => "lmt",
            //                        "symbol" => "pi_xrpusd",
            //                        "side" => "buy",
            //                        "quantity" => 1,
            //                        "filled" => 0,
            //                        "limitPrice" => 0.7,
            //                        "reduceOnly" => false,
            //                        "timestamp" => "2022-02-28T19:32:17.122Z",
            //                        "lastUpdateTimestamp" => "2022-02-28T19:32:17.122Z"
            //                    ),
            //                    "reducedQuantity" => null,
            //                    "type" => "PLACE"
            //                }
            //            )
            //        ),
            //        "serverTime" => "2022-02-28T19:32:17.122Z"
            //    }
            //
            $sendStatus = $this->safe_value($response, 'sendStatus');
            $status = $this->safe_string($sendStatus, 'status');
            $this->verify_order_action_success($status, 'createOrder', array( 'filled' ));
            return $this->parse_order($sendStatus);
        }) ();
    }

    public function edit_order(string $id, $symbol, $type, $side, $amount = null, $price = null, $params = array ()) {
        return Async\async(function () use ($id, $symbol, $type, $side, $amount, $price, $params) {
            /**
             * Edit an open $order on the exchange
             * @param {string} $id $order $id
             * @param {string} $symbol Not used by Krakenfutures
             * @param {string} $type Not used by Krakenfutures
             * @param {string} $side Not used by Krakenfutures
             * @param {float|null} $amount Order size
             * @param {float|null} $price Price to fill $order at
             * @param {array} $params Exchange specific $params
             * @return An ~@link https://docs.ccxt.com/#/?$id=$order-structure $order structure~
             */
            Async\await($this->load_markets());
            $request = array(
                'orderId' => $id,
            );
            if ($amount !== null) {
                $request['size'] = $amount;
            }
            if ($price !== null) {
                $request['limitPrice'] = $price;
            }
            $response = Async\await($this->privatePostEditorder (array_merge($request, $params)));
            $status = $this->safe_string($response['editStatus'], 'status');
            $this->verify_order_action_success($status, 'editOrder', array( 'filled' ));
            $order = $this->parse_order($response['editStatus']);
            return array_merge(array( 'info' => $response ), $order);
        }) ();
    }

    public function cancel_order(string $id, ?string $symbol = null, $params = array ()) {
        return Async\async(function () use ($id, $symbol, $params) {
            /**
             * @param {string} $id Order $id
             * @param {string|null} $symbol Not used by Krakenfutures
             * @param {array} $params Exchange specific $params
             * @return An ~@link https://docs.ccxt.com/#/?$id=$order-structure $order structure~
             */
            Async\await($this->load_markets());
            $response = Async\await($this->privatePostCancelorder (array_merge(array( 'order_id' => $id ), $params)));
            $status = $this->safe_string($this->safe_value($response, 'cancelStatus', array()), 'status');
            $this->verify_order_action_success($status, 'cancelOrder');
            $order = array();
            if (is_array($response) && array_key_exists('cancelStatus', $response)) {
                $order = $this->parse_order($response['cancelStatus']);
            }
            return array_merge(array( 'info' => $response ), $order);
        }) ();
    }

    public function cancel_all_orders(?string $symbol = null, $params = array ()) {
        return Async\async(function () use ($symbol, $params) {
            /**
             * Cancels all orders on the exchange, including trigger orders
             * @param {str} $symbol Unified market $symbol
             * @param {dict} $params Exchange specific $params
             * @return Response from exchange api
             */
            $request = array();
            if ($symbol !== null) {
                $request['symbol'] = $this->market_id($symbol);
            }
            $response = Async\await($this->privatePostCancelallorders (array_merge($request, $params)));
            return $response;
        }) ();
    }

    public function fetch_open_orders(?string $symbol = null, ?int $since = null, ?int $limit = null, $params = array ()) {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            /**
             * Gets all open $orders, including trigger $orders, for an account from the exchange api
             * @param {string} $symbol Unified $market $symbol
             * @param {int} $since Timestamp (ms) of earliest order. (Not used by kraken api but filtered internally by CCXT)
             * @param {int} $limit How many $orders to return. (Not used by kraken api but filtered internally by CCXT)
             * @param {array} $params Exchange specific parameters
             * @return An array of ~@link https://docs.ccxt.com/#/?id=order-structure order structures~
             */
            Async\await($this->load_markets());
            $market = null;
            if ($symbol !== null) {
                $market = $this->market($symbol);
            }
            $response = Async\await($this->privateGetOpenorders ($params));
            $orders = $this->safe_value($response, 'openOrders', array());
            return $this->parse_orders($orders, $market, $since, $limit);
        }) ();
    }

    public function parse_order_type($orderType) {
        $map = array(
            'lmt' => 'limit',
            'mkt' => 'market',
            'post' => 'limit',
            'ioc' => 'market',
        );
        return $this->safe_string($map, $orderType, $orderType);
    }

    public function verify_order_action_success($status, $method, $omit = []) {
        $errors = array(
            'invalidOrderType' => '\\ccxt\\InvalidOrder',
            'invalidSide' => '\\ccxt\\InvalidOrder',
            'invalidSize' => '\\ccxt\\InvalidOrder',
            'invalidPrice' => '\\ccxt\\InvalidOrder',
            'insufficientAvailableFunds' => '\\ccxt\\InsufficientFunds',
            'selfFill' => '\\ccxt\\ExchangeError',
            'tooManySmallOrders' => '\\ccxt\\ExchangeError',
            'maxPositionViolation' => '\\ccxt\\BadRequest',
            'marketSuspended' => '\\ccxt\\ExchangeNotAvailable',
            'marketInactive' => '\\ccxt\\ExchangeNotAvailable',
            'clientOrderIdAlreadyExist' => '\\ccxt\\DuplicateOrderId',
            'clientOrderIdTooLong' => '\\ccxt\\BadRequest',
            'outsidePriceCollar' => '\\ccxt\\InvalidOrder',
            'postWouldExecute' => '\\ccxt\\OrderImmediatelyFillable',  // the unplaced order could actually be parsed (with $status = "rejected"), but there is this specific error for this
            'iocWouldNotExecute' => '\\ccxt\\OrderNotFillable', // -||-
            'wouldNotReducePosition' => '\\ccxt\\ExchangeError',
            'orderForEditNotFound' => '\\ccxt\\OrderNotFound',
            'orderForEditNotAStop' => '\\ccxt\\InvalidOrder',
            'filled' => '\\ccxt\\OrderNotFound',
            'notFound' => '\\ccxt\\OrderNotFound',
        );
        if ((is_array($errors) && array_key_exists($status, $errors)) && !$this->in_array($status, $omit)) {
            throw new $errors[$status]($this->id . ' => ' . $method . ' failed due to ' . $status);
        }
    }

    public function parse_order_status($status) {
        $statuses = array(
            'placed' => 'open', // the order was placed successfully
            'cancelled' => 'canceled', // the order was cancelled successfully
            'invalidOrderType' => 'rejected', // the order was not placed because orderType is invalid
            'invalidSide' => 'rejected', // the order was not placed because side is invalid
            'invalidSize' => 'rejected', // the order was not placed because size is invalid
            'invalidPrice' => 'rejected', // the order was not placed because limitPrice and/or stopPrice are invalid
            'insufficientAvailableFunds' => 'rejected', // the order was not placed because available funds are insufficient
            'selfFill' => 'rejected', // the order was not placed because it would be filled against an existing order belonging to the same account
            'tooManySmallOrders' => 'rejected', // the order was not placed because the number of small open orders would exceed the permissible limit
            'maxPositionViolation' => 'rejected', // Order would cause you to exceed your maximum position in this contract.
            'marketSuspended' => 'rejected', // the order was not placed because the market is suspended
            'marketInactive' => 'rejected', // the order was not placed because the market is inactive
            'clientOrderIdAlreadyExist' => 'rejected', // the specified client id already exist
            'clientOrderIdTooLong' => 'rejected', // the client id is longer than the permissible limit
            'outsidePriceCollar' => 'rejected', // the limit order crosses the spread but is an order of magnitude away from the mark price - fat finger control
            // Should the next two be 'expired' ?
            'postWouldExecute' => 'rejected', // the post-only order would be filled upon placement, thus is cancelled
            'iocWouldNotExecute' => 'rejected', // the immediate-or-cancel order would not execute.
            'wouldNotReducePosition' => 'rejected', // the reduce only order would not reduce position.
            'edited' => 'open', // the order was edited successfully
            'orderForEditNotFound' => 'rejected', // the requested order for edit has not been found
            'orderForEditNotAStop' => 'rejected', // the supplied stopPrice cannot be applied because order is not a stop order
            'filled' => 'closed', // the order was found completely filled and could not be cancelled
            'notFound' => 'rejected', // the order was not found, either because it had already been cancelled or it never existed
            'untouched' => 'open', // the entire size of the order is unfilled
            'partiallyFilled' => 'open', // the size of the order is partially but not entirely filled
        );
        return $this->safe_string($statuses, $status, $status);
    }

    public function parse_order($order, $market = null) {
        //
        // LIMIT
        //
        //    {
        //        "order_id" => "179f9af8-e45e-469d-b3e9-2fd4675cb7d0",
        //        "status" => "placed",
        //        "receivedTime" => "2019-09-05T16:33:50.734Z",
        //        "orderEvents" => array(
        //            {
        //                "uid" => "614a5298-0071-450f-83c6-0617ce8c6bc4",
        //                "order" => array(
        //                    "orderId" => "179f9af8-e45e-469d-b3e9-2fd4675cb7d0",
        //                    "cliOrdId" => null,
        //                    "type" => "lmt",
        //                    "symbol" => "pi_xbtusd",
        //                    "side" => "buy",
        //                    "quantity" => 10000,
        //                    "filled" => 0,
        //                    "limitPrice" => 9400,
        //                    "reduceOnly" => false,
        //                    "timestamp" => "2019-09-05T16:33:50.734Z",
        //                    "lastUpdateTimestamp" => "2019-09-05T16:33:50.734Z"
        //                ),
        //                "reducedQuantity" => null,
        //                "reason" => "WOULD_NOT_REDUCE_POSITION", // REJECTED
        //                "type" => "PLACE"
        //            }
        //        )
        //    }
        //
        // CONDITIONAL
        //
        //    {
        //        "order_id" => "1abfd3c6-af93-4b30-91cc-e4a93797f3f5",
        //        "status" => "placed",
        //        "receivedTime" => "2019-12-05T10:20:50.701Z",
        //        "orderEvents" => array(
        //            {
        //                "orderTrigger" => array(
        //                    "uid" => "1abfd3c6-af93-4b30-91cc-e4a93797f3f5",
        //                    "clientId":null,
        //                    "type" => "lmt",                                // "ioc" if stop $market
        //                    "symbol" => "pi_xbtusd",
        //                    "side" => "buy",
        //                    "quantity":10,
        //                    "limitPrice":15000,
        //                    "triggerPrice":9500,
        //                    "triggerSide" => "trigger_below",
        //                    "triggerSignal" => "mark_price",
        //                    "reduceOnly":false,
        //                    "timestamp" => "2019-12-05T10:20:50.701Z",
        //                    "lastUpdateTimestamp" => "2019-12-05T10:20:50.701Z"
        //                ),
        //                "type" => "PLACE"
        //            }
        //        )
        //    }
        //
        // EXECUTION
        //
        //    {
        //        "order_id" => "61ca5732-3478-42fe-8362-abbfd9465294",
        //        "status" => "placed",
        //        "receivedTime" => "2019-12-11T17:17:33.888Z",
        //        "orderEvents" => array(
        //            {
        //                "executionId" => "e1ec9f63-2338-4c44-b40a-43486c6732d7",
        //                "price" => 7244.5,
        //                "amount" => 10,
        //                "orderPriorEdit" => null,
        //                "orderPriorExecution" => array(
        //                    "orderId" => "61ca5732-3478-42fe-8362-abbfd9465294",
        //                    "cliOrdId" => null,
        //                    "type" => "lmt",
        //                    "symbol" => "pi_xbtusd",
        //                    "side" => "buy",
        //                    "quantity" => 10,
        //                    "filled" => 0,
        //                    "limitPrice" => 7500,
        //                    "reduceOnly" => false,
        //                    "timestamp" => "2019-12-11T17:17:33.888Z",
        //                    "lastUpdateTimestamp" => "2019-12-11T17:17:33.888Z"
        //                ),
        //                "takerReducedQuantity" => null,
        //                "type" => "EXECUTION"
        //            }
        //        )
        //    }
        //
        // EDIT ORDER
        //
        //    {
        //        "status" => "edited",
        //        "orderId" => "022774bc-2c4a-4f26-9317-436c8d85746d",
        //        "receivedTime" => "2019-09-05T16:47:47.521Z",
        //        "orderEvents" => array(
        //            {
        //                "old" => array(
        //                    "orderId" => "022774bc-2c4a-4f26-9317-436c8d85746d",
        //                    "cliOrdId":null,
        //                    "type" => "lmt",
        //                    "symbol" => "pi_xbtusd",
        //                    "side" => "buy",
        //                    "quantity":1000,
        //                    "filled":0,
        //                    "limitPrice":9400.0,
        //                    "reduceOnly":false,
        //                    "timestamp" => "2019-09-05T16:41:35.173Z",
        //                    "lastUpdateTimestamp" => "2019-09-05T16:41:35.173Z"
        //                ),
        //                "new" => array(
        //                    "orderId" => "022774bc-2c4a-4f26-9317-436c8d85746d",
        //                    "cliOrdId" => null,
        //                    "type" => "lmt",
        //                    "symbol" => "pi_xbtusd",
        //                    "side" => "buy",
        //                    "quantity" => 1501,
        //                    "filled" => 0,
        //                    "limitPrice" => 7200,
        //                    "reduceOnly" => false,
        //                    "timestamp" => "2019-09-05T16:41:35.173Z",
        //                    "lastUpdateTimestamp" => "2019-09-05T16:47:47.519Z"
        //                ),
        //                "reducedQuantity" => null,
        //                "type" => "EDIT"
        //            }
        //        )
        //    }
        //
        // CANCEL ORDER
        //
        //    {
        //        "status" => "cancelled",
        //        "orderEvents" => array(
        //            {
        //                "uid" => "85c40002-3f20-4e87-9302-262626c3531b",
        //                "order" => array(
        //                    "orderId" => "85c40002-3f20-4e87-9302-262626c3531b",
        //                    "cliOrdId" => null,
        //                    "type" => "lmt",
        //                    "symbol" => "pi_xbtusd",
        //                    "side" => "buy",
        //                    "quantity" => 1000,
        //                    "filled" => 0,
        //                    "limitPrice" => 10144,
        //                    "stopPrice" => null,
        //                    "reduceOnly" => false,
        //                    "timestamp" => "2019-08-01T15:26:27.790Z"
        //                ),
        //                "type" => "CANCEL"
        //            }
        //        )
        //    }
        //
        // FETCH OPEN ORDERS
        //
        //    {
        //        "order_id" => "59302619-41d2-4f0b-941f-7e7914760ad3",
        //        "symbol" => "pi_xbtusd",
        //        "side" => "sell",
        //        "orderType" => "lmt",
        //        "limitPrice" => 10640,
        //        "unfilledSize" => 304,
        //        "receivedTime" => "2019-09-05T17:01:17.410Z",
        //        "status" => "untouched",
        //        "filledSize" => 0,
        //        "reduceOnly" => true,
        //        "lastUpdateTime" => "2019-09-05T17:01:17.410Z"
        //    }
        //
        $orderEvents = $this->safe_value($order, 'orderEvents', array());
        $details = null;
        $isPrior = false;
        $fixed = false;
        $statusId = null;
        $price = null;
        $trades = array();
        if (strlen($orderEvents) > 0) {
            $executions = array();
            for ($i = 0; $i < count($orderEvents); $i++) {
                $item = $orderEvents[$i];
                if ($this->safe_string($item, 'type') === 'EXECUTION') {
                    $executions[] = $item;
                }
                // Final $order (after placement / editing / execution / canceling)
                $orderTrigger = $this->safe_value($item, 'orderTrigger');
                $details = $this->safe_value_2($item, 'new', 'order', $orderTrigger);
                if ($details !== null) {
                    $isPrior = false;
                    $fixed = true;
                } elseif (!$fixed) {
                    $orderPriorExecution = $this->safe_value($item, 'orderPriorExecution');
                    $details = $this->safe_value_2($item, 'orderPriorExecution', 'orderPriorEdit');
                    $price = $this->safe_string($orderPriorExecution, 'limitPrice');
                    if ($details !== null) {
                        $isPrior = true;
                    }
                }
            }
            $trades = $this->parse_trades($executions);
            $statusId = $this->safe_string($order, 'status');
        }
        if ($details === null) {
            $details = $order;
        }
        if ($statusId === null) {
            $statusId = $this->safe_string($details, 'status');
        }
        // This may be incorrectly marked as "open" if only execution report is given,
        // but will be $fixed below
        $status = $this->parse_order_status($statusId);
        $isClosed = $this->in_array($status, array( 'canceled', 'rejected', 'closed' ));
        $marketId = $this->safe_string($details, 'symbol');
        $market = $this->safe_market($marketId, $market);
        $timestamp = $this->parse8601($this->safe_string_2($details, 'timestamp', 'receivedTime'));
        if ($price === null) {
            $price = $this->safe_string($details, 'limitPrice');
        }
        $amount = $this->safe_string($details, 'quantity');
        $filled = $this->safe_string_2($details, 'filledSize', 'filled', '0.0');
        $remaining = $this->safe_string($details, 'unfilledSize');
        $average = null;
        $filled2 = '0.0';
        if (strlen($trades) > 0) {
            $vwapSum = '0.0';
            for ($i = 0; $i < count($trades); $i++) {
                $trade = $trades[$i];
                $tradeAmount = $this->safe_string($trade, 'amount');
                $tradePrice = $this->safe_string($trade, 'price');
                $filled2 = Precise::string_add($filled2, $tradeAmount);
                $vwapSum = Precise::string_add($vwapSum, Precise::string_mul($tradeAmount, $tradePrice));
            }
            $average = Precise::string_div($vwapSum, $filled2);
            if (($amount !== null) && (!$isClosed) && $isPrior && Precise::string_ge($filled2, $amount)) {
                $status = 'closed';
                $isClosed = true;
            }
            if ($isPrior) {
                $filled = Precise::string_add($filled, $filled2);
            } else {
                $filled = Precise::string_max($filled, $filled2);
            }
        }
        if ($remaining === null) {
            if ($isPrior) {
                if ($amount !== null) {
                    // $remaining $amount before execution minus executed $amount
                    $remaining = Precise::string_sub($amount, $filled2);
                }
            } else {
                $remaining = $amount;
            }
        }
        // if fetchOpenOrders are parsed
        if (($amount === null) && (!$isPrior) && ($remaining !== null)) {
            $amount = Precise::string_add($filled, $remaining);
        }
        $cost = null;
        if (($filled !== null) && ($market !== null)) {
            $whichPrice = ($average !== null) ? $average : $price;
            if ($whichPrice !== null) {
                if ($market['linear']) {
                    $cost = Precise::string_mul($filled, $whichPrice); // in quote
                } else {
                    $cost = Precise::string_div($filled, $whichPrice); // in base
                }
            }
        }
        $id = $this->safe_string_2($order, 'order_id', 'orderId');
        if ($id === null) {
            $id = $this->safe_string_2($details, 'orderId', 'uid');
        }
        $type = $this->safe_string_lower_2($details, 'type', 'orderType');
        $timeInForce = 'gtc';
        if ($type === 'ioc' || $this->parse_order_type($type) === 'market') {
            $timeInForce = 'ioc';
        }
        return $this->safe_order(array(
            'info' => $order,
            'id' => $id,
            'clientOrderId' => $this->safe_string_2($details, 'clientOrderId', 'clientId'),
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'lastTradeTimestamp' => null,
            'symbol' => $this->safe_string($market, 'symbol'),
            'type' => $this->parse_order_type($type),
            'timeInForce' => $timeInForce,
            'postOnly' => $type === 'post',
            'side' => $this->safe_string($details, 'side'),
            'price' => $price,
            'stopPrice' => $this->safe_string($details, 'triggerPrice'),
            'triggerPrice' => $this->safe_string($details, 'triggerPrice'),
            'amount' => $amount,
            'cost' => $cost,
            'average' => $average,
            'filled' => $filled,
            'remaining' => $remaining,
            'status' => $status,
            'fee' => null,
            'fees' => null,
            'trades' => $trades,
        ));
    }

    public function fetch_my_trades(?string $symbol = null, ?int $since = null, ?int $limit = null, $params = array ()) {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            Async\await($this->load_markets());
            $market = null;
            if ($symbol !== null) {
                $market = $this->market($symbol);
            }
            $response = Async\await($this->privateGetFills ($params));
            //
            //    {
            //        "result" => "success",
            //        "serverTime" => "2016-02-25T09:45:53.818Z",
            //        "fills" => array(
            //            array(
            //                "fillTime" => "2016-02-25T09:47:01.000Z",
            //                "order_id" => "c18f0c17-9971-40e6-8e5b-10df05d422f0",
            //                "fill_id" => "522d4e08-96e7-4b44-9694-bfaea8fe215e",
            //                "cliOrdId" => "d427f920-ec55-4c18-ba95-5fe241513b30", // EXTRA
            //                "symbol" => "fi_xbtusd_180615",
            //                "side" => "buy",
            //                "size" => 2000,
            //                "price" => 4255,
            //                "fillType" => "maker"
            //            ),
            //            ...
            //        )
            //    }
            //
            return $this->parse_trades($response['fills'], $market, $since, $limit);
        }) ();
    }

    public function fetch_balance($params = array ()) {
        return Async\async(function () use ($params) {
            /**
             * Fetch the $balance for a sub-$account, all sub-$account balances are inside 'info' in the $response
             * @param {array} $params Exchange specific parameters
             * @param {string} $params->type The sub-$account $type to query the $balance of, possible values include 'flex', 'cash'/'main'/'funding', or a market $symbol * defaults to 'cash' *
             * @param {string} $params->symbol A unified market $symbol, when assigned the $balance for a trading market that matches the $symbol is returned
             * @return A ~@link https://docs.ccxt.com/#/?id=$balance-structure $balance structure~
             */
            Async\await($this->load_markets());
            $type = $this->safe_string_2($params, 'type', 'account');
            $symbol = $this->safe_string($params, 'symbol');
            $params = $this->omit($params, array( 'type', 'account', 'symbol' ));
            $response = Async\await($this->privateGetAccounts ($params));
            //
            //    {
            //        result => 'success',
            //        $accounts => {
            //            fi_xbtusd => array(
            //                auxiliary => array( usd => '0', pv => '0.0', pnl => '0.0', af => '0.0', funding => '0.0' ),
            //                marginRequirements => array( im => '0.0', mm => '0.0', lt => '0.0', tt => '0.0' ),
            //                triggerEstimates => array( im => '0', mm => '0', lt => '0', tt => '0' ),
            //                balances => array( xbt => '0.0' ),
            //                currency => 'xbt',
            //                $type => 'marginAccount'
            //            ),
            //            cash => array(
            //                balances => array(
            //                    eur => '0.0',
            //                    gbp => '0.0',
            //                    bch => '0.0',
            //                    xrp => '2.20188538338',
            //                    usd => '0.0',
            //                    eth => '0.0',
            //                    usdt => '0.0',
            //                    ltc => '0.0',
            //                    usdc => '0.0',
            //                    xbt => '0.0'
            //                ),
            //                $type => 'cashAccount'
            //            ),
            //            fv_xrpxbt => array(
            //                auxiliary => array( usd => '0', pv => '0.0', pnl => '0.0', af => '0.0', funding => '0.0' ),
            //                marginRequirements => array( im => '0.0', mm => '0.0', lt => '0.0', tt => '0.0' ),
            //                triggerEstimates => array( im => '0', mm => '0', lt => '0', tt => '0' ),
            //                balances => array( xbt => '0.0' ),
            //                currency => 'xbt',
            //                $type => 'marginAccount'
            //            ),
            //            fi_xrpusd => array(
            //                auxiliary => array( usd => '0', pv => '11.0', pnl => '0.0', af => '11.0', funding => '0.0' ),
            //                marginRequirements => array( im => '0.0', mm => '0.0', lt => '0.0', tt => '0.0' ),
            //                triggerEstimates => array( im => '0', mm => '0', lt => '0', tt => '0' ),
            //                balances => array( xrp => '11.0' ),
            //                currency => 'xrp',
            //                $type => 'marginAccount'
            //            ),
            //            fi_ethusd => array(
            //                auxiliary => array( usd => '0', pv => '0.0', pnl => '0.0', af => '0.0', funding => '0.0' ),
            //                marginRequirements => array( im => '0.0', mm => '0.0', lt => '0.0', tt => '0.0' ),
            //                triggerEstimates => array( im => '0', mm => '0', lt => '0', tt => '0' ),
            //                balances => array( eth => '0.0' ),
            //                currency => 'eth',
            //                $type => 'marginAccount'
            //            ),
            //            fi_ltcusd => array(
            //                auxiliary => array( usd => '0', pv => '0.0', pnl => '0.0', af => '0.0', funding => '0.0' ),
            //                marginRequirements => array( im => '0.0', mm => '0.0', lt => '0.0', tt => '0.0' ),
            //                triggerEstimates => array( im => '0', mm => '0', lt => '0', tt => '0' ),
            //                balances => array( ltc => '0.0' ),
            //                currency => 'ltc',
            //                $type => 'marginAccount'
            //            ),
            //            fi_bchusd => array(
            //                auxiliary => array( usd => '0', pv => '0.0', pnl => '0.0', af => '0.0', funding => '0.0' ),
            //                marginRequirements => array( im => '0.0', mm => '0.0', lt => '0.0', tt => '0.0' ),
            //                triggerEstimates => array( im => '0', mm => '0', lt => '0', tt => '0' ),
            //                balances => array( bch => '0.0' ),
            //                currency => 'bch',
            //                $type => 'marginAccount'
            //            ),
            //            flex => array(
            //                currencies => array(),
            //                initialMargin => '0.0',
            //                initialMarginWithOrders => '0.0',
            //                maintenanceMargin => '0.0',
            //                balanceValue => '0.0',
            //                portfolioValue => '0.0',
            //                collateralValue => '0.0',
            //                pnl => '0.0',
            //                unrealizedFunding => '0.0',
            //                totalUnrealized => '0.0',
            //                totalUnrealizedAsMargin => '0.0',
            //                availableMargin => '0.0',
            //                marginEquity => '0.0',
            //                $type => 'multiCollateralMarginAccount'
            //            }
            //        ),
            //        serverTime => '2022-04-12T07:48:07.475Z'
            //    }
            //
            $datetime = $this->safe_string($response, 'serverTime');
            if ($type === 'marginAccount' || $type === 'margin') {
                if ($symbol === null) {
                    throw new ArgumentsRequired($this->id . ' fetchBalance requires $symbol argument for margin accounts');
                }
                $type = $symbol;
            }
            if ($type === null) {
                $type = ($symbol === null) ? 'cash' : $symbol;
            }
            $accountName = $this->parse_account($type);
            $accounts = $this->safe_value($response, 'accounts');
            $account = $this->safe_value($accounts, $accountName);
            if ($account === null) {
                $type = ($type === null) ? '' : $type;
                $symbol = ($symbol === null) ? '' : $symbol;
                throw new BadRequest($this->id . ' fetchBalance has no $account for ' . $type);
            }
            $balance = $this->parse_balance($account);
            return array_merge(array(
                'info' => $response,
                'timestamp' => $this->parse8601($datetime),
                'datetime' => $datetime,
            ), $balance);
        }) ();
    }

    public function parse_balance($response) {
        //
        // cashAccount
        //
        //    {
        //        $balances => array(
        //            eur => '0.0',
        //            gbp => '0.0',
        //            bch => '0.0',
        //            xrp => '2.20188538338',
        //            usd => '0.0',
        //            eth => '0.0',
        //            usdt => '0.0',
        //            ltc => '0.0',
        //            usdc => '0.0',
        //            xbt => '0.0'
        //        ),
        //        type => 'cashAccount'
        //    }
        //
        // marginAccount e,g, fi_xrpusd
        //
        //    {
        //        $auxiliary => array(
        //            usd => '0',
        //            pv => '11.0',
        //            pnl => '0.0',
        //            af => '11.0',
        //            funding => '0.0'
        //        ),
        //        marginRequirements => array( im => '0.0', mm => '0.0', lt => '0.0', tt => '0.0' ),
        //        triggerEstimates => array( im => '0', mm => '0', lt => '0', tt => '0' ),
        //        $balances => array( xrp => '11.0' ),
        //        currency => 'xrp',
        //        type => 'marginAccount'
        //    }
        //
        // flex/multiCollateralMarginAccount
        //
        //    {
        //       currencies => {
        //            USDT => array(
        //                quantity => '1',
        //                value => '1.0001',
        //                collateral => '0.9477197625',
        //                available => '1.0'
        //             }
        //       ),
        //       initialMargin => '0.0',
        //       initialMarginWithOrders => '0.0',
        //       maintenanceMargin => '0.0',
        //       balanceValue => '1.0',
        //       portfolioValue => '1.0',
        //       collateralValue => '0.95',
        //       pnl => '0.0',
        //       unrealizedFunding => '0.0',
        //       totalUnrealized => '0.0',
        //       totalUnrealizedAsMargin => '0.0',
        //       availableMargin => '0.95',
        //       marginEquity => '0.95',
        //       type => 'multiCollateralMarginAccount'
        //    }
        //
        $accountType = $this->safe_string_2($response, 'accountType', 'type');
        $isFlex = ($accountType === 'multiCollateralMarginAccount');
        $isCash = ($accountType === 'cashAccount');
        $balances = $this->safe_value_2($response, 'balances', 'currencies', array());
        $result = array();
        $currencyIds = is_array($balances) ? array_keys($balances) : array();
        for ($i = 0; $i < count($currencyIds); $i++) {
            $currencyId = $currencyIds[$i];
            $balance = $balances[$currencyId];
            $code = $this->safe_currency_code($currencyId);
            $splitCode = explode('_', $code);
            $codeLength = count($splitCode);
            if ($codeLength > 1) {
                continue;   // Removes contract codes like PI_XRPUSD
            }
            $account = $this->account();
            if ($isFlex) {
                $account['total'] = $this->safe_string($balance, 'quantity');
                $account['free'] = $this->safe_string($balance, 'available');
            } elseif ($isCash) {
                $account['used'] = '0.0';
                $account['total'] = $balance;
            } else {
                $auxiliary = $this->safe_value($response, 'auxiliary');
                $account['free'] = $this->safe_string($auxiliary, 'af');
                $account['total'] = $this->safe_string($auxiliary, 'pv');
            }
            $result[$code] = $account;
        }
        return $this->safe_balance($result);
    }

    public function fetch_funding_rate_history(?string $symbol = null, ?int $since = null, ?int $limit = null, $params = array ()) {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            $this->check_required_symbol('fetchFundingRateHistory', $symbol);
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            if (!$market['swap']) {
                throw new BadRequest($this->id . ' fetchFundingRateHistory() supports swap contracts only');
            }
            $request = array(
                'symbol' => strtoupper($market['id']),
            );
            $response = Async\await($this->publicGetHistoricalfundingrates (array_merge($request, $params)));
            //
            //    {
            //        $rates => array(
            //          array(
            //            timestamp => '2018-08-31T16:00:00.000Z',
            //            fundingRate => '2.18900669884E-7',
            //            relativeFundingRate => '0.000060779960000000'
            //          ),
            //          ...
            //        )
            //    }
            //
            $rates = $this->safe_value($response, 'rates');
            $result = array();
            for ($i = 0; $i < count($rates); $i++) {
                $item = $rates[$i];
                $datetime = $this->safe_string($item, 'timestamp');
                $result[] = array(
                    'info' => $item,
                    'symbol' => $symbol,
                    'fundingRate' => $this->safe_number($item, 'fundingRate'),
                    'timestamp' => $this->parse8601($datetime),
                    'datetime' => $datetime,
                );
            }
            $sorted = $this->sort_by($result, 'timestamp');
            return $this->filter_by_symbol_since_limit($sorted, $symbol, $since, $limit);
        }) ();
    }

    public function fetch_positions(?array $symbols = null, $params = array ()) {
        return Async\async(function () use ($symbols, $params) {
            /**
             * Fetches current contract trading positions
             * @param {[string]} $symbols List of unified $symbols
             * @param {array} $params Not used by krakenfutures
             * @return Parsed exchange $response for positions
             */
            Async\await($this->load_markets());
            $request = array();
            $response = Async\await($this->privateGetOpenpositions ($request));
            //
            //    {
            //        $result => 'success',
            //        openPositions => array(
            //            {
            //                side => 'long',
            //                symbol => 'pi_xrpusd',
            //                price => '0.7533',
            //                fillTime => '2022-03-03T22:51:16.566Z',
            //                size => '230',
            //                unrealizedFunding => '-0.001878596918214635'
            //            }
            //        ),
            //        serverTime => '2022-03-03T22:51:16.566Z'
            //    }
            //
            $result = $this->parse_positions($response);
            return $this->filter_by_array($result, 'symbol', $symbols, false);
        }) ();
    }

    public function parse_positions($response, ?array $symbols = null, $params = array ()) {
        $result = array();
        $positions = $this->safe_value($response, 'openPositions');
        for ($i = 0; $i < count($positions); $i++) {
            $position = $this->parse_position($positions[$i]);
            $result[] = $position;
        }
        return $result;
    }

    public function parse_position($position, $market = null) {
        // cross
        //    {
        //        side => 'long',
        //        symbol => 'pi_xrpusd',
        //        price => '0.7533',
        //        fillTime => '2022-03-03T22:51:16.566Z',
        //        size => '230',
        //        unrealizedFunding => '-0.001878596918214635'
        //    }
        //
        // isolated
        //    {
        //        "side":"long",
        //        "symbol":"pf_ftmusd",
        //        "price":"0.4921",
        //        "fillTime":"2023-02-22T11:37:16.685Z",
        //        "size":"1",
        //        "unrealizedFunding":"-8.155240068885155E-8",
        //        "pnlCurrency":"USD",
        //        "maxFixedLeverage":"1.0"
        //    }
        //
        $leverage = $this->safe_number($position, 'maxFixedLeverage');
        $marginType = 'cross';
        if ($leverage !== null) {
            $marginType = 'isolated';
        }
        $datetime = $this->safe_string($position, 'fillTime');
        $marketId = $this->safe_string($position, 'symbol');
        $market = $this->safe_market($marketId, $market);
        return array(
            'info' => $position,
            'symbol' => $market['symbol'],
            'timestamp' => $this->parse8601($datetime),
            'datetime' => $datetime,
            'initialMargin' => null,
            'initialMarginPercentage' => null,
            'maintenanceMargin' => null,
            'maintenanceMarginPercentage' => null,
            'entryPrice' => $this->safe_number($position, 'price'),
            'notional' => null,
            'leverage' => $leverage,
            'unrealizedPnl' => $this->safe_number($position, 'unrealizedFunding'),
            'contracts' => $this->safe_number($position, 'size'),
            'contractSize' => $this->safe_number($market, 'contractSize'),
            'marginRatio' => null,
            'liquidationPrice' => null,
            'markPrice' => null,
            'collateral' => null,
            'marginType' => $marginType,
            'side' => $this->safe_string($position, 'side'),
            'percentage' => null,
        );
    }

    public function fetch_leverage_tiers(?array $symbols = null, $params = array ()) {
        return Async\async(function () use ($symbols, $params) {
            Async\await($this->load_markets());
            $response = Async\await($this->publicGetInstruments ($params));
            //
            //    {
            //        "result" => "success",
            //        "instruments" => array(
            //            {
            //                "symbol" => "fi_ethusd_180928",
            //                "type" => "futures_inverse",  // futures_vanilla  // spot index
            //                "underlying" => "rr_ethusd",
            //                "lastTradingTime" => "2018-09-28T15:00:00.000Z",
            //                "tickSize" => 0.1,
            //                "contractSize" => 1,
            //                "tradeable" => true,
            //                "marginLevels" => array(
            //                    array(
            //                        "contracts":0,
            //                        "initialMargin":0.02,
            //                        "maintenanceMargin":0.01
            //                    ),
            //                    array(
            //                        "contracts":250000,
            //                        "initialMargin":0.04,
            //                        "maintenanceMargin":0.02
            //                    ),
            //                    ...
            //                ),
            //                "isin" => "GB00JVMLMP88",
            //                "retailMarginLevels" => array(
            //                    array(
            //                        "contracts" => 0,
            //                        "initialMargin" => 0.5,
            //                        "maintenanceMargin" => 0.25
            //                    }
            //                ),
            //                "tags" => array(),
            //            ),
            //            {
            //                "symbol" => "in_xbtusd",
            //                "type" => "spot index",
            //                "tradeable":false
            //            }
            //        )
            //        "serverTime" => "2018-07-19T11:32:39.433Z"
            //    }
            //
            $data = $this->safe_value($response, 'instruments');
            return $this->parse_leverage_tiers($data, $symbols, 'symbol');
        }) ();
    }

    public function parse_market_leverage_tiers($info, $market = null) {
        /**
         * @ignore
         * @param $info Exchange $market response for 1 $market
         * @param $market CCXT $market
         */
        //
        //    {
        //        "symbol" => "fi_ethusd_180928",
        //        "type" => "futures_inverse",  // futures_vanilla  // spot index
        //        "underlying" => "rr_ethusd",
        //        "lastTradingTime" => "2018-09-28T15:00:00.000Z",
        //        "tickSize" => 0.1,
        //        "contractSize" => 1,
        //        "tradeable" => true,
        //        "marginLevels" => array(
        //            array(
        //                "contracts":0,
        //                "initialMargin":0.02,
        //                "maintenanceMargin":0.01
        //            ),
        //            array(
        //                "contracts":250000,
        //                "initialMargin":0.04,
        //                "maintenanceMargin":0.02
        //            ),
        //            ...
        //        ),
        //        "isin" => "GB00JVMLMP88",
        //        "retailMarginLevels" => array(
        //            {
        //                "contracts" => 0,
        //                "initialMargin" => 0.5,
        //                "maintenanceMargin" => 0.25
        //            }
        //        ),
        //        "tags" => array(),
        //    }
        //
        $marginLevels = $this->safe_value($info, 'marginLevels');
        $id = $this->safe_string($info, 'symbol');
        $market = $this->safe_market($id, $market);
        $tiers = array();
        for ($i = 0; $i < count($marginLevels); $i++) {
            $tier = $marginLevels[$i];
            $initialMargin = $this->safe_string($tier, 'initialMargin');
            $notionalFloor = $this->safe_number($tier, 'contracts');
            if ($i !== 0) {
                $tiersLength = count($tiers);
                $previousTier = $tiers[$tiersLength - 1];
                $previousTier['notionalCap'] = $notionalFloor;
            }
            $tiers[] = array(
                'tier' => $this->sum($i, 1),
                'currency' => $market['quote'],
                'notionalFloor' => $notionalFloor,
                'notionalCap' => null,
                'maintenanceMarginRate' => $this->safe_number($tier, 'maintenanceMargin'),
                'maxLeverage' => $this->parse_number(Precise::string_div('1', $initialMargin)),
                'info' => $tier,
            );
        }
        return $tiers;
    }

    public function parse_transfer($transfer, $currency = null) {
        //
        // $transfer
        //
        //    {
        //        result => 'success',
        //        serverTime => '2022-04-12T01:22:53.420Z'
        //    }
        //
        $datetime = $this->safe_string($transfer, 'serverTime');
        return array(
            'info' => $transfer,
            'id' => null,
            'timestamp' => $this->parse8601($datetime),
            'datetime' => $datetime,
            'currency' => $this->safe_string($currency, 'code'),
            'amount' => null,
            'fromAccount' => null,
            'toAccount' => null,
            'status' => $this->safe_string($transfer, 'result'),
        );
    }

    public function parse_account($account) {
        $accountByType = array(
            'main' => 'cash',
            'funding' => 'cash',
            'future' => 'cash',
            'futures' => 'cash',
            'cashAccount' => 'cash',
            'multiCollateralMarginAccount' => 'flex',
            'multiCollateral' => 'flex',
            'multiCollateralMargin' => 'flex',
        );
        if (is_array($accountByType) && array_key_exists($account, $accountByType)) {
            return $accountByType[$account];
        } elseif (is_array($this->markets) && array_key_exists($account, $this->markets)) {
            $market = $this->market($account);
            $marketId = $market['id'];
            $splitId = explode('_', $marketId);
            if ($market['inverse']) {
                return 'fi_' . $this->safe_string($splitId, 1);
            } else {
                return 'fv_' . $this->safe_string($splitId, 1);
            }
        } else {
            return $account;
        }
    }

    public function transfer_out(string $code, $amount, $params = array ()) {
        return Async\async(function () use ($code, $amount, $params) {
            /**
             * transfer from futures wallet to spot wallet
             * @param {str} $code Unified currency $code
             * @param {float} $amount Size of the transfer
             * @param {dict} $params Exchange specific parameters
             * @return a ~@link https://docs.ccxt.com/#/?id=transfer-structure transfer structure~
             */
            return Async\await($this->transfer($code, $amount, 'future', 'spot', $params));
        }) ();
    }

    public function transfer(string $code, $amount, $fromAccount, $toAccount, $params = array ()) {
        return Async\async(function () use ($code, $amount, $fromAccount, $toAccount, $params) {
            /**
             * transfers currencies between sub-accounts
             * @param {string} $code Unified $currency $code
             * @param {float} $amount Size of the $transfer
             * @param {string} $fromAccount 'main'/'funding'/'future', 'flex', or a unified market symbol
             * @param {string} $toAccount 'main'/'funding', 'flex', 'spot' or a unified market symbol
             * @param {array} $params Exchange specific parameters
             * @return a ~@link https://docs.ccxt.com/#/?id=$transfer-structure $transfer structure~
             */
            Async\await($this->load_markets());
            $currency = $this->currency($code);
            $method = 'privatePostTransfer';
            $request = array(
                'amount' => $amount,
            );
            if ($fromAccount === 'spot') {
                throw new BadRequest($this->id . ' $transfer does not yet support transfers from spot');
            }
            if ($toAccount === 'spot') {
                if ($this->parse_account($fromAccount) !== 'cash') {
                    throw new BadRequest($this->id . ' $transfer cannot $transfer from ' . $fromAccount . ' to ' . $toAccount);
                }
                $method = 'privatePostWithdrawal';
                $request['currency'] = $currency['id'];
            } else {
                $request['fromAccount'] = $this->parse_account($fromAccount);
                $request['toAccount'] = $this->parse_account($toAccount);
                $request['unit'] = $currency['id'];
            }
            $response = Async\await($this->$method (array_merge($request, $params)));
            //
            //    {
            //        result => 'success',
            //        serverTime => '2022-04-12T01:22:53.420Z'
            //    }
            //
            $transfer = $this->parse_transfer($response, $currency);
            return array_merge($transfer, array(
                'amount' => $amount,
                'fromAccount' => $fromAccount,
                'toAccount' => $toAccount,
            ));
        }) ();
    }

    public function handle_errors($code, $reason, $url, $method, $headers, $body, $response, $requestHeaders, $requestBody) {
        if ($response === null) {
            return null;
        }
        if ($code === 429) {
            throw new DDoSProtection($this->id . ' ' . $body);
        }
        $message = $this->safe_string($response, 'error');
        if ($message === null) {
            return null;
        }
        $feedback = $this->id . ' ' . $body;
        $this->throw_exactly_matched_exception($this->exceptions['exact'], $message, $feedback);
        $this->throw_broadly_matched_exception($this->exceptions['broad'], $message, $feedback);
        if ($code === 400) {
            throw new BadRequest($feedback);
        }
        throw new ExchangeError($feedback); // unknown message
    }

    public function sign($path, $api = 'public', $method = 'GET', $params = array (), $headers = null, $body = null) {
        $apiVersions = $this->safe_value($this->options['versions'], $api, array());
        $methodVersions = $this->safe_value($apiVersions, $method, array());
        $defaultVersion = $this->safe_string($methodVersions, $path, $this->version);
        $version = $this->safe_string($params, 'version', $defaultVersion);
        $params = $this->omit($params, 'version');
        $apiAccess = $this->safe_value($this->options['access'], $api, array());
        $methodAccess = $this->safe_value($apiAccess, $method, array());
        $access = $this->safe_string($methodAccess, $path, 'public');
        $endpoint = $version . '/' . $this->implode_params($path, $params);
        $params = $this->omit($params, $this->extract_params($path));
        $query = $endpoint;
        $postData = '';
        if ($params) {
            $postData = $this->urlencode($params);
            $query .= '?' . $postData;
        }
        $url = $this->urls['api'][$api] . $query;
        if ($api === 'private' || $access === 'private') {
            $auth = $postData . '/api/';
            if ($api !== 'private') {
                $auth .= $api . '/';
            }
            $auth .= $endpoint; // 1
            $hash = $this->hash($this->encode($auth), 'sha256', 'binary'); // 2
            $secret = base64_decode($this->secret); // 3
            $signature = $this->hmac($hash, $secret, 'sha512', 'base64'); // 4-5
            $headers = array(
                'Content-Type' => 'application/json',
                'APIKey' => $this->apiKey,
                'Authent' => $signature,
            );
        }
        return array( 'url' => $url, 'method' => $method, 'body' => $body, 'headers' => $headers );
    }
}
