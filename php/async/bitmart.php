<?php

namespace ccxt\async;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

use Exception; // a common import
use ccxt\ExchangeError;
use ccxt\ArgumentsRequired;
use ccxt\InvalidOrder;
use ccxt\NotSupported;
use ccxt\Precise;
use React\Async;

class bitmart extends Exchange {

    public function describe() {
        return $this->deep_extend(parent::describe(), array(
            'id' => 'bitmart',
            'name' => 'BitMart',
            'countries' => array( 'US', 'CN', 'HK', 'KR' ),
            // 150 per 5 seconds = 30 per second
            // rateLimit = 1000ms / 30 ~= 33.334
            'rateLimit' => 33.34,
            'version' => 'v2',
            'certified' => true,
            'pro' => true,
            'has' => array(
                'CORS' => null,
                'spot' => true,
                'margin' => true,
                'swap' => null, // has but unimplemented
                'future' => false,
                'option' => null,
                'borrowMargin' => true,
                'cancelAllOrders' => true,
                'cancelOrder' => true,
                'cancelOrders' => false,
                'createOrder' => true,
                'createPostOnlyOrder' => true,
                'createStopLimitOrder' => false,
                'createStopMarketOrder' => false,
                'createStopOrder' => false,
                'fetchBalance' => true,
                'fetchBorrowInterest' => true,
                'fetchBorrowRate' => true,
                'fetchBorrowRateHistories' => false,
                'fetchBorrowRateHistory' => false,
                'fetchBorrowRates' => true,
                'fetchCanceledOrders' => true,
                'fetchClosedOrders' => true,
                'fetchCurrencies' => true,
                'fetchDeposit' => true,
                'fetchDepositAddress' => true,
                'fetchDepositAddresses' => false,
                'fetchDepositAddressesByNetwork' => false,
                'fetchDeposits' => true,
                'fetchFundingHistory' => null,
                'fetchMarginMode' => false,
                'fetchMarkets' => true,
                'fetchMyTrades' => true,
                'fetchOHLCV' => true,
                'fetchOpenOrders' => true,
                'fetchOrder' => true,
                'fetchOrderBook' => true,
                'fetchOrders' => false,
                'fetchOrderTrades' => true,
                'fetchPositionMode' => false,
                'fetchStatus' => true,
                'fetchTicker' => true,
                'fetchTickers' => true,
                'fetchTime' => true,
                'fetchTrades' => true,
                'fetchTradingFee' => true,
                'fetchTradingFees' => false,
                'fetchTransactionFee' => true,
                'fetchTransactionFees' => false,
                'fetchTransfer' => false,
                'fetchTransfers' => false,
                'fetchWithdrawAddressesByNetwork' => false,
                'fetchWithdrawal' => true,
                'fetchWithdrawals' => true,
                'reduceMargin' => false,
                'repayMargin' => true,
                'setLeverage' => false,
                'setMarginMode' => false,
                'transfer' => true,
                'withdraw' => true,
            ),
            'hostname' => 'bitmart.com', // bitmart.info, bitmart.news for Hong Kong users
            'urls' => array(
                'logo' => 'https://user-images.githubusercontent.com/1294454/129991357-8f47464b-d0f4-41d6-8a82-34122f0d1398.jpg',
                'api' => array(
                    'rest' => 'https://api-cloud.{hostname}', // bitmart.info for Hong Kong users
                ),
                'www' => 'https://www.bitmart.com/',
                'doc' => 'https://developer-pro.bitmart.com/',
                'referral' => array(
                    'url' => 'http://www.bitmart.com/?r=rQCFLh',
                    'discount' => 0.3,
                ),
                'fees' => 'https://www.bitmart.com/fee/en',
            ),
            'requiredCredentials' => array(
                'apiKey' => true,
                'secret' => true,
                'uid' => true,
            ),
            'api' => array(
                'public' => array(
                    'get' => array(
                        'system/time' => 3,
                        'system/service' => 3,
                        // spot markets
                        'spot/v1/currencies' => 7.5,
                        'spot/v1/symbols' => 7.5,
                        'spot/v1/symbols/details' => 5,
                        'spot/v1/ticker' => 5,
                        'spot/v1/steps' => 30,
                        'spot/v1/symbols/kline' => 5,
                        'spot/v1/symbols/book' => 5,
                        'spot/v1/symbols/trades' => 5,
                        // contract markets
                        'contract/v1/tickers' => 15,
                        'contract/public/details' => 5,
                        'contract/public/depth' => 5,
                        'contract/public/open-interest' => 30,
                        'contract/public/funding-rate' => 30,
                        'contract/public/kline' => 5,
                    ),
                ),
                'private' => array(
                    'get' => array(
                        // sub-account
                        'account/sub-account/v1/transfer-list' => 7.5,
                        'account/sub-account/v1/transfer-history' => 7.5,
                        'account/sub-account/main/v1/wallet' => 5,
                        'account/sub-account/main/v1/subaccount-list' => 7.5,
                        // account
                        'account/v1/wallet' => 5,
                        'account/v1/currencies' => 30,
                        'spot/v1/wallet' => 5,
                        'account/v1/deposit/address' => 30,
                        'account/v1/withdraw/charge' => 32, // should be 30 but errors
                        'account/v2/deposit-withdraw/history' => 7.5,
                        'account/v1/deposit-withdraw/detail' => 7.5,
                        // order
                        'spot/v1/order_detail' => 1,
                        'spot/v2/orders' => 5,
                        'spot/v1/trades' => 5,
                        // newer order endpoint
                        'spot/v2/trades' => 5,
                        'spot/v3/orders' => 5,
                        'spot/v2/order_detail' => 1,
                        // margin
                        'spot/v1/margin/isolated/borrow_record' => 1,
                        'spot/v1/margin/isolated/repay_record' => 1,
                        'spot/v1/margin/isolated/pairs' => 1,
                        'spot/v1/margin/isolated/account' => 6,
                        'spot/v1/trade_fee' => 6,
                        'spot/v1/user_fee' => 6,
                        // contract
                        'contract/private/assets-detail' => 5,
                        'contract/private/order' => 2,
                        'contract/private/order-history' => 10,
                        'contract/private/position' => 10,
                    ),
                    'post' => array(
                        // sub-account endpoints
                        'account/sub-account/main/v1/sub-to-main' => 30,
                        'account/sub-account/sub/v1/sub-to-main' => 30,
                        'account/sub-account/main/v1/main-to-sub' => 30,
                        'account/sub-account/sub/v1/sub-to-sub' => 30,
                        'account/sub-account/main/v1/sub-to-sub' => 30,
                        // account
                        'account/v1/withdraw/apply' => 7.5,
                        // transaction and trading
                        'spot/v1/submit_order' => 1,
                        'spot/v1/batch_orders' => 1,
                        'spot/v2/cancel_order' => 1,
                        'spot/v1/cancel_orders' => 15,
                        // newer endpoint
                        'spot/v3/cancel_order' => 1,
                        'spot/v2/batch_orders' => 1,
                        'spot/v2/submit_order' => 1,
                        // margin
                        'spot/v1/margin/submit_order' => 1,
                        'spot/v1/margin/isolated/borrow' => 6,
                        'spot/v1/margin/isolated/repay' => 6,
                        'spot/v1/margin/isolated/transfer' => 6,
                        // contract
                        'contract/private/trades' => 10,
                    ),
                ),
            ),
            'timeframes' => array(
                '1m' => 1,
                '3m' => 3,
                '5m' => 5,
                '15m' => 15,
                '30m' => 30,
                '45m' => 45,
                '1h' => 60,
                '2h' => 120,
                '3h' => 180,
                '4h' => 240,
                '1d' => 1440,
                '1w' => 10080,
                '1M' => 43200,
            ),
            'fees' => array(
                'trading' => array(
                    'tierBased' => true,
                    'percentage' => true,
                    'taker' => $this->parse_number('0.0025'),
                    'maker' => $this->parse_number('0.0025'),
                    'tiers' => array(
                        'taker' => array(
                            array( $this->parse_number('0'), $this->parse_number('0.0020') ),
                            array( $this->parse_number('10'), $this->parse_number('0.18') ),
                            array( $this->parse_number('50'), $this->parse_number('0.0016') ),
                            array( $this->parse_number('250'), $this->parse_number('0.0014') ),
                            array( $this->parse_number('1000'), $this->parse_number('0.0012') ),
                            array( $this->parse_number('5000'), $this->parse_number('0.0010') ),
                            array( $this->parse_number('25000'), $this->parse_number('0.0008') ),
                            array( $this->parse_number('50000'), $this->parse_number('0.0006') ),
                        ),
                        'maker' => array(
                            array( $this->parse_number('0'), $this->parse_number('0.001') ),
                            array( $this->parse_number('10'), $this->parse_number('0.0009') ),
                            array( $this->parse_number('50'), $this->parse_number('0.0008') ),
                            array( $this->parse_number('250'), $this->parse_number('0.0007') ),
                            array( $this->parse_number('1000'), $this->parse_number('0.0006') ),
                            array( $this->parse_number('5000'), $this->parse_number('0.0005') ),
                            array( $this->parse_number('25000'), $this->parse_number('0.0004') ),
                            array( $this->parse_number('50000'), $this->parse_number('0.0003') ),
                        ),
                    ),
                ),
            ),
            'precisionMode' => TICK_SIZE,
            'exceptions' => array(
                'exact' => array(
                    // general errors
                    '30000' => '\\ccxt\\ExchangeError', // 404, Not found
                    '30001' => '\\ccxt\\AuthenticationError', // 401, Header X-BM-KEY is empty
                    '30002' => '\\ccxt\\AuthenticationError', // 401, Header X-BM-KEY not found
                    '30003' => '\\ccxt\\AccountSuspended', // 401, Header X-BM-KEY has frozen
                    '30004' => '\\ccxt\\AuthenticationError', // 401, Header X-BM-SIGN is empty
                    '30005' => '\\ccxt\\AuthenticationError', // 401, Header X-BM-SIGN is wrong
                    '30006' => '\\ccxt\\AuthenticationError', // 401, Header X-BM-TIMESTAMP is empty
                    '30007' => '\\ccxt\\AuthenticationError', // 401, Header X-BM-TIMESTAMP range. Within a minute
                    '30008' => '\\ccxt\\AuthenticationError', // 401, Header X-BM-TIMESTAMP invalid format
                    '30010' => '\\ccxt\\PermissionDenied', // 403, IP is forbidden. We recommend enabling IP whitelist for API trading. After that reauth your account
                    '30011' => '\\ccxt\\AuthenticationError', // 403, Header X-BM-KEY over expire time
                    '30012' => '\\ccxt\\AuthenticationError', // 403, Header X-BM-KEY is forbidden to request it
                    '30013' => '\\ccxt\\RateLimitExceeded', // 429, Request too many requests
                    '30014' => '\\ccxt\\ExchangeNotAvailable', // 503, Service unavailable
                    // funding account errors
                    '60000' => '\\ccxt\\BadRequest', // 400, Invalid request (maybe the body is empty, or the int parameter passes string data)
                    '60001' => '\\ccxt\\BadRequest', // 400, Asset account type does not exist
                    '60002' => '\\ccxt\\BadRequest', // 400, currency does not exist
                    '60003' => '\\ccxt\\ExchangeError', // 400, Currency has been closed recharge channel, if there is any problem, please consult customer service
                    '60004' => '\\ccxt\\ExchangeError', // 400, Currency has been closed withdraw channel, if there is any problem, please consult customer service
                    '60005' => '\\ccxt\\ExchangeError', // 400, Minimum amount is %s
                    '60006' => '\\ccxt\\ExchangeError', // 400, Maximum withdraw precision is %d
                    '60007' => '\\ccxt\\InvalidAddress', // 400, Only withdrawals from added addresses are allowed
                    '60008' => '\\ccxt\\InsufficientFunds', // 400, Balance not enough
                    '60009' => '\\ccxt\\ExchangeError', // 400, Beyond the limit
                    '60010' => '\\ccxt\\ExchangeError', // 400, Withdraw id or deposit id not found
                    '60011' => '\\ccxt\\InvalidAddress', // 400, Address is not valid
                    '60012' => '\\ccxt\\ExchangeError', // 400, This action is not supported in this currency(If IOTA, HLX recharge and withdraw calls are prohibited)
                    '60020' => '\\ccxt\\PermissionDenied', // 403, Your account is not allowed to recharge
                    '60021' => '\\ccxt\\PermissionDenied', // 403, Your account is not allowed to withdraw
                    '60022' => '\\ccxt\\PermissionDenied', // 403, No withdrawals for 24 hours
                    '60030' => '\\ccxt\\BadRequest', // 405, Method Not Allowed
                    '60031' => '\\ccxt\\BadRequest', // 415, Unsupported Media Type
                    '60050' => '\\ccxt\\ExchangeError', // 500, User account not found
                    '60051' => '\\ccxt\\ExchangeError', // 500, Internal Server Error
                    '61001' => '\\ccxt\\InsufficientFunds', // array("message":"Balance not enough","code":61001,"trace":"b85ea1f8-b9af-4001-ac5f-9e061fe93d78","data":array())
                    '61003' => '\\ccxt\\BadRequest', // array("message":"sub-account not found","code":61003,"trace":"b35ec2fd-0bc9-4ef2-a3c0-6f78d4f335a4","data":array())
                    // spot errors
                    '50000' => '\\ccxt\\BadRequest', // 400, Bad Request
                    '50001' => '\\ccxt\\BadSymbol', // 400, Symbol not found
                    '50002' => '\\ccxt\\BadRequest', // 400, From Or To format error
                    '50003' => '\\ccxt\\BadRequest', // 400, Step format error
                    '50004' => '\\ccxt\\BadRequest', // 400, Kline size over 500
                    '50005' => '\\ccxt\\OrderNotFound', // 400, Order Id not found
                    '50006' => '\\ccxt\\InvalidOrder', // 400, Minimum size is %s
                    '50007' => '\\ccxt\\InvalidOrder', // 400, Maximum size is %s
                    '50008' => '\\ccxt\\InvalidOrder', // 400, Minimum price is %s
                    '50009' => '\\ccxt\\InvalidOrder', // 400, Minimum count*price is %s
                    '50010' => '\\ccxt\\InvalidOrder', // 400, RequestParam size is required
                    '50011' => '\\ccxt\\InvalidOrder', // 400, RequestParam price is required
                    '50012' => '\\ccxt\\InvalidOrder', // 400, RequestParam notional is required
                    '50013' => '\\ccxt\\InvalidOrder', // 400, Maximum limit*offset is %d
                    '50014' => '\\ccxt\\BadRequest', // 400, RequestParam limit is required
                    '50015' => '\\ccxt\\BadRequest', // 400, Minimum limit is 1
                    '50016' => '\\ccxt\\BadRequest', // 400, Maximum limit is %d
                    '50017' => '\\ccxt\\BadRequest', // 400, RequestParam offset is required
                    '50018' => '\\ccxt\\BadRequest', // 400, Minimum offset is 1
                    '50019' => '\\ccxt\\BadRequest', // 400, Maximum price is %s
                    '51004' => '\\ccxt\\InsufficientFunds', // array("message":"Exceed the maximum number of borrows available.","code":51004,"trace":"4030b753-9beb-44e6-8352-1633c5edcd47","data":array())
                    // '50019' => '\\ccxt\\ExchangeError', // 400, Invalid status. validate status is [1=Failed, 2=Success, 3=Frozen Failed, 4=Frozen Success, 5=Partially Filled, 6=Fully Fulled, 7=Canceling, 8=Canceled
                    '50020' => '\\ccxt\\InsufficientFunds', // 400, Balance not enough
                    '50021' => '\\ccxt\\BadRequest', // 400, Invalid %s
                    '50022' => '\\ccxt\\ExchangeNotAvailable', // 400, Service unavailable
                    '50023' => '\\ccxt\\BadSymbol', // 400, This Symbol can't place order by api
                    '50029' => '\\ccxt\\InvalidOrder', // array("message":"param not match : size * price >=1000","code":50029,"trace":"f931f030-b692-401b-a0c5-65edbeadc598","data":array())
                    '50030' => '\\ccxt\\InvalidOrder', // array("message":"Order is already canceled","code":50030,"trace":"8d6f64ee-ad26-45a4-9efd-1080f9fca1fa","data":array())
                    '50032' => '\\ccxt\\OrderNotFound', // array("message":"Order does not exist","code":50032,"trace":"8d6b482d-4bf2-4e6c-aab2-9dcd22bf2481","data":array())
                    // below Error codes used interchangeably for both failed postOnly and IOC orders depending on market price and order side
                    '50035' => '\\ccxt\\InvalidOrder', // array("message":"The price is low and there is no matching depth","code":50035,"trace":"677f01c7-8b88-4346-b097-b4226c75c90e","data":array())
                    '50034' => '\\ccxt\\InvalidOrder', // array("message":"The price is high and there is no matching depth","code":50034,"trace":"ebfae59a-ba69-4735-86b2-0ed7b9ca14ea","data":array())
                    '53000' => '\\ccxt\\AccountSuspended', // 403, Your account is frozen due to security policies. Please contact customer service
                    '53001' => '\\ccxt\\AccountSuspended', // array("message":"Your kyc country is restricted. Please contact customer service.","code":53001,"trace":"8b445940-c123-4de9-86d7-73c5be2e7a24","data":array())
                    '57001' => '\\ccxt\\BadRequest', // 405, Method Not Allowed
                    '58001' => '\\ccxt\\BadRequest', // 415, Unsupported Media Type
                    '59001' => '\\ccxt\\ExchangeError', // 500, User account not found
                    '59002' => '\\ccxt\\ExchangeError', // 500, Internal Server Error
                    // contract errors
                    '40001' => '\\ccxt\\ExchangeError', // 400, Cloud account not found
                    '40002' => '\\ccxt\\ExchangeError', // 400, out_trade_no not found
                    '40003' => '\\ccxt\\ExchangeError', // 400, out_trade_no already existed
                    '40004' => '\\ccxt\\ExchangeError', // 400, Cloud account count limit
                    '40005' => '\\ccxt\\ExchangeError', // 400, Transfer vol precision error
                    '40006' => '\\ccxt\\PermissionDenied', // 400, Invalid ip error
                    '40007' => '\\ccxt\\BadRequest', // 400, Parse parameter error
                    '40008' => '\\ccxt\\InvalidNonce', // 400, Check nonce error
                    '40009' => '\\ccxt\\BadRequest', // 400, Check ver error
                    '40010' => '\\ccxt\\BadRequest', // 400, Not found func error
                    '40011' => '\\ccxt\\BadRequest', // 400, Invalid request
                    '40012' => '\\ccxt\\ExchangeError', // 500, System error
                    '40013' => '\\ccxt\\ExchangeError', // 400, Access too often" CLIENT_TIME_INVALID, "Please check your system time.
                    '40014' => '\\ccxt\\BadSymbol', // 400, This contract is offline
                    '40015' => '\\ccxt\\BadSymbol', // 400, This contract's exchange has been paused
                    '40016' => '\\ccxt\\InvalidOrder', // 400, This order would trigger user position liquidate
                    '40017' => '\\ccxt\\InvalidOrder', // 400, It is not possible to open and close simultaneously in the same position
                    '40018' => '\\ccxt\\InvalidOrder', // 400, Your position is closed
                    '40019' => '\\ccxt\\ExchangeError', // 400, Your position is in liquidation delegating
                    '40020' => '\\ccxt\\InvalidOrder', // 400, Your position volume is not enough
                    '40021' => '\\ccxt\\ExchangeError', // 400, The position is not exsit
                    '40022' => '\\ccxt\\ExchangeError', // 400, The position is not isolated
                    '40023' => '\\ccxt\\ExchangeError', // 400, The position would liquidate when sub margin
                    '40024' => '\\ccxt\\ExchangeError', // 400, The position would be warnning of liquidation when sub margin
                    '40025' => '\\ccxt\\ExchangeError', // 400, The position’s margin shouldn’t be lower than the base limit
                    '40026' => '\\ccxt\\ExchangeError', // 400, You cross margin position is in liquidation delegating
                    '40027' => '\\ccxt\\InsufficientFunds', // 400, You contract account available balance not enough
                    '40028' => '\\ccxt\\PermissionDenied', // 400, Your plan order's count is more than system maximum limit.
                    '40029' => '\\ccxt\\InvalidOrder', // 400, The order's leverage is too large.
                    '40030' => '\\ccxt\\InvalidOrder', // 400, The order's leverage is too small.
                    '40031' => '\\ccxt\\InvalidOrder', // 400, The deviation between current price and trigger price is too large.
                    '40032' => '\\ccxt\\InvalidOrder', // 400, The plan order's life cycle is too long.
                    '40033' => '\\ccxt\\InvalidOrder', // 400, The plan order's life cycle is too short.
                    '40034' => '\\ccxt\\BadSymbol', // 400, This contract is not found
                    '53002' => '\\ccxt\\PermissionDenied', // 403, Your account has not yet completed the kyc advanced certification, please complete first
                ),
                'broad' => array(),
            ),
            'commonCurrencies' => array(
                '$GM' => 'GOLDMINER',
                '$HERO' => 'Step Hero',
                '$PAC' => 'PAC',
                'BP' => 'BEYOND',
                'GDT' => 'Gorilla Diamond',
                'GLD' => 'Goldario',
                'MVP' => 'MVP Coin',
                'TRU' => 'Truebit', // conflict with TrueFi
            ),
            'options' => array(
                'networks' => array(
                    'TRX' => 'TRC20',
                    'ETH' => 'ERC20',
                ),
                'defaultNetworks' => array(
                    'USDT' => 'ERC20',
                ),
                'defaultType' => 'spot', // 'spot', 'swap'
                'fetchBalance' => array(
                    'type' => 'spot', // 'spot', 'swap', 'account'
                ),
                'createMarketBuyOrderRequiresPrice' => true,
            ),
        ));
    }

    public function fetch_time($params = array ()) {
        return Async\async(function () use ($params) {
            /**
             * fetches the current integer timestamp in milliseconds from the exchange server
             * @param {array} $params extra parameters specific to the bitmart api endpoint
             * @return {int} the current integer timestamp in milliseconds from the exchange server
             */
            $response = Async\await($this->publicGetSystemTime ($params));
            //
            //     {
            //         "message":"OK",
            //         "code":1000,
            //         "trace":"c4e5e5b7-fe9f-4191-89f7-53f6c5bf9030",
            //         "data":{
            //             "server_time":1599843709578
            //         }
            //     }
            //
            $data = $this->safe_value($response, 'data', array());
            return $this->safe_integer($data, 'server_time');
        }) ();
    }

    public function fetch_status($params = array ()) {
        return Async\async(function () use ($params) {
            /**
             * the latest known information on the availability of the exchange API
             * @param {array} $params extra parameters specific to the bitmart api endpoint
             * @return {array} a {@link https://docs.ccxt.com/en/latest/manual.html#exchange-$status-structure $status structure}
             */
            $options = $this->safe_value($this->options, 'fetchStatus', array());
            $defaultType = $this->safe_string($this->options, 'defaultType');
            $type = $this->safe_string($options, 'type', $defaultType);
            $type = $this->safe_string($params, 'type', $type);
            $params = $this->omit($params, 'type');
            $response = Async\await($this->publicGetSystemService ($params));
            //
            //     {
            //         "message" => "OK",
            //         "code" => 1000,
            //         "trace" => "1d3f28b0-763e-4f78-90c4-5e3ad19dc595",
            //         "data" => {
            //           "service" => array(
            //             array(
            //               "title" => "Spot API Stop",
            //               "service_type" => "spot",
            //               "status" => 2,
            //               "start_time" => 1648639069125,
            //               "end_time" => 1648639069125
            //             ),
            //             {
            //               "title" => "Contract API Stop",
            //               "service_type" => "contract",
            //               "status" => 2,
            //               "start_time" => 1648639069125,
            //               "end_time" => 1648639069125
            //             }
            //           )
            //         }
            //     }
            //
            $data = $this->safe_value($response, 'data', array());
            $services = $this->safe_value($data, 'service', array());
            $servicesByType = $this->index_by($services, 'service_type');
            if ($type === 'swap') {
                $type = 'contract';
            }
            $service = $this->safe_value($servicesByType, $type);
            $status = null;
            $eta = null;
            if ($service !== null) {
                $statusCode = $this->safe_integer($service, 'status');
                if ($statusCode === 2) {
                    $status = 'ok';
                } else {
                    $status = 'maintenance';
                    $eta = $this->safe_integer($service, 'end_time');
                }
            }
            return array(
                'status' => $status,
                'updated' => null,
                'eta' => $eta,
                'url' => null,
                'info' => $response,
            );
        }) ();
    }

    public function fetch_spot_markets($params = array ()) {
        return Async\async(function () use ($params) {
            $response = Async\await($this->publicGetSpotV1SymbolsDetails ($params));
            //
            //     {
            //         "message":"OK",
            //         "code":1000,
            //         "trace":"a67c9146-086d-4d3f-9897-5636a9bb26e1",
            //         "data":{
            //             "symbols":array(
            //               array(
            //                  "symbol" => "BTC_USDT",
            //                  "symbol_id" => 53,
            //                  "base_currency" => "BTC",
            //                  "quote_currency" => "USDT",
            //                  "base_min_size" => "0.000010000000000000000000000000",
            //                  "base_max_size" => "100000000.000000000000000000000000000000",
            //                  "price_min_precision" => -1,
            //                  "price_max_precision" => 2,
            //                  "quote_increment" => "0.00001", // Api docs says "The minimum order quantity is also the minimum order quantity increment", however I think they mistakenly use the term 'order quantity'
            //                  "expiration" => "NA",
            //                  "min_buy_amount" => "5.000000000000000000000000000000",
            //                  "min_sell_amount" => "5.000000000000000000000000000000",
            //                  "trade_status" => "trading"
            //               ),
            //             )
            //         }
            //     }
            //
            $data = $this->safe_value($response, 'data', array());
            $symbols = $this->safe_value($data, 'symbols', array());
            $result = array();
            for ($i = 0; $i < count($symbols); $i++) {
                $market = $symbols[$i];
                $id = $this->safe_string($market, 'symbol');
                $numericId = $this->safe_integer($market, 'symbol_id');
                $baseId = $this->safe_string($market, 'base_currency');
                $quoteId = $this->safe_string($market, 'quote_currency');
                $base = $this->safe_currency_code($baseId);
                $quote = $this->safe_currency_code($quoteId);
                $symbol = $base . '/' . $quote;
                $minBuyCost = $this->safe_string($market, 'min_buy_amount');
                $minSellCost = $this->safe_string($market, 'min_sell_amount');
                $minCost = Precise::string_max($minBuyCost, $minSellCost);
                $baseMinSize = $this->safe_number($market, 'base_min_size');
                $result[] = array(
                    'id' => $id,
                    'numericId' => $numericId,
                    'symbol' => $symbol,
                    'base' => $base,
                    'quote' => $quote,
                    'settle' => null,
                    'baseId' => $baseId,
                    'quoteId' => $quoteId,
                    'settleId' => null,
                    'type' => 'spot',
                    'spot' => true,
                    'margin' => false,
                    'swap' => false,
                    'future' => false,
                    'option' => false,
                    'active' => true,
                    'contract' => false,
                    'linear' => null,
                    'inverse' => null,
                    'contractSize' => null,
                    'expiry' => null,
                    'expiryDatetime' => null,
                    'strike' => null,
                    'optionType' => null,
                    'precision' => array(
                        'amount' => $baseMinSize,
                        'price' => $this->parse_number($this->parse_precision($this->safe_string($market, 'price_max_precision'))),
                    ),
                    'limits' => array(
                        'leverage' => array(
                            'min' => null,
                            'max' => null,
                        ),
                        'amount' => array(
                            'min' => $baseMinSize,
                            'max' => $this->safe_number($market, 'base_max_size'),
                        ),
                        'price' => array(
                            'min' => null,
                            'max' => null,
                        ),
                        'cost' => array(
                            'min' => $this->parse_number($minCost),
                            'max' => null,
                        ),
                    ),
                    'info' => $market,
                );
            }
            return $result;
        }) ();
    }

    public function fetch_contract_markets($params = array ()) {
        return Async\async(function () use ($params) {
            $response = Async\await($this->publicGetContractV1Tickers ($params));
            //
            //    {
            //        "message" => "OK",
            //        "code" => 1000,
            //        "trace" => "045d13a8-4bc7-4974-9748-97d0ea183ef0",
            //        "data" => {
            //            "tickers" => array(
            //                array(
            //                    "contract_symbol" => "RAYUSDT",
            //                    "last_price" => "3.893",
            //                    "index_price" => "3.90248043",
            //                    "last_funding_rate" => "-0.00054285",
            //                    "price_change_percent_24h" => "-6.955",
            //                    "volume_24h" => "10450969.34602996",
            //                    "url" => "https://futures.bitmart.com/en?$symbol=RAYUSDT",
            //                    "high_price" => "4.299",
            //                    "low_price" => "3.887",
            //                    "legal_coin_price" => "3.893056"
            //                ),
            //                ...
            //            )
            //        }
            //    }
            //
            $data = $this->safe_value($response, 'data', array());
            $tickers = $this->safe_value($data, 'tickers', array());
            $result = array();
            for ($i = 0; $i < count($tickers); $i++) {
                $market = $tickers[$i];
                $id = $this->safe_string($market, 'contract_symbol');
                $baseId = mb_substr($id, 0, -4 - 0);
                $quoteId = mb_substr($id, -4);
                $base = $this->safe_currency_code($baseId);
                $quote = $this->safe_currency_code($quoteId);
                $settle = 'USDT';
                $symbol = $base . '/' . $quote . ':' . $settle;
                $result[] = array(
                    'id' => $id,
                    'numericId' => null,
                    'symbol' => $symbol,
                    'base' => $base,
                    'quote' => $quote,
                    'settle' => $settle,
                    'baseId' => $baseId,
                    'quoteId' => $quoteId,
                    'settleId' => null,
                    'type' => 'swap',
                    'spot' => false,
                    'margin' => false,
                    'swap' => true,
                    'future' => false,
                    'option' => false,
                    'active' => true,
                    'contract' => true,
                    'linear' => true,
                    'inverse' => false,
                    'contractSize' => null,
                    'expiry' => null,
                    'expiryDatetime' => null,
                    'strike' => null,
                    'optionType' => null,
                    'precision' => array(
                        'amount' => null,
                        'price' => null,
                    ),
                    'limits' => array(
                        'leverage' => array(
                            'min' => null,
                            'max' => null,
                        ),
                        'amount' => array(
                            'min' => null,
                            'max' => null,
                        ),
                        'price' => array(
                            'min' => null,
                            'max' => null,
                        ),
                        'cost' => array(
                            'min' => null,
                            'max' => null,
                        ),
                    ),
                    'info' => $market,
                );
            }
            return $result;
        }) ();
    }

    public function fetch_markets($params = array ()) {
        return Async\async(function () use ($params) {
            /**
             * retrieves data on all markets for bitmart
             * @param {array} $params extra parameters specific to the exchange api endpoint
             * @return {[array]} an array of objects representing market data
             */
            $spot = Async\await($this->fetch_spot_markets($params));
            $contract = Async\await($this->fetch_contract_markets($params));
            return $this->array_concat($spot, $contract);
        }) ();
    }

    public function fetch_currencies($params = array ()) {
        return Async\async(function () use ($params) {
            /**
             * fetches all available $currencies on an exchange
             * @param {array} $params extra parameters specific to the bitmart api endpoint
             * @return {array} an associative dictionary of $currencies
             */
            $response = Async\await($this->publicGetSpotV1Currencies ($params));
            //
            //     {
            //         "message":"OK",
            //         "code":1000,
            //         "trace":"8c768b3c-025f-413f-bec5-6d6411d46883",
            //         "data":{
            //             "currencies":array(
            //                 array("currency":"MATIC","name":"Matic Network","withdraw_enabled":true,"deposit_enabled":true),
            //                 array("currency":"KTN","name":"Kasoutuuka News","withdraw_enabled":true,"deposit_enabled":false),
            //                 array("currency":"BRT","name":"Berith","withdraw_enabled":true,"deposit_enabled":true),
            //             )
            //         }
            //     }
            //
            $data = $this->safe_value($response, 'data', array());
            $currencies = $this->safe_value($data, 'currencies', array());
            $result = array();
            for ($i = 0; $i < count($currencies); $i++) {
                $currency = $currencies[$i];
                $id = $this->safe_string($currency, 'id');
                $code = $this->safe_currency_code($id);
                $name = $this->safe_string($currency, 'name');
                $withdrawEnabled = $this->safe_value($currency, 'withdraw_enabled');
                $depositEnabled = $this->safe_value($currency, 'deposit_enabled');
                $active = $withdrawEnabled && $depositEnabled;
                $result[$code] = array(
                    'id' => $id,
                    'code' => $code,
                    'name' => $name,
                    'info' => $currency, // the original payload
                    'active' => $active,
                    'deposit' => $depositEnabled,
                    'withdraw' => $withdrawEnabled,
                    'fee' => null,
                    'precision' => null,
                    'limits' => array(
                        'amount' => array( 'min' => null, 'max' => null ),
                        'withdraw' => array( 'min' => null, 'max' => null ),
                    ),
                );
            }
            return $result;
        }) ();
    }

    public function fetch_transaction_fee($code, $params = array ()) {
        return Async\async(function () use ($code, $params) {
            /**
             * fetch the fee for a transaction
             * @param {string} $code unified $currency $code
             * @param {array} $params extra parameters specific to the bitmart api endpoint
             * @return {array} a {@link https://docs.ccxt.com/en/latest/manual.html#fee-structure fee structure}
             */
            Async\await($this->load_markets());
            $currency = $this->currency($code);
            $request = array(
                'currency' => $currency['id'],
            );
            $response = Async\await($this->privateGetAccountV1WithdrawCharge (array_merge($request, $params)));
            //
            //     {
            //         message => 'OK',
            //         $code => '1000',
            //         trace => '3ecc0adf-91bd-4de7-aca1-886c1122f54f',
            //         $data => {
            //             today_available_withdraw_BTC => '100.0000',
            //             min_withdraw => '0.005',
            //             withdraw_precision => '8',
            //             withdraw_fee => '0.000500000000000000000000000000'
            //         }
            //     }
            //
            $data = $response['data'];
            $withdrawFees = array();
            $withdrawFees[$code] = $this->safe_number($data, 'withdraw_fee');
            return array(
                'info' => $response,
                'withdraw' => $withdrawFees,
                'deposit' => array(),
            );
        }) ();
    }

    public function parse_ticker($ticker, $market = null) {
        //
        // spot
        //
        //      {
        //          "symbol":"DOGE_USDT",
        //          "last_price":"0.128300",
        //          "quote_volume_24h":"2296619.060420",
        //          "base_volume_24h":"17508866.000000000000000000000000000000",
        //          "high_24h":"0.133900",
        //          "low_24h":"0.127799",
        //          "open_24h":"0.133100",
        //          "close_24h":"0.128300",
        //          "best_ask":"0.128530",
        //          "best_ask_size":"15170",
        //          "best_bid":"0.128200",
        //          "best_bid_size":"21232",
        //          "fluctuation":"-0.0361",
        //          "s_t" => 1610936002, // ws only
        //          "url":"https://www.bitmart.com/trade?$symbol=DOGE_USDT"
        //      }
        //
        // swap
        //
        //      {
        //          "contract_symbol":"DOGEUSDT",
        //          "last_price":"0.130340",
        //          "index_price":"0.13048245",
        //          "last_funding_rate":"0.00002287",
        //          "price_change_percent_24h":"-2.074",
        //          "volume_24h":"113705028.59482228",
        //          "url":"https://futures.bitmart.com/en?$symbol=DOGEUSDT",
        //          "high_price":"0.134520",
        //          "low_price":"0.128570",
        //          "legal_coin_price":"0.1302699"
        //      }
        //
        $timestamp = $this->safe_timestamp_2($ticker, 'timestamp', 's_t', $this->milliseconds());
        $marketId = $this->safe_string_2($ticker, 'symbol', 'contract_symbol');
        $market = $this->safe_market($marketId, $market);
        $symbol = $market['symbol'];
        $last = $this->safe_string_2($ticker, 'close_24h', 'last_price');
        $percentage = $this->safe_string($ticker, 'price_change_percent_24h');
        if ($percentage === null) {
            $percentageRaw = $this->safe_string($ticker, 'fluctuation');
            if (($percentageRaw !== null) && ($percentageRaw !== '0')) { // a few tickers show strictly '0' in fluctuation field
                $direction = $percentageRaw[0];
                $percentage = $direction . Precise::string_mul(str_replace($direction, '', $percentageRaw), '100');
            } elseif ($percentageRaw === '0') {
                $percentage = '0';
            }
        }
        $baseVolume = $this->safe_string($ticker, 'base_volume_24h');
        $quoteVolume = $this->safe_string($ticker, 'quote_volume_24h');
        $quoteVolume = $this->safe_string($ticker, 'volume_24h', $quoteVolume);
        $average = $this->safe_string_2($ticker, 'avg_price', 'index_price');
        $high = $this->safe_string_2($ticker, 'high_24h', 'high_price');
        $low = $this->safe_string_2($ticker, 'low_24h', 'low_price');
        return $this->safe_ticker(array(
            'symbol' => $symbol,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'high' => $high,
            'low' => $low,
            'bid' => $this->safe_string($ticker, 'best_bid'),
            'bidVolume' => $this->safe_string($ticker, 'best_bid_size'),
            'ask' => $this->safe_string($ticker, 'best_ask'),
            'askVolume' => $this->safe_string($ticker, 'best_ask_size'),
            'vwap' => null,
            'open' => $this->safe_string($ticker, 'open_24h'),
            'close' => $last,
            'last' => $last,
            'previousClose' => null,
            'change' => null,
            'percentage' => $percentage,
            'average' => $average,
            'baseVolume' => $baseVolume,
            'quoteVolume' => $quoteVolume,
            'info' => $ticker,
        ), $market);
    }

    public function fetch_ticker($symbol, $params = array ()) {
        return Async\async(function () use ($symbol, $params) {
            /**
             * fetches a price $ticker, a statistical calculation with the information calculated over the past 24 hours for a specific $market
             * @param {string} $symbol unified $symbol of the $market to fetch the $ticker for
             * @param {array} $params extra parameters specific to the bitmart api endpoint
             * @return {array} a {@link https://docs.ccxt.com/en/latest/manual.html#$ticker-structure $ticker structure}
             */
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $request = array();
            $method = null;
            if ($market['swap']) {
                $method = 'publicGetContractV1Tickers';
                $request['contract_symbol'] = $market['id'];
            } elseif ($market['spot']) {
                $method = 'publicGetSpotV1Ticker';
                $request['symbol'] = $market['id'];
            }
            $response = Async\await($this->$method (array_merge($request, $params)));
            //
            // spot
            //
            //     {
            //         "message":"OK",
            //         "code":1000,
            //         "trace":"6aa5b923-2f57-46e3-876d-feca190e0b82",
            //         "data":{
            //             "tickers":array(
            //                 {
            //                     "symbol":"ETH_BTC",
            //                     "last_price":"0.036037",
            //                     "quote_volume_24h":"4380.6660000000",
            //                     "base_volume_24h":"159.3582006712",
            //                     "high_24h":"0.036972",
            //                     "low_24h":"0.035524",
            //                     "open_24h":"0.036561",
            //                     "close_24h":"0.036037",
            //                     "best_ask":"0.036077",
            //                     "best_ask_size":"9.9500",
            //                     "best_bid":"0.035983",
            //                     "best_bid_size":"4.2792",
            //                     "fluctuation":"-0.0143",
            //                     "url":"https://www.bitmart.com/trade?$symbol=ETH_BTC"
            //                 }
            //             )
            //         }
            //     }
            //
            // swap
            //
            //      {
            //          "message":"OK",
            //          "code":1000,
            //          "trace":"4a0ebceb-d3f7-45a3-8feb-f61e230e24cd",
            //          "data":{
            //              "tickers":array(
            //                  {
            //                      "contract_symbol":"DOGEUSDT",
            //                      "last_price":"0.130180",
            //                      "index_price":"0.13028635",
            //                      "last_funding_rate":"0.00002025",
            //                      "price_change_percent_24h":"-2.326",
            //                      "volume_24h":"116789313.01797258",
            //                      "url":"https://futures.bitmart.com/en?$symbol=DOGEUSDT",
            //                      "high_price":"0.134520",
            //                      "low_price":"0.128570",
            //                      "legal_coin_price":"0.13017401"
            //                  }
            //              )
            //          }
            //      }
            //
            $data = $this->safe_value($response, 'data', array());
            $tickers = $this->safe_value($data, 'tickers', array());
            // fails in naming for contract $tickers 'contract_symbol'
            $tickersById = null;
            if ($market['spot']) {
                $tickersById = $this->index_by($tickers, 'symbol');
            } elseif ($market['swap']) {
                $tickersById = $this->index_by($tickers, 'contract_symbol');
            }
            $ticker = $this->safe_value($tickersById, $market['id']);
            return $this->parse_ticker($ticker, $market);
        }) ();
    }

    public function fetch_tickers($symbols = null, $params = array ()) {
        return Async\async(function () use ($symbols, $params) {
            /**
             * fetches price $tickers for multiple markets, statistical calculations with the information calculated over the past 24 hours each market
             * @param {[string]|null} $symbols unified $symbols of the markets to fetch the $ticker for, all market $tickers are returned if not assigned
             * @param {array} $params extra parameters specific to the bitmart api endpoint
             * @return {array} an array of {@link https://docs.ccxt.com/en/latest/manual.html#$ticker-structure $ticker structures}
             */
            Async\await($this->load_markets());
            $symbols = $this->market_symbols($symbols);
            list($marketType, $query) = $this->handle_market_type_and_params('fetchTickers', null, $params);
            $method = $this->get_supported_mapping($marketType, array(
                'spot' => 'publicGetSpotV1Ticker',
                'swap' => 'publicGetContractV1Tickers',
            ));
            $response = Async\await($this->$method ($query));
            $data = $this->safe_value($response, 'data', array());
            $tickers = $this->safe_value($data, 'tickers', array());
            $result = array();
            for ($i = 0; $i < count($tickers); $i++) {
                $ticker = $this->parse_ticker($tickers[$i]);
                $symbol = $ticker['symbol'];
                $result[$symbol] = $ticker;
            }
            return $this->filter_by_array($result, 'symbol', $symbols);
        }) ();
    }

    public function fetch_order_book($symbol, $limit = null, $params = array ()) {
        return Async\async(function () use ($symbol, $limit, $params) {
            /**
             * fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other $data
             * @param {string} $symbol unified $symbol of the $market to fetch the order book for
             * @param {int|null} $limit the maximum amount of order book entries to return
             * @param {array} $params extra parameters specific to the bitmart api endpoint
             * @return {array} A dictionary of {@link https://docs.ccxt.com/en/latest/manual.html#order-book-structure order book structures} indexed by $market symbols
             */
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            if (!$market['spot']) {
                throw new NotSupported($this->id . ' fetchOrderBook() does not support ' . $market['type'] . ' markets, only spot markets are accepted');
            }
            $request = array(
                'symbol' => $market['id'],
            );
            if ($limit !== null) {
                $request['size'] = $limit; // default 50, max 200
            }
            // $request['precision'] = 4; // optional price precision / depth level whose range is defined in $symbol details
            $response = Async\await($this->publicGetSpotV1SymbolsBook (array_merge($request, $params)));
            //
            // spot
            //
            //     {
            //         "message":"OK",
            //         "code":1000,
            //         "trace":"8254f8fc-431d-404f-ad9a-e716339f66c7",
            //         "data":{
            //             "buys":array(
            //                 array("amount":"4.7091","total":"4.71","price":"0.034047","count":"1"),
            //                 array("amount":"5.7439","total":"10.45","price":"0.034039","count":"1"),
            //                 array("amount":"2.5249","total":"12.98","price":"0.032937","count":"1"),
            //             ),
            //             "sells":array(
            //                 array("amount":"41.4365","total":"41.44","price":"0.034174","count":"1"),
            //                 array("amount":"4.2317","total":"45.67","price":"0.034183","count":"1"),
            //                 array("amount":"0.3000","total":"45.97","price":"0.034240","count":"1"),
            //             )
            //         }
            //     }
            //
            $data = $this->safe_value($response, 'data', array());
            $timestamp = $this->safe_integer($data, 'timestamp');
            return $this->parse_order_book($data, $symbol, $timestamp, 'buys', 'sells', 'price', 'amount');
        }) ();
    }

    public function parse_trade($trade, $market = null) {
        //
        // public fetchTrades spot ( amount = count * price )
        //
        //     {
        //          "amount" => "818.94",
        //          "order_time" => "1637601839035",    // ETH/USDT
        //          "price" => "4221.99",
        //          "count" => "0.19397",
        //          "type" => "buy"
        //      }
        //
        // private fetchMyTrades spot
        //
        //     {
        //         "detail_id":256348632,
        //         "order_id":2147484350,
        //         "symbol":"BTC_USDT",
        //         "create_time":1590462303000,
        //         "side":"buy",
        //         "fees":"0.00001350",
        //         "fee_coin_name":"BTC",
        //         "notional":"88.00000000",
        //         "price_avg":"8800.00",
        //         "size":"0.01000",
        //         "exec_type":"M"
        //     }
        //
        $id = $this->safe_string($trade, 'detail_id');
        $timestamp = $this->safe_integer_2($trade, 'order_time', 'create_time');
        $type = null;
        $side = $this->safe_string_lower_2($trade, 'type', 'side');
        $takerOrMaker = null;
        $execType = $this->safe_string($trade, 'exec_type');
        if ($execType !== null) {
            $takerOrMaker = ($execType === 'M') ? 'maker' : 'taker';
        }
        $priceString = $this->safe_string($trade, 'price');
        $priceString = $this->safe_string($trade, 'price_avg', $priceString);
        $amountString = $this->safe_string($trade, 'count');
        $amountString = $this->safe_string($trade, 'size', $amountString);
        $costString = $this->safe_string_2($trade, 'amount', 'notional');
        $orderId = $this->safe_string($trade, 'order_id');
        $marketId = $this->safe_string($trade, 'symbol');
        $market = $this->safe_market($marketId, $market, '_');
        $feeCostString = $this->safe_string($trade, 'fees');
        $fee = null;
        if ($feeCostString !== null) {
            $feeCurrencyId = $this->safe_string($trade, 'fee_coin_name');
            $feeCurrencyCode = $this->safe_currency_code($feeCurrencyId);
            if ($feeCurrencyCode === null) {
                $feeCurrencyCode = ($side === 'buy') ? $market['base'] : $market['quote'];
            }
            $fee = array(
                'cost' => $feeCostString,
                'currency' => $feeCurrencyCode,
            );
        }
        return $this->safe_trade(array(
            'info' => $trade,
            'id' => $id,
            'order' => $orderId,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'symbol' => $market['symbol'],
            'type' => $type,
            'side' => $side,
            'price' => $priceString,
            'amount' => $amountString,
            'cost' => $costString,
            'takerOrMaker' => $takerOrMaker,
            'fee' => $fee,
        ), $market);
    }

    public function fetch_trades($symbol, $since = null, $limit = null, $params = array ()) {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            /**
             * get the list of most recent $trades for a particular $symbol
             * @param {string} $symbol unified $symbol of the $market to fetch $trades for
             * @param {int|null} $since timestamp in ms of the earliest trade to fetch
             * @param {int|null} $limit the maximum amount of $trades to fetch
             * @param {array} $params extra parameters specific to the bitmart api endpoint
             * @return {[array]} a list of ~@link https://docs.ccxt.com/en/latest/manual.html?#public-$trades trade structures~
             */
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            if (!$market['spot']) {
                throw new NotSupported($this->id . ' fetchTrades() does not support ' . $market['type'] . ' orders, only spot orders are accepted');
            }
            $request = array(
                'symbol' => $market['id'],
            );
            $response = Async\await($this->publicGetSpotV1SymbolsTrades (array_merge($request, $params)));
            //
            // spot
            //
            //     {
            //         "message":"OK",
            //         "code":1000,
            //         "trace":"222d74c0-8f6d-49d9-8e1b-98118c50eeba",
            //         "data":{
            //             "trades":array(
            //                 array(
            //                     "amount":"0.005703",
            //                     "order_time":1599652045394,
            //                     "price":"0.034029",
            //                     "count":"0.1676",
            //                     "type":"sell"
            //                 ),
            //             )
            //         }
            //     }
            //
            $data = $this->safe_value($response, 'data', array());
            $trades = $this->safe_value($data, 'trades', array());
            return $this->parse_trades($trades, $market, $since, $limit);
        }) ();
    }

    public function parse_ohlcv($ohlcv, $market = null) {
        //
        // spot
        //
        //     {
        //         "last_price":"0.034987",
        //         "timestamp":1598787420,
        //         "volume":"1.0198",
        //         "open":"0.035007",
        //         "close":"0.034987",
        //         "high":"0.035007",
        //         "low":"0.034986"
        //     }
        //
        // swap
        //
        //     {
        //         "low_price" => "20090.3",
        //         "high_price" => "20095.5",
        //         "open_price" => "20092.6",
        //         "close_price" => "20091.4",
        //         "volume" => "8748",
        //         "timestamp" => 1665002281
        //     }
        //
        // ws
        //
        //     array(
        //         1631056350, // timestamp
        //         '46532.83', // oopen
        //         '46555.71', // high
        //         '46511.41', // low
        //         '46555.71', // close
        //         '0.25', // volume
        //     )
        //
        if (gettype($ohlcv) === 'array' && array_keys($ohlcv) === array_keys(array_keys($ohlcv))) {
            return array(
                $this->safe_timestamp($ohlcv, 0),
                $this->safe_number($ohlcv, 1),
                $this->safe_number($ohlcv, 2),
                $this->safe_number($ohlcv, 3),
                $this->safe_number($ohlcv, 4),
                $this->safe_number($ohlcv, 5),
            );
        } else {
            return array(
                $this->safe_timestamp($ohlcv, 'timestamp'),
                $this->safe_number_2($ohlcv, 'open', 'open_price'),
                $this->safe_number_2($ohlcv, 'high', 'high_price'),
                $this->safe_number_2($ohlcv, 'low', 'low_price'),
                $this->safe_number_2($ohlcv, 'close', 'close_price'),
                $this->safe_number($ohlcv, 'volume'),
            );
        }
    }

    public function fetch_ohlcv($symbol, $timeframe = '1m', $since = null, $limit = null, $params = array ()) {
        return Async\async(function () use ($symbol, $timeframe, $since, $limit, $params) {
            /**
             * fetches historical candlestick $data containing the open, high, low, and close price, and the volume of a $market
             * @see https://developer-pro.bitmart.com/en/spot/#get-k-line
             * @see https://developer-pro.bitmart.com/en/futures/#get-k-line
             * @param {string} $symbol unified $symbol of the $market to fetch OHLCV $data for
             * @param {string} $timeframe the length of time each candle represents
             * @param {int|null} $since timestamp in ms of the earliest candle to fetch
             * @param {int|null} $limit the maximum amount of candles to fetch
             * @param {array} $params extra parameters specific to the bitmart api endpoint
             * @return {[[int]]} A list of candles ordered as timestamp, open, high, low, close, volume
             */
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $type = $market['type'];
            $duration = $this->parse_timeframe($timeframe);
            $request = array(
                'symbol' => $market['id'],
                'step' => $this->timeframes[$timeframe],
            );
            $maxLimit = 500;
            if ($limit === null) {
                $limit = $maxLimit;
            }
            $limit = min ($maxLimit, $limit);
            $now = intval($this->milliseconds() / 1000);
            $fromRequest = ($type === 'spot') ? 'from' : 'start_time';
            $toRequest = ($type === 'spot') ? 'to' : 'end_time';
            if ($since === null) {
                $start = $now - $limit * $duration;
                $request[$fromRequest] = $start;
                $request[$toRequest] = $now;
            } else {
                $start = intval($since / 1000) - 1;
                $end = $this->sum($start, $limit * $duration);
                $request[$fromRequest] = $start;
                $request[$toRequest] = min ($end, $now);
            }
            $method = 'publicGetSpotV1SymbolsKline';
            if ($type === 'swap') {
                $method = 'publicGetContractPublicKline';
            }
            $response = Async\await($this->$method (array_merge($request, $params)));
            //
            // spot
            //
            //     {
            //         "message":"OK",
            //         "code":1000,
            //         "trace":"80d86378-ab4e-4c70-819e-b42146cf87ad",
            //         "data":{
            //             "klines":array(
            //                 array("last_price":"0.034987","timestamp":1598787420,"volume":"1.0198","open":"0.035007","close":"0.034987","high":"0.035007","low":"0.034986"),
            //                 array("last_price":"0.034986","timestamp":1598787480,"volume":"0.3959","open":"0.034982","close":"0.034986","high":"0.034986","low":"0.034980"),
            //                 array("last_price":"0.034978","timestamp":1598787540,"volume":"0.3259","open":"0.034987","close":"0.034978","high":"0.034987","low":"0.034977"),
            //             )
            //         }
            //     }
            //
            // swap
            //
            //     {
            //         "code" => 1000,
            //         "message" => "Ok",
            //         "data" => array(
            //             array(
            //                 "low_price" => "20090.3",
            //                 "high_price" => "20095.5",
            //                 "open_price" => "20092.6",
            //                 "close_price" => "20091.4",
            //                 "volume" => "8748",
            //                 "timestamp" => 1665002281
            //             ),
            //             ...
            //         ),
            //         "trace" => "96c989db-e0f5-46f5-bba6-60cfcbde699b"
            //     }
            //
            $data = $this->safe_value($response, 'data', array());
            $klines = $this->safe_value($data, 'klines', array());
            $ohlcv = ($type === 'spot') ? $klines : $data;
            return $this->parse_ohlcvs($ohlcv, $market, $timeframe, $since, $limit);
        }) ();
    }

    public function fetch_my_trades($symbol = null, $since = null, $limit = null, $params = array ()) {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            /**
             * fetch all $trades made by the user
             * @param {string} $symbol unified $market $symbol
             * @param {int|null} $since the earliest time in ms to fetch $trades for
             * @param {int|null} $limit the maximum number of $trades structures to retrieve
             * @param {array} $params extra parameters specific to the bitmart api endpoint
             * @return {[array]} a list of {@link https://docs.ccxt.com/en/latest/manual.html#trade-structure trade structures}
             */
            if ($symbol === null) {
                throw new ArgumentsRequired($this->id . ' fetchMyTrades() requires a $symbol argument');
            }
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            if (!$market['spot']) {
                throw new NotSupported($this->id . ' fetchMyTrades() does not support ' . $market['type'] . ' orders, only spot orders are accepted');
            }
            $options = $this->safe_value($this->options, 'fetchMyTrades', array());
            $defaultLimit = $this->safe_integer($options, 'limit', 200);
            if ($limit === null) {
                $limit = $defaultLimit;
            }
            $request = array(
                'symbol' => $market['id'],
                'N' => $limit,
            );
            $response = Async\await($this->privateGetSpotV2Trades (array_merge($request, $params)));
            //
            // spot
            //
            //     {
            //         "message":"OK",
            //         "code":1000,
            //         "trace":"a06a5c53-8e6f-42d6-8082-2ff4718d221c",
            //         "data":{
            //             "current_page":1,
            //             "trades":array(
            //                 array(
            //                     "detail_id":256348632,
            //                     "order_id":2147484350,
            //                     "symbol":"BTC_USDT",
            //                     "create_time":1590462303000,
            //                     "side":"buy",
            //                     "fees":"0.00001350",
            //                     "fee_coin_name":"BTC",
            //                     "notional":"88.00000000",
            //                     "price_avg":"8800.00",
            //                     "size":"0.01000",
            //                     "exec_type":"M"
            //                 ),
            //             )
            //         }
            //     }
            //
            $data = $this->safe_value($response, 'data', array());
            $trades = $this->safe_value($data, 'trades', array());
            return $this->parse_trades($trades, $market, $since, $limit);
        }) ();
    }

    public function fetch_order_trades($id, $symbol = null, $since = null, $limit = null, $params = array ()) {
        return Async\async(function () use ($id, $symbol, $since, $limit, $params) {
            /**
             * fetch all the $trades made from a single order
             * @param {string} $id order $id
             * @param {string} $symbol unified $market $symbol
             * @param {int|null} $since the earliest time in ms to fetch $trades for
             * @param {int|null} $limit the maximum number of $trades to retrieve
             * @param {array} $params extra parameters specific to the bitmart api endpoint
             * @return {[array]} a list of {@link https://docs.ccxt.com/en/latest/manual.html#trade-structure trade structures}
             */
            if ($symbol === null) {
                throw new ArgumentsRequired($this->id . ' fetchOrderTrades() requires a $symbol argument');
            }
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            if (!$market['spot']) {
                throw new NotSupported($this->id . ' fetchOrderTrades() does not support ' . $market['type'] . ' orders, only spot orders are accepted');
            }
            $options = $this->safe_value($this->options, 'fetchOrderTrades', array());
            $defaultLimit = $this->safe_integer($options, 'limit', 200);
            if ($limit === null) {
                $limit = $defaultLimit;
            }
            $request = array(
                'symbol' => $market['id'],
                'order_id' => $id,
                'N' => $limit,
            );
            $response = Async\await($this->privateGetSpotV2Trades (array_merge($request, $params)));
            //
            // spot
            //
            //     {
            //         "message":"OK",
            //         "code":1000,
            //         "trace":"a06a5c53-8e6f-42d6-8082-2ff4718d221c",
            //         "data":{
            //             "current_page":1,
            //             "trades":array(
            //                 array(
            //                     "detail_id":256348632,
            //                     "order_id":2147484350,
            //                     "symbol":"BTC_USDT",
            //                     "create_time":1590462303000,
            //                     "side":"buy",
            //                     "fees":"0.00001350",
            //                     "fee_coin_name":"BTC",
            //                     "notional":"88.00000000",
            //                     "price_avg":"8800.00",
            //                     "size":"0.01000",
            //                     "exec_type":"M"
            //                 ),
            //             )
            //         }
            //     }
            //
            $data = $this->safe_value($response, 'data', array());
            $trades = $this->safe_value($data, 'trades', array());
            return $this->parse_trades($trades, $market, $since, $limit);
        }) ();
    }

    public function parse_balance($response, $marketType) {
        $wallet = null;
        if ($marketType === 'swap') {
            $wallet = $this->safe_value($response, 'data', array());
        } else {
            $data = $this->safe_value($response, 'data', array());
            $wallet = $this->safe_value($data, 'wallet', array());
        }
        $result = array( 'info' => $response );
        for ($i = 0; $i < count($wallet); $i++) {
            $balance = $wallet[$i];
            $currencyId = $this->safe_string_2($balance, 'id', 'currency');
            $currencyId = $this->safe_string($balance, 'coin_code', $currencyId);
            $code = $this->safe_currency_code($currencyId);
            $account = $this->account();
            $account['free'] = $this->safe_string_2($balance, 'available', 'available_balance');
            $account['used'] = $this->safe_string_2($balance, 'frozen', 'frozen_balance');
            $result[$code] = $account;
        }
        return $this->safe_balance($result);
    }

    public function fetch_balance($params = array ()) {
        return Async\async(function () use ($params) {
            /**
             * $query for balance and get the amount of funds available for trading or funds locked in orders
             * @param {array} $params extra parameters specific to the bitmart api endpoint
             * @return {array} a ~@link https://docs.ccxt.com/en/latest/manual.html?#balance-structure balance structure~
             */
            Async\await($this->load_markets());
            list($marketType, $query) = $this->handle_market_type_and_params('fetchBalance', null, $params);
            $method = $this->get_supported_mapping($marketType, array(
                'spot' => 'privateGetSpotV1Wallet',
                'swap' => 'privateGetContractPrivateAssetsDetail',
                'account' => 'privateGetAccountV1Wallet',
            ));
            $response = Async\await($this->$method ($query));
            //
            // spot
            //
            //     {
            //         "message":"OK",
            //         "code":1000,
            //         "trace":"39069916-72f9-44c7-acde-2ad5afd21cad",
            //         "data":{
            //             "wallet":array(
            //                 array("id":"BTC","name":"Bitcoin","available":"0.00000062","frozen":"0.00000000"),
            //                 array("id":"ETH","name":"Ethereum","available":"0.00002277","frozen":"0.00000000"),
            //                 array("id":"BMX","name":"BitMart Token","available":"0.00000000","frozen":"0.00000000")
            //             )
            //         }
            //     }
            //
            // account
            //
            //     {
            //         "message":"OK",
            //         "code":1000,
            //         "trace":"5c3b7fc7-93b2-49ef-bb59-7fdc56915b59",
            //         "data":{
            //             "wallet":array(
            //                 array("currency":"BTC","name":"Bitcoin","available":"0.00000062","frozen":"0.00000000"),
            //                 array("currency":"ETH","name":"Ethereum","available":"0.00002277","frozen":"0.00000000")
            //             )
            //         }
            //     }
            //
            // swap
            //
            //     {
            //         "code" => 1000,
            //         "message" => "Ok",
            //         "data" => array(
            //             array(
            //                 "currency" => "USDT",
            //                 "available_balance" => "0",
            //                 "frozen_balance" => "0",
            //                 "unrealized" => "0",
            //                 "equity" => "0",
            //                 "position_deposit" => "0"
            //             ),
            //             ...
            //         ),
            //         "trace" => "f9da3a39-cf45-42e7-914d-294f565dfc33"
            //     }
            //
            return $this->parse_balance($response, $marketType);
        }) ();
    }

    public function parse_trading_fee($fee, $market = null) {
        //
        //     {
        //         $symbol => 'ETH_USDT',
        //         taker_fee_rate => '0.0025',
        //         maker_fee_rate => '0.0025'
        //     }
        //
        $marketId = $this->safe_string($fee, 'symbol');
        $symbol = $this->safe_symbol($marketId);
        return array(
            'info' => $fee,
            'symbol' => $symbol,
            'maker' => $this->safe_number($fee, 'maker_fee_rate'),
            'taker' => $this->safe_number($fee, 'taker_fee_rate'),
        );
    }

    public function fetch_trading_fee($symbol, $params = array ()) {
        return Async\async(function () use ($symbol, $params) {
            /**
             * fetch the trading fees for a $market
             * @param {string} $symbol unified $market $symbol
             * @param {array} $params extra parameters specific to the bitmart api endpoint
             * @return {array} a {@link https://docs.ccxt.com/en/latest/manual.html#fee-structure fee structure}
             */
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            if (!$market['spot']) {
                throw new NotSupported($this->id . ' fetchTradingFee() does not support ' . $market['type'] . ' orders, only spot orders are accepted');
            }
            $request = array(
                'symbol' => $market['id'],
            );
            $response = Async\await($this->privateGetSpotV1TradeFee (array_merge($request, $params)));
            //
            //     {
            //         message => 'OK',
            //         code => '1000',
            //         trace => '5a6f1e40-37fe-4849-a494-03279fadcc62',
            //         $data => {
            //             $symbol => 'ETH_USDT',
            //             taker_fee_rate => '0.0025',
            //             maker_fee_rate => '0.0025'
            //         }
            //     }
            //
            $data = $this->safe_value($response, 'data');
            return $this->parse_trading_fee($data);
        }) ();
    }

    public function parse_order($order, $market = null) {
        //
        // createOrder
        //
        //     {
        //         "order_id" => 2707217580
        //     }
        //
        // cancelOrder
        //
        //     '2707217580' // $order $id
        //
        // spot fetchOrder, fetchOrdersByStatus, fetchOpenOrders, fetchClosedOrders
        //
        //     {
        //         "order_id":1736871726781,
        //         "symbol":"BTC_USDT",
        //         "create_time":1591096004000,
        //         "side":"sell",
        //         "type":"market", // limit, $market, limit_maker, ioc
        //         "price":"0.00",
        //         "price_avg":"0.00",
        //         "size":"0.02000",
        //         "notional":"0.00000000",
        //         "filled_notional":"0.00000000",
        //         "filled_size":"0.00000",
        //         "status":"8"
        //     }
        //
        $id = null;
        if (gettype($order) === 'string') {
            $id = $order;
            $order = array();
        }
        $id = $this->safe_string($order, 'order_id', $id);
        $timestamp = $this->safe_integer($order, 'create_time');
        $marketId = $this->safe_string($order, 'symbol');
        $symbol = $this->safe_symbol($marketId, $market, '_');
        $status = null;
        if ($market !== null) {
            $status = $this->parse_order_status_by_type($market['type'], $this->safe_string($order, 'status'));
        }
        $amount = $this->safe_string($order, 'size');
        $filled = $this->safe_string($order, 'filled_size');
        $average = $this->safe_string($order, 'price_avg');
        $price = $this->safe_string($order, 'price');
        $side = $this->safe_string($order, 'side');
        $type = $this->safe_string($order, 'type');
        $timeInForce = null;
        $postOnly = null;
        if ($type === 'limit_maker') {
            $type = 'limit';
            $postOnly = true;
            $timeInForce = 'PO';
        }
        if ($type === 'ioc') {
            $type = 'limit';
            $timeInForce = 'IOC';
        }
        return $this->safe_order(array(
            'id' => $id,
            'clientOrderId' => null,
            'info' => $order,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'lastTradeTimestamp' => null,
            'symbol' => $symbol,
            'type' => $type,
            'timeInForce' => $timeInForce,
            'postOnly' => $postOnly,
            'side' => $side,
            'price' => $price,
            'stopPrice' => null,
            'amount' => $amount,
            'cost' => null,
            'average' => $average,
            'filled' => $filled,
            'remaining' => null,
            'status' => $status,
            'fee' => null,
            'trades' => null,
        ), $market);
    }

    public function parse_order_status_by_type($type, $status) {
        $statusesByType = array(
            'spot' => array(
                '1' => 'failed', // Order failure
                '2' => 'open', // Placing order
                '3' => 'failed', // Order failure, Freeze failure
                '4' => 'open', // Order success, Pending for fulfilment
                '5' => 'open', // Partially filled
                '6' => 'closed', // Fully filled
                '7' => 'canceling', // Canceling
                '8' => 'canceled', // Canceled
            ),
            'swap' => array(
                '1' => 'open', // Submitting
                '2' => 'open', // Commissioned
                '4' => 'closed', // Completed
            ),
        );
        $statuses = $this->safe_value($statusesByType, $type, array());
        return $this->safe_string($statuses, $status, $status);
    }

    public function create_order($symbol, $type, $side, $amount, $price = null, $params = array ()) {
        return Async\async(function () use ($symbol, $type, $side, $amount, $price, $params) {
            /**
             * create a trade $order
             * @see https://developer-pro.bitmart.com/en/spot/#place-spot-$order
             * @see https://developer-pro.bitmart.com/en/spot/#place-margin-$order
             * @param {string} $symbol unified $symbol of the $market to create an $order in
             * @param {string} $type 'market' or 'limit'
             * @param {string} $side 'buy' or 'sell'
             * @param {float} $amount how much of currency you want to trade in units of base currency
             * @param {float|null} $price the $price at which the $order is to be fullfilled, in units of the quote currency, ignored in $market orders
             * @param {array} $params extra parameters specific to the bitmart api endpoint
             * @param {string|null} $params->marginMode 'cross' or 'isolated'
             * @return {array} an {@link https://docs.ccxt.com/en/latest/manual.html#$order-structure $order structure}
             */
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $request = array();
            $timeInForce = $this->safe_string($params, 'timeInForce');
            if ($timeInForce === 'FOK') {
                throw new InvalidOrder($this->id . ' createOrder() only accepts $timeInForce parameter values of IOC or PO');
            }
            $isMarketOrder = $type === 'market';
            $postOnly = $this->is_post_only($isMarketOrder, $type === 'limit_maker', $params);
            $params = $this->omit($params, array( 'timeInForce', 'postOnly' ));
            $ioc = (($timeInForce === 'IOC') || ($type === 'ioc'));
            $isLimitOrder = ($type === 'limit') || $postOnly || $ioc;
            $method = null;
            if ($market['spot']) {
                $request['symbol'] = $market['id'];
                $request['side'] = $side;
                $request['type'] = $type;
                $method = 'privatePostSpotV2SubmitOrder';
                if ($isLimitOrder) {
                    $request['size'] = $this->amount_to_precision($symbol, $amount);
                    $request['price'] = $this->price_to_precision($symbol, $price);
                } elseif ($isMarketOrder) {
                    // for $market buy it requires the $amount of quote currency to spend
                    if ($side === 'buy') {
                        $notional = $this->safe_number($params, 'notional');
                        $createMarketBuyOrderRequiresPrice = $this->safe_value($this->options, 'createMarketBuyOrderRequiresPrice', true);
                        if ($createMarketBuyOrderRequiresPrice) {
                            if ($price !== null) {
                                if ($notional === null) {
                                    $amountString = $this->number_to_string($amount);
                                    $priceString = $this->number_to_string($price);
                                    $notional = $this->parse_number(Precise::string_mul($amountString, $priceString));
                                }
                            } elseif ($notional === null) {
                                throw new InvalidOrder($this->id . " createOrder () requires the $price argument with $market buy orders to calculate total $order cost ($amount to spend), where cost = $amount * $price-> Supply a $price argument to createOrder() call if you want the cost to be calculated for you from $price and $amount, or, alternatively, add .options['createMarketBuyOrderRequiresPrice'] = false and supply the total cost value in the 'amount' argument or in the 'notional' extra parameter (the exchange-specific behaviour)");
                            }
                        } else {
                            $notional = ($notional === null) ? $amount : $notional;
                        }
                        $request['notional'] = $this->decimal_to_precision($notional, TRUNCATE, $market['precision']['price'], $this->precisionMode);
                    } elseif ($side === 'sell') {
                        $request['size'] = $this->amount_to_precision($symbol, $amount);
                    }
                }
            } elseif ($market['swap']) {
                throw new NotSupported($this->id . ' createOrder() does not accept swap orders, only spot orders are allowed');
            }
            if ($postOnly) {
                $request['type'] = 'limit_maker';
            }
            if ($ioc) {
                $request['type'] = 'ioc';
            }
            list($marginMode, $query) = $this->handle_margin_mode_and_params('createOrder', $params);
            if ($marginMode !== null) {
                $method = 'privatePostSpotV1MarginSubmitOrder';
            }
            $response = Async\await($this->$method (array_merge($request, $query)));
            //
            // spot and margin
            //
            //     {
            //         "code" => 1000,
            //         "trace":"886fb6ae-456b-4654-b4e0-d681ac05cea1",
            //         "message" => "OK",
            //         "data" => {
            //             "order_id" => 2707217580
            //         }
            //     }
            //
            $data = $this->safe_value($response, 'data', array());
            $order = $this->parse_order($data, $market);
            return array_merge($order, array(
                'type' => $type,
                'side' => $side,
                'amount' => $amount,
                'price' => $price,
            ));
        }) ();
    }

    public function cancel_order($id, $symbol = null, $params = array ()) {
        return Async\async(function () use ($id, $symbol, $params) {
            /**
             * cancels an open $order
             * @param {string} $id $order $id
             * @param {string} $symbol unified $symbol of the $market the $order was made in
             * @param {array} $params extra parameters specific to the bitmart api endpoint
             * @return {array} An {@link https://docs.ccxt.com/en/latest/manual.html#$order-structure $order structure}
             */
            if ($symbol === null) {
                throw new ArgumentsRequired($this->id . ' cancelOrder() requires a $symbol argument');
            }
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            if (!$market['spot']) {
                throw new NotSupported($this->id . ' cancelOrder() does not support ' . $market['type'] . ' orders, only spot orders are accepted');
            }
            $request = array(
                'order_id' => (string) $id,
                'symbol' => $market['id'],
            );
            $response = Async\await($this->privatePostSpotV3CancelOrder (array_merge($request, $params)));
            //
            // spot
            //
            //     {
            //         "code" => 1000,
            //         "trace":"886fb6ae-456b-4654-b4e0-d681ac05cea1",
            //         "message" => "OK",
            //         "data" => {
            //             "result" => true
            //         }
            //     }
            //
            // spot alternative
            //
            //     {
            //         "code" => 1000,
            //         "trace":"886fb6ae-456b-4654-b4e0-d681ac05cea1",
            //         "message" => "OK",
            //         "data" => true
            //     }
            //
            $data = $this->safe_value($response, 'data');
            if ($data === true) {
                return $this->parse_order($id, $market);
            }
            $succeeded = $this->safe_value($data, 'succeed');
            if ($succeeded !== null) {
                $id = $this->safe_string($succeeded, 0);
                if ($id === null) {
                    throw new InvalidOrder($this->id . ' cancelOrder() failed to cancel ' . $symbol . ' $order $id ' . $id);
                }
            } else {
                $result = $this->safe_value($data, 'result');
                if (!$result) {
                    throw new InvalidOrder($this->id . ' cancelOrder() ' . $symbol . ' $order $id ' . $id . ' is filled or canceled');
                }
            }
            $order = $this->parse_order($id, $market);
            return array_merge($order, array( 'id' => $id ));
        }) ();
    }

    public function cancel_all_orders($symbol = null, $params = array ()) {
        return Async\async(function () use ($symbol, $params) {
            /**
             * cancel all open orders in a $market
             * @param {string} $symbol unified $market $symbol of the $market to cancel orders in
             * @param {array} $params extra parameters specific to the bitmart api endpoint
             * @return {[array]} a list of {@link https://docs.ccxt.com/en/latest/manual.html#order-structure order structures}
             */
            if ($symbol === null) {
                throw new ArgumentsRequired($this->id . ' cancelAllOrders() requires a $symbol argument');
            }
            $side = $this->safe_string($params, 'side');
            if ($side === null) {
                throw new ArgumentsRequired($this->id . " cancelAllOrders() requires a `$side` parameter ('buy' or 'sell')");
            }
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            if (!$market['spot']) {
                throw new NotSupported($this->id . ' cancelAllOrders() does not support ' . $market['type'] . ' orders, only spot orders are accepted');
            }
            $request = array(
                'symbol' => $market['id'],
                'side' => $side, // 'buy' or 'sell'
            );
            $response = Async\await($this->privatePostSpotV1CancelOrders (array_merge($request, $params)));
            //
            //     {
            //         "code" => 1000,
            //         "trace":"886fb6ae-456b-4654-b4e0-d681ac05cea1",
            //         "message" => "OK",
            //         "data" => array()
            //     }
            //
            return $response;
        }) ();
    }

    public function fetch_orders_by_status($status, $symbol = null, $since = null, $limit = null, $params = array ()) {
        return Async\async(function () use ($status, $symbol, $since, $limit, $params) {
            if ($symbol === null) {
                throw new ArgumentsRequired($this->id . ' fetchOrdersByStatus() requires a $symbol argument');
            }
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            if (!$market['spot']) {
                throw new NotSupported($this->id . ' fetchOrdersByStatus() does not support ' . $market['type'] . ' $orders, only spot $orders are accepted');
            }
            $request = array(
                'symbol' => $market['id'],
                'offset' => 1, // max offset * $limit < 500
                'N' => 100, // max $limit is 100
            );
            if ($status === 'open') {
                $request['status'] = 9;
            } elseif ($status === 'closed') {
                $request['status'] = 6;
            } elseif ($status === 'canceled') {
                $request['status'] = 8;
            } else {
                $request['status'] = $status;
            }
            $response = Async\await($this->privateGetSpotV3Orders (array_merge($request, $params)));
            //
            // spot
            //
            //     {
            //         "message":"OK",
            //         "code":1000,
            //         "trace":"70e7d427-7436-4fb8-8cdd-97e1f5eadbe9",
            //         "data":{
            //             "current_page":1,
            //             "orders":array(
            //                 {
            //                     "order_id":2147601241,
            //                     "symbol":"BTC_USDT",
            //                     "create_time":1591099963000,
            //                     "side":"sell",
            //                     "type":"limit",
            //                     "price":"9000.00",
            //                     "price_avg":"0.00",
            //                     "size":"1.00000",
            //                     "notional":"9000.00000000",
            //                     "filled_notional":"0.00000000",
            //                     "filled_size":"0.00000",
            //                     "status":"4"
            //                 }
            //             )
            //         }
            //     }
            //
            $data = $this->safe_value($response, 'data', array());
            $orders = $this->safe_value($data, 'orders', array());
            return $this->parse_orders($orders, $market, $since, $limit);
        }) ();
    }

    public function fetch_open_orders($symbol = null, $since = null, $limit = null, $params = array ()) {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            /**
             * fetch all unfilled currently open orders
             * @param {string} $symbol unified market $symbol
             * @param {int|null} $since the earliest time in ms to fetch open orders for
             * @param {int|null} $limit the maximum number of  open orders structures to retrieve
             * @param {array} $params extra parameters specific to the bitmart api endpoint
             * @return {[array]} a list of {@link https://docs.ccxt.com/en/latest/manual.html#order-structure order structures}
             */
            return Async\await($this->fetch_orders_by_status('open', $symbol, $since, $limit, $params));
        }) ();
    }

    public function fetch_closed_orders($symbol = null, $since = null, $limit = null, $params = array ()) {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            /**
             * fetches information on multiple closed orders made by the user
             * @param {string} $symbol unified market $symbol of the market orders were made in
             * @param {int|null} $since the earliest time in ms to fetch orders for
             * @param {int|null} $limit the maximum number of  orde structures to retrieve
             * @param {array} $params extra parameters specific to the bitmart api endpoint
             * @return {[array]} a list of {@link https://docs.ccxt.com/en/latest/manual.html#order-structure order structures}
             */
            return Async\await($this->fetch_orders_by_status('closed', $symbol, $since, $limit, $params));
        }) ();
    }

    public function fetch_canceled_orders($symbol = null, $since = null, $limit = null, $params = array ()) {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            /**
             * fetches information on multiple canceled orders made by the user
             * @param {string} $symbol unified market $symbol of the market orders were made in
             * @param {int|null} $since timestamp in ms of the earliest order, default is null
             * @param {int|null} $limit max number of orders to return, default is null
             * @param {array} $params extra parameters specific to the bitmart api endpoint
             * @return {array} a list of {@link https://docs.ccxt.com/en/latest/manual.html#order-structure order structures}
             */
            return Async\await($this->fetch_orders_by_status('canceled', $symbol, $since, $limit, $params));
        }) ();
    }

    public function fetch_order($id, $symbol = null, $params = array ()) {
        return Async\async(function () use ($id, $symbol, $params) {
            /**
             * fetches information on an order made by the user
             * @param {string} $symbol unified $symbol of the $market the order was made in
             * @param {array} $params extra parameters specific to the bitmart api endpoint
             * @return {array} An {@link https://docs.ccxt.com/en/latest/manual.html#order-structure order structure}
             */
            if ($symbol === null) {
                throw new ArgumentsRequired($this->id . ' fetchOrder() requires a $symbol argument');
            }
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            if (!$market['spot']) {
                throw new NotSupported($this->id . ' fetchOrder() does not support ' . $market['type'] . ' orders, only spot orders are accepted');
            }
            if (gettype($id) !== 'string') {
                $id = (string) $id;
            }
            $request = array(
                'symbol' => $market['id'],
                'order_id' => $id,
            );
            $response = Async\await($this->privateGetSpotV2OrderDetail (array_merge($request, $params)));
            //
            // spot
            //
            //     {
            //         "message":"OK",
            //         "code":1000,
            //         "trace":"a27c2cb5-ead4-471d-8455-1cfeda054ea6",
            //         "data" => {
            //             "order_id":1736871726781,
            //             "symbol":"BTC_USDT",
            //             "create_time":1591096004000,
            //             "side":"sell",
            //             "type":"market",
            //             "price":"0.00",
            //             "price_avg":"0.00",
            //             "size":"0.02000",
            //             "notional":"0.00000000",
            //             "filled_notional":"0.00000000",
            //             "filled_size":"0.00000",
            //             "status":"8"
            //         }
            //     }
            //
            $data = $this->safe_value($response, 'data', array());
            return $this->parse_order($data, $market);
        }) ();
    }

    public function fetch_deposit_address($code, $params = array ()) {
        return Async\async(function () use ($code, $params) {
            /**
             * fetch the deposit $address for a $currency associated with this account
             * @param {string} $code unified $currency $code
             * @param {array} $params extra parameters specific to the bitmart api endpoint
             * @return {array} an {@link https://docs.ccxt.com/en/latest/manual.html#$address-structure $address structure}
             */
            Async\await($this->load_markets());
            $currency = $this->currency($code);
            $request = array(
                'currency' => $currency['id'],
            );
            if ($code === 'USDT') {
                $defaultNetworks = $this->safe_value($this->options, 'defaultNetworks');
                $defaultNetwork = $this->safe_string_upper($defaultNetworks, $code);
                $networks = $this->safe_value($this->options, 'networks', array());
                $network = $this->safe_string_upper($params, 'network', $defaultNetwork); // this line allows the user to specify either ERC20 or ETH
                $network = $this->safe_string($networks, $network, $network); // handle ERC20>ETH alias
                if ($network !== null) {
                    $request['currency'] .= '-' . $network; // when $network the $currency need to be changed to $currency . '-' . $network https://developer-pro.bitmart.com/en/account/withdraw_apply.html on the end of page
                    $params = $this->omit($params, 'network');
                }
            }
            $response = Async\await($this->privateGetAccountV1DepositAddress (array_merge($request, $params)));
            //
            //     {
            //         "message":"OK",
            //         "code":1000,
            //         "trace":"0e6edd79-f77f-4251-abe5-83ba75d06c1a",
            //         "data":{
            //             "currency":"USDT-TRC20",
            //             "chain":"USDT-TRC20",
            //             "address":"TGR3ghy2b5VLbyAYrmiE15jasR6aPHTvC5",
            //             "address_memo":""
            //         }
            //     }
            //
            $data = $this->safe_value($response, 'data', array());
            $address = $this->safe_string($data, 'address');
            $tag = $this->safe_string($data, 'address_memo');
            $chain = $this->safe_string($data, 'chain');
            $network = null;
            if ($chain !== null) {
                $parts = explode('-', $chain);
                $networkId = $this->safe_string($parts, 1);
                $network = $this->safe_network($networkId);
            }
            $this->check_address($address);
            return array(
                'currency' => $code,
                'address' => $address,
                'tag' => $tag,
                'network' => $network,
                'info' => $response,
            );
        }) ();
    }

    public function safe_network($networkId) {
        // TODO => parse
        return $networkId;
    }

    public function withdraw($code, $amount, $address, $tag = null, $params = array ()) {
        return Async\async(function () use ($code, $amount, $address, $tag, $params) {
            /**
             * make a withdrawal
             * @param {string} $code unified $currency $code
             * @param {float} $amount the $amount to withdraw
             * @param {string} $address the $address to withdraw to
             * @param {string|null} $tag
             * @param {array} $params extra parameters specific to the bitmart api endpoint
             * @return {array} a {@link https://docs.ccxt.com/en/latest/manual.html#$transaction-structure $transaction structure}
             */
            list($tag, $params) = $this->handle_withdraw_tag_and_params($tag, $params);
            $this->check_address($address);
            Async\await($this->load_markets());
            $currency = $this->currency($code);
            $request = array(
                'currency' => $currency['id'],
                'amount' => $amount,
                'destination' => 'To Digital Address', // To Digital Address, To Binance, To OKEX
                'address' => $address,
            );
            if ($tag !== null) {
                $request['address_memo'] = $tag;
            }
            if ($code === 'USDT') {
                $defaultNetworks = $this->safe_value($this->options, 'defaultNetworks');
                $defaultNetwork = $this->safe_string_upper($defaultNetworks, $code);
                $networks = $this->safe_value($this->options, 'networks', array());
                $network = $this->safe_string_upper($params, 'network', $defaultNetwork); // this line allows the user to specify either ERC20 or ETH
                $network = $this->safe_string($networks, $network, $network); // handle ERC20>ETH alias
                if ($network !== null) {
                    $request['currency'] .= '-' . $network; // when $network the $currency need to be changed to $currency . '-' . $network https://developer-pro.bitmart.com/en/account/withdraw_apply.html on the end of page
                    $params = $this->omit($params, 'network');
                }
            }
            $response = Async\await($this->privatePostAccountV1WithdrawApply (array_merge($request, $params)));
            //
            //     {
            //         "code" => 1000,
            //         "trace":"886fb6ae-456b-4654-b4e0-d681ac05cea1",
            //         "message" => "OK",
            //         "data" => {
            //             "withdraw_id" => "121212"
            //         }
            //     }
            //
            $data = $this->safe_value($response, 'data');
            $transaction = $this->parse_transaction($data, $currency);
            return array_merge($transaction, array(
                'code' => $code,
                'address' => $address,
                'tag' => $tag,
            ));
        }) ();
    }

    public function fetch_transactions_by_type($type, $code = null, $since = null, $limit = null, $params = array ()) {
        return Async\async(function () use ($type, $code, $since, $limit, $params) {
            Async\await($this->load_markets());
            if ($limit === null) {
                $limit = 50; // max 50
            }
            $request = array(
                'operation_type' => $type, // deposit or withdraw
                'offset' => 1,
                'N' => $limit,
            );
            $currency = null;
            if ($code !== null) {
                $currency = $this->currency($code);
                $request['currency'] = $currency['id'];
            }
            if ($code === 'USDT') {
                $defaultNetworks = $this->safe_value($this->options, 'defaultNetworks');
                $defaultNetwork = $this->safe_string_upper($defaultNetworks, $code);
                $networks = $this->safe_value($this->options, 'networks', array());
                $network = $this->safe_string_upper($params, 'network', $defaultNetwork); // this line allows the user to specify either ERC20 or ETH
                $network = $this->safe_string($networks, $network, $network); // handle ERC20>ETH alias
                if ($network !== null) {
                    $request['currency'] .= '-' . $network; // when $network the $currency need to be changed to $currency . '-' . $network https://developer-pro.bitmart.com/en/account/withdraw_apply.html on the end of page
                    $currency['code'] = $request['currency']; // update $currency $code to filter
                    $params = $this->omit($params, 'network');
                }
            }
            $response = Async\await($this->privateGetAccountV2DepositWithdrawHistory (array_merge($request, $params)));
            //
            //     {
            //         "message":"OK",
            //         "code":1000,
            //         "trace":"142bf92a-fc50-4689-92b6-590886f90b97",
            //         "data":{
            //             "records":array(
            //                 array(
            //                     "withdraw_id":"1679952",
            //                     "deposit_id":"",
            //                     "operation_type":"withdraw",
            //                     "currency":"BMX",
            //                     "apply_time":1588867374000,
            //                     "arrival_amount":"59.000000000000",
            //                     "fee":"1.000000000000",
            //                     "status":0,
            //                     "address":"0xe57b69a8776b37860407965B73cdFFBDFe668Bb5",
            //                     "address_memo":"",
            //                     "tx_id":""
            //                 ),
            //             )
            //         }
            //     }
            //
            $data = $this->safe_value($response, 'data', array());
            $records = $this->safe_value($data, 'records', array());
            return $this->parse_transactions($records, $currency, $since, $limit);
        }) ();
    }

    public function fetch_deposit($id, $code = null, $params = array ()) {
        return Async\async(function () use ($id, $code, $params) {
            /**
             * fetch information on a deposit
             * @param {string} $id deposit $id
             * @param {string|null} $code not used by bitmart fetchDeposit ()
             * @param {array} $params extra parameters specific to the bitmart api endpoint
             * @return {array} a {@link https://docs.ccxt.com/en/latest/manual.html#transaction-structure transaction structure}
             */
            Async\await($this->load_markets());
            $request = array(
                'id' => $id,
            );
            $response = Async\await($this->privateGetAccountV1DepositWithdrawDetail (array_merge($request, $params)));
            //
            //     {
            //         "message":"OK",
            //         "code":1000,
            //         "trace":"f7f74924-14da-42a6-b7f2-d3799dd9a612",
            //         "data":{
            //             "record":{
            //                 "withdraw_id":"",
            //                 "deposit_id":"1679952",
            //                 "operation_type":"deposit",
            //                 "currency":"BMX",
            //                 "apply_time":1588867374000,
            //                 "arrival_amount":"59.000000000000",
            //                 "fee":"1.000000000000",
            //                 "status":0,
            //                 "address":"0xe57b69a8776b37860407965B73cdFFBDFe668Bb5",
            //                 "address_memo":"",
            //                 "tx_id":""
            //             }
            //         }
            //     }
            //
            $data = $this->safe_value($response, 'data', array());
            $record = $this->safe_value($data, 'record', array());
            return $this->parse_transaction($record);
        }) ();
    }

    public function fetch_deposits($code = null, $since = null, $limit = null, $params = array ()) {
        return Async\async(function () use ($code, $since, $limit, $params) {
            /**
             * fetch all deposits made to an account
             * @param {string|null} $code unified currency $code
             * @param {int|null} $since the earliest time in ms to fetch deposits for
             * @param {int|null} $limit the maximum number of deposits structures to retrieve
             * @param {array} $params extra parameters specific to the bitmart api endpoint
             * @return {[array]} a list of {@link https://docs.ccxt.com/en/latest/manual.html#transaction-structure transaction structures}
             */
            return Async\await($this->fetch_transactions_by_type('deposit', $code, $since, $limit, $params));
        }) ();
    }

    public function fetch_withdrawal($id, $code = null, $params = array ()) {
        return Async\async(function () use ($id, $code, $params) {
            /**
             * fetch $data on a currency withdrawal via the withdrawal $id
             * @param {string} $id withdrawal $id
             * @param {string|null} $code not used by bitmart.fetchWithdrawal
             * @param {array} $params extra parameters specific to the bitmart api endpoint
             * @return {array} a {@link https://docs.ccxt.com/en/latest/manual.html#transaction-structure transaction structure}
             */
            Async\await($this->load_markets());
            $request = array(
                'id' => $id,
            );
            $response = Async\await($this->privateAccountGetDepositWithdrawDetail (array_merge($request, $params)));
            //
            //     {
            //         "message":"OK",
            //         "code":1000,
            //         "trace":"f7f74924-14da-42a6-b7f2-d3799dd9a612",
            //         "data":{
            //             "record":{
            //                 "withdraw_id":"1679952",
            //                 "deposit_id":"",
            //                 "operation_type":"withdraw",
            //                 "currency":"BMX",
            //                 "apply_time":1588867374000,
            //                 "arrival_amount":"59.000000000000",
            //                 "fee":"1.000000000000",
            //                 "status":0,
            //                 "address":"0xe57b69a8776b37860407965B73cdFFBDFe668Bb5",
            //                 "address_memo":"",
            //                 "tx_id":""
            //             }
            //         }
            //     }
            //
            $data = $this->safe_value($response, 'data', array());
            $record = $this->safe_value($data, 'record', array());
            return $this->parse_transaction($record);
        }) ();
    }

    public function fetch_withdrawals($code = null, $since = null, $limit = null, $params = array ()) {
        return Async\async(function () use ($code, $since, $limit, $params) {
            /**
             * fetch all withdrawals made from an account
             * @param {string|null} $code unified currency $code
             * @param {int|null} $since the earliest time in ms to fetch withdrawals for
             * @param {int|null} $limit the maximum number of withdrawals structures to retrieve
             * @param {array} $params extra parameters specific to the bitmart api endpoint
             * @return {[array]} a list of {@link https://docs.ccxt.com/en/latest/manual.html#transaction-structure transaction structures}
             */
            return Async\await($this->fetch_transactions_by_type('withdraw', $code, $since, $limit, $params));
        }) ();
    }

    public function parse_transaction_status($status) {
        $statuses = array(
            '0' => 'pending', // Create
            '1' => 'pending', // Submitted, waiting for withdrawal
            '2' => 'pending', // Processing
            '3' => 'ok', // Success
            '4' => 'canceled', // Cancel
            '5' => 'failed', // Fail
        );
        return $this->safe_string($statuses, $status, $status);
    }

    public function parse_transaction($transaction, $currency = null) {
        //
        // withdraw
        //
        //     {
        //         "withdraw_id" => "121212"
        //     }
        //
        // fetchDeposits, fetchWithdrawals, fetchWithdrawal
        //
        //     {
        //         "withdraw_id":"1679952",
        //         "deposit_id":"",
        //         "operation_type":"withdraw",
        //         "currency":"BMX",
        //         "apply_time":1588867374000,
        //         "arrival_amount":"59.000000000000",
        //         "fee":"1.000000000000",
        //         "status":0,
        //         "address":"0xe57b69a8776b37860407965B73cdFFBDFe668Bb5",
        //         "address_memo":"",
        //         "tx_id":""
        //     }
        //
        $id = null;
        $withdrawId = $this->safe_string($transaction, 'withdraw_id');
        $depositId = $this->safe_string($transaction, 'deposit_id');
        $type = null;
        if (($withdrawId !== null) && ($withdrawId !== '')) {
            $type = 'withdraw';
            $id = $withdrawId;
        } elseif (($depositId !== null) && ($depositId !== '')) {
            $type = 'deposit';
            $id = $depositId;
        }
        $amount = $this->safe_number($transaction, 'arrival_amount');
        $timestamp = $this->safe_integer($transaction, 'apply_time');
        $currencyId = $this->safe_string($transaction, 'currency');
        $code = $this->safe_currency_code($currencyId, $currency);
        $status = $this->parse_transaction_status($this->safe_string($transaction, 'status'));
        $feeCost = $this->safe_number($transaction, 'fee');
        $fee = null;
        if ($feeCost !== null) {
            $fee = array(
                'cost' => $feeCost,
                'currency' => $code,
            );
        }
        $txid = $this->safe_string($transaction, 'tx_id');
        $address = $this->safe_string($transaction, 'address');
        $tag = $this->safe_string($transaction, 'address_memo');
        return array(
            'info' => $transaction,
            'id' => $id,
            'currency' => $code,
            'amount' => $amount,
            'network' => null,
            'address' => $address,
            'addressFrom' => null,
            'addressTo' => null,
            'tag' => $tag,
            'tagFrom' => null,
            'tagTo' => null,
            'status' => $status,
            'type' => $type,
            'updated' => null,
            'txid' => $txid,
            'timestamp' => ($timestamp !== 0) ? $timestamp : null,
            'datetime' => ($timestamp !== 0) ? $this->iso8601($timestamp) : null,
            'fee' => $fee,
        );
    }

    public function repay_margin($code, $amount, $symbol = null, $params = array ()) {
        return Async\async(function () use ($code, $amount, $symbol, $params) {
            /**
             * repay borrowed margin and interest
             * @see https://developer-pro.bitmart.com/en/spot/#margin-repay-isolated
             * @param {string} $code unified $currency $code of the $currency to repay
             * @param {string} $amount the $amount to repay
             * @param {string} $symbol unified $market $symbol
             * @param {array} $params extra parameters specific to the bitmart api endpoint
             * @param {string|null} $params->marginMode 'isolated' is the default and 'cross' is unavailable
             * @return {array} a {@link https://docs.ccxt.com/en/latest/manual.html#margin-loan-structure margin loan structure}
             */
            Async\await($this->load_markets());
            if ($symbol === null) {
                throw new ArgumentsRequired($this->id . ' repayMargin() requires a $symbol argument');
            }
            $marginMode = null;
            list($marginMode, $params) = $this->handle_margin_mode_and_params('repayMargin', $params);
            if ($marginMode === null) {
                $marginMode = 'isolated'; // isolated as the default $marginMode
            }
            $market = $this->market($symbol);
            $currency = $this->currency($code);
            $request = array(
                'symbol' => $market['id'],
                'currency' => $currency['id'],
                'amount' => $this->currency_to_precision($code, $amount),
            );
            $response = Async\await($this->privatePostSpotV1MarginIsolatedRepay (array_merge($request, $params)));
            //
            //     {
            //         "message" => "OK",
            //         "code" => 1000,
            //         "trace" => "b0a60b4c-e986-4b54-a190-8f7c05ddf685",
            //         "data" => {
            //             "repay_id" => "2afcc16d99bd4707818c5a355dc89bed"
            //         }
            //     }
            //
            $data = $this->safe_value($response, 'data', array());
            $transaction = $this->parse_margin_loan($data, $currency);
            return array_merge($transaction, array(
                'amount' => $amount,
                'symbol' => $symbol,
            ));
        }) ();
    }

    public function borrow_margin($code, $amount, $symbol = null, $params = array ()) {
        return Async\async(function () use ($code, $amount, $symbol, $params) {
            /**
             * create a loan to borrow margin
             * @see https://developer-pro.bitmart.com/en/spot/#margin-borrow-isolated
             * @param {string} $code unified $currency $code of the $currency to borrow
             * @param {string} $amount the $amount to borrow
             * @param {string} $symbol unified $market $symbol
             * @param {array} $params extra parameters specific to the bitmart api endpoint
             * @param {string|null} $params->marginMode 'isolated' is the default and 'cross' is unavailable
             * @return {array} a {@link https://docs.ccxt.com/en/latest/manual.html#margin-loan-structure margin loan structure}
             */
            Async\await($this->load_markets());
            if ($symbol === null) {
                throw new ArgumentsRequired($this->id . ' borrowMargin() requires a $symbol argument');
            }
            $marginMode = null;
            list($marginMode, $params) = $this->handle_margin_mode_and_params('borrowMargin', $params);
            if ($marginMode === null) {
                $marginMode = 'isolated'; // isolated as the default $marginMode
            }
            $market = $this->market($symbol);
            $currency = $this->currency($code);
            $request = array(
                'symbol' => $market['id'],
                'currency' => $currency['id'],
                'amount' => $this->currency_to_precision($code, $amount),
            );
            $response = Async\await($this->privatePostSpotV1MarginIsolatedBorrow (array_merge($request, $params)));
            //
            //     {
            //         "message" => "OK",
            //         "code" => 1000,
            //         "trace" => "e6fda683-181e-4e78-ac9c-b27c4c8ba035",
            //         "data" => {
            //             "borrow_id" => "629a7177a4ed4cf09869c6a4343b788c"
            //         }
            //     }
            //
            $data = $this->safe_value($response, 'data', array());
            $transaction = $this->parse_margin_loan($data, $currency);
            return array_merge($transaction, array(
                'amount' => $amount,
                'symbol' => $symbol,
            ));
        }) ();
    }

    public function parse_margin_loan($info, $currency = null) {
        //
        // borrowMargin
        //
        //     {
        //         "borrow_id" => "629a7177a4ed4cf09869c6a4343b788c",
        //     }
        //
        // repayMargin
        //
        //     {
        //         "repay_id" => "2afcc16d99bd4707818c5a355dc89bed",
        //     }
        //
        $timestamp = $this->milliseconds();
        return array(
            'id' => $this->safe_string_2($info, 'borrow_id', 'repay_id'),
            'currency' => $this->safe_currency_code(null, $currency),
            'amount' => null,
            'symbol' => null,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'info' => $info,
        );
    }

    public function fetch_borrow_rate($code, $params = array ()) {
        return Async\async(function () use ($code, $params) {
            /**
             * fetch the rate of interest to borrow a $currency for margin trading
             * @see https://developer-pro.bitmart.com/en/spot/#get-trading-pair-borrowing-rate-and-amount
             * @param {string} $code unified $currency $code
             * @param {array} $params extra parameters specific to the bitmart api endpoint
             * @return {array} a {@link https://docs.ccxt.com/en/latest/manual.html#borrow-rate-structure borrow rate structure}
             */
            Async\await($this->load_markets());
            $market = null;
            if (is_array($this->markets) && array_key_exists($code, $this->markets)) {
                $market = $this->market($code);
            } else {
                $defaultSettle = $this->safe_string($this->options, 'defaultSettle', 'USDT');
                if ($code === 'USDT') {
                    $market = $this->market('BTC' . '/' . $defaultSettle);
                } else {
                    $market = $this->market($code . '/' . $defaultSettle);
                }
            }
            $request = array(
                'symbol' => $market['id'],
            );
            $response = Async\await($this->privateGetSpotV1MarginIsolatedPairs (array_merge($request, $params)));
            //
            //     {
            //         "message" => "OK",
            //         "code" => 1000,
            //         "trace" => "0985a130-a5ae-4fc1-863f-4704e214f585",
            //         "data" => {
            //             "symbols" => array(
            //                 {
            //                     "symbol" => "BTC_USDT",
            //                     "max_leverage" => "5",
            //                     "symbol_enabled" => true,
            //                     "base" => array(
            //                         "currency" => "BTC",
            //                         "daily_interest" => "0.00055000",
            //                         "hourly_interest" => "0.00002291",
            //                         "max_borrow_amount" => "2.00000000",
            //                         "min_borrow_amount" => "0.00000001",
            //                         "borrowable_amount" => "0.00670810"
            //                     ),
            //                     "quote" => {
            //                         "currency" => "USDT",
            //                         "daily_interest" => "0.00055000",
            //                         "hourly_interest" => "0.00002291",
            //                         "max_borrow_amount" => "50000.00000000",
            //                         "min_borrow_amount" => "0.00000001",
            //                         "borrowable_amount" => "135.12575038"
            //                     }
            //                 }
            //             )
            //         }
            //     }
            //
            $data = $this->safe_value($response, 'data', array());
            $symbols = $this->safe_value($data, 'symbols', array());
            $currency = ($code === 'USDT') ? $market['quote'] : $market['base'];
            return $this->parse_borrow_rate($symbols, $currency);
        }) ();
    }

    public function parse_borrow_rate($info, $currency = null) {
        //
        //     {
        //         "symbol" => "BTC_USDT",
        //         "max_leverage" => "5",
        //         "symbol_enabled" => true,
        //         "base" => array(
        //             "currency" => "BTC",
        //             "daily_interest" => "0.00055000",
        //             "hourly_interest" => "0.00002291",
        //             "max_borrow_amount" => "2.00000000",
        //             "min_borrow_amount" => "0.00000001",
        //             "borrowable_amount" => "0.00670810"
        //         ),
        //         "quote" => {
        //             "currency" => "USDT",
        //             "daily_interest" => "0.00055000",
        //             "hourly_interest" => "0.00002291",
        //             "max_borrow_amount" => "50000.00000000",
        //             "min_borrow_amount" => "0.00000001",
        //             "borrowable_amount" => "135.12575038"
        //         }
        //     }
        //
        $timestamp = $this->milliseconds();
        $currencyData = ($currency === 'USDT') ? $this->safe_value($info[0], 'quote', array()) : $this->safe_value($info[0], 'base', array());
        return array(
            'currency' => $this->safe_currency_code($currency),
            'rate' => $this->safe_number($currencyData, 'hourly_interest'),
            'period' => 3600000, // 1-Hour
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'info' => $info,
        );
    }

    public function fetch_borrow_rates($params = array ()) {
        return Async\async(function () use ($params) {
            /**
             * fetch the borrow interest rates of all currencies, currently only works for isolated margin
             * @see https://developer-pro.bitmart.com/en/spot/#get-trading-pair-borrowing-rate-and-amount
             * @param {array} $params extra parameters specific to the bitmart api endpoint
             * @return {array} a list of {@link https://docs.ccxt.com/en/latest/manual.html#borrow-rate-structure borrow rate structures}
             */
            Async\await($this->load_markets());
            $response = Async\await($this->privateGetSpotV1MarginIsolatedPairs ($params));
            //
            //     {
            //         "message" => "OK",
            //         "code" => 1000,
            //         "trace" => "0985a130-a5ae-4fc1-863f-4704e214f585",
            //         "data" => {
            //             "symbols" => array(
            //                 {
            //                     "symbol" => "BTC_USDT",
            //                     "max_leverage" => "5",
            //                     "symbol_enabled" => true,
            //                     "base" => array(
            //                         "currency" => "BTC",
            //                         "daily_interest" => "0.00055000",
            //                         "hourly_interest" => "0.00002291",
            //                         "max_borrow_amount" => "2.00000000",
            //                         "min_borrow_amount" => "0.00000001",
            //                         "borrowable_amount" => "0.00670810"
            //                     ),
            //                     "quote" => {
            //                         "currency" => "USDT",
            //                         "daily_interest" => "0.00055000",
            //                         "hourly_interest" => "0.00002291",
            //                         "max_borrow_amount" => "50000.00000000",
            //                         "min_borrow_amount" => "0.00000001",
            //                         "borrowable_amount" => "135.12575038"
            //                     }
            //                 }
            //             )
            //         }
            //     }
            //
            $data = $this->safe_value($response, 'data', array());
            $symbols = $this->safe_value($data, 'symbols', array());
            return $this->parse_borrow_rates($symbols, null);
        }) ();
    }

    public function parse_borrow_rates($info, $codeKey) {
        //
        //     {
        //         "symbol" => "BTC_USDT",
        //         "max_leverage" => "5",
        //         "symbol_enabled" => true,
        //         "base" => array(
        //             "currency" => "BTC",
        //             "daily_interest" => "0.00055000",
        //             "hourly_interest" => "0.00002291",
        //             "max_borrow_amount" => "2.00000000",
        //             "min_borrow_amount" => "0.00000001",
        //             "borrowable_amount" => "0.00670810"
        //         ),
        //         "quote" => {
        //             "currency" => "USDT",
        //             "daily_interest" => "0.00055000",
        //             "hourly_interest" => "0.00002291",
        //             "max_borrow_amount" => "50000.00000000",
        //             "min_borrow_amount" => "0.00000001",
        //             "borrowable_amount" => "135.12575038"
        //         }
        //     }
        //
        $timestamp = $this->milliseconds();
        $rates = array();
        for ($i = 0; $i < count($info); $i++) {
            $entry = $info[$i];
            $base = $this->safe_value($entry, 'base', array());
            $rates[] = array(
                'currency' => $this->safe_currency_code($this->safe_string($base, 'currency')),
                'rate' => $this->safe_number($base, 'hourly_interest'),
                'period' => 3600000, // 1-Hour
                'timestamp' => $timestamp,
                'datetime' => $this->iso8601($timestamp),
                'info' => $entry,
            );
        }
        return $rates;
    }

    public function transfer($code, $amount, $fromAccount, $toAccount, $params = array ()) {
        return Async\async(function () use ($code, $amount, $fromAccount, $toAccount, $params) {
            /**
             * transfer $currency internally between wallets on the same account, currently only supports transfer between spot and margin
             * @see https://developer-pro.bitmart.com/en/spot/#margin-asset-transfer
             * @param {string} $code unified $currency $code
             * @param {float} $amount amount to transfer
             * @param {string} $fromAccount account to transfer from
             * @param {string} $toAccount account to transfer to
             * @param {array} $params extra parameters specific to the bitmart api endpoint
             * @return {array} a {@link https://docs.ccxt.com/en/latest/manual.html#transfer-structure transfer structure}
             */
            $symbol = $this->safe_string($params, 'symbol');
            if ($symbol === null) {
                throw new ArgumentsRequired($this->id . ' transfer() requires a $symbol argument');
            }
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $currency = $this->currency($code);
            $amountToPrecision = $this->currency_to_precision($code, $amount);
            $request = array(
                'amount' => $amountToPrecision,
                'currency' => $currency['id'],
                'symbol' => $market['id'],
            );
            if (($fromAccount === 'spot') && ($toAccount === 'margin')) {
                $request['side'] = 'in';
            } elseif (($fromAccount === 'margin') && ($toAccount === 'spot')) {
                $request['side'] = 'out';
            }
            $params = $this->omit($params, 'symbol');
            $response = Async\await($this->privatePostSpotV1MarginIsolatedTransfer (array_merge($request, $params)));
            //
            //     {
            //         "message" => "OK",
            //         "code" => 1000,
            //         "trace" => "b26cecec-ef5a-47d9-9531-2bd3911d3d55",
            //         "data" => {
            //             "transfer_id" => "ca90d97a621e47d49774f19af6b029f5"
            //         }
            //     }
            //
            return array_merge($this->parse_transfer($response, $currency), array(
                'amount' => $this->parse_number($amountToPrecision),
                'fromAccount' => $fromAccount,
                'toAccount' => $toAccount,
            ));
        }) ();
    }

    public function parse_transfer_status($status) {
        $statuses = array(
            '1000' => 'ok',
            'OK' => 'ok',
        );
        return $this->safe_string($statuses, $status, $status);
    }

    public function parse_transfer($transfer, $currency = null) {
        //
        //     {
        //         "message" => "OK",
        //         "code" => 1000,
        //         "trace" => "b26cecec-ef5a-47d9-9531-2bd3911d3d55",
        //         "data" => {
        //             "transfer_id" => "ca90d97a621e47d49774f19af6b029f5"
        //         }
        //     }
        //
        $data = $this->safe_value($transfer, 'data', array());
        return array(
            'id' => $this->safe_string($data, 'transfer_id'),
            'timestamp' => null,
            'datetime' => null,
            'currency' => $this->safe_currency_code(null, $currency),
            'amount' => null,
            'fromAccount' => null,
            'toAccount' => null,
            'status' => $this->parse_transfer_status($this->safe_string_2($transfer, 'code', 'message')),
        );
    }

    public function fetch_borrow_interest($code = null, $symbol = null, $since = null, $limit = null, $params = array ()) {
        return Async\async(function () use ($code, $symbol, $since, $limit, $params) {
            /**
             * fetch the $interest owed by the user for borrowing currency for margin trading
             * @see https://developer-pro.bitmart.com/en/spot/#get-borrow-record-isolated
             * @param {string|null} $code unified currency $code
             * @param {string} $symbol unified $market $symbol when fetch $interest in isolated markets
             * @param {int|null} $since the earliest time in ms to fetch borrrow $interest for
             * @param {int|null} $limit the maximum number of structures to retrieve
             * @param {array} $params extra parameters specific to the bitmart api endpoint
             * @return {[array]} a list of {@link https://docs.ccxt.com/en/latest/manual.html#borrow-$interest-structure borrow $interest structures}
             */
            if ($symbol === null) {
                throw new ArgumentsRequired($this->id . ' fetchBorrowInterest() requires a $symbol argument');
            }
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $request = array(
                'symbol' => $market['id'],
            );
            if ($limit !== null) {
                $request['N'] = $limit;
            }
            if ($since !== null) {
                $request['start_time'] = $since;
            }
            $response = Async\await($this->privateGetSpotV1MarginIsolatedBorrowRecord (array_merge($request, $params)));
            //
            //     {
            //         "message" => "OK",
            //         "code" => 1000,
            //         "trace" => "8ea27a2a-4aba-49fa-961d-43a0137b0ef3",
            //         "data" => {
            //             "records" => array(
            //                 array(
            //                     "borrow_id" => "1659045283903rNvJnuRTJNL5J53n",
            //                     "symbol" => "BTC_USDT",
            //                     "currency" => "USDT",
            //                     "borrow_amount" => "100.00000000",
            //                     "daily_interest" => "0.00055000",
            //                     "hourly_interest" => "0.00002291",
            //                     "interest_amount" => "0.00229166",
            //                     "create_time" => 1659045284000
            //                 ),
            //             )
            //         }
            //     }
            //
            $data = $this->safe_value($response, 'data', array());
            $rows = $this->safe_value($data, 'records', array());
            $interest = $this->parse_borrow_interests($rows, $market);
            return $this->filter_by_currency_since_limit($interest, $code, $since, $limit);
        }) ();
    }

    public function parse_borrow_interest($info, $market = null) {
        //
        //     array(
        //         "borrow_id" => "1657664327844Lk5eJJugXmdHHZoe",
        //         "symbol" => "BTC_USDT",
        //         "currency" => "USDT",
        //         "borrow_amount" => "20.00000000",
        //         "daily_interest" => "0.00055000",
        //         "hourly_interest" => "0.00002291",
        //         "interest_amount" => "0.00045833",
        //         "create_time" => 1657664329000
        //     ),
        //
        $marketId = $this->safe_string($info, 'symbol');
        $market = $this->safe_market($marketId, $market);
        $timestamp = $this->safe_integer($info, 'create_time');
        return array(
            'symbol' => $this->safe_string($market, 'symbol'),
            'marginMode' => 'isolated',
            'currency' => $this->safe_currency_code($this->safe_string($info, 'currency')),
            'interest' => $this->safe_number($info, 'interest_amount'),
            'interestRate' => $this->safe_number($info, 'hourly_interest'),
            'amountBorrowed' => $this->safe_number($info, 'borrow_amount'),
            'timestamp' => $timestamp,  // borrow creation time
            'datetime' => $this->iso8601($timestamp),
            'info' => $info,
        );
    }

    public function handle_margin_mode_and_params($methodName, $params = array ()) {
        /**
         * @ignore
         * $marginMode specified by $params["marginMode"], $this->options["marginMode"], $this->options["defaultMarginMode"], $params["margin"] = true or $this->options["defaultType"] = 'margin'
         * @param {array} $params extra parameters specific to the exchange api endpoint
         * @return array([string|null, object]) the $marginMode in lowercase
         */
        $defaultType = $this->safe_string($this->options, 'defaultType');
        $isMargin = $this->safe_value($params, 'margin', false);
        $marginMode = null;
        list($marginMode, $params) = parent::handle_margin_mode_and_params($methodName, $params);
        if ($marginMode !== null) {
            if ($marginMode !== 'isolated') {
                throw new NotSupported($this->id . ' only isolated margin is supported');
            }
        } else {
            if (($defaultType === 'margin') || ($isMargin === true)) {
                $marginMode = 'isolated';
            }
        }
        return array( $marginMode, $params );
    }

    public function nonce() {
        return $this->milliseconds();
    }

    public function sign($path, $api = 'public', $method = 'GET', $params = array (), $headers = null, $body = null) {
        $baseUrl = $this->implode_hostname($this->urls['api']['rest']);
        $url = $baseUrl . '/' . $this->implode_params($path, $params);
        $query = $this->omit($params, $this->extract_params($path));
        $queryString = '';
        $getOrDelete = ($method === 'GET') || ($method === 'DELETE');
        if ($getOrDelete) {
            if ($query) {
                $queryString = $this->urlencode($query);
                $url .= '?' . $queryString;
            }
        }
        if ($api === 'private') {
            $this->check_required_credentials();
            $timestamp = (string) $this->milliseconds();
            $headers = array(
                'X-BM-KEY' => $this->apiKey,
                'X-BM-TIMESTAMP' => $timestamp,
                'Content-Type' => 'application/json',
            );
            if (!$getOrDelete) {
                $body = $this->json($query);
                $queryString = $body;
            }
            $auth = $timestamp . '#' . $this->uid . '#' . $queryString;
            $signature = $this->hmac($this->encode($auth), $this->encode($this->secret));
            $headers['X-BM-SIGN'] = $signature;
        }
        return array( 'url' => $url, 'method' => $method, 'body' => $body, 'headers' => $headers );
    }

    public function handle_errors($code, $reason, $url, $method, $headers, $body, $response, $requestHeaders, $requestBody) {
        if ($response === null) {
            return;
        }
        //
        // spot
        //
        //     array("message":"Bad Request [to is empty]","code":50000,"trace":"f9d46e1b-4edb-4d07-a06e-4895fb2fc8fc","data":array())
        //     array("message":"Bad Request [from is empty]","code":50000,"trace":"579986f7-c93a-4559-926b-06ba9fa79d76","data":array())
        //     array("message":"Kline size over 500","code":50004,"trace":"d625caa8-e8ca-4bd2-b77c-958776965819","data":array())
        //     array("message":"Balance not enough","code":50020,"trace":"7c709d6a-3292-462c-98c5-32362540aeef","data":array())
        //
        // contract
        //
        //     array("errno":"OK","message":"INVALID_PARAMETER","code":49998,"trace":"eb5ebb54-23cd-4de2-9064-e090b6c3b2e3","data":null)
        //
        $message = $this->safe_string_lower($response, 'message');
        $errorCode = $this->safe_string($response, 'code');
        if ((($errorCode !== null) && ($errorCode !== '1000')) || (($message !== null) && ($message !== 'ok'))) {
            $feedback = $this->id . ' ' . $body;
            $this->throw_exactly_matched_exception($this->exceptions['exact'], $errorCode, $feedback);
            $this->throw_broadly_matched_exception($this->exceptions['broad'], $errorCode, $feedback);
            $this->throw_exactly_matched_exception($this->exceptions['exact'], $message, $feedback);
            $this->throw_broadly_matched_exception($this->exceptions['broad'], $message, $feedback);
            throw new ExchangeError($feedback); // unknown $message
        }
    }
}
