<?php

namespace ccxt\async;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

use Exception; // a common import
use ccxt\async\abstract\woo as Exchange;
use ccxt\ArgumentsRequired;
use ccxt\BadRequest;
use ccxt\InvalidOrder;
use ccxt\NotSupported;
use ccxt\Precise;
use React\Async;
use React\Promise\PromiseInterface;

class woo extends Exchange {

    public function describe() {
        return $this->deep_extend(parent::describe(), array(
            'id' => 'woo',
            'name' => 'WOO X',
            'countries' => array( 'KY' ), // Cayman Islands
            'rateLimit' => 100,
            'version' => 'v1',
            'certified' => true,
            'pro' => true,
            'hostname' => 'woo.org',
            'has' => array(
                'CORS' => null,
                'spot' => true,
                'margin' => true,
                'swap' => true,
                'future' => false,
                'option' => false,
                'addMargin' => false,
                'cancelAllOrders' => true,
                'cancelOrder' => true,
                'cancelWithdraw' => false, // exchange have that endpoint disabled atm, but was once implemented in ccxt per old docs => https://kronosresearch.github.io/wootrade-documents/#cancel-withdraw-request
                'closeAllPositions' => false,
                'closePosition' => false,
                'createDepositAddress' => false,
                'createMarketBuyOrderWithCost' => true,
                'createMarketOrder' => false,
                'createMarketOrderWithCost' => false,
                'createMarketSellOrderWithCost' => false,
                'createOrder' => true,
                'createOrderWithTakeProfitAndStopLoss' => true,
                'createReduceOnlyOrder' => true,
                'createStopLimitOrder' => false,
                'createStopLossOrder' => true,
                'createStopMarketOrder' => false,
                'createStopOrder' => false,
                'createTakeProfitOrder' => true,
                'createTrailingAmountOrder' => true,
                'createTrailingPercentOrder' => true,
                'createTriggerOrder' => true,
                'fetchAccounts' => true,
                'fetchBalance' => true,
                'fetchCanceledOrders' => false,
                'fetchClosedOrder' => false,
                'fetchClosedOrders' => false,
                'fetchCurrencies' => true,
                'fetchDepositAddress' => true,
                'fetchDeposits' => true,
                'fetchDepositsWithdrawals' => true,
                'fetchFundingHistory' => true,
                'fetchFundingRate' => true,
                'fetchFundingRateHistory' => true,
                'fetchFundingRates' => true,
                'fetchIndexOHLCV' => false,
                'fetchLedger' => true,
                'fetchLeverage' => true,
                'fetchMarginMode' => false,
                'fetchMarkets' => true,
                'fetchMarkOHLCV' => false,
                'fetchMyTrades' => true,
                'fetchOHLCV' => true,
                'fetchOpenInterestHistory' => false,
                'fetchOpenOrder' => false,
                'fetchOpenOrders' => false,
                'fetchOrder' => true,
                'fetchOrderBook' => true,
                'fetchOrders' => true,
                'fetchOrderTrades' => true,
                'fetchPosition' => true,
                'fetchPositionMode' => false,
                'fetchPositions' => true,
                'fetchPremiumIndexOHLCV' => false,
                'fetchStatus' => false,
                'fetchTicker' => false,
                'fetchTickers' => false,
                'fetchTime' => false,
                'fetchTrades' => true,
                'fetchTradingFee' => false,
                'fetchTradingFees' => true,
                'fetchTransactions' => 'emulated',
                'fetchTransfers' => true,
                'fetchWithdrawals' => true,
                'reduceMargin' => false,
                'setLeverage' => true,
                'setMargin' => false,
                'transfer' => true,
                'withdraw' => true, // exchange have that endpoint disabled atm, but was once implemented in ccxt per old docs => https://kronosresearch.github.io/wootrade-documents/#token-withdraw
            ),
            'timeframes' => array(
                '1m' => '1m',
                '5m' => '5m',
                '15m' => '15m',
                '30m' => '30m',
                '1h' => '1h',
                '4h' => '4h',
                '12h' => '12h',
                '1d' => '1d',
                '1w' => '1w',
                '1M' => '1mon',
                '1y' => '1y',
            ),
            'urls' => array(
                'logo' => 'https://user-images.githubusercontent.com/1294454/150730761-1a00e5e0-d28c-480f-9e65-089ce3e6ef3b.jpg',
                'api' => array(
                    'pub' => 'https://api-pub.woo.org',
                    'public' => 'https://api.{hostname}',
                    'private' => 'https://api.{hostname}',
                ),
                'test' => array(
                    'pub' => 'https://api-pub.staging.woo.org',
                    'public' => 'https://api.staging.woo.org',
                    'private' => 'https://api.staging.woo.org',
                ),
                'www' => 'https://woo.org/',
                'doc' => array(
                    'https://docs.woo.org/',
                ),
                'fees' => array(
                    'https://support.woo.org/hc/en-001/articles/4404611795353--Trading-Fees',
                ),
                'referral' => array(
                    'url' => 'https://x.woo.org/register?ref=YWOWC96B',
                    'discount' => 0.35,
                ),
            ),
            'api' => array(
                'v1' => array(
                    'pub' => array(
                        'get' => array(
                            'hist/kline' => 10,
                            'hist/trades' => 1,
                        ),
                    ),
                    'public' => array(
                        'get' => array(
                            'info' => 1,
                            'info/{symbol}' => 1,
                            'system_info' => 1,
                            'market_trades' => 1,
                            'token' => 1,
                            'token_network' => 1,
                            'funding_rates' => 1,
                            'funding_rate/{symbol}' => 1,
                            'funding_rate_history' => 1,
                            'futures' => 1,
                            'futures/{symbol}' => 1,
                            'orderbook/{symbol}' => 1,
                            'kline' => 1,
                        ),
                    ),
                    'private' => array(
                        'get' => array(
                            'client/token' => 1,
                            'order/{oid}' => 1,
                            'client/order/{client_order_id}' => 1,
                            'orders' => 1,
                            'client/trade/{tid}' => 1,
                            'order/{oid}/trades' => 1,
                            'client/trades' => 1,
                            'asset/deposit' => 10,
                            'asset/history' => 60,
                            'sub_account/all' => 60,
                            'sub_account/assets' => 60,
                            'token_interest' => 60,
                            'token_interest/{token}' => 60,
                            'interest/history' => 60,
                            'interest/repay' => 60,
                            'funding_fee/history' => 30,
                            'positions' => 3.33, // 30 requests per 10 seconds
                            'position/{symbol}' => 3.33,
                            'client/transaction_history' => 60,
                        ),
                        'post' => array(
                            'order' => 5, // 2 requests per 1 second per symbol
                            'asset/main_sub_transfer' => 30, // 20 requests per 60 seconds
                            'asset/withdraw' => 30,  // implemented in ccxt, disabled on the exchange side https://kronosresearch.github.io/wootrade-documents/#token-withdraw
                            'interest/repay' => 60,
                            'client/account_mode' => 120,
                            'client/leverage' => 120,
                        ),
                        'delete' => array(
                            'order' => 1,
                            'client/order' => 1,
                            'orders' => 1,
                            'asset/withdraw' => 120,  // implemented in ccxt, disabled on the exchange side https://kronosresearch.github.io/wootrade-documents/#cancel-withdraw-request
                        ),
                    ),
                ),
                'v2' => array(
                    'private' => array(
                        'get' => array(
                            'client/holding' => 1,
                        ),
                    ),
                ),
                'v3' => array(
                    'public' => array(
                        'get' => array(
                            'insuranceFund' => 3,
                        ),
                    ),
                    'private' => array(
                        'get' => array(
                            'algo/order/{oid}' => 1,
                            'algo/orders' => 1,
                            'balances' => 1,
                            'accountinfo' => 60,
                            'positions' => 3.33,
                            'buypower' => 1,
                            'referrals' => 60,
                            'referral_rewards' => 60,
                            'convert/exchangeInfo' => 1,
                            'convert/assetInfo' => 1,
                            'convert/rfq' => 60,
                            'convert/trade' => 1,
                            'convert/trades' => 1,
                        ),
                        'post' => array(
                            'algo/order' => 5,
                            'convert/rft' => 60,
                        ),
                        'put' => array(
                            'order/{oid}' => 2,
                            'order/client/{client_order_id}' => 2,
                            'algo/order/{oid}' => 2,
                            'algo/order/client/{client_order_id}' => 2,
                        ),
                        'delete' => array(
                            'algo/order/{order_id}' => 1,
                            'algo/orders/pending' => 1,
                            'algo/orders/pending/{symbol}' => 1,
                            'orders/pending' => 1,
                        ),
                    ),
                ),
            ),
            'fees' => array(
                'trading' => array(
                    'tierBased' => true,
                    'percentage' => true,
                    'maker' => $this->parse_number('0.0002'),
                    'taker' => $this->parse_number('0.0005'),
                ),
            ),
            'options' => array(
                'sandboxMode' => false,
                'createMarketBuyOrderRequiresPrice' => true,
                // these network aliases require manual mapping here
                'network-aliases-for-tokens' => array(
                    'HT' => 'ERC20',
                    'OMG' => 'ERC20',
                    'UATOM' => 'ATOM',
                    'ZRX' => 'ZRX',
                ),
                'networks' => array(
                    'TRX' => 'TRON',
                    'TRC20' => 'TRON',
                    'ERC20' => 'ETH',
                    'BEP20' => 'BSC',
                ),
                // override defaultNetworkCodePriorities for a specific currency
                'defaultNetworkCodeForCurrencies' => array(
                    // 'USDT' => 'TRC20',
                    // 'BTC' => 'BTC',
                ),
                'transfer' => array(
                    'fillResponseFromRequest' => true,
                ),
                'brokerId' => 'bc830de7-50f3-460b-9ee0-f430f83f9dad',
            ),
            'commonCurrencies' => array(),
            'exceptions' => array(
                'exact' => array(
                    '-1000' => '\\ccxt\\ExchangeError', // array( "code" => -1000,  "message" => "An unknown error occurred while processing the request" )
                    '-1001' => '\\ccxt\\AuthenticationError', // array( "code" => -1001,  "message" => "The api key or secret is in wrong format" )
                    '-1002' => '\\ccxt\\AuthenticationError', // array( "code" => -1002,  "message" => "API key or secret is invalid, it may because key have insufficient permission or the key is expired/revoked." )
                    '-1003' => '\\ccxt\\RateLimitExceeded', // array( "code" => -1003,  "message" => "Rate limit exceed." )
                    '-1004' => '\\ccxt\\BadRequest', // array( "code" => -1004,  "message" => "An unknown parameter was sent." )
                    '-1005' => '\\ccxt\\BadRequest', // array( "code" => -1005,  "message" => "Some parameters are in wrong format for api." )
                    '-1006' => '\\ccxt\\BadRequest', // array( "code" => -1006,  "message" => "The data is not found in server." )
                    '-1007' => '\\ccxt\\BadRequest', // array( "code" => -1007,  "message" => "The data is already exists or your request is duplicated." )
                    '-1008' => '\\ccxt\\InvalidOrder', // array( "code" => -1008,  "message" => "The quantity of settlement is too high than you can request." )
                    '-1009' => '\\ccxt\\BadRequest', // array( "code" => -1009,  "message" => "Can not request withdrawal settlement, you need to deposit other arrears first." )
                    '-1011' => '\\ccxt\\ExchangeError', // array( "code" => -1011,  "message" => "Can not place/cancel orders, it may because internal network error. Please try again in a few seconds." )
                    '-1012' => '\\ccxt\\BadRequest', // array( "code" => -1012,  "message" => "Amount is required for buy market orders when margin disabled.")  The place/cancel order request is rejected by internal module, it may because the account is in liquidation or other internal errors. Please try again in a few seconds." }
                    '-1101' => '\\ccxt\\InvalidOrder', // array( "code" => -1101,  "message" => "The risk exposure for client is too high, it may cause by sending too big order or the leverage is too low. please refer to client info to check the current exposure." )
                    '-1102' => '\\ccxt\\InvalidOrder', // array( "code" => -1102,  "message" => "The order value (price * size) is too small." )
                    '-1103' => '\\ccxt\\InvalidOrder', // array( "code" => -1103,  "message" => "The order price is not following the tick size rule for the symbol." )
                    '-1104' => '\\ccxt\\InvalidOrder', // array( "code" => -1104,  "message" => "The order quantity is not following the step size rule for the symbol." )
                    '-1105' => '\\ccxt\\InvalidOrder', // array( "code" => -1105,  "message" => "Price is X% too high or X% too low from the mid price." )
                ),
                'broad' => array(
                    'symbol must not be blank' => '\\ccxt\\BadRequest', // when sending 'cancelOrder' without symbol [-1005]
                    'The token is not supported' => '\\ccxt\\BadRequest', // when getting incorrect token's deposit address [-1005]
                    'Your order and symbol are not valid or already canceled' => '\\ccxt\\BadRequest', // actual response whensending 'cancelOrder' for already canceled id [-1006]
                    'Insufficient WOO. Please enable margin trading for leverage trading' => '\\ccxt\\BadRequest', // when selling insufficent token [-1012]
                ),
            ),
            'precisionMode' => TICK_SIZE,
        ));
    }

    public function fetch_markets($params = array ()) {
        return Async\async(function () use ($params) {
            /**
             * retrieves $data on all markets for woo
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array[]} an array of objects representing market $data
             */
            $response = Async\await($this->v1PublicGetInfo ($params));
            //
            // {
            //     "rows" => [
            //         array(
            //             "symbol" => "SPOT_AAVE_USDT",
            //             "quote_min" => 0,
            //             "quote_max" => 100000,
            //             "quote_tick" => 0.01,
            //             "base_min" => 0.01,
            //             "base_max" => 7284,
            //             "base_tick" => 0.0001,
            //             "min_notional" => 10,
            //             "price_range" => 0.1,
            //             "created_time" => "0",
            //             "updated_time" => "1639107647.988",
            //             "is_stable" => 0
            //         ),
            //         ...
            //     "success" => true
            // }
            //
            $data = $this->safe_value($response, 'rows', array());
            return $this->parse_markets($data);
        }) ();
    }

    public function parse_market($market): array {
        $marketId = $this->safe_string($market, 'symbol');
        $parts = explode('_', $marketId);
        $first = $this->safe_string($parts, 0);
        $spot = false;
        $swap = false;
        if ($first === 'SPOT') {
            $spot = true;
            $marketType = 'spot';
        } elseif ($first === 'PERP') {
            $swap = true;
            $marketType = 'swap';
        }
        $baseId = $this->safe_string($parts, 1);
        $quoteId = $this->safe_string($parts, 2);
        $base = $this->safe_currency_code($baseId);
        $quote = $this->safe_currency_code($quoteId);
        $settleId = null;
        $settle = null;
        $symbol = $base . '/' . $quote;
        $contractSize = null;
        $linear = null;
        $margin = true;
        $contract = $swap;
        if ($contract) {
            $margin = false;
            $settleId = $this->safe_string($parts, 2);
            $settle = $this->safe_currency_code($settleId);
            $symbol = $base . '/' . $quote . ':' . $settle;
            $contractSize = $this->parse_number('1');
            $linear = true;
        }
        return array(
            'id' => $marketId,
            'symbol' => $symbol,
            'base' => $base,
            'quote' => $quote,
            'settle' => $settle,
            'baseId' => $baseId,
            'quoteId' => $quoteId,
            'settleId' => $settleId,
            'type' => $marketType,
            'spot' => $spot,
            'margin' => $margin,
            'swap' => $swap,
            'future' => false,
            'option' => false,
            'active' => null,
            'contract' => $contract,
            'linear' => $linear,
            'inverse' => null,
            'contractSize' => $contractSize,
            'expiry' => null,
            'expiryDatetime' => null,
            'strike' => null,
            'optionType' => null,
            'precision' => array(
                'amount' => $this->safe_number($market, 'base_tick'),
                'price' => $this->safe_number($market, 'quote_tick'),
            ),
            'limits' => array(
                'leverage' => array(
                    'min' => null,
                    'max' => null,
                ),
                'amount' => array(
                    'min' => $this->safe_number($market, 'base_min'),
                    'max' => $this->safe_number($market, 'base_max'),
                ),
                'price' => array(
                    'min' => $this->safe_number($market, 'quote_min'),
                    'max' => $this->safe_number($market, 'quote_max'),
                ),
                'cost' => array(
                    'min' => $this->safe_number($market, 'min_notional'),
                    'max' => null,
                ),
            ),
            'created' => $this->safe_timestamp($market, 'created_time'),
            'info' => $market,
        );
    }

    public function fetch_trades(string $symbol, ?int $since = null, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            /**
             * get the list of most recent trades for a particular $symbol
             * @param {string} $symbol unified $symbol of the $market to fetch trades for
             * @param {int} [$since] timestamp in ms of the earliest trade to fetch
             * @param {int} [$limit] the maximum amount of trades to fetch
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {Trade[]} a list of ~@link https://docs.ccxt.com/#/?id=public-trades trade structures~
             */
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $request = array(
                'symbol' => $market['id'],
            );
            if ($limit !== null) {
                $request['limit'] = $limit;
            }
            $response = Async\await($this->v1PublicGetMarketTrades (array_merge($request, $params)));
            //
            // {
            //     "success" => true,
            //     "rows" => array(
            //         array(
            //             "symbol" => "SPOT_BTC_USDT",
            //             "side" => "SELL",
            //             "executed_price" => 46222.35,
            //             "executed_quantity" => 0.0012,
            //             "executed_timestamp" => "1641241162.329"
            //         ),
            //         array(
            //             "symbol" => "SPOT_BTC_USDT",
            //             "side" => "SELL",
            //             "executed_price" => 46222.35,
            //             "executed_quantity" => 0.0012,
            //             "executed_timestamp" => "1641241162.329"
            //         ),
            //         array(
            //             "symbol" => "SPOT_BTC_USDT",
            //             "side" => "BUY",
            //             "executed_price" => 46224.32,
            //             "executed_quantity" => 0.00039,
            //             "executed_timestamp" => "1641241162.287"
            //         ),
            //         ...
            //      )
            // }
            //
            $resultResponse = $this->safe_value($response, 'rows', array());
            return $this->parse_trades($resultResponse, $market, $since, $limit);
        }) ();
    }

    public function parse_trade($trade, ?array $market = null): array {
        //
        // public/market_trades
        //
        //     {
        //         "symbol" => "SPOT_BTC_USDT",
        //         "side" => "SELL",
        //         "executed_price" => 46222.35,
        //         "executed_quantity" => 0.0012,
        //         "executed_timestamp" => "1641241162.329"
        //     }
        //
        // fetchOrderTrades, fetchOrder
        //
        //     {
        //         "id" => "99119876",
        //         "symbol" => "SPOT_WOO_USDT",
        //         "fee" => "0.0024",
        //         "side" => "BUY",
        //         "executed_timestamp" => "1641481113.084",
        //         "order_id" => "87001234",
        //         "order_tag" => "default", <-- this param only in "fetchOrderTrades"
        //         "executed_price" => "1",
        //         "executed_quantity" => "12",
        //         "fee_asset" => "WOO",
        //         "is_maker" => "1"
        //     }
        //
        $isFromFetchOrder = (is_array($trade) && array_key_exists('id', $trade));
        $timestamp = $this->safe_timestamp($trade, 'executed_timestamp');
        $marketId = $this->safe_string($trade, 'symbol');
        $market = $this->safe_market($marketId, $market);
        $symbol = $market['symbol'];
        $price = $this->safe_string($trade, 'executed_price');
        $amount = $this->safe_string($trade, 'executed_quantity');
        $order_id = $this->safe_string($trade, 'order_id');
        $fee = $this->parse_token_and_fee_temp($trade, 'fee_asset', 'fee');
        $cost = Precise::string_mul($price, $amount);
        $side = $this->safe_string_lower($trade, 'side');
        $id = $this->safe_string($trade, 'id');
        $takerOrMaker = null;
        if ($isFromFetchOrder) {
            $isMaker = $this->safe_string($trade, 'is_maker') === '1';
            $takerOrMaker = $isMaker ? 'maker' : 'taker';
        }
        return $this->safe_trade(array(
            'id' => $id,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'symbol' => $symbol,
            'side' => $side,
            'price' => $price,
            'amount' => $amount,
            'cost' => $cost,
            'order' => $order_id,
            'takerOrMaker' => $takerOrMaker,
            'type' => null,
            'fee' => $fee,
            'info' => $trade,
        ), $market);
    }

    public function parse_token_and_fee_temp($item, $feeTokenKey, $feeAmountKey) {
        $feeCost = $this->safe_string($item, $feeAmountKey);
        $fee = null;
        if ($feeCost !== null) {
            $feeCurrencyId = $this->safe_string($item, $feeTokenKey);
            $feeCurrencyCode = $this->safe_currency_code($feeCurrencyId);
            $fee = array(
                'cost' => $feeCost,
                'currency' => $feeCurrencyCode,
            );
        }
        return $fee;
    }

    public function fetch_trading_fees($params = array ()) {
        return Async\async(function () use ($params) {
            /**
             * fetch the trading fees for multiple markets
             * @see https://docs.woo.org/#get-account-information-new
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} a dictionary of ~@link https://docs.ccxt.com/#/?id=fee-structure fee structures~ indexed by market symbols
             */
            Async\await($this->load_markets());
            $response = Async\await($this->v3PrivateGetAccountinfo ($params));
            //
            //     {
            //         "success" => true,
            //         "data" => array(
            //             "applicationId" => "dsa",
            //             "account" => "dsa",
            //             "alias" => "haha",
            //             "accountMode" => "MARGIN",
            //             "leverage" => 1,
            //             "takerFeeRate" => 1,
            //             "makerFeeRate" => 1,
            //             "interestRate" => 1,
            //             "futuresTakerFeeRate" => 1,
            //             "futuresMakerFeeRate" => 1,
            //             "otpauth" => true,
            //             "marginRatio" => 1,
            //             "openMarginRatio" => 1,
            //             "initialMarginRatio" => 1,
            //             "maintenanceMarginRatio" => 1,
            //             "totalCollateral" => 1,
            //             "freeCollateral" => 1,
            //             "totalAccountValue" => 1,
            //             "totalVaultValue" => 1,
            //             "totalStakingValue" => 1
            //         ),
            //         "timestamp" => 1673323685109
            //     }
            //
            $data = $this->safe_value($response, 'data', array());
            $maker = $this->safe_string($data, 'makerFeeRate');
            $taker = $this->safe_string($data, 'takerFeeRate');
            $result = array();
            for ($i = 0; $i < count($this->symbols); $i++) {
                $symbol = $this->symbols[$i];
                $result[$symbol] = array(
                    'info' => $response,
                    'symbol' => $symbol,
                    'maker' => $this->parse_number(Precise::string_div($maker, '10000')),
                    'taker' => $this->parse_number(Precise::string_div($taker, '10000')),
                    'percentage' => true,
                    'tierBased' => true,
                );
            }
            return $result;
        }) ();
    }

    public function fetch_currencies($params = array ()) {
        return Async\async(function () use ($params) {
            /**
             * fetches all available currencies on an exchange
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} an associative dictionary of currencies
             */
            $result = array();
            $tokenResponse = Async\await($this->v1PublicGetToken ($params));
            //
            // {
            //     "rows" => array(
            //         array(
            //             "token" => "ETH_USDT",
            //             "fullname" => "Tether",
            //             "decimals" => 6,
            //             "balance_token" => "USDT",
            //             "created_time" => "0",
            //             "updated_time" => "0"
            //         ),
            //         array(
            //             "token" => "BSC_USDT",
            //             "fullname" => "Tether",
            //             "decimals" => 18,
            //             "balance_token" => "USDT",
            //             "created_time" => "0",
            //             "updated_time" => "0"
            //         ),
            //         array(
            //             "token" => "ZEC",
            //             "fullname" => "ZCash",
            //             "decimals" => 8,
            //             "balance_token" => "ZEC",
            //             "created_time" => "0",
            //             "updated_time" => "0"
            //         ),
            //         ...
            //     ),
            //     "success" => true
            // }
            //
            // only make one request for currrencies...
            // $tokenNetworkResponse = Async\await($this->v1PublicGetTokenNetwork ($params));
            //
            // {
            //     "rows" => array(
            //         array(
            //             "protocol" => "ERC20",
            //             "token" => "USDT",
            //             "name" => "Ethereum",
            //             "minimum_withdrawal" => 30,
            //             "withdrawal_fee" => 25,
            //             "allow_deposit" => 1,
            //             "allow_withdraw" => 1
            //         ),
            //         array(
            //             "protocol" => "TRC20",
            //             "token" => "USDT",
            //             "name" => "Tron",
            //             "minimum_withdrawal" => 30,
            //             "withdrawal_fee" => 1,
            //             "allow_deposit" => 1,
            //             "allow_withdraw" => 1
            //         ),
            //         ...
            //     ),
            //     "success" => true
            // }
            //
            $tokenRows = $this->safe_value($tokenResponse, 'rows', array());
            $networksByCurrencyId = $this->group_by($tokenRows, 'balance_token');
            $currencyIds = is_array($networksByCurrencyId) ? array_keys($networksByCurrencyId) : array();
            for ($i = 0; $i < count($currencyIds); $i++) {
                $currencyId = $currencyIds[$i];
                $networks = $networksByCurrencyId[$currencyId];
                $code = $this->safe_currency_code($currencyId);
                $name = null;
                $minPrecision = null;
                $resultingNetworks = array();
                for ($j = 0; $j < count($networks); $j++) {
                    $network = $networks[$j];
                    $name = $this->safe_string($network, 'fullname');
                    $networkId = $this->safe_string($network, 'token');
                    $splitted = explode('_', $networkId);
                    $unifiedNetwork = $splitted[0];
                    $precision = $this->parse_precision($this->safe_string($network, 'decimals'));
                    if ($precision !== null) {
                        $minPrecision = ($minPrecision === null) ? $precision : Precise::string_min($precision, $minPrecision);
                    }
                    $resultingNetworks[$unifiedNetwork] = array(
                        'id' => $networkId,
                        'network' => $unifiedNetwork,
                        'limits' => array(
                            'withdraw' => array(
                                'min' => null,
                                'max' => null,
                            ),
                            'deposit' => array(
                                'min' => null,
                                'max' => null,
                            ),
                        ),
                        'active' => null,
                        'deposit' => null,
                        'withdraw' => null,
                        'fee' => null,
                        'precision' => $this->parse_number($precision),
                        'info' => $network,
                    );
                }
                $result[$code] = array(
                    'id' => $currencyId,
                    'name' => $name,
                    'code' => $code,
                    'precision' => $this->parse_number($minPrecision),
                    'active' => null,
                    'fee' => null,
                    'networks' => $resultingNetworks,
                    'deposit' => null,
                    'withdraw' => null,
                    'limits' => array(
                        'deposit' => array(
                            'min' => null,
                            'max' => null,
                        ),
                        'withdraw' => array(
                            'min' => null,
                            'max' => null,
                        ),
                    ),
                    'info' => $networks,
                );
            }
            return $result;
        }) ();
    }

    public function create_market_buy_order_with_cost(string $symbol, $cost, $params = array ()) {
        return Async\async(function () use ($symbol, $cost, $params) {
            /**
             * create a $market buy order by providing the $symbol and $cost
             * @see https://docs.woo.org/#send-order
             * @param {string} $symbol unified $symbol of the $market to create an order in
             * @param {float} $cost how much you want to trade in units of the quote currency
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} an ~@link https://docs.ccxt.com/#/?id=order-structure order structure~
             */
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            if (!$market['spot']) {
                throw new NotSupported($this->id . ' createMarketBuyOrderWithCost() supports spot orders only');
            }
            $params['createMarketBuyOrderRequiresPrice'] = false;
            return Async\await($this->create_order($symbol, 'market', 'buy', $cost, null, $params));
        }) ();
    }

    public function create_trailing_amount_order(string $symbol, string $type, string $side, $amount, $price = null, $trailingAmount = null, $trailingTriggerPrice = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $type, $side, $amount, $price, $trailingAmount, $trailingTriggerPrice, $params) {
            /**
             * create a trailing order by providing the $symbol, $type, $side, $amount, $price and $trailingAmount
             * @param {string} $symbol unified $symbol of the market to create an order in
             * @param {string} $type 'market' or 'limit'
             * @param {string} $side 'buy' or 'sell'
             * @param {float} $amount how much you want to trade in units of the base currency, or number of contracts
             * @param {float} [$price] the $price for the order to be filled at, in units of the quote currency, ignored in market orders
             * @param {float} $trailingAmount the quote $amount to trail away from the current market $price
             * @param {float} $trailingTriggerPrice the $price to activate a trailing order, default uses the $price argument
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} an ~@link https://docs.ccxt.com/#/?id=order-structure order structure~
             */
            if ($trailingAmount === null) {
                throw new ArgumentsRequired($this->id . ' createTrailingAmountOrder() requires a $trailingAmount argument');
            }
            if ($trailingTriggerPrice === null) {
                throw new ArgumentsRequired($this->id . ' createTrailingAmountOrder() requires a $trailingTriggerPrice argument');
            }
            $params['trailingAmount'] = $trailingAmount;
            $params['trailingTriggerPrice'] = $trailingTriggerPrice;
            return Async\await($this->create_order($symbol, $type, $side, $amount, $price, $params));
        }) ();
    }

    public function create_trailing_percent_order(string $symbol, string $type, string $side, $amount, $price = null, $trailingPercent = null, $trailingTriggerPrice = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $type, $side, $amount, $price, $trailingPercent, $trailingTriggerPrice, $params) {
            /**
             * create a trailing order by providing the $symbol, $type, $side, $amount, $price and $trailingPercent
             * @param {string} $symbol unified $symbol of the market to create an order in
             * @param {string} $type 'market' or 'limit'
             * @param {string} $side 'buy' or 'sell'
             * @param {float} $amount how much you want to trade in units of the base currency, or number of contracts
             * @param {float} [$price] the $price for the order to be filled at, in units of the quote currency, ignored in market orders
             * @param {float} $trailingPercent the percent to trail away from the current market $price
             * @param {float} $trailingTriggerPrice the $price to activate a trailing order, default uses the $price argument
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} an ~@link https://docs.ccxt.com/#/?id=order-structure order structure~
             */
            if ($trailingPercent === null) {
                throw new ArgumentsRequired($this->id . ' createTrailingPercentOrder() requires a $trailingPercent argument');
            }
            if ($trailingTriggerPrice === null) {
                throw new ArgumentsRequired($this->id . ' createTrailingPercentOrder() requires a $trailingTriggerPrice argument');
            }
            $params['trailingPercent'] = $trailingPercent;
            $params['trailingTriggerPrice'] = $trailingTriggerPrice;
            return Async\await($this->create_order($symbol, $type, $side, $amount, $price, $params));
        }) ();
    }

    public function create_order(string $symbol, string $type, string $side, $amount, $price = null, $params = array ()) {
        return Async\async(function () use ($symbol, $type, $side, $amount, $price, $params) {
            /**
             * create a trade $order
             * @see https://docs.woo.org/#send-$order
             * @see https://docs.woo.org/#send-algo-$order
             * @param {string} $symbol unified $symbol of the $market to create an $order in
             * @param {string} $type 'market' or 'limit'
             * @param {string} $side 'buy' or 'sell'
             * @param {float} $amount how much of currency you want to trade in units of base currency
             * @param {float} [$price] the $price at which the $order is to be fullfilled, in units of the quote currency, ignored in $market orders
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @param {float} [$params->triggerPrice] The $price a trigger $order is triggered at
             * @param {array} [$params->takeProfit] *$takeProfit object in $params* containing the triggerPrice at which the attached take profit $order will be triggered (perpetual swap markets only)
             * @param {float} [$params->takeProfit.triggerPrice] take profit trigger $price
             * @param {array} [$params->stopLoss] *$stopLoss object in $params* containing the triggerPrice at which the attached stop loss $order will be triggered (perpetual swap markets only)
             * @param {float} [$params->stopLoss.triggerPrice] stop loss trigger $price
             * @param {float} [$params->algoType] 'STOP'or 'TRAILING_STOP' or 'OCO' or 'CLOSE_POSITION'
             * @param {float} [$params->cost] *spot $market buy only* the quote quantity that can be used alternative for the $amount
             * @param {string} [$params->trailingAmount] the quote $amount to trail away from the current $market $price
             * @param {string} [$params->trailingPercent] the percent to trail away from the current $market $price
             * @param {string} [$params->trailingTriggerPrice] the $price to trigger a trailing $order, default uses the $price argument
             * @return {array} an ~@link https://docs.ccxt.com/#/?id=$order-structure $order structure~
             */
            $reduceOnly = $this->safe_value_2($params, 'reduceOnly', 'reduce_only');
            $params = $this->omit($params, array( 'reduceOnly', 'reduce_only' ));
            $orderType = strtoupper($type);
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $orderSide = strtoupper($side);
            $request = array(
                'symbol' => $market['id'],
                'side' => $orderSide,
            );
            $stopPrice = $this->safe_number_2($params, 'triggerPrice', 'stopPrice');
            $stopLoss = $this->safe_value($params, 'stopLoss');
            $takeProfit = $this->safe_value($params, 'takeProfit');
            $algoType = $this->safe_string($params, 'algoType');
            $trailingTriggerPrice = $this->safe_string_2($params, 'trailingTriggerPrice', 'activatedPrice', $price);
            $trailingAmount = $this->safe_string_2($params, 'trailingAmount', 'callbackValue');
            $trailingPercent = $this->safe_string_2($params, 'trailingPercent', 'callbackRate');
            $isTrailingAmountOrder = $trailingAmount !== null;
            $isTrailingPercentOrder = $trailingPercent !== null;
            $isTrailing = $isTrailingAmountOrder || $isTrailingPercentOrder;
            $isStop = $isTrailing || $stopPrice !== null || $stopLoss !== null || $takeProfit !== null || ($this->safe_value($params, 'childOrders') !== null);
            $isMarket = $orderType === 'MARKET';
            $timeInForce = $this->safe_string_lower($params, 'timeInForce');
            $postOnly = $this->is_post_only($isMarket, null, $params);
            $reduceOnlyKey = $isStop ? 'reduceOnly' : 'reduce_only';
            $clientOrderIdKey = $isStop ? 'clientOrderId' : 'client_order_id';
            $orderQtyKey = $isStop ? 'quantity' : 'order_quantity';
            $priceKey = $isStop ? 'price' : 'order_price';
            $typeKey = $isStop ? 'type' : 'order_type';
            $request[$typeKey] = $orderType; // LIMIT/MARKET/IOC/FOK/POST_ONLY/ASK/BID
            if (!$isStop) {
                if ($postOnly) {
                    $request['order_type'] = 'POST_ONLY';
                } elseif ($timeInForce === 'fok') {
                    $request['order_type'] = 'FOK';
                } elseif ($timeInForce === 'ioc') {
                    $request['order_type'] = 'IOC';
                }
            }
            if ($reduceOnly) {
                $request[$reduceOnlyKey] = $reduceOnly;
            }
            if ($price !== null) {
                $request[$priceKey] = $this->price_to_precision($symbol, $price);
            }
            if ($isMarket && !$isStop) {
                // for $market buy it requires the $amount of quote currency to spend
                if ($market['spot'] && $orderSide === 'BUY') {
                    $quoteAmount = null;
                    $createMarketBuyOrderRequiresPrice = true;
                    list($createMarketBuyOrderRequiresPrice, $params) = $this->handle_option_and_params($params, 'createOrder', 'createMarketBuyOrderRequiresPrice', true);
                    $cost = $this->safe_number_2($params, 'cost', 'order_amount');
                    $params = $this->omit($params, array( 'cost', 'order_amount' ));
                    if ($cost !== null) {
                        $quoteAmount = $this->cost_to_precision($symbol, $cost);
                    } elseif ($createMarketBuyOrderRequiresPrice) {
                        if ($price === null) {
                            throw new InvalidOrder($this->id . ' createOrder() requires the $price argument for $market buy orders to calculate the total $cost to spend ($amount * $price), alternatively set the $createMarketBuyOrderRequiresPrice option or param to false and pass the $cost to spend (quote quantity) in the $amount argument');
                        } else {
                            $amountString = $this->number_to_string($amount);
                            $priceString = $this->number_to_string($price);
                            $costRequest = Precise::string_mul($amountString, $priceString);
                            $quoteAmount = $this->cost_to_precision($symbol, $costRequest);
                        }
                    } else {
                        $quoteAmount = $this->cost_to_precision($symbol, $amount);
                    }
                    $request['order_amount'] = $quoteAmount;
                } else {
                    $request['order_quantity'] = $this->amount_to_precision($symbol, $amount);
                }
            } elseif ($algoType !== 'POSITIONAL_TP_SL') {
                $request[$orderQtyKey] = $this->amount_to_precision($symbol, $amount);
            }
            $clientOrderId = $this->safe_string_n($params, array( 'clOrdID', 'clientOrderId', 'client_order_id' ));
            if ($clientOrderId !== null) {
                $request[$clientOrderIdKey] = $clientOrderId;
            }
            if ($isTrailing) {
                if ($trailingTriggerPrice === null) {
                    throw new ArgumentsRequired($this->id . ' createOrder() requires a $trailingTriggerPrice parameter for trailing orders');
                }
                $request['activatedPrice'] = $this->price_to_precision($symbol, $trailingTriggerPrice);
                $request['algoType'] = 'TRAILING_STOP';
                if ($isTrailingAmountOrder) {
                    $request['callbackValue'] = $trailingAmount;
                } elseif ($isTrailingPercentOrder) {
                    $convertedTrailingPercent = Precise::string_div($trailingPercent, '100');
                    $request['callbackRate'] = $convertedTrailingPercent;
                }
            } elseif ($stopPrice !== null) {
                if ($algoType !== 'TRAILING_STOP') {
                    $request['triggerPrice'] = $this->price_to_precision($symbol, $stopPrice);
                    $request['algoType'] = 'STOP';
                }
            } elseif (($stopLoss !== null) || ($takeProfit !== null)) {
                $request['algoType'] = 'BRACKET';
                $outterOrder = array(
                    'symbol' => $market['id'],
                    'reduceOnly' => false,
                    'algoType' => 'POSITIONAL_TP_SL',
                    'childOrders' => array(),
                );
                $closeSide = ($orderSide === 'BUY') ? 'SELL' : 'BUY';
                if ($stopLoss !== null) {
                    $stopLossPrice = $this->safe_number_2($stopLoss, 'triggerPrice', 'price', $stopLoss);
                    $stopLossOrder = array(
                        'side' => $closeSide,
                        'algoType' => 'STOP_LOSS',
                        'triggerPrice' => $this->price_to_precision($symbol, $stopLossPrice),
                        'type' => 'CLOSE_POSITION',
                        'reduceOnly' => true,
                    );
                    $outterOrder['childOrders'][] = $stopLossOrder;
                }
                if ($takeProfit !== null) {
                    $takeProfitPrice = $this->safe_number_2($takeProfit, 'triggerPrice', 'price', $takeProfit);
                    $takeProfitOrder = array(
                        'side' => $closeSide,
                        'algoType' => 'TAKE_PROFIT',
                        'triggerPrice' => $this->price_to_precision($symbol, $takeProfitPrice),
                        'type' => 'CLOSE_POSITION',
                        'reduceOnly' => true,
                    );
                    $outterOrder['childOrders'][] = $takeProfitOrder;
                }
                $request['childOrders'] = array( $outterOrder );
            }
            $params = $this->omit($params, array( 'clOrdID', 'clientOrderId', 'client_order_id', 'postOnly', 'timeInForce', 'stopPrice', 'triggerPrice', 'stopLoss', 'takeProfit', 'trailingPercent', 'trailingAmount', 'trailingTriggerPrice' ));
            $response = null;
            if ($isStop) {
                $response = Async\await($this->v3PrivatePostAlgoOrder (array_merge($request, $params)));
            } else {
                $response = Async\await($this->v1PrivatePostOrder (array_merge($request, $params)));
            }
            // {
            //     "success" => true,
            //     "timestamp" => "1641383206.489",
            //     "order_id" => "86980774",
            //     "order_type" => "LIMIT",
            //     "order_price" => "1", // null for "MARKET" $order
            //     "order_quantity" => "12", // null for "MARKET" $order
            //     "order_amount" => null, // NOT-null for "MARKET" $order
            //     "client_order_id" => "0"
            // }
            // stop orders
            // {
            //     "success" => true,
            //     "data" => {
            //       "rows" => array(
            //         array(
            //           "orderId" => "1578938",
            //           "clientOrderId" => "0",
            //           "algoType" => "STOP_LOSS",
            //           "quantity" => "0.1"
            //         }
            //       )
            //     ),
            //     "timestamp" => "1686149372216"
            // }
            $data = $this->safe_value($response, 'data');
            if ($data !== null) {
                $rows = $this->safe_value($data, 'rows', array());
                return $this->parse_order($rows[0], $market);
            }
            $order = $this->parse_order($response, $market);
            $order['type'] = $type;
            return $order;
        }) ();
    }

    public function edit_order(string $id, $symbol, $type, $side, $amount = null, $price = null, $params = array ()) {
        return Async\async(function () use ($id, $symbol, $type, $side, $amount, $price, $params) {
            /**
             * edit a trade order
             * @see https://docs.woo.org/#edit-order
             * @see https://docs.woo.org/#edit-order-by-client_order_id
             * @see https://docs.woo.org/#edit-algo-order
             * @see https://docs.woo.org/#edit-algo-order-by-client_order_id
             * @param {string} $id order $id
             * @param {string} $symbol unified $symbol of the $market to create an order in
             * @param {string} $type 'market' or 'limit'
             * @param {string} $side 'buy' or 'sell'
             * @param {float} $amount how much of currency you want to trade in units of base currency
             * @param {float} [$price] the $price at which the order is to be fullfilled, in units of the quote currency, ignored in $market orders
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @param {float} [$params->triggerPrice] The $price a trigger order is triggered at
             * @param {float} [$params->stopLossPrice] $price to trigger stop-loss orders
             * @param {float} [$params->takeProfitPrice] $price to trigger take-profit orders
             * @param {string} [$params->trailingAmount] the quote $amount to trail away from the current $market $price
             * @param {string} [$params->trailingPercent] the percent to trail away from the current $market $price
             * @param {string} [$params->trailingTriggerPrice] the $price to trigger a trailing order, default uses the $price argument
             * @return {array} an ~@link https://docs.ccxt.com/#/?$id=order-structure order structure~
             */
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $request = array(
                // 'quantity' => $this->amount_to_precision($symbol, $amount),
                // 'price' => $this->price_to_precision($symbol, $price),
            );
            if ($price !== null) {
                $request['price'] = $this->price_to_precision($symbol, $price);
            }
            if ($amount !== null) {
                $request['quantity'] = $this->amount_to_precision($symbol, $amount);
            }
            $clientOrderIdUnified = $this->safe_string_2($params, 'clOrdID', 'clientOrderId');
            $clientOrderIdExchangeSpecific = $this->safe_string($params, 'client_order_id', $clientOrderIdUnified);
            $isByClientOrder = $clientOrderIdExchangeSpecific !== null;
            $stopPrice = $this->safe_number_n($params, array( 'triggerPrice', 'stopPrice', 'takeProfitPrice', 'stopLossPrice' ));
            if ($stopPrice !== null) {
                $request['triggerPrice'] = $this->price_to_precision($symbol, $stopPrice);
            }
            $trailingTriggerPrice = $this->safe_string_2($params, 'trailingTriggerPrice', 'activatedPrice', $price);
            $trailingAmount = $this->safe_string_2($params, 'trailingAmount', 'callbackValue');
            $trailingPercent = $this->safe_string_2($params, 'trailingPercent', 'callbackRate');
            $isTrailingAmountOrder = $trailingAmount !== null;
            $isTrailingPercentOrder = $trailingPercent !== null;
            $isTrailing = $isTrailingAmountOrder || $isTrailingPercentOrder;
            if ($isTrailing) {
                if ($trailingTriggerPrice !== null) {
                    $request['activatedPrice'] = $this->price_to_precision($symbol, $trailingTriggerPrice);
                }
                if ($isTrailingAmountOrder) {
                    $request['callbackValue'] = $trailingAmount;
                } elseif ($isTrailingPercentOrder) {
                    $convertedTrailingPercent = Precise::string_div($trailingPercent, '100');
                    $request['callbackRate'] = $convertedTrailingPercent;
                }
            }
            $params = $this->omit($params, array( 'clOrdID', 'clientOrderId', 'client_order_id', 'stopPrice', 'triggerPrice', 'takeProfitPrice', 'stopLossPrice', 'trailingTriggerPrice', 'trailingAmount', 'trailingPercent' ));
            $isStop = $isTrailing || ($stopPrice !== null) || ($this->safe_value($params, 'childOrders') !== null);
            $response = null;
            if ($isByClientOrder) {
                $request['client_order_id'] = $clientOrderIdExchangeSpecific;
                if ($isStop) {
                    $response = Async\await($this->v3PrivatePutAlgoOrderClientClientOrderId (array_merge($request, $params)));
                } else {
                    $response = Async\await($this->v3PrivatePutOrderClientClientOrderId (array_merge($request, $params)));
                }
            } else {
                $request['oid'] = $id;
                if ($isStop) {
                    $response = Async\await($this->v3PrivatePutAlgoOrderOid (array_merge($request, $params)));
                } else {
                    $response = Async\await($this->v3PrivatePutOrderOid (array_merge($request, $params)));
                }
            }
            //
            //     {
            //         "code" => 0,
            //         "data" => array(
            //             "status" => "string",
            //             "success" => true
            //         ),
            //         "message" => "string",
            //         "success" => true,
            //         "timestamp" => 0
            //     }
            //
            $data = $this->safe_value($response, 'data', array());
            return $this->parse_order($data, $market);
        }) ();
    }

    public function cancel_order(string $id, ?string $symbol = null, $params = array ()) {
        return Async\async(function () use ($id, $symbol, $params) {
            /**
             * @see https://docs.woo.org/#cancel-algo-order
             * @see https://docs.woo.org/#cancel-order
             * @see https://docs.woo.org/#cancel-order-by-client_order_id
             * cancels an open order
             * @param {string} $id order $id
             * @param {string} $symbol unified $symbol of the $market the order was made in
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @param {boolean} [$params->stop] whether the order is a stop/algo order
             * @return {array} An ~@link https://docs.ccxt.com/#/?$id=order-structure order structure~
             */
            $stop = $this->safe_value($params, 'stop', false);
            $params = $this->omit($params, 'stop');
            if (!$stop && ($symbol === null)) {
                throw new ArgumentsRequired($this->id . ' cancelOrder() requires a $symbol argument');
            }
            Async\await($this->load_markets());
            $market = null;
            if ($symbol !== null) {
                $market = $this->market($symbol);
            }
            $request = array();
            $clientOrderIdUnified = $this->safe_string_2($params, 'clOrdID', 'clientOrderId');
            $clientOrderIdExchangeSpecific = $this->safe_string($params, 'client_order_id', $clientOrderIdUnified);
            $isByClientOrder = $clientOrderIdExchangeSpecific !== null;
            $response = null;
            if ($stop) {
                $request['order_id'] = $id;
                $response = Async\await($this->v3PrivateDeleteAlgoOrderOrderId (array_merge($request, $params)));
            } else {
                $request['symbol'] = $market['id'];
                if ($isByClientOrder) {
                    $request['client_order_id'] = $clientOrderIdExchangeSpecific;
                    $params = $this->omit($params, array( 'clOrdID', 'clientOrderId', 'client_order_id' ));
                    $response = Async\await($this->v1PrivateDeleteClientOrder (array_merge($request, $params)));
                } else {
                    $request['order_id'] = $id;
                    $response = Async\await($this->v1PrivateDeleteOrder (array_merge($request, $params)));
                }
            }
            //
            // array( success => true, status => "CANCEL_SENT" )
            //
            $extendParams = array( 'symbol' => $symbol );
            if ($isByClientOrder) {
                $extendParams['client_order_id'] = $clientOrderIdExchangeSpecific;
            } else {
                $extendParams['id'] = $id;
            }
            return array_merge($this->parse_order($response), $extendParams);
        }) ();
    }

    public function cancel_all_orders(?string $symbol = null, $params = array ()) {
        return Async\async(function () use ($symbol, $params) {
            /**
             * @see https://docs.woo.org/#cancel-all-pending-orders
             * @see https://docs.woo.org/#cancel-orders
             * @see https://docs.woo.org/#cancel-all-pending-algo-orders
             * cancel all open orders in a $market
             * @param {string} $symbol unified $market $symbol
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @param {boolean} [$params->stop] whether the order is a stop/algo order
             * @return {array} an list of ~@link https://docs.ccxt.com/#/?id=order-structure order structures~
             */
            Async\await($this->load_markets());
            $stop = $this->safe_value($params, 'stop');
            $params = $this->omit($params, 'stop');
            if ($stop) {
                return Async\await($this->v3PrivateDeleteAlgoOrdersPending ($params));
            }
            if ($symbol === null) {
                throw new ArgumentsRequired($this->id . ' cancelOrders() requires a $symbol argument');
            }
            $market = $this->market($symbol);
            $request = array(
                'symbol' => $market['id'],
            );
            $response = Async\await($this->v1PrivateDeleteOrders (array_merge($request, $params)));
            //
            //     {
            //         "success":true,
            //         "status":"CANCEL_ALL_SENT"
            //     }
            //
            return $response;
        }) ();
    }

    public function fetch_order(string $id, ?string $symbol = null, $params = array ()) {
        return Async\async(function () use ($id, $symbol, $params) {
            /**
             * @see https://docs.woo.org/#get-algo-order
             * @see https://docs.woo.org/#get-order
             * fetches information on an order made by the user
             * @param {string} $symbol unified $symbol of the $market the order was made in
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @param {boolean} [$params->stop] whether the order is a stop/algo order
             * @return {array} An ~@link https://docs.ccxt.com/#/?$id=order-structure order structure~
             */
            Async\await($this->load_markets());
            $market = ($symbol !== null) ? $this->market($symbol) : null;
            $stop = $this->safe_value($params, 'stop');
            $params = $this->omit($params, 'stop');
            $request = array();
            $clientOrderId = $this->safe_string_2($params, 'clOrdID', 'clientOrderId');
            $response = null;
            if ($stop) {
                $request['oid'] = $id;
                $response = Async\await($this->v3PrivateGetAlgoOrderOid (array_merge($request, $params)));
            } elseif ($clientOrderId) {
                $request['client_order_id'] = $clientOrderId;
                $response = Async\await($this->v1PrivateGetClientOrderClientOrderId (array_merge($request, $params)));
            } else {
                $request['oid'] = $id;
                $response = Async\await($this->v1PrivateGetOrderOid (array_merge($request, $params)));
            }
            //
            // {
            //     "success" => true,
            //     "symbol" => "SPOT_WOO_USDT",
            //     "status" => "FILLED", // FILLED, NEW
            //     "side" => "BUY",
            //     "created_time" => "1641480933.000",
            //     "order_id" => "87541111",
            //     "order_tag" => "default",
            //     "price" => "1",
            //     "type" => "LIMIT",
            //     "quantity" => "12",
            //     "amount" => null,
            //     "visible" => "12",
            //     "executed" => "12", // or any partial amount
            //     "total_fee" => "0.0024",
            //     "fee_asset" => "WOO",
            //     "client_order_id" => null,
            //     "average_executed_price" => "1",
            //     "Transactions" => array(
            //       {
            //         "id" => "99111647",
            //         "symbol" => "SPOT_WOO_USDT",
            //         "fee" => "0.0024",
            //         "side" => "BUY",
            //         "executed_timestamp" => "1641482113.084",
            //         "order_id" => "87541111",
            //         "executed_price" => "1",
            //         "executed_quantity" => "12",
            //         "fee_asset" => "WOO",
            //         "is_maker" => "1"
            //       }
            //     )
            // }
            //
            $orders = $this->safe_value($response, 'data', $response);
            return $this->parse_order($orders, $market);
        }) ();
    }

    public function fetch_orders(?string $symbol = null, ?int $since = null, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            /**
             * fetches information on multiple $orders made by the user
             * @see https://docs.woo.org/#get-$orders
             * @see https://docs.woo.org/#get-algo-$orders
             * @param {string} $symbol unified $market $symbol of the $market $orders were made in
             * @param {int} [$since] the earliest time in ms to fetch $orders for
             * @param {int} [$limit] the maximum number of order structures to retrieve
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @param {boolean} [$params->stop] whether the order is a stop/algo order
             * @param {boolean} [$params->isTriggered] whether the order has been triggered (false by default)
             * @param {string} [$params->side] 'buy' or 'sell'
             * @param {boolean} [$params->trailing] set to true if you want to fetch $trailing $orders
             * @return {Order[]} a list of ~@link https://docs.ccxt.com/#/?id=order-structure order structures~
             */
            Async\await($this->load_markets());
            $request = array();
            $market = null;
            $stop = $this->safe_value($params, 'stop');
            $trailing = $this->safe_value($params, 'trailing', false);
            $params = $this->omit($params, array( 'stop', 'trailing' ));
            if ($symbol !== null) {
                $market = $this->market($symbol);
                $request['symbol'] = $market['id'];
            }
            if ($since !== null) {
                if ($stop || $trailing) {
                    $request['createdTimeStart'] = $since;
                } else {
                    $request['start_t'] = $since;
                }
            }
            if ($stop) {
                $request['algoType'] = 'stop';
            } elseif ($trailing) {
                $request['algoType'] = 'TRAILING_STOP';
            }
            $response = null;
            if ($stop || $trailing) {
                $response = Async\await($this->v3PrivateGetAlgoOrders (array_merge($request, $params)));
            } else {
                $response = Async\await($this->v1PrivateGetOrders (array_merge($request, $params)));
            }
            //
            //     {
            //         "success":true,
            //         "meta":array(
            //             "total":1,
            //             "records_per_page":100,
            //             "current_page":1
            //         ),
            //         "rows":array(
            //             {
            //                 "symbol":"PERP_BTC_USDT",
            //                 "status":"FILLED",
            //                 "side":"SELL",
            //                 "created_time":"1611617776.000",
            //                 "updated_time":"1611617776.000",
            //                 "order_id":52121167,
            //                 "order_tag":"default",
            //                 "price":null,
            //                 "type":"MARKET",
            //                 "quantity":0.002,
            //                 "amount":null,
            //                 "visible":0,
            //                 "executed":0.002,
            //                 "total_fee":0.01732885,
            //                 "fee_asset":"USDT",
            //                 "client_order_id":null,
            //                 "average_executed_price":28881.41
            //             }
            //         )
            //     }
            //
            $data = $this->safe_value($response, 'data', $response);
            $orders = $this->safe_value($data, 'rows');
            return $this->parse_orders($orders, $market, $since, $limit, $params);
        }) ();
    }

    public function parse_time_in_force($timeInForce) {
        $timeInForces = array(
            'ioc' => 'IOC',
            'fok' => 'FOK',
            'post_only' => 'PO',
        );
        return $this->safe_string($timeInForces, $timeInForce, null);
    }

    public function parse_order($order, ?array $market = null): array {
        //
        // Possible input functions:
        // * createOrder
        // * cancelOrder
        // * fetchOrder
        // * fetchOrders
        // $isFromFetchOrder = (is_array($order) && array_key_exists('order_tag', $order)); TO_DO
        //
        // stop $order after creating it:
        //   {
        //     "orderId" => "1578938",
        //     "clientOrderId" => "0",
        //     "algoType" => "STOP_LOSS",
        //     "quantity" => "0.1"
        //   }
        // stop $order after fetching it:
        //   {
        //       "algoOrderId" => "1578958",
        //       "clientOrderId" => "0",
        //       "rootAlgoOrderId" => "1578958",
        //       "parentAlgoOrderId" => "0",
        //       "symbol" => "SPOT_LTC_USDT",
        //       "orderTag" => "default",
        //       "algoType" => "STOP_LOSS",
        //       "side" => "BUY",
        //       "quantity" => "0.1",
        //       "isTriggered" => false,
        //       "triggerPrice" => "100",
        //       "triggerStatus" => "USELESS",
        //       "type" => "LIMIT",
        //       "rootAlgoStatus" => "CANCELLED",
        //       "algoStatus" => "CANCELLED",
        //       "triggerPriceType" => "MARKET_PRICE",
        //       "price" => "75",
        //       "triggerTime" => "0",
        //       "totalExecutedQuantity" => "0",
        //       "averageExecutedPrice" => "0",
        //       "totalFee" => "0",
        //       "feeAsset" => '',
        //       "reduceOnly" => false,
        //       "createdTime" => "1686149609.744",
        //       "updatedTime" => "1686149903.362"
        //   }
        //
        $timestamp = $this->safe_timestamp_n($order, array( 'timestamp', 'created_time', 'createdTime' ));
        $orderId = $this->safe_string_n($order, array( 'order_id', 'orderId', 'algoOrderId' ));
        $clientOrderId = $this->omit_zero($this->safe_string_2($order, 'client_order_id', 'clientOrderId')); // Somehow, this always returns 0 for limit $order
        $marketId = $this->safe_string($order, 'symbol');
        $market = $this->safe_market($marketId, $market);
        $symbol = $market['symbol'];
        $price = $this->safe_string_2($order, 'order_price', 'price');
        $amount = $this->safe_string_2($order, 'order_quantity', 'quantity'); // This is base $amount
        $cost = $this->safe_string_2($order, 'order_amount', 'amount'); // This is quote $amount
        $orderType = $this->safe_string_lower_2($order, 'order_type', 'type');
        $status = $this->safe_value_2($order, 'status', 'algoStatus');
        $side = $this->safe_string_lower($order, 'side');
        $filled = $this->omit_zero($this->safe_value_2($order, 'executed', 'totalExecutedQuantity'));
        $average = $this->omit_zero($this->safe_string_2($order, 'average_executed_price', 'averageExecutedPrice'));
        $remaining = Precise::string_sub($cost, $filled);
        $fee = $this->safe_value_2($order, 'total_fee', 'totalFee');
        $feeCurrency = $this->safe_string_2($order, 'fee_asset', 'feeAsset');
        $transactions = $this->safe_value($order, 'Transactions');
        $stopPrice = $this->safe_number($order, 'triggerPrice');
        $takeProfitPrice = null;
        $stopLossPrice = null;
        $childOrders = $this->safe_value($order, 'childOrders');
        if ($childOrders !== null) {
            $first = $this->safe_value($childOrders, 0);
            $innerChildOrders = $this->safe_value($first, 'childOrders', array());
            $innerChildOrdersLength = count($innerChildOrders);
            if ($innerChildOrdersLength > 0) {
                $takeProfitOrder = $this->safe_value($innerChildOrders, 0);
                $stopLossOrder = $this->safe_value($innerChildOrders, 1);
                $takeProfitPrice = $this->safe_number($takeProfitOrder, 'triggerPrice');
                $stopLossPrice = $this->safe_number($stopLossOrder, 'triggerPrice');
            }
        }
        $lastUpdateTimestamp = $this->safe_timestamp_2($order, 'updatedTime', 'updated_time');
        return $this->safe_order(array(
            'id' => $orderId,
            'clientOrderId' => $clientOrderId,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'lastTradeTimestamp' => null,
            'lastUpdateTimestamp' => $lastUpdateTimestamp,
            'status' => $this->parse_order_status($status),
            'symbol' => $symbol,
            'type' => $orderType,
            'timeInForce' => $this->parse_time_in_force($orderType),
            'postOnly' => null, // TO_DO
            'reduceOnly' => $this->safe_value($order, 'reduce_only'),
            'side' => $side,
            'price' => $price,
            'stopPrice' => $stopPrice,
            'triggerPrice' => $stopPrice,
            'takeProfitPrice' => $takeProfitPrice,
            'stopLossPrice' => $stopLossPrice,
            'average' => $average,
            'amount' => $amount,
            'filled' => $filled,
            'remaining' => $remaining, // TO_DO
            'cost' => $cost,
            'trades' => $transactions,
            'fee' => array(
                'cost' => $fee,
                'currency' => $feeCurrency,
            ),
            'info' => $order,
        ), $market);
    }

    public function parse_order_status($status) {
        if ($status !== null) {
            $statuses = array(
                'NEW' => 'open',
                'FILLED' => 'closed',
                'CANCEL_SENT' => 'canceled',
                'CANCEL_ALL_SENT' => 'canceled',
                'CANCELLED' => 'canceled',
                'PARTIAL_FILLED' => 'open',
                'REJECTED' => 'rejected',
                'INCOMPLETE' => 'open',
                'COMPLETED' => 'closed',
            );
            return $this->safe_string($statuses, $status, $status);
        }
        return $status;
    }

    public function fetch_order_book(string $symbol, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $limit, $params) {
            /**
             * fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
             * @param {string} $symbol unified $symbol of the $market to fetch the order book for
             * @param {int} [$limit] the maximum amount of order book entries to return
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} A dictionary of ~@link https://docs.ccxt.com/#/?id=order-book-structure order book structures~ indexed by $market symbols
             */
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $request = array(
                'symbol' => $market['id'],
            );
            if ($limit !== null) {
                $limit = min ($limit, 1000);
                $request['max_level'] = $limit;
            }
            $response = Async\await($this->v1PublicGetOrderbookSymbol (array_merge($request, $params)));
            //
            // {
            //   "success" => true,
            //   "timestamp" => "1641562961192",
            //   "asks" => array(
            //     array( price => '0.921', quantity => "76.01" ),
            //     array( price => '0.933', quantity => "477.10" ),
            //     ...
            //   ),
            //   "bids" => array(
            //     array( price => '0.940', quantity => "13502.47" ),
            //     array( price => '0.932', quantity => "43.91" ),
            //     ...
            //   )
            // }
            //
            $timestamp = $this->safe_integer($response, 'timestamp');
            return $this->parse_order_book($response, $symbol, $timestamp, 'bids', 'asks', 'price', 'quantity');
        }) ();
    }

    public function fetch_ohlcv(string $symbol, $timeframe = '1m', ?int $since = null, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $timeframe, $since, $limit, $params) {
            /**
             * @see https://docs.woo.org/#kline-public
             * fetches historical candlestick $data containing the open, high, low, and close price, and the volume of a $market
             * @param {string} $symbol unified $symbol of the $market to fetch OHLCV $data for
             * @param {string} $timeframe the length of time each candle represents
             * @param {int} [$since] timestamp in ms of the earliest candle to fetch
             * @param {int} [$limit] the maximum amount of candles to fetch
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {int[][]} A list of candles ordered, open, high, low, close, volume
             */
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $request = array(
                'symbol' => $market['id'],
                'type' => $this->safe_string($this->timeframes, $timeframe, $timeframe),
            );
            if ($limit !== null) {
                $request['limit'] = min ($limit, 1000);
            }
            $response = Async\await($this->v1PublicGetKline (array_merge($request, $params)));
            // {
            //     "success" => true,
            //     "rows" => array(
            //       array(
            //         "open" => "0.94238",
            //         "close" => "0.94271",
            //         "low" => "0.94238",
            //         "high" => "0.94296",
            //         "volume" => "73.55",
            //         "amount" => "69.32040520",
            //         "symbol" => "SPOT_WOO_USDT",
            //         "type" => "1m",
            //         "start_timestamp" => "1641584700000",
            //         "end_timestamp" => "1641584760000"
            //       ),
            //       array(
            //         "open" => "0.94186",
            //         "close" => "0.94186",
            //         "low" => "0.94186",
            //         "high" => "0.94186",
            //         "volume" => "64.00",
            //         "amount" => "60.27904000",
            //         "symbol" => "SPOT_WOO_USDT",
            //         "type" => "1m",
            //         "start_timestamp" => "1641584640000",
            //         "end_timestamp" => "1641584700000"
            //       ),
            //       ...
            //     )
            // }
            $data = $this->safe_value($response, 'rows', array());
            return $this->parse_ohlcvs($data, $market, $timeframe, $since, $limit);
        }) ();
    }

    public function parse_ohlcv($ohlcv, ?array $market = null): array {
        // example response in fetchOHLCV
        return array(
            $this->safe_integer($ohlcv, 'start_timestamp'),
            $this->safe_number($ohlcv, 'open'),
            $this->safe_number($ohlcv, 'high'),
            $this->safe_number($ohlcv, 'low'),
            $this->safe_number($ohlcv, 'close'),
            $this->safe_number($ohlcv, 'volume'),
        );
    }

    public function fetch_order_trades(string $id, ?string $symbol = null, ?int $since = null, ?int $limit = null, $params = array ()) {
        return Async\async(function () use ($id, $symbol, $since, $limit, $params) {
            /**
             * fetch all the $trades made from a single order
             * @param {string} $id order $id
             * @param {string} $symbol unified $market $symbol
             * @param {int} [$since] the earliest time in ms to fetch $trades for
             * @param {int} [$limit] the maximum number of $trades to retrieve
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array[]} a list of ~@link https://docs.ccxt.com/#/?$id=trade-structure trade structures~
             */
            Async\await($this->load_markets());
            $market = null;
            if ($symbol !== null) {
                $market = $this->market($symbol);
            }
            $request = array(
                'oid' => $id,
            );
            $response = Async\await($this->v1PrivateGetOrderOidTrades (array_merge($request, $params)));
            // {
            //     "success" => true,
            //     "rows" => array(
            //       {
            //         "id" => "99111647",
            //         "symbol" => "SPOT_WOO_USDT",
            //         "fee" => "0.0024",
            //         "side" => "BUY",
            //         "executed_timestamp" => "1641482113.084",
            //         "order_id" => "87541111",
            //         "order_tag" => "default",
            //         "executed_price" => "1",
            //         "executed_quantity" => "12",
            //         "fee_asset" => "WOO",
            //         "is_maker" => "1"
            //       }
            //     )
            // }
            $trades = $this->safe_value($response, 'rows', array());
            return $this->parse_trades($trades, $market, $since, $limit, $params);
        }) ();
    }

    public function fetch_my_trades(?string $symbol = null, ?int $since = null, ?int $limit = null, $params = array ()) {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            /**
             * fetch all $trades made by the user
             * @param {string} $symbol unified $market $symbol
             * @param {int} [$since] the earliest time in ms to fetch $trades for
             * @param {int} [$limit] the maximum number of $trades structures to retrieve
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {Trade[]} a list of ~@link https://docs.ccxt.com/#/?id=trade-structure trade structures~
             */
            Async\await($this->load_markets());
            $request = array();
            $market = null;
            if ($symbol !== null) {
                $market = $this->market($symbol);
                $request['symbol'] = $market['id'];
            }
            if ($since !== null) {
                $request['start_t'] = $since;
            }
            $response = Async\await($this->v1PrivateGetClientTrades (array_merge($request, $params)));
            // {
            //     "success" => true,
            //     "meta" => array(
            //         "records_per_page" => 25,
            //         "current_page" => 1
            //     ),
            //     "rows" => array(
            //         array(
            //             "id" => 5,
            //             "symbol" => "SPOT_BTC_USDT",
            //             "order_id" => 211,
            //             "order_tag" => "default",
            //             "executed_price" => 10892.84,
            //             "executed_quantity" => 0.002,
            //             "is_maker" => 0,
            //             "side" => "SELL",
            //             "fee" => 0,
            //             "fee_asset" => "USDT",
            //             "executed_timestamp" => "1566264290.250"
            //         ),
            //         ...
            //     )
            // }
            $trades = $this->safe_value($response, 'rows', array());
            return $this->parse_trades($trades, $market, $since, $limit, $params);
        }) ();
    }

    public function fetch_accounts($params = array ()) {
        return Async\async(function () use ($params) {
            /**
             * fetch all the accounts associated with a profile
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} a dictionary of ~@link https://docs.ccxt.com/#/?id=account-structure account structures~ indexed by the account type
             */
            $response = Async\await($this->v1PrivateGetSubAccountAssets ($params));
            //
            //     {
            //         "rows" => [array(
            //                 "application_id" => "13e4fc34-e2ff-4cb7-b1e4-4c22fee7d365",
            //                 "account" => "Main",
            //                 "usdt_balance" => "4.0"
            //             ),
            //             {
            //                 "application_id" => "432952aa-a401-4e26-aff6-972920aebba3",
            //                 "account" => "subaccount",
            //                 "usdt_balance" => "1.0"
            //             }
            //         ],
            //         "success" => true
            //     }
            //
            $rows = $this->safe_value($response, 'rows', array());
            return $this->parse_accounts($rows, $params);
        }) ();
    }

    public function parse_account($account) {
        //
        //     {
        //         "application_id" => "336952aa-a401-4e26-aff6-972920aebba3",
        //         "account" => "subaccount",
        //         "usdt_balance" => "1.0",
        //     }
        //
        $accountId = $this->safe_string($account, 'account');
        return array(
            'info' => $account,
            'id' => $this->safe_string($account, 'application_id'),
            'name' => $accountId,
            'code' => null,
            'type' => $accountId === 'Main' ? 'main' : 'subaccount',
        );
    }

    public function fetch_balance($params = array ()): PromiseInterface {
        return Async\async(function () use ($params) {
            /**
             * query for balance and get the amount of funds available for trading or funds locked in orders
             * @see https://docs.woo.org/#get-current-holding-get-balance-new
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} a ~@link https://docs.ccxt.com/#/?id=balance-structure balance structure~
             */
            Async\await($this->load_markets());
            $response = Async\await($this->v3PrivateGetBalances ($params));
            //
            //     {
            //         "success" => true,
            //         "data" => {
            //             "holding" => array(
            //                 array(
            //                     "token" => "0_token",
            //                     "holding" => 1,
            //                     "frozen" => 0,
            //                     "staked" => 0,
            //                     "unbonding" => 0,
            //                     "vault" => 0,
            //                     "interest" => 0,
            //                     "pendingShortQty" => 0,
            //                     "pendingLongQty" => 0,
            //                     "availableBalance" => 0,
            //                     "updatedTime" => 312321.121
            //                 }
            //             )
            //         ),
            //         "timestamp" => 1673323746259
            //     }
            //
            $data = $this->safe_value($response, 'data');
            return $this->parse_balance($data);
        }) ();
    }

    public function parse_balance($response): array {
        $result = array(
            'info' => $response,
        );
        $balances = $this->safe_value($response, 'holding', array());
        for ($i = 0; $i < count($balances); $i++) {
            $balance = $balances[$i];
            $code = $this->safe_currency_code($this->safe_string($balance, 'token'));
            $account = $this->account();
            $account['total'] = $this->safe_string($balance, 'holding');
            $account['free'] = $this->safe_string($balance, 'availableBalance');
            $result[$code] = $account;
        }
        return $this->safe_balance($result);
    }

    public function fetch_deposit_address(string $code, $params = array ()) {
        return Async\async(function () use ($code, $params) {
            /**
             * fetch the deposit $address for a $currency associated with this account
             * @param {string} $code unified $currency $code
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} an ~@link https://docs.ccxt.com/#/?id=$address-structure $address structure~
             */
            // this method is TODO because of networks unification
            Async\await($this->load_markets());
            $currency = $this->currency($code);
            $networkCodeDefault = $this->default_network_code_for_currency($code);
            $networkCode = $this->safe_string($params, 'network', $networkCodeDefault);
            $params = $this->omit($params, 'network');
            $codeForExchange = $networkCode . '_' . $currency['code'];
            $request = array(
                'token' => $codeForExchange,
            );
            $response = Async\await($this->v1PrivateGetAssetDeposit (array_merge($request, $params)));
            // {
            //     "success" => true,
            //     "address" => "3Jmtjx5544T4smrit9Eroe4PCrRkpDeKjP",
            //     "extra" => ''
            // }
            $tag = $this->safe_string($response, 'extra');
            $address = $this->safe_string($response, 'address');
            $this->check_address($address);
            return array(
                'currency' => $code,
                'address' => $address,
                'tag' => $tag,
                'network' => $networkCode,
                'info' => $response,
            );
        }) ();
    }

    public function get_asset_history_rows(?string $code = null, ?int $since = null, ?int $limit = null, $params = array ()) {
        return Async\async(function () use ($code, $since, $limit, $params) {
            Async\await($this->load_markets());
            $request = array( );
            $currency = null;
            if ($code !== null) {
                $currency = $this->currency($code);
                $request['balance_token'] = $currency['id'];
            }
            if ($since !== null) {
                $request['start_t'] = $since;
            }
            if ($limit !== null) {
                $request['pageSize'] = $limit;
            }
            $transactionType = $this->safe_string($params, 'type');
            $params = $this->omit($params, 'type');
            if ($transactionType !== null) {
                $request['type'] = $transactionType;
            }
            $response = Async\await($this->v1PrivateGetAssetHistory (array_merge($request, $params)));
            // {
            //     "rows" => array(
            //       {
            //         "id" => "22010508193900165",
            //         "token" => "TRON_USDT",
            //         "extra" => '',
            //         "amount" => "13.75848500",
            //         "status" => "COMPLETED",
            //         "account" => null,
            //         "description" => null,
            //         "user_id" => "42222",
            //         "application_id" => "6ad2b303-f354-45c0-8105-9f5f19d0e335",
            //         "external_id" => "220105081900134",
            //         "target_address" => "TXnyFSnAYad3YCaqtwMw9jvXKkeU39NLnK",
            //         "source_address" => "TYDzsYUEpvnYmQk4zGP9sWWcTEd2MiAtW6",
            //         "type" => "BALANCE",
            //         "token_side" => "DEPOSIT",
            //         "tx_id" => "35b0004022f6b3ad07f39a0b7af199f6b258c2c3e2c7cdc93c67efa74fd625ee",
            //         "fee_token" => '',
            //         "fee_amount" => "0.00000000",
            //         "created_time" => "1641370779.442",
            //         "updated_time" => "1641370779.465",
            //         "is_new_target_address" => null,
            //         "confirmed_number" => "29",
            //         "confirming_threshold" => "27",
            //         "audit_tag" => "1",
            //         "audit_result" => "0",
            //         "balance_token" => null, // TODO -write to support, that this seems broken. here should be the token id
            //         "network_name" => null // TODO -write to support, that this seems broken. here should be the network id
            //       }
            //     ),
            //     "meta" => array( total => '1', records_per_page => "25", current_page => "1" ),
            //     "success" => true
            // }
            return array( $currency, $this->safe_value($response, 'rows', array()) );
        }) ();
    }

    public function fetch_ledger(?string $code = null, ?int $since = null, ?int $limit = null, $params = array ()) {
        return Async\async(function () use ($code, $since, $limit, $params) {
            /**
             * fetch the history of changes, actions done by the user or operations that altered balance of the user
             * @param {string} $code unified $currency $code, default is null
             * @param {int} [$since] timestamp in ms of the earliest ledger entry, default is null
             * @param {int} [$limit] max number of ledger entrys to return, default is null
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} a ~@link https://docs.ccxt.com/#/?id=ledger-structure ledger structure~
             */
            list($currency, $rows) = Async\await($this->get_asset_history_rows($code, $since, $limit, $params));
            return $this->parse_ledger($rows, $currency, $since, $limit, $params);
        }) ();
    }

    public function parse_ledger_entry($item, ?array $currency = null) {
        $networkizedCode = $this->safe_string($item, 'token');
        $currencyDefined = $this->get_currency_from_chaincode($networkizedCode, $currency);
        $code = $currencyDefined['code'];
        $amount = $this->safe_number($item, 'amount');
        $side = $this->safe_string($item, 'token_side');
        $direction = ($side === 'DEPOSIT') ? 'in' : 'out';
        $timestamp = $this->safe_timestamp($item, 'created_time');
        $fee = $this->parse_token_and_fee_temp($item, 'fee_token', 'fee_amount');
        return array(
            'id' => $this->safe_string($item, 'id'),
            'currency' => $code,
            'account' => $this->safe_string($item, 'account'),
            'referenceAccount' => null,
            'referenceId' => $this->safe_string($item, 'tx_id'),
            'status' => $this->parse_transaction_status($this->safe_string($item, 'status')),
            'amount' => $amount,
            'before' => null,
            'after' => null,
            'fee' => $fee,
            'direction' => $direction,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'type' => $this->parse_ledger_entry_type($this->safe_string($item, 'type')),
            'info' => $item,
        );
    }

    public function parse_ledger_entry_type($type) {
        $types = array(
            'BALANCE' => 'transaction', // Funds moved in/out wallet
            'COLLATERAL' => 'transfer', // Funds moved between portfolios
        );
        return $this->safe_string($types, $type, $type);
    }

    public function get_currency_from_chaincode($networkizedCode, $currency) {
        if ($currency !== null) {
            return $currency;
        } else {
            $parts = explode('_', $networkizedCode);
            $partsLength = count($parts);
            $firstPart = $this->safe_string($parts, 0);
            $currencyId = $this->safe_string($parts, 1, $firstPart);
            if ($partsLength > 2) {
                $currencyId .= '_' . $this->safe_string($parts, 2);
            }
            $currency = $this->safe_currency($currencyId);
        }
        return $currency;
    }

    public function fetch_deposits(?string $code = null, ?int $since = null, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($code, $since, $limit, $params) {
            /**
             * fetch all deposits made to an account
             * @param {string} $code unified currency $code
             * @param {int} [$since] the earliest time in ms to fetch deposits for
             * @param {int} [$limit] the maximum number of deposits structures to retrieve
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array[]} a list of ~@link https://docs.ccxt.com/#/?id=transaction-structure transaction structures~
             */
            $request = array(
                'token_side' => 'DEPOSIT',
            );
            return Async\await($this->fetch_deposits_withdrawals($code, $since, $limit, array_merge($request, $params)));
        }) ();
    }

    public function fetch_withdrawals(?string $code = null, ?int $since = null, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($code, $since, $limit, $params) {
            /**
             * fetch all withdrawals made from an account
             * @param {string} $code unified currency $code
             * @param {int} [$since] the earliest time in ms to fetch withdrawals for
             * @param {int} [$limit] the maximum number of withdrawals structures to retrieve
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array[]} a list of ~@link https://docs.ccxt.com/#/?id=transaction-structure transaction structures~
             */
            $request = array(
                'token_side' => 'WITHDRAW',
            );
            return Async\await($this->fetch_deposits_withdrawals($code, $since, $limit, array_merge($request, $params)));
        }) ();
    }

    public function fetch_deposits_withdrawals(?string $code = null, ?int $since = null, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($code, $since, $limit, $params) {
            /**
             * fetch history of deposits and withdrawals
             * @param {string} [$code] unified $currency $code for the $currency of the deposit/withdrawals, default is null
             * @param {int} [$since] timestamp in ms of the earliest deposit/withdrawal, default is null
             * @param {int} [$limit] max number of deposit/withdrawals to return, default is null
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} a list of ~@link https://docs.ccxt.com/#/?id=transaction-structure transaction structure~
             */
            $request = array(
                'type' => 'BALANCE',
            );
            list($currency, $rows) = Async\await($this->get_asset_history_rows($code, $since, $limit, array_merge($request, $params)));
            //
            //     {
            //         "rows":array(),
            //         "meta":array(
            //             "total":0,
            //             "records_per_page":25,
            //             "current_page":1
            //         ),
            //         "success":true
            //     }
            //
            return $this->parse_transactions($rows, $currency, $since, $limit, $params);
        }) ();
    }

    public function parse_transaction($transaction, ?array $currency = null): array {
        // example in fetchLedger
        $networkizedCode = $this->safe_string($transaction, 'token');
        $currencyDefined = $this->get_currency_from_chaincode($networkizedCode, $currency);
        $code = $currencyDefined['code'];
        $movementDirection = $this->safe_string_lower($transaction, 'token_side');
        if ($movementDirection === 'withdraw') {
            $movementDirection = 'withdrawal';
        }
        $fee = $this->parse_token_and_fee_temp($transaction, 'fee_token', 'fee_amount');
        $addressTo = $this->safe_string($transaction, 'target_address');
        $addressFrom = $this->safe_string($transaction, 'source_address');
        $timestamp = $this->safe_timestamp($transaction, 'created_time');
        return array(
            'info' => $transaction,
            'id' => $this->safe_string_2($transaction, 'id', 'withdraw_id'),
            'txid' => $this->safe_string($transaction, 'tx_id'),
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'address' => null,
            'addressFrom' => $addressFrom,
            'addressTo' => $addressTo,
            'tag' => $this->safe_string($transaction, 'extra'),
            'tagFrom' => null,
            'tagTo' => null,
            'type' => $movementDirection,
            'amount' => $this->safe_number($transaction, 'amount'),
            'currency' => $code,
            'status' => $this->parse_transaction_status($this->safe_string($transaction, 'status')),
            'updated' => $this->safe_timestamp($transaction, 'updated_time'),
            'comment' => null,
            'internal' => null,
            'fee' => $fee,
            'network' => null,
        );
    }

    public function parse_transaction_status($status) {
        $statuses = array(
            'NEW' => 'pending',
            'CONFIRMING' => 'pending',
            'PROCESSING' => 'pending',
            'COMPLETED' => 'ok',
            'CANCELED' => 'canceled',
        );
        return $this->safe_string($statuses, $status, $status);
    }

    public function transfer(string $code, $amount, $fromAccount, $toAccount, $params = array ()) {
        return Async\async(function () use ($code, $amount, $fromAccount, $toAccount, $params) {
            /**
             * $transfer $currency internally between wallets on the same account
             * @param {string} $code unified $currency $code
             * @param {float} $amount amount to $transfer
             * @param {string} $fromAccount account to $transfer from
             * @param {string} $toAccount account to $transfer to
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} a ~@link https://docs.ccxt.com/#/?id=$transfer-structure $transfer structure~
             */
            Async\await($this->load_markets());
            $currency = $this->currency($code);
            $request = array(
                'token' => $currency['id'],
                'amount' => $this->parse_number($amount),
                'from_application_id' => $fromAccount,
                'to_application_id' => $toAccount,
            );
            $response = Async\await($this->v1PrivatePostAssetMainSubTransfer (array_merge($request, $params)));
            //
            //     {
            //         "success" => true,
            //         "id" => 200
            //     }
            //
            $transfer = $this->parse_transfer($response, $currency);
            $transferOptions = $this->safe_value($this->options, 'transfer', array());
            $fillResponseFromRequest = $this->safe_value($transferOptions, 'fillResponseFromRequest', true);
            if ($fillResponseFromRequest) {
                $transfer['amount'] = $amount;
                $transfer['fromAccount'] = $fromAccount;
                $transfer['toAccount'] = $toAccount;
            }
            return $transfer;
        }) ();
    }

    public function fetch_transfers(?string $code = null, ?int $since = null, ?int $limit = null, $params = array ()) {
        return Async\async(function () use ($code, $since, $limit, $params) {
            /**
             * fetch a history of internal transfers made on an account
             * @param {string} $code unified $currency $code of the $currency transferred
             * @param {int} [$since] the earliest time in ms to fetch transfers for
             * @param {int} [$limit] the maximum number of  transfers structures to retrieve
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array[]} a list of ~@link https://docs.ccxt.com/#/?id=transfer-structure transfer structures~
             */
            $request = array(
                'type' => 'COLLATERAL',
            );
            list($currency, $rows) = Async\await($this->get_asset_history_rows($code, $since, $limit, array_merge($request, $params)));
            return $this->parse_transfers($rows, $currency, $since, $limit, $params);
        }) ();
    }

    public function parse_transfer($transfer, ?array $currency = null) {
        //
        //    getAssetHistoryRows
        //        {
        //            "created_time" => "1579399877.041",  // Unix epoch time in seconds
        //            "updated_time" => "1579399877.041",  // Unix epoch time in seconds
        //            "id" => "202029292829292",
        //            "external_id" => "202029292829292",
        //            "application_id" => null,
        //            "token" => "ETH",
        //            "target_address" => "0x31d64B3230f8baDD91dE1710A65DF536aF8f7cDa",
        //            "source_address" => "0x70fd25717f769c7f9a46b319f0f9103c0d887af0",
        //            "extra" => "",
        //            "type" => "BALANCE",
        //            "token_side" => "DEPOSIT",
        //            "amount" => 1000,
        //            "tx_id" => "0x8a74c517bc104c8ebad0c3c3f64b1f302ed5f8bca598ae4459c63419038106b6",
        //            "fee_token" => null,
        //            "fee_amount" => null,
        //            "status" => "CONFIRMING"
        //        }
        //
        //    v1PrivatePostAssetMainSubTransfer
        //        {
        //            "success" => true,
        //            "id" => 200
        //        }
        //
        $networkizedCode = $this->safe_string($transfer, 'token');
        $currencyDefined = $this->get_currency_from_chaincode($networkizedCode, $currency);
        $code = $currencyDefined['code'];
        $movementDirection = $this->safe_string_lower($transfer, 'token_side');
        if ($movementDirection === 'withdraw') {
            $movementDirection = 'withdrawal';
        }
        $fromAccount = null;
        $toAccount = null;
        if ($movementDirection === 'withdraw') {
            $fromAccount = null;
            $toAccount = 'spot';
        } elseif ($movementDirection === 'deposit') {
            $fromAccount = 'spot';
            $toAccount = null;
        }
        $timestamp = $this->safe_timestamp($transfer, 'created_time');
        $success = $this->safe_value($transfer, 'success');
        $status = null;
        if ($success !== null) {
            $status = $success ? 'ok' : 'failed';
        }
        return array(
            'id' => $this->safe_string($transfer, 'id'),
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'currency' => $code,
            'amount' => $this->safe_number($transfer, 'amount'),
            'fromAccount' => $fromAccount,
            'toAccount' => $toAccount,
            'status' => $this->parse_transfer_status($this->safe_string($transfer, 'status', $status)),
            'info' => $transfer,
        );
    }

    public function parse_transfer_status($status) {
        $statuses = array(
            'NEW' => 'pending',
            'CONFIRMING' => 'pending',
            'PROCESSING' => 'pending',
            'COMPLETED' => 'ok',
            'CANCELED' => 'canceled',
        );
        return $this->safe_string($statuses, $status, $status);
    }

    public function withdraw(string $code, $amount, $address, $tag = null, $params = array ()) {
        return Async\async(function () use ($code, $amount, $address, $tag, $params) {
            /**
             * make a withdrawal
             * @param {string} $code unified $currency $code
             * @param {float} $amount the $amount to withdraw
             * @param {string} $address the $address to withdraw to
             * @param {string} $tag
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} a ~@link https://docs.ccxt.com/#/?id=transaction-structure transaction structure~
             */
            list($tag, $params) = $this->handle_withdraw_tag_and_params($tag, $params);
            Async\await($this->load_markets());
            $this->check_address($address);
            $currency = $this->currency($code);
            $request = array(
                'amount' => $amount,
                'address' => $address,
            );
            if ($tag !== null) {
                $request['extra'] = $tag;
            }
            $networks = $this->safe_value($this->options, 'networks', array());
            $currencyNetworks = $this->safe_value($currency, 'networks', array());
            $network = $this->safe_string_upper($params, 'network');
            $networkId = $this->safe_string($networks, $network, $network);
            $coinNetwork = $this->safe_value($currencyNetworks, $networkId, array());
            $coinNetworkId = $this->safe_string($coinNetwork, 'id');
            if ($coinNetworkId === null) {
                throw new BadRequest($this->id . ' withdraw() require $network parameter');
            }
            $request['token'] = $coinNetworkId;
            $response = Async\await($this->v1PrivatePostAssetWithdraw (array_merge($request, $params)));
            //
            //     {
            //         "success" => true,
            //         "withdraw_id" => "20200119145703654"
            //     }
            //
            return $this->parse_transaction($response, $currency);
        }) ();
    }

    public function repay_margin(string $code, $amount, ?string $symbol = null, $params = array ()) {
        return Async\async(function () use ($code, $amount, $symbol, $params) {
            /**
             * repay borrowed margin and interest
             * @see https://docs.woo.org/#repay-interest
             * @param {string} $code unified $currency $code of the $currency to repay
             * @param {float} $amount the $amount to repay
             * @param {string} $symbol not used by woo.repayMargin ()
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} a ~@link https://docs.ccxt.com/#/?id=margin-loan-structure margin loan structure~
             */
            Async\await($this->load_markets());
            $market = null;
            if ($symbol !== null) {
                $market = $this->market($symbol);
                $symbol = $market['symbol'];
            }
            $currency = $this->currency($code);
            $request = array(
                'token' => $currency['id'], // interest token that you want to repay
                'amount' => $this->currency_to_precision($code, $amount),
            );
            $response = Async\await($this->v1PrivatePostInterestRepay (array_merge($request, $params)));
            //
            //     {
            //         "success" => true,
            //     }
            //
            $transaction = $this->parse_margin_loan($response, $currency);
            return array_merge($transaction, array(
                'amount' => $amount,
                'symbol' => $symbol,
            ));
        }) ();
    }

    public function parse_margin_loan($info, ?array $currency = null) {
        //
        //     {
        //         "success" => true,
        //     }
        //
        return array(
            'id' => null,
            'currency' => $this->safe_currency_code(null, $currency),
            'amount' => null,
            'symbol' => null,
            'timestamp' => null,
            'datetime' => null,
            'info' => $info,
        );
    }

    public function nonce() {
        return $this->milliseconds();
    }

    public function sign($path, $section = 'public', $method = 'GET', $params = array (), $headers = null, $body = null) {
        $version = $section[0];
        $access = $section[1];
        $pathWithParams = $this->implode_params($path, $params);
        $url = $this->implode_hostname($this->urls['api'][$access]);
        $url .= '/' . $version . '/';
        $params = $this->omit($params, $this->extract_params($path));
        $params = $this->keysort($params);
        if ($access === 'public') {
            $url .= $access . '/' . $pathWithParams;
            if ($params) {
                $url .= '?' . $this->urlencode($params);
            }
        } else {
            $this->check_required_credentials();
            if ($method === 'POST' && ($path === 'algo/order' || $path === 'order')) {
                $isSandboxMode = $this->safe_value($this->options, 'sandboxMode', false);
                if (!$isSandboxMode) {
                    $applicationId = 'bc830de7-50f3-460b-9ee0-f430f83f9dad';
                    $brokerId = $this->safe_string($this->options, 'brokerId', $applicationId);
                    $isStop = mb_strpos($path, 'algo') > -1;
                    if ($isStop) {
                        $params['brokerId'] = $brokerId;
                    } else {
                        $params['broker_id'] = $brokerId;
                    }
                }
                $params = $this->keysort($params);
            }
            $auth = '';
            $ts = (string) $this->nonce();
            $url .= $pathWithParams;
            $headers = array(
                'x-api-key' => $this->apiKey,
                'x-api-timestamp' => $ts,
            );
            if ($version === 'v3') {
                $auth = $ts . $method . '/' . $version . '/' . $pathWithParams;
                if ($method === 'POST' || $method === 'PUT' || $method === 'DELETE') {
                    $body = $this->json($params);
                    $auth .= $body;
                } else {
                    if ($params) {
                        $query = $this->urlencode($params);
                        $url .= '?' . $query;
                        $auth .= '?' . $query;
                    }
                }
                $headers['content-type'] = 'application/json';
            } else {
                $auth = $this->urlencode($params);
                if ($method === 'POST' || $method === 'PUT' || $method === 'DELETE') {
                    $body = $auth;
                } else {
                    $url .= '?' . $auth;
                }
                $auth .= '|' . $ts;
                $headers['content-type'] = 'application/x-www-form-urlencoded';
            }
            $headers['x-api-signature'] = $this->hmac($this->encode($auth), $this->encode($this->secret), 'sha256');
        }
        return array( 'url' => $url, 'method' => $method, 'body' => $body, 'headers' => $headers );
    }

    public function handle_errors($httpCode, $reason, $url, $method, $headers, $body, $response, $requestHeaders, $requestBody) {
        if (!$response) {
            return null; // fallback to default error handler
        }
        //
        //     400 Bad Request array("success":false,"code":-1012,"message":"Amount is required for buy market orders when margin disabled.")
        //
        $success = $this->safe_value($response, 'success');
        $errorCode = $this->safe_string($response, 'code');
        if (!$success) {
            $feedback = $this->id . ' ' . $this->json($response);
            $this->throw_broadly_matched_exception($this->exceptions['broad'], $body, $feedback);
            $this->throw_exactly_matched_exception($this->exceptions['exact'], $errorCode, $feedback);
        }
        return null;
    }

    public function parse_income($income, ?array $market = null) {
        //
        //     {
        //         "id":666666,
        //         "symbol":"PERP_BTC_USDT",
        //         "funding_rate":0.00001198,
        //         "mark_price":28941.04000000,
        //         "funding_fee":0.00069343,
        //         "payment_type":"Pay",
        //         "status":"COMPLETED",
        //         "created_time":"1653616000.666",
        //         "updated_time":"1653616000.605"
        //     }
        //
        $marketId = $this->safe_string($income, 'symbol');
        $symbol = $this->safe_symbol($marketId, $market);
        $amount = $this->safe_number($income, 'funding_fee');
        $code = $this->safe_currency_code('USD');
        $id = $this->safe_string($income, 'id');
        $timestamp = $this->safe_timestamp($income, 'updated_time');
        $rate = $this->safe_number($income, 'funding_rate');
        return array(
            'info' => $income,
            'symbol' => $symbol,
            'code' => $code,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'id' => $id,
            'amount' => $amount,
            'rate' => $rate,
        );
    }

    public function fetch_funding_history(?string $symbol = null, ?int $since = null, ?int $limit = null, $params = array ()) {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            Async\await($this->load_markets());
            $request = array();
            $market = null;
            if ($symbol !== null) {
                $market = $this->market($symbol);
                $request['symbol'] = $market['id'];
            }
            if ($since !== null) {
                $request['start_t'] = $since;
            }
            $response = Async\await($this->v1PrivateGetFundingFeeHistory (array_merge($request, $params)));
            //
            //     {
            //         "rows":array(
            //             {
            //                 "id":666666,
            //                 "symbol":"PERP_BTC_USDT",
            //                 "funding_rate":0.00001198,
            //                 "mark_price":28941.04000000,
            //                 "funding_fee":0.00069343,
            //                 "payment_type":"Pay",
            //                 "status":"COMPLETED",
            //                 "created_time":"1653616000.666",
            //                 "updated_time":"1653616000.605"
            //             }
            //         ),
            //         "meta":array(
            //             "total":235,
            //             "records_per_page":25,
            //             "current_page":1
            //         ),
            //         "success":true
            //     }
            //
            $result = $this->safe_value($response, 'rows', array());
            return $this->parse_incomes($result, $market, $since, $limit);
        }) ();
    }

    public function parse_funding_rate($fundingRate, ?array $market = null) {
        //
        //         {
        //             "symbol":"PERP_AAVE_USDT",
        //             "est_funding_rate":-0.00003447,
        //             "est_funding_rate_timestamp":1653633959001,
        //             "last_funding_rate":-0.00002094,
        //             "last_funding_rate_timestamp":1653631200000,
        //             "next_funding_time":1653634800000
        //         }
        //
        //
        $symbol = $this->safe_string($fundingRate, 'symbol');
        $market = $this->market($symbol);
        $nextFundingTimestamp = $this->safe_integer($fundingRate, 'next_funding_time');
        $estFundingRateTimestamp = $this->safe_integer($fundingRate, 'est_funding_rate_timestamp');
        $lastFundingRateTimestamp = $this->safe_integer($fundingRate, 'last_funding_rate_timestamp');
        return array(
            'info' => $fundingRate,
            'symbol' => $market['symbol'],
            'markPrice' => null,
            'indexPrice' => null,
            'interestRate' => $this->parse_number('0'),
            'estimatedSettlePrice' => null,
            'timestamp' => $estFundingRateTimestamp,
            'datetime' => $this->iso8601($estFundingRateTimestamp),
            'fundingRate' => $this->safe_number($fundingRate, 'est_funding_rate'),
            'fundingTimestamp' => $nextFundingTimestamp,
            'fundingDatetime' => $this->iso8601($nextFundingTimestamp),
            'nextFundingRate' => null,
            'nextFundingTimestamp' => null,
            'nextFundingDatetime' => null,
            'previousFundingRate' => $this->safe_number($fundingRate, 'last_funding_rate'),
            'previousFundingTimestamp' => $lastFundingRateTimestamp,
            'previousFundingDatetime' => $this->iso8601($lastFundingRateTimestamp),
        );
    }

    public function fetch_funding_rate(string $symbol, $params = array ()) {
        return Async\async(function () use ($symbol, $params) {
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $request = array(
                'symbol' => $market['id'],
            );
            $response = Async\await($this->v1PublicGetFundingRateSymbol (array_merge($request, $params)));
            //
            //     {
            //         "success":true,
            //         "timestamp":1653640572711,
            //         "symbol":"PERP_BTC_USDT",
            //         "est_funding_rate":0.00000738,
            //         "est_funding_rate_timestamp":1653640559003,
            //         "last_funding_rate":0.00000629,
            //         "last_funding_rate_timestamp":1653638400000,
            //         "next_funding_time":1653642000000
            //     }
            //
            return $this->parse_funding_rate($response, $market);
        }) ();
    }

    public function fetch_funding_rates(?array $symbols = null, $params = array ()) {
        return Async\async(function () use ($symbols, $params) {
            Async\await($this->load_markets());
            $symbols = $this->market_symbols($symbols);
            $response = Async\await($this->v1PublicGetFundingRates ($params));
            //
            //     {
            //         "success":true,
            //         "rows":array(
            //             {
            //                 "symbol":"PERP_AAVE_USDT",
            //                 "est_funding_rate":-0.00003447,
            //                 "est_funding_rate_timestamp":1653633959001,
            //                 "last_funding_rate":-0.00002094,
            //                 "last_funding_rate_timestamp":1653631200000,
            //                 "next_funding_time":1653634800000
            //             }
            //         ),
            //         "timestamp":1653633985646
            //     }
            //
            $rows = $this->safe_value($response, 'rows', array());
            $result = $this->parse_funding_rates($rows);
            return $this->filter_by_array($result, 'symbol', $symbols);
        }) ();
    }

    public function fetch_funding_rate_history(?string $symbol = null, ?int $since = null, ?int $limit = null, $params = array ()) {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            /**
             * fetches historical funding rate prices
             * @see https://docs.woo.org/#get-funding-rate-history-for-one-$market-public
             * @param {string} $symbol unified $symbol of the $market to fetch the funding rate history for
             * @param {int} [$since] $timestamp in ms of the earliest funding rate to fetch
             * @param {int} [$limit] the maximum amount of ~@link https://docs.ccxt.com/#/?id=funding-rate-history-structure funding rate structures~ to fetch
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @param {int} [$params->until] $timestamp in ms of the latest funding rate
             * @param {boolean} [$params->paginate] default false, when true will automatically $paginate by calling this endpoint multiple times. See in the docs all the [availble parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-$params)
             * @return {array[]} a list of ~@link https://docs.ccxt.com/#/?id=funding-rate-history-structure funding rate structures~
             */
            Async\await($this->load_markets());
            $paginate = false;
            list($paginate, $params) = $this->handle_option_and_params($params, 'fetchFundingRateHistory', 'paginate');
            if ($paginate) {
                return Async\await($this->fetch_paginated_call_incremental('fetchFundingRateHistory', $symbol, $since, $limit, $params, 'page', 25));
            }
            $request = array();
            if ($symbol !== null) {
                $market = $this->market($symbol);
                $symbol = $market['symbol'];
                $request['symbol'] = $market['id'];
            }
            if ($since !== null) {
                $request['start_t'] = $this->parse_to_int($since / 1000);
            }
            list($request, $params) = $this->handle_until_option('end_t', $request, $params, 0.001);
            $response = Async\await($this->v1PublicGetFundingRateHistory (array_merge($request, $params)));
            //
            //     {
            //         "success":true,
            //         "meta":array(
            //             "total":2464,
            //             "records_per_page":25,
            //             "current_page":1
            //         ),
            //         "rows":array(
            //             {
            //                 "symbol":"PERP_BTC_USDT",
            //                 "funding_rate":0.00000629,
            //                 "funding_rate_timestamp":1653638400000,
            //                 "next_funding_time":1653642000000
            //             }
            //         ),
            //         "timestamp":1653640814885
            //     }
            //
            $result = $this->safe_value($response, 'rows');
            $rates = array();
            for ($i = 0; $i < count($result); $i++) {
                $entry = $result[$i];
                $marketId = $this->safe_string($entry, 'symbol');
                $timestamp = $this->safe_integer($entry, 'funding_rate_timestamp');
                $rates[] = array(
                    'info' => $entry,
                    'symbol' => $this->safe_symbol($marketId),
                    'fundingRate' => $this->safe_number($entry, 'funding_rate'),
                    'timestamp' => $timestamp,
                    'datetime' => $this->iso8601($timestamp),
                );
            }
            $sorted = $this->sort_by($rates, 'timestamp');
            return $this->filter_by_symbol_since_limit($sorted, $symbol, $since, $limit);
        }) ();
    }

    public function fetch_leverage(string $symbol, $params = array ()) {
        return Async\async(function () use ($symbol, $params) {
            Async\await($this->load_markets());
            $response = Async\await($this->v3PrivateGetAccountinfo ($params));
            //
            //     {
            //         "success" => true,
            //         "data" => array(
            //             "applicationId" => "dsa",
            //             "account" => "dsa",
            //             "alias" => "haha",
            //             "accountMode" => "MARGIN",
            //             "leverage" => 1,
            //             "takerFeeRate" => 1,
            //             "makerFeeRate" => 1,
            //             "interestRate" => 1,
            //             "futuresTakerFeeRate" => 1,
            //             "futuresMakerFeeRate" => 1,
            //             "otpauth" => true,
            //             "marginRatio" => 1,
            //             "openMarginRatio" => 1,
            //             "initialMarginRatio" => 1,
            //             "maintenanceMarginRatio" => 1,
            //             "totalCollateral" => 1,
            //             "freeCollateral" => 1,
            //             "totalAccountValue" => 1,
            //             "totalVaultValue" => 1,
            //             "totalStakingValue" => 1
            //         ),
            //         "timestamp" => 1673323685109
            //     }
            //
            $result = $this->safe_value($response, 'data');
            $leverage = $this->safe_number($result, 'leverage');
            return array(
                'info' => $response,
                'leverage' => $leverage,
            );
        }) ();
    }

    public function set_leverage($leverage, ?string $symbol = null, $params = array ()) {
        return Async\async(function () use ($leverage, $symbol, $params) {
            Async\await($this->load_markets());
            if (($leverage < 1) || ($leverage > 20)) {
                throw new BadRequest($this->id . ' $leverage should be between 1 and 20');
            }
            $request = array(
                'leverage' => $leverage,
            );
            return Async\await($this->v1PrivatePostClientLeverage (array_merge($request, $params)));
        }) ();
    }

    public function fetch_position(?string $symbol = null, $params = array ()) {
        return Async\async(function () use ($symbol, $params) {
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $request = array(
                'symbol' => $market['id'],
            );
            $response = Async\await($this->v1PrivateGetPositionSymbol (array_merge($request, $params)));
            //
            //     {
            //         "symbol":"PERP_ETC_USDT",
            //         "holding":0.0,
            //         "pnl_24_h":0,
            //         "settle_price":0.0,
            //         "average_open_price":0,
            //         "success":true,
            //         "mark_price":22.6955,
            //         "pending_short_qty":0.0,
            //         "pending_long_qty":0.0,
            //         "fee_24_h":0,
            //         "timestamp":"1652231044.920"
            //     }
            //
            return $this->parse_position($response, $market);
        }) ();
    }

    public function fetch_positions(?array $symbols = null, $params = array ()) {
        return Async\async(function () use ($symbols, $params) {
            Async\await($this->load_markets());
            $response = Async\await($this->v3PrivateGetPositions ($params));
            //
            //     {
            //         "success" => true,
            //         "data" => {
            //             "positions" => array(
            //                 array(
            //                     "symbol" => "0_symbol",
            //                     "holding" => 1,
            //                     "pendingLongQty" => 0,
            //                     "pendingShortQty" => 1,
            //                     "settlePrice" => 1,
            //                     "averageOpenPrice" => 1,
            //                     "pnl24H" => 1,
            //                     "fee24H" => 1,
            //                     "markPrice" => 1,
            //                     "estLiqPrice" => 1,
            //                     "timestamp" => 12321321
            //                 }
            //             )
            //         ),
            //         "timestamp" => 1673323880342
            //     }
            //
            $result = $this->safe_value($response, 'data', array());
            $positions = $this->safe_value($result, 'positions', array());
            return $this->parse_positions($positions, $symbols);
        }) ();
    }

    public function parse_position($position, ?array $market = null) {
        //
        //     {
        //         "symbol" => "0_symbol",
        //         "holding" => 1,
        //         "pendingLongQty" => 0,
        //         "pendingShortQty" => 1,
        //         "settlePrice" => 1,
        //         "averageOpenPrice" => 1,
        //         "pnl24H" => 1,
        //         "fee24H" => 1,
        //         "markPrice" => 1,
        //         "estLiqPrice" => 1,
        //         "timestamp" => 12321321
        //     }
        //
        $contract = $this->safe_string($position, 'symbol');
        $market = $this->safe_market($contract, $market);
        $size = $this->safe_string($position, 'holding');
        $side = null;
        if (Precise::string_gt($size, '0')) {
            $side = 'long';
        } else {
            $side = 'short';
        }
        $contractSize = $this->safe_string($market, 'contractSize');
        $markPrice = $this->safe_string($position, 'markPrice');
        $timestamp = $this->safe_timestamp($position, 'timestamp');
        $entryPrice = $this->safe_string($position, 'averageOpenPrice');
        $priceDifference = Precise::string_sub($markPrice, $entryPrice);
        $unrealisedPnl = Precise::string_mul($priceDifference, $size);
        $size = Precise::string_abs($size);
        $notional = Precise::string_mul($size, $markPrice);
        return $this->safe_position(array(
            'info' => $position,
            'id' => null,
            'symbol' => $this->safe_string($market, 'symbol'),
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'lastUpdateTimestamp' => null,
            'initialMargin' => null,
            'initialMarginPercentage' => null,
            'maintenanceMargin' => null,
            'maintenanceMarginPercentage' => null,
            'entryPrice' => $this->parse_number($entryPrice),
            'notional' => $this->parse_number($notional),
            'leverage' => null,
            'unrealizedPnl' => $this->parse_number($unrealisedPnl),
            'contracts' => $this->parse_number($size),
            'contractSize' => $this->parse_number($contractSize),
            'marginRatio' => null,
            'liquidationPrice' => $this->safe_number($position, 'estLiqPrice'),
            'markPrice' => $this->parse_number($markPrice),
            'lastPrice' => null,
            'collateral' => null,
            'marginMode' => 'cross',
            'marginType' => null,
            'side' => $side,
            'percentage' => null,
            'hedged' => null,
            'stopLossPrice' => null,
            'takeProfitPrice' => null,
        ));
    }

    public function default_network_code_for_currency($code) {
        $currencyItem = $this->currency($code);
        $networks = $currencyItem['networks'];
        $networkKeys = is_array($networks) ? array_keys($networks) : array();
        for ($i = 0; $i < count($networkKeys); $i++) {
            $network = $networkKeys[$i];
            if ($network === 'ETH') {
                return $network;
            }
        }
        // if it was not returned according to above options, then return the first $network of currency
        return $this->safe_value($networkKeys, 0);
    }

    public function set_sandbox_mode($enable) {
        parent::set_sandbox_mode($enable);
        $this->options['sandboxMode'] = $enable;
    }
}
