<?php

namespace ccxt\pro;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

use Exception; // a common import
use ccxt\ExchangeError;
use \React\Async;
use \React\Promise\PromiseInterface;

class arkham extends \ccxt\async\arkham {

    public function describe(): mixed {
        return $this->deep_extend(parent::describe(), array(
            'has' => array(
                'ws' => true,
                'watchTrades' => true,
                'watchTradesForSymbols' => false,
                'watchOrderBook' => true,
                'watchOrderBookForSymbols' => false,
                'watchOHLCV' => true,
                'watchOHLCVForSymbols' => false,
                'watchOrders' => true,
                'watchMyTrades' => false,
                'watchTicker' => true,
                'watchTickers' => false,
                'watchBalance' => true,
            ),
            'urls' => array(
                'api' => array(
                    'ws' => 'wss://arkm.com/ws',
                ),
            ),
            'options' => array(
                'watchOrderBook' => array(
                    'depth' => 100, // 5, 10, 20, 50, 100
                    'interval' => 500, // 100, 200, 500, 1000
                ),
            ),
            'streaming' => array(
                'keepAlive' => 300000, // 5 minutes
            ),
        ));
    }

    public function handle_message(Client $client, $message) {
        //
        // confirmation
        //
        //     array($channel => 'confirmations', confirmationId => 'myCustomId-123')
        if ($this->handle_error_message($client, $message)) {
            return;
        }
        $methods = array(
            'ticker' => array($this, 'handle_ticker'),
            'candles' => array($this, 'handle_ohlcv'),
            'l2_updates' => array($this, 'handle_order_book'),
            'trades' => array($this, 'handle_trades'),
            'balances' => array($this, 'handle_balance'),
            'positions' => array($this, 'handle_positions'),
            'order_statuses' => array($this, 'handle_order'),
            'trigger_orders' => array($this, 'handle_order'),
            // 'confirmations' => array($this, 'handle_ticker'),
        );
        $channel = $this->safe_string($message, 'channel');
        if ($channel === 'confirmations') {
            return;
        }
        // $type = $this->safe_string($message, 'type');
        // if ($type !== 'update' && $type !== 'snapshot') {
        //     debugger;
        // }
        $method = $this->safe_value($methods, $channel);
        if ($method !== null) {
            $method($client, $message);
        }
    }

    public function subscribe(string $messageHash, string $rawChannel, array $params): PromiseInterface {
        return Async\async(function () use ($messageHash, $rawChannel, $params) {
            $subscriptionHash = $messageHash;
            $request = array(
                'args' => array(
                    'channel' => $rawChannel,
                    'params' => $params,
                ),
                'confirmationId' => $this->uuid(),
                'method' => 'subscribe',
            );
            return Async\await($this->watch($this->urls['api']['ws'], $messageHash, $request, $subscriptionHash));
        }) ();
    }

    public function watch_ticker(string $symbol, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $params) {
            /**
             * watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific $market
             *
             * @see https://arkm.com/docs#stream/ticker
             *
             * @param {string} $symbol unified $symbol of the $market to fetch the ticker for
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} a ~@link https://docs.ccxt.com/?id=ticker-structure ticker structure~
             */
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $requestArg = array(
                'symbol' => $market['id'],
            );
            $messageHash = 'ticker::' . $market['symbol'];
            return Async\await($this->subscribe($messageHash, 'ticker', $this->extend($params, $requestArg)));
        }) ();
    }

    public function handle_ticker(Client $client, $message) {
        //
        // {
        //   channel => 'ticker',
        //   type => 'update',
        //   $data => {
        //     $symbol => 'BTC_USDT',
        //     baseSymbol => 'BTC',
        //     quoteSymbol => 'USDT',
        //     price => '118962.74',
        //     price24hAgo => '118780.42',
        //     high24h => '120327.96',
        //     low24h => '118217.28',
        //     volume24h => '32.89729',
        //     quoteVolume24h => '3924438.7146048',
        //     markPrice => '0',
        //     indexPrice => '118963.080293502',
        //     fundingRate => '0',
        //     nextFundingRate => '0',
        //     nextFundingTime => 0,
        //     productType => 'spot',
        //     openInterest => '0',
        //     indexCurrency => 'USDT',
        //     usdVolume24h => '3924438.7146048',
        //     openInterestUSD => '0'
        //   }
        // }
        //
        $data = $this->safe_dict($message, 'data', array());
        $marketId = $this->safe_string($data, 'symbol');
        $market = $this->safe_market($marketId, null);
        $symbol = $market['symbol'];
        $ticker = $this->parse_ws_ticker($data, $market);
        $this->tickers[$symbol] = $ticker;
        $client->resolve ($ticker, 'ticker::' . $symbol);
        // if ($this->safe_string($message, 'dataType') === 'all@ticker') {
        //     $client->resolve ($ticker, $this->getMessageHash ('ticker'));
        // }
    }

    public function parse_ws_ticker($message, $market = null) {
        // same dict api
        return $this->parse_ticker($message, $market);
    }

    public function watch_ohlcv(string $symbol, $timeframe = '1m', ?int $since = null, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $timeframe, $since, $limit, $params) {
            /**
             * watches historical candlestick data containing the open, high, low, and close price, and the volume of a $market
             *
             * @see https://arkm.com/docs#stream/candles
             *
             * @param {string} $symbol unified $symbol of the $market to fetch OHLCV data for
             * @param {string} $timeframe the length of time each candle represents
             * @param {int} [$since] timestamp in ms of the earliest candle to fetch
             * @param {int} [$limit] the maximum amount of candles to fetch
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {int[][]} A list of candles ordered, open, high, low, close, volume
             */
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $rawTimeframe = $this->safe_string($this->timeframes, $timeframe, $timeframe);
            $requestArg = array(
                'symbol' => $market['id'],
                'duration' => $rawTimeframe,
            );
            $messageHash = 'ohlcv::' . $market['symbol'] . '::' . $rawTimeframe;
            $result = Async\await($this->subscribe($messageHash, 'candles', $this->extend($requestArg, $params)));
            $ohlcv = $result;
            if ($this->newUpdates) {
                $limit = $ohlcv->getLimit ($market['symbol'], $limit);
            }
            return $this->filter_by_since_limit($ohlcv, $since, $limit, 0, true);
        }) ();
    }

    public function handle_ohlcv(Client $client, $message) {
        //
        // {
        //   channel => 'candles',
        //   type => 'update',
        //   $data => {
        //     $symbol => 'BTC_USDT',
        //     time => '1755076380000000',
        //     $duration => 60000000,
        //     open => '120073.01',
        //     high => '120073.01',
        //     low => '120073.01',
        //     close => '120073.01',
        //     volume => '0',
        //     quoteVolume => '0'
        //   }
        // }
        //
        $data = $this->safe_dict($message, 'data', array());
        $marketId = $this->safe_string($data, 'symbol');
        $market = $this->safe_market($marketId, null);
        $symbol = $market['symbol'];
        $duration = $this->safe_integer($data, 'duration');
        $timeframe = $this->findTimeframeByDuration ($duration);
        $messageHash = 'ohlcv::' . $symbol . '::' . $timeframe;
        $this->ohlcvs[$symbol] = $this->safe_value($this->ohlcvs, $symbol, array());
        if (!(is_array($this->ohlcvs[$symbol]) && array_key_exists($timeframe, $this->ohlcvs[$symbol]))) {
            $limit = $this->handle_option('watchOHLCV', 'limit', 1000);
            $this->ohlcvs[$symbol][$timeframe] = new ArrayCacheByTimestamp ($limit);
        }
        $stored = $this->ohlcvs[$symbol][$timeframe];
        $parsed = $this->parse_ws_ohlcv($data, $market);
        $stored->append ($parsed);
        $client->resolve ($stored, $messageHash);
        return $message;
    }

    public function parse_ws_ohlcv($ohlcv, $market = null): array {
        // same api
        return $this->parse_ohlcv($ohlcv, $market);
    }

    public function watch_order_book(string $symbol, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $limit, $params) {
            /**
             * watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
             *
             * @see https://arkm.com/docs#stream/l2_updates
             *
             * @param {string} $symbol unified $symbol of the $market to fetch the order book for
             * @param {int} [$limit] the maximum amount of order book entries to return
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} A dictionary of ~@link https://docs.ccxt.com/?id=order-book-structure order book structures~ indexed by $market symbols
             */
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $requestArg = array(
                'symbol' => $market['id'],
                'snapshot' => true,
            );
            $messageHash = 'orderBook::' . $market['symbol'];
            $orderbook = Async\await($this->subscribe($messageHash, 'l2_updates', $this->extend($requestArg, $params)));
            return $orderbook->limit ();
        }) ();
    }

    public function handle_order_book(Client $client, $message) {
        //
        // snapshot:
        //
        // {
        //     channel => 'l2_updates',
        //     $type => 'snapshot',
        //     $data => {
        //         $symbol => 'BTC_USDT',
        //         group => '0.01',
        //         asks => [  [Object], [Object], ... ],
        //         bids => [  [Object], [Object], ... ],
        //         lastTime => 1755115180608299
        //     }
        // }
        //
        // update:
        //
        // {
        //   channel => "l2_updates",
        //   $type => "update",
        //   $data => {
        //     $symbol => "BTC_USDT",
        //     group => "0.01",
        //     $side => "sell",
        //     size => "0.05295",
        //     price => "122722.76",
        //     revisionId => 2455511217,
        //     time => 1755115736475207,
        //   }
        // }
        //
        $data = $this->safe_dict($message, 'data');
        $type = $this->safe_string($message, 'type');
        $marketId = $this->safe_string($data, 'symbol');
        $market = $this->safe_market($marketId);
        $symbol = $market['symbol'];
        $messageHash = 'orderBook::' . $symbol;
        if (!(is_array($this->orderbooks) && array_key_exists($symbol, $this->orderbooks))) {
            $ob = $this->order_book(array());
            $ob['symbol'] = $symbol;
            $this->orderbooks[$symbol] = $ob;
        }
        $orderbook = $this->orderbooks[$symbol];
        if ($type === 'snapshot') {
            $timestamp = $this->safe_integer_product($data, 'lastTime', 0.001);
            $parsedOrderBook = $this->parse_order_book($data, $symbol, $timestamp, 'bids', 'asks', 'price', 'size');
            $orderbook->reset ($parsedOrderBook);
        } elseif ($type === 'update') {
            $timestamp = $this->safe_integer_product($data, 'time', 0.001);
            $side = $this->safe_string($data, 'side');
            $bookside = ($side === 'buy') ? $orderbook['bids'] : $orderbook['asks'];
            $this->handle_delta($bookside, $data);
            $orderbook['timestamp'] = $timestamp;
            $orderbook['datetime'] = $this->iso8601($timestamp);
        }
        $this->orderbooks[$symbol] = $orderbook;
        $client->resolve ($this->orderbooks[$symbol], $messageHash);
    }

    public function handle_delta($bookside, $delta) {
        $bidAsk = $this->parse_bid_ask($delta, 'price', 'size');
        $bookside->storeArray ($bidAsk);
    }

    public function watch_trades(string $symbol, ?int $since = null, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            /**
             * watches information on multiple $trades made in a $market
             *
             * @see https://arkm.com/docs#stream/trades
             *
             * @param {string} $symbol unified $market $symbol of the $market $trades were made in
             * @param {int} [$since] the earliest time in ms to fetch orders for
             * @param {int} [$limit] the maximum number of trade structures to retrieve
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array[]} a list of ~@link https://docs.ccxt.com/?id=trade-structure trade structures~
             */
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $requestArg = array(
                'symbol' => $market['id'],
            );
            $messageHash = 'trade::' . $market['symbol'];
            $trades = Async\await($this->subscribe($messageHash, 'trades', $this->extend($requestArg, $params)));
            if ($this->newUpdates) {
                $limit = $trades->getLimit ($market['symbol'], $limit);
            }
            return $this->filter_by_since_limit($trades, $since, $limit, 'timestamp', true);
        }) ();
    }

    public function handle_trades(Client $client, $message) {
        //
        // {
        //     channel => 'trades',
        //     type => 'update',
        //     $data => {
        //         $symbol => 'BTC_USDT',
        //         revisionId => 2643896903,
        //         size => '0.00261',
        //         price => '118273.2',
        //         takerSide => 'buy',
        //         time => 1755200320146389
        //     }
        // }
        //
        $data = $this->safe_dict($message, 'data');
        $marketId = $this->safe_string($data, 'symbol');
        $symbol = $this->safe_symbol($marketId);
        if (!(is_array($this->trades) && array_key_exists($symbol, $this->trades))) {
            $limit = $this->safe_integer($this->options, 'tradesLimit', 1000);
            $this->trades[$symbol] = new ArrayCache ($limit);
        }
        $parsed = $this->parse_ws_trade($data);
        $stored = $this->trades[$symbol];
        $stored->append ($parsed);
        $client->resolve ($stored, 'trade::' . $symbol);
    }

    public function parse_ws_trade($trade, $market = null) {
        // same api
        return $this->parse_trade($trade, $market);
    }

    public function authenticate($params = array ()) {
        $this->check_required_credentials();
        $expires = ($this->milliseconds() . $this->safe_integer($this->options, 'requestExpiration', 5000)) * 1000; // need macroseconds
        $wsOptions = $this->safe_dict($this->options, 'ws', array());
        $authenticated = $this->safe_string($wsOptions, 'token');
        if ($authenticated === null) {
            $method = 'GET';
            $bodyStr = '';
            $path = 'ws';
            $payload = $this->apiKey . (string) $expires . strtoupper($method) . '/' . $path . $bodyStr;
            $decodedSecret = base64_decode($this->secret);
            $signature = $this->hmac($this->encode($payload), $decodedSecret, 'sha256', 'base64');
            $defaultOptions = array(
                'ws' => array(
                    'options' => array(
                        'headers' => array(
                            'Content-Type' => 'application/json',
                            'Accept' => 'application/json',
                            'Arkham-Api-Key' => $this->apiKey,
                            'Arkham-Expires' => (string) $expires,
                            'Arkham-Signature' => $signature,
                        ),
                    ),
                ),
            );
            $this->extend_exchange_options($defaultOptions);
            $this->client($this->urls['api']['ws']);
        }
    }

    public function watch_balance($params = array ()): PromiseInterface {
        return Async\async(function () use ($params) {
            /**
             * watch balance and get the amount of funds available for trading or funds locked in orders
             *
             * @see https://arkm.com/docs#stream/balances
             *
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @param {str} [$params->type] spot or contract if not provided $this->options['defaultType'] is used
             * @return {array} a ~@link https://docs.ccxt.com/?id=balance-structure balance structure~
             */
            Async\await($this->authenticate());
            Async\await($this->load_markets());
            $requestArg = array(
                'snapshot' => true,
            );
            $messageHash = 'balances';
            $result = Async\await($this->subscribe($messageHash, 'balances', $this->extend($requestArg, $params)));
            return $result;
        }) ();
    }

    public function handle_balance(Client $client, $message) {
        //
        // snapshot:
        //
        //     {
        //         channel => 'balances',
        //         $type => 'snapshot',
        //         $data => array(
        //           array(
        //             subaccountId => 0,
        //             symbol => 'USDT',
        //             balance => '7.035335375',
        //             free => '7.035335375',
        //             priceUSDT => '1',
        //             balanceUSDT => '7.035335375',
        //             freeUSDT => '7.035335375',
        //             lastUpdateReason => 'withdrawalFee',
        //             lastUpdateTime => '1753905990432678',
        //             lastUpdateId => 250483404,
        //             lastUpdateAmount => '-2'
        //           ),
        //           {
        //             subaccountId => 0,
        //             symbol => 'SOL',
        //             balance => '0.03',
        //             free => '0.03',
        //             priceUSDT => '197.37823276',
        //             balanceUSDT => '5.921346982',
        //             freeUSDT => '5.921346982',
        //             lastUpdateReason => 'orderFill',
        //             lastUpdateTime => '1753777760560164',
        //             lastUpdateId => 248588190,
        //             lastUpdateAmount => '0.03'
        //           }
        //         )
        //     }
        //
        // update:
        //
        //     {
        //         channel => 'balances',
        //         $type => 'update',
        //         $data => {
        //             subaccountId => 0,
        //             symbol => 'USDT',
        //             balance => '7.028357615',
        //             free => '7.028357615',
        //             priceUSDT => '1',
        //             balanceUSDT => '7.028357615',
        //             freeUSDT => '7.028357615',
        //             lastUpdateReason => 'tradingFee',
        //             lastUpdateTime => '1755240882544056',
        //             lastUpdateId => 2697860787,
        //             lastUpdateAmount => '-0.00697776'
        //         }
        //     }
        //
        $type = $this->safe_string($message, 'type');
        $parsed = array();
        if ($type === 'snapshot') {
            // response same api
            $data = $this->safe_list($message, 'data');
            $parsed = $this->parse_ws_balance($data);
            $parsed['info'] = $message;
            $this->balance = $parsed;
        } else {
            $data = $this->safe_dict($message, 'data');
            $balancesArray = array( $data );
            $parsed = $this->parse_ws_balance($balancesArray);
            $currencyId = $this->safe_string($data, 'symbol');
            $code = $this->safe_currency_code($currencyId);
            $this->balance[$code] = $parsed[$code];
        }
        $messageHash = 'balances';
        $client->resolve ($this->safe_balance($this->balance), $messageHash);
    }

    public function parse_ws_balance($balance) {
        // same api
        return $this->parse_balance($balance);
    }

    public function watch_positions(?array $symbols = null, ?int $since = null, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbols, $since, $limit, $params) {
            /**
             *
             * @see https://arkm.com/docs#stream/positions
             *
             * watch all open positions
             * @param {string[]} [$symbols] list of unified market $symbols
             * @param {int} [$since] the earliest time in ms to fetch positions for
             * @param {int} [$limit] the maximum number of positions to retrieve
             * @param {array} $params extra parameters specific to the exchange API endpoint
             * @return {array[]} a list of {@link https://docs.ccxt.com/en/latest/manual.html#position-structure position structure}
             */
            Async\await($this->authenticate());
            Async\await($this->load_markets());
            $messageHash = 'positions';
            if (!$this->is_empty($symbols)) {
                $symbols = $this->market_symbols($symbols);
                $messageHash .= '::' . implode(',', $symbols);
            }
            $this->positions = new ArrayCacheBySymbolBySide ();
            $requestArg = array(
                'snapshot' => false, // no need for initial snapshot, it's done in REST api
            );
            $newPositions = Async\await($this->subscribe($messageHash, 'positions', $this->extend($requestArg, $params)));
            if ($this->newUpdates) {
                return $newPositions;
            }
            return $this->filter_by_symbols_since_limit($this->positions, $symbols, $since, $limit, true);
        }) ();
    }

    public function handle_positions($client, $message) {
        //
        // snapshot:
        //
        //     {
        //         channel => 'positions',
        //         $type => 'snapshot',
        //         $data => array(
        //           {
        //             subaccountId => 0,
        //             $symbol => 'SOL_USDT_PERP',
        //             base => '0.059',
        //             quote => '-11.50618',
        //             openBuySize => '0',
        //             openSellSize => '0',
        //             openBuyNotional => '0',
        //             openSellNotional => '0',
        //             lastUpdateReason => 'orderFill',
        //             lastUpdateTime => '1755251065621402',
        //             lastUpdateId => 2709589783,
        //             lastUpdateBaseDelta => '0.059',
        //             lastUpdateQuoteDelta => '-11.50618',
        //             breakEvenPrice => '195.02',
        //             markPrice => '195',
        //             value => '11.505',
        //             pnl => '-0.00118',
        //             initialMargin => '1.1505',
        //             maintenanceMargin => '0.6903',
        //             averageEntryPrice => '195.02'
        //           }
        //         )
        //     }
        //
        $newPositions = array();
        if ($this->positions === null) {
            $this->positions = array();
        }
        $type = $this->safe_string($message, 'type');
        if ($type === 'snapshot') {
            $data = $this->safe_list($message, 'data', array());
            for ($i = 0; $i < count($data); $i++) {
                $position = $this->parse_ws_position($data[$i]);
                if ($this->safe_integer($position, 'entryPrice') !== 0) {
                    $newPositions[] = $position;
                    $symbol = $this->safe_string($position, 'symbol');
                    $this->positions[$symbol] = $position;
                }
            }
        } else {
            $data = $this->safe_dict($message, 'data');
            $position = $this->parse_ws_position($data);
            $symbol = $this->safe_string($position, 'symbol');
            $this->positions[$symbol] = $position;
            $newPositions[] = $position;
        }
        $messageHashes = $this->find_message_hashes($client, 'positions::');
        for ($i = 0; $i < count($messageHashes); $i++) {
            $messageHash = $messageHashes[$i];
            $parts = explode('::', $messageHash);
            $symbolsString = $parts[1];
            $symbols = explode(',', $symbolsString);
            $positions = $this->filter_by_array($newPositions, 'symbol', $symbols, false);
            if (!$this->is_empty($positions)) {
                $client->resolve ($positions, $messageHash);
            }
        }
        $length = count($newPositions);
        if ($length > 0) {
            $client->resolve ($newPositions, 'positions');
        }
    }

    public function parse_ws_positions(array $positions, ?array $symbols = null, $params = array ()): array {
        $symbols = $this->market_symbols($symbols);
        $positions = $this->to_array($positions);
        $result = array();
        for ($i = 0; $i < count($positions); $i++) {
            $position = $this->extend($this->parse_ws_position($positions[$i], null), $params);
            $result[] = $position;
        }
        return $this->filter_by_array_positions($result, 'symbol', $symbols, false);
    }

    public function parse_ws_position($position, $market = null) {
        // same api
        return $this->parse_position($position, $market);
    }

    public function watch_orders(?string $symbol = null, ?int $since = null, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            /**
             * watches information on multiple $orders made by the user
             *
             * @see https://arkm.com/docs#stream/order_statuses
             *
             * @param {string} $symbol unified $market $symbol of the $market $orders were made in
             * @param {int} [$since] the earliest time in ms to fetch $orders for
             * @param {int} [$limit] the maximum number of order structures to retrieve
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array[]} a list of ~@link https://docs.ccxt.com/?id=order-structure order structures~
             */
            Async\await($this->authenticate());
            Async\await($this->load_markets());
            $market = null;
            if ($symbol !== null) {
                $market = $this->market($symbol);
            }
            $requestArg = array(
                'snapshot' => false,
            );
            $isTriggerOrder = false;
            list($isTriggerOrder, $params) = $this->handle_option_and_params($params, 'watchOrders', 'trigger', false);
            $rawChannel = $isTriggerOrder ? 'trigger_orders' : 'order_statuses';
            $messageHash = 'orders';
            if ($symbol !== null) {
                $messageHash .= '::' . $market['symbol'];
            }
            $messageHash .= '::' . $rawChannel;
            $orders = Async\await($this->subscribe($messageHash, $rawChannel, $this->extend($requestArg, $params)));
            if ($this->newUpdates) {
                $limit = $orders->getLimit ($symbol, $limit);
            }
            return $this->filter_by_symbol_since_limit($orders, $symbol, $since, $limit, true);
        }) ();
    }

    public function handle_order(Client $client, $message) {
        //
        //     {
        //         $channel => "order_statuses",
        //         type => "update",
        //         $data => {
        //             orderId => 4200775347657,
        //             userId => 2959880,
        //             subaccountId => 0,
        //             symbol => "ARKM_USDT_PERP",
        //             time => "1755253639782186",
        //             side => "buy",
        //             type => "limitGtc",
        //             size => "10",
        //             price => "0.5",
        //             postOnly => false,
        //             reduceOnly => false,
        //             executedSize => "0",
        //             status => "cancelled",
        //             avgPrice => "0",
        //             executedNotional => "0",
        //             creditFeePaid => "0",
        //             marginBonusFeePaid => "0",
        //             quoteFeePaid => "0",
        //             arkmFeePaid => "0",
        //             revisionId => 2752963990,
        //             lastTime => "1755272026403545",
        //             clientOrderId => "",
        //             lastSize => "0",
        //             lastPrice => "0",
        //             lastCreditFee => "0",
        //             lastMarginBonusFee => "0",
        //             lastQuoteFee => "0",
        //             lastArkmFee => "0",
        //         }
        //     }
        //
        $channel = $this->safe_string($message, 'channel');
        $data = $this->safe_dict($message, 'data');
        if ($this->orders === null) {
            $limit = $this->safe_integer($this->options, 'ordersLimit', 1000);
            $this->orders = new ArrayCacheBySymbolById ($limit);
        }
        $orders = $this->orders;
        $order = $this->parse_ws_order($data);
        $orders->append ($order);
        $client->resolve ($orders, 'orders');
        $client->resolve ($orders, 'orders::' . $order['symbol'] . '::' . $channel);
        $client->resolve ($orders, 'orders::' . $channel);
    }

    public function parse_ws_order($order, $market = null): array {
        // same api
        return $this->parse_order($order, $market);
    }

    public function handle_error_message(Client $client, $response): Bool {
        //
        // error example:
        //
        //    {
        //        "id" => "30005",
        //        "name" => "InvalidNotional",
        //        "message" => "order validation failed => invalid notional => notional 0.25 is less than min notional 1"
        //    }
        //
        $message = $this->safe_string($response, 'message');
        if ($message !== null) {
            $body = $this->json($response);
            $errorCode = $this->safe_string($response, 'id');
            $feedback = $this->id . ' ' . $body;
            $this->throw_exactly_matched_exception($this->exceptions['exact'], $errorCode, $feedback);
            $this->throw_exactly_matched_exception($this->exceptions['exact'], $message, $feedback);
            $this->throw_broadly_matched_exception($this->exceptions['broad'], $message, $feedback);
            throw new ExchangeError($this->id . ' ' . $body);
        }
        return false;
    }
}
