<?php

namespace ccxt\pro;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

use Exception; // a common import
use ccxt\ExchangeError;
use ccxt\AuthenticationError;
use ccxt\BadRequest;
use React\Async;

class bybit extends \ccxt\async\bybit {

    use ClientTrait;

    public function describe() {
        return $this->deep_extend(parent::describe(), array(
            'has' => array(
                'ws' => true,
                'watchBalance' => true,
                'watchMyTrades' => true,
                'watchOHLCV' => true,
                'watchOrderBook' => true,
                'watchOrders' => true,
                'watchTicker' => true,
                'watchTickers' => false, // for now
                'watchTrades' => true,
                'watchPosition' => null,
            ),
            'urls' => array(
                'api' => array(
                    'ws' => array(
                        'public' => array(
                            'spot' => 'wss://stream.{hostname}/spot/public/v3',
                            'inverse' => 'wss://stream.{hostname}/contract/inverse/public/v3',
                            'usdt' => 'wss://stream.{hostname}/contract/usdt/public/v3',
                            'usdc' => array(
                                'option' => 'wss://stream.{hostname}/option/usdc/public/v3',
                                'swap' => 'wss://stream.{hostname}/contract/usdc/public/v3',
                            ),
                        ),
                        'private' => array(
                            'spot' => 'wss://stream.{hostname}/spot/private/v3',
                            'contract' => array(
                                'unified' => 'wss://stream.{hostname}/unified/private/v3',
                                'nonUnified' => 'wss://stream.{hostname}/contract/private/v3',
                            ),
                        ),
                    ),
                ),
                'test' => array(
                    'ws' => array(
                        'public' => array(
                            'spot' => 'wss://stream-testnet.{hostname}/spot/public/v3',
                            'inverse' => 'wss://stream-testnet.{hostname}/contract/inverse/public/v3',
                            'usdt' => 'wss://stream-testnet.{hostname}/contract/usdt/public/v3',
                            'usdc' => array(
                                'option' => 'wss://stream-testnet.{hostname}/option/usdc/public/v3',
                                'swap' => 'wss://stream-testnet.{hostname}/contract/usdc/public/v3',
                            ),
                        ),
                        'private' => array(
                            'spot' => 'wss://stream-testnet.{hostname}/spot/private/v3',
                            'contract' => array(
                                'unified' => 'wss://stream-testnet.{hostname}/unified/private/v3',
                                'nonUnified' => 'wss://stream-testnet.{hostname}/contract/private/v3',
                            ),
                        ),
                    ),
                ),
            ),
            'options' => array(
                'watchTicker' => array(
                    'name' => 'tickers', // 'tickers' for 24hr statistical ticker or 'bookticker' for Best bid price and best ask price
                ),
                'spot' => array(
                    'timeframes' => array(
                        '1m' => '1m',
                        '3m' => '3m',
                        '5m' => '5m',
                        '15m' => '15m',
                        '30m' => '30m',
                        '1h' => '1h',
                        '2h' => '2h',
                        '4h' => '4h',
                        '6h' => '6h',
                        '12h' => '12h',
                        '1d' => '1d',
                        '1w' => '1w',
                        '1M' => '1M',
                    ),
                ),
                'contract' => array(
                    'timeframes' => array(
                        '1m' => '1',
                        '3m' => '3',
                        '5m' => '5',
                        '15m' => '15',
                        '30m' => '30',
                        '1h' => '60',
                        '2h' => '120',
                        '4h' => '240',
                        '6h' => '360',
                        '12h' => '720',
                        '1d' => 'D',
                        '1w' => 'W',
                        '1M' => 'M',
                    ),
                ),
            ),
            'streaming' => array(
                'ping' => array($this, 'ping'),
                'keepAlive' => 20000,
            ),
            'exceptions' => array(
                'ws' => array(
                    'exact' => array(
                    ),
                ),
            ),
        ));
    }

    public function request_id() {
        $requestId = $this->sum($this->safe_integer($this->options, 'requestId', 0), 1);
        $this->options['requestId'] = $requestId;
        return $requestId;
    }

    public function get_url_by_market_type($symbol = null, $isPrivate = false, $isUnifiedMargin = false, $method = null, $params = array ()) {
        $accessibility = $isPrivate ? 'private' : 'public';
        $isUsdcSettled = null;
        $isSpot = null;
        $type = null;
        $isUsdtSettled = null;
        $market = null;
        $url = $this->urls['api']['ws'];
        if ($symbol !== null) {
            $market = $this->market($symbol);
            $isUsdcSettled = $market['settle'] === 'USDC';
            $isUsdtSettled = $market['settle'] === 'USDT';
            $isSpot = $market['spot'];
            $type = $market['type'];
        } else {
            list($type, $params) = $this->handle_market_type_and_params($method, null, $params);
            $defaultSettle = $this->safe_string($this->options, 'defaultSettle');
            $defaultSettle = $this->safe_string_2($params, 'settle', 'defaultSettle', $defaultSettle);
            $isUsdcSettled = ($defaultSettle === 'USDC');
            $isUsdtSettled = ($defaultSettle === 'USDT');
            $isSpot = ($type === 'spot');
        }
        if ($isPrivate) {
            if ($isSpot) {
                $url = $url[$accessibility]['spot'];
            } else {
                $margin = $isUnifiedMargin ? 'unified' : 'nonUnified';
                $url = $url[$accessibility]['contract'][$margin];
            }
        } else {
            if ($isSpot) {
                $url = $url[$accessibility]['spot'];
            } elseif ($isUsdcSettled) {
                $url = $url[$accessibility]['usdc'][$type];
            } elseif ($isUsdtSettled) {
                $url = $url[$accessibility]['usdt'];
            } else {
                // inverse
                $url = $url[$accessibility]['inverse'];
            }
        }
        $url = $this->implode_hostname($url);
        return $url;
    }

    public function clean_params($params) {
        $params = $this->omit($params, array( 'type', 'subType', 'settle', 'defaultSettle', 'unifiedMargin' ));
        return $params;
    }

    public function watch_ticker($symbol, $params = array ()) {
        return Async\async(function () use ($symbol, $params) {
            /**
             * watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific $market
             * @param {string} $symbol unified $symbol of the $market to fetch the ticker for
             * @param {array} $params extra parameters specific to the bybit api endpoint
             * @return {array} a {@link https://docs.ccxt.com/en/latest/manual.html#ticker-structure ticker structure}
             */
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $messageHash = 'ticker:' . $market['symbol'];
            $url = $this->get_url_by_market_type($symbol, false, false, $params);
            $params = $this->clean_params($params);
            $options = $this->safe_value($this->options, 'watchTicker', array());
            $topic = $this->safe_string($options, 'name', 'tickers');
            if (!$market['spot'] && $topic !== 'tickers') {
                throw new BadRequest($this->id . ' watchTicker() only supports name tickers for contract markets');
            }
            $topic .= '.' . $market['id'];
            $topics = array( $topic );
            return Async\await($this->watch_topics($url, $messageHash, $topics, $params));
        }) ();
    }

    public function handle_ticker($client, $message) {
        //
        //  spot - tickers
        //    {
        //        "data" => array(
        //            "t" => 1661742216005,
        //            "s" => "BTCUSDT",
        //            "o" => "19820",
        //            "h" => "20071.93",
        //            "l" => "19365.85",
        //            "c" => "19694.27",
        //            "v" => "9997.246174",
        //            "qv" => "197357775.97621786",
        //            "m" => "-0.0063"
        //        ),
        //        "type" => "delta",
        //        "topic" => "tickers.BTCUSDT",
        //        "ts" => 1661742216011
        //    }
        //  spot - bookticker
        //    {
        //        "data" => array(
        //            "s" => "BTCUSDT",
        //            "bp" => "19693.04",
        //            "bq" => "0.913957",
        //            "ap" => "19694.27",
        //            "aq" => "0.705447",
        //            "t" => 1661742216108
        //        ),
        //        "type" => "delta",
        //        "topic" => "bookticker.BTCUSDT",
        //        "ts" => 1661742216109
        //    }
        //  swap
        //    {
        //        "topic":"tickers.BTCUSDT",
        //        "type":"snapshot",
        //        "data":array(
        //            "symbol":"BTCUSDT",
        //            "tickDirection":"ZeroMinusTick",
        //            "price24hPcnt":"0.032786",
        //            "lastPrice":"22019.00",
        //            "prevPrice24h":"21320.00",
        //            "highPrice24h":"22522.00",
        //            "lowPrice24h":"20745.00",
        //            "prevPrice1h":"22186.50",
        //            "markPrice":"22010.11",
        //            "indexPrice":"22009.01",
        //            "openInterest":"44334.438",
        //            "turnover24h":"4609010554.786498",
        //            "volume24h":"213532.606",
        //            "fundingRate":"0.0001",
        //            "nextFundingTime":"2022-07-18T16:00:00Z",
        //            "bid1Price":"22019.00",
        //            "bid1Size":"41.530",
        //            "ask1Price":"22019.50",
        //            "ask1Size":"7.041",
        //            "basisRate":"0",
        //            "deliveryFeeRate":"0"
        //        ),
        //        "cs":14236992078,
        //        "ts":1663203915102
        //    }
        //
        $topic = $this->safe_string($message, 'topic', '');
        $updateType = $this->safe_string($message, 'type', '');
        $data = $this->safe_value($message, 'data', array());
        $isSpot = $this->safe_string($data, 's') !== null;
        $symbol = null;
        $parsed = null;
        if (($updateType === 'snapshot') || $isSpot) {
            $parsed = $this->parse_ticker($data);
            $symbol = $parsed['symbol'];
        } elseif ($updateType === 'delta') {
            $topicParts = explode('.', $topic);
            $topicLength = count($topicParts);
            $marketId = $this->safe_string($topicParts, $topicLength - 1);
            $market = $this->market($marketId);
            $symbol = $market['symbol'];
            // update the info in place
            $ticker = $this->safe_value($this->tickers, $symbol, array());
            $rawTicker = $this->safe_value($ticker, 'info', array());
            $merged = array_merge($rawTicker, $data);
            $parsed = $this->parse_ticker($merged);
        }
        $timestamp = $this->safe_integer($message, 'ts');
        $parsed['timestamp'] = $timestamp;
        $parsed['datetime'] = $this->iso8601($timestamp);
        $this->tickers[$symbol] = $parsed;
        $messageHash = 'ticker:' . $symbol;
        $client->resolve ($this->tickers[$symbol], $messageHash);
    }

    public function watch_ohlcv($symbol, $timeframe = '1m', $since = null, $limit = null, $params = array ()) {
        return Async\async(function () use ($symbol, $timeframe, $since, $limit, $params) {
            /**
             * watches historical candlestick data containing the open, high, low, and close price, and the volume of a $market
             * @param {string} $symbol unified $symbol of the $market to fetch OHLCV data for
             * @param {string} $timeframe the length of time each candle represents
             * @param {int|null} $since timestamp in ms of the earliest candle to fetch
             * @param {int|null} $limit the maximum amount of candles to fetch
             * @param {array} $params extra parameters specific to the bybit api endpoint
             * @return {[[int]]} A list of candles ordered as timestamp, open, high, low, close, volume
             */
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $symbol = $market['symbol'];
            $url = $this->get_url_by_market_type($symbol, false, false, $params);
            $params = $this->clean_params($params);
            $ohlcv = null;
            $marketType = $market['spot'] ? 'spot' : 'contract';
            $marketOptions = $this->safe_value($this->options, $marketType, array());
            $timeframes = $this->safe_value($marketOptions, 'timeframes', array());
            $timeframeId = $this->safe_string($timeframes, $timeframe, $timeframe);
            $topics = [ 'kline.' . $timeframeId . '.' . $market['id'] ];
            $messageHash = 'kline' . ':' . $timeframeId . ':' . $symbol;
            $ohlcv = Async\await($this->watch_topics($url, $messageHash, $topics, $params));
            if ($this->newUpdates) {
                $limit = $ohlcv->getLimit ($symbol, $limit);
            }
            return $this->filter_by_since_limit($ohlcv, $since, $limit, 0, true);
        }) ();
    }

    public function handle_ohlcv($client, $message) {
        //
        // swap
        //    {
        //        "topic":"kline.1.BTCUSDT",
        //        "data":array(
        //          {
        //            "start":1658150220000,
        //            "end":1658150279999,
        //            "interval":"1",
        //            "open":"22212",
        //            "close":"22214",
        //            "high":"22214.5",
        //            "low":"22212",
        //            "volume":"5.456",
        //            "turnover":"121193.36",
        //            "confirm":false,
        //            "timestamp":1658150224542
        //          }
        //        ),
        //        "ts":1658150224542,
        //        "type":"snapshot"
        //    }
        //
        // spot
        //    {
        //        "data" => array(
        //            "t" => 1661742000000,
        //            "s" => "BTCUSDT",
        //            "c" => "19685.55",
        //            "h" => "19756.95",
        //            "l" => "19674.61",
        //            "o" => "19705.38",
        //            "v" => "0.232154"
        //        ),
        //        "type" => "delta",
        //        "topic" => "kline.1h.BTCUSDT",
        //        "ts" => 1661745259605
        //    }
        //
        $data = $this->safe_value($message, 'data', array());
        $topic = $this->safe_string($message, 'topic');
        $topicParts = explode('.', $topic);
        $topicLength = count($topicParts);
        $timeframeId = $this->safe_string($topicParts, 1);
        $marketId = $this->safe_string($topicParts, $topicLength - 1);
        $isSpot = mb_strpos($client->url, 'spot') > -1;
        $marketType = $isSpot ? 'spot' : 'contract';
        $market = $this->safe_market($marketId, null, null, $marketType);
        $symbol = $market['symbol'];
        $ohlcvsByTimeframe = $this->safe_value($this->ohlcvs, $symbol);
        if ($ohlcvsByTimeframe === null) {
            $this->ohlcvs[$symbol] = array();
        }
        $stored = $this->safe_value($ohlcvsByTimeframe, $timeframeId);
        if ($stored === null) {
            $limit = $this->safe_integer($this->options, 'OHLCVLimit', 1000);
            $stored = new ArrayCacheByTimestamp ($limit);
            $this->ohlcvs[$symbol][$timeframeId] = $stored;
        }
        if (gettype($data) === 'array' && array_keys($data) === array_keys(array_keys($data))) {
            for ($i = 0; $i < count($data); $i++) {
                $parsed = $this->parse_ws_contract_ohlcv($data[$i]);
                $stored->append ($parsed);
            }
        } else {
            $parsed = $this->parseSpotOHLCV ($data);
            $stored->append ($parsed);
        }
        $messageHash = 'kline' . ':' . $timeframeId . ':' . $symbol;
        $client->resolve ($stored, $messageHash);
    }

    public function parse_ws_contract_ohlcv($ohlcv) {
        //
        //     {
        //         "start" => 1670363160000,
        //         "end" => 1670363219999,
        //         "interval" => "1",
        //         "open" => "16987.5",
        //         "close" => "16987.5",
        //         "high" => "16988",
        //         "low" => "16987.5",
        //         "volume" => "23.511",
        //         "turnover" => "399396.344",
        //         "confirm" => false,
        //         "timestamp" => 1670363219614
        //     }
        //
        return array(
            $this->safe_integer($ohlcv, 'timestamp'),
            $this->safe_number($ohlcv, 'open'),
            $this->safe_number($ohlcv, 'high'),
            $this->safe_number($ohlcv, 'low'),
            $this->safe_number($ohlcv, 'close'),
            $this->safe_number_2($ohlcv, 'volume', 'turnover'),
        );
    }

    public function watch_order_book($symbol, $limit = null, $params = array ()) {
        return Async\async(function () use ($symbol, $limit, $params) {
            /**
             * watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
             * @param {string} $symbol unified $symbol of the $market to fetch the order book for
             * @param {int|null} $limit the maximum amount of order book entries to return.
             * @param {array} $params extra parameters specific to the bybit api endpoint
             * @return {array} A dictionary of {@link https://docs.ccxt.com/en/latest/manual.html#order-book-structure order book structures} indexed by $market symbols
             */
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $symbol = $market['symbol'];
            $url = $this->get_url_by_market_type($symbol, false, false, $params);
            $params = $this->clean_params($params);
            $messageHash = 'orderbook' . ':' . $symbol;
            if ($limit === null) {
                if ($market['spot']) {
                    $limit = 40;
                } else {
                    $limit = 200;
                }
            }
            $topics = [ 'orderbook.' . (string) $limit . '.' . $market['id'] ];
            $orderbook = Async\await($this->watch_topics($url, $messageHash, $topics, $params));
            return $orderbook->limit ();
        }) ();
    }

    public function handle_order_book($client, $message) {
        //
        // spot $snapshot
        //     {
        //         "data" => array(
        //             "s" => "BTCUSDT",
        //             "t" => 1661743689733,
        //             "b" => array(
        //                 array(
        //                     "19721.9",
        //                     "0.784806"
        //                 ),
        //                 ...
        //             ),
        //             "a" => array(
        //                 array(
        //                     "19721.91",
        //                     "0.192687"
        //                 ),
        //                 ...
        //             )
        //         ),
        //         "type" => "delta", // docs say to ignore, always $snapshot
        //         "topic" => "orderbook.40.BTCUSDT",
        //         "ts" => 1661743689735
        //     }
        //
        // contract
        //    {
        //        "topic" => "orderbook.50.BTCUSDT",
        //        "type" => "snapshot",
        //        "ts" => 1668748553479,
        //        "data" => {
        //            "s" => "BTCUSDT",
        //            "b" => array(
        //                array(
        //                    "17053.00", //price
        //                    "0.021" //size
        //                ),
        //                ....
        //            ),
        //            "a" => array(
        //                array(
        //                    "17054.00",
        //                    "6.288"
        //                ),
        //                ....
        //            ),
        //            "u" => 3083181,
        //            "seq" => 7545268447
        //        }
        //    }
        //
        $isSpot = mb_strpos($client->url, 'spot') !== false;
        $type = $this->safe_string($message, 'type');
        $isSnapshot = ($type === 'snapshot');
        if ($isSpot) {
            $isSnapshot = true;
        }
        $data = $this->safe_value($message, 'data', array());
        $marketId = $this->safe_string($data, 's');
        $marketType = $isSpot ? 'spot' : 'contract';
        $market = $this->safe_market($marketId, null, null, $marketType);
        $symbol = $market['symbol'];
        $timestamp = $this->safe_integer($message, 'ts');
        $orderbook = $this->safe_value($this->orderbooks, $symbol);
        if ($orderbook === null) {
            $orderbook = $this->order_book();
        }
        if ($isSnapshot) {
            $snapshot = $this->parse_order_book($data, $symbol, $timestamp, 'b', 'a');
            $orderbook->reset ($snapshot);
        } else {
            $asks = $this->safe_value($data, 'a', array());
            $bids = $this->safe_value($data, 'b', array());
            $this->handle_deltas($orderbook['asks'], $asks);
            $this->handle_deltas($orderbook['bids'], $bids);
            $orderbook['timestamp'] = $timestamp;
            $orderbook['datetime'] = $this->iso8601($timestamp);
        }
        $messageHash = 'orderbook' . ':' . $symbol;
        $this->orderbooks[$symbol] = $orderbook;
        $client->resolve ($orderbook, $messageHash);
    }

    public function handle_delta($bookside, $delta) {
        $bidAsk = $this->parse_bid_ask($delta, 0, 1);
        $bookside->storeArray ($bidAsk);
    }

    public function handle_deltas($bookside, $deltas) {
        for ($i = 0; $i < count($deltas); $i++) {
            $this->handle_delta($bookside, $deltas[$i]);
        }
    }

    public function watch_trades($symbol, $since = null, $limit = null, $params = array ()) {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            /**
             * watches information on multiple $trades made in a $market
             * @param {string} $symbol unified $market $symbol of the $market orders were made in
             * @param {int|null} $since the earliest time in ms to fetch orders for
             * @param {int|null} $limit the maximum number of  orde structures to retrieve
             * @param {array} $params extra parameters specific to the bybit api endpoint
             * @return {[array]} a list of [order structures]{@link https://docs.ccxt.com/en/latest/manual.html#order-structure
             */
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $symbol = $market['symbol'];
            $url = $this->get_url_by_market_type($symbol, false, false, $params);
            $params = $this->clean_params($params);
            $messageHash = 'trade:' . $symbol;
            $topic = null;
            if ($market['spot']) {
                $topic = 'trade.' . $market['id'];
            } else {
                $topic = 'publicTrade.';
                if ($market['option']) {
                    $topic .= $market['baseId'];
                } else {
                    $topic .= $market['id'];
                }
            }
            $trades = Async\await($this->watch_topics($url, $messageHash, array( $topic ), $params));
            if ($this->newUpdates) {
                $limit = $trades->getLimit ($symbol, $limit);
            }
            return $this->filter_by_since_limit($trades, $since, $limit, 'timestamp', true);
        }) ();
    }

    public function handle_trades($client, $message) {
        //
        // swap
        //    {
        //        "topic" => "publicTrade.BTCUSDT",
        //        "type" => "snapshot",
        //        "ts" => 1662694953823,
        //        "data" => array(
        //            {
        //                "T" => 1662694953819,
        //                "s" => "BTCUSDT",
        //                "S" => "Buy",
        //                "v" => "0.010",
        //                "p" => "19792.50",
        //                "L" => "PlusTick",
        //                "i" => "5c9ab13e-6010-522c-aecd-02c4d9c8db3d",
        //                "BT" => false
        //            }
        //        )
        //    }
        //
        // spot
        //    {
        //        "data" => array(
        //            "v" => "2100000000001992601",
        //            "t" => 1661742109857,
        //            "p" => "19706.87",
        //            "q" => "0.000158",
        //            "m" => true
        //        ),
        //        "type" => "delta",
        //        "topic" => "trade.BTCUSDT",
        //        "ts" => 1661742109863
        //    }
        //
        $data = $this->safe_value($message, 'data', array());
        $topic = $this->safe_string($message, 'topic');
        $trades = null;
        $parts = explode('.', $topic);
        $tradeType = $this->safe_string($parts, 0);
        $marketType = ($tradeType === 'trade') ? 'spot' : 'contract';
        $marketId = $this->safe_string($parts, 1);
        $market = $this->safe_market($marketId, null, null, $marketType);
        if (gettype($data) === 'array' && array_keys($data) === array_keys(array_keys($data))) {
            // contract markets
            $trades = $data;
        } else {
            // spot markets
            $trades = array( $data );
        }
        $symbol = $market['symbol'];
        $stored = $this->safe_value($this->trades, $symbol);
        if ($stored === null) {
            $limit = $this->safe_integer($this->options, 'tradesLimit', 1000);
            $stored = new ArrayCache ($limit);
            $this->trades[$symbol] = $stored;
        }
        for ($j = 0; $j < count($trades); $j++) {
            $parsed = $this->parse_ws_trade($trades[$j], $market);
            $stored->append ($parsed);
        }
        $messageHash = 'trade' . ':' . $symbol;
        $client->resolve ($stored, $messageHash);
    }

    public function parse_ws_trade($trade, $market = null) {
        //
        // contract public
        //    {
        //         T => 1670198879981,
        //         s => 'BTCUSDT',
        //         S => 'Buy',
        //         v => '0.001',
        //         p => '17130.00',
        //         L => 'ZeroPlusTick',
        //         i => 'a807f4ee-2e8b-5f21-a02a-3e258ddbfdc9',
        //         BT => false
        //     }
        // contract private
        //
        // parsed by rest implementation
        //    {
        //        "symbol" => "BITUSDT",
        //        "execFee" => "0.02022",
        //        "execId" => "beba036f-9fb4-59a7-84b7-2620e5d13e1c",
        //        "execPrice" => "0.674",
        //        "execQty" => "50",
        //        "execType" => "Trade",
        //        "execValue" => "33.7",
        //        "feeRate" => "0.0006",
        //        "lastLiquidityInd" => "RemovedLiquidity",
        //        "leavesQty" => "0",
        //        "orderId" => "ddbea432-2bd7-45dd-ab42-52d920b8136d",
        //        "orderLinkId" => "b001",
        //        "orderPrice" => "0.707",
        //        "orderQty" => "50",
        //        "orderType" => "Market",
        //        "stopOrderType" => "UNKNOWN",
        //        "side" => "Buy",
        //        "execTime" => "1659057535081",
        //        "closedSize" => "0"
        //    }
        //
        // spot public
        //
        //    {
        //      'symbol' => 'BTCUSDT', // artificially added
        //       v => '2290000000003002848', // $trade $id
        //       t => 1652967602261,
        //       p => '29698.82',
        //       q => '0.189531',
        //       $m => true
        //     }
        //
        // spot private
        //     {
        //         "e" => "ticketInfo",
        //         "E" => "1662348310386",
        //         "s" => "BTCUSDT",
        //         "q" => "0.001007",
        //         "t" => "1662348310373",
        //         "p" => "19842.02",
        //         "T" => "2100000000002220938",
        //         "o" => "1238261807653647872",
        //         "c" => "spotx008",
        //         "O" => "1238225004531834368",
        //         "a" => "533287",
        //         "A" => "642908",
        //         "m" => false,
        //         "S" => "BUY"
        //     }
        //
        $id = $this->safe_string_n($trade, array( 'i', 'T', 'v' ));
        $isContract = (is_array($trade) && array_key_exists('BT', $trade));
        $marketType = $isContract ? 'contract' : 'spot';
        $marketId = $this->safe_string($trade, 's');
        $market = $this->safe_market($marketId, $market, null, $marketType);
        $symbol = $market['symbol'];
        $timestamp = $this->safe_integer_2($trade, 't', 'T');
        $side = $this->safe_string_lower($trade, 'S');
        $takerOrMaker = null;
        $m = $this->safe_value($trade, 'm');
        if ($side === null) {
            $side = $m ? 'buy' : 'sell';
        } else {
            // spot private
            $takerOrMaker = $m;
        }
        $price = $this->safe_string($trade, 'p');
        $amount = $this->safe_string_2($trade, 'q', 'v');
        $orderId = $this->safe_string($trade, 'o');
        return $this->safe_trade(array(
            'id' => $id,
            'info' => $trade,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'symbol' => $symbol,
            'order' => $orderId,
            'type' => null,
            'side' => $side,
            'takerOrMaker' => $takerOrMaker,
            'price' => $price,
            'amount' => $amount,
            'cost' => null,
            'fee' => null,
        ), $market);
    }

    public function get_private_type($url) {
        if (mb_strpos($url, 'spot') !== false) {
            return 'spot';
        } elseif (mb_strpos($url, 'unified') !== false) {
            return 'unified';
        } elseif (mb_strpos($url, 'contract') !== false) {
            return 'contract';
        }
    }

    public function watch_my_trades($symbol = null, $since = null, $limit = null, $params = array ()) {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            /**
             * watches information on multiple $trades made by the user
             * @param {string} $symbol unified market $symbol of the market orders were made in
             * @param {int|null} $since the earliest time in ms to fetch orders for
             * @param {int|null} $limit the maximum number of  orde structures to retrieve
             * @param {array} $params extra parameters specific to the bybit api endpoint
             * @param {boolean} $params->unifiedMargin use unified margin account
             * @return {[array]} a list of [order structures]{@link https://docs.ccxt.com/en/latest/manual.html#order-structure
             */
            $method = 'watchMyTrades';
            $messageHash = 'myTrades';
            Async\await($this->load_markets());
            if ($symbol !== null) {
                $symbol = $this->symbol($symbol);
                $messageHash .= ':' . $symbol;
            }
            $isUnifiedMargin = Async\await($this->isUnifiedMarginEnabled ());
            $url = $this->get_url_by_market_type($symbol, true, $isUnifiedMargin, $method, $params);
            Async\await($this->authenticate($url));
            $topicByMarket = array(
                'spot' => 'ticketInfo',
                'contract' => 'user.execution.contractAccount',
                'unified' => 'user.execution.unifiedAccount',
            );
            $topic = $this->safe_value($topicByMarket, $this->get_private_type($url));
            $trades = Async\await($this->watch_topics($url, $messageHash, array( $topic ), $params));
            if ($this->newUpdates) {
                $limit = $trades->getLimit ($symbol, $limit);
            }
            return $this->filter_by_since_limit($trades, $since, $limit, 'timestamp', true);
        }) ();
    }

    public function handle_my_trades($client, $message) {
        //
        //    {
        //        "type" => "snapshot",
        //        "topic" => "ticketInfo",
        //        "ts" => "1662348310388",
        //        "data" => array(
        //            {
        //                "e" => "ticketInfo",
        //                "E" => "1662348310386",
        //                "s" => "BTCUSDT",
        //                "q" => "0.001007",
        //                "t" => "1662348310373",
        //                "p" => "19842.02",
        //                "T" => "2100000000002220938",
        //                "o" => "1238261807653647872",
        //                "c" => "spotx008",
        //                "O" => "1238225004531834368",
        //                "a" => "533287",
        //                "A" => "642908",
        //                "m" => false,
        //                "S" => "BUY"
        //            }
        //        )
        //    }
        // contract
        //     {
        //         $topic => 'user.execution.contractAccount',
        //         $data => array(
        //           {
        //             $symbol => 'BTCUSD',
        //             execFee => '0.00000004',
        //             execId => '7d0f66da-8312-52a9-959b-9fba58a90af0',
        //             execPrice => '17228.00',
        //             execQty => '1',
        //             execType => 'Trade',
        //             execValue => '0.00005804',
        //             feeRate => '0.0006',
        //             lastLiquidityInd => 'RemovedLiquidity',
        //             leavesQty => '0',
        //             orderId => '6111f83d-2c8c-463a-b9a8-77885eae2f57',
        //             orderLinkId => '',
        //             orderPrice => '17744.50',
        //             orderQty => '1',
        //             orderType => 'Market',
        //             stopOrderType => 'UNKNOWN',
        //             side => 'Buy',
        //             execTime => '1670210101997',
        //             closedSize => '0'
        //           }
        //         )
        //     }
        //
        $topic = $this->safe_string($message, 'topic');
        $spot = $topic === 'ticketInfo';
        $data = $this->safe_value($message, 'data', array());
        // unified margin
        $data = $this->safe_value($data, 'result', $data);
        if ($this->myTrades === null) {
            $limit = $this->safe_integer($this->options, 'tradesLimit', 1000);
            $this->myTrades = new ArrayCacheBySymbolById ($limit);
        }
        $trades = $this->myTrades;
        $symbols = array();
        $method = $spot ? 'parseWsTrade' : 'parseTrade';
        for ($i = 0; $i < count($data); $i++) {
            $rawTrade = $data[$i];
            $parsed = $this->$method ($rawTrade);
            $symbol = $parsed['symbol'];
            $symbols[$symbol] = true;
            $trades->append ($parsed);
        }
        $keys = is_array($symbols) ? array_keys($symbols) : array();
        for ($i = 0; $i < count($keys); $i++) {
            $messageHash = 'myTrades:' . $keys[$i];
            $client->resolve ($trades, $messageHash);
        }
        // non-$symbol specific
        $messageHash = 'myTrades';
        $client->resolve ($trades, $messageHash);
    }

    public function watch_orders($symbol = null, $since = null, $limit = null, $params = array ()) {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            /**
             * watches information on multiple $orders made by the user
             * @param {string|null} $symbol unified market $symbol of the market $orders were made in
             * @param {int|null} $since the earliest time in ms to fetch $orders for
             * @param {int|null} $limit the maximum number of  orde structures to retrieve
             * @param {array} $params extra parameters specific to the bybit api endpoint
             * @return {[array]} a list of [order structures]{@link https://docs.ccxt.com/en/latest/manual.html#order-structure
             */
            Async\await($this->load_markets());
            $method = 'watchOrders';
            $messageHash = 'orders';
            if ($symbol !== null) {
                $symbol = $this->symbol($symbol);
                $messageHash .= ':' . $symbol;
            }
            $isUnifiedMargin = Async\await($this->isUnifiedMarginEnabled ());
            $url = $this->get_url_by_market_type(null, true, $isUnifiedMargin, $method, $params);
            Async\await($this->authenticate($url));
            $topicsByMarket = array(
                'spot' => array( 'order', 'stopOrder' ),
                'contract' => array( 'user.order.contractAccount' ),
                'unified' => array( 'user.order.unifiedAccount' ),
            );
            $topics = $this->safe_value($topicsByMarket, $this->get_private_type($url));
            $orders = Async\await($this->watch_topics($url, $messageHash, $topics, $params));
            if ($this->newUpdates) {
                $limit = $orders->getLimit ($symbol, $limit);
            }
            return $this->filter_by_symbol_since_limit($orders, $symbol, $since, $limit, true);
        }) ();
    }

    public function handle_order($client, $message, $subscription = null) {
        //
        //     spot
        //     {
        //         "type" => "snapshot",
        //         "topic" => "order",
        //         "ts" => "1662348310441",
        //         "data" => array(
        //             {
        //                 "e" => "order",
        //                 "E" => "1662348310441",
        //                 "s" => "BTCUSDT",
        //                 "c" => "spotx008",
        //                 "S" => "BUY",
        //                 "o" => "MARKET_OF_QUOTE",
        //                 "f" => "GTC",
        //                 "q" => "20",
        //                 "p" => "0",
        //                 "X" => "CANCELED",
        //                 "i" => "1238261807653647872",
        //                 "M" => "1238225004531834368",
        //                 "l" => "0.001007",
        //                 "z" => "0.001007",
        //                 "L" => "19842.02",
        //                 "n" => "0",
        //                 "N" => "BTC",
        //                 "u" => true,
        //                 "w" => true,
        //                 "m" => false,
        //                 "O" => "1662348310368",
        //                 "Z" => "19.98091414",
        //                 "A" => "0",
        //                 "C" => false,
        //                 "v" => "0",
        //                 "d" => "NO_LIQ",
        //                 "t" => "2100000000002220938"
        //             }
        //         )
        //     }
        //  contract
        //     {
        //         "topic" => "user.order.contractAccount",
        //         "data" => array(
        //             {
        //                 "symbol" => "BTCUSD",
        //                 "orderId" => "ee013d82-fafc-4504-97b1-d92aca21eedd",
        //                 "side" => "Buy",
        //                 "orderType" => "Market",
        //                 "stopOrderType" => "UNKNOWN",
        //                 "price" => "21920.00",
        //                 "qty" => "200",
        //                 "timeInForce" => "ImmediateOrCancel",
        //                 "orderStatus" => "Filled",
        //                 "triggerPrice" => "0.00",
        //                 "orderLinkId" => "inv001",
        //                 "createdTime" => "1661338622771",
        //                 "updatedTime" => "1661338622775",
        //                 "takeProfit" => "0.00",
        //                 "stopLoss" => "0.00",
        //                 "tpTriggerBy" => "UNKNOWN",
        //                 "slTriggerBy" => "UNKNOWN",
        //                 "triggerBy" => "UNKNOWN",
        //                 "reduceOnly" => false,
        //                 "closeOnTrigger" => false,
        //                 "triggerDirection" => 0,
        //                 "leavesQty" => "0",
        //                 "lastExecQty" => "200",
        //                 "lastExecPrice" => "21282.00",
        //                 "cumExecQty" => "200",
        //                 "cumExecValue" => "0.00939761"
        //             }
        //         )
        //     }
        // unified
        //     {
        //         "id" => "f91080af-5187-4261-a802-7604419771aa",
        //         "topic" => "user.order.unifiedAccount",
        //         "ts" => 1661932033707,
        //         "data" => {
        //             "result" => array(
        //                 array(
        //                     "orderId" => "415f8961-4073-4d74-bc3e-df2830e52843",
        //                     "orderLinkId" => "",
        //                     "symbol" => "BTCUSDT",
        //                     "side" => "Buy",
        //                     "orderType" => "Limit",
        //                     "price" => "17000.00000000",
        //                     "qty" => "0.0100",
        //                     "timeInForce" => "GoodTillCancel",
        //                     "orderStatus" => "New",
        //                     "cumExecQty" => "0.0000",
        //                     "cumExecValue" => "0.00000000",
        //                     "cumExecFee" => "0.00000000",
        //                     "stopOrderType" => "UNKNOWN",
        //                     "triggerBy" => "UNKNOWN",
        //                     "triggerPrice" => "",
        //                     "reduceOnly" => true,
        //                     "closeOnTrigger" => true,
        //                     "createdTime" => 1661932033636,
        //                     "updatedTime" => 1661932033644,
        //                     "iv" => "",
        //                     "orderIM" => "",
        //                     "takeProfit" => "",
        //                     "stopLoss" => "",
        //                     "tpTriggerBy" => "UNKNOWN",
        //                     "slTriggerBy" => "UNKNOWN",
        //                     "basePrice" => "",
        //                     "blockTradeId" => "",
        //                     "leavesQty" => "0.0100"
        //                 }
        //             ),
        //             "version" => 284
        //         ),
        //         "type" => "snapshot"
        //     }
        //
        $topic = $this->safe_string($message, 'topic', '');
        if ($this->orders === null) {
            $limit = $this->safe_integer($this->options, 'ordersLimit', 1000);
            $this->orders = new ArrayCacheBySymbolById ($limit);
        }
        $orders = $this->orders;
        $rawOrders = array();
        $parser = null;
        if ($topic === 'order') {
            $rawOrders = $this->safe_value($message, 'data', array());
            $parser = 'parseWsSpotOrder';
        } else {
            $parser = 'parseContractOrder';
            $rawOrders = $this->safe_value($message, 'data', array());
            $rawOrders = $this->safe_value($rawOrders, 'result', $rawOrders);
        }
        $symbols = array();
        for ($i = 0; $i < count($rawOrders); $i++) {
            $parsed = $this->$parser ($rawOrders[$i]);
            $symbol = $parsed['symbol'];
            $symbols[$symbol] = true;
            $orders->append ($parsed);
        }
        $symbolsArray = is_array($symbols) ? array_keys($symbols) : array();
        for ($i = 0; $i < count($symbolsArray); $i++) {
            $messageHash = 'orders:' . $symbolsArray[$i];
            $client->resolve ($orders, $messageHash);
        }
        $messageHash = 'orders';
        $client->resolve ($orders, $messageHash);
    }

    public function parse_ws_spot_order($order, $market = null) {
        //
        //    {
        //        e => 'executionReport',
        //        E => '1653297251061', // $timestamp
        //        s => 'LTCUSDT', // $symbol
        //        c => '1653297250740', // user $id
        //        S => 'SELL', // $side
        //        o => 'MARKET_OF_BASE', // $order $type
        //        f => 'GTC', // time in force
        //        $q => '0.16233', // quantity
        //        p => '0', // $price
        //        X => 'NEW', // $status
        //        i => '1162336018974750208', // $order $id
        //        M => '0',
        //        l => '0', // last $filled
        //        z => '0', // total $filled
        //        L => '0', // last traded $price
        //        n => '0', // trading $fee
        //        N => '', // $fee asset
        //        u => true,
        //        w => true,
        //        m => false, // is limit_maker
        //        O => '1653297251042', // $order creation
        //        Z => '0', // total $filled
        //        A => '0', // account $id
        //        C => false, // is close
        //        v => '0', // leverage
        //        d => 'NO_LIQ'
        //    }
        //
        $id = $this->safe_string($order, 'i');
        $marketId = $this->safe_string($order, 's');
        $symbol = $this->safe_symbol($marketId, $market, null, 'spot');
        $timestamp = $this->safe_integer($order, 'O');
        $price = $this->safe_string($order, 'p');
        if ($price === '0') {
            $price = null; // $market orders
        }
        $filled = $this->safe_string($order, 'z');
        $status = $this->parse_order_status($this->safe_string($order, 'X'));
        $side = $this->safe_string_lower($order, 'S');
        $lastTradeTimestamp = $this->safe_string($order, 'E');
        $timeInForce = $this->safe_string($order, 'f');
        $amount = null;
        $cost = $this->safe_string($order, 'Z');
        $q = $this->safe_string($order, 'q');
        $type = $this->safe_string_lower($order, 'o');
        if (mb_strpos($type, 'quote') !== false) {
            $amount = $filled;
        } else {
            $amount = $q;
        }
        if (mb_strpos($type, 'market') !== false) {
            $type = 'market';
        }
        $fee = null;
        $feeCost = $this->safe_string($order, 'n');
        if ($feeCost !== null && $feeCost !== '0') {
            $feeCurrencyId = $this->safe_string($order, 'N');
            $feeCurrencyCode = $this->safe_currency_code($feeCurrencyId);
            $fee = array(
                'cost' => $feeCost,
                'currency' => $feeCurrencyCode,
            );
        }
        return $this->safe_order(array(
            'info' => $order,
            'id' => $id,
            'clientOrderId' => $this->safe_string($order, 'c'),
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'lastTradeTimestamp' => $lastTradeTimestamp,
            'symbol' => $symbol,
            'type' => $type,
            'timeInForce' => $timeInForce,
            'postOnly' => null,
            'side' => $side,
            'price' => $price,
            'stopPrice' => null,
            'amount' => $amount,
            'cost' => $cost,
            'average' => null,
            'filled' => $filled,
            'remaining' => null,
            'status' => $status,
            'fee' => $fee,
        ), $market);
    }

    public function watch_balance($params = array ()) {
        return Async\async(function () use ($params) {
            /**
             * query for balance and get the amount of funds available for trading or funds locked in orders
             * @param {array} $params extra parameters specific to the bybit api endpoint
             * @return {array} a ~@link https://docs.ccxt.com/en/latest/manual.html?#balance-structure balance structure~
             */
            $method = 'watchBalance';
            $messageHash = 'balances';
            $isUnifiedMargin = Async\await($this->isUnifiedMarginEnabled ());
            $url = $this->get_url_by_market_type(null, true, $isUnifiedMargin, $method, $params);
            Async\await($this->authenticate($url));
            $topicByMarket = array(
                'spot' => 'outboundAccountInfo',
                'contract' => 'user.wallet.contractAccount',
                'unified' => 'user.wallet.unifiedAccount',
            );
            $topics = array( $this->safe_value($topicByMarket, $this->get_private_type($url)) );
            return Async\await($this->watch_topics($url, $messageHash, $topics, $params));
        }) ();
    }

    public function handle_balance($client, $message) {
        //
        // spot
        //    {
        //        "type" => "snapshot",
        //        "topic" => "outboundAccountInfo",
        //        "ts" => "1662107217641",
        //        "data" => array(
        //            {
        //                "e" => "outboundAccountInfo",
        //                "E" => "1662107217640",
        //                "T" => true,
        //                "W" => true,
        //                "D" => true,
        //                "B" => array(
        //                    {
        //                        "a" => "USDT",
        //                        "f" => "176.81254174",
        //                        "l" => "201.575"
        //                    }
        //                )
        //            }
        //        )
        //    }
        // contract
        //    {
        //        "topic" => "user.wallet.contractAccount",
        //        "data" => array(
        //            {
        //                "coin" => "USDT",
        //                "equity" => "610.3984319",
        //                "walletBalance" => "609.7384319",
        //                "positionMargin" => "4.7582882",
        //                "availableBalance" => "604.9801437",
        //                "orderMargin" => "0",
        //                "unrealisedPnl" => "0.66",
        //                "cumRealisedPnl" => "-0.2615681"
        //            }
        //        )
        //    }
        // unified
        //    {
        //        "id" => "46bd0430-1d03-48f7-a503-c6c020d07536",
        //        "topic" => "user.wallet.unifiedAccount",
        //        "ts" => 1649150852199,
        //        "data" => array(
        //            "result" => array(
        //                "accountIMRate" => "0.0002",
        //                "accountMMRate" => "0.0000",
        //                "totalEquity" => "510444.50000000",
        //                "totalWalletBalance" => "510444.50000000",
        //                "totalMarginBalance" => "510444.50000000",
        //                "totalAvailableBalance" => "510333.52491801",
        //                "totalPerpUPL" => "0.00000000",
        //                "totalInitialMargin" => "110.97508199",
        //                "totalMaintenanceMargin" => "9.13733489",
        //                "coin" => [array(
        //                    "currencyCoin" => "USDC",
        //                    "equity" => "0.00000000",
        //                    "usdValue" => "0.00000000",
        //                    "walletBalance" => "0.00000000",
        //                    "marginBalance" => "510444.50000000",
        //                    "availableBalance" => "510333.52491801",
        //                    "marginBalanceWithoutConvert" => "0.00000000",
        //                    "availableBalanceWithoutConvert" => "0.00000000",
        //                    "borrowSize" => "0.00000000",
        //                    "availableToBorrow" => "200000.00000000",
        //                    "accruedInterest" => "0.00000000",
        //                    "totalOrderIM" => "0.00000000",
        //                    "totalPositionIM" => "0.00000000",
        //                    "totalPositionMM" => "0.00000000"
        //                )]
        //            ),
        //            "version" => 19
        //        ),
        //        "type" => "snapshot"
        //    }
        //
        if ($this->balance === null) {
            $this->balance = array();
        }
        $messageHash = 'balance';
        $topic = $this->safe_value($message, 'topic');
        $info = null;
        $rawBalances = array();
        if ($topic === 'outboundAccountInfo') {
            $data = $this->safe_value($message, 'data', array());
            for ($i = 0; $i < count($data); $i++) {
                $B = $this->safe_value($data[$i], 'B', array());
                $rawBalances = $this->array_concat($rawBalances, $B);
            }
            $info = $rawBalances;
        }
        if ($topic === 'user.wallet.contractAccount') {
            $rawBalances = $this->safe_value($message, 'data', array());
            $info = $rawBalances;
        }
        if ($topic === 'user.wallet.unifiedAccount') {
            $data = $this->safe_value($message, 'data', array());
            $result = $this->safe_value($data, 'result', array());
            $rawBalances = $this->safe_value($result, 'coin', array());
            $info = $result;
        }
        for ($i = 0; $i < count($rawBalances); $i++) {
            $this->parse_ws_balance($rawBalances[$i]);
        }
        $this->balance['info'] = $info;
        $timestamp = $this->safe_integer($message, 'ts');
        $this->balance['timestamp'] = $timestamp;
        $this->balance['datetime'] = $this->iso8601($timestamp);
        $this->balance = $this->safe_balance($this->balance);
        $messageHash = 'balances';
        $client->resolve ($this->balance, $messageHash);
    }

    public function parse_ws_balance($balance) {
        //
        // spot
        //    {
        //        "a" => "USDT",
        //        "f" => "176.81254174",
        //        "l" => "201.575"
        //    }
        // contract
        //    {
        //        "coin" => "USDT",
        //        "equity" => "610.3984319",
        //        "walletBalance" => "609.7384319",
        //        "positionMargin" => "4.7582882",
        //        "availableBalance" => "604.9801437",
        //        "orderMargin" => "0",
        //        "unrealisedPnl" => "0.66",
        //        "cumRealisedPnl" => "-0.2615681"
        //    }
        // unified
        //    {
        //        "currencyCoin" => "USDC",
        //        "equity" => "0.00000000",
        //        "usdValue" => "0.00000000",
        //        "walletBalance" => "0.00000000",
        //        "marginBalance" => "510444.50000000",
        //        "availableBalance" => "510333.52491801",
        //        "marginBalanceWithoutConvert" => "0.00000000",
        //        "availableBalanceWithoutConvert" => "0.00000000",
        //        "borrowSize" => "0.00000000",
        //        "availableToBorrow" => "200000.00000000",
        //        "accruedInterest" => "0.00000000",
        //        "totalOrderIM" => "0.00000000",
        //        "totalPositionIM" => "0.00000000",
        //        "totalPositionMM" => "0.00000000"
        //    }
        //
        $account = $this->account();
        $currencyId = $this->safe_string_n($balance, array( 'a', 'currencyCoin', 'coin' ));
        $code = $this->safe_currency_code($currencyId);
        $account['free'] = $this->safe_string_n($balance, array( 'availableBalanceWithoutConvert', 'availableBalance', 'f' ));
        $account['used'] = $this->safe_string($balance, 'l');
        $account['total'] = $this->safe_string($balance, 'walletBalance');
        $this->balance[$code] = $account;
    }

    public function watch_topics($url, $messageHash, $topics = [], $params = array ()) {
        return Async\async(function () use ($url, $messageHash, $topics, $params) {
            $request = array(
                'op' => 'subscribe',
                'req_id' => $this->request_id(),
                'args' => $topics,
            );
            $message = array_merge($request, $params);
            return Async\await($this->watch($url, $messageHash, $message, $messageHash));
        }) ();
    }

    public function authenticate($url, $params = array ()) {
        return Async\async(function () use ($url, $params) {
            $this->check_required_credentials();
            $messageHash = 'login';
            $client = $this->client($url);
            $future = $this->safe_value($client->subscriptions, $messageHash);
            if ($future === null) {
                $future = $client->future ('authenticated');
                $expires = $this->milliseconds() + 10000;
                $expires = (string) $expires;
                $path = 'GET/realtime';
                $auth = $path . $expires;
                $signature = $this->hmac($this->encode($auth), $this->encode($this->secret), 'sha256', 'hex');
                $request = array(
                    'op' => 'auth',
                    'args' => array(
                        $this->apiKey, $expires, $signature,
                    ),
                );
                $this->spawn(array($this, 'watch'), $url, $messageHash, $request, $messageHash, $future);
            }
            return Async\await($future);
        }) ();
    }

    public function handle_error_message($client, $message) {
        //
        //   {
        //       $success => false,
        //       $ret_msg => 'error:invalid op',
        //       conn_id => '5e079fdd-9c7f-404d-9dbf-969d650838b5',
        //       $request => array( $op => '', args => null )
        //   }
        //
        // auth error
        //
        //   {
        //       $success => false,
        //       $ret_msg => 'error:USVC1111',
        //       conn_id => 'e73770fb-a0dc-45bd-8028-140e20958090',
        //       $request => {
        //         $op => 'auth',
        //         args => array(
        //           '9rFT6uR4uz9Imkw4Wx',
        //           '1653405853543',
        //           '542e71bd85597b4db0290f0ce2d13ed1fd4bb5df3188716c1e9cc69a879f7889'
        //         )
        //   }
        //
        //   array( $code => '-10009', desc => 'Invalid period!' )
        //
        $code = $this->safe_integer($message, 'code');
        try {
            if ($code !== null) {
                $feedback = $this->id . ' ' . $this->json($message);
                $this->throw_exactly_matched_exception($this->exceptions['exact'], $code, $feedback);
            }
            $success = $this->safe_value($message, 'success');
            if ($success !== null && !$success) {
                $ret_msg = $this->safe_string($message, 'ret_msg');
                $request = $this->safe_value($message, 'request', array());
                $op = $this->safe_string($request, 'op');
                if ($op === 'auth') {
                    throw new AuthenticationError('Authentication failed => ' . $ret_msg);
                } else {
                    throw new ExchangeError($this->id . ' ' . $ret_msg);
                }
            }
        } catch (Exception $e) {
            if ($e instanceof AuthenticationError) {
                $client->reject ($e, 'authenticated');
                $method = 'login';
                if (is_array($client->subscriptions) && array_key_exists($method, $client->subscriptions)) {
                    unset($client->subscriptions[$method]);
                }
                return false;
            }
            throw $e;
        }
        return $message;
    }

    public function handle_message($client, $message) {
        if (!$this->handle_error_message($client, $message)) {
            return;
        }
        // contract $pong
        $ret_msg = $this->safe_string($message, 'ret_msg');
        if ($ret_msg === 'pong') {
            $this->handle_pong($client, $message);
            return;
        }
        // spot $pong
        $pong = $this->safe_integer($message, 'pong');
        if ($pong !== null) {
            $this->handle_pong($client, $message);
            return;
        }
        // $pong
        $op = $this->safe_string($message, 'op');
        if ($op === 'pong') {
            $this->handle_pong($client, $message);
            return;
        }
        $event = $this->safe_string($message, 'event');
        if ($event === 'sub') {
            $this->handle_subscription_status($client, $message);
            return;
        }
        $topic = $this->safe_string($message, 'topic', '');
        $methods = array(
            'orderbook' => array($this, 'handle_order_book'),
            'kline' => array($this, 'handle_ohlcv'),
            'order' => array($this, 'handle_order'),
            'stopOrder' => array($this, 'handle_order'),
            'ticker' => array($this, 'handle_ticker'),
            'trade' => array($this, 'handle_trades'),
            'publicTrade' => array($this, 'handle_trades'),
            'depth' => array($this, 'handle_order_book'),
            'wallet' => array($this, 'handle_balance'),
            'outboundAccountInfo' => array($this, 'handle_balance'),
            'execution' => array($this, 'handle_my_trades'),
            'ticketInfo' => array($this, 'handle_my_trades'),
        );
        $keys = is_array($methods) ? array_keys($methods) : array();
        for ($i = 0; $i < count($keys); $i++) {
            $key = $keys[$i];
            if (mb_strpos($topic, $keys[$i]) !== false) {
                $method = $methods[$key];
                $method($client, $message);
                return;
            }
        }
        // unified auth acknowledgement
        $type = $this->safe_string($message, 'type');
        if (($op === 'auth') || ($type === 'AUTH_RESP')) {
            $this->handle_authenticate($client, $message);
        }
    }

    public function ping() {
        return array(
            'req_id' => $this->request_id(),
            'op' => 'ping',
        );
    }

    public function handle_pong($client, $message) {
        //
        //   {
        //       success => true,
        //       ret_msg => 'pong',
        //       conn_id => 'db3158a0-8960-44b9-a9de-ac350ee13158',
        //       request => array( op => 'ping', args => null )
        //   }
        //
        //   array( pong => 1653296711335 )
        //
        $client->lastPong = $this->safe_integer($message, 'pong');
        return $message;
    }

    public function handle_authenticate($client, $message) {
        //
        //    {
        //        $success => true,
        //        ret_msg => '',
        //        op => 'auth',
        //        conn_id => 'ce3dpomvha7dha97tvp0-2xh'
        //    }
        //
        $success = $this->safe_value($message, 'success');
        if ($success) {
            $client->resolve ($message, 'authenticated');
        } else {
            $error = new AuthenticationError ($this->id . ' ' . $this->json($message));
            $client->reject ($error, 'authenticated');
        }
        return $message;
    }

    public function handle_subscription_status($client, $message) {
        //
        //    {
        //        topic => 'kline',
        //        event => 'sub',
        //        params => array(
        //          symbol => 'LTCUSDT',
        //          binary => 'false',
        //          klineType => '1m',
        //          symbolName => 'LTCUSDT'
        //        ),
        //        code => '0',
        //        msg => 'Success'
        //    }
        //
        return $message;
    }
}
