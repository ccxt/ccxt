<?php

namespace ccxt\pro;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

use Exception; // a common import
use ccxt\ExchangeError;
use ccxt\BadRequest;
use ccxt\AuthenticationError;
use React\Async;

class bybit extends \ccxt\async\bybit {

    public function describe() {
        return $this->deep_extend(parent::describe(), array(
            'has' => array(
                'ws' => true,
                'watchBalance' => true,
                'watchMyTrades' => true,
                'watchOHLCV' => true,
                'watchOrderBook' => true,
                'watchOrders' => true,
                'watchTicker' => true,
                'watchTickers' => false, // for now
                'watchTrades' => true,
                'watchPosition' => null,
            ),
            'urls' => array(
                'api' => array(
                    'ws' => array(
                        'public' => array(
                            'spot' => 'wss://stream.{hostname}/v5/public/spot',
                            'inverse' => 'wss://stream.{hostname}/v5/public/inverse',
                            'option' => 'wss://stream.{hostname}/v5/public/option',
                            'linear' => 'wss://stream.{hostname}/v5/public/linear',
                        ),
                        'private' => array(
                            'spot' => array(
                                'unified' => 'wss://stream.{hostname}/v5/private',
                                'nonUnified' => 'wss://stream.{hostname}/spot/private/v3',
                            ),
                            'contract' => 'wss://stream.{hostname}/v5/private',
                            'usdc' => 'wss://stream.{hostname}/trade/option/usdc/private/v1',
                        ),
                    ),
                ),
                'test' => array(
                    'ws' => array(
                        'public' => array(
                            'spot' => 'wss://stream-testnet.{hostname}/v5/public/spot',
                            'inverse' => 'wss://stream-testnet.{hostname}/v5/public/inverse',
                            'linear' => 'wss://stream-testnet.{hostname}/v5/public/linear',
                            'option' => 'wss://stream-testnet.{hostname}/v5/public/option',
                        ),
                        'private' => array(
                            'spot' => array(
                                'unified' => 'wss://stream-testnet.{hostname}/v5/private',
                                'nonUnified' => 'wss://stream-testnet.{hostname}/spot/private/v3',
                            ),
                            'contract' => 'wss://stream-testnet.{hostname}/v5/private',
                            'usdc' => 'wss://stream-testnet.{hostname}/trade/option/usdc/private/v1',
                        ),
                    ),
                ),
            ),
            'options' => array(
                'watchTicker' => array(
                    'name' => 'tickers', // 'tickers' for 24hr statistical ticker or 'tickers_lt' for leverage token ticker
                ),
                'spot' => array(
                    'timeframes' => array(
                        '1m' => '1m',
                        '3m' => '3m',
                        '5m' => '5m',
                        '15m' => '15m',
                        '30m' => '30m',
                        '1h' => '1h',
                        '2h' => '2h',
                        '4h' => '4h',
                        '6h' => '6h',
                        '12h' => '12h',
                        '1d' => '1d',
                        '1w' => '1w',
                        '1M' => '1M',
                    ),
                ),
                'contract' => array(
                    'timeframes' => array(
                        '1m' => '1',
                        '3m' => '3',
                        '5m' => '5',
                        '15m' => '15',
                        '30m' => '30',
                        '1h' => '60',
                        '2h' => '120',
                        '4h' => '240',
                        '6h' => '360',
                        '12h' => '720',
                        '1d' => 'D',
                        '1w' => 'W',
                        '1M' => 'M',
                    ),
                ),
            ),
            'streaming' => array(
                'ping' => array($this, 'ping'),
                'keepAlive' => 20000,
            ),
        ));
    }

    public function request_id() {
        $requestId = $this->sum($this->safe_integer($this->options, 'requestId', 0), 1);
        $this->options['requestId'] = $requestId;
        return $requestId;
    }

    public function get_url_by_market_type(?string $symbol = null, $isPrivate = false, $method = null, $params = array ()) {
        $accessibility = $isPrivate ? 'private' : 'public';
        $isUsdcSettled = null;
        $isSpot = null;
        $type = null;
        $market = null;
        $url = $this->urls['api']['ws'];
        if ($symbol !== null) {
            $market = $this->market($symbol);
            $isUsdcSettled = $market['settle'] === 'USDC';
            $type = $market['type'];
        } else {
            list($type, $params) = $this->handle_market_type_and_params($method, null, $params);
            $defaultSettle = $this->safe_string($this->options, 'defaultSettle');
            $defaultSettle = $this->safe_string_2($params, 'settle', 'defaultSettle', $defaultSettle);
            $isUsdcSettled = ($defaultSettle === 'USDC');
        }
        $isSpot = ($type === 'spot');
        if ($isPrivate) {
            $url = ($isUsdcSettled) ? $url[$accessibility]['usdc'] : $url[$accessibility]['contract'];
        } else {
            if ($isSpot) {
                $url = $url[$accessibility]['spot'];
            } elseif ($type === 'swap') {
                $subType = null;
                list($subType, $params) = $this->handle_sub_type_and_params($method, $market, $params, 'linear');
                $url = $url[$accessibility][$subType];
            } else {
                // option
                $url = $url[$accessibility]['option'];
            }
        }
        $url = $this->implode_hostname($url);
        return $url;
    }

    public function clean_params($params) {
        $params = $this->omit($params, array( 'type', 'subType', 'settle', 'defaultSettle', 'unifiedMargin' ));
        return $params;
    }

    public function watch_ticker(string $symbol, $params = array ()) {
        return Async\async(function () use ($symbol, $params) {
            /**
             * watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific $market
             * @see https://bybit-exchange.github.io/docs/v5/websocket/public/ticker
             * @see https://bybit-exchange.github.io/docs/v5/websocket/public/etp-ticker
             * @param {string} $symbol unified $symbol of the $market to fetch the ticker for
             * @param {array} $params extra parameters specific to the bybit api endpoint
             * @return {array} a ~@link https://docs.ccxt.com/#/?id=ticker-structure ticker structure~
             */
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $symbol = $market['symbol'];
            $messageHash = 'ticker:' . $symbol;
            $url = $this->get_url_by_market_type($symbol, false, $params);
            $params = $this->clean_params($params);
            $options = $this->safe_value($this->options, 'watchTicker', array());
            $topic = $this->safe_string($options, 'name', 'tickers');
            if (!$market['spot'] && $topic !== 'tickers') {
                throw new BadRequest($this->id . ' watchTicker() only supports name tickers for contract markets');
            }
            $topic .= '.' . $market['id'];
            $topics = array( $topic );
            return Async\await($this->watch_topics($url, $messageHash, $topics, $params));
        }) ();
    }

    public function handle_ticker(Client $client, $message) {
        //
        // linear
        //     {
        //         "topic" => "tickers.BTCUSDT",
        //         "type" => "snapshot",
        //         "data" => array(
        //             "symbol" => "BTCUSDT",
        //             "tickDirection" => "PlusTick",
        //             "price24hPcnt" => "0.017103",
        //             "lastPrice" => "17216.00",
        //             "prevPrice24h" => "16926.50",
        //             "highPrice24h" => "17281.50",
        //             "lowPrice24h" => "16915.00",
        //             "prevPrice1h" => "17238.00",
        //             "markPrice" => "17217.33",
        //             "indexPrice" => "17227.36",
        //             "openInterest" => "68744.761",
        //             "openInterestValue" => "1183601235.91",
        //             "turnover24h" => "1570383121.943499",
        //             "volume24h" => "91705.276",
        //             "nextFundingTime" => "1673280000000",
        //             "fundingRate" => "-0.000212",
        //             "bid1Price" => "17215.50",
        //             "bid1Size" => "84.489",
        //             "ask1Price" => "17216.00",
        //             "ask1Size" => "83.020"
        //         ),
        //         "cs" => 24987956059,
        //         "ts" => 1673272861686
        //     }
        //
        // option
        //     {
        //         "id" => "tickers.BTC-6JAN23-17500-C-2480334983-1672917511074",
        //         "topic" => "tickers.BTC-6JAN23-17500-C",
        //         "ts" => 1672917511074,
        //         "data" => array(
        //             "symbol" => "BTC-6JAN23-17500-C",
        //             "bidPrice" => "0",
        //             "bidSize" => "0",
        //             "bidIv" => "0",
        //             "askPrice" => "10",
        //             "askSize" => "5.1",
        //             "askIv" => "0.514",
        //             "lastPrice" => "10",
        //             "highPrice24h" => "25",
        //             "lowPrice24h" => "5",
        //             "markPrice" => "7.86976724",
        //             "indexPrice" => "16823.73",
        //             "markPriceIv" => "0.4896",
        //             "underlyingPrice" => "16815.1",
        //             "openInterest" => "49.85",
        //             "turnover24h" => "446802.8473",
        //             "volume24h" => "26.55",
        //             "totalVolume" => "86",
        //             "totalTurnover" => "1437431",
        //             "delta" => "0.047831",
        //             "gamma" => "0.00021453",
        //             "vega" => "0.81351067",
        //             "theta" => "-19.9115368",
        //             "predictedDeliveryPrice" => "0",
        //             "change24h" => "-0.33333334"
        //         ),
        //         "type" => "snapshot"
        //     }
        //
        // spot
        //     {
        //         "topic" => "tickers.BTCUSDT",
        //         "ts" => 1673853746003,
        //         "type" => "snapshot",
        //         "cs" => 2588407389,
        //         "data" => {
        //             "symbol" => "BTCUSDT",
        //             "lastPrice" => "21109.77",
        //             "highPrice24h" => "21426.99",
        //             "lowPrice24h" => "20575",
        //             "prevPrice24h" => "20704.93",
        //             "volume24h" => "6780.866843",
        //             "turnover24h" => "141946527.22907118",
        //             "price24hPcnt" => "0.0196",
        //             "usdIndexPrice" => "21120.2400136"
        //         }
        //     }
        //
        // lt $ticker
        //     {
        //         "topic" => "tickers_lt.EOS3LUSDT",
        //         "ts" => 1672325446847,
        //         "type" => "snapshot",
        //         "data" => {
        //             "symbol" => "EOS3LUSDT",
        //             "lastPrice" => "0.41477848043290448",
        //             "highPrice24h" => "0.435285472510871305",
        //             "lowPrice24h" => "0.394601507960931382",
        //             "prevPrice24h" => "0.431502290172376349",
        //             "price24hPcnt" => "-0.0388"
        //         }
        //     }
        //
        $topic = $this->safe_string($message, 'topic', '');
        $updateType = $this->safe_string($message, 'type', '');
        $data = $this->safe_value($message, 'data', array());
        $isSpot = $this->safe_string($data, 's') !== null;
        $symbol = null;
        $parsed = null;
        if (($updateType === 'snapshot') || $isSpot) {
            $parsed = $this->parse_ticker($data);
            $symbol = $parsed['symbol'];
        } elseif ($updateType === 'delta') {
            $topicParts = explode('.', $topic);
            $topicLength = count($topicParts);
            $marketId = $this->safe_string($topicParts, $topicLength - 1);
            $market = $this->market($marketId);
            $symbol = $market['symbol'];
            // update the info in place
            $ticker = $this->safe_value($this->tickers, $symbol, array());
            $rawTicker = $this->safe_value($ticker, 'info', array());
            $merged = array_merge($rawTicker, $data);
            $parsed = $this->parse_ticker($merged);
        }
        $timestamp = $this->safe_integer($message, 'ts');
        $parsed['timestamp'] = $timestamp;
        $parsed['datetime'] = $this->iso8601($timestamp);
        $this->tickers[$symbol] = $parsed;
        $messageHash = 'ticker:' . $symbol;
        $client->resolve ($this->tickers[$symbol], $messageHash);
    }

    public function watch_ohlcv(string $symbol, $timeframe = '1m', ?int $since = null, ?int $limit = null, $params = array ()) {
        return Async\async(function () use ($symbol, $timeframe, $since, $limit, $params) {
            /**
             * watches historical candlestick data containing the open, high, low, and close price, and the volume of a $market
             * @see https://bybit-exchange.github.io/docs/v5/websocket/public/kline
             * @see https://bybit-exchange.github.io/docs/v5/websocket/public/etp-kline
             * @param {string} $symbol unified $symbol of the $market to fetch OHLCV data for
             * @param {string} $timeframe the length of time each candle represents
             * @param {int|null} $since timestamp in ms of the earliest candle to fetch
             * @param {int|null} $limit the maximum amount of candles to fetch
             * @param {array} $params extra parameters specific to the bybit api endpoint
             * @return {[[int]]} A list of candles ordered, open, high, low, close, volume
             */
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $symbol = $market['symbol'];
            $url = $this->get_url_by_market_type($symbol, false, $params);
            $params = $this->clean_params($params);
            $ohlcv = null;
            $timeframeId = $this->safe_string($this->timeframes, $timeframe, $timeframe);
            $topics = [ 'kline.' . $timeframeId . '.' . $market['id'] ];
            $messageHash = 'kline' . ':' . $timeframeId . ':' . $symbol;
            $ohlcv = Async\await($this->watch_topics($url, $messageHash, $topics, $params));
            if ($this->newUpdates) {
                $limit = $ohlcv->getLimit ($symbol, $limit);
            }
            return $this->filter_by_since_limit($ohlcv, $since, $limit, 0, true);
        }) ();
    }

    public function handle_ohlcv(Client $client, $message) {
        //
        //     {
        //         "topic" => "kline.5.BTCUSDT",
        //         "data" => array(
        //             {
        //                 "start" => 1672324800000,
        //                 "end" => 1672325099999,
        //                 "interval" => "5",
        //                 "open" => "16649.5",
        //                 "close" => "16677",
        //                 "high" => "16677",
        //                 "low" => "16608",
        //                 "volume" => "2.081",
        //                 "turnover" => "34666.4005",
        //                 "confirm" => false,
        //                 "timestamp" => 1672324988882
        //             }
        //         ),
        //         "ts" => 1672324988882,
        //         "type" => "snapshot"
        //     }
        //
        $data = $this->safe_value($message, 'data', array());
        $topic = $this->safe_string($message, 'topic');
        $topicParts = explode('.', $topic);
        $topicLength = count($topicParts);
        $timeframeId = $this->safe_string($topicParts, 1);
        $marketId = $this->safe_string($topicParts, $topicLength - 1);
        $isSpot = mb_strpos($client->url, 'spot') > -1;
        $marketType = $isSpot ? 'spot' : 'contract';
        $market = $this->safe_market($marketId, null, null, $marketType);
        $symbol = $market['symbol'];
        $ohlcvsByTimeframe = $this->safe_value($this->ohlcvs, $symbol);
        if ($ohlcvsByTimeframe === null) {
            $this->ohlcvs[$symbol] = array();
        }
        $stored = $this->safe_value($ohlcvsByTimeframe, $timeframeId);
        if ($stored === null) {
            $limit = $this->safe_integer($this->options, 'OHLCVLimit', 1000);
            $stored = new ArrayCacheByTimestamp ($limit);
            $this->ohlcvs[$symbol][$timeframeId] = $stored;
        }
        for ($i = 0; $i < count($data); $i++) {
            $parsed = $this->parse_ws_ohlcv($data[$i]);
            $stored->append ($parsed);
        }
        $messageHash = 'kline' . ':' . $timeframeId . ':' . $symbol;
        $client->resolve ($stored, $messageHash);
    }

    public function parse_ws_ohlcv($ohlcv) {
        //
        //     {
        //         "start" => 1670363160000,
        //         "end" => 1670363219999,
        //         "interval" => "1",
        //         "open" => "16987.5",
        //         "close" => "16987.5",
        //         "high" => "16988",
        //         "low" => "16987.5",
        //         "volume" => "23.511",
        //         "turnover" => "399396.344",
        //         "confirm" => false,
        //         "timestamp" => 1670363219614
        //     }
        //
        return array(
            $this->safe_integer($ohlcv, 'timestamp'),
            $this->safe_number($ohlcv, 'open'),
            $this->safe_number($ohlcv, 'high'),
            $this->safe_number($ohlcv, 'low'),
            $this->safe_number($ohlcv, 'close'),
            $this->safe_number_2($ohlcv, 'volume', 'turnover'),
        );
    }

    public function watch_order_book(string $symbol, ?int $limit = null, $params = array ()) {
        return Async\async(function () use ($symbol, $limit, $params) {
            /**
             * watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
             * @see https://bybit-exchange.github.io/docs/v5/websocket/public/orderbook
             * @param {string} $symbol unified $symbol of the $market to fetch the order book for
             * @param {int|null} $limit the maximum amount of order book entries to return.
             * @param {array} $params extra parameters specific to the bybit api endpoint
             * @return {array} A dictionary of ~@link https://docs.ccxt.com/#/?id=order-book-structure order book structures~ indexed by $market symbols
             */
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $symbol = $market['symbol'];
            $url = $this->get_url_by_market_type($symbol, false, $params);
            $params = $this->clean_params($params);
            $messageHash = 'orderbook' . ':' . $symbol;
            if ($limit === null) {
                if ($market['spot']) {
                    $limit = 50;
                } else {
                    $limit = 500;
                }
            } else {
                if (!$market['spot']) {
                    // bybit only support $limit 1, 50, 200, 500 for contract
                    if (($limit !== 1) && ($limit !== 50) && ($limit !== 200) && ($limit !== 500)) {
                        throw new BadRequest($this->id . ' watchOrderBook() can only use $limit 1, 50, 200 and 500.');
                    }
                }
            }
            $topics = [ 'orderbook.' . (string) $limit . '.' . $market['id'] ];
            $orderbook = Async\await($this->watch_topics($url, $messageHash, $topics, $params));
            return $orderbook->limit ();
        }) ();
    }

    public function handle_order_book(Client $client, $message) {
        //
        //     {
        //         "topic" => "orderbook.50.BTCUSDT",
        //         "type" => "snapshot",
        //         "ts" => 1672304484978,
        //         "data" => {
        //             "s" => "BTCUSDT",
        //             "b" => array(
        //                 ...,
        //                 array(
        //                     "16493.50",
        //                     "0.006"
        //                 ),
        //                 array(
        //                     "16493.00",
        //                     "0.100"
        //                 )
        //             ),
        //             "a" => array(
        //                 array(
        //                     "16611.00",
        //                     "0.029"
        //                 ),
        //                 array(
        //                     "16612.00",
        //                     "0.213"
        //                 ),
        //             ),
        //             "u" => 18521288,
        //             "seq" => 7961638724
        //         }
        //     }
        //
        $isSpot = mb_strpos($client->url, 'spot') !== false;
        $type = $this->safe_string($message, 'type');
        $isSnapshot = ($type === 'snapshot');
        $data = $this->safe_value($message, 'data', array());
        $marketId = $this->safe_string($data, 's');
        $marketType = $isSpot ? 'spot' : 'contract';
        $market = $this->safe_market($marketId, null, null, $marketType);
        $symbol = $market['symbol'];
        $timestamp = $this->safe_integer($message, 'ts');
        $orderbook = $this->safe_value($this->orderbooks, $symbol);
        if ($orderbook === null) {
            $orderbook = $this->order_book();
        }
        if ($isSnapshot) {
            $snapshot = $this->parse_order_book($data, $symbol, $timestamp, 'b', 'a');
            $orderbook->reset ($snapshot);
        } else {
            $asks = $this->safe_value($data, 'a', array());
            $bids = $this->safe_value($data, 'b', array());
            $this->handle_deltas($orderbook['asks'], $asks);
            $this->handle_deltas($orderbook['bids'], $bids);
            $orderbook['timestamp'] = $timestamp;
            $orderbook['datetime'] = $this->iso8601($timestamp);
        }
        $messageHash = 'orderbook' . ':' . $symbol;
        $this->orderbooks[$symbol] = $orderbook;
        $client->resolve ($orderbook, $messageHash);
    }

    public function handle_delta($bookside, $delta) {
        $bidAsk = $this->parse_bid_ask($delta, 0, 1);
        $bookside->storeArray ($bidAsk);
    }

    public function handle_deltas($bookside, $deltas) {
        for ($i = 0; $i < count($deltas); $i++) {
            $this->handle_delta($bookside, $deltas[$i]);
        }
    }

    public function watch_trades(string $symbol, ?int $since = null, ?int $limit = null, $params = array ()) {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            /**
             * watches information on multiple $trades made in a $market
             * @see https://bybit-exchange.github.io/docs/v5/websocket/public/trade
             * @param {string} $symbol unified $market $symbol of the $market orders were made in
             * @param {int|null} $since the earliest time in ms to fetch orders for
             * @param {int|null} $limit the maximum number of  orde structures to retrieve
             * @param {array} $params extra parameters specific to the bybit api endpoint
             * @return {[array]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure
             */
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $symbol = $market['symbol'];
            $url = $this->get_url_by_market_type($symbol, false, $params);
            $params = $this->clean_params($params);
            $messageHash = 'trade:' . $symbol;
            $topic = 'publicTrade.' . $market['id'];
            $trades = Async\await($this->watch_topics($url, $messageHash, array( $topic ), $params));
            if ($this->newUpdates) {
                $limit = $trades->getLimit ($symbol, $limit);
            }
            return $this->filter_by_since_limit($trades, $since, $limit, 'timestamp', true);
        }) ();
    }

    public function handle_trades(Client $client, $message) {
        //
        //     {
        //         "topic" => "publicTrade.BTCUSDT",
        //         "type" => "snapshot",
        //         "ts" => 1672304486868,
        //         "data" => array(
        //             {
        //                 "T" => 1672304486865,
        //                 "s" => "BTCUSDT",
        //                 "S" => "Buy",
        //                 "v" => "0.001",
        //                 "p" => "16578.50",
        //                 "L" => "PlusTick",
        //                 "i" => "20f43950-d8dd-5b31-9112-a178eb6023af",
        //                 "BT" => false
        //             }
        //         )
        //     }
        //
        $data = $this->safe_value($message, 'data', array());
        $topic = $this->safe_string($message, 'topic');
        $trades = $data;
        $parts = explode('.', $topic);
        $isSpot = mb_strpos($client->url, 'spot') !== false;
        $marketType = ($isSpot) ? 'spot' : 'contract';
        $marketId = $this->safe_string($parts, 1);
        $market = $this->safe_market($marketId, null, null, $marketType);
        $symbol = $market['symbol'];
        $stored = $this->safe_value($this->trades, $symbol);
        if ($stored === null) {
            $limit = $this->safe_integer($this->options, 'tradesLimit', 1000);
            $stored = new ArrayCache ($limit);
            $this->trades[$symbol] = $stored;
        }
        for ($j = 0; $j < count($trades); $j++) {
            $parsed = $this->parse_ws_trade($trades[$j], $market);
            $stored->append ($parsed);
        }
        $messageHash = 'trade' . ':' . $symbol;
        $client->resolve ($stored, $messageHash);
    }

    public function parse_ws_trade($trade, $market = null) {
        //
        // public
        //    {
        //         "T" => 1672304486865,
        //         "s" => "BTCUSDT",
        //         "S" => "Buy",
        //         "v" => "0.001",
        //         "p" => "16578.50",
        //         "L" => "PlusTick",
        //         "i" => "20f43950-d8dd-5b31-9112-a178eb6023af",
        //         "BT" => false
        //     }
        //
        // spot private
        //     {
        //         "e" => "ticketInfo",
        //         "E" => "1662348310386",
        //         "s" => "BTCUSDT",
        //         "q" => "0.001007",
        //         "t" => "1662348310373",
        //         "p" => "19842.02",
        //         "T" => "2100000000002220938",
        //         "o" => "1238261807653647872",
        //         "c" => "spotx008",
        //         "O" => "1238225004531834368",
        //         "a" => "533287",
        //         "A" => "642908",
        //         "m" => false,
        //         "S" => "BUY"
        //     }
        //
        $id = $this->safe_string_n($trade, array( 'i', 'T', 'v' ));
        $isContract = (is_array($trade) && array_key_exists('BT', $trade));
        $marketType = $isContract ? 'contract' : 'spot';
        if ($market !== null) {
            $marketType = $market['type'];
        }
        $marketId = $this->safe_string($trade, 's');
        $market = $this->safe_market($marketId, $market, null, $marketType);
        $symbol = $market['symbol'];
        $timestamp = $this->safe_integer_2($trade, 't', 'T');
        $side = $this->safe_string_lower($trade, 'S');
        $takerOrMaker = null;
        $m = $this->safe_value($trade, 'm');
        if ($side === null) {
            $side = $m ? 'buy' : 'sell';
        } else {
            // spot private
            $takerOrMaker = $m;
        }
        $price = $this->safe_string($trade, 'p');
        $amount = $this->safe_string_2($trade, 'q', 'v');
        $orderId = $this->safe_string($trade, 'o');
        return $this->safe_trade(array(
            'id' => $id,
            'info' => $trade,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'symbol' => $symbol,
            'order' => $orderId,
            'type' => null,
            'side' => $side,
            'takerOrMaker' => $takerOrMaker,
            'price' => $price,
            'amount' => $amount,
            'cost' => null,
            'fee' => null,
        ), $market);
    }

    public function get_private_type($url) {
        if (mb_strpos($url, 'spot') !== false) {
            return 'spot';
        } elseif (mb_strpos($url, 'v5/private') !== false) {
            return 'unified';
        } else {
            return 'usdc';
        }
    }

    public function watch_my_trades(?string $symbol = null, ?int $since = null, ?int $limit = null, $params = array ()) {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            /**
             * watches information on multiple $trades made by the user
             * @see https://bybit-exchange.github.io/docs/v5/websocket/private/execution
             * @param {string} $symbol unified market $symbol of the market orders were made in
             * @param {int|null} $since the earliest time in ms to fetch orders for
             * @param {int|null} $limit the maximum number of  orde structures to retrieve
             * @param {array} $params extra parameters specific to the bybit api endpoint
             * @param {boolean} $params->unifiedMargin use unified margin account
             * @return {[array]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure
             */
            $method = 'watchMyTrades';
            $messageHash = 'myTrades';
            Async\await($this->load_markets());
            if ($symbol !== null) {
                $symbol = $this->symbol($symbol);
                $messageHash .= ':' . $symbol;
            }
            $url = $this->get_url_by_market_type($symbol, true, $method, $params);
            Async\await($this->authenticate($url));
            $topicByMarket = array(
                'spot' => 'ticketInfo',
                'unified' => 'execution',
                'usdc' => 'user.openapi.perp.trade',
            );
            $topic = $this->safe_value($topicByMarket, $this->get_private_type($url));
            $trades = Async\await($this->watch_topics($url, $messageHash, array( $topic ), $params));
            if ($this->newUpdates) {
                $limit = $trades->getLimit ($symbol, $limit);
            }
            return $this->filter_by_since_limit($trades, $since, $limit, 'timestamp', true);
        }) ();
    }

    public function handle_my_trades(Client $client, $message) {
        //
        // $spot
        //    {
        //        "type" => "snapshot",
        //        "topic" => "ticketInfo",
        //        "ts" => "1662348310388",
        //        "data" => array(
        //            {
        //                "e" => "ticketInfo",
        //                "E" => "1662348310386",
        //                "s" => "BTCUSDT",
        //                "q" => "0.001007",
        //                "t" => "1662348310373",
        //                "p" => "19842.02",
        //                "T" => "2100000000002220938",
        //                "o" => "1238261807653647872",
        //                "c" => "spotx008",
        //                "O" => "1238225004531834368",
        //                "a" => "533287",
        //                "A" => "642908",
        //                "m" => false,
        //                "S" => "BUY"
        //            }
        //        )
        //    }
        // unified
        //     {
        //         "id" => "592324803b2785-26fa-4214-9963-bdd4727f07be",
        //         "topic" => "execution",
        //         "creationTime" => 1672364174455,
        //         "data" => array(
        //             {
        //                 "category" => "linear",
        //                 "symbol" => "XRPUSDT",
        //                 "execFee" => "0.005061",
        //                 "execId" => "7e2ae69c-4edf-5800-a352-893d52b446aa",
        //                 "execPrice" => "0.3374",
        //                 "execQty" => "25",
        //                 "execType" => "Trade",
        //                 "execValue" => "8.435",
        //                 "isMaker" => false,
        //                 "feeRate" => "0.0006",
        //                 "tradeIv" => "",
        //                 "markIv" => "",
        //                 "blockTradeId" => "",
        //                 "markPrice" => "0.3391",
        //                 "indexPrice" => "",
        //                 "underlyingPrice" => "",
        //                 "leavesQty" => "0",
        //                 "orderId" => "f6e324ff-99c2-4e89-9739-3086e47f9381",
        //                 "orderLinkId" => "",
        //                 "orderPrice" => "0.3207",
        //                 "orderQty" => "25",
        //                 "orderType" => "Market",
        //                 "stopOrderType" => "UNKNOWN",
        //                 "side" => "Sell",
        //                 "execTime" => "1672364174443",
        //                 "isLeverage" => "0"
        //             }
        //         )
        //     }
        //
        $topic = $this->safe_string($message, 'topic');
        $spot = $topic === 'ticketInfo';
        $data = $this->safe_value($message, 'data', array());
        if (gettype($data) !== 'array' || array_keys($data) !== array_keys(array_keys($data))) {
            $data = $this->safe_value($data, 'result', array());
        }
        if ($this->myTrades === null) {
            $limit = $this->safe_integer($this->options, 'tradesLimit', 1000);
            $this->myTrades = new ArrayCacheBySymbolById ($limit);
        }
        $trades = $this->myTrades;
        $symbols = array();
        $method = $spot ? 'parseWsTrade' : 'parseTrade';
        for ($i = 0; $i < count($data); $i++) {
            $rawTrade = $data[$i];
            $parsed = $this->$method ($rawTrade);
            $symbol = $parsed['symbol'];
            $symbols[$symbol] = true;
            $trades->append ($parsed);
        }
        $keys = is_array($symbols) ? array_keys($symbols) : array();
        for ($i = 0; $i < count($keys); $i++) {
            $messageHash = 'myTrades:' . $keys[$i];
            $client->resolve ($trades, $messageHash);
        }
        // non-$symbol specific
        $messageHash = 'myTrades';
        $client->resolve ($trades, $messageHash);
    }

    public function watch_orders(?string $symbol = null, ?int $since = null, ?int $limit = null, $params = array ()) {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            /**
             * watches information on multiple $orders made by the user
             * @see https://bybit-exchange.github.io/docs/v5/websocket/private/order
             * @param {string|null} $symbol unified market $symbol of the market $orders were made in
             * @param {int|null} $since the earliest time in ms to fetch $orders for
             * @param {int|null} $limit the maximum number of  orde structures to retrieve
             * @param {array} $params extra parameters specific to the bybit api endpoint
             * @return {[array]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure
             */
            Async\await($this->load_markets());
            $method = 'watchOrders';
            $messageHash = 'orders';
            if ($symbol !== null) {
                $symbol = $this->symbol($symbol);
                $messageHash .= ':' . $symbol;
            }
            $url = $this->get_url_by_market_type($symbol, true, $method, $params);
            Async\await($this->authenticate($url));
            $topicsByMarket = array(
                'spot' => array( 'order', 'stopOrder' ),
                'unified' => array( 'order' ),
                'usdc' => array( 'user.openapi.perp.order' ),
            );
            $topics = $this->safe_value($topicsByMarket, $this->get_private_type($url));
            $orders = Async\await($this->watch_topics($url, $messageHash, $topics, $params));
            if ($this->newUpdates) {
                $limit = $orders->getLimit ($symbol, $limit);
            }
            return $this->filter_by_symbol_since_limit($orders, $symbol, $since, $limit);
        }) ();
    }

    public function handle_order(Client $client, $message, $subscription = null) {
        //
        //     spot
        //     {
        //         "type" => "snapshot",
        //         "topic" => "order",
        //         "ts" => "1662348310441",
        //         "data" => array(
        //             {
        //                 "e" => "order",
        //                 "E" => "1662348310441",
        //                 "s" => "BTCUSDT",
        //                 "c" => "spotx008",
        //                 "S" => "BUY",
        //                 "o" => "MARKET_OF_QUOTE",
        //                 "f" => "GTC",
        //                 "q" => "20",
        //                 "p" => "0",
        //                 "X" => "CANCELED",
        //                 "i" => "1238261807653647872",
        //                 "M" => "1238225004531834368",
        //                 "l" => "0.001007",
        //                 "z" => "0.001007",
        //                 "L" => "19842.02",
        //                 "n" => "0",
        //                 "N" => "BTC",
        //                 "u" => true,
        //                 "w" => true,
        //                 "m" => false,
        //                 "O" => "1662348310368",
        //                 "Z" => "19.98091414",
        //                 "A" => "0",
        //                 "C" => false,
        //                 "v" => "0",
        //                 "d" => "NO_LIQ",
        //                 "t" => "2100000000002220938"
        //             }
        //         )
        //     }
        // unified
        //     {
        //         "id" => "5923240c6880ab-c59f-420b-9adb-3639adc9dd90",
        //         "topic" => "order",
        //         "creationTime" => 1672364262474,
        //         "data" => array(
        //             {
        //                 "symbol" => "ETH-30DEC22-1400-C",
        //                 "orderId" => "5cf98598-39a7-459e-97bf-76ca765ee020",
        //                 "side" => "Sell",
        //                 "orderType" => "Market",
        //                 "cancelType" => "UNKNOWN",
        //                 "price" => "72.5",
        //                 "qty" => "1",
        //                 "orderIv" => "",
        //                 "timeInForce" => "IOC",
        //                 "orderStatus" => "Filled",
        //                 "orderLinkId" => "",
        //                 "lastPriceOnCreated" => "",
        //                 "reduceOnly" => false,
        //                 "leavesQty" => "",
        //                 "leavesValue" => "",
        //                 "cumExecQty" => "1",
        //                 "cumExecValue" => "75",
        //                 "avgPrice" => "75",
        //                 "blockTradeId" => "",
        //                 "positionIdx" => 0,
        //                 "cumExecFee" => "0.358635",
        //                 "createdTime" => "1672364262444",
        //                 "updatedTime" => "1672364262457",
        //                 "rejectReason" => "EC_NoError",
        //                 "stopOrderType" => "",
        //                 "triggerPrice" => "",
        //                 "takeProfit" => "",
        //                 "stopLoss" => "",
        //                 "tpTriggerBy" => "",
        //                 "slTriggerBy" => "",
        //                 "triggerDirection" => 0,
        //                 "triggerBy" => "",
        //                 "closeOnTrigger" => false,
        //                 "category" => "option"
        //             }
        //         )
        //     }
        //
        $type = $this->safe_string($message, 'type', '');
        if ($this->orders === null) {
            $limit = $this->safe_integer($this->options, 'ordersLimit', 1000);
            $this->orders = new ArrayCacheBySymbolById ($limit);
        }
        $orders = $this->orders;
        $rawOrders = array();
        $parser = null;
        if ($type === 'snapshot') {
            $rawOrders = $this->safe_value($message, 'data', array());
            $parser = 'parseWsSpotOrder';
        } else {
            $parser = 'parseContractOrder';
            $rawOrders = $this->safe_value($message, 'data', array());
            $rawOrders = $this->safe_value($rawOrders, 'result', $rawOrders);
        }
        $symbols = array();
        for ($i = 0; $i < count($rawOrders); $i++) {
            $parsed = $this->$parser ($rawOrders[$i]);
            $symbol = $parsed['symbol'];
            $symbols[$symbol] = true;
            $orders->append ($parsed);
        }
        $symbolsArray = is_array($symbols) ? array_keys($symbols) : array();
        for ($i = 0; $i < count($symbolsArray); $i++) {
            $messageHash = 'orders:' . $symbolsArray[$i];
            $client->resolve ($orders, $messageHash);
        }
        $messageHash = 'orders';
        $client->resolve ($orders, $messageHash);
    }

    public function parse_ws_spot_order($order, $market = null) {
        //
        //    {
        //        e => 'executionReport',
        //        E => '1653297251061', // $timestamp
        //        s => 'LTCUSDT', // $symbol
        //        c => '1653297250740', // user $id
        //        S => 'SELL', // $side
        //        o => 'MARKET_OF_BASE', // $order $type
        //        f => 'GTC', // time in force
        //        $q => '0.16233', // quantity
        //        p => '0', // $price
        //        X => 'NEW', // $status
        //        i => '1162336018974750208', // $order $id
        //        M => '0',
        //        l => '0', // last $filled
        //        z => '0', // total $filled
        //        L => '0', // last traded $price
        //        n => '0', // trading $fee
        //        N => '', // $fee asset
        //        u => true,
        //        w => true,
        //        m => false, // is limit_maker
        //        O => '1653297251042', // $order creation
        //        Z => '0', // total $filled
        //        A => '0', // account $id
        //        C => false, // is close
        //        v => '0', // leverage
        //        d => 'NO_LIQ'
        //    }
        //
        $id = $this->safe_string($order, 'i');
        $marketId = $this->safe_string($order, 's');
        $symbol = $this->safe_symbol($marketId, $market, null, 'spot');
        $timestamp = $this->safe_integer($order, 'O');
        $price = $this->safe_string($order, 'p');
        if ($price === '0') {
            $price = null; // $market orders
        }
        $filled = $this->safe_string($order, 'z');
        $status = $this->parse_order_status($this->safe_string($order, 'X'));
        $side = $this->safe_string_lower($order, 'S');
        $lastTradeTimestamp = $this->safe_string($order, 'E');
        $timeInForce = $this->safe_string($order, 'f');
        $amount = null;
        $cost = $this->safe_string($order, 'Z');
        $q = $this->safe_string($order, 'q');
        $type = $this->safe_string_lower($order, 'o');
        if (mb_strpos($type, 'quote') !== false) {
            $amount = $filled;
        } else {
            $amount = $q;
        }
        if (mb_strpos($type, 'market') !== false) {
            $type = 'market';
        }
        $fee = null;
        $feeCost = $this->safe_string($order, 'n');
        if ($feeCost !== null && $feeCost !== '0') {
            $feeCurrencyId = $this->safe_string($order, 'N');
            $feeCurrencyCode = $this->safe_currency_code($feeCurrencyId);
            $fee = array(
                'cost' => $feeCost,
                'currency' => $feeCurrencyCode,
            );
        }
        return $this->safe_order(array(
            'info' => $order,
            'id' => $id,
            'clientOrderId' => $this->safe_string($order, 'c'),
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'lastTradeTimestamp' => $lastTradeTimestamp,
            'symbol' => $symbol,
            'type' => $type,
            'timeInForce' => $timeInForce,
            'postOnly' => null,
            'side' => $side,
            'price' => $price,
            'stopPrice' => null,
            'triggerPrice' => null,
            'amount' => $amount,
            'cost' => $cost,
            'average' => null,
            'filled' => $filled,
            'remaining' => null,
            'status' => $status,
            'fee' => $fee,
        ), $market);
    }

    public function watch_balance($params = array ()) {
        return Async\async(function () use ($params) {
            /**
             * query for balance and get the amount of funds available for trading or funds locked in orders
             * @see https://bybit-exchange.github.io/docs/v5/websocket/private/wallet
             * @param {array} $params extra parameters specific to the bybit api endpoint
             * @return {array} a ~@link https://docs.ccxt.com/en/latest/manual.html?#balance-structure balance structure~
             */
            Async\await($this->load_markets());
            $method = 'watchBalance';
            $messageHash = 'balances';
            $type = null;
            list($type, $params) = $this->handle_market_type_and_params('watchBalance', null, $params);
            $subType = null;
            list($subType, $params) = $this->handle_sub_type_and_params('watchBalance', null, $params);
            $unified = Async\await($this->isUnifiedEnabled ());
            $isUnifiedMargin = $this->safe_value($unified, 0, false);
            $isUnifiedAccount = $this->safe_value($unified, 1, false);
            $url = $this->get_url_by_market_type(null, true, $method, $params);
            Async\await($this->authenticate($url));
            $topicByMarket = array(
                'spot' => 'outboundAccountInfo',
                'unified' => 'wallet',
            );
            if ($isUnifiedAccount) {
                // $unified account
                if ($subType === 'inverse') {
                    $messageHash .= ':contract';
                } else {
                    $messageHash .= ':unified';
                }
            }
            if (!$isUnifiedMargin && !$isUnifiedAccount) {
                // normal account using v5
                if ($type === 'spot') {
                    $messageHash .= ':spot';
                } else {
                    $messageHash .= ':contract';
                }
            }
            if ($isUnifiedMargin) {
                // $unified margin account using v5
                if ($type === 'spot') {
                    $messageHash .= ':spot';
                } else {
                    if ($subType === 'linear') {
                        $messageHash .= ':unified';
                    } else {
                        $messageHash .= ':contract';
                    }
                }
            }
            $topics = array( $this->safe_value($topicByMarket, $this->get_private_type($url)) );
            return Async\await($this->watch_topics($url, $messageHash, $topics, $params));
        }) ();
    }

    public function handle_balance(Client $client, $message) {
        //
        // spot
        //    {
        //        "type" => "snapshot",
        //        "topic" => "outboundAccountInfo",
        //        "ts" => "1662107217641",
        //        "data" => array(
        //            {
        //                "e" => "outboundAccountInfo",
        //                "E" => "1662107217640",
        //                "T" => true,
        //                "W" => true,
        //                "D" => true,
        //                "B" => array(
        //                    {
        //                        "a" => "USDT",
        //                        "f" => "176.81254174",
        //                        "l" => "201.575"
        //                    }
        //                )
        //            }
        //        )
        //    }
        // unified
        //     {
        //         "id" => "5923242c464be9-25ca-483d-a743-c60101fc656f",
        //         "topic" => "wallet",
        //         "creationTime" => 1672364262482,
        //         "data" => array(
        //             {
        //                 "accountIMRate" => "0.016",
        //                 "accountMMRate" => "0.003",
        //                 "totalEquity" => "12837.78330098",
        //                 "totalWalletBalance" => "12840.4045924",
        //                 "totalMarginBalance" => "12837.78330188",
        //                 "totalAvailableBalance" => "12632.05767702",
        //                 "totalPerpUPL" => "-2.62129051",
        //                 "totalInitialMargin" => "205.72562486",
        //                 "totalMaintenanceMargin" => "39.42876721",
        //                 "coin" => array(
        //                     array(
        //                         "coin" => "USDC",
        //                         "equity" => "200.62572554",
        //                         "usdValue" => "200.62572554",
        //                         "walletBalance" => "201.34882644",
        //                         "availableToWithdraw" => "0",
        //                         "availableToBorrow" => "1500000",
        //                         "borrowAmount" => "0",
        //                         "accruedInterest" => "0",
        //                         "totalOrderIM" => "0",
        //                         "totalPositionIM" => "202.99874213",
        //                         "totalPositionMM" => "39.14289747",
        //                         "unrealisedPnl" => "74.2768991",
        //                         "cumRealisedPnl" => "-209.1544627",
        //                         "bonus" => "0"
        //                     ),
        //                     array(
        //                         "coin" => "BTC",
        //                         "equity" => "0.06488393",
        //                         "usdValue" => "1023.08402268",
        //                         "walletBalance" => "0.06488393",
        //                         "availableToWithdraw" => "0.06488393",
        //                         "availableToBorrow" => "2.5",
        //                         "borrowAmount" => "0",
        //                         "accruedInterest" => "0",
        //                         "totalOrderIM" => "0",
        //                         "totalPositionIM" => "0",
        //                         "totalPositionMM" => "0",
        //                         "unrealisedPnl" => "0",
        //                         "cumRealisedPnl" => "0",
        //                         "bonus" => "0"
        //                     ),
        //                     array(
        //                         "coin" => "ETH",
        //                         "equity" => "0",
        //                         "usdValue" => "0",
        //                         "walletBalance" => "0",
        //                         "availableToWithdraw" => "0",
        //                         "availableToBorrow" => "26",
        //                         "borrowAmount" => "0",
        //                         "accruedInterest" => "0",
        //                         "totalOrderIM" => "0",
        //                         "totalPositionIM" => "0",
        //                         "totalPositionMM" => "0",
        //                         "unrealisedPnl" => "0",
        //                         "cumRealisedPnl" => "0",
        //                         "bonus" => "0"
        //                     ),
        //                     array(
        //                         "coin" => "USDT",
        //                         "equity" => "11726.64664904",
        //                         "usdValue" => "11613.58597018",
        //                         "walletBalance" => "11728.54414904",
        //                         "availableToWithdraw" => "11723.92075829",
        //                         "availableToBorrow" => "2500000",
        //                         "borrowAmount" => "0",
        //                         "accruedInterest" => "0",
        //                         "totalOrderIM" => "0",
        //                         "totalPositionIM" => "2.72589075",
        //                         "totalPositionMM" => "0.28576575",
        //                         "unrealisedPnl" => "-1.8975",
        //                         "cumRealisedPnl" => "0.64782276",
        //                         "bonus" => "0"
        //                     ),
        //                     array(
        //                         "coin" => "EOS3L",
        //                         "equity" => "215.0570412",
        //                         "usdValue" => "0",
        //                         "walletBalance" => "215.0570412",
        //                         "availableToWithdraw" => "215.0570412",
        //                         "availableToBorrow" => "0",
        //                         "borrowAmount" => "0",
        //                         "accruedInterest" => "",
        //                         "totalOrderIM" => "0",
        //                         "totalPositionIM" => "0",
        //                         "totalPositionMM" => "0",
        //                         "unrealisedPnl" => "0",
        //                         "cumRealisedPnl" => "0",
        //                         "bonus" => "0"
        //                     ),
        //                     {
        //                         "coin" => "BIT",
        //                         "equity" => "1.82",
        //                         "usdValue" => "0.48758257",
        //                         "walletBalance" => "1.82",
        //                         "availableToWithdraw" => "1.82",
        //                         "availableToBorrow" => "0",
        //                         "borrowAmount" => "0",
        //                         "accruedInterest" => "",
        //                         "totalOrderIM" => "0",
        //                         "totalPositionIM" => "0",
        //                         "totalPositionMM" => "0",
        //                         "unrealisedPnl" => "0",
        //                         "cumRealisedPnl" => "0",
        //                         "bonus" => "0"
        //                     }
        //                 ),
        //                 "accountType" => "UNIFIED"
        //             }
        //         )
        //     }
        //
        if ($this->balance === null) {
            $this->balance = array();
        }
        $messageHash = 'balance';
        $topic = $this->safe_value($message, 'topic');
        $info = null;
        $rawBalances = array();
        $account = null;
        if ($topic === 'outboundAccountInfo') {
            $account = 'spot';
            $data = $this->safe_value($message, 'data', array());
            for ($i = 0; $i < count($data); $i++) {
                $B = $this->safe_value($data[$i], 'B', array());
                $rawBalances = $this->array_concat($rawBalances, $B);
            }
            $info = $rawBalances;
        }
        if ($topic === 'wallet') {
            $data = $this->safe_value($message, 'data', array());
            for ($i = 0; $i < count($data); $i++) {
                $result = $this->safe_value($data, 0, array());
                $account = $this->safe_string_lower($result, 'accountType');
                $rawBalances = $this->array_concat($rawBalances, $this->safe_value($result, 'coin', array()));
            }
            $info = $data;
        }
        for ($i = 0; $i < count($rawBalances); $i++) {
            $this->parse_ws_balance($rawBalances[$i], $account);
        }
        if ($account !== null) {
            if ($this->safe_value($this->balance, $account) === null) {
                $this->balance[$account] = array();
            }
            $this->balance[$account]['info'] = $info;
            $timestamp = $this->safe_integer($message, 'ts');
            $this->balance[$account]['timestamp'] = $timestamp;
            $this->balance[$account]['datetime'] = $this->iso8601($timestamp);
            $this->balance[$account] = $this->safe_balance($this->balance[$account]);
            $messageHash = 'balances:' . $account;
            $client->resolve ($this->balance[$account], $messageHash);
        } else {
            $this->balance['info'] = $info;
            $timestamp = $this->safe_integer($message, 'ts');
            $this->balance['timestamp'] = $timestamp;
            $this->balance['datetime'] = $this->iso8601($timestamp);
            $this->balance = $this->safe_balance($this->balance);
            $messageHash = 'balances';
            $client->resolve ($this->balance, $messageHash);
        }
    }

    public function parse_ws_balance($balance, $accountType = null) {
        //
        // spot
        //    {
        //        "a" => "USDT",
        //        "f" => "176.81254174",
        //        "l" => "201.575"
        //    }
        // unified
        //     {
        //         "coin" => "BTC",
        //         "equity" => "0.06488393",
        //         "usdValue" => "1023.08402268",
        //         "walletBalance" => "0.06488393",
        //         "availableToWithdraw" => "0.06488393",
        //         "availableToBorrow" => "2.5",
        //         "borrowAmount" => "0",
        //         "accruedInterest" => "0",
        //         "totalOrderIM" => "0",
        //         "totalPositionIM" => "0",
        //         "totalPositionMM" => "0",
        //         "unrealisedPnl" => "0",
        //         "cumRealisedPnl" => "0",
        //         "bonus" => "0"
        //     }
        //
        $account = $this->account();
        $currencyId = $this->safe_string_2($balance, 'a', 'coin');
        $code = $this->safe_currency_code($currencyId);
        $account['free'] = $this->safe_string_n($balance, array( 'availableToWithdraw', 'f', 'free', 'availableToWithdraw' ));
        $account['used'] = $this->safe_string_2($balance, 'l', 'locked');
        $account['total'] = $this->safe_string($balance, 'walletBalance');
        if ($accountType !== null) {
            if ($this->safe_value($this->balance, $accountType) === null) {
                $this->balance[$accountType] = array();
            }
            $this->balance[$accountType][$code] = $account;
        } else {
            $this->balance[$code] = $account;
        }
    }

    public function watch_topics($url, $messageHash, $topics = [], $params = array ()) {
        return Async\async(function () use ($url, $messageHash, $topics, $params) {
            $request = array(
                'op' => 'subscribe',
                'req_id' => $this->request_id(),
                'args' => $topics,
            );
            $message = array_merge($request, $params);
            return Async\await($this->watch($url, $messageHash, $message, $messageHash));
        }) ();
    }

    public function authenticate($url, $params = array ()) {
        $this->check_required_credentials();
        $messageHash = 'authenticated';
        $client = $this->client($url);
        $future = $this->safe_value($client->subscriptions, $messageHash);
        if ($future === null) {
            $expiresInt = $this->milliseconds() + 10000;
            $expires = (string) $expiresInt;
            $path = 'GET/realtime';
            $auth = $path . $expires;
            $signature = $this->hmac($this->encode($auth), $this->encode($this->secret), 'sha256', 'hex');
            $request = array(
                'op' => 'auth',
                'args' => array(
                    $this->apiKey, $expires, $signature,
                ),
            );
            $message = array_merge($request, $params);
            $future = $this->watch($url, $messageHash, $message);
            $client->subscriptions[$messageHash] = $future;
        }
        return $future;
    }

    public function handle_error_message(Client $client, $message) {
        //
        //   {
        //       $success => false,
        //       $ret_msg => 'error:invalid op',
        //       conn_id => '5e079fdd-9c7f-404d-9dbf-969d650838b5',
        //       $request => array( $op => '', args => null )
        //   }
        //
        // auth $error
        //
        //   {
        //       $success => false,
        //       $ret_msg => 'error:USVC1111',
        //       conn_id => 'e73770fb-a0dc-45bd-8028-140e20958090',
        //       $request => {
        //         $op => 'auth',
        //         args => array(
        //           '9rFT6uR4uz9Imkw4Wx',
        //           '1653405853543',
        //           '542e71bd85597b4db0290f0ce2d13ed1fd4bb5df3188716c1e9cc69a879f7889'
        //         )
        //   }
        //
        //   array( $code => '-10009', desc => 'Invalid period!' )
        //
        $code = $this->safe_string_2($message, 'code', 'ret_code');
        try {
            if ($code !== null) {
                $feedback = $this->id . ' ' . $this->json($message);
                $this->throw_exactly_matched_exception($this->exceptions['exact'], $code, $feedback);
            }
            $success = $this->safe_value($message, 'success');
            if ($success !== null && !$success) {
                $ret_msg = $this->safe_string($message, 'ret_msg');
                $request = $this->safe_value($message, 'request', array());
                $op = $this->safe_string($request, 'op');
                if ($op === 'auth') {
                    throw new AuthenticationError('Authentication failed => ' . $ret_msg);
                } else {
                    throw new ExchangeError($this->id . ' ' . $ret_msg);
                }
            }
            return false;
        } catch (Exception $error) {
            if ($error instanceof AuthenticationError) {
                $messageHash = 'authenticated';
                $client->reject ($error, $messageHash);
                if (is_array($client->subscriptions) && array_key_exists($messageHash, $client->subscriptions)) {
                    unset($client->subscriptions[$messageHash]);
                }
            } else {
                $client->reject ($error);
            }
            return true;
        }
    }

    public function handle_message(Client $client, $message) {
        if ($this->handle_error_message($client, $message)) {
            return;
        }
        // contract $pong
        $ret_msg = $this->safe_string($message, 'ret_msg');
        if ($ret_msg === 'pong') {
            $this->handle_pong($client, $message);
            return;
        }
        // spot $pong
        $pong = $this->safe_integer($message, 'pong');
        if ($pong !== null) {
            $this->handle_pong($client, $message);
            return;
        }
        // $pong
        $op = $this->safe_string($message, 'op');
        if ($op === 'pong') {
            $this->handle_pong($client, $message);
            return;
        }
        $event = $this->safe_string($message, 'event');
        if ($event === 'sub') {
            $this->handle_subscription_status($client, $message);
            return;
        }
        $topic = $this->safe_string($message, 'topic', '');
        $methods = array(
            'orderbook' => array($this, 'handle_order_book'),
            'kline' => array($this, 'handle_ohlcv'),
            'order' => array($this, 'handle_order'),
            'stopOrder' => array($this, 'handle_order'),
            'ticker' => array($this, 'handle_ticker'),
            'trade' => array($this, 'handle_trades'),
            'publicTrade' => array($this, 'handle_trades'),
            'depth' => array($this, 'handle_order_book'),
            'wallet' => array($this, 'handle_balance'),
            'outboundAccountInfo' => array($this, 'handle_balance'),
            'execution' => array($this, 'handle_my_trades'),
            'ticketInfo' => array($this, 'handle_my_trades'),
            'user.openapi.perp.trade' => array($this, 'handle_my_trades'),
        );
        $exacMethod = $this->safe_value($methods, $topic);
        if ($exacMethod !== null) {
            $exacMethod($client, $message);
            return;
        }
        $keys = is_array($methods) ? array_keys($methods) : array();
        for ($i = 0; $i < count($keys); $i++) {
            $key = $keys[$i];
            if (mb_strpos($topic, $keys[$i]) !== false) {
                $method = $methods[$key];
                $method($client, $message);
                return;
            }
        }
        // unified auth acknowledgement
        $type = $this->safe_string($message, 'type');
        if (($op === 'auth') || ($type === 'AUTH_RESP')) {
            $this->handle_authenticate($client, $message);
        }
    }

    public function ping($client) {
        return array(
            'req_id' => $this->request_id(),
            'op' => 'ping',
        );
    }

    public function handle_pong(Client $client, $message) {
        //
        //   {
        //       success => true,
        //       ret_msg => 'pong',
        //       conn_id => 'db3158a0-8960-44b9-a9de-ac350ee13158',
        //       request => array( op => 'ping', args => null )
        //   }
        //
        //   array( pong => 1653296711335 )
        //
        $client->lastPong = $this->safe_integer($message, 'pong');
        return $message;
    }

    public function handle_authenticate(Client $client, $message) {
        //
        //    {
        //        $success => true,
        //        ret_msg => '',
        //        op => 'auth',
        //        conn_id => 'ce3dpomvha7dha97tvp0-2xh'
        //    }
        //
        $success = $this->safe_value($message, 'success');
        $messageHash = 'authenticated';
        if ($success) {
            $client->resolve ($message, $messageHash);
        } else {
            $error = new AuthenticationError ($this->id . ' ' . $this->json($message));
            $client->reject ($error, $messageHash);
            if (is_array($client->subscriptions) && array_key_exists($messageHash, $client->subscriptions)) {
                unset($client->subscriptions[$messageHash]);
            }
        }
        return $message;
    }

    public function handle_subscription_status(Client $client, $message) {
        //
        //    {
        //        topic => 'kline',
        //        event => 'sub',
        //        params => array(
        //          symbol => 'LTCUSDT',
        //          binary => 'false',
        //          klineType => '1m',
        //          symbolName => 'LTCUSDT'
        //        ),
        //        code => '0',
        //        msg => 'Success'
        //    }
        //
        return $message;
    }
}
