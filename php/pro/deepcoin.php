<?php

namespace ccxt\pro;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

use Exception; // a common import
use ccxt\ExchangeError;
use ccxt\BadRequest;
use \React\Async;
use \React\Promise\PromiseInterface;

class deepcoin extends \ccxt\async\deepcoin {

    public function describe(): mixed {
        return $this->deep_extend(parent::describe(), array(
            'has' => array(
                'ws' => true,
                'watchTicker' => true,
                'watchMarkPrice' => false,
                'watchMarkPrices' => false,
                'watchTickers' => false,
                'watchBidsAsks' => false,
                'watchOrderBook' => true,
                'watchTrades' => true,
                'watchTradesForSymbols' => false,
                'watchOrderBookForSymbols' => false,
                'watchBalance' => false,
                'watchLiquidations' => false,
                'watchLiquidationsForSymbols' => false,
                'watchMyLiquidations' => false,
                'watchMyLiquidationsForSymbols' => false,
                'watchOHLCV' => true,
                'watchOHLCVForSymbols' => false,
                'watchOrders' => true,
                'watchMyTrades' => true,
                'watchPositions' => true,
                'watchFundingRate' => false,
                'watchFundingRates' => false,
                'createOrderWs' => false,
                'editOrderWs' => false,
                'cancelOrderWs' => false,
                'cancelOrdersWs' => false,
                'cancelAllOrdersWs' => false,
                'unWatchTicker' => true,
                'unWatchTrades' => true,
                'unWatchOHLCV' => true,
                'unWatchOrderBook' => true,
            ),
            'urls' => array(
                'api' => array(
                    'ws' => array(
                        'public' => array(
                            'spot' => 'wss://stream.deepcoin.com/streamlet/trade/public/spot?platform=api',
                            'swap' => 'wss://stream.deepcoin.com/streamlet/trade/public/swap?platform=api',
                        ),
                        'private' => 'wss://stream.deepcoin.com/v1/private',
                    ),
                ),
            ),
            'options' => array(
                'lastRequestId' => null,
                'listenKey' => null,
                'listenKeyExpiryTimestamp' => null,
                'authenticate' => array(
                    'method' => 'privateGetDeepcoinListenkeyExtend', // refresh existing listen key or 'privateGetDeepcoinListenkeyAcquire' - get a new one
                ),
                'timeframes' => array(
                    '1m' => '1m',
                    '5m' => '5m',
                    '15m' => '15m',
                    '30m' => '30m',
                    '1h' => '1h',
                    '4h' => '4h',
                    '12h' => '12h',
                    '1d' => '1d',
                    '1w' => '1w',
                    '1M' => '1o',
                    '1y' => '1y',
                ),
            ),
            'streaming' => array(
                'ping' => array($this, 'ping'),
            ),
        ));
    }

    public function ping(Client $client) {
        $url = $client->url;
        if (mb_strpos($url, 'private') !== false) {
            $client->lastPong = $this->milliseconds();
            // prevent automatic disconnects on private channel
        }
        return 'ping';
    }

    public function handle_pong(Client $client, $message) {
        $client->lastPong = $this->milliseconds();
        return $message;
    }

    public function request_id() {
        $this->lock_id();
        $previousValue = $this->safe_integer($this->options, 'lastRequestId', 0);
        $newValue = $this->sum($previousValue, 1);
        $this->options['lastRequestId'] = $newValue;
        $this->unlock_id();
        return $newValue;
    }

    public function create_public_request(array $market, float $requestId, string $topicID, string $suffix = '', bool $unWatch = false) {
        $marketId = $market['symbol']; // spot markets use symbol with slash
        if ($market['type'] === 'swap') {
            $marketId = $market['baseId'] . $market['quoteId']; // swap markets use symbol without slash
        }
        $action = '1'; // subscribe
        if ($unWatch) {
            $action = '0'; // unsubscribe
        }
        $request = array(
            'sendTopicAction' => array(
                'Action' => $action,
                'FilterValue' => 'DeepCoin_' . $marketId . $suffix,
                'LocalNo' => $requestId,
                'ResumeNo' => -1, // -1 from the end, 0 from the beginning
                'TopicID' => $topicID,
            ),
        );
        return $request;
    }

    public function watch_public(array $market, string $messageHash, string $topicID, array $params = array (), string $suffix = ''): PromiseInterface {
        return Async\async(function () use ($market, $messageHash, $topicID, $params, $suffix) {
            $url = $this->urls['api']['ws']['public'][$market['type']];
            $requestId = $this->request_id();
            $request = $this->create_public_request($market, $requestId, $topicID, $suffix);
            $subscription = array(
                'subHash' => $messageHash,
                'id' => $requestId,
            );
            return Async\await($this->watch($url, $messageHash, $this->deep_extend($request, $params), $messageHash, $subscription));
        }) ();
    }

    public function un_watch_public(array $market, string $messageHash, string $topicID, array $params = array (), array $subscription = array (), string $suffix = ''): PromiseInterface {
        return Async\async(function () use ($market, $messageHash, $topicID, $params, $subscription, $suffix) {
            $url = $this->urls['api']['ws']['public'][$market['type']];
            $requestId = $this->request_id();
            $client = $this->client($url);
            $existingSubscription = $this->safe_dict($client->subscriptions, $messageHash);
            if ($existingSubscription === null) {
                throw new BadRequest($this->id . ' no $subscription for ' . $messageHash);
            }
            $subId = $this->safe_integer($existingSubscription, 'id');
            $request = $this->create_public_request($market, $subId, $topicID, $suffix, true); // unsubscribe message uses the same id original subscribe message
            $unsubHash = 'unsubscribe::' . $messageHash;
            $subscription = $this->extend($subscription, array(
                'subHash' => $messageHash,
                'unsubHash' => $unsubHash,
                'symbols' => [ $market['symbol'] ],
                'id' => $requestId,
            ));
            return Async\await($this->watch($url, $unsubHash, $this->deep_extend($request, $params), $unsubHash, $subscription));
        }) ();
    }

    public function watch_private(string $messageHash, array $params = array ()): PromiseInterface {
        return Async\async(function () use ($messageHash, $params) {
            $listenKey = Async\await($this->authenticate());
            $url = $this->urls['api']['ws']['private'] . '?$listenKey=' . $listenKey;
            return Async\await($this->watch($url, $messageHash, null, 'private', $params));
        }) ();
    }

    public function authenticate($params = array ()) {
        return Async\async(function () use ($params) {
            $this->check_required_credentials();
            $time = $this->milliseconds();
            $listenKeyExpiryTimestamp = $this->safe_integer($this->options, 'listenKeyExpiryTimestamp', $time);
            $expired = ($time - $listenKeyExpiryTimestamp) > 60000; // 1 minute before expiry
            $listenKey = $this->safe_string($this->options, 'listenKey');
            $response = null;
            if ($listenKey === null) {
                $response = Async\await($this->privateGetDeepcoinListenkeyAcquire ($params));
            } elseif ($expired) {
                $method = $this->safe_string($this->options, 'method', 'privateGetDeepcoinListenkeyExtend');
                $getNewKey = ($method === 'privateGetDeepcoinListenkeyAcquire');
                if ($getNewKey) {
                    $response = Async\await($this->privateGetDeepcoinListenkeyAcquire ($params));
                } else {
                    $request = array(
                        'listenkey' => $listenKey,
                    );
                    $response = Async\await($this->privateGetDeepcoinListenkeyExtend ($this->extend($request, $params)));
                }
            }
            if ($response !== null) {
                $data = $this->safe_dict($response, 'data', array());
                $listenKey = $this->safe_string($data, 'listenkey');
                $listenKeyExpiryTimestamp = $this->safe_timestamp($data, 'expire_time');
                $this->options['listenKey'] = $listenKey;
                $this->options['listenKeyExpiryTimestamp'] = $listenKeyExpiryTimestamp;
            }
            return $listenKey;
        }) ();
    }

    public function watch_ticker(string $symbol, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $params) {
            /**
             * watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific $market
             *
             * @see https://www.deepcoin.com/docs/publicWS/latestMarketData
             *
             * @param {string} $symbol unified $symbol of the $market to fetch the ticker for
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} a ~@link https://docs.ccxt.com/?id=ticker-structure ticker structure~
             */
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $messageHash = 'ticker' . '::' . $market['symbol'];
            return Async\await($this->watch_public($market, $messageHash, '7', $params));
        }) ();
    }

    public function un_watch_ticker(string $symbol, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $params) {
            /**
             * unWatches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific $market
             *
             * @see https://www.deepcoin.com/docs/publicWS/latestMarketData
             *
             * @param {string} $symbol unified $symbol of the $market to fetch the ticker for
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} a ~@link https://docs.ccxt.com/?id=ticker-structure ticker structure~
             */
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $messageHash = 'ticker' . '::' . $market['symbol'];
            $subscription = array(
                'topic' => 'ticker',
            );
            return Async\await($this->un_watch_public($market, $messageHash, '7', $params, $subscription));
        }) ();
    }

    public function handle_ticker(Client $client, $message) {
        //
        //     a => 'PO',
        //     m => 'Success',
        //     tt => 1760913034780,
        //     mt => 1760913034780,
        //     r => array(
        //         {
        //             d => {
        //                 I => 'BTC/USDT',
        //                 U => 1760913034742,
        //                 PF => 0,
        //                 E => 0,
        //                 O => 108479.9,
        //                 H => 109449.9,
        //                 L => 108238,
        //                 V => 789.3424915,
        //                 T => 43003872.3705223,
        //                 N => 109345,
        //                 M => 87294.7,
        //                 D => 0,
        //                 V2 => 3086.4496105,
        //                 T2 => 332811624.339836,
        //                 F => 0,
        //                 C => 0,
        //                 BP1 => 109344.9,
        //                 AP1 => 109345.2
        //             }
        //         }
        //     )
        //
        $response = $this->safe_list($message, 'r', array());
        $first = $this->safe_dict($response, 0, array());
        $data = $this->safe_dict($first, 'd', array());
        $marketId = $this->safe_string($data, 'I');
        $market = $this->safe_market($marketId, null, '/');
        $symbol = $this->safe_symbol($marketId, $market);
        $parsedTicker = $this->parse_ws_ticker($data, $market);
        $messageHash = 'ticker' . '::' . $symbol;
        $this->tickers[$symbol] = $parsedTicker;
        $client->resolve ($parsedTicker, $messageHash);
    }

    public function parse_ws_ticker(array $ticker, ?array $market = null): array {
        //
        //     {
        //         I => 'BTC/USDT',
        //         U => 1760913034742,
        //         PF => 0,
        //         E => 0,
        //         O => 108479.9,
        //         H => 109449.9,
        //         L => 108238,
        //         V => 789.3424915,
        //         T => 43003872.3705223,
        //         N => 109345,
        //         M => 87294.7,
        //         D => 0,
        //         V2 => 3086.4496105,
        //         T2 => 332811624.339836,
        //         F => 0,
        //         C => 0,
        //         BP1 => 109344.9,
        //         AP1 => 109345.2
        //     }
        //
        $timestamp = $this->safe_integer($ticker, 'U');
        $high = $this->safe_number($ticker, 'H');
        $low = $this->safe_number($ticker, 'L');
        $open = $this->safe_number($ticker, 'O');
        $last = $this->safe_number($ticker, 'N');
        $bid = $this->safe_number($ticker, 'BP1');
        $ask = $this->safe_number($ticker, 'AP1');
        $baseVolume = $this->safe_number($ticker, 'V');
        $quoteVolume = $this->safe_number($ticker, 'T');
        if ($market['inverse']) {
            $temp = $baseVolume;
            $baseVolume = $quoteVolume;
            $quoteVolume = $temp;
        }
        return $this->safe_ticker(array(
            'symbol' => $market['symbol'],
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'high' => $high,
            'low' => $low,
            'bid' => $bid,
            'bidVolume' => null,
            'ask' => $ask,
            'askVolume' => null,
            'vwap' => null,
            'open' => $open,
            'close' => $last,
            'last' => $last,
            'previousClose' => null,
            'change' => null,
            'percentage' => null,
            'average' => null,
            'baseVolume' => $baseVolume,
            'quoteVolume' => $quoteVolume,
            'info' => $ticker,
        ), $market);
    }

    public function watch_trades(string $symbol, ?int $since = null, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            /**
             * watches information on multiple $trades made in a $market
             *
             * @see https://www.deepcoin.com/docs/publicWS/lastTransactions
             *
             * @param {string} $symbol unified $market $symbol of the $market $trades were made in
             * @param {int} [$since] the earliest time in ms to fetch orders for
             * @param {int} [$limit] the maximum number of trade structures to retrieve
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array[]} a list of ~@link https://docs.ccxt.com/?id=trade-structure trade structures~
             */
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $messageHash = 'trades' . '::' . $market['symbol'];
            $trades = Async\await($this->watch_public($market, $messageHash, '2', $params));
            if ($this->newUpdates) {
                $limit = $trades->getLimit ($symbol, $limit);
            }
            return $this->filter_by_since_limit($trades, $since, $limit, 'timestamp', true);
        }) ();
    }

    public function un_watch_trades(string $symbol, $params = array ()) {
        return Async\async(function () use ($symbol, $params) {
            /**
             * unWatches the list of most recent trades for a particular $symbol
             *
             * @see https://www.deepcoin.com/docs/publicWS/lastTransactions
             *
             * @param {string} $symbol unified $symbol of the $market to fetch trades for
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array[]} a list of ~@link https://docs.ccxt.com/?id=public-trades trade structures~
             */
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $messageHash = 'trades' . '::' . $market['symbol'];
            $subscription = array(
                'topic' => 'trades',
            );
            return Async\await($this->un_watch_public($market, $messageHash, '2', $params, $subscription));
        }) ();
    }

    public function handle_trades(Client $client, $message) {
        //
        //     {
        //         "a" => "PMT",
        //         "b" => 0,
        //         "tt" => 1760968672380,
        //         "mt" => 1760968672380,
        //         "r" => array(
        //             {
        //                 "d" => {
        //                     "TradeID" => "1001056452325378",
        //                     "I" => "BTC/USDT",
        //                     "D" => "1",
        //                     "P" => 111061,
        //                     "V" => 0.00137,
        //                     "T" => 1760968672
        //                 }
        //             }
        //         )
        //     }
        //
        $response = $this->safe_list($message, 'r', array());
        $first = $this->safe_dict($response, 0, array());
        $data = $this->safe_dict($first, 'd', array());
        $marketId = $this->safe_string($data, 'I');
        $market = $this->safe_market($marketId, null, '/');
        $symbol = $this->safe_symbol($marketId, $market);
        if (!(is_array($this->trades) && array_key_exists($symbol, $this->trades))) {
            $limit = $this->safe_integer($this->options, 'tradesLimit', 1000);
            $this->trades[$symbol] = new ArrayCache ($limit);
        }
        $strored = $this->trades[$symbol];
        if ($data !== null) {
            $trade = $this->parse_ws_trade($data, $market);
            $strored->append ($trade);
        }
        $messageHash = 'trades' . '::' . $symbol;
        $client->resolve ($strored, $messageHash);
    }

    public function parse_ws_trade(array $trade, ?array $market = null): array {
        //
        // watchTrades
        //     {
        //         "TradeID" => "1001056452325378",
        //         "I" => "BTC/USDT",
        //         "D" => "1",
        //         "P" => 111061,
        //         "V" => 0.00137,
        //         "T" => 1760968672
        //     }
        //
        // watchMyTrades
        //     {
        //         "A" => "9256245",
        //         "CC" => "USDT",
        //         "CP" => 0,
        //         "D" => "0",
        //         "F" => 0.152,
        //         "I" => "DOGE/USDT",
        //         "IT" => 1761048103,
        //         "M" => "9256245",
        //         "OS" => "1001437462198486",
        //         "P" => 0.19443,
        //         "T" => 14.77668,
        //         "TI" => "1001056459096708",
        //         "TT" => 1761048103,
        //         "V" => 76,
        //         "f" => "DOGE",
        //         "l" => 1,
        //         "m" => "1",
        //         "o" => "0"
        //     }
        //
        $direction = $this->safe_string($trade, 'D');
        $timestamp = $this->safe_timestamp_2($trade, 'TT', 'T');
        $matchRole = $this->safe_string($trade, 'm');
        $fee = null;
        $feeCost = $this->safe_string($trade, 'F');
        if ($feeCost !== null) {
            $fee = array(
                'cost' => $feeCost,
                'currency' => $this->safe_currency_code($this->safe_string($trade, 'f')),
            );
        }
        return $this->safe_trade(array(
            'info' => $trade,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'symbol' => $market['symbol'],
            'id' => $this->safe_string_2($trade, 'TradeID', 'TI'),
            'order' => $this->safe_string($trade, 'OS'),
            'type' => null,
            'takerOrMaker' => $this->handle_taker_or_maker($matchRole),
            'side' => $this->parse_trade_side($direction),
            'price' => $this->safe_string($trade, 'P'),
            'amount' => $this->safe_string($trade, 'V'),
            'cost' => $this->safe_string($trade, 'T'),
            'fee' => $fee,
        ), $market);
    }

    public function parse_trade_side(?string $direction): ?string {
        $sides = array(
            '0' => 'buy',
            '1' => 'sell',
        );
        return $this->safe_string($sides, $direction, $direction);
    }

    public function handle_taker_or_maker(?string $matchRole): ?string {
        $roles = array(
            '0' => 'maker',
            '1' => 'taker',
        );
        return $this->safe_string($roles, $matchRole, $matchRole);
    }

    public function watch_ohlcv(string $symbol, string $timeframe = '1m', ?int $since = null, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $timeframe, $since, $limit, $params) {
            /**
             * watches historical candlestick data containing the open, high, low, and close price, and the volume of a $market
             *
             * @see https://www.deepcoin.com/docs/publicWS/KLines
             *
             * @param {string} $symbol unified $symbol of the $market to fetch OHLCV data for
             * @param {string} [$timeframe] the length of time each candle represents
             * @param {int} [$since] timestamp in ms of the earliest candle to fetch
             * @param {int} [$limit] the maximum amount of candles to fetch
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {int[][]} A list of candles ordered, open, high, low, close, volume
             */
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $symbol = $market['symbol'];
            $timeframes = $this->safe_dict($this->options, 'timeframes', array());
            $interval = $this->safe_string($timeframes, $timeframe, $timeframe);
            $messageHash = 'ohlcv' . '::' . $symbol . '::' . $timeframe;
            $suffix = '_' . $interval;
            $ohlcv = Async\await($this->watch_public($market, $messageHash, '11', $params, $suffix));
            if ($this->newUpdates) {
                $limit = $ohlcv->getLimit ($symbol, $limit);
            }
            return $this->filter_by_since_limit($ohlcv, $since, $limit, 0, true);
        }) ();
    }

    public function un_watch_ohlcv(string $symbol, string $timeframe = '1m', $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $timeframe, $params) {
            /**
             * watches historical candlestick data containing the open, high, low, and close price, and the volume of a $market
             *
             * @see https://docs.backpack.exchange/#tag/Streams/Public/K-Line
             *
             * @param {string} $symbol unified $symbol of the $market to fetch OHLCV data for
             * @param {string} [$timeframe] the length of time each candle represents
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {int[][]} A list of candles ordered, open, high, low, close, volume
             */
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $symbol = $market['symbol'];
            $timeframes = $this->safe_dict($this->options, 'timeframes', array());
            $interval = $this->safe_string($timeframes, $timeframe, $timeframe);
            $messageHash = 'ohlcv' . '::' . $symbol . '::' . $timeframe;
            $suffix = '_' . $interval;
            $subscription = array(
                'topic' => 'ohlcv',
                'symbolsAndTimeframes' => array( array( $symbol, $timeframe ) ),
            );
            return Async\await($this->un_watch_public($market, $messageHash, '11', $params, $subscription, $suffix));
        }) ();
    }

    public function handle_ohlcv(Client $client, $message) {
        //
        //     {
        //         "a" => "PK",
        //         "tt" => 1760972831580,
        //         "mt" => 1760972831580,
        //         "r" => array(
        //             {
        //                 "d" => array(
        //                     "I" => "BTC/USDT",
        //                     "P" => "1m",
        //                     "B" => 1760972820,
        //                     "O" => 111373,
        //                     "C" => 111382.9,
        //                     "H" => 111382.9,
        //                     "L" => 111373,
        //                     "V" => 0.2414172,
        //                     "M" => 26888.19693324
        //                 ),
        //                 "t" => "LK"
        //             }
        //         )
        //     }
        //
        $response = $this->safe_list($message, 'r', array());
        $first = $this->safe_dict($response, 0, array());
        $data = $this->safe_dict($first, 'd', array());
        $marketId = $this->safe_string($data, 'I');
        $market = $this->safe_market($marketId, null, '/');
        $symbol = $this->safe_symbol($marketId, $market);
        $interval = $this->safe_string($data, 'P');
        $timeframe = $this->find_timeframe($interval);
        if (!(is_array($this->ohlcvs) && array_key_exists($symbol, $this->ohlcvs))) {
            $this->ohlcvs[$symbol] = array();
        }
        if (!(is_array($this->ohlcvs[$symbol]) && array_key_exists($timeframe, $this->ohlcvs[$symbol]))) {
            $limit = $this->safe_integer($this->options, 'OHLCVLimit', 1000);
            $this->ohlcvs[$symbol][$timeframe] = new ArrayCacheByTimestamp ($limit);
        }
        $stored = $this->ohlcvs[$symbol][$timeframe];
        if ($data !== null) {
            $ohlcv = $this->parse_ws_ohlcv($data, $market);
            $stored->append ($ohlcv);
        }
        $messageHash = 'ohlcv' . '::' . $symbol . '::' . $timeframe;
        $client->resolve ($stored, $messageHash);
    }

    public function parse_ws_ohlcv($ohlcv, ?array $market = null): array {
        //
        //     {
        //         "I" => "BTC/USDT",
        //         "P" => "1m",
        //         "B" => 1760972820,
        //         "O" => 111373,
        //         "C" => 111382.9,
        //         "H" => 111382.9,
        //         "L" => 111373,
        //         "V" => 0.2414172,
        //         "M" => 26888.19693324
        //     }
        //
        return array(
            $this->safe_timestamp($ohlcv, 'B'),
            $this->safe_number($ohlcv, 'O'),
            $this->safe_number($ohlcv, 'H'),
            $this->safe_number($ohlcv, 'L'),
            $this->safe_number($ohlcv, 'C'),
            $this->safe_number($ohlcv, 'V'),
        );
    }

    public function watch_order_book(string $symbol, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $limit, $params) {
            /**
             * watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
             *
             * @see https://www.deepcoin.com/docs/publicWS/25LevelIncrementalMarketData
             *
             * @param {string} $symbol unified $symbol of the $market to fetch the order book for
             * @param {int} [$limit] the maximum amount of order book entries to return.
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} A dictionary of ~@link https://docs.ccxt.com/?id=order-book-structure order book structures~ indexed by $market symbols
             */
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $messageHash = 'orderbook' . '::' . $market['symbol'];
            $suffix = '_0.1';
            $orderbook = Async\await($this->watch_public($market, $messageHash, '25', $params, $suffix));
            return $orderbook->limit ();
        }) ();
    }

    public function un_watch_order_book(string $symbol, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $params) {
            /**
             * unWatches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
             *
             * @see https://www.deepcoin.com/docs/publicWS/25LevelIncrementalMarketData
             *
             * @param {string} $symbol unified array of symbols
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} A dictionary of ~@link https://docs.ccxt.com/?id=order-book-structure order book structures~ indexed by $market symbols
             */
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $messageHash = 'orderbook' . '::' . $market['symbol'];
            $suffix = '_0.1';
            $subscription = array(
                'topic' => 'orderbook',
            );
            return Async\await($this->un_watch_public($market, $messageHash, '25', $params, $subscription, $suffix));
        }) ();
    }

    public function handle_order_book(Client $client, $message) {
        //
        //     {
        //         "a" => "PMO",
        //         "t" => "i", // i - update, f - snapshot
        //         "r" => array(
        //             array(
        //                 "d" => array( "I" => "ETH/USDT", "D" => "1", "P" => 4021, "V" => 54.39979 )
        //             ),
        //             {
        //                 "d" => array( "I" => "ETH/USDT", "D" => "0", "P" => 4021.1, "V" => 49.56724 )
        //             }
        //         ),
        //         "tt" => 1760975816446,
        //         "mt" => 1760975816446
        //     }
        //
        $response = $this->safe_list($message, 'r', array());
        $first = $this->safe_dict($response, 0, array());
        $data = $this->safe_dict($first, 'd', array());
        $marketId = $this->safe_string($data, 'I');
        $market = $this->safe_market($marketId, null, '/');
        $symbol = $this->safe_symbol($marketId, $market);
        if (!(is_array($this->orderbooks) && array_key_exists($symbol, $this->orderbooks))) {
            $this->orderbooks[$symbol] = $this->order_book();
        }
        $orderbook = $this->orderbooks[$symbol];
        $type = $this->safe_string($message, 't');
        if ($orderbook['timestamp'] === null) {
            if ($type === 'f') {
                // snapshot
                $this->handle_order_book_snapshot($client, $message);
            } else {
                // cache the updates until the snapshot is received
                $orderbook->cache[] = $message;
            }
        } else {
            $this->handle_order_book_message($client, $message, $orderbook);
            $messageHash = 'orderbook' . '::' . $symbol;
            $client->resolve ($orderbook, $messageHash);
        }
    }

    public function handle_order_book_snapshot(Client $client, $message) {
        $entries = $this->safe_list($message, 'r', array());
        $first = $this->safe_dict($entries, 0, array());
        $data = $this->safe_dict($first, 'd', array());
        $marketId = $this->safe_string($data, 'I');
        $market = $this->safe_market($marketId, null, '/');
        $symbol = $this->safe_symbol($marketId, $market);
        $orderbook = $this->orderbooks[$symbol];
        $orderedEntries = array(
            'bids' => array(),
            'asks' => array(),
        );
        for ($i = 0; $i < count($entries); $i++) {
            $entry = $entries[$i];
            $entryData = $this->safe_dict($entry, 'd', array());
            $side = $this->safe_string($entryData, 'D');
            $price = $this->safe_number($entryData, 'P');
            $volume = $this->safe_number($entryData, 'V');
            if ($side === '0') {
                // bid
                $orderedEntries['bids'][] = array( $price, $volume );
            } elseif ($side === '1') {
                // ask
                $orderedEntries['asks'][] = array( $price, $volume );
            }
        }
        $timestamp = $this->safe_integer($message, 'mt');
        $snapshot = $this->parse_order_book($orderedEntries, $symbol, $timestamp);
        $orderbook->reset ($snapshot);
        $cachedMessages = $orderbook->cache;
        for ($j = 0; $j < count($cachedMessages); $j++) {
            $cachedMessage = $cachedMessages[$j];
            $this->handle_order_book_message($client, $cachedMessage, $orderbook);
        }
        $orderbook->cache = array();
        $messageHash = 'orderbook' . '::' . $symbol;
        $client->resolve ($orderbook, $messageHash);
    }

    public function handle_order_book_message(Client $client, $message, $orderbook) {
        //     {
        //         "a" => "PMO",
        //         "t" => "i", // i - update, f - snapshot
        //         "r" => array(
        //             array(
        //                 "d" => array( "I" => "ETH/USDT", "D" => "1", "P" => 4021, "V" => 54.39979 )
        //             ),
        //             {
        //                 "d" => array( "I" => "ETH/USDT", "D" => "0", "P" => 4021.1, "V" => 49.56724 )
        //             }
        //         ),
        //         "tt" => 1760975816446,
        //         "mt" => 1760975816446
        //     }
        //
        $timestamp = $this->safe_integer($message, 'mt');
        if ($timestamp > $orderbook['timestamp']) {
            $response = $this->safe_list($message, 'r', array());
            $this->handle_deltas($orderbook, $response);
            $orderbook['timestamp'] = $timestamp;
            $orderbook['datetime'] = $this->iso8601($timestamp);
        }
    }

    public function handle_delta($orderbook, $entry) {
        $data = $this->safe_dict($entry, 'd', array());
        $bids = $orderbook['bids'];
        $asks = $orderbook['asks'];
        $side = $this->safe_string($data, 'D');
        $price = $this->safe_number($data, 'P');
        $volume = $this->safe_number($data, 'V');
        if ($side === '0') {
            // bid
            $bids->store ($price, $volume);
        } elseif ($side === '1') {
            // ask
            $asks->store ($price, $volume);
        }
    }

    public function watch_my_trades(?string $symbol = null, ?int $since = null, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            /**
             * watches information on multiple $trades made by the user
             *
             * @see https://www.deepcoin.com/docs/privateWS/Trade
             *
             * @param {string} $symbol unified market $symbol of the market orders were made in
             * @param {int} [$since] the earliest time in ms to fetch orders for
             * @param {int} [$limit] the maximum number of order structures to retrieve
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array[]} a list of ~@link https://docs.ccxt.com/?id=order-structure order structures~
             */
            $messageHash = 'myTrades';
            Async\await($this->load_markets());
            if ($symbol !== null) {
                $symbol = $this->symbol($symbol);
                $messageHash .= '::' . $symbol;
            }
            $trades = Async\await($this->watch_private($messageHash, $params));
            if ($this->newUpdates) {
                $limit = $trades->getLimit ($symbol, $limit);
            }
            return $this->filter_by_symbol_since_limit($trades, $symbol, $since, $limit, true);
        }) ();
    }

    public function handle_my_trade(Client $client, $message) {
        //
        //     {
        //         "action" => "PushTrade",
        //         "result" => array(
        //             {
        //                 "table" => "Trade",
        //                 "data" => {
        //                     "A" => "9256245",
        //                     "CC" => "USDT",
        //                     "CP" => 0,
        //                     "D" => "0",
        //                     "F" => 0.152,
        //                     "I" => "DOGE/USDT",
        //                     "IT" => 1761048103,
        //                     "M" => "9256245",
        //                     "OS" => "1001437462198486",
        //                     "P" => 0.19443,
        //                     "T" => 14.77668,
        //                     "TI" => "1001056459096708",
        //                     "TT" => 1761048103,
        //                     "V" => 76,
        //                     "f" => "DOGE",
        //                     "l" => 1,
        //                     "m" => "1",
        //                     "o" => "0"
        //                 }
        //             }
        //         )
        //     }
        //
        $result = $this->safe_list($message, 'result', array());
        $first = $this->safe_dict($result, 0, array());
        $data = $this->safe_dict($first, 'data', array());
        $marketId = $this->safe_string($data, 'I');
        $market = $this->safe_market($marketId, null, '/');
        $symbol = $this->safe_symbol($marketId, $market);
        $messageHash = 'myTrades';
        $symbolMessageHash = $messageHash . '::' . $symbol;
        if ((is_array($client->futures) && array_key_exists($messageHash, $client->futures)) || (is_array($client->futures) && array_key_exists($symbolMessageHash, $client->futures))) {
            if ($this->myTrades === null) {
                $limit = $this->safe_integer($this->options, 'tradesLimit', 1000);
                $this->myTrades = new ArrayCacheBySymbolById ($limit);
            }
            $stored = $this->myTrades;
            $parsed = $this->parse_ws_trade($data, $market);
            $stored->append ($parsed);
            $client->resolve ($stored, $messageHash);
            $client->resolve ($stored, $symbolMessageHash);
        }
    }

    public function watch_orders(?string $symbol = null, ?int $since = null, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            /**
             * watches information on multiple $orders made by the user
             *
             * @see https://www.deepcoin.com/docs/privateWS/order
             *
             * @param {string} $symbol unified market $symbol of the market $orders were made in
             * @param {int} [$since] the earliest time in ms to fetch $orders for
             * @param {int} [$limit] the maximum number of order structures to retrieve
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array[]} a list of ~@link https://docs.ccxt.com/?id=order-structure order structures~
             */
            $messageHash = 'orders';
            Async\await($this->load_markets());
            if ($symbol !== null) {
                $symbol = $this->symbol($symbol);
                $messageHash .= '::' . $symbol;
            }
            $orders = Async\await($this->watch_private($messageHash, $params));
            if ($this->newUpdates) {
                $limit = $orders->getLimit ($symbol, $limit);
            }
            return $this->filter_by_symbol_since_limit($orders, $symbol, $since, $limit, true);
        }) ();
    }

    public function handle_order(Client $client, $message) {
        //
        //     {
        //         "action" => "PushOrder",
        //         "result" => array(
        //             {
        //                 "table" => "Order",
        //                 "data" => {
        //                     "D" => "0",
        //                     "I" => "DOGE/USDT",
        //                     "IT" => 1761051006,
        //                     "L" => "1001437480817468",
        //                     "OPT" => "4",
        //                     "OS" => "1001437480817468",
        //                     "OT" => "0",
        //                     "Or" => "1",
        //                     "P" => 0.19537,
        //                     "T" => 14.84128,
        //                     "U" => 1761051006,
        //                     "V" => 76,
        //                     "VT" => 76,
        //                     "i" => 1,
        //                     "l" => 1,
        //                     "o" => "0",
        //                     "p" => "0",
        //                     "t" => 0.19528
        //                 }
        //             }
        //         )
        //     }
        //
        $result = $this->safe_list($message, 'result', array());
        $first = $this->safe_dict($result, 0, array());
        $data = $this->safe_dict($first, 'data', array());
        $marketId = $this->safe_string($data, 'I');
        $market = $this->safe_market($marketId, null, '/');
        $symbol = $this->safe_symbol($marketId, $market);
        $messageHash = 'orders';
        $symbolMessageHash = $messageHash . '::' . $symbol;
        if ((is_array($client->futures) && array_key_exists($messageHash, $client->futures)) || (is_array($client->futures) && array_key_exists($symbolMessageHash, $client->futures))) {
            if ($this->orders === null) {
                $limit = $this->safe_integer($this->options, 'ordersLimit', 1000);
                $this->orders = new ArrayCacheBySymbolById ($limit);
            }
            $parsed = $this->parse_ws_order($data, $market);
            $this->orders.append ($parsed);
            $client->resolve ($this->orders, $messageHash);
            $client->resolve ($this->orders, $symbolMessageHash);
        }
    }

    public function parse_ws_order($order, ?array $market = null): array {
        //
        //     {
        //         "D" => "0",
        //         "I" => "DOGE/USDT",
        //         "IT" => 1761051006,
        //         "L" => "1001437480817468",
        //         "OPT" => "4",
        //         "OS" => "1001437480817468",
        //         "OT" => "0",
        //         "Or" => "1",
        //         "P" => 0.19537,
        //         "T" => 14.84128,
        //         "U" => 1761051006,
        //         "V" => 76,
        //         "VT" => 76,
        //         "i" => 1,
        //         "l" => 1,
        //         "o" => "0",
        //         "p" => "0",
        //         "t" => 0.19528
        //     }
        //
        $state = $this->safe_string($order, 'Or');
        $timestamp = $this->safe_timestamp($order, 'IT');
        $direction = $this->safe_string($order, 'D');
        return $this->safe_order(array(
            'id' => $this->safe_string($order, 'OS'),
            'clientOrderId' => null,
            'datetime' => $this->iso8601($timestamp),
            'timestamp' => $timestamp,
            'lastTradeTimestamp' => null,
            'lastUpdateTimestamp' => $this->safe_timestamp($order, 'U'),
            'status' => $this->parse_ws_order_status($state),
            'symbol' => $market['symbol'],
            'type' => null,
            'timeInForce' => null,
            'side' => $this->parse_trade_side($direction),
            'price' => $this->safe_string($order, 'P'),
            'average' => $this->safe_string($order, 't'),
            'amount' => $this->safe_string($order, 'V'),
            'filled' => $this->safe_string($order, 'VT'),
            'remaining' => null,
            'triggerPrice' => null,
            'takeProfitPrice' => $this->safe_string($order, 'TPT'),
            'stopLossPrice' => $this->safe_string($order, 'SLT'),
            'cost' => $this->safe_string($order, 'T'),
            'trades' => null,
            'fee' => null,
            'reduceOnly' => null,
            'postOnly' => null,
            'info' => $order,
        ), $market);
    }

    public function parse_ws_order_status(?string $status): ?string {
        $statuses = array(
            '1' => 'closed',
            '4' => 'open',
            '6' => 'canceled',
        );
        return $this->safe_string($statuses, $status, $status);
    }

    public function watch_positions(?array $symbols = null, ?int $since = null, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbols, $since, $limit, $params) {
            /**
             * watch all open $positions
             *
             * @see https://www.deepcoin.com/docs/privateWS/Position
             *
             * @param {string[]} [$symbols] list of unified market $symbols to watch $positions for
             * @param {int} [$since] the earliest time in ms to fetch $positions for
             * @param {int} [$limit] the maximum number of $positions to retrieve
             * @param {array} $params extra parameters specific to the exchange API endpoint
             * @return {array[]} a list of {@link https://docs.ccxt.com/en/latest/manual.html#position-structure position structure}
             */
            Async\await($this->load_markets());
            $listenKey = Async\await($this->authenticate());
            $symbols = $this->market_symbols($symbols);
            $messageHash = 'positions';
            $messageHashes = array();
            if ($symbols !== null) {
                for ($i = 0; $i < count($symbols); $i++) {
                    $symbol = $symbols[$i];
                    $symbolMessageHash = $messageHash . '::' . $symbol;
                    $messageHashes[] = $symbolMessageHash;
                }
            } else {
                $messageHashes[] = $messageHash;
            }
            $url = $this->urls['api']['ws']['private'] . '?$listenKey=' . $listenKey;
            $positions = Async\await($this->watch_multiple($url, $messageHashes, $params, array( 'private' )));
            if ($this->newUpdates) {
                return $positions;
            }
            return $this->filter_by_symbols_since_limit($this->positions, $symbols, $since, $limit, true);
        }) ();
    }

    public function handle_position(Client $client, $message) {
        //
        //     {
        //         "action" => "PushPosition",
        //         "result" => array(
        //             {
        //                 "table" => "Position",
        //                 "data" => {
        //                     "A" => "9256245",
        //                     "CP" => 0,
        //                     "I" => "DOGE/USDT",
        //                     "M" => "9256245",
        //                     "OP" => 0.198845,
        //                     "Po" => 151.696,
        //                     "U" => 1761058213,
        //                     "i" => 1,
        //                     "l" => 1,
        //                     "p" => "0",
        //                     "u" => 0
        //                 }
        //             }
        //         )
        //     }
        //
        $result = $this->safe_list($message, 'result', array());
        $first = $this->safe_dict($result, 0, array());
        $data = $this->safe_dict($first, 'data', array());
        $marketId = $this->safe_string($data, 'I');
        $market = $this->safe_market($marketId, null, '/');
        $symbol = $this->safe_symbol($marketId, $market);
        $messageHash = 'positions';
        $symbolMessageHash = $messageHash . '::' . $symbol;
        if ((is_array($client->futures) && array_key_exists($messageHash, $client->futures)) || (is_array($client->futures) && array_key_exists($symbolMessageHash, $client->futures))) {
            if ($this->positions === null) {
                $this->positions = new ArrayCacheBySymbolBySide ();
            }
            $parsed = $this->parse_ws_position($data, $market);
            $this->positions.append ($parsed);
            $client->resolve ($this->positions, $messageHash);
            $client->resolve ($this->positions, $symbolMessageHash);
        }
    }

    public function parse_ws_position($position, ?array $market = null): array {
        //
        //     {
        //         "A" => "9256245",
        //         "CP" => 0,
        //         "I" => "DOGE/USDT",
        //         "M" => "9256245",
        //         "OP" => 0.198845,
        //         "Po" => 151.696,
        //         "U" => 1761058213,
        //         "i" => 1,
        //         "l" => 1,
        //         "p" => "0",
        //         "u" => 0
        //     }
        //
        $timestamp = $this->safe_integer($position, 'U');
        $direction = $this->safe_string($position, 'p');
        $marginMode = $this->safe_string($position, 'i');
        return $this->safe_position(array(
            'symbol' => $market['symbol'],
            'id' => null,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'contracts' => $this->safe_string($position, 'Po'),
            'contractSize' => null,
            'side' => $this->parse_position_side($direction),
            'notional' => null,
            'leverage' => $this->omit_zero($this->safe_string($position, 'l')),
            'unrealizedPnl' => null,
            'realizedPnl' => null,
            'collateral' => null,
            'entryPrice' => $this->safe_string($position, 'OP'),
            'markPrice' => null,
            'liquidationPrice' => null,
            'marginMode' => $this->parse_ws_margin_mode($marginMode),
            'hedged' => true,
            'maintenanceMargin' => $this->safe_string($position, 'u'),
            'maintenanceMarginPercentage' => null,
            'initialMargin' => null,
            'initialMarginPercentage' => null,
            'marginRatio' => null,
            'lastUpdateTimestamp' => null,
            'lastPrice' => null,
            'stopLossPrice' => null,
            'takeProfitPrice' => null,
            'percentage' => null,
            'info' => $position,
        ));
    }

    public function parse_position_side(?string $direction): ?string {
        if ($direction === null) {
            return $direction;
        }
        $directions = array(
            '0' => 'long',
            '1' => 'short',
        );
        return $this->safe_string($directions, $direction, $direction);
    }

    public function parse_ws_margin_mode(?string $marginMode): ?string {
        if ($marginMode === null) {
            return $marginMode;
        }
        $modes = array(
            '0' => 'isolated',
            '1' => 'cross',
        );
        return $this->safe_string($modes, $marginMode, $marginMode);
    }

    public function handle_message(Client $client, $message) {
        if ($message === 'pong') {
            $this->handle_pong($client, $message);
        } else {
            $m = $this->safe_string($message, 'm');
            if (($m !== null) && ($m !== 'Success')) {
                $this->handle_error_message($client, $message);
            }
            $action = $this->safe_string_2($message, 'a', 'action');
            if ($action === 'RecvTopicAction') {
                $this->handle_subscription_status($client, $message);
            } elseif ($action === 'PO') {
                $this->handle_ticker($client, $message);
            } elseif ($action === 'PMT') {
                $this->handle_trades($client, $message);
            } elseif ($action === 'PK') {
                $this->handle_ohlcv($client, $message);
            } elseif ($action === 'PMO') {
                $this->handle_order_book($client, $message);
            } elseif ($action === 'PushTrade') {
                $this->handle_my_trade($client, $message);
            } elseif ($action === 'PushOrder') {
                $this->handle_order($client, $message);
            } elseif ($action === 'PushPosition') {
                $this->handle_position($client, $message);
            }
        }
    }

    public function handle_subscription_status(Client $client, $message) {
        //
        //     {
        //         "a" => "RecvTopicAction",
        //         "m" => "Success",
        //         "r" => array(
        //             {
        //                 "d" => {
        //                     "A" => "0",
        //                     "L" => 1,
        //                     "T" => "7",
        //                     "F" => "DeepCoin_BTC/USDT",
        //                     "R" => -1
        //                 }
        //             }
        //         )
        //     }
        //
        $response = $this->safe_list($message, 'r', array());
        $first = $this->safe_dict($response, 0, array());
        $data = $this->safe_dict($first, 'd', array());
        $action = $this->safe_string($data, 'A'); // 1 = subscribe, 0 = unsubscribe
        if ($action === '0') {
            $subscriptionsById = $this->index_by($client->subscriptions, 'id');
            $subId = $this->safe_integer($data, 'L');
            $subscription = $this->safe_dict($subscriptionsById, $subId, array()); // original watch $subscription
            $subHash = $this->safe_string($subscription, 'subHash');
            $unsubHash = 'unsubscribe::' . $subHash;
            $unsubsciption = $this->safe_dict($client->subscriptions, $unsubHash, array()); // unWatch $subscription
            $this->handle_un_subscription($client, $unsubsciption);
        }
    }

    public function handle_un_subscription(Client $client, array $subscription) {
        $subHash = $this->safe_string($subscription, 'subHash');
        $unsubHash = $this->safe_string($subscription, 'unsubHash');
        $this->clean_unsubscription($client, $subHash, $unsubHash);
        $this->clean_cache($subscription);
    }

    public function handle_error_message(Client $client, $message) {
        //
        //     {
        //         "a" => "RecvTopicAction",
        //         "m" => "subscription cluster does not "exist" => BTC/USD",
        //         "r" => array(
        //             {
        //                 "d" => {
        //                     "A" => "1",
        //                     "L" => 1,
        //                     "T" => "7",
        //                     "F" => "DeepCoin_BTC/USD",
        //                     "R" => -1
        //                 }
        //             }
        //         )
        //     }
        //
        $messageText = $this->safe_string($message, 'm', '');
        $response = $this->safe_list($message, 'r', array());
        $first = $this->safe_dict($response, 0, array());
        $data = $this->safe_dict($first, 'd', array());
        $requestId = $this->safe_integer($data, 'L');
        $subscriptionsById = $this->index_by($client->subscriptions, 'id');
        $subscription = $this->safe_dict($subscriptionsById, $requestId, array());
        $messageHash = $this->safe_string($subscription, 'subHash');
        $feedback = $this->id . ' ' . $this->json($message);
        try {
            $this->throw_exactly_matched_exception($this->exceptions['exact'], $messageText, $feedback);
            $this->throw_broadly_matched_exception($this->exceptions['broad'], $messageText, $feedback);
            throw new ExchangeError($feedback);
        } catch (Exception $e) {
            $client->reject ($e, $messageHash);
        }
    }
}
