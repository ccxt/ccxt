<?php
namespace ccxt\pro;
include_once (__DIR__.'/../../../../ccxt.php');
// ----------------------------------------------------------------------------

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

// -----------------------------------------------------------------------------


function equals($a, $b) {
   return json_encode($a) === json_encode($b);
}




// ----------------------------------------------------------------------------
$array_cache = new ArrayCache(3);


$array_cache->append(array(
    'symbol' => 'BTC/USDT',
    'data' => 1,
));


$array_cache->append(array(
    'symbol' => 'BTC/USDT',
    'data' => 2,
));


$array_cache->append(array(
    'symbol' => 'BTC/USDT',
    'data' => 3,
));


$array_cache->append(array(
    'symbol' => 'BTC/USDT',
    'data' => 4,
));


assert(equals($array_cache, [array(
    'symbol' => 'BTC/USDT',
    'data' => 2,
), array(
    'symbol' => 'BTC/USDT',
    'data' => 3,
), array(
    'symbol' => 'BTC/USDT',
    'data' => 4,
)]));


$array_cache->append(array(
    'symbol' => 'BTC/USDT',
    'data' => 5,
));


$array_cache->append(array(
    'symbol' => 'BTC/USDT',
    'data' => 6,
));


$array_cache->append(array(
    'symbol' => 'BTC/USDT',
    'data' => 7,
));


$array_cache->append(array(
    'symbol' => 'BTC/USDT',
    'data' => 8,
));


assert(equals($array_cache, [array(
    'symbol' => 'BTC/USDT',
    'data' => 6,
), array(
    'symbol' => 'BTC/USDT',
    'data' => 7,
), array(
    'symbol' => 'BTC/USDT',
    'data' => 8,
)]));


$array_cache->clear();


$array_cache->append(array(
    'symbol' => 'BTC/USDT',
    'data' => 1,
));


assert(equals($array_cache, [array(
    'symbol' => 'BTC/USDT',
    'data' => 1,
)]));


// ----------------------------------------------------------------------------
$arraycache2 = new ArrayCache(1);


$arraycache2->append(array(
    'symbol' => 'BTC/USDT',
    'data' => 1,
));


$arraycache2->append(array(
    'symbol' => 'BTC/USDT',
    'data' => 2,
));


assert(equals($arraycache2, [array(
    'symbol' => 'BTC/USDT',
    'data' => 2,
)]));


// ----------------------------------------------------------------------------
$timestamp_cache = new ArrayCacheByTimestamp();


$ohlcv1 = [100, 1, 2, 3];


$ohlcv2 = [200, 5, 6, 7];


$timestamp_cache->append($ohlcv1);


$timestamp_cache->append($ohlcv2);


assert(equals($timestamp_cache, [$ohlcv1, $ohlcv2]));


$modify2 = [200, 10, 11, 12];


$timestamp_cache->append($modify2);


assert(equals($timestamp_cache, [$ohlcv1, $modify2]));


// ----------------------------------------------------------------------------
$cache_symbol_id = new ArrayCacheBySymbolById();


$object1 = array(
    'symbol' => 'BTC/USDT',
    'id' => 'abcdef',
    'i' => 1,
);


$object2 = array(
    'symbol' => 'ETH/USDT',
    'id' => 'qwerty',
    'i' => 2,
);


$object3 = array(
    'symbol' => 'BTC/USDT',
    'id' => 'abcdef',
    'i' => 3,
);


$cache_symbol_id->append($object1);


$cache_symbol_id->append($object2);


$cache_symbol_id->append($object3); // should update index 0


assert(equals($cache_symbol_id, [$object2, $object3]));


// ----------------------------------------------------------------------------
$cache_symbol_id_5 = new ArrayCacheBySymbolById(5);


for ($i = 1; $i < 11; $i++) {
    $cache_symbol_id_5->append(array(
        'symbol' => 'BTC/USDT',
        'id' => ((string) $i),
        'i' => $i,
    ));
}


assert(equals($cache_symbol_id_5, [array(
    'symbol' => 'BTC/USDT',
    'id' => '6',
    'i' => 6,
), array(
    'symbol' => 'BTC/USDT',
    'id' => '7',
    'i' => 7,
), array(
    'symbol' => 'BTC/USDT',
    'id' => '8',
    'i' => 8,
), array(
    'symbol' => 'BTC/USDT',
    'id' => '9',
    'i' => 9,
), array(
    'symbol' => 'BTC/USDT',
    'id' => '10',
    'i' => 10,
)]));


for ($i = 1; $i < 11; $i++) {
    $cache_symbol_id_5->append(array(
        'symbol' => 'BTC/USDT',
        'id' => ((string) $i),
        'i' => $i + 10,
    ));
}


assert(equals($cache_symbol_id_5, [array(
    'symbol' => 'BTC/USDT',
    'id' => '6',
    'i' => 16,
), array(
    'symbol' => 'BTC/USDT',
    'id' => '7',
    'i' => 17,
), array(
    'symbol' => 'BTC/USDT',
    'id' => '8',
    'i' => 18,
), array(
    'symbol' => 'BTC/USDT',
    'id' => '9',
    'i' => 19,
), array(
    'symbol' => 'BTC/USDT',
    'id' => '10',
    'i' => 20,
)]));


$middle = array(
    'symbol' => 'BTC/USDT',
    'id' => '8',
    'i' => 28,
);


$cache_symbol_id_5->append($middle);


assert(equals($cache_symbol_id_5, [array(
    'symbol' => 'BTC/USDT',
    'id' => '6',
    'i' => 16,
), array(
    'symbol' => 'BTC/USDT',
    'id' => '7',
    'i' => 17,
), array(
    'symbol' => 'BTC/USDT',
    'id' => '9',
    'i' => 19,
), array(
    'symbol' => 'BTC/USDT',
    'id' => '10',
    'i' => 20,
), array(
    'symbol' => 'BTC/USDT',
    'id' => '8',
    'i' => 28,
)]));


$other_middle = array(
    'symbol' => 'BTC/USDT',
    'id' => '7',
    'i' => 27,
);


$cache_symbol_id_5->append($other_middle);


assert(equals($cache_symbol_id_5, [array(
    'symbol' => 'BTC/USDT',
    'id' => '6',
    'i' => 16,
), array(
    'symbol' => 'BTC/USDT',
    'id' => '9',
    'i' => 19,
), array(
    'symbol' => 'BTC/USDT',
    'id' => '10',
    'i' => 20,
), array(
    'symbol' => 'BTC/USDT',
    'id' => '8',
    'i' => 28,
), array(
    'symbol' => 'BTC/USDT',
    'id' => '7',
    'i' => 27,
)]));


for ($i = 30; $i < 33; $i++) {
    $cache_symbol_id_5->append(array(
        'symbol' => 'BTC/USDT',
        'id' => ((string) $i),
        'i' => $i + 10,
    ));
}


assert(equals($cache_symbol_id_5, [array(
    'symbol' => 'BTC/USDT',
    'id' => '8',
    'i' => 28,
), array(
    'symbol' => 'BTC/USDT',
    'id' => '7',
    'i' => 27,
), array(
    'symbol' => 'BTC/USDT',
    'id' => '30',
    'i' => 40,
), array(
    'symbol' => 'BTC/USDT',
    'id' => '31',
    'i' => 41,
), array(
    'symbol' => 'BTC/USDT',
    'id' => '32',
    'i' => 42,
)]));


$first = array(
    'symbol' => 'BTC/USDT',
    'id' => '8',
    'i' => 38,
);


$cache_symbol_id_5->append($first);


assert(equals($cache_symbol_id_5, [array(
    'symbol' => 'BTC/USDT',
    'id' => '7',
    'i' => 27,
), array(
    'symbol' => 'BTC/USDT',
    'id' => '30',
    'i' => 40,
), array(
    'symbol' => 'BTC/USDT',
    'id' => '31',
    'i' => 41,
), array(
    'symbol' => 'BTC/USDT',
    'id' => '32',
    'i' => 42,
), array(
    'symbol' => 'BTC/USDT',
    'id' => '8',
    'i' => 38,
)]));


$another = array(
    'symbol' => 'BTC/USDT',
    'id' => '30',
    'i' => 50,
);


$cache_symbol_id_5->append($another);


assert(equals($cache_symbol_id_5, [array(
    'symbol' => 'BTC/USDT',
    'id' => '7',
    'i' => 27,
), array(
    'symbol' => 'BTC/USDT',
    'id' => '31',
    'i' => 41,
), array(
    'symbol' => 'BTC/USDT',
    'id' => '32',
    'i' => 42,
), array(
    'symbol' => 'BTC/USDT',
    'id' => '8',
    'i' => 38,
), array(
    'symbol' => 'BTC/USDT',
    'id' => '30',
    'i' => 50,
)]));


// ----------------------------------------------------------------------------
// test ArrayCacheBySymbolById limit with symbol set
$symbol = 'BTC/USDT';


$cache_symbol_id_2 = new ArrayCacheBySymbolById();


$initial_length = 5;


for ($i = 0; $i < $initial_length; $i++) {
    $cache_symbol_id_2->append(array(
        'symbol' => $symbol,
        'id' => ((string) $i),
        'i' => $i,
    ));
}


$limited = $cache_symbol_id_2->get_limit($symbol, null);


assert($initial_length === $limited);


// ----------------------------------------------------------------------------
$cache_symbol_id_3 = new ArrayCacheBySymbolById();


$append_items_length = 3;


for ($i = 0; $i < $append_items_length; $i++) {
    $cache_symbol_id_3->append(array(
        'symbol' => $symbol,
        'id' => ((string) $i),
        'i' => $i,
    ));
}


$outside_limit = 5;


$limited = $cache_symbol_id_3->get_limit($symbol, $outside_limit);


assert($append_items_length === $limited);


$outside_limit = 2; // if limit < newsUpdate that should be returned


$limited = $cache_symbol_id_3->get_limit($symbol, $outside_limit);


assert($outside_limit === $limited);


// ----------------------------------------------------------------------------
// test ArrayCacheBySymbolById limit with symbol undefined
$symbol = 'BTC/USDT';


$cache_symbol_id_4 = new ArrayCacheBySymbolById();


$initial_length = 5;


for ($i = 0; $i < $initial_length; $i++) {
    $cache_symbol_id_4->append(array(
        'symbol' => $symbol,
        'id' => ((string) $i),
        'i' => $i,
    ));
}


$limited = $cache_symbol_id_4->get_limit(null, null);


assert($initial_length === $limited);


// ----------------------------------------------------------------------------
$cache_symbol_id_6 = new ArrayCacheBySymbolById();


$append_items_length = 3;


for ($i = 0; $i < $append_items_length; $i++) {
    $cache_symbol_id_6->append(array(
        'symbol' => $symbol,
        'id' => ((string) $i),
        'i' => $i,
    ));
}


$outside_limit = 5;


$limited = $cache_symbol_id_6->get_limit($symbol, $outside_limit);


assert($append_items_length === $limited);


$outside_limit = 2; // if limit < newsUpdate that should be returned


$limited = $cache_symbol_id_6->get_limit($symbol, $outside_limit);


assert($outside_limit === $limited);


// ----------------------------------------------------------------------------
// test ArrayCacheBySymbolById, same order should not increase the limit
$cache_symbol_id_7 = new ArrayCacheBySymbolById();


$symbol = 'BTC/USDT';


$other_symbol = 'ETH/USDT';


$cache_symbol_id_7->append(array(
    'symbol' => $symbol,
    'id' => 'singleId',
    'i' => 3,
));


$cache_symbol_id_7->append(array(
    'symbol' => $symbol,
    'id' => 'singleId',
    'i' => 3,
));


$cache_symbol_id_7->append(array(
    'symbol' => $other_symbol,
    'id' => 'singleId',
    'i' => 3,
));


$outside_limit = 5;


$limited = $cache_symbol_id_7->get_limit($symbol, $outside_limit);


$limited2 = $cache_symbol_id_7->get_limit(null, $outside_limit);


assert($limited === 1);


assert($limited2 === 2);


// ----------------------------------------------------------------------------
// test testLimitArrayCacheByTimestamp limit
$timestamp_cache_2 = new ArrayCacheByTimestamp();


$initial_length = 5;


for ($i = 0; $i < $initial_length; $i++) {
    $timestamp_cache_2->append([$i * 10, $i * 10, $i * 10, $i * 10]);
}


$limited = $timestamp_cache_2->get_limit(null, null);


assert($initial_length === $limited);


$append_items_length = 3;


for ($i = 0; $i < $append_items_length; $i++) {
    $timestamp_cache_2->append([$i * 4, $i * 4, $i * 4, $i * 4]);
}


$outside_limit = 5;


$limited = $timestamp_cache_2->get_limit(null, $outside_limit);


assert($append_items_length === $limited);


$outside_limit = 2; // if limit < newsUpdate that should be returned


$limited = $timestamp_cache_2->get_limit(null, $outside_limit);


assert($outside_limit === $limited);


// ----------------------------------------------------------------------------
// test ArrayCacheBySymbolById, watch all orders, same symbol and order id gets updated
$cache_symbol_id_8 = new ArrayCacheBySymbolById();


$symbol = 'BTC/USDT';


$outside_limit = 5;


$cache_symbol_id_8->append(array(
    'symbol' => $symbol,
    'id' => 'oneId',
    'i' => 3,
)); // create first order


$cache_symbol_id_8->get_limit(null, $outside_limit); // watch all orders


$cache_symbol_id_8->append(array(
    'symbol' => $symbol,
    'id' => 'oneId',
    'i' => 4,
)); // first order is closed


$cache_symbol_id_8->get_limit(null, $outside_limit); // watch all orders


$cache_symbol_id_8->append(array(
    'symbol' => $symbol,
    'id' => 'twoId',
    'i' => 5,
)); // create second order


$cache_symbol_id_8->get_limit(null, $outside_limit); // watch all orders


$cache_symbol_id_8->append(array(
    'symbol' => $symbol,
    'id' => 'twoId',
    'i' => 6,
)); // second order is closed


$limited = $cache_symbol_id_8->get_limit(null, $outside_limit); // watch all orders


assert($limited === 1); // one new update


// ----------------------------------------------------------------------------
// test ArrayCacheBySymbolById, watch all orders, and watchOrders (symbol) work independently
$cache_symbol_id_9 = new ArrayCacheBySymbolById();


$symbol = 'BTC/USDT';


$symbol2 = 'ETH/USDT';


$outside_limit = 5;


$cache_symbol_id_9->append(array(
    'symbol' => $symbol,
    'id' => 'one',
    'i' => 1,
)); // create first order


$cache_symbol_id_9->append(array(
    'symbol' => $symbol2,
    'id' => 'two',
    'i' => 1,
)); // create second order


assert($cache_symbol_id_9->get_limit(null, $outside_limit) === 2); // watch all orders


assert($cache_symbol_id_9->get_limit($symbol, $outside_limit) === 1); // watch by symbol


$cache_symbol_id_9->append(array(
    'symbol' => $symbol,
    'id' => 'one',
    'i' => 2,
)); // update first order


$cache_symbol_id_9->append(array(
    'symbol' => $symbol2,
    'id' => 'two',
    'i' => 2,
)); // update second order


assert($cache_symbol_id_9->get_limit($symbol, $outside_limit) === 1); // watch by symbol


assert($cache_symbol_id_9->get_limit(null, $outside_limit) === 2); // watch all orders


$cache_symbol_id_9->append(array(
    'symbol' => $symbol2,
    'id' => 'two',
    'i' => 3,
)); // update second order


$cache_symbol_id_9->append(array(
    'symbol' => $symbol2,
    'id' => 'three',
    'i' => 3,
)); // create third order


assert($cache_symbol_id_9->get_limit(null, $outside_limit) === 2); // watch all orders


// ----------------------------------------------------------------------------
// test ArrayCacheBySymbolBySide, watch all positions, same symbol and side id gets updated
$cache_symbol_side = new ArrayCacheBySymbolBySide();


$symbol = 'BTC/USDT';


$outside_limit = 5;


$cache_symbol_side->append(array(
    'symbol' => $symbol,
    'side' => 'short',
    'contracts' => 1,
)); // create first position


$cache_symbol_side->append(array(
    'symbol' => $symbol,
    'side' => 'short',
    'contracts' => 0,
)); // first position is closed


assert($cache_symbol_side->get_limit($symbol, $outside_limit) === 1); // limit position


$cache_symbol_side->append(array(
    'symbol' => $symbol,
    'side' => 'short',
    'contracts' => 1,
)); // create first position


assert($cache_symbol_side->get_limit($symbol, $outside_limit) === 1); // watch all positions


// ----------------------------------------------------------------------------
// test ArrayCacheBySymbolBySide, watch all positions, same symbol and side id gets updated
$cache_symbol_side_2 = new ArrayCacheBySymbolBySide();


$symbol = 'BTC/USDT';


$outside_limit = 5;


$cache_symbol_side_2->append(array(
    'symbol' => $symbol,
    'side' => 'short',
    'contracts' => 1,
)); // create first position


assert($cache_symbol_side_2->get_limit(null, $outside_limit) === 1); // watch all positions


$cache_symbol_side_2->append(array(
    'symbol' => $symbol,
    'side' => 'short',
    'contracts' => 0,
)); // first position is closed


assert($cache_symbol_side_2->get_limit(null, $outside_limit) === 1); // watch all positions


$cache_symbol_side_2->append(array(
    'symbol' => $symbol,
    'side' => 'long',
    'contracts' => 3,
)); // create second position


assert($cache_symbol_side_2->get_limit(null, $outside_limit) === 1); // watch all positions


$cache_symbol_side_2->append(array(
    'symbol' => $symbol,
    'side' => 'long',
    'contracts' => 2,
)); // second position is reduced


$cache_symbol_side_2->append(array(
    'symbol' => $symbol,
    'side' => 'long',
    'contracts' => 1,
)); // second position is reduced


assert($cache_symbol_side_2->get_limit(null, $outside_limit) === 1); // watch all orders


// ----------------------------------------------------------------------------
// test ArrayCacheBySymbolBySide, watchPositions, and watchPosition (symbol) work independently
$cache_symbol_side_3 = new ArrayCacheBySymbolBySide();


$symbol = 'BTC/USDT';


$symbol2 = 'ETH/USDT';


$cache_symbol_side_3->append(array(
    'symbol' => $symbol,
    'side' => 'short',
    'contracts' => 1,
)); // create first position


$cache_symbol_side_3->append(array(
    'symbol' => $symbol2,
    'side' => 'long',
    'contracts' => 1,
)); // create second position


assert($cache_symbol_side_3->get_limit(null, $outside_limit) === 2); // watch all positions


assert($cache_symbol_side_3->get_limit($symbol, $outside_limit) === 1); // watch by symbol


$cache_symbol_side_3->append(array(
    'symbol' => $symbol,
    'side' => 'short',
    'contracts' => 2,
)); // update first position


$cache_symbol_side_3->append(array(
    'symbol' => $symbol2,
    'side' => 'long',
    'contracts' => 2,
)); // update second position


assert($cache_symbol_side_3->get_limit($symbol, $outside_limit) === 1); // watch by symbol


assert($cache_symbol_side_3->get_limit(null, $outside_limit) === 2); // watch all positions


$cache_symbol_side_3->append(array(
    'symbol' => $symbol2,
    'side' => 'long',
    'contracts' => 3,
)); // update second position


assert($cache_symbol_side_3->get_limit(null, $outside_limit) === 1); // watch all positions
