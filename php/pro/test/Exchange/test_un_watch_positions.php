<?php
namespace ccxt;

// ----------------------------------------------------------------------------

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

// -----------------------------------------------------------------------------
use React\Async;
use React\Promise;
include_once PATH_TO_CCXT . '/test/exchange/base/test_shared_methods.php';

function create_order_after_delay($exchange) {
    return Async\async(function () use ($exchange) {
        Async\await($exchange->sleep(3000));
        Async\await($exchange->create_order('BTC/USDT:USDT', 'market', 'buy', 0.001));
    }) ();
}


function test_unwatch_positions($exchange, $skipped_properties, $symbol) {
    return Async\async(function () use ($exchange, $skipped_properties, $symbol) {
        $method = 'unWatchPositions';
        $exchange->set_sandbox_mode(true);
        // First, we need to subscribe to positions to test the unsubscribe functionality
        $positions_subscription = null;
        try {
            // First call uses snapshot
            $positions_subscription = Async\await($exchange->watch_positions());
            // trigger a position update
            $exchange->spawn('create_order_after_delay', $exchange);
            // Second call uses subscription
            $positions_subscription = Async\await($exchange->watch_positions());
        } catch(\Throwable $e) {
            if (!is_temporary_failure($e)) {
                throw $e;
            }
            // If we can't subscribe, we can't test unsubscribe, so skip this test
            return;
        }
        // Verify that we have a subscription
        assert(gettype($positions_subscription) === 'array' && array_is_list($positions_subscription), $exchange->id . ' ' . $method . ' requires a valid positions subscription to test unsubscribe');
        // Assert unWatchPositions for one symbol is not supported
        $error_response = null;
        try {
            $error_response = Async\await($exchange->un_watch_positions([$symbol]));
        } catch(\Throwable $e) {
            $error_response = $e;
        }
        assert($error_response !== null, $exchange->id . ' ' . $method . ' must throw an error when unwatching a specific symbol, returned ' . $exchange->json($error_response));
        // Test unwatching all positions (without specific symbols)
        $response_all = null;
        try {
            $response_all = Async\await($exchange->un_watch_positions());
        } catch(\Throwable $e) {
            if (!is_temporary_failure($e)) {
                throw $e;
            }
            throw $e;
        }
        // Verify the response for unwatching all positions
        assert($response_all !== null, $exchange->id . ' ' . $method . ' must return a response when unwatching all positions, returned ' . $exchange->json($response_all));
        // Test that we can resubscribe after unwatching (to ensure cleanup was proper)
        $resubscribe_response = null;
        try {
            $resubscribe_response = Async\await($exchange->watch_positions());
            $exchange->spawn('create_order_after_delay', $exchange);
            $resubscribe_response = Async\await($exchange->watch_positions());
        } catch(\Throwable $e) {
            if (!is_temporary_failure($e)) {
                throw $e;
            }
            throw new Error($exchange->id . ' ' . $method . ' failed to resubscribe after unwatch, indicating potential cleanup issues');
        }
        // Verify resubscription works
        assert(gettype($resubscribe_response) === 'array' && array_is_list($resubscribe_response), $exchange->id . ' ' . $method . ' must allow resubscription after unwatch, returned ' . $exchange->json($resubscribe_response));
    }) ();
}
