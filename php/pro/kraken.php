<?php

namespace ccxt\pro;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

use Exception; // a common import
use ccxt\ExchangeError;
use ccxt\NotSupported;
use ccxt\ChecksumError;
use ccxt\Precise;
use React\Async;
use React\Promise\PromiseInterface;

class kraken extends \ccxt\async\kraken {

    public function describe() {
        return $this->deep_extend(parent::describe(), array(
            'has' => array(
                'ws' => true,
                'watchBalance' => true,
                'watchMyTrades' => true,
                'watchOHLCV' => true,
                'watchOrderBook' => true,
                'watchOrderBookForSymbols' => true,
                'watchOrders' => true,
                'watchTicker' => true,
                'watchTickers' => true,
                'watchTrades' => true,
                'watchTradesForSymbols' => true,
                'createOrderWs' => true,
                'editOrderWs' => true,
                'cancelOrderWs' => true,
                'cancelOrdersWs' => true,
                'cancelAllOrdersWs' => true,
                // 'watchHeartbeat' => true,
                // 'watchStatus' => true,
            ),
            'urls' => array(
                'api' => array(
                    'ws' => array(
                        'public' => 'wss://ws.kraken.com',
                        'private' => 'wss://ws-auth.kraken.com',
                        'privateV2' => 'wss://ws-auth.kraken.com/v2',
                        'beta' => 'wss://beta-ws.kraken.com',
                        'beta-private' => 'wss://beta-ws-auth.kraken.com',
                    ),
                ),
            ),
            // 'versions' => array(
            //     'ws' => '0.2.0',
            // ),
            'options' => array(
                'tradesLimit' => 1000,
                'OHLCVLimit' => 1000,
                'ordersLimit' => 1000,
                'symbolsByOrderId' => array(),
                'watchOrderBook' => array(
                    'checksum' => true,
                ),
            ),
            'exceptions' => array(
                'ws' => array(
                    'exact' => array(
                        'Event(s) not found' => '\\ccxt\\BadRequest',
                    ),
                    'broad' => array(
                        'Already subscribed' => '\\ccxt\\BadRequest',
                        'Currency pair not in ISO 4217-A3 format' => '\\ccxt\\BadSymbol',
                        'Malformed request' => '\\ccxt\\BadRequest',
                        'Pair field must be an array' => '\\ccxt\\BadRequest',
                        'Pair field unsupported for this subscription type' => '\\ccxt\\BadRequest',
                        'Pair(s) not found' => '\\ccxt\\BadSymbol',
                        'Subscription book depth must be an integer' => '\\ccxt\\BadRequest',
                        'Subscription depth not supported' => '\\ccxt\\BadRequest',
                        'Subscription field must be an object' => '\\ccxt\\BadRequest',
                        'Subscription name invalid' => '\\ccxt\\BadRequest',
                        'Subscription object unsupported field' => '\\ccxt\\BadRequest',
                        'Subscription ohlc interval must be an integer' => '\\ccxt\\BadRequest',
                        'Subscription ohlc interval not supported' => '\\ccxt\\BadRequest',
                        'Subscription ohlc requires interval' => '\\ccxt\\BadRequest',
                        'EAccount:Invalid permissions' => '\\ccxt\\PermissionDenied',
                        'EAuth:Account temporary disabled' => '\\ccxt\\AccountSuspended',
                        'EAuth:Account unconfirmed' => '\\ccxt\\AuthenticationError',
                        'EAuth:Rate limit exceeded' => '\\ccxt\\RateLimitExceeded',
                        'EAuth:Too many requests' => '\\ccxt\\RateLimitExceeded',
                        'EDatabase => Internal error (to be deprecated)' => '\\ccxt\\ExchangeError',
                        'EGeneral:Internal error[:<code>]' => '\\ccxt\\ExchangeError',
                        'EGeneral:Invalid arguments' => '\\ccxt\\BadRequest',
                        'EOrder:Cannot open opposing position' => '\\ccxt\\InvalidOrder',
                        'EOrder:Cannot open position' => '\\ccxt\\InvalidOrder',
                        'EOrder:Insufficient funds (insufficient user funds)' => '\\ccxt\\InsufficientFunds',
                        'EOrder:Insufficient margin (exchange does not have sufficient funds to allow margin trading)' => '\\ccxt\\InsufficientFunds',
                        'EOrder:Invalid price' => '\\ccxt\\InvalidOrder',
                        'EOrder:Margin allowance exceeded' => '\\ccxt\\InvalidOrder',
                        'EOrder:Margin level too low' => '\\ccxt\\InvalidOrder',
                        'EOrder:Margin position size exceeded (client would exceed the maximum position size for this pair)' => '\\ccxt\\InvalidOrder',
                        'EOrder:Order minimum not met (volume too low)' => '\\ccxt\\InvalidOrder',
                        'EOrder:Orders limit exceeded' => '\\ccxt\\InvalidOrder',
                        'EOrder:Positions limit exceeded' => '\\ccxt\\InvalidOrder',
                        'EOrder:Rate limit exceeded' => '\\ccxt\\RateLimitExceeded',
                        'EOrder:Scheduled orders limit exceeded' => '\\ccxt\\InvalidOrder',
                        'EOrder:Unknown position' => '\\ccxt\\OrderNotFound',
                        'EOrder:Unknown order' => '\\ccxt\\OrderNotFound',
                        'EOrder:Invalid order' => '\\ccxt\\InvalidOrder',
                        'EService:Deadline elapsed' => '\\ccxt\\ExchangeNotAvailable',
                        'EService:Market in cancel_only mode' => '\\ccxt\\NotSupported',
                        'EService:Market in limit_only mode' => '\\ccxt\\NotSupported',
                        'EService:Market in post_only mode' => '\\ccxt\\NotSupported',
                        'EService:Unavailable' => '\\ccxt\\ExchangeNotAvailable',
                        'ETrade:Invalid request' => '\\ccxt\\BadRequest',
                    ),
                ),
            ),
        ));
    }

    public function create_order_ws(string $symbol, string $type, string $side, float $amount, ?float $price = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $type, $side, $amount, $price, $params) {
            /**
             * @see https://docs.kraken.com/api/docs/websocket-v1/addorder
             * create a trade order
             * @param {string} $symbol unified $symbol of the $market to create an order in
             * @param {string} $type 'market' or 'limit'
             * @param {string} $side 'buy' or 'sell'
             * @param {float} $amount how much of currency you want to trade in units of base currency
             * @param {float} [$price] the $price at which the order is to be fulfilled, in units of the quote currency, ignored in $market orders
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} an ~@link https://docs.ccxt.com/#/?id=order-structure order structure~
             */
            Async\await($this->load_markets());
            $token = Async\await($this->authenticate());
            $market = $this->market($symbol);
            $url = $this->urls['api']['ws']['private'];
            $requestId = $this->request_id();
            $messageHash = $requestId;
            $request = array(
                'event' => 'addOrder',
                'token' => $token,
                'reqid' => $requestId,
                'ordertype' => $type,
                'type' => $side,
                'pair' => $market['wsId'],
                'volume' => $this->amount_to_precision($symbol, $amount),
            );
            list($request, $params) = $this->orderRequest ('createOrderWs', $symbol, $type, $request, $amount, $price, $params);
            return Async\await($this->watch($url, $messageHash, $this->extend($request, $params), $messageHash));
        }) ();
    }

    public function handle_create_edit_order($client, $message) {
        //
        //  createOrder
        //    {
        //        "descr" => "sell 0.00010000 XBTUSDT @ market",
        //        "event" => "addOrderStatus",
        //        "reqid" => 1,
        //        "status" => "ok",
        //        "txid" => "OAVXZH-XIE54-JCYYDG"
        //    }
        //  editOrder
        //    {
        //        "descr" => "order edited price = 9000.00000000",
        //        "event" => "editOrderStatus",
        //        "originaltxid" => "O65KZW-J4AW3-VFS74A",
        //        "reqid" => 3,
        //        "status" => "ok",
        //        "txid" => "OTI672-HJFAO-XOIPPK"
        //    }
        //
        $order = $this->parse_order($message);
        $messageHash = $this->safe_value($message, 'reqid');
        $client->resolve ($order, $messageHash);
    }

    public function edit_order_ws(string $id, string $symbol, string $type, string $side, ?float $amount = null, ?float $price = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($id, $symbol, $type, $side, $amount, $price, $params) {
            /**
             * edit a trade order
             * @see https://docs.kraken.com/api/docs/websocket-v1/editorder
             * @param {string} $id order $id
             * @param {string} $symbol unified $symbol of the $market to create an order in
             * @param {string} $type 'market' or 'limit'
             * @param {string} $side 'buy' or 'sell'
             * @param {float} $amount how much of the currency you want to trade in units of the base currency
             * @param {float} [$price] the $price at which the order is to be fulfilled, in units of the quote currency, ignored in $market orders
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} an ~@link https://docs.ccxt.com/#/?$id=order-structure order structure~
             */
            Async\await($this->load_markets());
            $token = Async\await($this->authenticate());
            $market = $this->market($symbol);
            $url = $this->urls['api']['ws']['private'];
            $requestId = $this->request_id();
            $messageHash = $requestId;
            $request = array(
                'event' => 'editOrder',
                'token' => $token,
                'reqid' => $requestId,
                'orderid' => $id,
                'pair' => $market['wsId'],
            );
            if ($amount !== null) {
                $request['volume'] = $this->amount_to_precision($symbol, $amount);
            }
            list($request, $params) = $this->orderRequest ('editOrderWs', $symbol, $type, $request, $amount, $price, $params);
            return Async\await($this->watch($url, $messageHash, $this->extend($request, $params), $messageHash));
        }) ();
    }

    public function cancel_orders_ws(array $ids, ?string $symbol = null, $params = array ()) {
        return Async\async(function () use ($ids, $symbol, $params) {
            /**
             * @see https://docs.kraken.com/api/docs/websocket-v1/cancelorder
             * cancel multiple orders
             * @param {string[]} $ids order $ids
             * @param {string} $symbol unified market $symbol, default is null
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} an list of ~@link https://docs.ccxt.com/#/?id=order-structure order structures~
             */
            Async\await($this->load_markets());
            $token = Async\await($this->authenticate());
            $url = $this->urls['api']['ws']['private'];
            $requestId = $this->request_id();
            $messageHash = $requestId;
            $request = array(
                'event' => 'cancelOrder',
                'token' => $token,
                'reqid' => $requestId,
                'txid' => $ids,
            );
            return Async\await($this->watch($url, $messageHash, $this->extend($request, $params), $messageHash));
        }) ();
    }

    public function cancel_order_ws(string $id, ?string $symbol = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($id, $symbol, $params) {
            /**
             * @see https://docs.kraken.com/api/docs/websocket-v1/cancelorder
             * cancels an open order
             * @param {string} $id order $id
             * @param {string} $symbol unified $symbol of the market the order was made in
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} An ~@link https://docs.ccxt.com/#/?$id=order-structure order structure~
             */
            Async\await($this->load_markets());
            $token = Async\await($this->authenticate());
            $url = $this->urls['api']['ws']['private'];
            $requestId = $this->request_id();
            $messageHash = $requestId;
            $clientOrderId = $this->safe_value_2($params, 'userref', 'clientOrderId', $id);
            $params = $this->omit($params, array( 'userref', 'clientOrderId' ));
            $request = array(
                'event' => 'cancelOrder',
                'token' => $token,
                'reqid' => $requestId,
                'txid' => array( $clientOrderId ),
            );
            return Async\await($this->watch($url, $messageHash, $this->extend($request, $params), $messageHash));
        }) ();
    }

    public function handle_cancel_order($client, $message) {
        //
        //  success
        //    {
        //        "event" => "cancelOrderStatus",
        //        "status" => "ok"
        //        "reqid" => 1,
        //    }
        //
        $reqId = $this->safe_value($message, 'reqid');
        $client->resolve ($message, $reqId);
    }

    public function cancel_all_orders_ws(?string $symbol = null, $params = array ()) {
        return Async\async(function () use ($symbol, $params) {
            /**
             * @see https://docs.kraken.com/api/docs/websocket-v1/cancelall
             * cancel all open orders
             * @param {string} $symbol unified market $symbol, only orders in the market of this $symbol are cancelled when $symbol is not null
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array[]} a list of ~@link https://docs.ccxt.com/#/?id=order-structure order structures~
             */
            if ($symbol !== null) {
                throw new NotSupported($this->id . ' cancelAllOrdersWs () does not support cancelling orders in a specific market.');
            }
            Async\await($this->load_markets());
            $token = Async\await($this->authenticate());
            $url = $this->urls['api']['ws']['private'];
            $requestId = $this->request_id();
            $messageHash = $requestId;
            $request = array(
                'event' => 'cancelAll',
                'token' => $token,
                'reqid' => $requestId,
            );
            return Async\await($this->watch($url, $messageHash, $this->extend($request, $params), $messageHash));
        }) ();
    }

    public function handle_cancel_all_orders($client, $message) {
        //
        //    {
        //        "count" => 2,
        //        "event" => "cancelAllStatus",
        //        "status" => "ok",
        //        "reqId" => 1
        //    }
        //
        $reqId = $this->safe_value($message, 'reqid');
        $client->resolve ($message, $reqId);
    }

    public function handle_ticker($client, $message, $subscription) {
        //
        //     array(
        //         0, // channelID
        //         array(
        //             "a" => array( "5525.40000", 1, "1.000" ), // ask, wholeAskVolume, askVolume
        //             "b" => array( "5525.10000", 1, "1.000" ), // bid, wholeBidVolume, bidVolume
        //             "c" => array( "5525.10000", "0.00398963" ), // closing price, volume
        //             "h" => array( "5783.00000", "5783.00000" ), // high price today, high price 24h ago
        //             "l" => array( "5505.00000", "5505.00000" ), // low price today, low price 24h ago
        //             "o" => array( "5760.70000", "5763.40000" ), // open price today, open price 24h ago
        //             "p" => array( "5631.44067", "5653.78939" ), // $vwap today, $vwap 24h ago
        //             "t" => array( 11493, 16267 ), // number of trades today, 24 hours ago
        //             "v" => array( "2634.11501494", "3591.17907851" ), // volume today, volume 24 hours ago
        //         ),
        //         "ticker",
        //         "XBT/USD"
        //     )
        //
        $wsName = $message[3];
        $market = $this->safe_value($this->options['marketsByWsName'], $wsName);
        $symbol = $market['symbol'];
        $messageHash = $this->get_message_hash('ticker', null, $symbol);
        $ticker = $message[1];
        $vwap = $this->safe_string($ticker['p'], 0);
        $quoteVolume = null;
        $baseVolume = $this->safe_string($ticker['v'], 0);
        if ($baseVolume !== null && $vwap !== null) {
            $quoteVolume = Precise::string_mul($baseVolume, $vwap);
        }
        $last = $this->safe_string($ticker['c'], 0);
        $result = $this->safe_ticker(array(
            'symbol' => $symbol,
            'timestamp' => null,
            'datetime' => null,
            'high' => $this->safe_string($ticker['h'], 0),
            'low' => $this->safe_string($ticker['l'], 0),
            'bid' => $this->safe_string($ticker['b'], 0),
            'bidVolume' => $this->safe_string($ticker['b'], 2),
            'ask' => $this->safe_string($ticker['a'], 0),
            'askVolume' => $this->safe_string($ticker['a'], 2),
            'vwap' => $vwap,
            'open' => $this->safe_string($ticker['o'], 0),
            'close' => $last,
            'last' => $last,
            'previousClose' => null,
            'change' => null,
            'percentage' => null,
            'average' => null,
            'baseVolume' => $baseVolume,
            'quoteVolume' => $quoteVolume,
            'info' => $ticker,
        ));
        $this->tickers[$symbol] = $result;
        $client->resolve ($result, $messageHash);
    }

    public function handle_trades(Client $client, $message, $subscription) {
        //
        //     array(
        //         0, // channelID
        //         array( //     price        volume         time             side type misc
        //             array( "5541.20000", "0.15850568", "1534614057.321596", "s", "l", "" ),
        //             array( "6060.00000", "0.02455000", "1534614057.324998", "b", "l", "" ),
        //         ),
        //         "trade",
        //         "XBT/USD"
        //     )
        //
        $wsName = $this->safe_string($message, 3);
        $name = $this->safe_string($message, 2);
        $market = $this->safe_value($this->options['marketsByWsName'], $wsName);
        $symbol = $market['symbol'];
        $messageHash = $this->get_message_hash($name, null, $symbol);
        $stored = $this->safe_value($this->trades, $symbol);
        if ($stored === null) {
            $limit = $this->safe_integer($this->options, 'tradesLimit', 1000);
            $stored = new ArrayCache ($limit);
            $this->trades[$symbol] = $stored;
        }
        $trades = $this->safe_value($message, 1, array());
        $parsed = $this->parse_trades($trades, $market);
        for ($i = 0; $i < count($parsed); $i++) {
            $stored->append ($parsed[$i]);
        }
        $client->resolve ($stored, $messageHash);
    }

    public function handle_ohlcv(Client $client, $message, $subscription) {
        //
        //     array(
        //         216, // channelID
        //         array(
        //             "1574454214.962096", // Time, seconds since epoch
        //             "1574454240.000000", // End $timestamp of the $interval
        //             "0.020970", // Open price at midnight UTC
        //             "0.020970", // Intraday high price
        //             "0.020970", // Intraday low price
        //             "0.020970", // Closing price at midnight UTC
        //             "0.020970", // Volume weighted average price
        //             "0.08636138", // Accumulated volume today
        //             1, // Number of trades today
        //         ),
        //         "ohlc-1", // Channel Name of $subscription
        //         "ETH/XBT", // Asset pair
        //     )
        //
        $info = $this->safe_value($subscription, 'subscription', array());
        $interval = $this->safe_integer($info, 'interval');
        $name = $this->safe_string($info, 'name');
        $wsName = $this->safe_string($message, 3);
        $market = $this->safe_value($this->options['marketsByWsName'], $wsName);
        $symbol = $market['symbol'];
        $timeframe = $this->find_timeframe($interval);
        $duration = $this->parse_timeframe($timeframe);
        if ($timeframe !== null) {
            $candle = $this->safe_value($message, 1);
            $messageHash = $name . ':' . $timeframe . ':' . $wsName;
            $timestamp = $this->safe_float($candle, 1);
            $timestamp -= $duration;
            $ts = $this->parse_to_int($timestamp * 1000);
            $result = array(
                $ts,
                $this->safe_float($candle, 2),
                $this->safe_float($candle, 3),
                $this->safe_float($candle, 4),
                $this->safe_float($candle, 5),
                $this->safe_float($candle, 7),
            );
            $this->ohlcvs[$symbol] = $this->safe_value($this->ohlcvs, $symbol, array());
            $stored = $this->safe_value($this->ohlcvs[$symbol], $timeframe);
            if ($stored === null) {
                $limit = $this->safe_integer($this->options, 'OHLCVLimit', 1000);
                $stored = new ArrayCacheByTimestamp ($limit);
                $this->ohlcvs[$symbol][$timeframe] = $stored;
            }
            $stored->append ($result);
            $client->resolve ($stored, $messageHash);
        }
    }

    public function request_id() {
        // their support said that $reqid must be an int32, not documented
        $reqid = $this->sum($this->safe_integer($this->options, 'reqid', 0), 1);
        $this->options['reqid'] = $reqid;
        return $reqid;
    }

    public function watch_public($name, $symbol, $params = array ()) {
        return Async\async(function () use ($name, $symbol, $params) {
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $wsName = $this->safe_value($market['info'], 'wsname');
            $messageHash = $name . ':' . $wsName;
            $url = $this->urls['api']['ws']['public'];
            $requestId = $this->request_id();
            $subscribe = array(
                'event' => 'subscribe',
                'reqid' => $requestId,
                'pair' => array(
                    $wsName,
                ),
                'subscription' => array(
                    'name' => $name,
                ),
            );
            $request = $this->deep_extend($subscribe, $params);
            return Async\await($this->watch($url, $messageHash, $request, $messageHash));
        }) ();
    }

    public function watch_ticker(string $symbol, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $params) {
            /**
             * watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
             * @see https://docs.kraken.com/api/docs/websocket-v1/ticker
             * @param {string} $symbol unified $symbol of the market to fetch the ticker for
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} a ~@link https://docs.ccxt.com/#/?id=ticker-structure ticker structure~
             */
            Async\await($this->load_markets());
            $symbol = $this->symbol($symbol);
            $tickers = Async\await($this->watch_tickers(array( $symbol ), $params));
            return $tickers[$symbol];
        }) ();
    }

    public function watch_tickers(?array $symbols = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbols, $params) {
            /**
             * watches a price $ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
             * @see https://docs.kraken.com/api/docs/websocket-v1/ticker
             * @param {string} symbol unified symbol of the market to fetch the $ticker for
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} a ~@link https://docs.ccxt.com/#/?id=$ticker-structure $ticker structure~
             */
            Async\await($this->load_markets());
            $symbols = $this->market_symbols($symbols, null, false);
            $ticker = Async\await($this->watch_multi_helper('ticker', 'ticker', $symbols, null, $params));
            if ($this->newUpdates) {
                $result = array();
                $result[$ticker['symbol']] = $ticker;
                return $result;
            }
            return $this->filter_by_array($this->tickers, 'symbol', $symbols);
        }) ();
    }

    public function watch_trades(string $symbol, ?int $since = null, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            /**
             * get the list of most recent trades for a particular $symbol
             * @see https://docs.kraken.com/api/docs/websocket-v1/trade
             * @param {string} $symbol unified $symbol of the market to fetch trades for
             * @param {int} [$since] timestamp in ms of the earliest trade to fetch
             * @param {int} [$limit] the maximum amount of trades to fetch
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array[]} a list of ~@link https://docs.ccxt.com/#/?id=public-trades trade structures~
             */
            return Async\await($this->watch_trades_for_symbols(array( $symbol ), $since, $limit, $params));
        }) ();
    }

    public function watch_trades_for_symbols(array $symbols, ?int $since = null, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbols, $since, $limit, $params) {
            /**
             * @see https://docs.kraken.com/api/docs/websocket-v1/trade
             * get the list of most recent $trades for a list of $symbols
             * @param {string[]} $symbols unified symbol of the market to fetch $trades for
             * @param {int} [$since] timestamp in ms of the earliest trade to fetch
             * @param {int} [$limit] the maximum amount of $trades to fetch
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array[]} a list of ~@link https://docs.ccxt.com/#/?id=public-$trades trade structures~
             */
            $trades = Async\await($this->watch_multi_helper('trade', 'trade', $symbols, null, $params));
            if ($this->newUpdates) {
                $first = $this->safe_list($trades, 0);
                $tradeSymbol = $this->safe_string($first, 'symbol');
                $limit = $trades->getLimit ($tradeSymbol, $limit);
            }
            return $this->filter_by_since_limit($trades, $since, $limit, 'timestamp', true);
        }) ();
    }

    public function watch_order_book(string $symbol, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $limit, $params) {
            /**
             * watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
             * @see https://docs.kraken.com/api/docs/websocket-v1/book
             * @param {string} $symbol unified $symbol of the market to fetch the order book for
             * @param {int} [$limit] the maximum amount of order book entries to return
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} A dictionary of ~@link https://docs.ccxt.com/#/?id=order-book-structure order book structures~ indexed by market symbols
             */
            return Async\await($this->watch_order_book_for_symbols(array( $symbol ), $limit, $params));
        }) ();
    }

    public function watch_order_book_for_symbols(array $symbols, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbols, $limit, $params) {
            /**
             * watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
             * @see https://docs.kraken.com/api/docs/websocket-v1/book
             * @param {string[]} $symbols unified array of $symbols
             * @param {int} [$limit] the maximum amount of order book entries to return
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} A dictionary of ~@link https://docs.ccxt.com/#/?id=order-book-structure order book structures~ indexed by market $symbols
             */
            $request = array();
            if ($limit !== null) {
                if ($this->in_array($limit, array( 10, 25, 100, 500, 1000 ))) {
                    $request['subscription'] = array(
                        'depth' => $limit, // default 10, valid options 10, 25, 100, 500, 1000
                    );
                } else {
                    throw new NotSupported($this->id . ' watchOrderBook accepts $limit values of 10, 25, 100, 500 and 1000 only');
                }
            }
            $orderbook = Async\await($this->watch_multi_helper('orderbook', 'book', $symbols, array( 'limit' => $limit ), $this->extend($request, $params)));
            return $orderbook->limit ();
        }) ();
    }

    public function watch_ohlcv(string $symbol, $timeframe = '1m', ?int $since = null, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $timeframe, $since, $limit, $params) {
            /**
             * watches historical candlestick data containing the open, high, low, and close price, and the volume of a $market
             * @see https://docs.kraken.com/api/docs/websocket-v1/ohlc
             * @param {string} $symbol unified $symbol of the $market to fetch OHLCV data for
             * @param {string} $timeframe the length of time each candle represents
             * @param {int} [$since] timestamp in ms of the earliest candle to fetch
             * @param {int} [$limit] the maximum amount of candles to fetch
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {int[][]} A list of candles ordered, open, high, low, close, volume
             */
            Async\await($this->load_markets());
            $name = 'ohlc';
            $market = $this->market($symbol);
            $symbol = $market['symbol'];
            $wsName = $this->safe_value($market['info'], 'wsname');
            $messageHash = $name . ':' . $timeframe . ':' . $wsName;
            $url = $this->urls['api']['ws']['public'];
            $requestId = $this->request_id();
            $subscribe = array(
                'event' => 'subscribe',
                'reqid' => $requestId,
                'pair' => array(
                    $wsName,
                ),
                'subscription' => array(
                    'name' => $name,
                    'interval' => $this->safe_value($this->timeframes, $timeframe, $timeframe),
                ),
            );
            $request = $this->deep_extend($subscribe, $params);
            $ohlcv = Async\await($this->watch($url, $messageHash, $request, $messageHash));
            if ($this->newUpdates) {
                $limit = $ohlcv->getLimit ($symbol, $limit);
            }
            return $this->filter_by_since_limit($ohlcv, $since, $limit, 0, true);
        }) ();
    }

    public function load_markets($reload = false, $params = array ()) {
        return Async\async(function () use ($reload, $params) {
            $markets = Async\await(parent::load_markets($reload, $params));
            $marketsByWsName = $this->safe_value($this->options, 'marketsByWsName');
            if (($marketsByWsName === null) || $reload) {
                $marketsByWsName = array();
                for ($i = 0; $i < count($this->symbols); $i++) {
                    $symbol = $this->symbols[$i];
                    $market = $this->markets[$symbol];
                    if ($market['darkpool']) {
                        $info = $this->safe_value($market, 'info', array());
                        $altname = $this->safe_string($info, 'altname');
                        $wsName = mb_substr($altname, 0, 3 - 0) . '/' . mb_substr($altname, 3);
                        $marketsByWsName[$wsName] = $market;
                    } else {
                        $info = $this->safe_value($market, 'info', array());
                        $wsName = $this->safe_string($info, 'wsname');
                        $marketsByWsName[$wsName] = $market;
                    }
                }
                $this->options['marketsByWsName'] = $marketsByWsName;
            }
            return $markets;
        }) ();
    }

    public function watch_heartbeat($params = array ()) {
        return Async\async(function () use ($params) {
            Async\await($this->load_markets());
            $event = 'heartbeat';
            $url = $this->urls['api']['ws']['public'];
            return Async\await($this->watch($url, $event));
        }) ();
    }

    public function handle_heartbeat(Client $client, $message) {
        //
        // every second (approx) if no other updates are sent
        //
        //     array( "event" => "heartbeat" )
        //
        $event = $this->safe_string($message, 'event');
        $client->resolve ($message, $event);
    }

    public function handle_order_book(Client $client, $message, $subscription) {
        //
        // first $message (snapshot)
        //
        //     array(
        //         1234, // channelID
        //         array(
        //             "as" => array(
        //                 array( "5541.30000", "2.50700000", "1534614248.123678" ),
        //                 array( "5541.80000", "0.33000000", "1534614098.345543" ),
        //                 array( "5542.70000", "0.64700000", "1534614244.654432" )
        //             ),
        //             "bs" => array(
        //                 array( "5541.20000", "1.52900000", "1534614248.765567" ),
        //                 array( "5539.90000", "0.30000000", "1534614241.769870" ),
        //                 array( "5539.50000", "5.00000000", "1534613831.243486" )
        //             )
        //         ),
        //         "book-10",
        //         "XBT/USD"
        //     )
        //
        // subsequent updates
        //
        //     array(
        //         1234,
        //         array( // optional
        //             "a" => array(
        //                 array( "5541.30000", "2.50700000", "1534614248.456738" ),
        //                 array( "5542.50000", "0.40100000", "1534614248.456738" )
        //             )
        //         ),
        //         array( // optional
        //             "b" => array(
        //                 array( "5541.30000", "0.00000000", "1534614335.345903" )
        //             )
        //         ),
        //         "book-10",
        //         "XBT/USD"
        //     )
        //
        $messageLength = count($message);
        $wsName = $message[$messageLength - 1];
        $bookDepthString = $message[$messageLength - 2];
        $parts = explode('-', $bookDepthString);
        $depth = $this->safe_integer($parts, 1, 10);
        $market = $this->safe_value($this->options['marketsByWsName'], $wsName);
        $symbol = $market['symbol'];
        $timestamp = null;
        $messageHash = $this->get_message_hash('orderbook', null, $symbol);
        // if this is $a snapshot
        if (is_array($message[1]) && array_key_exists('as', $message[1])) {
            // todo get $depth from marketsByWsName
            $this->orderbooks[$symbol] = $this->order_book(array(), $depth);
            $orderbook = $this->orderbooks[$symbol];
            $sides = array(
                'as' => 'asks',
                'bs' => 'bids',
            );
            $keys = is_array($sides) ? array_keys($sides) : array();
            for ($i = 0; $i < count($keys); $i++) {
                $key = $keys[$i];
                $side = $sides[$key];
                $bookside = $orderbook[$side];
                $deltas = $this->safe_value($message[1], $key, array());
                $timestamp = $this->custom_handle_deltas($bookside, $deltas, $timestamp);
            }
            $orderbook['symbol'] = $symbol;
            $orderbook['timestamp'] = $timestamp;
            $orderbook['datetime'] = $this->iso8601($timestamp);
            $client->resolve ($orderbook, $messageHash);
        } else {
            $orderbook = $this->orderbooks[$symbol];
            // else, if this is an $orderbook update
            $a = null;
            $b = null;
            $c = null;
            if ($messageLength === 5) {
                $a = $this->safe_value($message[1], 'a', array());
                $b = $this->safe_value($message[2], 'b', array());
                $c = $this->safe_integer($message[1], 'c');
                $c = $this->safe_integer($message[2], 'c', $c);
            } else {
                $c = $this->safe_integer($message[1], 'c');
                if (is_array($message[1]) && array_key_exists('a', $message[1])) {
                    $a = $this->safe_value($message[1], 'a', array());
                } else {
                    $b = $this->safe_value($message[1], 'b', array());
                }
            }
            $storedAsks = $orderbook['asks'];
            $storedBids = $orderbook['bids'];
            $example = null;
            if ($a !== null) {
                $timestamp = $this->custom_handle_deltas($storedAsks, $a, $timestamp);
                $example = $this->safe_value($a, 0);
            }
            if ($b !== null) {
                $timestamp = $this->custom_handle_deltas($storedBids, $b, $timestamp);
                $example = $this->safe_value($b, 0);
            }
            // don't remove this line or I will poop on your face
            $orderbook->limit ();
            $checksum = $this->handle_option('watchOrderBook', 'checksum', true);
            if ($checksum) {
                $priceString = $this->safe_string($example, 0);
                $amountString = $this->safe_string($example, 1);
                $priceParts = explode('.', $priceString);
                $amountParts = explode('.', $amountString);
                $priceLength = strlen($priceParts[1]) - 0;
                $amountLength = strlen($amountParts[1]) - 0;
                $payloadArray = array();
                if ($c !== null) {
                    for ($i = 0; $i < 10; $i++) {
                        $formatted = $this->format_number($storedAsks[$i][0], $priceLength) . $this->format_number($storedAsks[$i][1], $amountLength);
                        $payloadArray[] = $formatted;
                    }
                    for ($i = 0; $i < 10; $i++) {
                        $formatted = $this->format_number($storedBids[$i][0], $priceLength) . $this->format_number($storedBids[$i][1], $amountLength);
                        $payloadArray[] = $formatted;
                    }
                }
                $payload = implode('', $payloadArray);
                $localChecksum = $this->crc32($payload, false);
                if ($localChecksum !== $c) {
                    $error = new ChecksumError ($this->id . ' ' . $this->orderbook_checksum_message($symbol));
                    unset($client->subscriptions[$messageHash]);
                    unset($this->orderbooks[$symbol]);
                    $client->reject ($error, $messageHash);
                    return;
                }
            }
            $orderbook['symbol'] = $symbol;
            $orderbook['timestamp'] = $timestamp;
            $orderbook['datetime'] = $this->iso8601($timestamp);
            $client->resolve ($orderbook, $messageHash);
        }
    }

    public function format_number($n, $length) {
        $stringNumber = $this->number_to_string($n);
        $parts = explode('.', $stringNumber);
        $integer = $this->safe_string($parts, 0);
        $decimals = $this->safe_string($parts, 1, '');
        $paddedDecimals = str_pad($decimals, $length, '0', STR_PAD_RIGHT);
        $joined = $integer . $paddedDecimals;
        $i = 0;
        while ($joined[$i] === '0') {
            $i += 1;
        }
        if ($i > 0) {
            return mb_substr($joined, $i);
        } else {
            return $joined;
        }
    }

    public function custom_handle_deltas($bookside, $deltas, $timestamp = null) {
        for ($j = 0; $j < count($deltas); $j++) {
            $delta = $deltas[$j];
            $price = $this->parse_number($delta[0]);
            $amount = $this->parse_number($delta[1]);
            $oldTimestamp = $timestamp ? $timestamp : 0;
            $timestamp = max ($oldTimestamp, $this->parse_to_int(floatval($delta[2]) * 1000));
            $bookside->store ($price, $amount);
        }
        return $timestamp;
    }

    public function handle_system_status(Client $client, $message) {
        //
        // todo => answer the question whether handleSystemStatus should be renamed
        // and unified for any usage pattern that
        // involves system status and maintenance updates
        //
        //     {
        //         "connectionID" => 15527282728335292000,
        //         "event" => "systemStatus",
        //         "status" => "online", // online|maintenance|(custom status tbd)
        //         "version" => "0.2.0"
        //     }
        //
        return $message;
    }

    public function authenticate($params = array ()) {
        return Async\async(function () use ($params) {
            $url = $this->urls['api']['ws']['private'];
            $client = $this->client($url);
            $authenticated = 'authenticated';
            $subscription = $this->safe_value($client->subscriptions, $authenticated);
            if ($subscription === null) {
                $response = Async\await($this->privatePostGetWebSocketsToken ($params));
                //
                //     {
                //         "error":array(),
                //         "result":{
                //             "token":"xeAQ\/RCChBYNVh53sTv1yZ5H4wIbwDF20PiHtTF+4UI",
                //             "expires":900
                //         }
                //     }
                //
                $subscription = $this->safe_value($response, 'result');
                $client->subscriptions[$authenticated] = $subscription;
            }
            return $this->safe_string($subscription, 'token');
        }) ();
    }

    public function watch_private($name, ?string $symbol = null, ?int $since = null, ?int $limit = null, $params = array ()) {
        return Async\async(function () use ($name, $symbol, $since, $limit, $params) {
            Async\await($this->load_markets());
            $token = Async\await($this->authenticate());
            $subscriptionHash = $name;
            $messageHash = $name;
            if ($symbol !== null) {
                $symbol = $this->symbol($symbol);
                $messageHash .= ':' . $symbol;
            }
            $url = $this->urls['api']['ws']['private'];
            $requestId = $this->request_id();
            $subscribe = array(
                'event' => 'subscribe',
                'reqid' => $requestId,
                'subscription' => array(
                    'name' => $name,
                    'token' => $token,
                ),
            );
            $request = $this->deep_extend($subscribe, $params);
            $result = Async\await($this->watch($url, $messageHash, $request, $subscriptionHash));
            if ($this->newUpdates) {
                $limit = $result->getLimit ($symbol, $limit);
            }
            return $this->filter_by_symbol_since_limit($result, $symbol, $since, $limit);
        }) ();
    }

    public function watch_my_trades(?string $symbol = null, ?int $since = null, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            /**
             * watches information on multiple trades made by the user
             * @see https://docs.kraken.com/api/docs/websocket-v1/owntrades
             * @param {string} $symbol unified market $symbol of the market trades were made in
             * @param {int} [$since] the earliest time in ms to fetch trades for
             * @param {int} [$limit] the maximum number of trade structures to retrieve
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array[]} a list of ~@link https://docs.ccxt.com/#/?id=trade-structure trade structures~
             */
            return Async\await($this->watch_private('ownTrades', $symbol, $since, $limit, $params));
        }) ();
    }

    public function handle_my_trades(Client $client, $message, $subscription = null) {
        //
        //     array(
        //         array(
        //             {
        //                 "TT5UC3-GOIRW-6AZZ6R" => array(
        //                     "cost" => "1493.90107",
        //                     "fee" => "3.88415",
        //                     "margin" => "0.00000",
        //                     "ordertxid" => "OTLAS3-RRHUF-NDWH5A",
        //                     "ordertype" => "market",
        //                     "pair" => "XBT/USDT",
        //                     "postxid" => "TKH2SE-M7IF5-CFI7LT",
        //                     "price" => "6851.50005",
        //                     "time" => "1586822919.335498",
        //                     "type" => "sell",
        //                     "vol" => "0.21804000"
        //                 }
        //             ),
        //             {
        //                 "TIY6G4-LKLAI-Y3GD4A" => array(
        //                     "cost" => "22.17134",
        //                     "fee" => "0.05765",
        //                     "margin" => "0.00000",
        //                     "ordertxid" => "ODQXS7-MOLK6-ICXKAA",
        //                     "ordertype" => "market",
        //                     "pair" => "ETH/USD",
        //                     "postxid" => "TKH2SE-M7IF5-CFI7LT",
        //                     "price" => "169.97999",
        //                     "time" => "1586340530.895739",
        //                     "type" => "buy",
        //                     "vol" => "0.13043500"
        //                 }
        //             ),
        //         ),
        //         "ownTrades",
        //         array( sequence => 1 )
        //     )
        //
        $allTrades = $this->safe_value($message, 0, array());
        $allTradesLength = count($allTrades);
        if ($allTradesLength > 0) {
            if ($this->myTrades === null) {
                $limit = $this->safe_integer($this->options, 'tradesLimit', 1000);
                $this->myTrades = new ArrayCache ($limit);
            }
            $stored = $this->myTrades;
            $symbols = array();
            for ($i = 0; $i < count($allTrades); $i++) {
                $trades = $this->safe_value($allTrades, $i, array());
                $ids = is_array($trades) ? array_keys($trades) : array();
                for ($j = 0; $j < count($ids); $j++) {
                    $id = $ids[$j];
                    $trade = $trades[$id];
                    $parsed = $this->parse_ws_trade($this->extend(array( 'id' => $id ), $trade));
                    $stored->append ($parsed);
                    $symbol = $parsed['symbol'];
                    $symbols[$symbol] = true;
                }
            }
            $name = 'ownTrades';
            $client->resolve ($this->myTrades, $name);
            $keys = is_array($symbols) ? array_keys($symbols) : array();
            for ($i = 0; $i < count($keys); $i++) {
                $messageHash = $name . ':' . $keys[$i];
                $client->resolve ($this->myTrades, $messageHash);
            }
        }
    }

    public function parse_ws_trade($trade, $market = null) {
        //
        //     {
        //         "id" => "TIMIRG-WUNNE-RRJ6GT", // injected from outside
        //         "ordertxid" => "OQRPN2-LRHFY-HIFA7D",
        //         "postxid" => "TKH2SE-M7IF5-CFI7LT",
        //         "pair" => "USDCUSDT",
        //         "time" => 1586340086.457,
        //         "type" => "sell",
        //         "ordertype" => "market",
        //         "price" => "0.99860000",
        //         "cost" => "22.16892001",
        //         "fee" => "0.04433784",
        //         "vol" => "22.20000000",
        //         "margin" => "0.00000000",
        //         "misc" => ''
        //     }
        //
        //     {
        //         "id" => "TIY6G4-LKLAI-Y3GD4A",
        //         "cost" => "22.17134",
        //         "fee" => "0.05765",
        //         "margin" => "0.00000",
        //         "ordertxid" => "ODQXS7-MOLK6-ICXKAA",
        //         "ordertype" => "market",
        //         "pair" => "ETH/USD",
        //         "postxid" => "TKH2SE-M7IF5-CFI7LT",
        //         "price" => "169.97999",
        //         "time" => "1586340530.895739",
        //         "type" => "buy",
        //         "vol" => "0.13043500"
        //     }
        //
        $wsName = $this->safe_string($trade, 'pair');
        $market = $this->safe_value($this->options['marketsByWsName'], $wsName, $market);
        $symbol = null;
        $orderId = $this->safe_string($trade, 'ordertxid');
        $id = $this->safe_string_2($trade, 'id', 'postxid');
        $timestamp = $this->safe_timestamp($trade, 'time');
        $side = $this->safe_string($trade, 'type');
        $type = $this->safe_string($trade, 'ordertype');
        $price = $this->safe_float($trade, 'price');
        $amount = $this->safe_float($trade, 'vol');
        $cost = null;
        $fee = null;
        if (is_array($trade) && array_key_exists('fee', $trade)) {
            $currency = null;
            if ($market !== null) {
                $currency = $market['quote'];
            }
            $fee = array(
                'cost' => $this->safe_float($trade, 'fee'),
                'currency' => $currency,
            );
        }
        if ($market !== null) {
            $symbol = $market['symbol'];
        }
        if ($price !== null) {
            if ($amount !== null) {
                $cost = $price * $amount;
            }
        }
        return array(
            'id' => $id,
            'order' => $orderId,
            'info' => $trade,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'symbol' => $symbol,
            'type' => $type,
            'side' => $side,
            'takerOrMaker' => null,
            'price' => $price,
            'amount' => $amount,
            'cost' => $cost,
            'fee' => $fee,
        );
    }

    public function watch_orders(?string $symbol = null, ?int $since = null, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            /**
             * @see https://docs.kraken.com/api/docs/websocket-v1/openorders
             * watches information on multiple orders made by the user
             * @param {string} $symbol unified market $symbol of the market orders were made in
             * @param {int} [$since] the earliest time in ms to fetch orders for
             * @param {int} [$limit] the maximum number of  orde structures to retrieve
             * @param {array} [$params] maximum number of orderic to the exchange API endpoint
             * @return {array[]} a list of ~@link https://docs.ccxt.com/#/?id=order-structure order structures~
             */
            return Async\await($this->watch_private('openOrders', $symbol, $since, $limit, $params));
        }) ();
    }

    public function handle_orders(Client $client, $message, $subscription = null) {
        //
        //     array(
        //         array(
        //             {
        //                 "OGTT3Y-C6I3P-XRI6HX" => array(
        //                     "cost" => "0.00000",
        //                     "descr" => array(
        //                         "close" => "",
        //                         "leverage" => "0:1",
        //                         "order" => "sell 10.00345345 XBT/EUR @ $limit 34.50000 with 0:1 leverage",
        //                         "ordertype" => "limit",
        //                         "pair" => "XBT/EUR",
        //                         "price" => "34.50000",
        //                         "price2" => "0.00000",
        //                         "type" => "sell"
        //                     ),
        //                     "expiretm" => "0.000000",
        //                     "fee" => "0.00000",
        //                     "limitprice" => "34.50000",
        //                     "misc" => "",
        //                     "oflags" => "fcib",
        //                     "opentm" => "0.000000",
        //                     "price" => "34.50000",
        //                     "refid" => "OKIVMP-5GVZN-Z2D2UA",
        //                     "starttm" => "0.000000",
        //                     "status" => "open",
        //                     "stopprice" => "0.000000",
        //                     "userref" => 0,
        //                     "vol" => "10.00345345",
        //                     "vol_exec" => "0.00000000"
        //                 }
        //             ),
        //             {
        //                 "OGTT3Y-C6I3P-XRI6HX" => array(
        //                     "cost" => "0.00000",
        //                     "descr" => array(
        //                         "close" => "",
        //                         "leverage" => "0:1",
        //                         "order" => "sell 0.00000010 XBT/EUR @ $limit 5334.60000 with 0:1 leverage",
        //                         "ordertype" => "limit",
        //                         "pair" => "XBT/EUR",
        //                         "price" => "5334.60000",
        //                         "price2" => "0.00000",
        //                         "type" => "sell"
        //                     ),
        //                     "expiretm" => "0.000000",
        //                     "fee" => "0.00000",
        //                     "limitprice" => "5334.60000",
        //                     "misc" => "",
        //                     "oflags" => "fcib",
        //                     "opentm" => "0.000000",
        //                     "price" => "5334.60000",
        //                     "refid" => "OKIVMP-5GVZN-Z2D2UA",
        //                     "starttm" => "0.000000",
        //                     "status" => "open",
        //                     "stopprice" => "0.000000",
        //                     "userref" => 0,
        //                     "vol" => "0.00000010",
        //                     "vol_exec" => "0.00000000"
        //                 }
        //             ),
        //         ),
        //         "openOrders",
        //         array( "sequence" => 234 )
        //     )
        //
        // status-change
        //
        //     array(
        //         array(
        //             array( "OGTT3Y-C6I3P-XRI6HX" => array( "status" => "closed" )),
        //             array( "OGTT3Y-C6I3P-XRI6HX" => array( "status" => "closed" )),
        //         ),
        //         "openOrders",
        //         array( "sequence" => 59342 )
        //     )
        //
        $allOrders = $this->safe_value($message, 0, array());
        $allOrdersLength = count($allOrders);
        if ($allOrdersLength > 0) {
            $limit = $this->safe_integer($this->options, 'ordersLimit', 1000);
            if ($this->orders === null) {
                $this->orders = new ArrayCacheBySymbolById ($limit);
            }
            $stored = $this->orders;
            $symbols = array();
            for ($i = 0; $i < count($allOrders); $i++) {
                $orders = $this->safe_value($allOrders, $i, array());
                $ids = is_array($orders) ? array_keys($orders) : array();
                for ($j = 0; $j < count($ids); $j++) {
                    $id = $ids[$j];
                    $order = $orders[$id];
                    $parsed = $this->parse_ws_order($order);
                    $parsed['id'] = $id;
                    $symbol = null;
                    $symbolsByOrderId = $this->safe_value($this->options, 'symbolsByOrderId', array());
                    if ($parsed['symbol'] !== null) {
                        $symbol = $parsed['symbol'];
                        $symbolsByOrderId[$id] = $symbol;
                        $this->options['symbolsByOrderId'] = $symbolsByOrderId;
                    } else {
                        $symbol = $this->safe_string($symbolsByOrderId, $id);
                    }
                    $previousOrders = $this->safe_value($stored->hashmap, $symbol);
                    $previousOrder = $this->safe_value($previousOrders, $id);
                    $newOrder = $parsed;
                    if ($previousOrder !== null) {
                        $newRawOrder = $this->extend($previousOrder['info'], $newOrder['info']);
                        $newOrder = $this->parse_ws_order($newRawOrder);
                        $newOrder['id'] = $id;
                    }
                    $length = count($stored);
                    if ($length === $limit && ($previousOrder === null)) {
                        $first = $stored[0];
                        if (is_array($symbolsByOrderId) && array_key_exists($first['id'], $symbolsByOrderId)) {
                            unset($symbolsByOrderId[$first['id']]);
                        }
                    }
                    $stored->append ($newOrder);
                    $symbols[$symbol] = true;
                }
            }
            $name = 'openOrders';
            $client->resolve ($this->orders, $name);
            $keys = is_array($symbols) ? array_keys($symbols) : array();
            for ($i = 0; $i < count($keys); $i++) {
                $messageHash = $name . ':' . $keys[$i];
                $client->resolve ($this->orders, $messageHash);
            }
        }
    }

    public function parse_ws_order($order, $market = null) {
        //
        // createOrder
        //    {
        //        "avg_price" => "0.00000",
        //        "cost" => "0.00000",
        //        "descr" => array(
        //            "close" => null,
        //            "leverage" => null,
        //            "order" => "sell 0.01000000 ETH/USDT @ limit 1900.00000",
        //            "ordertype" => "limit",
        //            "pair" => "ETH/USDT",
        //            "price" => "1900.00000",
        //            "price2" => "0.00000",
        //            "type" => "sell"
        //        ),
        //        "expiretm" => null,
        //        "fee" => "0.00000",
        //        "limitprice" => "0.00000",
        //        "misc" => '',
        //        "oflags" => "fciq",
        //        "opentm" => "1667522705.757622",
        //        "refid" => null,
        //        "starttm" => null,
        //        "status" => "open",
        //        "stopprice" => "0.00000",
        //        "timeinforce" => "GTC",
        //        "userref" => 0,
        //        "vol" => "0.01000000",
        //        "vol_exec" => "0.00000000"
        //    }
        //
        $description = $this->safe_value($order, 'descr', array());
        $orderDescription = $this->safe_string($description, 'order');
        $side = null;
        $type = null;
        $wsName = null;
        $price = null;
        $amount = null;
        if ($orderDescription !== null) {
            $parts = explode(' ', $orderDescription);
            $side = $this->safe_string($parts, 0);
            $amount = $this->safe_string($parts, 1);
            $wsName = $this->safe_string($parts, 2);
            $type = $this->safe_string($parts, 4);
            $price = $this->safe_string($parts, 5);
        }
        $side = $this->safe_string($description, 'type', $side);
        $type = $this->safe_string($description, 'ordertype', $type);
        $wsName = $this->safe_string($description, 'pair', $wsName);
        $market = $this->safe_value($this->options['marketsByWsName'], $wsName, $market);
        $symbol = null;
        $timestamp = $this->safe_timestamp($order, 'opentm');
        $amount = $this->safe_string($order, 'vol', $amount);
        $filled = $this->safe_string($order, 'vol_exec');
        $fee = null;
        $cost = $this->safe_string($order, 'cost');
        $price = $this->safe_string($description, 'price', $price);
        if (($price === null) || (Precise::string_eq($price, '0.0'))) {
            $price = $this->safe_string($description, 'price2');
        }
        if (($price === null) || (Precise::string_eq($price, '0.0'))) {
            $price = $this->safe_string($order, 'price', $price);
        }
        $average = $this->safe_string_2($order, 'avg_price', 'price');
        if ($market !== null) {
            $symbol = $market['symbol'];
            if (is_array($order) && array_key_exists('fee', $order)) {
                $flags = $order['oflags'];
                $feeCost = $this->safe_string($order, 'fee');
                $fee = array(
                    'cost' => $feeCost,
                    'rate' => null,
                );
                if (mb_strpos($flags, 'fciq') !== false) {
                    $fee['currency'] = $market['quote'];
                } elseif (mb_strpos($flags, 'fcib') !== false) {
                    $fee['currency'] = $market['base'];
                }
            }
        }
        $status = $this->parse_order_status($this->safe_string($order, 'status'));
        $id = $this->safe_string($order, 'id');
        if ($id === null) {
            $txid = $this->safe_value($order, 'txid');
            $id = $this->safe_string($txid, 0);
        }
        $clientOrderId = $this->safe_string($order, 'userref');
        $rawTrades = $this->safe_value($order, 'trades');
        $trades = null;
        if ($rawTrades !== null) {
            $trades = $this->parse_trades($rawTrades, $market, null, null, array( 'order' => $id ));
        }
        $stopPrice = $this->safe_number($order, 'stopprice');
        return $this->safe_order(array(
            'id' => $id,
            'clientOrderId' => $clientOrderId,
            'info' => $order,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'lastTradeTimestamp' => null,
            'status' => $status,
            'symbol' => $symbol,
            'type' => $type,
            'timeInForce' => null,
            'postOnly' => null,
            'side' => $side,
            'price' => $price,
            'stopPrice' => $stopPrice,
            'triggerPrice' => $stopPrice,
            'cost' => $cost,
            'amount' => $amount,
            'filled' => $filled,
            'average' => $average,
            'remaining' => null,
            'fee' => $fee,
            'trades' => $trades,
        ));
    }

    public function watch_multi_helper(string $unifiedName, string $channelName, ?array $symbols = null, $subscriptionArgs = null, $params = array ()) {
        return Async\async(function () use ($unifiedName, $channelName, $symbols, $subscriptionArgs, $params) {
            Async\await($this->load_markets());
            // $symbols are required
            $symbols = $this->market_symbols($symbols, null, false, true, false);
            $messageHashes = array();
            for ($i = 0; $i < count($symbols); $i++) {
                $messageHashes[] = $this->get_message_hash($unifiedName, null, $this->symbol($symbols[$i]));
            }
            // for WS subscriptions, we can't use .marketIds ($symbols), instead a custom is field needed
            $markets = $this->markets_for_symbols($symbols);
            $wsMarketIds = array();
            for ($i = 0; $i < count($markets); $i++) {
                $wsMarketId = $this->safe_string($markets[$i]['info'], 'wsname');
                $wsMarketIds[] = $wsMarketId;
            }
            $request = array(
                'event' => 'subscribe',
                'reqid' => $this->request_id(),
                'pair' => $wsMarketIds,
                'subscription' => array(
                    'name' => $channelName,
                ),
            );
            $url = $this->urls['api']['ws']['public'];
            return Async\await($this->watch_multiple($url, $messageHashes, $this->deep_extend($request, $params), $messageHashes, $subscriptionArgs));
        }) ();
    }

    public function watch_balance($params = array ()): PromiseInterface {
        return Async\async(function () use ($params) {
            /**
             * watch balance and get the amount of funds available for trading or funds locked in orders
             * @see https://docs.kraken.com/api/docs/websocket-v2/balances
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} a ~@link https://docs.ccxt.com/#/?id=balance-structure balance structure~
             */
            Async\await($this->load_markets());
            $token = Async\await($this->authenticate());
            $messageHash = 'balances';
            $url = $this->urls['api']['ws']['privateV2'];
            $requestId = $this->request_id();
            $subscribe = array(
                'method' => 'subscribe',
                'req_id' => $requestId,
                'params' => array(
                    'channel' => 'balances',
                    'token' => $token,
                ),
            );
            $request = $this->deep_extend($subscribe, $params);
            return Async\await($this->watch($url, $messageHash, $request, $messageHash));
        }) ();
    }

    public function handle_balance(Client $client, $message) {
        //
        //     {
        //         "channel" => "balances",
        //         "data" => array(
        //             {
        //                 "asset" => "BTC",
        //                 "asset_class" => "currency",
        //                 "balance" => 1.2,
        //                 "wallets" => array(
        //                     {
        //                         "type" => "spot",
        //                         "id" => "main",
        //                         "balance" => 1.2
        //                     }
        //                 )
        //             }
        //         ),
        //         "type" => "snapshot",
        //         "sequence" => 1
        //     }
        //
        $data = $this->safe_list($message, 'data', array());
        $result = array( 'info' => $message );
        for ($i = 0; $i < count($data); $i++) {
            $currencyId = $this->safe_string($data[$i], 'asset');
            $code = $this->safe_currency_code($currencyId);
            $account = $this->account();
            $eq = $this->safe_string($data[$i], 'balance');
            $account['total'] = $eq;
            $result[$code] = $account;
        }
        $type = 'spot';
        $balance = $this->safe_balance($result);
        $oldBalance = $this->safe_value($this->balance, $type, array());
        $newBalance = $this->deep_extend($oldBalance, $balance);
        $this->balance[$type] = $this->safe_balance($newBalance);
        $channel = $this->safe_string($message, 'channel');
        $client->resolve ($this->balance[$type], $channel);
    }

    public function get_message_hash(string $unifiedElementName, ?string $subChannelName = null, ?string $symbol = null) {
        // $unifiedElementName can be : orderbook, trade, ticker, bidask ...
        // $subChannelName only applies to channel that needs specific variation (i.e. depth_50, depth_100..) to be selected
        $withSymbol = $symbol !== null;
        $messageHash = $unifiedElementName;
        if (!$withSymbol) {
            $messageHash .= 's';
        } else {
            $messageHash .= '@' . $symbol;
        }
        if ($subChannelName !== null) {
            $messageHash .= '#' . $subChannelName;
        }
        return $messageHash;
    }

    public function handle_subscription_status(Client $client, $message) {
        //
        // public
        //
        //     {
        //         "channelID" => 210,
        //         "channelName" => "book-10",
        //         "event" => "subscriptionStatus",
        //         "reqid" => 1574146735269,
        //         "pair" => "ETH/XBT",
        //         "status" => "subscribed",
        //         "subscription" => array( depth => 10, name => "book" )
        //     }
        //
        // private
        //
        //     {
        //         "channelName" => "openOrders",
        //         "event" => "subscriptionStatus",
        //         "reqid" => 1,
        //         "status" => "subscribed",
        //         "subscription" => array( maxratecount => 125, name => "openOrders" )
        //     }
        //
        $channelId = $this->safe_string($message, 'channelID');
        if ($channelId !== null) {
            $client->subscriptions[$channelId] = $message;
        }
        // $requestId = $this->safe_string($message, "reqid");
        // if (is_array($client->futures) && array_key_exists($requestId, $client->futures)) {
        //     unset($client->futures[$requestId]);
        // }
    }

    public function handle_error_message(Client $client, $message) {
        //
        //     {
        //         "errorMessage" => "Currency pair not in ISO 4217-A3 format foobar",
        //         "event" => "subscriptionStatus",
        //         "pair" => "foobar",
        //         "reqid" => 1574146735269,
        //         "status" => "error",
        //         "subscription" => array( name => "ticker" )
        //     }
        //
        $errorMessage = $this->safe_string($message, 'errorMessage');
        if ($errorMessage !== null) {
            $requestId = $this->safe_value($message, 'reqid');
            if ($requestId !== null) {
                $broad = $this->exceptions['ws']['broad'];
                $broadKey = $this->find_broadly_matched_key($broad, $errorMessage);
                $exception = null;
                if ($broadKey === null) {
                    $exception = new ExchangeError ($errorMessage); // c# requirement to convert the $errorMessage to string
                } else {
                    $exception = new $broad[$broadKey] ($errorMessage);
                }
                $client->reject ($exception, $requestId);
                return false;
            }
        }
        return true;
    }

    public function handle_message(Client $client, $message) {
        if (gettype($message) === 'array' && array_keys($message) === array_keys(array_keys($message))) {
            $channelId = $this->safe_string($message, 0);
            $subscription = $this->safe_value($client->subscriptions, $channelId, array());
            $info = $this->safe_value($subscription, 'subscription', array());
            $messageLength = count($message);
            $channelName = $this->safe_string($message, $messageLength - 2);
            $name = $this->safe_string($info, 'name');
            $methods = array(
                // public
                'book' => array($this, 'handle_order_book'),
                'ohlc' => array($this, 'handle_ohlcv'),
                'ticker' => array($this, 'handle_ticker'),
                'trade' => array($this, 'handle_trades'),
                // private
                'openOrders' => array($this, 'handle_orders'),
                'ownTrades' => array($this, 'handle_my_trades'),
            );
            $method = $this->safe_value_2($methods, $name, $channelName);
            if ($method !== null) {
                $method($client, $message, $subscription);
            }
        } else {
            $channel = $this->safe_string($message, 'channel');
            if ($channel !== null) {
                $methods = array(
                    'balances' => array($this, 'handle_balance'),
                );
                $method = $this->safe_value($methods, $channel);
                if ($method !== null) {
                    $method($client, $message);
                }
            }
            if ($this->handle_error_message($client, $message)) {
                $event = $this->safe_string($message, 'event');
                $methods = array(
                    'heartbeat' => array($this, 'handle_heartbeat'),
                    'systemStatus' => array($this, 'handle_system_status'),
                    'subscriptionStatus' => array($this, 'handle_subscription_status'),
                    'addOrderStatus' => array($this, 'handle_create_edit_order'),
                    'editOrderStatus' => array($this, 'handle_create_edit_order'),
                    'cancelOrderStatus' => array($this, 'handle_cancel_order'),
                    'cancelAllStatus' => array($this, 'handle_cancel_all_orders'),
                );
                $method = $this->safe_value($methods, $event);
                if ($method !== null) {
                    $method($client, $message);
                }
            }
        }
    }
}
