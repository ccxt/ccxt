<?php

namespace ccxt\pro;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

use Exception; // a common import
use ccxt\ExchangeError;
use ccxt\NetworkError;
use ccxt\InvalidNonce;
use React\Async;

class kucoin extends \ccxt\async\kucoin {

    use ClientTrait;

    public function describe() {
        return $this->deep_extend(parent::describe(), array(
            'has' => array(
                'ws' => true,
                'watchOrderBook' => true,
                'watchOrders' => true,
                'watchMyTrades' => true,
                'watchTickers' => false, // for now
                'watchTicker' => true,
                'watchTrades' => true,
                'watchBalance' => true,
                'watchOHLCV' => true,
            ),
            'options' => array(
                'tradesLimit' => 1000,
                'watchOrderBookRate' => 100, // get updates every 100ms or 1000ms
                'fetchOrderBookSnapshot' => array(
                    'maxAttempts' => 3, // default number of sync attempts
                    'delay' => 1000, // warmup delay in ms before synchronizing
                ),
                'watchTicker' => array(
                    'name' => 'market/snapshot', // market/ticker
                ),
            ),
            'streaming' => array(
                // kucoin does not support built-in ws protocol-level ping-pong
                // instead it requires a custom json-based text ping-pong
                // https://docs.kucoin.com/#ping
                'ping' => array($this, 'ping'),
            ),
        ));
    }

    public function negotiate($params = array ()) {
        return Async\async(function () use ($params) {
            $client = $this->client('ws');
            $messageHash = 'negotiate';
            $future = $this->safe_value($client->subscriptions, $messageHash);
            if ($future === null) {
                $future = $client->future ($messageHash);
                $client->subscriptions[$messageHash] = $future;
                $response = null;
                $throwException = false;
                if ($this->check_required_credentials($throwException)) {
                    $response = Async\await($this->privatePostBulletPrivate ());
                    //
                    //     {
                    //         code => "200000",
                    //         $data => {
                    //             $instanceServers => array(
                    //                 {
                    //                     pingInterval =>  50000,
                    //                     $endpoint => "wss://push-private.kucoin.com/endpoint",
                    //                     protocol => "websocket",
                    //                     encrypt => true,
                    //                     pingTimeout => 10000
                    //                 }
                    //             ),
                    //             $token => "2neAiuYvAU61ZDXANAGAsiL4-iAExhsBXZxftpOeh_55i3Ysy2q2LEsEWU64mdzUOPusi34M_wGoSf7iNyEWJ1UQy47YbpY4zVdzilNP-Bj3iXzrjjGlWtiYB9J6i9GjsxUuhPw3BlrzazF6ghq4Lzf7scStOz3KkxjwpsOBCH4=.WNQmhZQeUKIkh97KYgU0Lg=="
                    //         }
                    //     }
                    //
                } else {
                    $response = Async\await($this->publicPostBulletPublic ());
                }
                $client->resolve ($response, $messageHash);
                // $data = $this->safe_value($response, 'data', array());
                // $instanceServers = $this->safe_value($data, 'instanceServers', array());
                // $firstServer = $this->safe_value($instanceServers, 0, array());
                // $endpoint = $this->safe_string($firstServer, 'endpoint');
                // $token = $this->safe_string($data, 'token');
            }
            return Async\await($future);
        }) ();
    }

    public function request_id() {
        $requestId = $this->sum($this->safe_integer($this->options, 'requestId', 0), 1);
        $this->options['requestId'] = $requestId;
        return $requestId;
    }

    public function subscribe($negotiation, $topic, $messageHash, $method, $symbol, $params = array ()) {
        return Async\async(function () use ($negotiation, $topic, $messageHash, $method, $symbol, $params) {
            Async\await($this->load_markets());
            // $market = $this->market($symbol);
            $data = $this->safe_value($negotiation, 'data', array());
            $instanceServers = $this->safe_value($data, 'instanceServers', array());
            $firstServer = $this->safe_value($instanceServers, 0, array());
            $endpoint = $this->safe_string($firstServer, 'endpoint');
            $token = $this->safe_string($data, 'token');
            $nonce = $this->request_id();
            $query = array(
                'token' => $token,
                'acceptUserMessage' => 'true',
                // 'connectId' => $nonce, // user-defined id is supported, received by handleSystemStatus
            );
            $url = $endpoint . '?' . $this->urlencode($query);
            // $topic = '/market/snapshot'; // '/market/ticker';
            // $messageHash = $topic . ':' . $market['id'];
            $subscribe = array(
                'id' => $nonce,
                'type' => 'subscribe',
                'topic' => $topic,
                'response' => true,
            );
            $subscription = array(
                'id' => (string) $nonce,
                'symbol' => $symbol,
                'topic' => $topic,
                'messageHash' => $messageHash,
                'method' => $method,
            );
            $request = array_merge($subscribe, $params);
            $subscriptionHash = $topic;
            return Async\await($this->watch($url, $messageHash, $request, $subscriptionHash, $subscription));
        }) ();
    }

    public function watch_ticker($symbol, $params = array ()) {
        return Async\async(function () use ($symbol, $params) {
            /**
             * watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific $market
             * @param {string} $symbol unified $symbol of the $market to fetch the ticker for
             * @param {array} $params extra parameters specific to the kucoin api endpoint
             * @return {array} a {@link https://docs.ccxt.com/en/latest/manual.html#ticker-structure ticker structure}
             */
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $symbol = $market['symbol'];
            $negotiation = Async\await($this->negotiate());
            $options = $this->safe_value($this->options, 'watchTicker', array());
            $channel = $this->safe_string_2($options, 'name', 'topic', 'market/snapshot'); // $topic option is deprecated use name instead
            $topic = '/' . $channel . ':' . $market['id'];
            $messageHash = $topic;
            return Async\await($this->subscribe($negotiation, $topic, $messageHash, null, $symbol, $params));
        }) ();
    }

    public function handle_ticker($client, $message) {
        //
        // market/snapshot
        //
        // updates come in every 2 sec unless there
        // were no changes since the previous update
        //
        //     {
        //         "data" => {
        //             "sequence" => "1545896669291",
        //             "data" => array(
        //                 "trading" => true,
        //                 "symbol" => "KCS-BTC",
        //                 "buy" => 0.00011,
        //                 "sell" => 0.00012,
        //                 "sort" => 100,
        //                 "volValue" => 3.13851792584, // total
        //                 "baseCurrency" => "KCS",
        //                 "market" => "BTC",
        //                 "quoteCurrency" => "BTC",
        //                 "symbolCode" => "KCS-BTC",
        //                 "datetime" => 1548388122031,
        //                 "high" => 0.00013,
        //                 "vol" => 27514.34842,
        //                 "low" => 0.0001,
        //                 "changePrice" => -1.0e-5,
        //                 "changeRate" => -0.0769,
        //                 "lastTradedPrice" => 0.00012,
        //                 "board" => 0,
        //                 "mark" => 0
        //             }
        //         ),
        //         "subject" => "trade.snapshot",
        //         "topic" => "/market/snapshot:KCS-BTC",
        //         "type" => "message"
        //     }
        //
        // market/ticker
        //
        //     {
        //         type => 'message',
        //         $topic => '/market/ticker:BTC-USDT',
        //         subject => 'trade.ticker',
        //         $data => {
        //             bestAsk => '62163',
        //             bestAskSize => '0.99011388',
        //             bestBid => '62162.9',
        //             bestBidSize => '0.04794181',
        //             price => '62162.9',
        //             sequence => '1621383371852',
        //             size => '0.00832274',
        //             time => 1634641987564
        //         }
        //     }
        //
        $topic = $this->safe_string($message, 'topic');
        $market = null;
        if ($topic !== null) {
            $parts = explode(':', $topic);
            $marketId = $this->safe_string($parts, 1);
            $market = $this->safe_market($marketId, $market, '-');
        }
        $data = $this->safe_value($message, 'data', array());
        $rawTicker = $this->safe_value($data, 'data', $data);
        $ticker = $this->parse_ticker($rawTicker, $market);
        $symbol = $ticker['symbol'];
        $this->tickers[$symbol] = $ticker;
        $messageHash = $this->safe_string($message, 'topic');
        if ($messageHash !== null) {
            $client->resolve ($ticker, $messageHash);
        }
        return $message;
    }

    public function watch_ohlcv($symbol, $timeframe = '1m', $since = null, $limit = null, $params = array ()) {
        return Async\async(function () use ($symbol, $timeframe, $since, $limit, $params) {
            /**
             * watches historical candlestick data containing the open, high, low, and close price, and the volume of a $market
             * @param {string} $symbol unified $symbol of the $market to fetch OHLCV data for
             * @param {string} $timeframe the length of time each candle represents
             * @param {int|null} $since timestamp in ms of the earliest candle to fetch
             * @param {int|null} $limit the maximum amount of candles to fetch
             * @param {array} $params extra parameters specific to the kucoin api endpoint
             * @return {[[int]]} A list of candles ordered as timestamp, open, high, low, close, volume
             */
            Async\await($this->load_markets());
            $negotiation = Async\await($this->negotiate());
            $market = $this->market($symbol);
            $symbol = $market['symbol'];
            $period = $this->timeframes[$timeframe];
            $topic = '/market/candles:' . $market['id'] . '_' . $period;
            $messageHash = $topic;
            $ohlcv = Async\await($this->subscribe($negotiation, $topic, $messageHash, null, $symbol, $params));
            if ($this->newUpdates) {
                $limit = $ohlcv->getLimit ($symbol, $limit);
            }
            return $this->filter_by_since_limit($ohlcv, $since, $limit, 0, true);
        }) ();
    }

    public function handle_ohlcv($client, $message) {
        //
        //     {
        //         $data => array(
        //             $symbol => 'BTC-USDT',
        //             $candles => array(
        //                 '1624881240',
        //                 '34138.8',
        //                 '34121.6',
        //                 '34138.8',
        //                 '34097.9',
        //                 '3.06097133',
        //                 '104430.955068564'
        //             ),
        //             time => 1624881284466023700
        //         ),
        //         subject => 'trade.candles.update',
        //         $topic => '/market/candles:BTC-USDT_1min',
        //         type => 'message'
        //     }
        //
        $data = $this->safe_value($message, 'data', array());
        $marketId = $this->safe_string($data, 'symbol');
        $candles = $this->safe_value($data, 'candles', array());
        $topic = $this->safe_string($message, 'topic');
        $parts = explode('_', $topic);
        $interval = $this->safe_string($parts, 1);
        // use a reverse lookup in a static map instead
        $timeframe = $this->find_timeframe($interval);
        $symbol = $this->safe_symbol($marketId);
        $market = $this->market($symbol);
        $this->ohlcvs[$symbol] = $this->safe_value($this->ohlcvs, $symbol, array());
        $stored = $this->safe_value($this->ohlcvs[$symbol], $timeframe);
        if ($stored === null) {
            $limit = $this->safe_integer($this->options, 'OHLCVLimit', 1000);
            $stored = new ArrayCacheByTimestamp ($limit);
            $this->ohlcvs[$symbol][$timeframe] = $stored;
        }
        $ohlcv = $this->parse_ohlcv($candles, $market);
        $stored->append ($ohlcv);
        $client->resolve ($stored, $topic);
    }

    public function watch_trades($symbol, $since = null, $limit = null, $params = array ()) {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            /**
             * get the list of most recent $trades for a particular $symbol
             * @param {string} $symbol unified $symbol of the $market to fetch $trades for
             * @param {int|null} $since timestamp in ms of the earliest trade to fetch
             * @param {int|null} $limit the maximum amount of $trades to fetch
             * @param {array} $params extra parameters specific to the kucoin api endpoint
             * @return {[array]} a list of ~@link https://docs.ccxt.com/en/latest/manual.html?#public-$trades trade structures~
             */
            Async\await($this->load_markets());
            $negotiation = Async\await($this->negotiate());
            $market = $this->market($symbol);
            $symbol = $market['symbol'];
            $topic = '/market/match:' . $market['id'];
            $messageHash = $topic;
            $trades = Async\await($this->subscribe($negotiation, $topic, $messageHash, null, $symbol, $params));
            if ($this->newUpdates) {
                $limit = $trades->getLimit ($symbol, $limit);
            }
            return $this->filter_by_since_limit($trades, $since, $limit, 'timestamp', true);
        }) ();
    }

    public function handle_trade($client, $message) {
        //
        //     {
        //         $data => array(
        //             sequence => '1568787654360',
        //             $symbol => 'BTC-USDT',
        //             side => 'buy',
        //             size => '0.00536577',
        //             price => '9345',
        //             takerOrderId => '5e356c4a9f1a790008f8d921',
        //             time => '1580559434436443257',
        //             type => 'match',
        //             makerOrderId => '5e356bffedf0010008fa5d7f',
        //             tradeId => '5e356c4aeefabd62c62a1ece'
        //         ),
        //         subject => 'trade.l3match',
        //         topic => '/market/match:BTC-USDT',
        //         type => 'message'
        //     }
        //
        $data = $this->safe_value($message, 'data', array());
        $trade = $this->parse_trade($data);
        $messageHash = $this->safe_string($message, 'topic');
        $symbol = $trade['symbol'];
        $trades = $this->safe_value($this->trades, $symbol);
        if ($trades === null) {
            $limit = $this->safe_integer($this->options, 'tradesLimit', 1000);
            $trades = new ArrayCache ($limit);
            $this->trades[$symbol] = $trades;
        }
        $trades->append ($trade);
        $client->resolve ($trades, $messageHash);
        return $message;
    }

    public function watch_order_book($symbol, $limit = null, $params = array ()) {
        return Async\async(function () use ($symbol, $limit, $params) {
            /**
             * watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
             * @param {string} $symbol unified $symbol of the $market to fetch the order book for
             * @param {int|null} $limit the maximum amount of order book entries to return
             * @param {array} $params extra parameters specific to the kucoin api endpoint
             * @return {array} A dictionary of {@link https://docs.ccxt.com/en/latest/manual.html#order-book-structure order book structures} indexed by $market symbols
             */
            //
            // https://docs.kucoin.com/#level-2-$market-data
            //
            // 1. After receiving the websocket Level 2 data flow, cache the data.
            // 2. Initiate a REST request to get the snapshot data of Level 2 order book.
            // 3. Playback the cached Level 2 data flow.
            // 4. Apply the new Level 2 data flow to the local snapshot to ensure that
            // the sequence of the new Level 2 update lines up with the sequence of
            // the previous Level 2 data. Discard all the message prior to that
            // sequence, and then playback the change to snapshot.
            // 5. Update the level2 full data based on sequence according to the
            // size. If the price is 0, ignore the messages and update the sequence.
            // If the size=0, update the sequence and remove the price of which the
            // size is 0 out of level 2. For other cases, please update the price.
            //
            if ($limit !== null) {
                if (($limit !== 20) && ($limit !== 100)) {
                    throw new ExchangeError($this->id . " watchOrderBook 'limit' argument must be null, 20 or 100");
                }
            }
            Async\await($this->load_markets());
            $negotiation = Async\await($this->negotiate());
            $market = $this->market($symbol);
            $symbol = $market['symbol'];
            $topic = '/market/level2:' . $market['id'];
            $messageHash = $topic;
            $orderbook = Async\await($this->subscribe($negotiation, $topic, $messageHash, array($this, 'handle_order_book_subscription'), $symbol, $params));
            return $orderbook->limit ();
        }) ();
    }

    public function retry_fetch_order_book_snapshot($client, $message, $subscription) {
        $symbol = $this->safe_string($subscription, 'symbol');
        $messageHash = $this->safe_string($subscription, 'messageHash');
        // var_dump ('fetchOrderBookSnapshot', nonce, previousSequence, nonce >= previousSequence);
        $options = $this->safe_value($this->options, 'fetchOrderBookSnapshot', array());
        $maxAttempts = $this->safe_integer($options, 'maxAttempts', 3);
        $numAttempts = $this->safe_integer($subscription, 'numAttempts', 0);
        // retry to syncrhonize if we haven't reached $maxAttempts yet
        if ($numAttempts < $maxAttempts) {
            // safety guard
            if (is_array($client->subscriptions) && array_key_exists($messageHash, $client->subscriptions)) {
                $numAttempts = $this->sum($numAttempts, 1);
                $subscription['numAttempts'] = $numAttempts;
                $client->subscriptions[$messageHash] = $subscription;
                $this->spawn(array($this, 'fetch_order_book_snapshot'), $client, $message, $subscription);
            }
        } else {
            if (is_array($client->subscriptions) && array_key_exists($messageHash, $client->subscriptions)) {
                $subscription['fetchingOrderBookSnapshot'] = false;
                $subscription['numAttempts'] = 0;
                $client->subscriptions[$messageHash] = $subscription;
            }
            $e = new InvalidNonce ($this->id . ' failed to synchronize WebSocket feed with the snapshot for $symbol ' . $symbol . ' in ' . (string) $maxAttempts . ' attempts');
            $client->reject ($e, $messageHash);
        }
    }

    public function fetch_order_book_snapshot($client, $message, $subscription) {
        return Async\async(function () use ($client, $message, $subscription) {
            $symbol = $this->safe_string($subscription, 'symbol');
            $limit = $this->safe_integer($subscription, 'limit');
            $messageHash = $this->safe_string($subscription, 'messageHash');
            try {
                // 2. Initiate a REST request to get the $snapshot $data of Level 2 order book.
                // todo => this is a synch blocking call in ccxt.php - make it async
                $snapshot = Async\await($this->fetch_order_book($symbol, $limit));
                $orderbook = $this->orderbooks[$symbol];
                $messages = $orderbook->cache;
                // make sure we have at least one delta before fetching the $snapshot
                // otherwise we cannot synchronize the feed with the $snapshot
                // and that will lead to a bidask cross as reported here
                // https://github.com/ccxt/ccxt/issues/6762
                $firstMessage = $this->safe_value($messages, 0, array());
                $data = $this->safe_value($firstMessage, 'data', array());
                $sequenceStart = $this->safe_integer($data, 'sequenceStart');
                $nonce = $this->safe_integer($snapshot, 'nonce');
                $previousSequence = $sequenceStart - 1;
                // if the received $snapshot is earlier than the first cached delta
                // then we cannot align it with the cached deltas and we need to
                // retry synchronizing in maxAttempts
                if ($nonce < $previousSequence) {
                    $this->retry_fetch_order_book_snapshot($client, $message, $subscription);
                } else {
                    $orderbook->reset ($snapshot);
                    // unroll the accumulated deltas
                    // 3. Playback the cached Level 2 $data flow.
                    for ($i = 0; $i < count($messages); $i++) {
                        $message = $messages[$i];
                        $this->handle_order_book_message($client, $message, $orderbook);
                    }
                    $this->orderbooks[$symbol] = $orderbook;
                    $client->resolve ($orderbook, $messageHash);
                }
            } catch (Exception $e) {
                if ($e instanceof NetworkError) {
                    $this->retry_fetch_order_book_snapshot($client, $message, $subscription);
                } else {
                    $client->reject ($e, $messageHash);
                }
            }
        }) ();
    }

    public function handle_delta($bookside, $delta, $nonce) {
        $price = $this->safe_float($delta, 0);
        if ($price > 0) {
            $sequence = $this->safe_integer($delta, 2);
            if ($sequence > $nonce) {
                $amount = $this->safe_float($delta, 1);
                $bookside->store ($price, $amount);
            }
        }
    }

    public function handle_deltas($bookside, $deltas, $nonce) {
        for ($i = 0; $i < count($deltas); $i++) {
            $this->handle_delta($bookside, $deltas[$i], $nonce);
        }
    }

    public function handle_order_book_message($client, $message, $orderbook) {
        //
        //     {
        //         "type":"message",
        //         "topic":"/market/level2:BTC-USDT",
        //         "subject":"trade.l2update",
        //         "data":{
        //             "sequenceStart":1545896669105,
        //             "sequenceEnd":1545896669106,
        //             "symbol":"BTC-USDT",
        //             "changes" => {
        //                 "asks" => [["6","1","1545896669105"]], // price, size, sequence
        //                 "bids" => [["4","1","1545896669106"]]
        //             }
        //         }
        //     }
        //
        $data = $this->safe_value($message, 'data', array());
        $sequenceEnd = $this->safe_integer($data, 'sequenceEnd');
        // 4. Apply the new Level 2 $data flow to the local snapshot to ensure that
        // the sequence of the new Level 2 update lines up with the sequence of
        // the previous Level 2 $data-> Discard all the $message prior to that
        // sequence, and then playback the change to snapshot.
        if ($sequenceEnd > $orderbook['nonce']) {
            $sequenceStart = $this->safe_integer($message, 'sequenceStart');
            if (($sequenceStart !== null) && (($sequenceStart - 1) > $orderbook['nonce'])) {
                // todo => $client->reject from handleOrderBookMessage properly
                throw new ExchangeError($this->id . ' handleOrderBook received an out-of-order nonce');
            }
            $changes = $this->safe_value($data, 'changes', array());
            $asks = $this->safe_value($changes, 'asks', array());
            $bids = $this->safe_value($changes, 'bids', array());
            $asks = $this->sort_by($asks, 2); // sort by sequence
            $bids = $this->sort_by($bids, 2);
            // 5. Update the level2 full $data based on sequence according to the
            // size. If the price is 0, ignore the messages and update the sequence.
            // If the size=0, update the sequence and remove the price of which the
            // size is 0 out of level 2. For other cases, please update the price.
            $this->handle_deltas($orderbook['asks'], $asks, $orderbook['nonce']);
            $this->handle_deltas($orderbook['bids'], $bids, $orderbook['nonce']);
            $orderbook['nonce'] = $sequenceEnd;
            $orderbook['timestamp'] = null;
            $orderbook['datetime'] = null;
        }
        return $orderbook;
    }

    public function handle_order_book($client, $message) {
        //
        // initial snapshot is fetched with ccxt's fetchOrderBook
        // the feed does not include a snapshot, just the deltas
        //
        //     {
        //         "type":"message",
        //         "topic":"/market/level2:BTC-USDT",
        //         "subject":"trade.l2update",
        //         "data":{
        //             "sequenceStart":1545896669105,
        //             "sequenceEnd":1545896669106,
        //             "symbol":"BTC-USDT",
        //             "changes" => {
        //                 "asks" => [["6","1","1545896669105"]], // price, size, sequence
        //                 "bids" => [["4","1","1545896669106"]]
        //             }
        //         }
        //     }
        //
        $messageHash = $this->safe_string($message, 'topic');
        $data = $this->safe_value($message, 'data');
        $marketId = $this->safe_string($data, 'symbol');
        $symbol = $this->safe_symbol($marketId, null, '-');
        $orderbook = $this->orderbooks[$symbol];
        if ($orderbook['nonce'] === null) {
            $subscription = $this->safe_value($client->subscriptions, $messageHash);
            $fetchingOrderBookSnapshot = $this->safe_value($subscription, 'fetchingOrderBookSnapshot');
            if ($fetchingOrderBookSnapshot === null) {
                $subscription['fetchingOrderBookSnapshot'] = true;
                $client->subscriptions[$messageHash] = $subscription;
                $options = $this->safe_value($this->options, 'fetchOrderBookSnapshot', array());
                $delay = $this->safe_integer($options, 'delay', $this->rateLimit);
                // fetch the snapshot in a separate async call after a warmup $delay
                $this->delay($delay, array($this, 'fetch_order_book_snapshot'), $client, $message, $subscription);
            }
            // 1. After receiving the websocket Level 2 $data flow, cache the $data->
            $orderbook->cache[] = $message;
        } else {
            $this->handle_order_book_message($client, $message, $orderbook);
            $client->resolve ($orderbook, $messageHash);
        }
    }

    public function handle_order_book_subscription($client, $message, $subscription) {
        $symbol = $this->safe_string($subscription, 'symbol');
        $limit = $this->safe_string($subscription, 'limit');
        if (is_array($this->orderbooks) && array_key_exists($symbol, $this->orderbooks)) {
            unset($this->orderbooks[$symbol]);
        }
        $this->orderbooks[$symbol] = $this->order_book(array(), $limit);
        // moved snapshot initialization to handleOrderBook to fix
        // https://github.com/ccxt/ccxt/issues/6820
        // the general idea is to fetch the snapshot after the first delta
        // but not before, because otherwise we cannot synchronize the feed
    }

    public function handle_subscription_status($client, $message) {
        //
        //     {
        //         $id => '1578090438322',
        //         type => 'ack'
        //     }
        //
        $id = $this->safe_string($message, 'id');
        $subscriptionsById = $this->index_by($client->subscriptions, 'id');
        $subscription = $this->safe_value($subscriptionsById, $id, array());
        $method = $this->safe_value($subscription, 'method');
        if ($method !== null) {
            $method($client, $message, $subscription);
        }
        return $message;
    }

    public function handle_system_status($client, $message) {
        //
        // todo => answer the question whether handleSystemStatus should be renamed
        // and unified as handleStatus for any usage pattern that
        // involves system status and maintenance updates
        //
        //     {
        //         id => '1578090234088', // connectId
        //         type => 'welcome',
        //     }
        //
        return $message;
    }

    public function watch_orders($symbol = null, $since = null, $limit = null, $params = array ()) {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            /**
             * watches information on multiple $orders made by the user
             * @param {string|null} $symbol unified $market $symbol of the $market $orders were made in
             * @param {int|null} $since the earliest time in ms to fetch $orders for
             * @param {int|null} $limit the maximum number of  orde structures to retrieve
             * @param {array} $params extra parameters specific to the kucoin api endpoint
             * @return {[array]} a list of {@link https://docs.ccxt.com/en/latest/manual.html#order-structure order structures}
             */
            Async\await($this->load_markets());
            $negotiation = Async\await($this->negotiate());
            $topic = '/spotMarket/tradeOrders';
            $request = array(
                'privateChannel' => true,
            );
            $messageHash = $topic;
            if ($symbol !== null) {
                $market = $this->market($symbol);
                $symbol = $market['symbol'];
                $messageHash = $messageHash . ':' . $market['symbol'];
            }
            $orders = Async\await($this->subscribe($negotiation, $topic, $messageHash, null, null, array_merge($request, $params)));
            if ($this->newUpdates) {
                $limit = $orders->getLimit ($symbol, $limit);
            }
            return $this->filter_by_symbol_since_limit($orders, $symbol, $since, $limit, true);
        }) ();
    }

    public function parse_ws_order_status($status) {
        $statuses = array(
            'open' => 'open',
            'filled' => 'closed',
            'match' => 'open',
            'update' => 'open',
            'canceled' => 'canceled',
        );
        return $this->safe_string($statuses, $status, $status);
    }

    public function parse_ws_order($order, $market = null) {
        //
        //     {
        //         'symbol' => 'XCAD-USDT',
        //         'orderType' => 'limit',
        //         'side' => 'buy',
        //         'orderId' => '6249167327218b000135e749',
        //         'type' => 'canceled',
        //         'orderTime' => 1648957043065280224,
        //         'size' => '100.452',
        //         'filledSize' => '0',
        //         'price' => '2.9635',
        //         'clientOid' => 'buy-XCAD-USDT-1648957043010159',
        //         'remainSize' => '0',
        //         'status' => 'done',
        //         'ts' => 1648957054031001037
        //     }
        //
        $id = $this->safe_string($order, 'orderId');
        $clientOrderId = $this->safe_string($order, 'clientOid');
        $orderType = $this->safe_string_lower($order, 'orderType');
        $price = $this->safe_string($order, 'price');
        $filled = $this->safe_string($order, 'filledSize');
        $amount = $this->safe_string($order, 'size');
        $rawType = $this->safe_string($order, 'type');
        $status = $this->parse_ws_order_status($rawType);
        $timestamp = $this->safe_integer_product($order, 'orderTime', 0.000001);
        $marketId = $this->safe_string($order, 'symbol');
        $market = $this->safe_market($marketId, $market);
        $symbol = $market['symbol'];
        $side = $this->safe_string_lower($order, 'side');
        return $this->safe_order(array(
            'info' => $order,
            'symbol' => $symbol,
            'id' => $id,
            'clientOrderId' => $clientOrderId,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'lastTradeTimestamp' => null,
            'type' => $orderType,
            'timeInForce' => null,
            'postOnly' => null,
            'side' => $side,
            'price' => $price,
            'stopPrice' => null,
            'amount' => $amount,
            'cost' => null,
            'average' => null,
            'filled' => $filled,
            'remaining' => null,
            'status' => $status,
            'fee' => null,
            'trades' => null,
        ), $market);
    }

    public function handle_order($client, $message) {
        $messageHash = '/spotMarket/tradeOrders';
        $data = $this->safe_value($message, 'data');
        $parsed = $this->parse_ws_order($data);
        $symbol = $this->safe_string($parsed, 'symbol');
        $orderId = $this->safe_string($parsed, 'id');
        if ($symbol !== null) {
            if ($this->orders === null) {
                $limit = $this->safe_integer($this->options, 'ordersLimit', 1000);
                $this->orders = new ArrayCacheBySymbolById ($limit);
            }
            $cachedOrders = $this->orders;
            $orders = $this->safe_value($cachedOrders->hashmap, $symbol, array());
            $order = $this->safe_value($orders, $orderId);
            if ($order !== null) {
                // todo add others to calculate average etc
                $stopPrice = $this->safe_value($order, 'stopPrice');
                if ($stopPrice !== null) {
                    $parsed['stopPrice'] = $stopPrice;
                }
                if ($order['status'] === 'closed') {
                    $parsed['status'] = 'closed';
                }
            }
            $cachedOrders->append ($parsed);
            $client->resolve ($this->orders, $messageHash);
            $symbolSpecificMessageHash = $messageHash . ':' . $symbol;
            $client->resolve ($this->orders, $symbolSpecificMessageHash);
        }
    }

    public function watch_my_trades($symbol = null, $since = null, $limit = null, $params = array ()) {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            /**
             * watches information on multiple $trades made by the user
             * @param {string} $symbol unified $market $symbol of the $market orders were made in
             * @param {int|null} $since the earliest time in ms to fetch orders for
             * @param {int|null} $limit the maximum number of  orde structures to retrieve
             * @param {array} $params extra parameters specific to the kucoin api endpoint
             * @return {[array]} a list of [order structures]{@link https://docs.ccxt.com/en/latest/manual.html#order-structure
             */
            Async\await($this->load_markets());
            $negotiation = Async\await($this->negotiate());
            $topic = '/spot/tradeFills';
            $request = array(
                'privateChannel' => true,
            );
            $messageHash = $topic;
            if ($symbol !== null) {
                $market = $this->market($symbol);
                $symbol = $market['symbol'];
                $messageHash = $messageHash . ':' . $market['symbol'];
            }
            $trades = Async\await($this->subscribe($negotiation, $topic, $messageHash, null, null, array_merge($request, $params)));
            if ($this->newUpdates) {
                $limit = $trades->getLimit ($symbol, $limit);
            }
            return $this->filter_by_symbol_since_limit($trades, $symbol, $since, $limit);
        }) ();
    }

    public function handle_my_trade($client, $message) {
        $trades = $this->myTrades;
        if ($trades === null) {
            $limit = $this->safe_integer($this->options, 'tradesLimit', 1000);
            $trades = new ArrayCacheBySymbolById ($limit);
        }
        $data = $this->safe_value($message, 'data');
        $parsed = $this->parse_ws_trade($data);
        $trades->append ($parsed);
        $messageHash = '/spot/tradeFills';
        $client->resolve ($trades, $messageHash);
        $symbolSpecificMessageHash = $messageHash . ':' . $parsed['symbol'];
        $client->resolve ($trades, $symbolSpecificMessageHash);
    }

    public function parse_ws_trade($trade, $market = null) {
        //
        // {
        //     $fee => 0.00262148,
        //     $feeCurrency => 'USDT',
        //     $feeRate => 0.001,
        //     orderId => '62417436b29df8000183df2f',
        //     orderType => 'market',
        //     $price => 131.074,
        //     $side => 'sell',
        //     size => 0.02,
        //     $symbol => 'LTC-USDT',
        //     time => '1648456758734571745',
        //     $tradeId => '624174362e113d2f467b3043'
        //   }
        //
        $marketId = $this->safe_string($trade, 'symbol');
        $market = $this->safe_market($marketId, $market, '-');
        $symbol = $market['symbol'];
        $type = $this->safe_string($trade, 'orderType');
        $side = $this->safe_string($trade, 'side');
        $tradeId = $this->safe_string($trade, 'tradeId');
        $price = $this->safe_string($trade, 'price');
        $amount = $this->safe_string($trade, 'size');
        $order = $this->safe_string($trade, 'orderId');
        $timestamp = $this->safe_integer_product($trade, 'time', 0.000001);
        $feeCurrency = $market['quote'];
        $feeRate = $this->safe_string($trade, 'feeRate');
        $fee = array(
            'cost' => null,
            'rate' => $feeRate,
            'currency' => $feeCurrency,
        );
        return $this->safe_trade(array(
            'info' => $trade,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'symbol' => $symbol,
            'id' => $tradeId,
            'order' => $order,
            'type' => $type,
            'takerOrMaker' => null,
            'side' => $side,
            'price' => $price,
            'amount' => $amount,
            'cost' => null,
            'fee' => $fee,
        ), $market);
    }

    public function watch_balance($params = array ()) {
        return Async\async(function () use ($params) {
            /**
             * query for balance and get the amount of funds available for trading or funds locked in orders
             * @param {array} $params extra parameters specific to the kucoin api endpoint
             * @return {array} a ~@link https://docs.ccxt.com/en/latest/manual.html?#balance-structure balance structure~
             */
            Async\await($this->load_markets());
            $negotiation = Async\await($this->negotiate());
            $topic = '/account/balance';
            $request = array(
                'privateChannel' => true,
            );
            $messageHash = $topic;
            return Async\await($this->subscribe($negotiation, $topic, $messageHash, array($this, 'handle_balance_subscription'), null, array_merge($request, $params)));
        }) ();
    }

    public function handle_balance($client, $message) {
        //
        // {
        //     "id":"6217a451294b030001e3a26a",
        //     "type":"message",
        //     "topic":"/account/balance",
        //     "userId":"6217707c52f97f00012a67db",
        //     "channelType":"private",
        //     "subject":"account.balance",
        //     "data":{
        //        "accountId":"62177fe67810720001db2f18",
        //        "available":"89",
        //        "availableChange":"-30",
        //        "currency":"USDT",
        //        "hold":"0",
        //        "holdChange":"0",
        //        "relationContext":array(
        //        ),
        //        "relationEvent":"main.transfer",
        //        "relationEventId":"6217a451294b030001e3a26a",
        //        "time":"1645716561816",
        //        "total":"89"
        //     }
        //
        $data = $this->safe_value($message, 'data', array());
        $messageHash = $this->safe_string($message, 'topic');
        $currencyId = $this->safe_string($data, 'currency');
        $relationEvent = $this->safe_string($data, 'relationEvent');
        $requestAccountType = null;
        if ($relationEvent !== null) {
            $relationEventParts = explode('.', $relationEvent);
            $requestAccountType = $this->safe_string($relationEventParts, 0);
        }
        $selectedType = $this->safe_string_2($this->options, 'watchBalance', 'defaultType', 'trade'); // trade, main, margin or other
        $accountsByType = $this->safe_value($this->options, 'accountsByType');
        $uniformType = $this->safe_string($accountsByType, $requestAccountType, 'trade');
        if (!(is_array($this->balance) && array_key_exists($uniformType, $this->balance))) {
            $this->balance[$uniformType] = array();
        }
        $code = $this->safe_currency_code($currencyId);
        $account = $this->account();
        $account['free'] = $this->safe_string($data, 'available');
        $account['used'] = $this->safe_string($data, 'hold');
        $account['total'] = $this->safe_string($data, 'total');
        $this->balance[$uniformType][$code] = $account;
        $this->balance[$uniformType] = $this->safe_balance($this->balance[$uniformType]);
        if ($uniformType === $selectedType) {
            $client->resolve ($this->balance[$uniformType], $messageHash);
        }
    }

    public function handle_balance_subscription($client, $message, $subscription) {
        $this->spawn(array($this, 'fetch_balance_snapshot'), $client, $message);
    }

    public function fetch_balance_snapshot($client, $message) {
        return Async\async(function () use ($client, $message) {
            Async\await($this->load_markets());
            $this->check_required_credentials();
            $messageHash = '/account/balance';
            $selectedType = $this->safe_string_2($this->options, 'watchBalance', 'defaultType', 'spot'); // spot, margin, main, funding, future, mining, trade, contract, pool
            $params = array(
                'type' => $selectedType,
            );
            $snapshot = Async\await($this->fetch_balance($params));
            //
            // {
            //     "info":{
            //        "code":"200000",
            //        "data":array(
            //           array(
            //              "id":"6217a451cbe8910001ed3aa8",
            //              "currency":"USDT",
            //              "type":"trade",
            //              "balance":"10",
            //              "available":"4.995",
            //              "holds":"5.005"
            //           }
            //        )
            //     ),
            //     "USDT":array(
            //        "free":4.995,
            //        "used":5.005,
            //        "total":10
            //     ),
            //     "free":array(
            //        "USDT":4.995
            //     ),
            //     "used":array(
            //        "USDT":5.005
            //     ),
            //     "total":{
            //        "USDT":10
            //     }
            //  }
            //
            $data = $this->safe_value($snapshot['info'], 'data', array());
            if (strlen($data) > 0) {
                $selectedType = $this->safe_string_2($this->options, 'watchBalance', 'defaultType', 'trade'); // trade, main, margin or other
                for ($i = 0; $i < count($data); $i++) {
                    $balance = $data[$i];
                    $type = $this->safe_string($balance, 'type');
                    $accountsByType = $this->safe_value($this->options, 'accountsByType');
                    $uniformType = $this->safe_string($accountsByType, $type, 'trade');
                    if (!(is_array($this->balance) && array_key_exists($uniformType, $this->balance))) {
                        $this->balance[$uniformType] = array();
                    }
                    $currencyId = $this->safe_string($balance, 'currency');
                    $code = $this->safe_currency_code($currencyId);
                    $account = $this->account();
                    $account['free'] = $this->safe_string($balance, 'available');
                    $account['used'] = $this->safe_string($balance, 'holds');
                    $account['total'] = $this->safe_string($balance, 'total');
                    $this->balance[$selectedType][$code] = $account;
                    $this->balance[$selectedType] = $this->safe_balance($this->balance[$selectedType]);
                }
                $client->resolve ($this->balance[$selectedType], $messageHash);
            }
        }) ();
    }

    public function handle_subject($client, $message) {
        //
        //     {
        //         "type":"message",
        //         "topic":"/market/level2:BTC-USDT",
        //         "subject":"trade.l2update",
        //         "data":{
        //             "sequenceStart":1545896669105,
        //             "sequenceEnd":1545896669106,
        //             "symbol":"BTC-USDT",
        //             "changes" => {
        //                 "asks" => [["6","1","1545896669105"]], // price, size, sequence
        //                 "bids" => [["4","1","1545896669106"]]
        //             }
        //         }
        //     }
        //
        $subject = $this->safe_string($message, 'subject');
        $methods = array(
            'trade.l2update' => array($this, 'handle_order_book'),
            'trade.ticker' => array($this, 'handle_ticker'),
            'trade.snapshot' => array($this, 'handle_ticker'),
            'trade.l3match' => array($this, 'handle_trade'),
            'trade.candles.update' => array($this, 'handle_ohlcv'),
            'account.balance' => array($this, 'handle_balance'),
            '/spot/tradeFills' => array($this, 'handle_my_trade'),
            'orderChange' => array($this, 'handle_order'),
        );
        $method = $this->safe_value($methods, $subject);
        if ($method === null) {
            return $message;
        } else {
            return $method($client, $message);
        }
    }

    public function ping($client) {
        // kucoin does not support built-in ws protocol-level ping-pong
        // instead it requires a custom json-based text ping-pong
        // https://docs.kucoin.com/#ping
        $id = (string) $this->request_id();
        return array(
            'id' => $id,
            'type' => 'ping',
        );
    }

    public function handle_pong($client, $message) {
        // https://docs.kucoin.com/#ping
        $client->lastPong = $this->milliseconds();
        return $message;
    }

    public function handle_error_message($client, $message) {
        return $message;
    }

    public function handle_message($client, $message) {
        if ($this->handle_error_message($client, $message)) {
            $type = $this->safe_string($message, 'type');
            $methods = array(
                // 'heartbeat' => $this->handleHeartbeat,
                'welcome' => array($this, 'handle_system_status'),
                'ack' => array($this, 'handle_subscription_status'),
                'message' => array($this, 'handle_subject'),
                'pong' => array($this, 'handle_pong'),
            );
            $method = $this->safe_value($methods, $type);
            if ($method === null) {
                return $message;
            } else {
                return $method($client, $message);
            }
        }
    }
}
