<?php

namespace ccxt\pro;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

use Exception; // a common import
use ccxt\AuthenticationError;
use ccxt\ArgumentsRequired;
use ccxt\NotSupported;
use ccxt\InvalidNonce;
use React\Async;

class gate extends \ccxt\async\gate {

    use ClientTrait;

    public function describe() {
        return $this->deep_extend(parent::describe(), array(
            'has' => array(
                'ws' => true,
                'watchOrderBook' => true,
                'watchTicker' => true,
                'watchTickers' => false, // for now
                'watchTrades' => true,
                'watchMyTrades' => true,
                'watchOHLCV' => true,
                'watchBalance' => true,
                'watchOrders' => true,
            ),
            'urls' => array(
                'api' => array(
                    'ws' => 'wss://ws.gate.io/v4',
                    'spot' => 'wss://api.gateio.ws/ws/v4/',
                    'swap' => array(
                        'usdt' => 'wss://fx-ws.gateio.ws/v4/ws/usdt',
                        'btc' => 'wss://fx-ws.gateio.ws/v4/ws/btc',
                    ),
                    'future' => array(
                        'usdt' => 'wss://fx-ws.gateio.ws/v4/ws/delivery/usdt',
                        'btc' => 'wss://fx-ws.gateio.ws/v4/ws/delivery/btc',
                    ),
                    'option' => 'wss://op-ws.gateio.live/v4/ws',
                ),
                'test' => array(
                    'swap' => array(
                        'usdt' => 'wss://fx-ws-testnet.gateio.ws/v4/ws/usdt',
                        'btc' => 'wss://fx-ws-testnet.gateio.ws/v4/ws/btc',
                    ),
                    'future' => array(
                        'usdt' => 'wss://fx-ws-testnet.gateio.ws/v4/ws/usdt',
                        'btc' => 'wss://fx-ws-testnet.gateio.ws/v4/ws/btc',
                    ),
                    'option' => 'wss://op-ws-testnet.gateio.live/v4/ws',
                ),
            ),
            'options' => array(
                'tradesLimit' => 1000,
                'OHLCVLimit' => 1000,
                'watchTradesSubscriptions' => array(),
                'watchTickerSubscriptions' => array(),
                'watchOrderBookSubscriptions' => array(),
                'watchOrderBook' => array(
                    'interval' => '100ms',
                ),
                'watchBalance' => array(
                    'settle' => 'usdt', // or btc
                    'spot' => 'spot.balances', // spot.margin_balances, spot.funding_balances or spot.cross_balances
                ),
            ),
            'exceptions' => array(
                'ws' => array(
                    'exact' => array(
                        '2' => '\\ccxt\\BadRequest',
                        '4' => '\\ccxt\\AuthenticationError',
                        '6' => '\\ccxt\\AuthenticationError',
                        '11' => '\\ccxt\\AuthenticationError',
                    ),
                ),
            ),
        ));
    }

    public function watch_order_book($symbol, $limit = null, $params = array ()) {
        return Async\async(function () use ($symbol, $limit, $params) {
            /**
             * watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
             * @param {string} $symbol unified $symbol of the $market to fetch the order book for
             * @param {int|null} $limit the maximum amount of order book entries to return
             * @param {array} $params extra parameters specific to the gate api endpoint
             * @return {array} A dictionary of {@link https://docs.ccxt.com/en/latest/manual.html#order-book-structure order book structures} indexed by $market symbols
             */
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $symbol = $market['symbol'];
            $marketId = $market['id'];
            $options = $this->safe_value($this->options, 'watchOrderBook', array());
            $defaultLimit = $this->safe_integer($options, 'limit', 20);
            if (!$limit) {
                $limit = $defaultLimit;
            }
            $defaultInterval = $this->safe_string($options, 'interval', '100ms');
            $interval = $this->safe_string($params, 'interval', $defaultInterval);
            $type = $market['type'];
            $messageType = $this->get_uniform_type($type);
            $method = $messageType . '.' . 'order_book_update';
            $messageHash = $method . ':' . $market['symbol'];
            $url = $this->get_url_by_market_type($type, $market['inverse']);
            $payload = array( $marketId, $interval );
            if ($type !== 'spot') {
                // contract pairs require $limit in the $payload
                $stringLimit = (string) $limit;
                $payload[] = $stringLimit;
            }
            $subscriptionParams = array(
                'method' => array($this, 'handle_order_book_subscription'),
                'symbol' => $symbol,
                'limit' => $limit,
            );
            $orderbook = Async\await($this->subscribe_public($url, $method, $messageHash, $payload, $subscriptionParams));
            return $orderbook->limit ($limit);
        }) ();
    }

    public function handle_order_book_subscription($client, $message, $subscription) {
        $symbol = $this->safe_string($subscription, 'symbol');
        $limit = $this->safe_integer($subscription, 'limit');
        if (is_array($this->orderbooks) && array_key_exists($symbol, $this->orderbooks)) {
            unset($this->orderbooks[$symbol]);
        }
        $this->orderbooks[$symbol] = $this->order_book(array(), $limit);
        $options = $this->safe_value($this->options, 'handleOrderBookSubscription', array());
        $fetchOrderBookSnapshot = $this->safe_value($options, 'fetchOrderBookSnapshot', false);
        if ($fetchOrderBookSnapshot) {
            $fetchingOrderBookSnapshot = 'fetchingOrderBookSnapshot';
            $subscription[$fetchingOrderBookSnapshot] = true;
            $messageHash = $subscription['messageHash'];
            $client->subscriptions[$messageHash] = $subscription;
            $this->spawn(array($this, 'fetch_order_book_snapshot'), $client, $message, $subscription);
        }
    }

    public function fetch_order_book_snapshot($client, $message, $subscription) {
        return Async\async(function () use ($client, $message, $subscription) {
            $symbol = $this->safe_string($subscription, 'symbol');
            $limit = $this->safe_integer($subscription, 'limit');
            $messageHash = $this->safe_string($subscription, 'messageHash');
            try {
                $snapshot = Async\await($this->fetch_order_book($symbol, $limit));
                $orderbook = $this->orderbooks[$symbol];
                $messages = $orderbook->cache;
                $firstMessage = $this->safe_value($messages, 0, array());
                $result = $this->safe_value($firstMessage, 'result');
                $seqNum = $this->safe_integer($result, 'U');
                $nonce = $this->safe_integer($snapshot, 'nonce');
                // if the received $snapshot is earlier than the first cached delta
                // then we cannot align it with the cached deltas and we need to
                // retry synchronizing in $maxAttempts
                if (($seqNum === null) || ($nonce < $seqNum)) {
                    $maxAttempts = $this->safe_integer($this->options, 'maxOrderBookSyncAttempts', 3);
                    $numAttempts = $this->safe_integer($subscription, 'numAttempts', 0);
                    // retry to synchronize if we haven't reached $maxAttempts yet
                    if ($numAttempts < $maxAttempts) {
                        // safety guard
                        if (is_array($client->subscriptions) && array_key_exists($messageHash, $client->subscriptions)) {
                            $numAttempts = $this->sum($numAttempts, 1);
                            $subscription['numAttempts'] = $numAttempts;
                            $client->subscriptions[$messageHash] = $subscription;
                            $this->spawn(array($this, 'fetch_order_book_snapshot'), $client, $message, $subscription);
                        }
                    } else {
                        // throw upon failing to synchronize in $maxAttempts
                        unset($client->subscriptions[$messageHash]);
                        throw new InvalidNonce($this->id . ' failed to synchronize WebSocket feed with the $snapshot for $symbol ' . $symbol . ' in ' . (string) $maxAttempts . ' attempts');
                    }
                } else {
                    $orderbook->reset ($snapshot);
                    // unroll the accumulated deltas
                    for ($i = 0; $i < count($messages); $i++) {
                        $message = $messages[$i];
                        $this->handle_order_book_message($client, $message, $orderbook);
                    }
                    $this->orderbooks[$symbol] = $orderbook;
                    $client->resolve ($orderbook, $messageHash);
                }
            } catch (Exception $e) {
                $client->reject ($e, $messageHash);
            }
        }) ();
    }

    public function handle_order_book($client, $message) {
        //
        //     {
        //         "time":1649770575,
        //         "channel":"spot.order_book_update",
        //         "event":"update",
        //         "result":{
        //             "t":1649770575537,
        //             "e":"depthUpdate",
        //             "E":1649770575,
        //             "s":"LTC_USDT",
        //             "U":2622528153,
        //             "u":2622528265,
        //             "b":[
        //                 ["104.18","3.9398"],
        //                 ["104.56","19.0603"],
        //                 ["104.94","0"],
        //                 ["103.72","0"],
        //                 ["105.01","52.6186"],
        //                 ["104.76","0"],
        //                 ["104.97","0"],
        //                 ["104.71","0"],
        //                 ["104.84","25.8604"],
        //                 ["104.51","47.6508"],
        //             ],
        //             "a":[
        //                 ["105.26","40.5519"],
        //                 ["106.08","35.4396"],
        //                 ["105.2","0"],
        //                 ["105.45","8.5834"],
        //                 ["105.5","20.17"],
        //                 ["105.11","54.8359"],
        //                 ["105.52","28.5605"],
        //                 ["105.27","6.6325"],
        //                 ["105.3","4.291446"],
        //                 ["106.03","9.712"],
        //             ]
        //         }
        //     }
        //
        $channel = $this->safe_string($message, 'channel');
        $result = $this->safe_value($message, 'result');
        $marketId = $this->safe_string($result, 's');
        $symbol = $this->safe_symbol($marketId);
        $orderbook = $this->safe_value($this->orderbooks, $symbol);
        if ($orderbook === null) {
            $orderbook = $this->order_book(array());
            $this->orderbooks[$symbol] = $orderbook;
        }
        $messageHash = $channel . ':' . $symbol;
        $subscription = $this->safe_value($client->subscriptions, $messageHash, array());
        $fetchingOrderBookSnapshot = 'fetchingOrderBookSnapshot';
        $isFetchingOrderBookSnapshot = $this->safe_value($subscription, $fetchingOrderBookSnapshot, false);
        if (!$isFetchingOrderBookSnapshot) {
            $subscription[$fetchingOrderBookSnapshot] = true;
            $client->subscriptions[$messageHash] = $subscription;
            $this->spawn(array($this, 'fetch_order_book_snapshot'), $client, $message, $subscription);
        }
        if ($orderbook['nonce'] === null) {
            $orderbook->cache[] = $message;
        } else {
            $messageHash = $channel . ':' . $symbol;
            $this->handle_order_book_message($client, $message, $orderbook, $messageHash);
        }
    }

    public function handle_order_book_message($client, $message, $orderbook, $messageHash = null) {
        //
        // spot
        //
        //     {
        //         time => 1650189272,
        //         channel => 'spot.order_book_update',
        //         event => 'update',
        //         $result => {
        //             t => 1650189272515,
        //             e => 'depthUpdate',
        //             E => 1650189272,
        //             s => 'GMT_USDT',
        //             U => 140595902,
        //             u => 140595902,
        //             b => array(
        //                 array( '2.51518', '228.119' ),
        //                 array( '2.50587', '1510.11' ),
        //                 array( '2.49944', '67.6' ),
        //             ),
        //             a => array(
        //                 array( '2.5182', '4.199' ),
        //                 array( '2.51926', '1874' ),
        //                 array( '2.53528', '96.529' ),
        //             )
        //         }
        //     }
        //
        // swap
        //
        //     {
        //         id => null,
        //         time => 1650188898,
        //         channel => 'futures.order_book_update',
        //         event => 'update',
        //         error => null,
        //         $result => {
        //             t => 1650188898938,
        //             s => 'GMT_USDT',
        //             U => 1577718307,
        //             u => 1577719254,
        //             b => array(
        //                 array( p => '2.5178', s => 0 ),
        //                 array( p => '2.5179', s => 0 ),
        //                 array( p => '2.518', s => 0 ),
        //             ),
        //             a => array(
        //                 array( p => '2.52', s => 0 ),
        //                 array( p => '2.5201', s => 0 ),
        //                 array( p => '2.5203', s => 0 ),
        //             )
        //         }
        //     }
        //
        $result = $this->safe_value($message, 'result');
        $seqNum = $this->safe_integer($result, 'u');
        $nonce = $orderbook['nonce'];
        // we can't use the prevSeqNum (U) here because it is not consistent
        // with the previous $message sometimes so if the current $seqNum
        // is 2 in the next $message might be 3 or 4... so it is not safe to use
        if ($seqNum >= $nonce) {
            $asks = $this->safe_value($result, 'a', array());
            $bids = $this->safe_value($result, 'b', array());
            $this->handle_deltas($orderbook['asks'], $asks);
            $this->handle_deltas($orderbook['bids'], $bids);
            $orderbook['nonce'] = $seqNum;
            $timestamp = $this->safe_integer($result, 't');
            $orderbook['timestamp'] = $timestamp;
            $orderbook['datetime'] = $this->iso8601($timestamp);
            if ($messageHash !== null) {
                $client->resolve ($orderbook, $messageHash);
            }
        }
        return $orderbook;
    }

    public function handle_delta($bookside, $delta) {
        $price = null;
        $amount = null;
        if (gettype($delta) === 'array' && array_keys($delta) === array_keys(array_keys($delta))) {
            // spot
            $price = $this->safe_float($delta, 0);
            $amount = $this->safe_float($delta, 1);
        } else {
            // swap
            $price = $this->safe_float($delta, 'p');
            $amount = $this->safe_float($delta, 's');
        }
        $bookside->store ($price, $amount);
    }

    public function handle_deltas($bookside, $deltas) {
        for ($i = 0; $i < count($deltas); $i++) {
            $this->handle_delta($bookside, $deltas[$i]);
        }
    }

    public function watch_ticker($symbol, $params = array ()) {
        return Async\async(function () use ($symbol, $params) {
            /**
             * watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific $market
             * @param {string} $symbol unified $symbol of the $market to fetch the ticker for
             * @param {array} $params extra parameters specific to the gate api endpoint
             * @return {array} a {@link https://docs.ccxt.com/en/latest/manual.html#ticker-structure ticker structure}
             */
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $marketId = $market['id'];
            $type = $market['type'];
            $messageType = $this->get_uniform_type($type);
            $channel = $messageType . '.' . 'tickers';
            $messageHash = $channel . '.' . $market['symbol'];
            $payload = array( $marketId );
            $url = $this->get_url_by_market_type($type, $market['inverse']);
            return Async\await($this->subscribe_public($url, $channel, $messageHash, $payload));
        }) ();
    }

    public function handle_ticker($client, $message) {
        //
        //    {
        //        time => 1649326221,
        //        $channel => 'spot.tickers',
        //        event => 'update',
        //        $result => {
        //          currency_pair => 'BTC_USDT',
        //          last => '43444.82',
        //          lowest_ask => '43444.82',
        //          highest_bid => '43444.81',
        //          change_percentage => '-4.0036',
        //          base_volume => '5182.5412425462',
        //          quote_volume => '227267634.93123952',
        //          high_24h => '47698',
        //          low_24h => '42721.03'
        //        }
        //    }
        //
        $channel = $this->safe_string($message, 'channel');
        $result = $this->safe_value($message, 'result');
        if (gettype($result) !== 'array' || array_keys($result) !== array_keys(array_keys($result))) {
            $result = array( $result );
        }
        for ($i = 0; $i < count($result); $i++) {
            $ticker = $result[$i];
            $parsed = $this->parse_ticker($ticker);
            $symbol = $parsed['symbol'];
            $this->tickers[$symbol] = $parsed;
            $messageHash = $channel . '.' . $symbol;
            $client->resolve ($this->tickers[$symbol], $messageHash);
        }
    }

    public function watch_trades($symbol, $since = null, $limit = null, $params = array ()) {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            /**
             * get the list of most recent $trades for a particular $symbol
             * @param {string} $symbol unified $symbol of the $market to fetch $trades for
             * @param {int|null} $since timestamp in ms of the earliest trade to fetch
             * @param {int|null} $limit the maximum amount of $trades to fetch
             * @param {array} $params extra parameters specific to the gate api endpoint
             * @return {[array]} a list of ~@link https://docs.ccxt.com/en/latest/manual.html?#public-$trades trade structures~
             */
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $symbol = $market['symbol'];
            $marketId = $market['id'];
            $type = $market['type'];
            $messageType = $this->get_uniform_type($type);
            $method = $messageType . '.trades';
            $messageHash = $method;
            if ($symbol !== null) {
                $messageHash .= ':' . $market['symbol'];
            }
            $url = $this->get_url_by_market_type($type, $market['inverse']);
            $payload = array( $marketId );
            $trades = Async\await($this->subscribe_public($url, $method, $messageHash, $payload));
            if ($this->newUpdates) {
                $limit = $trades->getLimit ($symbol, $limit);
            }
            return $this->filter_by_since_limit($trades, $since, $limit, 'timestamp', true);
        }) ();
    }

    public function handle_trades($client, $message) {
        //
        // {
        //     time => 1648725035,
        //     $channel => 'spot.trades',
        //     event => 'update',
        //     $result => [array(
        //       id => 3130257995,
        //       create_time => 1648725035,
        //       create_time_ms => '1648725035923.0',
        //       side => 'sell',
        //       currency_pair => 'LTC_USDT',
        //       amount => '0.0116',
        //       price => '130.11'
        //     )]
        // }
        //
        $channel = $this->safe_string($message, 'channel');
        $result = $this->safe_value($message, 'result');
        if (gettype($result) !== 'array' || array_keys($result) !== array_keys(array_keys($result))) {
            $result = array( $result );
        }
        $parsedTrades = $this->parse_trades($result);
        $marketIds = array();
        for ($i = 0; $i < count($parsedTrades); $i++) {
            $trade = $parsedTrades[$i];
            $symbol = $trade['symbol'];
            $cachedTrades = $this->safe_value($this->trades, $symbol);
            if ($cachedTrades === null) {
                $limit = $this->safe_integer($this->options, 'tradesLimit', 1000);
                $cachedTrades = new ArrayCache ($limit);
                $this->trades[$symbol] = $cachedTrades;
            }
            $cachedTrades->append ($trade);
            $marketIds[$symbol] = true;
        }
        $keys = is_array($marketIds) ? array_keys($marketIds) : array();
        for ($i = 0; $i < count($keys); $i++) {
            $symbol = $keys[$i];
            $hash = $channel . ':' . $symbol;
            $stored = $this->safe_value($this->trades, $symbol);
            $client->resolve ($stored, $hash);
        }
        $client->resolve ($this->trades, $channel);
    }

    public function watch_ohlcv($symbol, $timeframe = '1m', $since = null, $limit = null, $params = array ()) {
        return Async\async(function () use ($symbol, $timeframe, $since, $limit, $params) {
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $symbol = $market['symbol'];
            $marketId = $market['id'];
            $type = $market['type'];
            $interval = $this->timeframes[$timeframe];
            $messageType = $this->get_uniform_type($type);
            $method = $messageType . '.candlesticks';
            $messageHash = $method . ':' . $interval . ':' . $market['symbol'];
            $url = $this->get_url_by_market_type($type, $market['inverse']);
            $payload = array( $interval, $marketId );
            $ohlcv = Async\await($this->subscribe_public($url, $method, $messageHash, $payload));
            if ($this->newUpdates) {
                $limit = $ohlcv->getLimit ($symbol, $limit);
            }
            return $this->filter_by_since_limit($ohlcv, $since, $limit, 0, true);
        }) ();
    }

    public function handle_ohlcv($client, $message) {
        //
        // {
        //     "time" => 1606292600,
        //     "channel" => "spot.candlesticks",
        //     "event" => "update",
        //     "result" => {
        //       "t" => "1606292580", // total volume
        //       "v" => "2362.32035", // volume
        //       "c" => "19128.1", // close
        //       "h" => "19128.1", // high
        //       "l" => "19128.1", // low
        //       "o" => "19128.1", // open
        //       "n" => "1m_BTC_USDT" // sub
        //     }
        //   }
        //
        $channel = $this->safe_string($message, 'channel');
        $result = $this->safe_value($message, 'result');
        $isArray = gettype($result) === 'array' && array_keys($result) === array_keys(array_keys($result));
        if (!$isArray) {
            $result = array( $result );
        }
        $marketIds = array();
        for ($i = 0; $i < count($result); $i++) {
            $ohlcv = $result[$i];
            $subscription = $this->safe_string($ohlcv, 'n', '');
            $parts = explode('_', $subscription);
            $timeframe = $this->safe_string($parts, 0);
            $prefix = $timeframe . '_';
            $marketId = str_replace($prefix, '', $subscription);
            $symbol = $this->safe_symbol($marketId, null, '_');
            $parsed = $this->parse_ohlcv($ohlcv);
            $stored = $this->safe_value($this->ohlcvs, $symbol);
            if ($stored === null) {
                $limit = $this->safe_integer($this->options, 'OHLCVLimit', 1000);
                $stored = new ArrayCacheByTimestamp ($limit);
                $this->ohlcvs[$symbol] = $stored;
            }
            $stored->append ($parsed);
            $marketIds[$symbol] = $timeframe;
        }
        $keys = is_array($marketIds) ? array_keys($marketIds) : array();
        for ($i = 0; $i < count($keys); $i++) {
            $symbol = $keys[$i];
            $timeframe = $marketIds[$symbol];
            $interval = $this->timeframes[$timeframe];
            $hash = $channel . ':' . $interval . ':' . $symbol;
            $stored = $this->safe_value($this->ohlcvs, $symbol);
            $client->resolve ($stored, $hash);
        }
    }

    public function authenticate($params = array ()) {
        return Async\async(function () use ($params) {
            $url = $this->urls['api']['ws'];
            $client = $this->client($url);
            $future = $client->future ('authenticated');
            $method = 'server.sign';
            $authenticate = $this->safe_value($client->subscriptions, $method);
            if ($authenticate === null) {
                $requestId = $this->milliseconds();
                $requestIdString = (string) $requestId;
                $signature = $this->hmac($this->encode($requestIdString), $this->encode($this->secret), 'sha512', 'hex');
                $authenticateMessage = array(
                    'id' => $requestId,
                    'method' => $method,
                    'params' => array( $this->apiKey, $signature, $requestId ),
                );
                $subscribe = array(
                    'id' => $requestId,
                    'method' => array($this, 'handle_authentication_message'),
                );
                $this->spawn(array($this, 'watch'), $url, $requestId, $authenticateMessage, $method, $subscribe);
            }
            return Async\await($future);
        }) ();
    }

    public function watch_my_trades($symbol = null, $since = null, $limit = null, $params = array ()) {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            /**
             * watches information on multiple $trades made by the user
             * @param {string} $symbol unified $market $symbol of the $market orders were made in
             * @param {int|null} $since the earliest time in ms to fetch orders for
             * @param {int|null} $limit the maximum number of  orde structures to retrieve
             * @param {array} $params extra parameters specific to the gate api endpoint
             * @return {[array]} a list of [order structures]{@link https://docs.ccxt.com/en/latest/manual.html#order-structure
             */
            Async\await($this->load_markets());
            $subType = null;
            $type = null;
            $marketId = '!' . 'all';
            if ($symbol !== null) {
                $market = $this->market($symbol);
                $symbol = $market['symbol'];
                $type = $market['type'];
                $marketId = $market['id'];
            } else {
                list($type, $params) = $this->handle_market_type_and_params('watchMyTrades', null, $params);
                if ($type !== 'spot') {
                    $options = $this->safe_value($this->options, 'watchMyTrades', array());
                    $subType = $this->safe_value($options, 'subType', 'linear');
                    $subType = $this->safe_value($params, 'subType', $subType);
                    $params = $this->omit($params, 'subType');
                }
            }
            $messageType = $this->get_uniform_type($type);
            $method = $messageType . '.usertrades';
            $messageHash = $method;
            if ($symbol !== null) {
                $messageHash .= ':' . $symbol;
            }
            $isInverse = ($subType === 'inverse');
            $url = $this->get_url_by_market_type($type, $isInverse);
            $payload = array( $marketId );
            // uid required for non spot markets
            $requiresUid = ($type !== 'spot');
            $trades = Async\await($this->subscribe_private($url, $method, $messageHash, $payload, $requiresUid));
            if ($this->newUpdates) {
                $limit = $trades->getLimit ($symbol, $limit);
            }
            return $this->filter_by_symbol_since_limit($trades, $symbol, $since, $limit, true);
        }) ();
    }

    public function handle_my_trades($client, $message) {
        //
        // {
        //     "time" => 1543205083,
        //     "channel" => "futures.usertrades",
        //     "event" => "update",
        //     "error" => null,
        //     "result" => array(
        //       {
        //         "id" => "3335259",
        //         "create_time" => 1628736848,
        //         "create_time_ms" => 1628736848321,
        //         "contract" => "BTC_USD",
        //         "order_id" => "4872460",
        //         "size" => 1,
        //         "price" => "40000.4",
        //         "role" => "maker"
        //       }
        //     )
        // }
        //
        $result = $this->safe_value($message, 'result', array());
        $channel = $this->safe_string($message, 'channel');
        $tradesLength = count($result);
        if ($tradesLength === 0) {
            return;
        }
        $cachedTrades = $this->myTrades;
        if ($cachedTrades === null) {
            $limit = $this->safe_integer($this->options, 'tradesLimit', 1000);
            $cachedTrades = new ArrayCacheBySymbolById ($limit);
            $this->myTrades = $cachedTrades;
        }
        $parsed = $this->parse_trades($result);
        $marketIds = array();
        for ($i = 0; $i < count($parsed); $i++) {
            $trade = $parsed[$i];
            $cachedTrades->append ($trade);
            $symbol = $trade['symbol'];
            $marketIds[$symbol] = true;
        }
        $keys = is_array($marketIds) ? array_keys($marketIds) : array();
        for ($i = 0; $i < count($keys); $i++) {
            $market = $keys[$i];
            $hash = $channel . ':' . $market;
            $client->resolve ($cachedTrades, $hash);
        }
        $client->resolve ($cachedTrades, $channel);
    }

    public function watch_balance($params = array ()) {
        return Async\async(function () use ($params) {
            /**
             * query for balance and get the amount of funds available for trading or funds locked in orders
             * @param {array} $params extra parameters specific to the gate api endpoint
             * @return {array} a ~@link https://docs.ccxt.com/en/latest/manual.html?#balance-structure balance structure~
             */
            Async\await($this->load_markets());
            $type = null;
            list($type, $params) = $this->handle_market_type_and_params('watchBalance', null, $params);
            $options = $this->safe_value($this->options, 'watchBalance', array());
            $subType = $this->safe_value($options, 'subType', 'linear');
            $subType = $this->safe_value($params, 'subType', $subType);
            $params = $this->omit($params, 'subType');
            $isInverse = ($subType === 'inverse');
            $url = $this->get_url_by_market_type($type, $isInverse);
            $requiresUid = ($type !== 'spot');
            $channelType = 'spot';
            if ($type === 'future' || $type === 'swap') {
                $channelType = 'futures';
            } elseif ($type === 'option') {
                $channelType = 'options';
            }
            $channel = null;
            if ($type === 'spot') {
                $options = $this->safe_value($this->options, 'watchTicker', array());
                $channel = $this->safe_string($options, 'spot', 'spot.balances');
            } else {
                $channel = $channelType . '.balances';
            }
            return Async\await($this->subscribe_private($url, $channel, $channel, null, $requiresUid));
        }) ();
    }

    public function handle_balance($client, $message) {
        $messageHash = $message['method'];
        $result = $message['params'][0];
        $this->handle_balance_message($client, $messageHash, $result);
    }

    public function handle_balance_message($client, $message) {
        //
        // spot order fill
        //   {
        //       time => 1653664351,
        //       $channel => 'spot.balances',
        //       event => 'update',
        //       $result => array(
        //         {
        //           timestamp => '1653664351',
        //           timestamp_ms => '1653664351017',
        //           user => '10406147',
        //           currency => 'LTC',
        //           change => '-0.0002000000000000',
        //           total => '0.09986000000000000000',
        //           available => '0.09986000000000000000'
        //         }
        //       )
        //   }
        //
        // $account transfer
        //
        //    {
        //        id => null,
        //        time => 1653665088,
        //        $channel => 'futures.balances',
        //        event => 'update',
        //        error => null,
        //        $result => array(
        //          {
        //            balance => 25.035008537,
        //            change => 25,
        //            text => '-',
        //            time => 1653665088,
        //            time_ms => 1653665088286,
        //            type => 'dnw',
        //            user => '10406147'
        //          }
        //        )
        //   }
        //
        // swap order fill
        //   {
        //       id => null,
        //       time => 1653665311,
        //       $channel => 'futures.balances',
        //       event => 'update',
        //       error => null,
        //       $result => array(
        //         {
        //           balance => 20.031873037,
        //           change => -0.0031355,
        //           text => 'LTC_USDT:165551103273',
        //           time => 1653665311,
        //           time_ms => 1653665311437,
        //           type => 'fee',
        //           user => '10406147'
        //         }
        //       )
        //   }
        //
        $channel = $this->safe_string($message, 'channel');
        $result = $this->safe_value($message, 'result', array());
        for ($i = 0; $i < count($result); $i++) {
            $rawBalance = $result[$i];
            $account = $this->account();
            $currencyId = $this->safe_string($rawBalance, 'currency', 'USDT'); // when not present it is USDT
            $code = $this->safe_currency_code($currencyId);
            $account['free'] = $this->safe_string($rawBalance, 'available');
            $account['total'] = $this->safe_string_2($rawBalance, 'total', 'balance');
            $this->balance[$code] = $account;
        }
        $this->balance = $this->safe_balance($this->balance);
        $client->resolve ($this->balance, $channel);
    }

    public function watch_orders($symbol = null, $since = null, $limit = null, $params = array ()) {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            /**
             * watches information on multiple $orders made by the user
             * @param {string|null} $symbol unified $market $symbol of the $market $orders were made in
             * @param {int|null} $since the earliest time in ms to fetch $orders for
             * @param {int|null} $limit the maximum number of  orde structures to retrieve
             * @param {array} $params extra parameters specific to the gate api endpoint
             * @param {string} $params->type spot, margin, swap, future, or option. Required if listening to all symbols.
             * @param {boolean} $params->isInverse if future, listen to inverse or linear contracts
             * @return {[array]} a list of [order structures]{@link https://docs.ccxt.com/en/latest/manual.html#order-structure
             */
            Async\await($this->load_markets());
            $market = null;
            if ($symbol !== null) {
                $market = $this->market($symbol);
                $symbol = $market['symbol'];
            }
            $type = null;
            $query = null;
            list($type, $query) = $this->handle_market_type_and_params('watchOrders', $market, $params);
            $typeId = $this->get_supported_mapping($type, array(
                'spot' => 'spot',
                'margin' => 'spot',
                'future' => 'futures',
                'swap' => 'futures',
                'option' => 'options',
            ));
            $method = $typeId . '.orders';
            $messageHash = $method;
            $payload = array( '!' . 'all' );
            if ($symbol !== null) {
                $messageHash = $method . ':' . $market['id'];
                $payload = [ $market['id'] ];
            }
            $subType = null;
            list($subType, $query) = $this->handle_sub_type_and_params('watchOrders', $market, $query);
            $isInverse = ($subType === 'inverse');
            $url = $this->get_url_by_market_type($type, $isInverse);
            // uid required for non spot markets
            $requiresUid = ($type !== 'spot');
            $orders = Async\await($this->subscribe_private($url, $method, $messageHash, $payload, $requiresUid));
            if ($this->newUpdates) {
                $limit = $orders->getLimit ($symbol, $limit);
            }
            return $this->filter_by_since_limit($orders, $since, $limit, 'timestamp', true);
        }) ();
    }

    public function handle_order($client, $message) {
        //
        // {
        //     "time" => 1605175506,
        //     "channel" => "spot.orders",
        //     "event" => "update",
        //     "result" => array(
        //       {
        //         "id" => "30784435",
        //         "user" => 123456,
        //         "text" => "t-abc",
        //         "create_time" => "1605175506",
        //         "create_time_ms" => "1605175506123",
        //         "update_time" => "1605175506",
        //         "update_time_ms" => "1605175506123",
        //         "event" => "put",
        //         "currency_pair" => "BTC_USDT",
        //         "type" => "limit",
        //         "account" => "spot",
        //         "side" => "sell",
        //         "amount" => "1",
        //         "price" => "10001",
        //         "time_in_force" => "gtc",
        //         "left" => "1",
        //         "filled_total" => "0",
        //         "fee" => "0",
        //         "fee_currency" => "USDT",
        //         "point_fee" => "0",
        //         "gt_fee" => "0",
        //         "gt_discount" => true,
        //         "rebated_fee" => "0",
        //         "rebated_fee_currency" => "USDT"
        //       }
        //     )
        // }
        //
        $orders = $this->safe_value($message, 'result', array());
        $channel = $this->safe_string($message, 'channel');
        $ordersLength = count($orders);
        if ($ordersLength > 0) {
            $limit = $this->safe_integer($this->options, 'ordersLimit', 1000);
            if ($this->orders === null) {
                $this->orders = new ArrayCacheBySymbolById ($limit);
            }
            $stored = $this->orders;
            $marketIds = array();
            $parsedOrders = $this->parse_orders($orders);
            for ($i = 0; $i < count($parsedOrders); $i++) {
                $parsed = $parsedOrders[$i];
                // inject order status
                $info = $this->safe_value($parsed, 'info');
                $event = $this->safe_string($info, 'event');
                if ($event === 'put') {
                    $parsed['status'] = 'open';
                } elseif ($event === 'finish') {
                    $parsed['status'] = 'closed';
                }
                $stored->append ($parsed);
                $symbol = $parsed['symbol'];
                $market = $this->market($symbol);
                $marketIds[$market['id']] = true;
            }
            $keys = is_array($marketIds) ? array_keys($marketIds) : array();
            for ($i = 0; $i < count($keys); $i++) {
                $messageHash = $channel . ':' . $keys[$i];
                $client->resolve ($this->orders, $messageHash);
            }
            $client->resolve ($this->orders, $channel);
        }
    }

    public function handle_authentication_message($client, $message, $subscription) {
        $result = $this->safe_value($message, 'result');
        $status = $this->safe_string($result, 'status');
        if ($status === 'success') {
            // $client->resolve (true, 'authenticated') will delete the $future
            // we want to remember that we are authenticated in subsequent call to private methods
            $future = $this->safe_value($client->futures, 'authenticated');
            if ($future !== null) {
                $future->resolve (true);
            }
        } else {
            // delete authenticate subscribeHash to release the "subscribe lock"
            // allows subsequent calls to subscribe to reauthenticate
            // avoids sending two authentication messages before receiving a reply
            $error = new AuthenticationError ($this->id . ' handleAuthenticationMessage() error');
            $client->reject ($error, 'authenticated');
            if (is_array($client->subscriptions) && array_key_exists('server.sign', $client->subscriptions)) {
                unset($client->subscriptions['server.sign']);
            }
        }
    }

    public function handle_error_message($client, $message) {
        // {
        //     time => 1647274664,
        //     channel => 'futures.orders',
        //     event => 'subscribe',
        //     $error => array( $code => 2, $message => 'unknown contract BTC_USDT_20220318' ),
        // }
        // {
        //     time => 1647276473,
        //     channel => 'futures.orders',
        //     event => 'subscribe',
        //     $error => array(
        //       $code => 4,
        //       $message => 'array("label":"INVALID_KEY","message":"Invalid key provided")\n'
        //     ),
        //     result => null
        //   }
        $error = $this->safe_value($message, 'error', array());
        $code = $this->safe_integer($error, 'code');
        if ($code !== null) {
            $id = $this->safe_string($message, 'id');
            $subscriptionsById = $this->index_by($client->subscriptions, 'id');
            $subscription = $this->safe_value($subscriptionsById, $id);
            if ($subscription !== null) {
                try {
                    $this->throw_exactly_matched_exception($this->exceptions['ws']['exact'], $code, $this->json($message));
                } catch (Exception $e) {
                    $messageHash = $this->safe_string($subscription, 'messageHash');
                    $client->reject ($e, $messageHash);
                    $client->reject ($e, $id);
                    if (is_array($client->subscriptions) && array_key_exists($id, $client->subscriptions)) {
                        unset($client->subscriptions[$id]);
                    }
                }
            }
        }
    }

    public function handle_balance_subscription($client, $message) {
        $this->spawn(array($this, 'fetch_balance_snapshot'), $client, $message);
    }

    public function fetch_balance_snapshot($client, $message) {
        return Async\async(function () use ($client, $message) {
            //
            //  {
            //     id => 1,
            //     time => 1653665810,
            //     $channel => 'futures.balances',
            //     event => 'subscribe',
            //     auth => array(
            //     ),
            //     payload => array( '10406147' )
            //   }
            //
            Async\await($this->load_markets());
            $channel = $this->safe_string($message, 'channel', '');
            $parts = explode('.', $channel);
            $exchangeType = $this->safe_string($parts, 0);
            $type = $exchangeType;
            if ($exchangeType === 'futures') {
                $type = 'future';
            } elseif ($type === 'options') {
                $type = 'option';
            }
            $params = array(
                'type' => $type,
            );
            if ($type === 'future' || $type === 'swap') {
                $options = $this->safe_value($this->options, 'watchTicker', array());
                $settle = $this->safe_string($options, 'settle', 'usdt');
                $params['settle'] = $settle;
            }
            $snapshot = Async\await($this->fetch_balance($params));
            $this->balance = $snapshot;
            $client->resolve ($this->balance, $channel);
        }) ();
    }

    public function handle_subscription_status($client, $message) {
        $channel = $this->safe_string($message, 'channel', '');
        if (mb_strpos($channel, 'balance') !== false) {
            $this->handle_balance_subscription($client, $message);
        }
    }

    public function handle_message($client, $message) {
        //
        // subscribe
        //    {
        //        time => 1649062304,
        //        id => 1649062303,
        //        $channel => 'spot.candlesticks',
        //        $event => 'subscribe',
        //        result => array( status => 'success' )
        //    }
        //
        // candlestick
        //    {
        //        time => 1649063328,
        //        $channel => 'spot.candlesticks',
        //        $event => 'update',
        //        result => {
        //          t => '1649063280',
        //          v => '58932.23174896',
        //          c => '45966.47',
        //          h => '45997.24',
        //          l => '45966.47',
        //          o => '45975.18',
        //          n => '1m_BTC_USDT',
        //          a => '1.281699'
        //        }
        //     }
        //
        //  orders
        //   {
        //       "time" => 1630654851,
        //       "channel" => "options.orders", or futures.orders or spot.orders
        //       "event" => "update",
        //       "result" => array(
        //          {
        //             "contract" => "BTC_USDT-20211130-65000-C",
        //             "create_time" => 1637897000,
        //               (...)
        //       )
        //   }
        // orderbook
        //   {
        //       time => 1649770525,
        //       $channel => 'spot.order_book_update',
        //       $event => 'update',
        //       result => {
        //         t => 1649770525653,
        //         e => 'depthUpdate',
        //         E => 1649770525,
        //         s => 'LTC_USDT',
        //         U => 2622525645,
        //         u => 2622525665,
        //         b => [
        //           [Array], [Array],
        //           [Array], [Array],
        //           [Array], [Array],
        //           [Array], [Array],
        //           [Array], [Array],
        //           [Array]
        //         ],
        //         a => [
        //           [Array], [Array],
        //           [Array], [Array],
        //           [Array], [Array],
        //           [Array], [Array],
        //           [Array], [Array],
        //           [Array]
        //         ]
        //       }
        //     }
        //
        // balance update
        //
        //    {
        //        time => 1653664351,
        //        $channel => 'spot.balances',
        //        $event => 'update',
        //        result => array(
        //          {
        //            timestamp => '1653664351',
        //            timestamp_ms => '1653664351017',
        //            user => '10406147',
        //            currency => 'LTC',
        //            change => '-0.0002000000000000',
        //            total => '0.09986000000000000000',
        //            available => '0.09986000000000000000'
        //          }
        //        )
        //    }
        //
        $this->handle_error_message($client, $message);
        $event = $this->safe_string($message, 'event');
        if ($event === 'subscribe') {
            $this->handle_subscription_status($client, $message);
            return;
        }
        $channel = $this->safe_string($message, 'channel', '');
        $channelParts = explode('.', $channel);
        $channelType = $this->safe_value($channelParts, 1);
        $v4Methods = array(
            'usertrades' => array($this, 'handle_my_trades'),
            'candlesticks' => array($this, 'handle_ohlcv'),
            'orders' => array($this, 'handle_order'),
            'tickers' => array($this, 'handle_ticker'),
            'trades' => array($this, 'handle_trades'),
            'order_book_update' => array($this, 'handle_order_book'),
            'balances' => array($this, 'handle_balance_message'),
        );
        $method = $this->safe_value($v4Methods, $channelType);
        if ($method !== null) {
            $method($client, $message);
        }
    }

    public function get_uniform_type($type) {
        $uniformType = 'spot';
        if ($type === 'future' || $type === 'swap') {
            $uniformType = 'futures';
        } elseif ($type === 'option') {
            $uniformType = 'options';
        }
        return $uniformType;
    }

    public function get_url_by_market_type($type, $isInverse = false) {
        if ($type === 'spot') {
            $spotUrl = $this->urls['api']['spot'];
            if ($spotUrl === null) {
                throw new NotSupported($this->id . ' does not have a testnet for the ' . $type . ' market $type->');
            }
            return $spotUrl;
        }
        if ($type === 'swap') {
            $baseUrl = $this->urls['api']['swap'];
            return $isInverse ? $baseUrl['btc'] : $baseUrl['usdt'];
        }
        if ($type === 'future') {
            $baseUrl = $this->urls['api']['future'];
            return $isInverse ? $baseUrl['btc'] : $baseUrl['usdt'];
        }
        if ($type === 'option') {
            return $this->urls['api']['option'];
        }
    }

    public function request_id() {
        // their support said that $reqid must be an int32, not documented
        $reqid = $this->sum($this->safe_integer($this->options, 'reqid', 0), 1);
        $this->options['reqid'] = $reqid;
        return $reqid;
    }

    public function subscribe_public($url, $channel, $messageHash, $payload, $subscriptionParams = array ()) {
        return Async\async(function () use ($url, $channel, $messageHash, $payload, $subscriptionParams) {
            $requestId = $this->request_id();
            $time = $this->seconds();
            $request = array(
                'id' => $requestId,
                'time' => $time,
                'channel' => $channel,
                'event' => 'subscribe',
                'payload' => $payload,
            );
            $subscription = array(
                'id' => $requestId,
                'messageHash' => $messageHash,
            );
            $subscription = array_merge($subscription, $subscriptionParams);
            return Async\await($this->watch($url, $messageHash, $request, $messageHash, $subscription));
        }) ();
    }

    public function subscribe_private($url, $channel, $messageHash, $payload = null, $requiresUid = false) {
        return Async\async(function () use ($url, $channel, $messageHash, $payload, $requiresUid) {
            $this->check_required_credentials();
            // uid is required for some subscriptions only so it's not a part of required credentials
            if ($requiresUid) {
                if ($this->uid === null || strlen($this->uid) === 0) {
                    throw new ArgumentsRequired($this->id . ' requires uid to subscribe');
                }
                $idArray = array( $this->uid );
                if ($payload === null) {
                    $payload = $idArray;
                } else {
                    $payload = $this->array_concat($idArray, $payload);
                }
            }
            $time = $this->seconds();
            $event = 'subscribe';
            $signaturePayload = 'channel=' . $channel . '&' . 'event=' . $event . '&' . 'time=' . (string) $time;
            $signature = $this->hmac($this->encode($signaturePayload), $this->encode($this->secret), 'sha512', 'hex');
            $auth = array(
                'method' => 'api_key',
                'KEY' => $this->apiKey,
                'SIGN' => $signature,
            );
            $requestId = $this->request_id();
            $request = array(
                'id' => $requestId,
                'time' => $time,
                'channel' => $channel,
                'event' => 'subscribe',
                'auth' => $auth,
            );
            if ($payload !== null) {
                $request['payload'] = $payload;
            }
            $subscription = array(
                'id' => $requestId,
                'messageHash' => $messageHash,
            );
            return Async\await($this->watch($url, $messageHash, $request, $messageHash, $subscription));
        }) ();
    }
}
