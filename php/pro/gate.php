<?php

namespace ccxt\pro;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

use Exception; // a common import
use ccxt\ArgumentsRequired;
use ccxt\InvalidNonce;
use React\Async;

class gate extends \ccxt\async\gate {

    public function describe() {
        return $this->deep_extend(parent::describe(), array(
            'has' => array(
                'ws' => true,
                'watchOrderBook' => true,
                'watchTicker' => true,
                'watchTickers' => true, // for now
                'watchTrades' => true,
                'watchMyTrades' => true,
                'watchOHLCV' => true,
                'watchBalance' => true,
                'watchOrders' => true,
            ),
            'urls' => array(
                'api' => array(
                    'ws' => 'wss://ws.gate.io/v4',
                    'spot' => 'wss://api.gateio.ws/ws/v4/',
                    'swap' => array(
                        'usdt' => 'wss://fx-ws.gateio.ws/v4/ws/usdt',
                        'btc' => 'wss://fx-ws.gateio.ws/v4/ws/btc',
                    ),
                    'future' => array(
                        'usdt' => 'wss://fx-ws.gateio.ws/v4/ws/delivery/usdt',
                        'btc' => 'wss://fx-ws.gateio.ws/v4/ws/delivery/btc',
                    ),
                    'option' => 'wss://op-ws.gateio.live/v4/ws',
                ),
                'test' => array(
                    'swap' => array(
                        'usdt' => 'wss://fx-ws-testnet.gateio.ws/v4/ws/usdt',
                        'btc' => 'wss://fx-ws-testnet.gateio.ws/v4/ws/btc',
                    ),
                    'future' => array(
                        'usdt' => 'wss://fx-ws-testnet.gateio.ws/v4/ws/usdt',
                        'btc' => 'wss://fx-ws-testnet.gateio.ws/v4/ws/btc',
                    ),
                    'option' => 'wss://op-ws-testnet.gateio.live/v4/ws',
                ),
            ),
            'options' => array(
                'tradesLimit' => 1000,
                'OHLCVLimit' => 1000,
                'watchTradesSubscriptions' => array(),
                'watchTickerSubscriptions' => array(),
                'watchOrderBookSubscriptions' => array(),
                'watchTicker' => array(
                    'name' => 'tickers', // or book_ticker
                ),
                'watchOrderBook' => array(
                    'interval' => '100ms',
                    'snapshotDelay' => 10, // how many deltas to cache before fetching a snapshot
                    'maxRetries' => 3,
                ),
                'watchBalance' => array(
                    'settle' => 'usdt', // or btc
                    'spot' => 'spot.balances', // spot.margin_balances, spot.funding_balances or spot.cross_balances
                ),
            ),
            'exceptions' => array(
                'ws' => array(
                    'exact' => array(
                        '2' => '\\ccxt\\BadRequest',
                        '4' => '\\ccxt\\AuthenticationError',
                        '6' => '\\ccxt\\AuthenticationError',
                        '11' => '\\ccxt\\AuthenticationError',
                    ),
                ),
            ),
        ));
    }

    public function watch_order_book(string $symbol, ?int $limit = null, $params = array ()) {
        return Async\async(function () use ($symbol, $limit, $params) {
            /**
             * watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
             * @param {string} $symbol unified $symbol of the $market to fetch the order book for
             * @param {int|null} $limit the maximum amount of order book entries to return
             * @param {array} $params extra parameters specific to the gate api endpoint
             * @return {array} A dictionary of ~@link https://docs.ccxt.com/#/?id=order-book-structure order book structures~ indexed by $market symbols
             */
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $symbol = $market['symbol'];
            $marketId = $market['id'];
            list($interval, $query) = $this->handle_option_and_params($params, 'watchOrderBook', 'interval', '100ms');
            $messageType = $this->get_type_by_market($market);
            $channel = $messageType . '.order_book_update';
            $messageHash = 'orderbook' . ':' . $symbol;
            $url = $this->get_url_by_market($market);
            $payload = array( $marketId, $interval );
            if ($limit === null) {
                $limit = 100;
            }
            if ($market['contract']) {
                $stringLimit = (string) $limit;
                $payload[] = $stringLimit;
            }
            $subscription = array(
                'symbol' => $symbol,
                'limit' => $limit,
            );
            $orderbook = Async\await($this->subscribe_public($url, $messageHash, $payload, $channel, $query, $subscription));
            return $orderbook->limit ();
        }) ();
    }

    public function handle_order_book_subscription(Client $client, $message, $subscription) {
        $symbol = $this->safe_string($subscription, 'symbol');
        $limit = $this->safe_integer($subscription, 'limit');
        $this->orderbooks[$symbol] = $this->order_book(array(), $limit);
    }

    public function handle_order_book(Client $client, $message) {
        //
        // spot
        //
        //     {
        //         time => 1650189272,
        //         $channel => 'spot.order_book_update',
        //         event => 'update',
        //         result => {
        //             t => 1650189272515,
        //             e => 'depthUpdate',
        //             E => 1650189272,
        //             s => 'GMT_USDT',
        //             U => 140595902,
        //             u => 140595902,
        //             b => array(
        //                 array( '2.51518', '228.119' ),
        //                 array( '2.50587', '1510.11' ),
        //                 array( '2.49944', '67.6' ),
        //             ),
        //             a => array(
        //                 array( '2.5182', '4.199' ),
        //                 array( '2.51926', '1874' ),
        //                 array( '2.53528', '96.529' ),
        //             )
        //         }
        //     }
        //
        // swap
        //
        //     {
        //         id => null,
        //         time => 1650188898,
        //         $channel => 'futures.order_book_update',
        //         event => 'update',
        //         $error => null,
        //         result => {
        //             t => 1650188898938,
        //             s => 'GMT_USDT',
        //             U => 1577718307,
        //             u => 1577719254,
        //             b => array(
        //                 array( p => '2.5178', s => 0 ),
        //                 array( p => '2.5179', s => 0 ),
        //                 array( p => '2.518', s => 0 ),
        //             ),
        //             a => array(
        //                 array( p => '2.52', s => 0 ),
        //                 array( p => '2.5201', s => 0 ),
        //                 array( p => '2.5203', s => 0 ),
        //             )
        //         }
        //     }
        //
        $channel = $this->safe_string($message, 'channel');
        $channelParts = explode('.', $channel);
        $rawMarketType = $this->safe_string($channelParts, 0);
        $isSpot = $rawMarketType === 'spot';
        $marketType = $isSpot ? 'spot' : 'contract';
        $delta = $this->safe_value($message, 'result');
        $deltaStart = $this->safe_integer($delta, 'U');
        $deltaEnd = $this->safe_integer($delta, 'u');
        $marketId = $this->safe_string($delta, 's');
        $symbol = $this->safe_symbol($marketId, null, '_', $marketType);
        $messageHash = 'orderbook:' . $symbol;
        $storedOrderBook = $this->safe_value($this->orderbooks, $symbol, $this->order_book(array()));
        $nonce = $this->safe_integer($storedOrderBook, 'nonce');
        if ($nonce === null) {
            $cacheLength = 0;
            if ($storedOrderBook !== null) {
                $cacheLength = count($storedOrderBook->cache);
            }
            $snapshotDelay = $this->handle_option('watchOrderBook', 'snapshotDelay', 10);
            $waitAmount = $isSpot ? $snapshotDelay : 0;
            if ($cacheLength === $waitAmount) {
                // max $limit is 100
                $subscription = $client->subscriptions[$messageHash];
                $limit = $this->safe_integer($subscription, 'limit');
                $this->spawn(array($this, 'load_order_book'), $client, $messageHash, $symbol, $limit);
            }
            $storedOrderBook->cache[] = $delta;
            return;
        } elseif ($nonce >= $deltaEnd) {
            return;
        } elseif ($nonce >= $deltaStart - 1) {
            $this->handle_delta($storedOrderBook, $delta);
        } else {
            $error = new InvalidNonce ($this->id . ' orderbook update has a $nonce bigger than u');
            unset($client->subscriptions[$messageHash]);
            unset($this->orderbooks[$symbol]);
            $client->reject ($error, $messageHash);
        }
        $client->resolve ($storedOrderBook, $messageHash);
    }

    public function get_cache_index($orderBook, $cache) {
        $nonce = $this->safe_integer($orderBook, 'nonce');
        $firstDelta = $cache[0];
        $firstDeltaStart = $this->safe_integer($firstDelta, 'U');
        if ($nonce < $firstDeltaStart) {
            return -1;
        }
        for ($i = 0; $i < count($cache); $i++) {
            $delta = $cache[$i];
            $deltaStart = $this->safe_integer($delta, 'U');
            $deltaEnd = $this->safe_integer($delta, 'u');
            if (($nonce >= $deltaStart - 1) && ($nonce < $deltaEnd)) {
                return $i;
            }
        }
        return count($cache);
    }

    public function handle_bid_asks($bookSide, $bidAsks) {
        for ($i = 0; $i < count($bidAsks); $i++) {
            $bidAsk = $bidAsks[$i];
            if (gettype($bidAsk) === 'array' && array_keys($bidAsk) === array_keys(array_keys($bidAsk))) {
                $bookSide->storeArray ($this->parse_bid_ask($bidAsk));
            } else {
                $price = $this->safe_float($bidAsk, 'p');
                $amount = $this->safe_float($bidAsk, 's');
                $bookSide->store ($price, $amount);
            }
        }
    }

    public function handle_delta($orderbook, $delta) {
        $timestamp = $this->safe_integer($delta, 't');
        $orderbook['timestamp'] = $timestamp;
        $orderbook['datetime'] = $this->iso8601($timestamp);
        $orderbook['nonce'] = $this->safe_integer($delta, 'u');
        $bids = $this->safe_value($delta, 'b', array());
        $asks = $this->safe_value($delta, 'a', array());
        $storedBids = $orderbook['bids'];
        $storedAsks = $orderbook['asks'];
        $this->handle_bid_asks($storedBids, $bids);
        $this->handle_bid_asks($storedAsks, $asks);
    }

    public function watch_ticker(string $symbol, $params = array ()) {
        return Async\async(function () use ($symbol, $params) {
            /**
             * watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific $market
             * @param {string} $symbol unified $symbol of the $market to fetch the ticker for
             * @param {array} $params extra parameters specific to the gate api endpoint
             * @return {array} a ~@link https://docs.ccxt.com/#/?id=ticker-structure ticker structure~
             */
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $symbol = $market['symbol'];
            $marketId = $market['id'];
            $url = $this->get_url_by_market($market);
            $messageType = $this->get_type_by_market($market);
            list($topic, $query) = $this->handle_option_and_params($params, 'watchTicker', 'method', 'tickers');
            $channel = $messageType . '.' . $topic;
            $messageHash = 'ticker:' . $symbol;
            $payload = array( $marketId );
            return Async\await($this->subscribe_public($url, $messageHash, $payload, $channel, $query));
        }) ();
    }

    public function watch_tickers(?array $symbols = null, $params = array ()) {
        return Async\async(function () use ($symbols, $params) {
            /**
             * watches a price $ticker, a statistical calculation with the information calculated over the past 24 hours for all markets of a specific list
             * @param {[string]} $symbols unified symbol of the $market to fetch the $ticker for
             * @param {array} $params extra parameters specific to the gate api endpoint
             * @return {array} a ~@link https://docs.ccxt.com/#/?id=$ticker-structure $ticker structure~
             */
            Async\await($this->load_markets());
            $symbols = $this->market_symbols($symbols);
            if ($symbols === null) {
                throw new ArgumentsRequired($this->id . ' watchTickers requires symbols');
            }
            $market = $this->market($symbols[0]);
            $messageType = $this->get_type_by_market($market);
            $marketIds = $this->market_ids($symbols);
            list($topic, $query) = $this->handle_option_and_params($params, 'watchTicker', 'method', 'tickers');
            $channel = $messageType . '.' . $topic;
            $messageHash = 'tickers';
            $url = $this->get_url_by_market($market);
            $ticker = Async\await($this->subscribe_public($url, $messageHash, $marketIds, $channel, $query));
            $result = array();
            if ($this->newUpdates) {
                $result[$ticker['symbol']] = $ticker;
            } else {
                $result = $this->tickers;
            }
            return $this->filter_by_array($result, 'symbol', $symbols, true);
        }) ();
    }

    public function handle_ticker(Client $client, $message) {
        //
        //    {
        //        time => 1649326221,
        //        $channel => 'spot.tickers',
        //        event => 'update',
        //        $result => {
        //          currency_pair => 'BTC_USDT',
        //          last => '43444.82',
        //          lowest_ask => '43444.82',
        //          highest_bid => '43444.81',
        //          change_percentage => '-4.0036',
        //          base_volume => '5182.5412425462',
        //          quote_volume => '227267634.93123952',
        //          high_24h => '47698',
        //          low_24h => '42721.03'
        //        }
        //    }
        //    {
        //        time => 1671363004,
        //        time_ms => 1671363004235,
        //        $channel => 'spot.book_ticker',
        //        event => 'update',
        //        $result => {
        //          t => 1671363004228,
        //          u => 9793320464,
        //          s => 'BTC_USDT',
        //          b => '16716.8',
        //          B => '0.0134',
        //          a => '16716.9',
        //          A => '0.0353'
        //        }
        //    }
        //
        $channel = $this->safe_string($message, 'channel');
        $parts = explode('.', $channel);
        $rawMarketType = $this->safe_string($parts, 0);
        $marketType = ($rawMarketType === 'futures') ? 'contract' : 'spot';
        $result = $this->safe_value($message, 'result');
        if (gettype($result) !== 'array' || array_keys($result) !== array_keys(array_keys($result))) {
            $result = array( $result );
        }
        for ($i = 0; $i < count($result); $i++) {
            $ticker = $result[$i];
            $marketId = $this->safe_string($ticker, 's');
            $market = $this->safe_market($marketId, null, '_', $marketType);
            $parsed = $this->parse_ticker($ticker, $market);
            $symbol = $parsed['symbol'];
            $this->tickers[$symbol] = $parsed;
            $messageHash = 'ticker:' . $symbol;
            $client->resolve ($parsed, $messageHash);
            $client->resolve ($parsed, 'tickers');
        }
    }

    public function watch_trades(string $symbol, ?int $since = null, ?int $limit = null, $params = array ()) {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            /**
             * get the list of most recent $trades for a particular $symbol
             * @param {string} $symbol unified $symbol of the $market to fetch $trades for
             * @param {int|null} $since timestamp in ms of the earliest trade to fetch
             * @param {int|null} $limit the maximum amount of $trades to fetch
             * @param {array} $params extra parameters specific to the gate api endpoint
             * @return {[array]} a list of ~@link https://docs.ccxt.com/en/latest/manual.html?#public-$trades trade structures~
             */
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $symbol = $market['symbol'];
            $marketId = $market['id'];
            $messageType = $this->get_type_by_market($market);
            $channel = $messageType . '.trades';
            $messageHash = 'trades:' . $symbol;
            $url = $this->get_url_by_market($market);
            $payload = array( $marketId );
            $trades = Async\await($this->subscribe_public($url, $messageHash, $payload, $channel, $params));
            if ($this->newUpdates) {
                $limit = $trades->getLimit ($symbol, $limit);
            }
            return $this->filter_by_since_limit($trades, $since, $limit, 'timestamp');
        }) ();
    }

    public function handle_trades(Client $client, $message) {
        //
        // {
        //     time => 1648725035,
        //     channel => 'spot.trades',
        //     event => 'update',
        //     $result => [array(
        //       id => 3130257995,
        //       create_time => 1648725035,
        //       create_time_ms => '1648725035923.0',
        //       side => 'sell',
        //       currency_pair => 'LTC_USDT',
        //       amount => '0.0116',
        //       price => '130.11'
        //     )]
        // }
        //
        $result = $this->safe_value($message, 'result');
        if (gettype($result) !== 'array' || array_keys($result) !== array_keys(array_keys($result))) {
            $result = array( $result );
        }
        $parsedTrades = $this->parse_trades($result);
        for ($i = 0; $i < count($parsedTrades); $i++) {
            $trade = $parsedTrades[$i];
            $symbol = $trade['symbol'];
            $cachedTrades = $this->safe_value($this->trades, $symbol);
            if ($cachedTrades === null) {
                $limit = $this->safe_integer($this->options, 'tradesLimit', 1000);
                $cachedTrades = new ArrayCache ($limit);
                $this->trades[$symbol] = $cachedTrades;
            }
            $cachedTrades->append ($trade);
            $hash = 'trades:' . $symbol;
            $client->resolve ($cachedTrades, $hash);
        }
    }

    public function watch_ohlcv(string $symbol, $timeframe = '1m', ?int $since = null, ?int $limit = null, $params = array ()) {
        return Async\async(function () use ($symbol, $timeframe, $since, $limit, $params) {
            /**
             * watches historical candlestick data containing the open, high, low, and close price, and the volume of a $market
             * @param {string} $symbol unified $symbol of the $market to fetch OHLCV data for
             * @param {string} $timeframe the length of time each candle represents
             * @param {int|null} $since timestamp in ms of the earliest candle to fetch
             * @param {int|null} $limit the maximum amount of candles to fetch
             * @param {array} $params extra parameters specific to the gate api endpoint
             * @return {[[int]]} A list of candles ordered, open, high, low, close, volume
             */
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $symbol = $market['symbol'];
            $marketId = $market['id'];
            $interval = $this->safe_string($this->timeframes, $timeframe, $timeframe);
            $messageType = $this->get_type_by_market($market);
            $channel = $messageType . '.candlesticks';
            $messageHash = 'candles:' . $interval . ':' . $market['symbol'];
            $url = $this->get_url_by_market($market);
            $payload = array( $interval, $marketId );
            $ohlcv = Async\await($this->subscribe_public($url, $messageHash, $payload, $channel, $params));
            if ($this->newUpdates) {
                $limit = $ohlcv->getLimit ($symbol, $limit);
            }
            return $this->filter_by_since_limit($ohlcv, $since, $limit, 0);
        }) ();
    }

    public function handle_ohlcv(Client $client, $message) {
        //
        // {
        //     "time" => 1606292600,
        //     "channel" => "spot.candlesticks",
        //     "event" => "update",
        //     "result" => {
        //       "t" => "1606292580", // total volume
        //       "v" => "2362.32035", // volume
        //       "c" => "19128.1", // close
        //       "h" => "19128.1", // high
        //       "l" => "19128.1", // low
        //       "o" => "19128.1", // open
        //       "n" => "1m_BTC_USDT" // sub
        //     }
        //   }
        //
        $channel = $this->safe_string($message, 'channel');
        $channelParts = explode('.', $channel);
        $rawMarketType = $this->safe_string($channelParts, 0);
        $marketType = ($rawMarketType === 'spot') ? 'spot' : 'contract';
        $result = $this->safe_value($message, 'result');
        if (gettype($result) !== 'array' || array_keys($result) !== array_keys(array_keys($result))) {
            $result = array( $result );
        }
        $marketIds = array();
        for ($i = 0; $i < count($result); $i++) {
            $ohlcv = $result[$i];
            $subscription = $this->safe_string($ohlcv, 'n', '');
            $parts = explode('_', $subscription);
            $timeframe = $this->safe_string($parts, 0);
            $prefix = $timeframe . '_';
            $marketId = str_replace($prefix, '', $subscription);
            $symbol = $this->safe_symbol($marketId, null, '_', $marketType);
            $parsed = $this->parse_ohlcv($ohlcv);
            $stored = $this->safe_value($this->ohlcvs, $symbol);
            if ($stored === null) {
                $limit = $this->safe_integer($this->options, 'OHLCVLimit', 1000);
                $stored = new ArrayCacheByTimestamp ($limit);
                $this->ohlcvs[$symbol] = $stored;
            }
            $stored->append ($parsed);
            $marketIds[$symbol] = $timeframe;
        }
        $keys = is_array($marketIds) ? array_keys($marketIds) : array();
        for ($i = 0; $i < count($keys); $i++) {
            $symbol = $keys[$i];
            $timeframe = $marketIds[$symbol];
            $interval = $this->find_timeframe($timeframe);
            $hash = 'candles' . ':' . $interval . ':' . $symbol;
            $stored = $this->safe_value($this->ohlcvs, $symbol);
            $client->resolve ($stored, $hash);
        }
    }

    public function watch_my_trades(?string $symbol = null, ?int $since = null, ?int $limit = null, $params = array ()) {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            /**
             * watches information on multiple $trades made by the user
             * @param {string} $symbol unified $market $symbol of the $market orders were made in
             * @param {int|null} $since the earliest time in ms to fetch orders for
             * @param {int|null} $limit the maximum number of  orde structures to retrieve
             * @param {array} $params extra parameters specific to the gate api endpoint
             * @return {[array]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure
             */
            Async\await($this->load_markets());
            $subType = null;
            $type = null;
            $marketId = '!' . 'all';
            $market = null;
            if ($symbol !== null) {
                $market = $this->market($symbol);
                $marketId = $market['id'];
            }
            list($type, $params) = $this->handle_market_type_and_params('watchMyTrades', $market, $params);
            list($subType, $params) = $this->handle_sub_type_and_params('watchMyTrades', $market, $params);
            $messageType = $this->get_supported_mapping($type, array(
                'spot' => 'spot',
                'margin' => 'spot',
                'future' => 'futures',
                'swap' => 'futures',
                'option' => 'options',
            ));
            $channel = $messageType . '.usertrades';
            $messageHash = 'myTrades';
            if ($symbol !== null) {
                $messageHash .= ':' . $symbol;
            }
            $isInverse = ($subType === 'inverse');
            $url = $this->get_url_by_market_type($type, $isInverse);
            $payload = array( $marketId );
            // uid required for non spot markets
            $requiresUid = ($type !== 'spot');
            $trades = Async\await($this->subscribe_private($url, $messageHash, $payload, $channel, $params, $requiresUid));
            if ($this->newUpdates) {
                $limit = $trades->getLimit ($symbol, $limit);
            }
            return $this->filter_by_symbol_since_limit($trades, $symbol, $since, $limit);
        }) ();
    }

    public function handle_my_trades(Client $client, $message) {
        //
        // {
        //     "time" => 1543205083,
        //     "channel" => "futures.usertrades",
        //     "event" => "update",
        //     "error" => null,
        //     "result" => array(
        //       {
        //         "id" => "3335259",
        //         "create_time" => 1628736848,
        //         "create_time_ms" => 1628736848321,
        //         "contract" => "BTC_USD",
        //         "order_id" => "4872460",
        //         "size" => 1,
        //         "price" => "40000.4",
        //         "role" => "maker"
        //       }
        //     )
        // }
        //
        $result = $this->safe_value($message, 'result', array());
        $tradesLength = count($result);
        if ($tradesLength === 0) {
            return;
        }
        $cachedTrades = $this->myTrades;
        if ($cachedTrades === null) {
            $limit = $this->safe_integer($this->options, 'tradesLimit', 1000);
            $cachedTrades = new ArrayCacheBySymbolById ($limit);
            $this->myTrades = $cachedTrades;
        }
        $parsed = $this->parse_trades($result);
        $marketIds = array();
        for ($i = 0; $i < count($parsed); $i++) {
            $trade = $parsed[$i];
            $cachedTrades->append ($trade);
            $symbol = $trade['symbol'];
            $marketIds[$symbol] = true;
        }
        $keys = is_array($marketIds) ? array_keys($marketIds) : array();
        for ($i = 0; $i < count($keys); $i++) {
            $market = $keys[$i];
            $hash = 'myTrades:' . $market;
            $client->resolve ($cachedTrades, $hash);
        }
        $client->resolve ($cachedTrades, 'myTrades');
    }

    public function watch_balance($params = array ()) {
        return Async\async(function () use ($params) {
            /**
             * query for balance and get the amount of funds available for trading or funds locked in orders
             * @param {array} $params extra parameters specific to the gate api endpoint
             * @return {array} a ~@link https://docs.ccxt.com/en/latest/manual.html?#balance-structure balance structure~
             */
            Async\await($this->load_markets());
            $type = null;
            $subType = null;
            list($type, $params) = $this->handle_market_type_and_params('watchBalance', null, $params);
            list($subType, $params) = $this->handle_sub_type_and_params('watchBalance', null, $params);
            $isInverse = ($subType === 'inverse');
            $url = $this->get_url_by_market_type($type, $isInverse);
            $requiresUid = ($type !== 'spot');
            $channelType = $this->get_supported_mapping($type, array(
                'spot' => 'spot',
                'margin' => 'spot',
                'future' => 'futures',
                'swap' => 'futures',
                'option' => 'options',
            ));
            $channel = $channelType . '.balances';
            $messageHash = $type . '.balance';
            return Async\await($this->subscribe_private($url, $messageHash, null, $channel, $params, $requiresUid));
        }) ();
    }

    public function handle_balance(Client $client, $message) {
        //
        // spot order fill
        //   {
        //       time => 1653664351,
        //       $channel => 'spot.balances',
        //       event => 'update',
        //       $result => array(
        //         {
        //           $timestamp => '1653664351',
        //           timestamp_ms => '1653664351017',
        //           user => '10406147',
        //           currency => 'LTC',
        //           change => '-0.0002000000000000',
        //           total => '0.09986000000000000000',
        //           available => '0.09986000000000000000'
        //         }
        //       )
        //   }
        //
        // $account transfer
        //
        //    {
        //        id => null,
        //        time => 1653665088,
        //        $channel => 'futures.balances',
        //        event => 'update',
        //        error => null,
        //        $result => array(
        //          {
        //            balance => 25.035008537,
        //            change => 25,
        //            text => '-',
        //            time => 1653665088,
        //            time_ms => 1653665088286,
        //            type => 'dnw',
        //            user => '10406147'
        //          }
        //        )
        //   }
        //
        // swap order fill
        //   {
        //       id => null,
        //       time => 1653665311,
        //       $channel => 'futures.balances',
        //       event => 'update',
        //       error => null,
        //       $result => array(
        //         {
        //           balance => 20.031873037,
        //           change => -0.0031355,
        //           text => 'LTC_USDT:165551103273',
        //           time => 1653665311,
        //           time_ms => 1653665311437,
        //           type => 'fee',
        //           user => '10406147'
        //         }
        //       )
        //   }
        //
        $result = $this->safe_value($message, 'result', array());
        $timestamp = $this->safe_integer($message, 'time');
        $this->balance['info'] = $result;
        $this->balance['timestamp'] = $timestamp;
        $this->balance['datetime'] = $this->iso8601($timestamp);
        for ($i = 0; $i < count($result); $i++) {
            $rawBalance = $result[$i];
            $account = $this->account();
            $currencyId = $this->safe_string($rawBalance, 'currency', 'USDT'); // when not present it is USDT
            $code = $this->safe_currency_code($currencyId);
            $account['free'] = $this->safe_string($rawBalance, 'available');
            $account['total'] = $this->safe_string_2($rawBalance, 'total', 'balance');
            $this->balance[$code] = $account;
        }
        $channel = $this->safe_string($message, 'channel');
        $parts = explode('.', $channel);
        $rawType = $this->safe_string($parts, 0);
        $channelType = $this->get_supported_mapping($rawType, array(
            'spot' => 'spot',
            'futures' => 'swap',
            'options' => 'option',
        ));
        $messageHash = $channelType . '.balance';
        $this->balance = $this->safe_balance($this->balance);
        $client->resolve ($this->balance, $messageHash);
    }

    public function watch_orders(?string $symbol = null, ?int $since = null, ?int $limit = null, $params = array ()) {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            /**
             * watches information on multiple $orders made by the user
             * @param {string|null} $symbol unified $market $symbol of the $market $orders were made in
             * @param {int|null} $since the earliest time in ms to fetch $orders for
             * @param {int|null} $limit the maximum number of  orde structures to retrieve
             * @param {array} $params extra parameters specific to the gate api endpoint
             * @param {string} $params->type spot, margin, swap, future, or option. Required if listening to all symbols.
             * @param {boolean} $params->isInverse if future, listen to inverse or linear contracts
             * @return {[array]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure
             */
            Async\await($this->load_markets());
            $market = null;
            if ($symbol !== null) {
                $market = $this->market($symbol);
                $symbol = $market['symbol'];
            }
            $type = null;
            $query = null;
            list($type, $query) = $this->handle_market_type_and_params('watchOrders', $market, $params);
            $typeId = $this->get_supported_mapping($type, array(
                'spot' => 'spot',
                'margin' => 'spot',
                'future' => 'futures',
                'swap' => 'futures',
                'option' => 'options',
            ));
            $channel = $typeId . '.orders';
            $messageHash = 'orders';
            $payload = array( '!' . 'all' );
            if ($symbol !== null) {
                $messageHash .= ':' . $market['id'];
                $payload = [ $market['id'] ];
            }
            $subType = null;
            list($subType, $query) = $this->handle_sub_type_and_params('watchOrders', $market, $query);
            $isInverse = ($subType === 'inverse');
            $url = $this->get_url_by_market_type($type, $isInverse);
            // uid required for non spot markets
            $requiresUid = ($type !== 'spot');
            $orders = Async\await($this->subscribe_private($url, $messageHash, $payload, $channel, $query, $requiresUid));
            if ($this->newUpdates) {
                $limit = $orders->getLimit ($symbol, $limit);
            }
            return $this->filter_by_since_limit($orders, $since, $limit, 'timestamp');
        }) ();
    }

    public function handle_order(Client $client, $message) {
        //
        // {
        //     "time" => 1605175506,
        //     "channel" => "spot.orders",
        //     "event" => "update",
        //     "result" => array(
        //       {
        //         "id" => "30784435",
        //         "user" => 123456,
        //         "text" => "t-abc",
        //         "create_time" => "1605175506",
        //         "create_time_ms" => "1605175506123",
        //         "update_time" => "1605175506",
        //         "update_time_ms" => "1605175506123",
        //         "event" => "put",
        //         "currency_pair" => "BTC_USDT",
        //         "type" => "limit",
        //         "account" => "spot",
        //         "side" => "sell",
        //         "amount" => "1",
        //         "price" => "10001",
        //         "time_in_force" => "gtc",
        //         "left" => "1",
        //         "filled_total" => "0",
        //         "fee" => "0",
        //         "fee_currency" => "USDT",
        //         "point_fee" => "0",
        //         "gt_fee" => "0",
        //         "gt_discount" => true,
        //         "rebated_fee" => "0",
        //         "rebated_fee_currency" => "USDT"
        //       }
        //     )
        // }
        //
        $orders = $this->safe_value($message, 'result', array());
        $limit = $this->safe_integer($this->options, 'ordersLimit', 1000);
        if ($this->orders === null) {
            $this->orders = new ArrayCacheBySymbolById ($limit);
        }
        $stored = $this->orders;
        $marketIds = array();
        $parsedOrders = $this->parse_orders($orders);
        for ($i = 0; $i < count($parsedOrders); $i++) {
            $parsed = $parsedOrders[$i];
            // inject order status
            $info = $this->safe_value($parsed, 'info');
            $event = $this->safe_string($info, 'event');
            if ($event === 'put' || $event === ' update') {
                $parsed['status'] = 'open';
            } elseif ($event === 'finish') {
                $left = $this->safe_number($info, 'left');
                $parsed['status'] = ($left === 0) ? 'closed' : 'canceled';
            }
            $stored->append ($parsed);
            $symbol = $parsed['symbol'];
            $market = $this->market($symbol);
            $marketIds[$market['id']] = true;
        }
        $keys = is_array($marketIds) ? array_keys($marketIds) : array();
        for ($i = 0; $i < count($keys); $i++) {
            $messageHash = 'orders:' . $keys[$i];
            $client->resolve ($this->orders, $messageHash);
        }
        $client->resolve ($this->orders, 'orders');
    }

    public function handle_error_message(Client $client, $message) {
        // {
        //     time => 1647274664,
        //     channel => 'futures.orders',
        //     event => 'subscribe',
        //     $error => array( $code => 2, $message => 'unknown contract BTC_USDT_20220318' ),
        // }
        // {
        //     time => 1647276473,
        //     channel => 'futures.orders',
        //     event => 'subscribe',
        //     $error => array(
        //       $code => 4,
        //       $message => 'array("label":"INVALID_KEY","message":"Invalid key provided")\n'
        //     ),
        //     result => null
        //   }
        $error = $this->safe_value($message, 'error');
        $code = $this->safe_integer($error, 'code');
        $id = $this->safe_string($message, 'id');
        if ($id === null) {
            return false;
        }
        if ($code !== null) {
            $messageHash = $this->safe_string($client->subscriptions, $id);
            if ($messageHash !== null) {
                try {
                    $this->throw_exactly_matched_exception($this->exceptions['ws']['exact'], $code, $this->json($message));
                } catch (Exception $e) {
                    $client->reject ($e, $messageHash);
                    if (is_array($client->subscriptions) && array_key_exists($messageHash, $client->subscriptions)) {
                        unset($client->subscriptions[$messageHash]);
                    }
                }
            }
            unset($client->subscriptions[$id]);
            return true;
        }
        return false;
    }

    public function handle_balance_subscription(Client $client, $message, $subscription = null) {
        $this->balance = array();
    }

    public function handle_subscription_status(Client $client, $message) {
        $channel = $this->safe_string($message, 'channel');
        $methods = array(
            'balance' => array($this, 'handle_balance_subscription'),
            'spot.order_book_update' => array($this, 'handle_order_book_subscription'),
            'futures.order_book_update' => array($this, 'handle_order_book_subscription'),
        );
        $id = $this->safe_string($message, 'id');
        if (is_array($methods) && array_key_exists($channel, $methods)) {
            $subscriptionHash = $this->safe_string($client->subscriptions, $id);
            $subscription = $this->safe_value($client->subscriptions, $subscriptionHash);
            $method = $methods[$channel];
            $method($client, $message, $subscription);
        }
        if (is_array($client->subscriptions) && array_key_exists($id, $client->subscriptions)) {
            unset($client->subscriptions[$id]);
        }
    }

    public function handle_message(Client $client, $message) {
        //
        // subscribe
        //    {
        //        time => 1649062304,
        //        id => 1649062303,
        //        $channel => 'spot.candlesticks',
        //        $event => 'subscribe',
        //        result => array( status => 'success' )
        //    }
        //
        // candlestick
        //    {
        //        time => 1649063328,
        //        $channel => 'spot.candlesticks',
        //        $event => 'update',
        //        result => {
        //          t => '1649063280',
        //          v => '58932.23174896',
        //          c => '45966.47',
        //          h => '45997.24',
        //          l => '45966.47',
        //          o => '45975.18',
        //          n => '1m_BTC_USDT',
        //          a => '1.281699'
        //        }
        //     }
        //
        //  orders
        //   {
        //       "time" => 1630654851,
        //       "channel" => "options.orders", or futures.orders or spot.orders
        //       "event" => "update",
        //       "result" => array(
        //          {
        //             "contract" => "BTC_USDT-20211130-65000-C",
        //             "create_time" => 1637897000,
        //               (...)
        //       )
        //   }
        // orderbook
        //   {
        //       time => 1649770525,
        //       $channel => 'spot.order_book_update',
        //       $event => 'update',
        //       result => {
        //         t => 1649770525653,
        //         e => 'depthUpdate',
        //         E => 1649770525,
        //         s => 'LTC_USDT',
        //         U => 2622525645,
        //         u => 2622525665,
        //         b => [
        //           [Array], [Array],
        //           [Array], [Array],
        //           [Array], [Array],
        //           [Array], [Array],
        //           [Array], [Array],
        //           [Array]
        //         ],
        //         a => [
        //           [Array], [Array],
        //           [Array], [Array],
        //           [Array], [Array],
        //           [Array], [Array],
        //           [Array], [Array],
        //           [Array]
        //         ]
        //       }
        //     }
        //
        // balance update
        //
        //    {
        //        time => 1653664351,
        //        $channel => 'spot.balances',
        //        $event => 'update',
        //        result => array(
        //          {
        //            timestamp => '1653664351',
        //            timestamp_ms => '1653664351017',
        //            user => '10406147',
        //            currency => 'LTC',
        //            change => '-0.0002000000000000',
        //            total => '0.09986000000000000000',
        //            available => '0.09986000000000000000'
        //          }
        //        )
        //    }
        //
        if ($this->handle_error_message($client, $message)) {
            return;
        }
        $event = $this->safe_string($message, 'event');
        if ($event === 'subscribe') {
            $this->handle_subscription_status($client, $message);
            return;
        }
        $channel = $this->safe_string($message, 'channel', '');
        $channelParts = explode('.', $channel);
        $channelType = $this->safe_value($channelParts, 1);
        $v4Methods = array(
            'usertrades' => array($this, 'handle_my_trades'),
            'candlesticks' => array($this, 'handle_ohlcv'),
            'orders' => array($this, 'handle_order'),
            'tickers' => array($this, 'handle_ticker'),
            'book_ticker' => array($this, 'handle_ticker'),
            'trades' => array($this, 'handle_trades'),
            'order_book_update' => array($this, 'handle_order_book'),
            'balances' => array($this, 'handle_balance'),
        );
        $method = $this->safe_value($v4Methods, $channelType);
        if ($method !== null) {
            $method($client, $message);
        }
    }

    public function get_url_by_market($market) {
        $baseUrl = $this->urls['api'][$market['type']];
        if ($market['contract']) {
            return $market['linear'] ? $baseUrl['usdt'] : $baseUrl['btc'];
        } else {
            return $baseUrl;
        }
    }

    public function get_type_by_market($market) {
        if ($market['spot']) {
            return 'spot';
        } elseif ($market['option']) {
            return 'options';
        } else {
            return 'futures';
        }
    }

    public function get_url_by_market_type($type, $isInverse = false) {
        $api = $this->urls['api'];
        $url = $api[$type];
        if (($type === 'swap') || ($type === 'future')) {
            return $isInverse ? $url['btc'] : $url['usdt'];
        } else {
            return $url;
        }
    }

    public function request_id() {
        // their support said that $reqid must be an int32, not documented
        $reqid = $this->sum($this->safe_integer($this->options, 'reqid', 0), 1);
        $this->options['reqid'] = $reqid;
        return $reqid;
    }

    public function subscribe_public($url, $messageHash, $payload, $channel, $params = array (), $subscription = null) {
        return Async\async(function () use ($url, $messageHash, $payload, $channel, $params, $subscription) {
            $requestId = $this->request_id();
            $time = $this->seconds();
            $request = array(
                'id' => $requestId,
                'time' => $time,
                'channel' => $channel,
                'event' => 'subscribe',
                'payload' => $payload,
            );
            if ($subscription !== null) {
                $client = $this->client($url);
                if (!(is_array($client->subscriptions) && array_key_exists($messageHash, $client->subscriptions))) {
                    $tempSubscriptionHash = (string) $requestId;
                    $client->subscriptions[$tempSubscriptionHash] = $messageHash;
                }
            }
            $message = array_merge($request, $params);
            return Async\await($this->watch($url, $messageHash, $message, $messageHash, $subscription));
        }) ();
    }

    public function subscribe_private($url, $messageHash, $payload, $channel, $params, $requiresUid = false) {
        return Async\async(function () use ($url, $messageHash, $payload, $channel, $params, $requiresUid) {
            $this->check_required_credentials();
            // uid is required for some subscriptions only so it's not a part of required credentials
            if ($requiresUid) {
                if ($this->uid === null || strlen($this->uid) === 0) {
                    throw new ArgumentsRequired($this->id . ' requires uid to subscribe');
                }
                $idArray = array( $this->uid );
                if ($payload === null) {
                    $payload = $idArray;
                } else {
                    $payload = $this->array_concat($idArray, $payload);
                }
            }
            $time = $this->seconds();
            $event = 'subscribe';
            $signaturePayload = 'channel=' . $channel . '&' . 'event=' . $event . '&' . 'time=' . (string) $time;
            $signature = $this->hmac($this->encode($signaturePayload), $this->encode($this->secret), 'sha512', 'hex');
            $auth = array(
                'method' => 'api_key',
                'KEY' => $this->apiKey,
                'SIGN' => $signature,
            );
            $requestId = $this->request_id();
            $request = array(
                'id' => $requestId,
                'time' => $time,
                'channel' => $channel,
                'event' => 'subscribe',
                'auth' => $auth,
            );
            if ($payload !== null) {
                $request['payload'] = $payload;
            }
            $client = $this->client($url);
            if (!(is_array($client->subscriptions) && array_key_exists($messageHash, $client->subscriptions))) {
                $tempSubscriptionHash = (string) $requestId;
                // in case of authenticationError we will throw
                $client->subscriptions[$tempSubscriptionHash] = $messageHash;
            }
            $message = array_merge($request, $params);
            return Async\await($this->watch($url, $messageHash, $message, $messageHash));
        }) ();
    }
}
