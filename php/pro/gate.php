<?php

namespace ccxt\pro;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

use Exception; // a common import
use ccxt\ArgumentsRequired;
use ccxt\InvalidNonce;
use React\Async;
use React\Promise\PromiseInterface;

class gate extends \ccxt\async\gate {

    public function describe() {
        return $this->deep_extend(parent::describe(), array(
            'has' => array(
                'ws' => true,
                'watchOrderBook' => true,
                'watchTicker' => true,
                'watchTickers' => true, // for now
                'watchTrades' => true,
                'watchTradesForSymbols' => true,
                'watchMyTrades' => true,
                'watchOHLCV' => true,
                'watchBalance' => true,
                'watchOrders' => true,
                'watchPositions' => true,
            ),
            'urls' => array(
                'api' => array(
                    'ws' => 'wss://ws.gate.io/v4',
                    'spot' => 'wss://api.gateio.ws/ws/v4/',
                    'swap' => array(
                        'usdt' => 'wss://fx-ws.gateio.ws/v4/ws/usdt',
                        'btc' => 'wss://fx-ws.gateio.ws/v4/ws/btc',
                    ),
                    'future' => array(
                        'usdt' => 'wss://fx-ws.gateio.ws/v4/ws/delivery/usdt',
                        'btc' => 'wss://fx-ws.gateio.ws/v4/ws/delivery/btc',
                    ),
                    'option' => array(
                        'usdt' => 'wss://op-ws.gateio.live/v4/ws/usdt',
                        'btc' => 'wss://op-ws.gateio.live/v4/ws/btc',
                    ),
                ),
                'test' => array(
                    'swap' => array(
                        'usdt' => 'wss://fx-ws-testnet.gateio.ws/v4/ws/usdt',
                        'btc' => 'wss://fx-ws-testnet.gateio.ws/v4/ws/btc',
                    ),
                    'future' => array(
                        'usdt' => 'wss://fx-ws-testnet.gateio.ws/v4/ws/usdt',
                        'btc' => 'wss://fx-ws-testnet.gateio.ws/v4/ws/btc',
                    ),
                    'option' => array(
                        'usdt' => 'wss://op-ws-testnet.gateio.live/v4/ws/usdt',
                        'btc' => 'wss://op-ws-testnet.gateio.live/v4/ws/btc',
                    ),
                ),
            ),
            'options' => array(
                'tradesLimit' => 1000,
                'OHLCVLimit' => 1000,
                'watchTradesSubscriptions' => array(),
                'watchTickerSubscriptions' => array(),
                'watchOrderBookSubscriptions' => array(),
                'watchTicker' => array(
                    'name' => 'tickers', // or book_ticker
                ),
                'watchOrderBook' => array(
                    'interval' => '100ms',
                    'snapshotDelay' => 10, // how many deltas to cache before fetching a snapshot
                    'snapshotMaxRetries' => 3,
                ),
                'watchBalance' => array(
                    'settle' => 'usdt', // or btc
                    'spot' => 'spot.balances', // spot.margin_balances, spot.funding_balances or spot.cross_balances
                ),
                'watchPositions' => array(
                    'fetchPositionsSnapshot' => true, // or false
                    'awaitPositionsSnapshot' => true, // whether to wait for the positions snapshot before providing updates
                ),
            ),
            'exceptions' => array(
                'ws' => array(
                    'exact' => array(
                        '2' => '\\ccxt\\BadRequest',
                        '4' => '\\ccxt\\AuthenticationError',
                        '6' => '\\ccxt\\AuthenticationError',
                        '11' => '\\ccxt\\AuthenticationError',
                    ),
                ),
            ),
        ));
    }

    public function watch_order_book(string $symbol, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $limit, $params) {
            /**
             * watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
             * @param {string} $symbol unified $symbol of the $market to fetch the order book for
             * @param {int} [$limit] the maximum amount of order book entries to return
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} A dictionary of ~@link https://docs.ccxt.com/#/?id=order-book-structure order book structures~ indexed by $market symbols
             */
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $symbol = $market['symbol'];
            $marketId = $market['id'];
            list($interval, $query) = $this->handle_option_and_params($params, 'watchOrderBook', 'interval', '100ms');
            $messageType = $this->get_type_by_market($market);
            $channel = $messageType . '.order_book_update';
            $messageHash = 'orderbook' . ':' . $symbol;
            $url = $this->get_url_by_market($market);
            $payload = array( $marketId, $interval );
            if ($limit === null) {
                $limit = 100;
            }
            if ($market['contract']) {
                $stringLimit = (string) $limit;
                $payload[] = $stringLimit;
            }
            $subscription = array(
                'symbol' => $symbol,
                'limit' => $limit,
            );
            $orderbook = Async\await($this->subscribe_public($url, $messageHash, $payload, $channel, $query, $subscription));
            return $orderbook->limit ();
        }) ();
    }

    public function handle_order_book_subscription(Client $client, $message, $subscription) {
        $symbol = $this->safe_string($subscription, 'symbol');
        $limit = $this->safe_integer($subscription, 'limit');
        $this->orderbooks[$symbol] = $this->order_book(array(), $limit);
    }

    public function handle_order_book(Client $client, $message) {
        //
        // spot
        //
        //     {
        //         "time" => 1650189272,
        //         "channel" => "spot.order_book_update",
        //         "event" => "update",
        //         "result" => {
        //             "t" => 1650189272515,
        //             "e" => "depthUpdate",
        //             "E" => 1650189272,
        //             "s" => "GMT_USDT",
        //             "U" => 140595902,
        //             "u" => 140595902,
        //             "b" => array(
        //                 array( '2.51518', "228.119" ),
        //                 array( '2.50587', "1510.11" ),
        //                 array( '2.49944', "67.6" ),
        //             ),
        //             "a" => array(
        //                 array( '2.5182', "4.199" ),
        //                 array( "2.51926", "1874" ),
        //                 array( '2.53528', "96.529" ),
        //             )
        //         }
        //     }
        //
        // swap
        //
        //     {
        //         "id" => null,
        //         "time" => 1650188898,
        //         "channel" => "futures.order_book_update",
        //         "event" => "update",
        //         "error" => null,
        //         "result" => {
        //             "t" => 1650188898938,
        //             "s" => "GMT_USDT",
        //             "U" => 1577718307,
        //             "u" => 1577719254,
        //             "b" => array(
        //                 array( p => "2.5178", s => 0 ),
        //                 array( p => "2.5179", s => 0 ),
        //                 array( p => "2.518", s => 0 ),
        //             ),
        //             "a" => array(
        //                 array( p => "2.52", s => 0 ),
        //                 array( p => "2.5201", s => 0 ),
        //                 array( p => "2.5203", s => 0 ),
        //             )
        //         }
        //     }
        //
        $channel = $this->safe_string($message, 'channel');
        $channelParts = explode('.', $channel);
        $rawMarketType = $this->safe_string($channelParts, 0);
        $isSpot = $rawMarketType === 'spot';
        $marketType = $isSpot ? 'spot' : 'contract';
        $delta = $this->safe_value($message, 'result');
        $deltaStart = $this->safe_integer($delta, 'U');
        $deltaEnd = $this->safe_integer($delta, 'u');
        $marketId = $this->safe_string($delta, 's');
        $symbol = $this->safe_symbol($marketId, null, '_', $marketType);
        $messageHash = 'orderbook:' . $symbol;
        $storedOrderBook = $this->safe_value($this->orderbooks, $symbol, $this->order_book(array()));
        $nonce = $this->safe_integer($storedOrderBook, 'nonce');
        if ($nonce === null) {
            $cacheLength = 0;
            if ($storedOrderBook !== null) {
                $cacheLength = count($storedOrderBook->cache);
            }
            $snapshotDelay = $this->handle_option('watchOrderBook', 'snapshotDelay', 10);
            $waitAmount = $isSpot ? $snapshotDelay : 0;
            if ($cacheLength === $waitAmount) {
                // max $limit is 100
                $subscription = $client->subscriptions[$messageHash];
                $limit = $this->safe_integer($subscription, 'limit');
                $this->spawn(array($this, 'load_order_book'), $client, $messageHash, $symbol, $limit);
            }
            $storedOrderBook->cache[] = $delta;
            return;
        } elseif ($nonce >= $deltaEnd) {
            return;
        } elseif ($nonce >= $deltaStart - 1) {
            $this->handle_delta($storedOrderBook, $delta);
        } else {
            $error = new InvalidNonce ($this->id . ' orderbook update has a $nonce bigger than u');
            unset($client->subscriptions[$messageHash]);
            unset($this->orderbooks[$symbol]);
            $client->reject ($error, $messageHash);
        }
        $client->resolve ($storedOrderBook, $messageHash);
    }

    public function get_cache_index($orderBook, $cache) {
        $nonce = $this->safe_integer($orderBook, 'nonce');
        $firstDelta = $cache[0];
        $firstDeltaStart = $this->safe_integer($firstDelta, 'U');
        if ($nonce < $firstDeltaStart) {
            return -1;
        }
        for ($i = 0; $i < count($cache); $i++) {
            $delta = $cache[$i];
            $deltaStart = $this->safe_integer($delta, 'U');
            $deltaEnd = $this->safe_integer($delta, 'u');
            if (($nonce >= $deltaStart - 1) && ($nonce < $deltaEnd)) {
                return $i;
            }
        }
        return count($cache);
    }

    public function handle_bid_asks($bookSide, $bidAsks) {
        for ($i = 0; $i < count($bidAsks); $i++) {
            $bidAsk = $bidAsks[$i];
            if (gettype($bidAsk) === 'array' && array_keys($bidAsk) === array_keys(array_keys($bidAsk))) {
                $bookSide->storeArray ($this->parse_bid_ask($bidAsk));
            } else {
                $price = $this->safe_float($bidAsk, 'p');
                $amount = $this->safe_float($bidAsk, 's');
                $bookSide->store ($price, $amount);
            }
        }
    }

    public function handle_delta($orderbook, $delta) {
        $timestamp = $this->safe_integer($delta, 't');
        $orderbook['timestamp'] = $timestamp;
        $orderbook['datetime'] = $this->iso8601($timestamp);
        $orderbook['nonce'] = $this->safe_integer($delta, 'u');
        $bids = $this->safe_value($delta, 'b', array());
        $asks = $this->safe_value($delta, 'a', array());
        $storedBids = $orderbook['bids'];
        $storedAsks = $orderbook['asks'];
        $this->handle_bid_asks($storedBids, $bids);
        $this->handle_bid_asks($storedAsks, $asks);
    }

    public function watch_ticker(string $symbol, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $params) {
            /**
             * watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific $market
             * @param {string} $symbol unified $symbol of the $market to fetch the ticker for
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} a ~@link https://docs.ccxt.com/#/?id=ticker-structure ticker structure~
             */
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $symbol = $market['symbol'];
            $marketId = $market['id'];
            $url = $this->get_url_by_market($market);
            $messageType = $this->get_type_by_market($market);
            list($topic, $query) = $this->handle_option_and_params($params, 'watchTicker', 'name', 'tickers');
            $channel = $messageType . '.' . $topic;
            $messageHash = 'ticker:' . $symbol;
            $payload = array( $marketId );
            return Async\await($this->subscribe_public($url, $messageHash, $payload, $channel, $query));
        }) ();
    }

    public function watch_tickers(?array $symbols = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbols, $params) {
            /**
             * watches a price $ticker, a statistical calculation with the information calculated over the past 24 hours for all markets of a specific list
             * @param {string[]} $symbols unified symbol of the $market to fetch the $ticker for
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} a ~@link https://docs.ccxt.com/#/?id=$ticker-structure $ticker structure~
             */
            Async\await($this->load_markets());
            $symbols = $this->market_symbols($symbols);
            if ($symbols === null) {
                throw new ArgumentsRequired($this->id . ' watchTickers requires symbols');
            }
            $market = $this->market($symbols[0]);
            $messageType = $this->get_type_by_market($market);
            $marketIds = $this->market_ids($symbols);
            list($topic, $query) = $this->handle_option_and_params($params, 'watchTicker', 'method', 'tickers');
            $channel = $messageType . '.' . $topic;
            $messageHash = 'tickers';
            $url = $this->get_url_by_market($market);
            $ticker = Async\await($this->subscribe_public($url, $messageHash, $marketIds, $channel, $query));
            $result = array();
            if ($this->newUpdates) {
                $result[$ticker['symbol']] = $ticker;
            } else {
                $result = $this->tickers;
            }
            return $this->filter_by_array($result, 'symbol', $symbols, true);
        }) ();
    }

    public function handle_ticker(Client $client, $message) {
        //
        //    {
        //        "time" => 1649326221,
        //        "channel" => "spot.tickers",
        //        "event" => "update",
        //        "result" => {
        //          "currency_pair" => "BTC_USDT",
        //          "last" => "43444.82",
        //          "lowest_ask" => "43444.82",
        //          "highest_bid" => "43444.81",
        //          "change_percentage" => "-4.0036",
        //          "base_volume" => "5182.5412425462",
        //          "quote_volume" => "227267634.93123952",
        //          "high_24h" => "47698",
        //          "low_24h" => "42721.03"
        //        }
        //    }
        //    {
        //        "time" => 1671363004,
        //        "time_ms" => 1671363004235,
        //        "channel" => "spot.book_ticker",
        //        "event" => "update",
        //        "result" => {
        //          "t" => 1671363004228,
        //          "u" => 9793320464,
        //          "s" => "BTC_USDT",
        //          "b" => "16716.8",
        //          "B" => "0.0134",
        //          "a" => "16716.9",
        //          "A" => "0.0353"
        //        }
        //    }
        //
        $channel = $this->safe_string($message, 'channel');
        $parts = explode('.', $channel);
        $rawMarketType = $this->safe_string($parts, 0);
        $marketType = ($rawMarketType === 'futures') ? 'contract' : 'spot';
        $result = $this->safe_value($message, 'result');
        if (gettype($result) !== 'array' || array_keys($result) !== array_keys(array_keys($result))) {
            $result = array( $result );
        }
        for ($i = 0; $i < count($result); $i++) {
            $ticker = $result[$i];
            $marketId = $this->safe_string($ticker, 's');
            $market = $this->safe_market($marketId, null, '_', $marketType);
            $parsed = $this->parse_ticker($ticker, $market);
            $symbol = $parsed['symbol'];
            $this->tickers[$symbol] = $parsed;
            $messageHash = 'ticker:' . $symbol;
            $client->resolve ($parsed, $messageHash);
            $client->resolve ($parsed, 'tickers');
        }
    }

    public function watch_trades(string $symbol, ?int $since = null, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            /**
             * get the list of most recent trades for a particular $symbol
             * @param {string} $symbol unified $symbol of the market to fetch trades for
             * @param {int} [$since] timestamp in ms of the earliest trade to fetch
             * @param {int} [$limit] the maximum amount of trades to fetch
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array[]} a list of ~@link https://docs.ccxt.com/#/?id=public-trades trade structures~
             */
            return Async\await($this->watch_trades_for_symbols(array( $symbol ), $since, $limit, $params));
        }) ();
    }

    public function watch_trades_for_symbols(array $symbols, ?int $since = null, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbols, $since, $limit, $params) {
            /**
             * get the list of most recent $trades for a particular $symbol
             * @param {string} $symbol unified $symbol of the $market to fetch $trades for
             * @param {int} [$since] timestamp in ms of the earliest trade to fetch
             * @param {int} [$limit] the maximum amount of $trades to fetch
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array[]} a list of ~@link https://docs.ccxt.com/#/?id=public-$trades trade structures~
             */
            Async\await($this->load_markets());
            $symbols = $this->market_symbols($symbols);
            $marketIds = $this->market_ids($symbols);
            $market = $this->market($symbols[0]);
            $messageType = $this->get_type_by_market($market);
            $channel = $messageType . '.trades';
            $messageHashes = array();
            for ($i = 0; $i < count($symbols); $i++) {
                $symbol = $symbols[$i];
                $messageHashes[] = 'trades:' . $symbol;
            }
            $url = $this->get_url_by_market($market);
            $trades = Async\await($this->subscribe_public_multiple($url, $messageHashes, $marketIds, $channel, $params));
            if ($this->newUpdates) {
                $first = $this->safe_value($trades, 0);
                $tradeSymbol = $this->safe_string($first, 'symbol');
                $limit = $trades->getLimit ($tradeSymbol, $limit);
            }
            return $this->filter_by_since_limit($trades, $since, $limit, 'timestamp', true);
        }) ();
    }

    public function handle_trades(Client $client, $message) {
        //
        // {
        //     "time" => 1648725035,
        //     "channel" => "spot.trades",
        //     "event" => "update",
        //     "result" => [array(
        //       "id" => 3130257995,
        //       "create_time" => 1648725035,
        //       "create_time_ms" => "1648725035923.0",
        //       "side" => "sell",
        //       "currency_pair" => "LTC_USDT",
        //       "amount" => "0.0116",
        //       "price" => "130.11"
        //     )]
        // }
        //
        $result = $this->safe_value($message, 'result');
        if (gettype($result) !== 'array' || array_keys($result) !== array_keys(array_keys($result))) {
            $result = array( $result );
        }
        $parsedTrades = $this->parse_trades($result);
        for ($i = 0; $i < count($parsedTrades); $i++) {
            $trade = $parsedTrades[$i];
            $symbol = $trade['symbol'];
            $cachedTrades = $this->safe_value($this->trades, $symbol);
            if ($cachedTrades === null) {
                $limit = $this->safe_integer($this->options, 'tradesLimit', 1000);
                $cachedTrades = new ArrayCache ($limit);
                $this->trades[$symbol] = $cachedTrades;
            }
            $cachedTrades->append ($trade);
            $hash = 'trades:' . $symbol;
            $client->resolve ($cachedTrades, $hash);
        }
    }

    public function watch_ohlcv(string $symbol, $timeframe = '1m', ?int $since = null, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $timeframe, $since, $limit, $params) {
            /**
             * watches historical candlestick data containing the open, high, low, and close price, and the volume of a $market
             * @param {string} $symbol unified $symbol of the $market to fetch OHLCV data for
             * @param {string} $timeframe the length of time each candle represents
             * @param {int} [$since] timestamp in ms of the earliest candle to fetch
             * @param {int} [$limit] the maximum amount of candles to fetch
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {int[][]} A list of candles ordered, open, high, low, close, volume
             */
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $symbol = $market['symbol'];
            $marketId = $market['id'];
            $interval = $this->safe_string($this->timeframes, $timeframe, $timeframe);
            $messageType = $this->get_type_by_market($market);
            $channel = $messageType . '.candlesticks';
            $messageHash = 'candles:' . $interval . ':' . $market['symbol'];
            $url = $this->get_url_by_market($market);
            $payload = array( $interval, $marketId );
            $ohlcv = Async\await($this->subscribe_public($url, $messageHash, $payload, $channel, $params));
            if ($this->newUpdates) {
                $limit = $ohlcv->getLimit ($symbol, $limit);
            }
            return $this->filter_by_since_limit($ohlcv, $since, $limit, 0, true);
        }) ();
    }

    public function handle_ohlcv(Client $client, $message) {
        //
        // {
        //     "time" => 1606292600,
        //     "channel" => "spot.candlesticks",
        //     "event" => "update",
        //     "result" => {
        //       "t" => "1606292580", // total volume
        //       "v" => "2362.32035", // volume
        //       "c" => "19128.1", // close
        //       "h" => "19128.1", // high
        //       "l" => "19128.1", // low
        //       "o" => "19128.1", // open
        //       "n" => "1m_BTC_USDT" // sub
        //     }
        //   }
        //
        $channel = $this->safe_string($message, 'channel');
        $channelParts = explode('.', $channel);
        $rawMarketType = $this->safe_string($channelParts, 0);
        $marketType = ($rawMarketType === 'spot') ? 'spot' : 'contract';
        $result = $this->safe_value($message, 'result');
        if (gettype($result) !== 'array' || array_keys($result) !== array_keys(array_keys($result))) {
            $result = array( $result );
        }
        $marketIds = array();
        for ($i = 0; $i < count($result); $i++) {
            $ohlcv = $result[$i];
            $subscription = $this->safe_string($ohlcv, 'n', '');
            $parts = explode('_', $subscription);
            $timeframe = $this->safe_string($parts, 0);
            $timeframeId = $this->find_timeframe($timeframe);
            $prefix = $timeframe . '_';
            $marketId = str_replace($prefix, '', $subscription);
            $symbol = $this->safe_symbol($marketId, null, '_', $marketType);
            $parsed = $this->parse_ohlcv($ohlcv);
            $this->ohlcvs[$symbol] = $this->safe_value($this->ohlcvs, $symbol, array());
            $stored = $this->safe_value($this->ohlcvs[$symbol], $timeframe);
            if ($stored === null) {
                $limit = $this->safe_integer($this->options, 'OHLCVLimit', 1000);
                $stored = new ArrayCacheByTimestamp ($limit);
                $this->ohlcvs[$symbol][$timeframeId] = $stored;
            }
            $stored->append ($parsed);
            $marketIds[$symbol] = $timeframe;
        }
        $keys = is_array($marketIds) ? array_keys($marketIds) : array();
        for ($i = 0; $i < count($keys); $i++) {
            $symbol = $keys[$i];
            $timeframe = $marketIds[$symbol];
            $interval = $this->find_timeframe($timeframe);
            $hash = 'candles' . ':' . $interval . ':' . $symbol;
            $stored = $this->safe_value($this->ohlcvs[$symbol], $interval);
            $client->resolve ($stored, $hash);
        }
    }

    public function watch_my_trades(?string $symbol = null, ?int $since = null, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            /**
             * watches information on multiple $trades made by the user
             * @param {string} $symbol unified $market $symbol of the $market $trades were made in
             * @param {int} [$since] the earliest time in ms to fetch $trades for
             * @param {int} [$limit] the maximum number of trade structures to retrieve
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure
             */
            Async\await($this->load_markets());
            $subType = null;
            $type = null;
            $marketId = '!' . 'all';
            $market = null;
            if ($symbol !== null) {
                $market = $this->market($symbol);
                $marketId = $market['id'];
            }
            list($type, $params) = $this->handle_market_type_and_params('watchMyTrades', $market, $params);
            list($subType, $params) = $this->handle_sub_type_and_params('watchMyTrades', $market, $params);
            $messageType = $this->get_supported_mapping($type, array(
                'spot' => 'spot',
                'margin' => 'spot',
                'future' => 'futures',
                'swap' => 'futures',
                'option' => 'options',
            ));
            $channel = $messageType . '.usertrades';
            $messageHash = 'myTrades';
            if ($symbol !== null) {
                $messageHash .= ':' . $symbol;
            }
            $isInverse = ($subType === 'inverse');
            $url = $this->get_url_by_market_type($type, $isInverse);
            $payload = array( $marketId );
            // uid required for non spot markets
            $requiresUid = ($type !== 'spot');
            $trades = Async\await($this->subscribe_private($url, $messageHash, $payload, $channel, $params, $requiresUid));
            if ($this->newUpdates) {
                $limit = $trades->getLimit ($symbol, $limit);
            }
            return $this->filter_by_symbol_since_limit($trades, $symbol, $since, $limit, true);
        }) ();
    }

    public function handle_my_trades(Client $client, $message) {
        //
        // {
        //     "time" => 1543205083,
        //     "channel" => "futures.usertrades",
        //     "event" => "update",
        //     "error" => null,
        //     "result" => array(
        //       {
        //         "id" => "3335259",
        //         "create_time" => 1628736848,
        //         "create_time_ms" => 1628736848321,
        //         "contract" => "BTC_USD",
        //         "order_id" => "4872460",
        //         "size" => 1,
        //         "price" => "40000.4",
        //         "role" => "maker"
        //       }
        //     )
        // }
        //
        $result = $this->safe_value($message, 'result', array());
        $tradesLength = count($result);
        if ($tradesLength === 0) {
            return;
        }
        $cachedTrades = $this->myTrades;
        if ($cachedTrades === null) {
            $limit = $this->safe_integer($this->options, 'tradesLimit', 1000);
            $cachedTrades = new ArrayCacheBySymbolById ($limit);
            $this->myTrades = $cachedTrades;
        }
        $parsed = $this->parse_trades($result);
        $marketIds = array();
        for ($i = 0; $i < count($parsed); $i++) {
            $trade = $parsed[$i];
            $cachedTrades->append ($trade);
            $symbol = $trade['symbol'];
            $marketIds[$symbol] = true;
        }
        $keys = is_array($marketIds) ? array_keys($marketIds) : array();
        for ($i = 0; $i < count($keys); $i++) {
            $market = $keys[$i];
            $hash = 'myTrades:' . $market;
            $client->resolve ($cachedTrades, $hash);
        }
        $client->resolve ($cachedTrades, 'myTrades');
    }

    public function watch_balance($params = array ()): PromiseInterface {
        return Async\async(function () use ($params) {
            /**
             * watch balance and get the amount of funds available for trading or funds locked in orders
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} a ~@link https://docs.ccxt.com/#/?id=balance-structure balance structure~
             */
            Async\await($this->load_markets());
            $type = null;
            $subType = null;
            list($type, $params) = $this->handle_market_type_and_params('watchBalance', null, $params);
            list($subType, $params) = $this->handle_sub_type_and_params('watchBalance', null, $params);
            $isInverse = ($subType === 'inverse');
            $url = $this->get_url_by_market_type($type, $isInverse);
            $requiresUid = ($type !== 'spot');
            $channelType = $this->get_supported_mapping($type, array(
                'spot' => 'spot',
                'margin' => 'spot',
                'future' => 'futures',
                'swap' => 'futures',
                'option' => 'options',
            ));
            $channel = $channelType . '.balances';
            $messageHash = $type . '.balance';
            return Async\await($this->subscribe_private($url, $messageHash, null, $channel, $params, $requiresUid));
        }) ();
    }

    public function handle_balance(Client $client, $message) {
        //
        // spot order fill
        //   {
        //       "time" => 1653664351,
        //       "channel" => "spot.balances",
        //       "event" => "update",
        //       "result" => array(
        //         {
        //           "timestamp" => "1653664351",
        //           "timestamp_ms" => "1653664351017",
        //           "user" => "10406147",
        //           "currency" => "LTC",
        //           "change" => "-0.0002000000000000",
        //           "total" => "0.09986000000000000000",
        //           "available" => "0.09986000000000000000"
        //         }
        //       )
        //   }
        //
        // $account transfer
        //
        //    {
        //        "id" => null,
        //        "time" => 1653665088,
        //        "channel" => "futures.balances",
        //        "event" => "update",
        //        "error" => null,
        //        "result" => array(
        //          {
        //            "balance" => 25.035008537,
        //            "change" => 25,
        //            "text" => "-",
        //            "time" => 1653665088,
        //            "time_ms" => 1653665088286,
        //            "type" => "dnw",
        //            "user" => "10406147"
        //          }
        //        )
        //   }
        //
        // swap order fill
        //   {
        //       "id" => null,
        //       "time" => 1653665311,
        //       "channel" => "futures.balances",
        //       "event" => "update",
        //       "error" => null,
        //       "result" => array(
        //         {
        //           "balance" => 20.031873037,
        //           "change" => -0.0031355,
        //           "text" => "LTC_USDT:165551103273",
        //           "time" => 1653665311,
        //           "time_ms" => 1653665311437,
        //           "type" => "fee",
        //           "user" => "10406147"
        //         }
        //       )
        //   }
        //
        $result = $this->safe_value($message, 'result', array());
        $timestamp = $this->safe_integer($message, 'time_ms');
        $this->balance['info'] = $result;
        $this->balance['timestamp'] = $timestamp;
        $this->balance['datetime'] = $this->iso8601($timestamp);
        for ($i = 0; $i < count($result); $i++) {
            $rawBalance = $result[$i];
            $account = $this->account();
            $currencyId = $this->safe_string($rawBalance, 'currency', 'USDT'); // when not present it is USDT
            $code = $this->safe_currency_code($currencyId);
            $account['free'] = $this->safe_string($rawBalance, 'available');
            $account['total'] = $this->safe_string_2($rawBalance, 'total', 'balance');
            $this->balance[$code] = $account;
        }
        $channel = $this->safe_string($message, 'channel');
        $parts = explode('.', $channel);
        $rawType = $this->safe_string($parts, 0);
        $channelType = $this->get_supported_mapping($rawType, array(
            'spot' => 'spot',
            'futures' => 'swap',
            'options' => 'option',
        ));
        $messageHash = $channelType . '.balance';
        $this->balance = $this->safe_balance($this->balance);
        $client->resolve ($this->balance, $messageHash);
    }

    public function watch_positions(?array $symbols = null, ?int $since = null, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbols, $since, $limit, $params) {
            /**
             * @see https://www.gate.io/docs/developers/futures/ws/en/#$positions-subscription
             * @see https://www.gate.io/docs/developers/delivery/ws/en/#$positions-subscription
             * @see https://www.gate.io/docs/developers/options/ws/en/#$positions-$channel
             * watch all open $positions
             * @param {string[]|null} $symbols list of unified $market $symbols
             * @param {array} $params extra parameters specific to the exchange API endpoint
             * @return {array[]} a list of {@link https://docs.ccxt.com/en/latest/manual.html#position-structure position structure}
             */
            Async\await($this->load_markets());
            $market = null;
            $symbols = $this->market_symbols($symbols);
            $payload = array( '!' . 'all' );
            if (!$this->is_empty($symbols)) {
                $market = $this->get_market_from_symbols($symbols);
            }
            $type = null;
            $query = null;
            list($type, $query) = $this->handle_market_type_and_params('watchPositions', $market, $params);
            if ($type === 'spot') {
                $type = 'swap';
            }
            $typeId = $this->get_supported_mapping($type, array(
                'future' => 'futures',
                'swap' => 'futures',
                'option' => 'options',
            ));
            $messageHash = $type . ':positions';
            if (!$this->is_empty($symbols)) {
                $messageHash .= '::' . implode(',', $symbols);
            }
            $channel = $typeId . '.positions';
            $subType = null;
            list($subType, $query) = $this->handle_sub_type_and_params('watchPositions', $market, $query);
            $isInverse = ($subType === 'inverse');
            $url = $this->get_url_by_market_type($type, $isInverse);
            $client = $this->client($url);
            $this->set_positions_cache($client, $type, $symbols);
            $fetchPositionsSnapshot = $this->handle_option('watchPositions', 'fetchPositionsSnapshot', true);
            $awaitPositionsSnapshot = $this->safe_value('watchPositions', 'awaitPositionsSnapshot', true);
            $cache = $this->safe_value($this->positions, $type);
            if ($fetchPositionsSnapshot && $awaitPositionsSnapshot && $cache === null) {
                return Async\await($client->future ($type . ':fetchPositionsSnapshot'));
            }
            $positions = Async\await($this->subscribe_private($url, $messageHash, $payload, $channel, $query, true));
            if ($this->newUpdates) {
                return $positions;
            }
            return $this->filter_by_symbols_since_limit($this->positions[$type], $symbols, $since, $limit, true);
        }) ();
    }

    public function set_positions_cache(Client $client, $type, ?array $symbols = null) {
        if ($this->positions === null) {
            $this->positions = array();
        }
        if (is_array($this->positions) && array_key_exists($type, $this->positions)) {
            return;
        }
        $fetchPositionsSnapshot = $this->handle_option('watchPositions', 'fetchPositionsSnapshot', false);
        if ($fetchPositionsSnapshot) {
            $messageHash = $type . ':fetchPositionsSnapshot';
            if (!(is_array($client->futures) && array_key_exists($messageHash, $client->futures))) {
                $client->future ($messageHash);
                $this->spawn(array($this, 'load_positions_snapshot'), $client, $messageHash, $type);
            }
        } else {
            $this->positions[$type] = new ArrayCacheBySymbolBySide ();
        }
    }

    public function load_positions_snapshot($client, $messageHash, $type) {
        return Async\async(function () use ($client, $messageHash, $type) {
            $positions = Async\await($this->fetch_positions(null, array( 'type' => $type )));
            $this->positions[$type] = new ArrayCacheBySymbolBySide ();
            $cache = $this->positions[$type];
            for ($i = 0; $i < count($positions); $i++) {
                $position = $positions[$i];
                $cache->append ($position);
            }
            // don't remove the $future from the .futures $cache
            $future = $client->futures[$messageHash];
            $future->resolve ($cache);
            $client->resolve ($cache, $type . ':position');
        }) ();
    }

    public function handle_positions($client, $message) {
        //
        //    {
        //        time => 1693158497,
        //        time_ms => 1693158497204,
        //        channel => 'futures.positions',
        //        event => 'update',
        //        result => [array(
        //            contract => 'XRP_USDT',
        //            cross_leverage_limit => 0,
        //            entry_price => 0.5253,
        //            history_pnl => 0,
        //            history_point => 0,
        //            last_close_pnl => 0,
        //            leverage => 0,
        //            leverage_max => 50,
        //            liq_price => 0.0361,
        //            maintenance_rate => 0.01,
        //            margin => 4.89609962852,
        //            mode => 'single',
        //            realised_pnl => -0.0026265,
        //            realised_point => 0,
        //            risk_limit => 500000,
        //            size => 1,
        //            time => 1693158497,
        //            time_ms => 1693158497195,
        //            update_id => 1,
        //            user => '10444586'
        //        )]
        //    }
        //
        $type = $this->get_market_type_by_url($client->url);
        $data = $this->safe_value($message, 'result', array());
        $cache = $this->positions[$type];
        $newPositions = array();
        for ($i = 0; $i < count($data); $i++) {
            $rawPosition = $data[$i];
            $position = $this->parse_position($rawPosition);
            $newPositions[] = $position;
            $cache->append ($position);
        }
        $messageHashes = $this->find_message_hashes($client, $type . ':$positions::');
        for ($i = 0; $i < count($messageHashes); $i++) {
            $messageHash = $messageHashes[$i];
            $parts = explode('::', $messageHash);
            $symbolsString = $parts[1];
            $symbols = explode(',', $symbolsString);
            $positions = $this->filter_by_array($newPositions, 'symbol', $symbols, false);
            if (!$this->is_empty($positions)) {
                $client->resolve ($positions, $messageHash);
            }
        }
        $client->resolve ($newPositions, $type . ':positions');
    }

    public function watch_orders(?string $symbol = null, ?int $since = null, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            /**
             * watches information on multiple $orders made by the user
             * @param {string} $symbol unified $market $symbol of the $market $orders were made in
             * @param {int} [$since] the earliest time in ms to fetch $orders for
             * @param {int} [$limit] the maximum number of order structures to retrieve
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @param {string} [$params->type] spot, margin, swap, future, or option. Required if listening to all symbols.
             * @param {boolean} [$params->isInverse] if future, listen to inverse or linear contracts
             * @return {array[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure
             */
            Async\await($this->load_markets());
            $market = null;
            if ($symbol !== null) {
                $market = $this->market($symbol);
                $symbol = $market['symbol'];
            }
            $type = null;
            $query = null;
            list($type, $query) = $this->handle_market_type_and_params('watchOrders', $market, $params);
            $typeId = $this->get_supported_mapping($type, array(
                'spot' => 'spot',
                'margin' => 'spot',
                'future' => 'futures',
                'swap' => 'futures',
                'option' => 'options',
            ));
            $channel = $typeId . '.orders';
            $messageHash = 'orders';
            $payload = array( '!' . 'all' );
            if ($symbol !== null) {
                $messageHash .= ':' . $market['id'];
                $payload = [ $market['id'] ];
            }
            $subType = null;
            list($subType, $query) = $this->handle_sub_type_and_params('watchOrders', $market, $query);
            $isInverse = ($subType === 'inverse');
            $url = $this->get_url_by_market_type($type, $isInverse);
            // uid required for non spot markets
            $requiresUid = ($type !== 'spot');
            $orders = Async\await($this->subscribe_private($url, $messageHash, $payload, $channel, $query, $requiresUid));
            if ($this->newUpdates) {
                $limit = $orders->getLimit ($symbol, $limit);
            }
            return $this->filter_by_since_limit($orders, $since, $limit, 'timestamp', true);
        }) ();
    }

    public function handle_order(Client $client, $message) {
        //
        // {
        //     "time" => 1605175506,
        //     "channel" => "spot.orders",
        //     "event" => "update",
        //     "result" => array(
        //       {
        //         "id" => "30784435",
        //         "user" => 123456,
        //         "text" => "t-abc",
        //         "create_time" => "1605175506",
        //         "create_time_ms" => "1605175506123",
        //         "update_time" => "1605175506",
        //         "update_time_ms" => "1605175506123",
        //         "event" => "put",
        //         "currency_pair" => "BTC_USDT",
        //         "type" => "limit",
        //         "account" => "spot",
        //         "side" => "sell",
        //         "amount" => "1",
        //         "price" => "10001",
        //         "time_in_force" => "gtc",
        //         "left" => "1",
        //         "filled_total" => "0",
        //         "fee" => "0",
        //         "fee_currency" => "USDT",
        //         "point_fee" => "0",
        //         "gt_fee" => "0",
        //         "gt_discount" => true,
        //         "rebated_fee" => "0",
        //         "rebated_fee_currency" => "USDT"
        //       }
        //     )
        // }
        //
        $orders = $this->safe_value($message, 'result', array());
        $limit = $this->safe_integer($this->options, 'ordersLimit', 1000);
        if ($this->orders === null) {
            $this->orders = new ArrayCacheBySymbolById ($limit);
        }
        $stored = $this->orders;
        $marketIds = array();
        $parsedOrders = $this->parse_orders($orders);
        for ($i = 0; $i < count($parsedOrders); $i++) {
            $parsed = $parsedOrders[$i];
            // inject order $status
            $info = $this->safe_value($parsed, 'info');
            $event = $this->safe_string($info, 'event');
            if ($event === 'put' || $event === 'update') {
                $parsed['status'] = 'open';
            } elseif ($event === 'finish') {
                $status = $this->safe_string($parsed, 'status');
                if ($status === null) {
                    $left = $this->safe_number($info, 'left');
                    $parsed['status'] = ($left === 0) ? 'closed' : 'canceled';
                }
            }
            $stored->append ($parsed);
            $symbol = $parsed['symbol'];
            $market = $this->market($symbol);
            $marketIds[$market['id']] = true;
        }
        $keys = is_array($marketIds) ? array_keys($marketIds) : array();
        for ($i = 0; $i < count($keys); $i++) {
            $messageHash = 'orders:' . $keys[$i];
            $client->resolve ($this->orders, $messageHash);
        }
        $client->resolve ($this->orders, 'orders');
    }

    public function handle_error_message(Client $client, $message) {
        // {
        //     "time" => 1647274664,
        //     "channel" => "futures.orders",
        //     "event" => "subscribe",
        //     "error" => array( $code => 2, $message => "unknown contract BTC_USDT_20220318" ),
        // }
        // {
        //     "time" => 1647276473,
        //     "channel" => "futures.orders",
        //     "event" => "subscribe",
        //     "error" => array(
        //       "code" => 4,
        //       "message" => "array("label":"INVALID_KEY","message":"Invalid key provided")\n"
        //     ),
        //     "result" => null
        //   }
        $error = $this->safe_value($message, 'error');
        $code = $this->safe_integer($error, 'code');
        $id = $this->safe_string($message, 'id');
        if ($id === null) {
            return false;
        }
        if ($code !== null) {
            $messageHash = $this->safe_string($client->subscriptions, $id);
            if ($messageHash !== null) {
                try {
                    $this->throw_exactly_matched_exception($this->exceptions['ws']['exact'], $code, $this->json($message));
                } catch (Exception $e) {
                    $client->reject ($e, $messageHash);
                    if (is_array($client->subscriptions) && array_key_exists($messageHash, $client->subscriptions)) {
                        unset($client->subscriptions[$messageHash]);
                    }
                }
            }
            unset($client->subscriptions[$id]);
            return true;
        }
        return false;
    }

    public function handle_balance_subscription(Client $client, $message, $subscription = null) {
        $this->balance = array();
    }

    public function handle_subscription_status(Client $client, $message) {
        $channel = $this->safe_string($message, 'channel');
        $methods = array(
            'balance' => array($this, 'handle_balance_subscription'),
            'spot.order_book_update' => array($this, 'handle_order_book_subscription'),
            'futures.order_book_update' => array($this, 'handle_order_book_subscription'),
        );
        $id = $this->safe_string($message, 'id');
        if (is_array($methods) && array_key_exists($channel, $methods)) {
            $subscriptionHash = $this->safe_string($client->subscriptions, $id);
            $subscription = $this->safe_value($client->subscriptions, $subscriptionHash);
            $method = $methods[$channel];
            $method($client, $message, $subscription);
        }
        if (is_array($client->subscriptions) && array_key_exists($id, $client->subscriptions)) {
            unset($client->subscriptions[$id]);
        }
    }

    public function handle_message(Client $client, $message) {
        //
        // subscribe
        //    {
        //        "time" => 1649062304,
        //        "id" => 1649062303,
        //        "channel" => "spot.candlesticks",
        //        "event" => "subscribe",
        //        "result" => array( status => "success" )
        //    }
        //
        // candlestick
        //    {
        //        "time" => 1649063328,
        //        "channel" => "spot.candlesticks",
        //        "event" => "update",
        //        "result" => {
        //          "t" => "1649063280",
        //          "v" => "58932.23174896",
        //          "c" => "45966.47",
        //          "h" => "45997.24",
        //          "l" => "45966.47",
        //          "o" => "45975.18",
        //          "n" => "1m_BTC_USDT",
        //          "a" => "1.281699"
        //        }
        //     }
        //
        //  orders
        //   {
        //       "time" => 1630654851,
        //       "channel" => "options.orders", or futures.orders or spot.orders
        //       "event" => "update",
        //       "result" => array(
        //          {
        //             "contract" => "BTC_USDT-20211130-65000-C",
        //             "create_time" => 1637897000,
        //               (...)
        //       )
        //   }
        // orderbook
        //   {
        //       "time" => 1649770525,
        //       "channel" => "spot.order_book_update",
        //       "event" => "update",
        //       "result" => {
        //         "t" => 1649770525653,
        //         "e" => "depthUpdate",
        //         "E" => 1649770525,
        //         "s" => "LTC_USDT",
        //         "U" => 2622525645,
        //         "u" => 2622525665,
        //         "b" => [
        //           [Array], [Array],
        //           [Array], [Array],
        //           [Array], [Array],
        //           [Array], [Array],
        //           [Array], [Array],
        //           [Array]
        //         ],
        //         "a" => [
        //           [Array], [Array],
        //           [Array], [Array],
        //           [Array], [Array],
        //           [Array], [Array],
        //           [Array], [Array],
        //           [Array]
        //         ]
        //       }
        //     }
        //
        // balance update
        //
        //    {
        //        "time" => 1653664351,
        //        "channel" => "spot.balances",
        //        "event" => "update",
        //        "result" => array(
        //          {
        //            "timestamp" => "1653664351",
        //            "timestamp_ms" => "1653664351017",
        //            "user" => "10406147",
        //            "currency" => "LTC",
        //            "change" => "-0.0002000000000000",
        //            "total" => "0.09986000000000000000",
        //            "available" => "0.09986000000000000000"
        //          }
        //        )
        //    }
        //
        if ($this->handle_error_message($client, $message)) {
            return;
        }
        $event = $this->safe_string($message, 'event');
        if ($event === 'subscribe') {
            $this->handle_subscription_status($client, $message);
            return;
        }
        $channel = $this->safe_string($message, 'channel', '');
        $channelParts = explode('.', $channel);
        $channelType = $this->safe_value($channelParts, 1);
        $v4Methods = array(
            'usertrades' => array($this, 'handle_my_trades'),
            'candlesticks' => array($this, 'handle_ohlcv'),
            'orders' => array($this, 'handle_order'),
            'positions' => array($this, 'handle_positions'),
            'tickers' => array($this, 'handle_ticker'),
            'book_ticker' => array($this, 'handle_ticker'),
            'trades' => array($this, 'handle_trades'),
            'order_book_update' => array($this, 'handle_order_book'),
            'balances' => array($this, 'handle_balance'),
        );
        $method = $this->safe_value($v4Methods, $channelType);
        if ($method !== null) {
            $method($client, $message);
        }
    }

    public function get_url_by_market($market) {
        $baseUrl = $this->urls['api'][$market['type']];
        if ($market['contract']) {
            return $market['linear'] ? $baseUrl['usdt'] : $baseUrl['btc'];
        } else {
            return $baseUrl;
        }
    }

    public function get_type_by_market($market) {
        if ($market['spot']) {
            return 'spot';
        } elseif ($market['option']) {
            return 'options';
        } else {
            return 'futures';
        }
    }

    public function get_url_by_market_type($type, $isInverse = false) {
        $api = $this->urls['api'];
        $url = $api[$type];
        if (($type === 'swap') || ($type === 'future')) {
            return $isInverse ? $url['btc'] : $url['usdt'];
        } else {
            return $url;
        }
    }

    public function get_market_type_by_url(string $url) {
        $findBy = array(
            'op-' => 'option',
            'delivery' => 'future',
            'fx' => 'swap',
        );
        $keys = is_array($findBy) ? array_keys($findBy) : array();
        for ($i = 0; $i < count($keys); $i++) {
            $key = $keys[$i];
            $value = $findBy[$key];
            if (mb_strpos($url, $key) !== false) {
                return $value;
            }
        }
        return 'spot';
    }

    public function request_id() {
        // their support said that $reqid must be an int32, not documented
        $reqid = $this->sum($this->safe_integer($this->options, 'reqid', 0), 1);
        $this->options['reqid'] = $reqid;
        return $reqid;
    }

    public function subscribe_public($url, $messageHash, $payload, $channel, $params = array (), $subscription = null) {
        return Async\async(function () use ($url, $messageHash, $payload, $channel, $params, $subscription) {
            $requestId = $this->request_id();
            $time = $this->seconds();
            $request = array(
                'id' => $requestId,
                'time' => $time,
                'channel' => $channel,
                'event' => 'subscribe',
                'payload' => $payload,
            );
            if ($subscription !== null) {
                $client = $this->client($url);
                if (!(is_array($client->subscriptions) && array_key_exists($messageHash, $client->subscriptions))) {
                    $tempSubscriptionHash = (string) $requestId;
                    $client->subscriptions[$tempSubscriptionHash] = $messageHash;
                }
            }
            $message = array_merge($request, $params);
            return Async\await($this->watch($url, $messageHash, $message, $messageHash, $subscription));
        }) ();
    }

    public function subscribe_public_multiple($url, $messageHashes, $payload, $channel, $params = array ()) {
        return Async\async(function () use ($url, $messageHashes, $payload, $channel, $params) {
            $requestId = $this->request_id();
            $time = $this->seconds();
            $request = array(
                'id' => $requestId,
                'time' => $time,
                'channel' => $channel,
                'event' => 'subscribe',
                'payload' => $payload,
            );
            $message = array_merge($request, $params);
            return Async\await($this->watch_multiple($url, $messageHashes, $message, $messageHashes));
        }) ();
    }

    public function subscribe_private($url, $messageHash, $payload, $channel, $params, $requiresUid = false) {
        return Async\async(function () use ($url, $messageHash, $payload, $channel, $params, $requiresUid) {
            $this->check_required_credentials();
            // uid is required for some subscriptions only so it's not a part of required credentials
            if ($requiresUid) {
                if ($this->uid === null || strlen($this->uid) === 0) {
                    throw new ArgumentsRequired($this->id . ' requires uid to subscribe');
                }
                $idArray = array( $this->uid );
                if ($payload === null) {
                    $payload = $idArray;
                } else {
                    $payload = $this->array_concat($idArray, $payload);
                }
            }
            $time = $this->seconds();
            $event = 'subscribe';
            $signaturePayload = 'channel=' . $channel . '&' . 'event=' . $event . '&' . 'time=' . (string) $time;
            $signature = $this->hmac($this->encode($signaturePayload), $this->encode($this->secret), 'sha512', 'hex');
            $auth = array(
                'method' => 'api_key',
                'KEY' => $this->apiKey,
                'SIGN' => $signature,
            );
            $requestId = $this->request_id();
            $request = array(
                'id' => $requestId,
                'time' => $time,
                'channel' => $channel,
                'event' => 'subscribe',
                'auth' => $auth,
            );
            if ($payload !== null) {
                $request['payload'] = $payload;
            }
            $client = $this->client($url);
            if (!(is_array($client->subscriptions) && array_key_exists($messageHash, $client->subscriptions))) {
                $tempSubscriptionHash = (string) $requestId;
                // in case of authenticationError we will throw
                $client->subscriptions[$tempSubscriptionHash] = $messageHash;
            }
            $message = array_merge($request, $params);
            return Async\await($this->watch($url, $messageHash, $message, $messageHash));
        }) ();
    }
}
