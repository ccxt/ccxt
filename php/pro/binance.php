<?php

namespace ccxt\pro;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

use Exception; // a common import
use ccxt\ExchangeError;
use ccxt\ArgumentsRequired;
use ccxt\Precise;
use React\Async;

class binance extends \ccxt\async\binance {

    public function describe() {
        return $this->deep_extend(parent::describe(), array(
            'has' => array(
                'ws' => true,
                'watchBalance' => true,
                'watchMyTrades' => true,
                'watchOHLCV' => true,
                'watchOrderBook' => true,
                'watchOrders' => true,
                'watchTicker' => true,
                'watchTickers' => true,
                'watchTrades' => true,
            ),
            'urls' => array(
                'test' => array(
                    'ws' => array(
                        'spot' => 'wss://testnet.binance.vision/ws',
                        'margin' => 'wss://testnet.binance.vision/ws',
                        'future' => 'wss://stream.binancefuture.com/ws',
                        'delivery' => 'wss://dstream.binancefuture.com/ws',
                    ),
                ),
                'api' => array(
                    'ws' => array(
                        'spot' => 'wss://stream.binance.com:9443/ws',
                        'margin' => 'wss://stream.binance.com:9443/ws',
                        'future' => 'wss://fstream.binance.com/ws',
                        'delivery' => 'wss://dstream.binance.com/ws',
                    ),
                ),
            ),
            'streaming' => array(
                'keepAlive' => 180000,
            ),
            'options' => array(
                'streamLimits' => array(
                    'spot' => 50, // max 1024
                    'margin' => 50, // max 1024
                    'future' => 50, // max 200
                    'delivery' => 50, // max 200
                ),
                'streamBySubscriptionsHash' => array(),
                'streamIndex' => -1,
                // get updates every 1000ms or 100ms
                // or every 0ms in real-time for futures
                'watchOrderBookRate' => 100,
                'tradesLimit' => 1000,
                'ordersLimit' => 1000,
                'OHLCVLimit' => 1000,
                'requestId' => array(),
                'watchOrderBookLimit' => 1000, // default limit
                'watchTrades' => array(
                    'name' => 'trade', // 'trade' or 'aggTrade'
                ),
                'watchTicker' => array(
                    'name' => 'ticker', // ticker = 1000ms L1+OHLCV, bookTicker = real-time L1
                ),
                'watchTickers' => array(
                    'name' => 'ticker', // ticker or miniTicker or bookTicker
                ),
                'watchOHLCV' => array(
                    'name' => 'kline', // or indexPriceKline or markPriceKline (coin-m futures)
                ),
                'watchBalance' => array(
                    'fetchBalanceSnapshot' => false, // or true
                    'awaitBalanceSnapshot' => true, // whether to wait for the balance snapshot before providing updates
                ),
                'wallet' => 'wb', // wb = wallet balance, cw = cross balance
                'listenKeyRefreshRate' => 1200000, // 20 mins
                'ws' => array(
                    'cost' => 5,
                ),
            ),
        ));
    }

    public function request_id($url) {
        $options = $this->safe_value($this->options, 'requestId', array());
        $previousValue = $this->safe_integer($options, $url, 0);
        $newValue = $this->sum($previousValue, 1);
        $this->options['requestId'][$url] = $newValue;
        return $newValue;
    }

    public function stream($type, $subscriptionHash) {
        $streamBySubscriptionsHash = $this->safe_value($this->options, 'streamBySubscriptionsHash', array());
        $stream = $this->safe_string($streamBySubscriptionsHash, $subscriptionHash);
        if ($stream === null) {
            $streamIndex = $this->safe_integer($this->options, 'streamIndex', -1);
            $streamLimits = $this->safe_value($this->options, 'streamLimits');
            $streamLimit = $this->safe_integer($streamLimits, $type);
            $streamIndex = $streamIndex + 1;
            $normalizedIndex = fmod($streamIndex, $streamLimit);
            $this->options['streamIndex'] = $streamIndex;
            $stream = $this->number_to_string($normalizedIndex);
            $this->options['streamBySubscriptionsHash'][$subscriptionHash] = $stream;
        }
        return $stream;
    }

    public function watch_order_book(string $symbol, ?int $limit = null, $params = array ()) {
        return Async\async(function () use ($symbol, $limit, $params) {
            /**
             * watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
             * @param {string} $symbol unified $symbol of the $market to fetch the order book for
             * @param {int|null} $limit the maximum amount of order book entries to return
             * @param {array} $params extra parameters specific to the binance api endpoint
             * @return {array} A dictionary of ~@link https://docs.ccxt.com/#/?id=order-book-structure order book structures~ indexed by $market symbols
             */
            //
            // todo add support for <levels>-snapshots (depth)
            // https://github.com/binance-exchange/binance-official-api-docs/blob/master/web-socket-streams.md#partial-book-depth-streams        // <$symbol>@depth<levels>@100ms or <$symbol>@depth<levels> (1000ms)
            // valid <levels> are 5, 10, or 20
            //
            // default 100, max 1000, valid limits 5, 10, 20, 50, 100, 500, 1000
            if ($limit !== null) {
                if (($limit !== 5) && ($limit !== 10) && ($limit !== 20) && ($limit !== 50) && ($limit !== 100) && ($limit !== 500) && ($limit !== 1000)) {
                    throw new ExchangeError($this->id . ' watchOrderBook $limit argument must be null, 5, 10, 20, 50, 100, 500 or 1000');
                }
            }
            //
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $type = $market['type'];
            if ($market['contract']) {
                $type = $market['linear'] ? 'future' : 'delivery';
            }
            //
            // notice the differences between trading futures and spot trading
            // the algorithms use different urls in step 1
            // delta caching and merging also differs in steps 4, 5, 6
            //
            // spot/margin
            // https://binance-docs.github.io/apidocs/spot/en/#how-to-manage-a-local-order-book-correctly
            //
            // 1. Open a stream to wss://stream.binance.com:9443/ws/bnbbtc@depth.
            // 2. Buffer the events you receive from the stream.
            // 3. Get a depth snapshot from https://www.binance.com/api/v1/depth?$symbol=BNBBTC&$limit=1000 .
            // 4. Drop any event where u is <= lastUpdateId in the snapshot.
            // 5. The first processed event should have U <= lastUpdateId+1 AND u >= lastUpdateId+1.
            // 6. While listening to the stream, each new event's U should be equal to the previous event's u+1.
            // 7. The data in each event is the absolute quantity for a price level.
            // 8. If the quantity is 0, remove the price level.
            // 9. Receiving an event that removes a price level that is not in your local order book can happen and is normal.
            //
            // futures
            // https://binance-docs.github.io/apidocs/futures/en/#how-to-manage-a-local-order-book-correctly
            //
            // 1. Open a stream to wss://fstream.binance.com/stream?streams=btcusdt@depth.
            // 2. Buffer the events you receive from the stream. For same price, latest received update covers the previous one.
            // 3. Get a depth snapshot from https://fapi.binance.com/fapi/v1/depth?$symbol=BTCUSDT&$limit=1000 .
            // 4. Drop any event where u is < lastUpdateId in the snapshot.
            // 5. The first processed event should have U <= lastUpdateId AND u >= lastUpdateId
            // 6. While listening to the stream, each new event's pu should be equal to the previous event's u, otherwise initialize the process from step 3.
            // 7. The data in each event is the absolute quantity for a price level.
            // 8. If the quantity is 0, remove the price level.
            // 9. Receiving an event that removes a price level that is not in your local order book can happen and is normal.
            //
            $name = 'depth';
            $messageHash = $market['lowercaseId'] . '@' . $name;
            $url = $this->urls['api']['ws'][$type] . '/' . $this->stream($type, $messageHash);
            $requestId = $this->request_id($url);
            $watchOrderBookRate = $this->safe_string($this->options, 'watchOrderBookRate', '100');
            $request = array(
                'method' => 'SUBSCRIBE',
                'params' => array(
                    $messageHash . '@' . $watchOrderBookRate . 'ms',
                ),
                'id' => $requestId,
            );
            $subscription = array(
                'id' => (string) $requestId,
                'messageHash' => $messageHash,
                'name' => $name,
                'symbol' => $market['symbol'],
                'method' => array($this, 'handle_order_book_subscription'),
                'limit' => $limit,
                'type' => $type,
                'params' => $params,
            );
            $message = array_merge($request, $params);
            // 1. Open a stream to wss://stream.binance.com:9443/ws/bnbbtc@depth.
            $orderbook = Async\await($this->watch($url, $messageHash, $message, $messageHash, $subscription));
            return $orderbook->limit ();
        }) ();
    }

    public function fetch_order_book_snapshot($client, $message, $subscription) {
        return Async\async(function () use ($client, $message, $subscription) {
            $messageHash = $this->safe_string($subscription, 'messageHash');
            $symbol = $this->safe_string($subscription, 'symbol');
            try {
                $defaultLimit = $this->safe_integer($this->options, 'watchOrderBookLimit', 1000);
                $type = $this->safe_value($subscription, 'type');
                $limit = $this->safe_integer($subscription, 'limit', $defaultLimit);
                $params = $this->safe_value($subscription, 'params');
                // 3. Get a depth $snapshot from https://www.binance.com/api/v1/depth?$symbol=BNBBTC&$limit=1000 .
                // todo => this is a synch blocking call in ccxt.php - make it async
                // default 100, max 1000, valid limits 5, 10, 20, 50, 100, 500, 1000
                $snapshot = Async\await($this->fetch_order_book($symbol, $limit, $params));
                $orderbook = $this->safe_value($this->orderbooks, $symbol);
                if ($orderbook === null) {
                    // if the $orderbook is dropped before the $snapshot is received
                    return;
                }
                $orderbook->reset ($snapshot);
                // unroll the accumulated deltas
                $messages = $orderbook->cache;
                for ($i = 0; $i < count($messages); $i++) {
                    $message = $messages[$i];
                    $U = $this->safe_integer($message, 'U');
                    $u = $this->safe_integer($message, 'u');
                    $pu = $this->safe_integer($message, 'pu');
                    if ($type === 'future') {
                        // 4. Drop any event where $u is < lastUpdateId in the $snapshot
                        if ($u < $orderbook['nonce']) {
                            continue;
                        }
                        // 5. The first processed event should have $U <= lastUpdateId AND $u >= lastUpdateId
                        if (($U <= $orderbook['nonce']) && ($u >= $orderbook['nonce']) || ($pu === $orderbook['nonce'])) {
                            $this->handle_order_book_message($client, $message, $orderbook);
                        }
                    } else {
                        // 4. Drop any event where $u is <= lastUpdateId in the $snapshot
                        if ($u <= $orderbook['nonce']) {
                            continue;
                        }
                        // 5. The first processed event should have $U <= lastUpdateId+1 AND $u >= lastUpdateId+1
                        if ((($U - 1) <= $orderbook['nonce']) && (($u - 1) >= $orderbook['nonce'])) {
                            $this->handle_order_book_message($client, $message, $orderbook);
                        }
                    }
                }
                $this->orderbooks[$symbol] = $orderbook;
                $client->resolve ($orderbook, $messageHash);
            } catch (Exception $e) {
                unset($client->subscriptions[$messageHash]);
                $client->reject ($e, $messageHash);
            }
        }) ();
    }

    public function handle_delta($bookside, $delta) {
        $price = $this->safe_float($delta, 0);
        $amount = $this->safe_float($delta, 1);
        $bookside->store ($price, $amount);
    }

    public function handle_deltas($bookside, $deltas) {
        for ($i = 0; $i < count($deltas); $i++) {
            $this->handle_delta($bookside, $deltas[$i]);
        }
    }

    public function handle_order_book_message(Client $client, $message, $orderbook) {
        $u = $this->safe_integer($message, 'u');
        $this->handle_deltas($orderbook['asks'], $this->safe_value($message, 'a', array()));
        $this->handle_deltas($orderbook['bids'], $this->safe_value($message, 'b', array()));
        $orderbook['nonce'] = $u;
        $timestamp = $this->safe_integer($message, 'E');
        $orderbook['timestamp'] = $timestamp;
        $orderbook['datetime'] = $this->iso8601($timestamp);
        return $orderbook;
    }

    public function handle_order_book(Client $client, $message) {
        //
        // initial snapshot is fetched with ccxt's fetchOrderBook
        // the feed does not include a snapshot, just the deltas
        //
        //     {
        //         "e" => "depthUpdate", // Event type
        //         "E" => 1577554482280, // Event time
        //         "s" => "BNBBTC", // Symbol
        //         "U" => 157, // First update ID in event
        //         "u" => 160, // Final update ID in event
        //         "b" => array( // bids
        //             array( "0.0024", "10" ), // price, size
        //         ),
        //         "a" => array( // asks
        //             array( "0.0026", "100" ), // price, size
        //         )
        //     }
        //
        $isTestnetSpot = mb_strpos($client->url, 'testnet') > 0;
        $isSpotMainNet = mb_strpos($client->url, '/stream.binance.') > 0;
        $isSpot = $isTestnetSpot || $isSpotMainNet;
        $marketType = $isSpot ? 'spot' : 'contract';
        $marketId = $this->safe_string($message, 's');
        $market = $this->safe_market($marketId, null, null, $marketType);
        $symbol = $market['symbol'];
        $name = 'depth';
        $messageHash = $market['lowercaseId'] . '@' . $name;
        $orderbook = $this->safe_value($this->orderbooks, $symbol);
        if ($orderbook === null) {
            //
            // https://github.com/ccxt/ccxt/issues/6672
            //
            // Sometimes Binance sends the first delta before the subscription
            // confirmation arrives. At that point the $orderbook is not
            // initialized yet and the snapshot has not been requested yet
            // therefore it is safe to drop these premature messages.
            //
            return;
        }
        $nonce = $this->safe_integer($orderbook, 'nonce');
        if ($nonce === null) {
            // 2. Buffer the events you receive from the stream.
            $orderbook->cache[] = $message;
        } else {
            try {
                $U = $this->safe_integer($message, 'U');
                $u = $this->safe_integer($message, 'u');
                $pu = $this->safe_integer($message, 'pu');
                if ($pu === null) {
                    // spot
                    // 4. Drop any event where $u is <= lastUpdateId in the snapshot
                    if ($u > $orderbook['nonce']) {
                        $timestamp = $this->safe_integer($orderbook, 'timestamp');
                        $conditional = null;
                        if ($timestamp === null) {
                            // 5. The first processed event should have $U <= lastUpdateId+1 AND $u >= lastUpdateId+1
                            $conditional = (($U - 1) <= $orderbook['nonce']) && (($u - 1) >= $orderbook['nonce']);
                        } else {
                            // 6. While listening to the stream, each new event's $U should be equal to the previous event's $u+1.
                            $conditional = (($U - 1) === $orderbook['nonce']);
                        }
                        if ($conditional) {
                            $this->handle_order_book_message($client, $message, $orderbook);
                            if ($nonce < $orderbook['nonce']) {
                                $client->resolve ($orderbook, $messageHash);
                            }
                        } else {
                            // todo => $client->reject from handleOrderBookMessage properly
                            throw new ExchangeError($this->id . ' handleOrderBook received an out-of-order nonce');
                        }
                    }
                } else {
                    // future
                    // 4. Drop any event where $u is < lastUpdateId in the snapshot
                    if ($u >= $orderbook['nonce']) {
                        // 5. The first processed event should have $U <= lastUpdateId AND $u >= lastUpdateId
                        // 6. While listening to the stream, each new event's $pu should be equal to the previous event's $u, otherwise initialize the process from step 3
                        if (($U <= $orderbook['nonce']) || ($pu === $orderbook['nonce'])) {
                            $this->handle_order_book_message($client, $message, $orderbook);
                            if ($nonce <= $orderbook['nonce']) {
                                $client->resolve ($orderbook, $messageHash);
                            }
                        } else {
                            // todo => $client->reject from handleOrderBookMessage properly
                            throw new ExchangeError($this->id . ' handleOrderBook received an out-of-order nonce');
                        }
                    }
                }
            } catch (Exception $e) {
                unset($this->orderbooks[$symbol]);
                unset($client->subscriptions[$messageHash]);
                $client->reject ($e, $messageHash);
            }
        }
    }

    public function handle_order_book_subscription(Client $client, $message, $subscription) {
        $defaultLimit = $this->safe_integer($this->options, 'watchOrderBookLimit', 1000);
        $symbol = $this->safe_string($subscription, 'symbol');
        $limit = $this->safe_integer($subscription, 'limit', $defaultLimit);
        if (is_array($this->orderbooks) && array_key_exists($symbol, $this->orderbooks)) {
            unset($this->orderbooks[$symbol]);
        }
        $this->orderbooks[$symbol] = $this->order_book(array(), $limit);
        // fetch the snapshot in a separate async call
        $this->spawn(array($this, 'fetch_order_book_snapshot'), $client, $message, $subscription);
    }

    public function handle_subscription_status(Client $client, $message) {
        //
        //     {
        //         "result" => null,
        //         "id" => 1574649734450
        //     }
        //
        $id = $this->safe_string($message, 'id');
        $subscriptionsById = $this->index_by($client->subscriptions, 'id');
        $subscription = $this->safe_value($subscriptionsById, $id, array());
        $method = $this->safe_value($subscription, 'method');
        if ($method !== null) {
            $method($client, $message, $subscription);
        }
        return $message;
    }

    public function watch_trades(string $symbol, ?int $since = null, ?int $limit = null, $params = array ()) {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            /**
             * get the list of most recent $trades for a particular $symbol
             * @param {string} $symbol unified $symbol of the $market to fetch $trades for
             * @param {int|null} $since timestamp in ms of the earliest trade to fetch
             * @param {int|null} $limit the maximum amount of $trades to fetch
             * @param {array} $params extra parameters specific to the binance api endpoint
             * @return {[array]} a list of ~@link https://docs.ccxt.com/en/latest/manual.html?#public-$trades trade structures~
             */
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $options = $this->safe_value($this->options, 'watchTrades', array());
            $name = $this->safe_string($options, 'name', 'trade');
            $messageHash = $market['lowercaseId'] . '@' . $name;
            $type = $market['type'];
            if ($market['contract']) {
                $type = $market['linear'] ? 'future' : 'delivery';
            }
            $query = $this->omit($params, 'type');
            $url = $this->urls['api']['ws'][$type] . '/' . $this->stream($type, $messageHash);
            $requestId = $this->request_id($url);
            $request = array(
                'method' => 'SUBSCRIBE',
                'params' => array(
                    $messageHash,
                ),
                'id' => $requestId,
            );
            $subscribe = array(
                'id' => $requestId,
            );
            $trades = Async\await($this->watch($url, $messageHash, array_merge($request, $query), $messageHash, $subscribe));
            if ($this->newUpdates) {
                $limit = $trades->getLimit ($market['symbol'], $limit);
            }
            return $this->filter_by_since_limit($trades, $since, $limit, 'timestamp');
        }) ();
    }

    public function parse_trade($trade, $market = null) {
        //
        // public watchTrades
        //
        //     {
        //         e => 'trade',       // event $type
        //         E => 1579481530911, // event time
        //         s => 'ETHBTC',      // $symbol
        //         t => 158410082,     // $trade $id
        //         p => '0.01914100',  // $price
        //         q => '0.00700000',  // quantity
        //         b => 586187049,     // buyer order $id
        //         a => 586186710,     // seller order $id
        //         T => 1579481530910, // $trade time
        //         m => false,         // is the buyer the $market maker
        //         M => true           // binance docs say it should be ignored
        //     }
        //
        //     {
        //        "e" => "aggTrade",  // Event $type
        //        "E" => 123456789,   // Event time
        //        "s" => "BNBBTC",    // Symbol
        //        "a" => 12345,       // Aggregate $trade ID
        //        "p" => "0.001",     // Price
        //        "q" => "100",       // Quantity
        //        "f" => 100,         // First $trade ID
        //        "l" => 105,         // Last $trade ID
        //        "T" => 123456785,   // Trade time
        //        "m" => true,        // Is the buyer the $market maker?
        //        "M" => true         // Ignore
        //     }
        //
        // private watchMyTrades spot
        //
        //     {
        //         e => 'executionReport',
        //         E => 1611063861489,
        //         s => 'BNBUSDT',
        //         c => 'm4M6AD5MF3b1ERe65l4SPq',
        //         S => 'BUY',
        //         o => 'MARKET',
        //         f => 'GTC',
        //         q => '2.00000000',
        //         p => '0.00000000',
        //         P => '0.00000000',
        //         F => '0.00000000',
        //         g => -1,
        //         C => '',
        //         x => 'TRADE',
        //         X => 'PARTIALLY_FILLED',
        //         r => 'NONE',
        //         i => 1296882607,
        //         l => '0.33200000',
        //         z => '0.33200000',
        //         L => '46.86600000',
        //         n => '0.00033200',
        //         N => 'BNB',
        //         T => 1611063861488,
        //         t => 109747654,
        //         I => 2696953381,
        //         w => false,
        //         m => false,
        //         M => true,
        //         O => 1611063861488,
        //         Z => '15.55951200',
        //         Y => '15.55951200',
        //         Q => '0.00000000'
        //     }
        //
        // private watchMyTrades future/delivery
        //
        //     {
        //         s => 'BTCUSDT',
        //         c => 'pb2jD6ZQHpfzSdUac8VqMK',
        //         S => 'SELL',
        //         o => 'MARKET',
        //         f => 'GTC',
        //         q => '0.001',
        //         p => '0',
        //         ap => '33468.46000',
        //         sp => '0',
        //         x => 'TRADE',
        //         X => 'FILLED',
        //         i => 13351197194,
        //         l => '0.001',
        //         z => '0.001',
        //         L => '33468.46',
        //         n => '0.00027086',
        //         N => 'BNB',
        //         T => 1612095165362,
        //         t => 458032604,
        //         b => '0',
        //         a => '0',
        //         m => false,
        //         R => false,
        //         wt => 'CONTRACT_PRICE',
        //         ot => 'MARKET',
        //         ps => 'BOTH',
        //         cp => false,
        //         rp => '0.00335000',
        //         pP => false,
        //         si => 0,
        //         ss => 0
        //     }
        //
        $executionType = $this->safe_string($trade, 'x');
        $isTradeExecution = ($executionType === 'TRADE');
        if (!$isTradeExecution) {
            return parent::parse_trade($trade, $market);
        }
        $id = $this->safe_string_2($trade, 't', 'a');
        $timestamp = $this->safe_integer($trade, 'T');
        $price = $this->safe_string_2($trade, 'L', 'p');
        $amount = $this->safe_string($trade, 'q');
        if ($isTradeExecution) {
            $amount = $this->safe_string($trade, 'l', $amount);
        }
        $cost = $this->safe_string($trade, 'Y');
        if ($cost === null) {
            if (($price !== null) && ($amount !== null)) {
                $cost = Precise::string_mul($price, $amount);
            }
        }
        $marketId = $this->safe_string($trade, 's');
        $marketType = (is_array($trade) && array_key_exists('ps', $trade)) ? 'contract' : 'spot';
        $symbol = $this->safe_symbol($marketId, null, null, $marketType);
        $side = $this->safe_string_lower($trade, 'S');
        $takerOrMaker = null;
        $orderId = $this->safe_string($trade, 'i');
        if (is_array($trade) && array_key_exists('m', $trade)) {
            if ($side === null) {
                $side = $trade['m'] ? 'sell' : 'buy'; // this is reversed intentionally
            }
            $takerOrMaker = $trade['m'] ? 'maker' : 'taker';
        }
        $fee = null;
        $feeCost = $this->safe_string($trade, 'n');
        if ($feeCost !== null) {
            $feeCurrencyId = $this->safe_string($trade, 'N');
            $feeCurrencyCode = $this->safe_currency_code($feeCurrencyId);
            $fee = array(
                'cost' => $feeCost,
                'currency' => $feeCurrencyCode,
            );
        }
        $type = $this->safe_string_lower($trade, 'o');
        return $this->safe_trade(array(
            'info' => $trade,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'symbol' => $symbol,
            'id' => $id,
            'order' => $orderId,
            'type' => $type,
            'takerOrMaker' => $takerOrMaker,
            'side' => $side,
            'price' => $price,
            'amount' => $amount,
            'cost' => $cost,
            'fee' => $fee,
        ));
    }

    public function handle_trade(Client $client, $message) {
        // the $trade streams push raw $trade information in real-time
        // each $trade has a unique buyer and seller
        $index = mb_strpos($client->url, '/stream');
        $marketType = ($index >= 0) ? 'spot' : 'contract';
        $marketId = $this->safe_string($message, 's');
        $market = $this->safe_market($marketId, null, null, $marketType);
        $symbol = $market['symbol'];
        $lowerCaseId = $this->safe_string_lower($message, 's');
        $event = $this->safe_string($message, 'e');
        $messageHash = $lowerCaseId . '@' . $event;
        $trade = $this->parse_trade($message, $market);
        $tradesArray = $this->safe_value($this->trades, $symbol);
        if ($tradesArray === null) {
            $limit = $this->safe_integer($this->options, 'tradesLimit', 1000);
            $tradesArray = new ArrayCache ($limit);
        }
        $tradesArray->append ($trade);
        $this->trades[$symbol] = $tradesArray;
        $client->resolve ($tradesArray, $messageHash);
    }

    public function watch_ohlcv(string $symbol, $timeframe = '1m', ?int $since = null, ?int $limit = null, $params = array ()) {
        return Async\async(function () use ($symbol, $timeframe, $since, $limit, $params) {
            /**
             * watches historical candlestick data containing the open, high, low, and close price, and the volume of a $market
             * @param {string} $symbol unified $symbol of the $market to fetch OHLCV data for
             * @param {string} $timeframe the length of time each candle represents
             * @param {int|null} $since timestamp in ms of the earliest candle to fetch
             * @param {int|null} $limit the maximum amount of candles to fetch
             * @param {array} $params extra parameters specific to the binance api endpoint
             * @return {[[int]]} A list of candles ordered, open, high, low, close, volume
             */
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $marketId = $market['lowercaseId'];
            $interval = $this->safe_string($this->timeframes, $timeframe, $timeframe);
            $options = $this->safe_value($this->options, 'watchOHLCV', array());
            $nameOption = $this->safe_string($options, 'name', 'kline');
            $name = $this->safe_string($params, 'name', $nameOption);
            if ($name === 'indexPriceKline') {
                // weird behavior for index price kline we can't use the perp suffix
                $marketId = str_replace('_perp', '', $marketId);
            }
            $params = $this->omit($params, 'name');
            $messageHash = $marketId . '@' . $name . '_' . $interval;
            $type = $market['type'];
            if ($market['contract']) {
                $type = $market['linear'] ? 'future' : 'delivery';
            }
            $url = $this->urls['api']['ws'][$type] . '/' . $this->stream($type, $messageHash);
            $requestId = $this->request_id($url);
            $request = array(
                'method' => 'SUBSCRIBE',
                'params' => array(
                    $messageHash,
                ),
                'id' => $requestId,
            );
            $subscribe = array(
                'id' => $requestId,
            );
            $ohlcv = Async\await($this->watch($url, $messageHash, array_merge($request, $params), $messageHash, $subscribe));
            if ($this->newUpdates) {
                $limit = $ohlcv->getLimit ($symbol, $limit);
            }
            return $this->filter_by_since_limit($ohlcv, $since, $limit, 0);
        }) ();
    }

    public function handle_ohlcv(Client $client, $message) {
        //
        //     {
        //         e => 'kline',
        //         E => 1579482921215,
        //         s => 'ETHBTC',
        //         k => {
        //             t => 1579482900000,
        //             T => 1579482959999,
        //             s => 'ETHBTC',
        //             i => '1m',
        //             f => 158411535,
        //             L => 158411550,
        //             o => '0.01913200',
        //             c => '0.01913500',
        //             h => '0.01913700',
        //             l => '0.01913200',
        //             v => '5.08400000',
        //             n => 16,
        //             x => false,
        //             q => '0.09728060',
        //             V => '3.30200000',
        //             Q => '0.06318500',
        //             B => '0'
        //         }
        //     }
        //
        $event = $this->safe_string($message, 'e');
        $eventMap = array(
            'indexPrice_kline' => 'indexPriceKline',
            'markPrice_kline' => 'markPriceKline',
        );
        $event = $this->safe_string($eventMap, $event, $event);
        $kline = $this->safe_value($message, 'k');
        $marketId = $this->safe_string_2($kline, 's', 'ps');
        if ($event === 'indexPriceKline') {
            // indexPriceKline doesn't have the _PERP suffix
            $marketId = $this->safe_string($message, 'ps');
        }
        $lowercaseMarketId = strtolower($marketId);
        $interval = $this->safe_string($kline, 'i');
        // use a reverse lookup in a static map instead
        $timeframe = $this->find_timeframe($interval);
        $messageHash = $lowercaseMarketId . '@' . $event . '_' . $interval;
        $parsed = array(
            $this->safe_integer($kline, 't'),
            $this->safe_float($kline, 'o'),
            $this->safe_float($kline, 'h'),
            $this->safe_float($kline, 'l'),
            $this->safe_float($kline, 'c'),
            $this->safe_float($kline, 'v'),
        );
        $index = mb_strpos($client->url, '/stream');
        $marketType = ($index >= 0) ? 'spot' : 'contract';
        $symbol = $this->safe_symbol($marketId, null, null, $marketType);
        $this->ohlcvs[$symbol] = $this->safe_value($this->ohlcvs, $symbol, array());
        $stored = $this->safe_value($this->ohlcvs[$symbol], $timeframe);
        if ($stored === null) {
            $limit = $this->safe_integer($this->options, 'OHLCVLimit', 1000);
            $stored = new ArrayCacheByTimestamp ($limit);
            $this->ohlcvs[$symbol][$timeframe] = $stored;
        }
        $stored->append ($parsed);
        $client->resolve ($stored, $messageHash);
    }

    public function watch_ticker(string $symbol, $params = array ()) {
        return Async\async(function () use ($symbol, $params) {
            /**
             * watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific $market
             * @param {string} $symbol unified $symbol of the $market to fetch the ticker for
             * @param {array} $params extra parameters specific to the binance api endpoint
             * @param {string} $params->name stream to use can be ticker or bookTicker
             * @return {array} a ~@link https://docs.ccxt.com/#/?id=ticker-structure ticker structure~
             */
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $marketId = $market['lowercaseId'];
            $type = $market['type'];
            if ($market['contract']) {
                $type = $market['linear'] ? 'future' : 'delivery';
            }
            $options = $this->safe_value($this->options, 'watchTicker', array());
            $name = $this->safe_string($options, 'name', 'ticker');
            $name = $this->safe_string($params, 'name', $name);
            $params = $this->omit($params, 'name');
            $messageHash = $marketId . '@' . $name;
            $url = $this->urls['api']['ws'][$type] . '/' . $this->stream($type, $messageHash);
            $requestId = $this->request_id($url);
            $request = array(
                'method' => 'SUBSCRIBE',
                'params' => array(
                    $messageHash,
                ),
                'id' => $requestId,
            );
            $subscribe = array(
                'id' => $requestId,
            );
            return Async\await($this->watch($url, $messageHash, array_merge($request, $params), $messageHash, $subscribe));
        }) ();
    }

    public function watch_tickers(?array $symbols = null, $params = array ()) {
        return Async\async(function () use ($symbols, $params) {
            /**
             * watches a price $ticker, a statistical calculation with the information calculated over the past 24 hours for all markets of a specific list
             * @param {[string]} $symbols unified symbol of the $market to fetch the $ticker for
             * @param {array} $params extra parameters specific to the binance api endpoint
             * @return {array} a ~@link https://docs.ccxt.com/#/?id=$ticker-structure $ticker structure~
             */
            Async\await($this->load_markets());
            $symbols = $this->market_symbols($symbols);
            $marketIds = $this->market_ids($symbols);
            $market = null;
            $type = null;
            list($type, $params) = $this->handle_market_type_and_params('watchTickers', $market, $params);
            if ($marketIds !== null) {
                $market = $this->safe_market($marketIds[0], null, null, $type);
            }
            $subType = null;
            list($subType, $params) = $this->handle_sub_type_and_params('watchTickers', $market, $params);
            if ($this->isLinear ($type, $subType)) {
                $type = 'future';
            } elseif ($this->isInverse ($type, $subType)) {
                $type = 'delivery';
            }
            $options = $this->safe_value($this->options, 'watchTickers', array());
            $name = $this->safe_string($options, 'name', 'ticker');
            $name = $this->safe_string($params, 'name', $name);
            $oriParams = $params;
            $params = $this->omit($params, 'name');
            $wsParams = array();
            $messageHash = '!' . $name . '@arr';
            if ($name === 'bookTicker') {
                if ($marketIds === null) {
                    throw new ArgumentsRequired($this->id . ' watchTickers() requires $symbols for bookTicker');
                }
                // simulate watchTickers with $subscribe multiple individual bookTicker topic
                for ($i = 0; $i < count($marketIds); $i++) {
                    $wsParams[] = strtolower($marketIds[$i]) . '@bookTicker';
                }
            } else {
                $wsParams = array(
                    $messageHash,
                );
            }
            $url = $this->urls['api']['ws'][$type] . '/' . $this->stream($type, $messageHash);
            $requestId = $this->request_id($url);
            $request = array(
                'method' => 'SUBSCRIBE',
                'params' => $wsParams,
                'id' => $requestId,
            );
            $subscribe = array(
                'id' => $requestId,
            );
            $tickers = Async\await($this->watch($url, $messageHash, array_merge($request, $params), $messageHash, $subscribe));
            $result = array();
            for ($i = 0; $i < count($tickers); $i++) {
                $ticker = $tickers[$i];
                $tickerSymbol = $ticker['symbol'];
                if ($symbols === null || $this->in_array($tickerSymbol, $symbols)) {
                    $result[$tickerSymbol] = $ticker;
                }
            }
            $resultKeys = is_array($result) ? array_keys($result) : array();
            $resultKeysLength = count($resultKeys);
            if ($resultKeysLength > 0) {
                if ($this->newUpdates) {
                    return $result;
                }
                return $this->filter_by_array($this->tickers, 'symbol', $symbols);
            }
            return Async\await($this->watch_tickers($symbols, $oriParams));
        }) ();
    }

    public function parse_ws_ticker($message, $marketType) {
        //
        // $ticker
        //     {
        //         e => '24hrTicker',      // $event type
        //         E => 1579485598569,     // $event time
        //         s => 'ETHBTC',          // $symbol
        //         p => '-0.00004000',     // price change
        //         P => '-0.209',          // price change percent
        //         w => '0.01920495',      // weighted average price
        //         x => '0.01916500',      // the price of the first trade before the 24hr rolling window
        //         c => '0.01912500',      // $last (closing) price
        //         Q => '0.10400000',      // $last quantity
        //         b => '0.01912200',      // best bid
        //         B => '4.10400000',      // best bid quantity
        //         a => '0.01912500',      // best ask
        //         A => '0.00100000',      // best ask quantity
        //         o => '0.01916500',      // open price
        //         h => '0.01956500',      // high price
        //         l => '0.01887700',      // low price
        //         v => '173518.11900000', // base volume
        //         q => '3332.40703994',   // quote volume
        //         O => 1579399197842,     // open time
        //         C => 1579485597842,     // close time
        //         F => 158251292,         // first trade id
        //         L => 158414513,         // $last trade id
        //         n => 163222,            // total number of trades
        //     }
        //
        // miniTicker
        //     {
        //         e => '24hrMiniTicker',
        //         E => 1671617114585,
        //         s => 'MOBBUSD',
        //         c => '0.95900000',
        //         o => '0.91200000',
        //         h => '1.04000000',
        //         l => '0.89400000',
        //         v => '2109995.32000000',
        //         q => '2019254.05788000'
        //     }
        //
        $event = $this->safe_string($message, 'e', 'bookTicker');
        if ($event === '24hrTicker') {
            $event = 'ticker';
        }
        $timestamp = null;
        $now = $this->milliseconds();
        if ($event === 'bookTicker') {
            // take the $event $timestamp, if available, for spot tickers it is not
            $timestamp = $this->safe_integer($message, 'E', $now);
        } else {
            // take the $timestamp of the closing price for candlestick streams
            $timestamp = $this->safe_integer($message, 'C', $now);
        }
        $marketId = $this->safe_string($message, 's');
        $symbol = $this->safe_symbol($marketId, null, null, $marketType);
        $last = $this->safe_float($message, 'c');
        $ticker = array(
            'symbol' => $symbol,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'high' => $this->safe_float($message, 'h'),
            'low' => $this->safe_float($message, 'l'),
            'bid' => $this->safe_float($message, 'b'),
            'bidVolume' => $this->safe_float($message, 'B'),
            'ask' => $this->safe_float($message, 'a'),
            'askVolume' => $this->safe_float($message, 'A'),
            'vwap' => $this->safe_float($message, 'w'),
            'open' => $this->safe_float($message, 'o'),
            'close' => $last,
            'last' => $last,
            'previousClose' => $this->safe_float($message, 'x'), // previous day close
            'change' => $this->safe_float($message, 'p'),
            'percentage' => $this->safe_float($message, 'P'),
            'average' => null,
            'baseVolume' => $this->safe_float($message, 'v'),
            'quoteVolume' => $this->safe_float($message, 'q'),
            'info' => $message,
        );
        return $ticker;
    }

    public function handle_ticker(Client $client, $message) {
        //
        // 24hr rolling window ticker statistics for a single $symbol
        // These are NOT the statistics of the UTC day, but a 24hr rolling window for the previous 24hrs
        // Update Speed 1000ms
        //
        //     {
        //         e => '24hrTicker',      // $event type
        //         E => 1579485598569,     // $event time
        //         s => 'ETHBTC',          // $symbol
        //         p => '-0.00004000',     // price change
        //         P => '-0.209',          // price change percent
        //         w => '0.01920495',      // weighted average price
        //         x => '0.01916500',      // the price of the first trade before the 24hr rolling window
        //         c => '0.01912500',      // last (closing) price
        //         Q => '0.10400000',      // last quantity
        //         b => '0.01912200',      // best bid
        //         B => '4.10400000',      // best bid quantity
        //         a => '0.01912500',      // best ask
        //         A => '0.00100000',      // best ask quantity
        //         o => '0.01916500',      // open price
        //         h => '0.01956500',      // high price
        //         l => '0.01887700',      // low price
        //         v => '173518.11900000', // base volume
        //         q => '3332.40703994',   // quote volume
        //         O => 1579399197842,     // open time
        //         C => 1579485597842,     // close time
        //         F => 158251292,         // first trade id
        //         L => 158414513,         // last trade id
        //         n => 163222,            // total number of trades
        //     }
        //
        $event = $this->safe_string($message, 'e', 'bookTicker');
        if ($event === '24hrTicker') {
            $event = 'ticker';
        } elseif ($event === '24hrMiniTicker') {
            $event = 'miniTicker';
        }
        $wsMarketId = $this->safe_string_lower($message, 's');
        $messageHash = $wsMarketId . '@' . $event;
        $index = mb_strpos($client->url, '/stream');
        $marketType = ($index >= 0) ? 'spot' : 'contract';
        $result = $this->parse_ws_ticker($message, $marketType);
        $symbol = $result['symbol'];
        $this->tickers[$symbol] = $result;
        $client->resolve ($result, $messageHash);
        if ($event === 'bookTicker') {
            // watch bookTickers
            $client->resolve (array( $result ), '!' . 'bookTicker@arr');
        }
    }

    public function handle_tickers(Client $client, $message) {
        $event = null;
        $index = mb_strpos($client->url, '/stream');
        $marketType = ($index >= 0) ? 'spot' : 'contract';
        for ($i = 0; $i < count($message); $i++) {
            $ticker = $message[$i];
            $event = $this->safe_string($ticker, 'e');
            if ($event === '24hrTicker') {
                $event = 'ticker';
            } elseif ($event === '24hrMiniTicker') {
                $event = 'miniTicker';
            }
            $wsMarketId = $this->safe_string_lower($ticker, 's');
            $messageHash = $wsMarketId . '@' . $event;
            $result = $this->parse_ws_ticker($ticker, $marketType);
            $symbol = $result['symbol'];
            $this->tickers[$symbol] = $result;
            $client->resolve ($result, $messageHash);
        }
        $values = is_array($this->tickers) ? array_values($this->tickers) : array();
        $client->resolve ($values, '!' . $event . '@arr');
    }

    public function authenticate($params = array ()) {
        return Async\async(function () use ($params) {
            $time = $this->milliseconds();
            $type = $this->safe_string_2($this->options, 'defaultType', 'authenticate', 'spot');
            $type = $this->safe_string($params, 'type', $type);
            $subType = null;
            list($subType, $params) = $this->handle_sub_type_and_params('authenticate', null, $params);
            if ($this->isLinear ($type, $subType)) {
                $type = 'future';
            } elseif ($this->isInverse ($type, $subType)) {
                $type = 'delivery';
            }
            $marginMode = null;
            list($marginMode, $params) = $this->handle_margin_mode_and_params('authenticate', $params);
            $isIsolatedMargin = ($marginMode === 'isolated');
            $isCrossMargin = ($marginMode === 'cross') || ($marginMode === null);
            $symbol = $this->safe_string($params, 'symbol');
            $params = $this->omit($params, 'symbol');
            $options = $this->safe_value($this->options, $type, array());
            $lastAuthenticatedTime = $this->safe_integer($options, 'lastAuthenticatedTime', 0);
            $listenKeyRefreshRate = $this->safe_integer($this->options, 'listenKeyRefreshRate', 1200000);
            $delay = $this->sum($listenKeyRefreshRate, 10000);
            if ($time - $lastAuthenticatedTime > $delay) {
                $method = 'publicPostUserDataStream';
                if ($type === 'future') {
                    $method = 'fapiPrivatePostListenKey';
                } elseif ($type === 'delivery') {
                    $method = 'dapiPrivatePostListenKey';
                } elseif ($type === 'margin' && $isCrossMargin) {
                    $method = 'sapiPostUserDataStream';
                } elseif ($isIsolatedMargin) {
                    $method = 'sapiPostUserDataStreamIsolated';
                    if ($symbol === null) {
                        throw new ArgumentsRequired($this->id . ' authenticate() requires a $symbol argument for isolated margin mode');
                    }
                    $marketId = $this->market_id($symbol);
                    $params = array_merge($params, array( 'symbol' => $marketId ));
                }
                $response = Async\await($this->$method ($params));
                $this->options[$type] = array_merge($options, array(
                    'listenKey' => $this->safe_string($response, 'listenKey'),
                    'lastAuthenticatedTime' => $time,
                ));
                $this->delay($listenKeyRefreshRate, array($this, 'keep_alive_listen_key'), $params);
            }
        }) ();
    }

    public function keep_alive_listen_key($params = array ()) {
        return Async\async(function () use ($params) {
            // https://binance-docs.github.io/apidocs/spot/en/#listen-key-spot
            $type = $this->safe_string_2($this->options, 'defaultType', 'authenticate', 'spot');
            $type = $this->safe_string($params, 'type', $type);
            $subType = null;
            list($subType, $params) = $this->handle_sub_type_and_params('keepAliveListenKey', null, $params);
            if ($this->isLinear ($type, $subType)) {
                $type = 'future';
            } elseif ($this->isInverse ($type, $subType)) {
                $type = 'delivery';
            }
            $options = $this->safe_value($this->options, $type, array());
            $listenKey = $this->safe_string($options, 'listenKey');
            if ($listenKey === null) {
                // A network $error happened => we can't renew a listen key that does not exist.
                return;
            }
            $method = 'publicPutUserDataStream';
            if ($type === 'future') {
                $method = 'fapiPrivatePutListenKey';
            } elseif ($type === 'delivery') {
                $method = 'dapiPrivatePutListenKey';
            } elseif ($type === 'margin') {
                $method = 'sapiPutUserDataStream';
            }
            $request = array(
                'listenKey' => $listenKey,
            );
            $time = $this->milliseconds();
            $sendParams = $this->omit($params, 'type');
            try {
                Async\await($this->$method (array_merge($request, $sendParams)));
            } catch (Exception $error) {
                $url = $this->urls['api']['ws'][$type] . '/' . $this->options[$type]['listenKey'];
                $client = $this->client($url);
                $messageHashes = is_array($client->futures) ? array_keys($client->futures) : array();
                for ($i = 0; $i < count($messageHashes); $i++) {
                    $messageHash = $messageHashes[$i];
                    $client->reject ($error, $messageHash);
                }
                $this->options[$type] = array_merge($options, array(
                    'listenKey' => null,
                    'lastAuthenticatedTime' => 0,
                ));
                return;
            }
            $this->options[$type] = array_merge($options, array(
                'listenKey' => $listenKey,
                'lastAuthenticatedTime' => $time,
            ));
            // whether or not to schedule another $listenKey keepAlive $request
            $clients = is_array($this->clients) ? array_values($this->clients) : array();
            $listenKeyRefreshRate = $this->safe_integer($this->options, 'listenKeyRefreshRate', 1200000);
            for ($i = 0; $i < count($clients); $i++) {
                $client = $clients[$i];
                $subscriptionKeys = is_array($client->subscriptions) ? array_keys($client->subscriptions) : array();
                for ($j = 0; $j < count($subscriptionKeys); $j++) {
                    $subscribeType = $subscriptionKeys[$j];
                    if ($subscribeType === $type) {
                        return $this->delay($listenKeyRefreshRate, array($this, 'keep_alive_listen_key'), $params);
                    }
                }
            }
        }) ();
    }

    public function set_balance_cache(Client $client, $type) {
        if (is_array($client->subscriptions) && array_key_exists($type, $client->subscriptions)) {
            return null;
        }
        $options = $this->safe_value($this->options, 'watchBalance');
        $fetchBalanceSnapshot = $this->safe_value($options, 'fetchBalanceSnapshot', false);
        if ($fetchBalanceSnapshot) {
            $messageHash = $type . ':fetchBalanceSnapshot';
            if (!(is_array($client->futures) && array_key_exists($messageHash, $client->futures))) {
                $client->future ($messageHash);
                $this->spawn(array($this, 'load_balance_snapshot'), $client, $messageHash, $type);
            }
        } else {
            $this->balance[$type] = array();
        }
    }

    public function load_balance_snapshot($client, $messageHash, $type) {
        return Async\async(function () use ($client, $messageHash, $type) {
            $response = Async\await($this->fetch_balance(array( 'type' => $type )));
            $this->balance[$type] = array_merge($response, $this->safe_value($this->balance, $type, array()));
            // don't remove the $future from the .futures cache
            $future = $client->futures[$messageHash];
            $future->resolve ();
            $client->resolve ($this->balance[$type], $type . ':balance');
        }) ();
    }

    public function watch_balance($params = array ()) {
        return Async\async(function () use ($params) {
            /**
             * query for balance and get the amount of funds available for trading or funds locked in orders
             * @param {array} $params extra parameters specific to the binance api endpoint
             * @return {array} a ~@link https://docs.ccxt.com/en/latest/manual.html?#balance-structure balance structure~
             */
            Async\await($this->load_markets());
            Async\await($this->authenticate($params));
            $defaultType = $this->safe_string($this->options, 'defaultType', 'spot');
            $type = $this->safe_string($params, 'type', $defaultType);
            $subType = null;
            list($subType, $params) = $this->handle_sub_type_and_params('watchBalance', null, $params);
            if ($this->isLinear ($type, $subType)) {
                $type = 'future';
            } elseif ($this->isInverse ($type, $subType)) {
                $type = 'delivery';
            }
            $url = $this->urls['api']['ws'][$type] . '/' . $this->options[$type]['listenKey'];
            $client = $this->client($url);
            $this->set_balance_cache($client, $type);
            $options = $this->safe_value($this->options, 'watchBalance');
            $fetchBalanceSnapshot = $this->safe_value($options, 'fetchBalanceSnapshot', false);
            $awaitBalanceSnapshot = $this->safe_value($options, 'awaitBalanceSnapshot', true);
            if ($fetchBalanceSnapshot && $awaitBalanceSnapshot) {
                Async\await($client->future ($type . ':fetchBalanceSnapshot'));
            }
            $messageHash = $type . ':balance';
            $message = null;
            return Async\await($this->watch($url, $messageHash, $message, $type));
        }) ();
    }

    public function handle_balance(Client $client, $message) {
        //
        // sent upon a balance update not related to orders
        //
        //     {
        //         e => 'balanceUpdate',
        //         E => 1629352505586,
        //         a => 'IOTX',
        //         d => '0.43750000',
        //         T => 1629352505585
        //     }
        //
        // sent upon creating or filling an order
        //
        //     {
        //         "e" => "outboundAccountPosition", // Event type
        //         "E" => 1564034571105,             // Event Time
        //         "u" => 1564034571073,             // Time of last $account update
        //         "B" => array(                          // Balances Array
        //             {
        //                 "a" => "ETH",                 // Asset
        //                 "f" => "10000.000000",        // Free
        //                 "l" => "0.000000"             // Locked
        //             }
        //         )
        //     }
        //
        // future/delivery
        //
        //     {
        //         "e" => "ACCOUNT_UPDATE",            // Event Type
        //         "E" => 1564745798939,               // Event Time
        //         "T" => 1564745798938 ,              // Transaction
        //         "i" => "SfsR",                      // Account Alias
        //         "a" => {                            // Update Data
        //             "m":"ORDER",                  // Event reason type
        //             "B":array(                         // Balances
        //                 array(
        //                     "a":"BTC",                // Asset
        //                     "wb":"122624.12345678",   // Wallet Balance
        //                     "cw":"100.12345678"       // Cross Wallet Balance
        //                 ),
        //             ),
        //             "P":array(
        //                 array(
        //                     "s":"BTCUSD_200925",      // Symbol
        //                     "pa":"0",                 // Position Amount
        //                     "ep":"0.0",               // Entry Price
        //                     "cr":"200",               // (Pre-fee) Accumulated Realized
        //                     "up":"0",                 // Unrealized PnL
        //                     "mt":"isolated",          // Margin Type
        //                     "iw":"0.00000000",        // Isolated Wallet (if isolated position)
        //                     "ps":"BOTH"               // Position Side
        //                 ),
        //             )
        //         }
        //     }
        //
        $wallet = $this->safe_value($this->options, 'wallet', 'wb'); // cw for cross $wallet
        // each $account is connected to a different endpoint
        // and has exactly one subscriptionhash which is the $account type
        $subscriptions = is_array($client->subscriptions) ? array_keys($client->subscriptions) : array();
        $accountType = $subscriptions[0];
        $messageHash = $accountType . ':balance';
        $this->balance[$accountType]['info'] = $message;
        $event = $this->safe_string($message, 'e');
        if ($event === 'balanceUpdate') {
            $currencyId = $this->safe_string($message, 'a');
            $code = $this->safe_currency_code($currencyId);
            $account = $this->account();
            $delta = $this->safe_string($message, 'd');
            if (is_array($this->balance[$accountType]) && array_key_exists($code, $this->balance[$accountType])) {
                $previousValue = $this->balance[$accountType][$code]['free'];
                if (gettype($previousValue) !== 'string') {
                    $previousValue = $this->number_to_string($previousValue);
                }
                $account['free'] = Precise::string_add($previousValue, $delta);
            } else {
                $account['free'] = $delta;
            }
            $this->balance[$accountType][$code] = $account;
        } else {
            $message = $this->safe_value($message, 'a', $message);
            $B = $this->safe_value($message, 'B');
            for ($i = 0; $i < count($B); $i++) {
                $entry = $B[$i];
                $currencyId = $this->safe_string($entry, 'a');
                $code = $this->safe_currency_code($currencyId);
                $account = $this->account();
                $account['free'] = $this->safe_string($entry, 'f');
                $account['used'] = $this->safe_string($entry, 'l');
                $account['total'] = $this->safe_string($entry, $wallet);
                $this->balance[$accountType][$code] = $account;
            }
        }
        $timestamp = $this->safe_integer($message, 'E');
        $this->balance[$accountType]['timestamp'] = $timestamp;
        $this->balance[$accountType]['datetime'] = $this->iso8601($timestamp);
        $this->balance[$accountType] = $this->safe_balance($this->balance[$accountType]);
        $client->resolve ($this->balance[$accountType], $messageHash);
    }

    public function watch_orders(?string $symbol = null, ?int $since = null, ?int $limit = null, $params = array ()) {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            /**
             * watches information on multiple $orders made by the user
             * @param {string|null} $symbol unified $market $symbol of the $market $orders were made in
             * @param {int|null} $since the earliest time in ms to fetch $orders for
             * @param {int|null} $limit the maximum number of  orde structures to retrieve
             * @param {array} $params extra parameters specific to the binance api endpoint
             * @return {[array]} a list of ~@link https://docs.ccxt.com/#/?id=order-structure order structures~
             */
            Async\await($this->load_markets());
            $messageHash = 'orders';
            $market = null;
            if ($symbol !== null) {
                $market = $this->market($symbol);
                $symbol = $market['symbol'];
                $messageHash .= ':' . $symbol;
                $params = array_merge($params, array( 'symbol' => $symbol )); // needed inside authenticate for isolated margin
            }
            Async\await($this->authenticate($params));
            $type = null;
            list($type, $params) = $this->handle_market_type_and_params('watchOrders', $market, $params);
            $subType = null;
            list($subType, $params) = $this->handle_sub_type_and_params('watchOrders', $market, $params);
            if ($this->isLinear ($type, $subType)) {
                $type = 'future';
            } elseif ($this->isInverse ($type, $subType)) {
                $type = 'delivery';
            }
            $url = $this->urls['api']['ws'][$type] . '/' . $this->options[$type]['listenKey'];
            $client = $this->client($url);
            $this->set_balance_cache($client, $type);
            $message = null;
            $orders = Async\await($this->watch($url, $messageHash, $message, $type));
            if ($this->newUpdates) {
                $limit = $orders->getLimit ($symbol, $limit);
            }
            return $this->filter_by_symbol_since_limit($orders, $symbol, $since, $limit);
        }) ();
    }

    public function parse_ws_order($order, $market = null) {
        //
        // spot
        //
        //     {
        //         "e" => "executionReport",        // Event $type
        //         "E" => 1499405658658,            // Event time
        //         "s" => "ETHBTC",                 // Symbol
        //         "c" => "mUvoqJxFIILMdfAW5iGSOW", // Client $order ID
        //         "S" => "BUY",                    // Side
        //         "o" => "LIMIT",                  // Order $type
        //         "f" => "GTC",                    // Time in force
        //         "q" => "1.00000000",             // Order quantity
        //         "p" => "0.10264410",             // Order $price
        //         "P" => "0.00000000",             // Stop $price
        //         "F" => "0.00000000",             // Iceberg quantity
        //         "g" => -1,                       // OrderListId
        //         "C" => null,                     // Original client $order ID; This is the ID of the $order being canceled
        //         "x" => "NEW",                    // Current execution $type
        //         "X" => "NEW",                    // Current $order $status
        //         "r" => "NONE",                   // Order reject reason; will be an error code.
        //         "i" => 4293153,                  // Order ID
        //         "l" => "0.00000000",             // Last executed quantity
        //         "z" => "0.00000000",             // Cumulative $filled quantity
        //         "L" => "0.00000000",             // Last executed $price
        //         "n" => "0",                      // Commission $amount
        //         "N" => null,                     // Commission asset
        //         "T" => 1499405658657,            // Transaction time
        //         "t" => -1,                       // Trade ID
        //         "I" => 8641984,                  // Ignore
        //         "w" => true,                     // Is the $order on the book?
        //         "m" => false,                    // Is this trade the maker $side?
        //         "M" => false,                    // Ignore
        //         "O" => 1499405658657,            // Order creation time
        //         "Z" => "0.00000000",             // Cumulative quote asset transacted quantity
        //         "Y" => "0.00000000"              // Last quote asset transacted quantity (i.e. lastPrice * lastQty),
        //         "Q" => "0.00000000"              // Quote Order Qty
        //     }
        //
        // future
        //
        //     {
        //         "s":"BTCUSDT",                 // Symbol
        //         "c":"TEST",                    // Client Order Id
        //                                        // special client $order id:
        //                                        // starts with "autoclose-" => liquidation $order
        //                                        // "adl_autoclose" => ADL auto close $order
        //         "S":"SELL",                    // Side
        //         "o":"TRAILING_STOP_MARKET",    // Order Type
        //         "f":"GTC",                     // Time in Force
        //         "q":"0.001",                   // Original Quantity
        //         "p":"0",                       // Original Price
        //         "ap":"0",                      // Average Price
        //         "sp":"7103.04",                // Stop Price. Please ignore with TRAILING_STOP_MARKET $order
        //         "x":"NEW",                     // Execution Type
        //         "X":"NEW",                     // Order Status
        //         "i":8886774,                   // Order Id
        //         "l":"0",                       // Order Last Filled Quantity
        //         "z":"0",                       // Order Filled Accumulated Quantity
        //         "L":"0",                       // Last Filled Price
        //         "N":"USDT",                    // Commission Asset, will not push if no commission
        //         "n":"0",                       // Commission, will not push if no commission
        //         "T":1568879465651,             // Order Trade Time
        //         "t":0,                         // Trade Id
        //         "b":"0",                       // Bids Notional
        //         "a":"9.91",                    // Ask Notional
        //         "m":false,                     // Is this trade the maker $side?
        //         "R":false,                     // Is this reduce only
        //         "wt":"CONTRACT_PRICE",         // Stop Price Working Type
        //         "ot":"TRAILING_STOP_MARKET",   // Original Order Type
        //         "ps":"LONG",                   // Position Side
        //         "cp":false,                    // If Close-All, pushed with conditional $order
        //         "AP":"7476.89",                // Activation Price, only puhed with TRAILING_STOP_MARKET $order
        //         "cr":"5.0",                    // Callback Rate, only puhed with TRAILING_STOP_MARKET $order
        //         "rp":"0"                       // Realized Profit of the trade
        //     }
        //
        $executionType = $this->safe_string($order, 'x');
        $orderId = $this->safe_string($order, 'i');
        $marketId = $this->safe_string($order, 's');
        $marketType = (is_array($order) && array_key_exists('ps', $order)) ? 'contract' : 'spot';
        $symbol = $this->safe_symbol($marketId, null, null, $marketType);
        $timestamp = $this->safe_integer($order, 'O');
        $T = $this->safe_integer($order, 'T');
        $lastTradeTimestamp = null;
        if ($executionType === 'NEW') {
            if ($timestamp === null) {
                $timestamp = $T;
            }
        } elseif ($executionType === 'TRADE') {
            $lastTradeTimestamp = $T;
        }
        $fee = null;
        $feeCost = $this->safe_string($order, 'n');
        if (($feeCost !== null) && (Precise::string_gt($feeCost, '0'))) {
            $feeCurrencyId = $this->safe_string($order, 'N');
            $feeCurrency = $this->safe_currency_code($feeCurrencyId);
            $fee = array(
                'cost' => $feeCost,
                'currency' => $feeCurrency,
            );
        }
        $price = $this->safe_string($order, 'p');
        $amount = $this->safe_string($order, 'q');
        $side = $this->safe_string_lower($order, 'S');
        $type = $this->safe_string_lower($order, 'o');
        $filled = $this->safe_string($order, 'z');
        $cost = $this->safe_string($order, 'Z');
        $average = $this->safe_string($order, 'ap');
        $rawStatus = $this->safe_string($order, 'X');
        $status = $this->parse_order_status($rawStatus);
        $trades = null;
        $clientOrderId = $this->safe_string($order, 'C');
        if (($clientOrderId === null) || (strlen($clientOrderId) === 0)) {
            $clientOrderId = $this->safe_string($order, 'c');
        }
        $stopPrice = $this->safe_string_2($order, 'P', 'sp');
        $timeInForce = $this->safe_string($order, 'f');
        if ($timeInForce === 'GTX') {
            // GTX means "Good Till Crossing" and is an equivalent way of saying Post Only
            $timeInForce = 'PO';
        }
        return $this->safe_order(array(
            'info' => $order,
            'symbol' => $symbol,
            'id' => $orderId,
            'clientOrderId' => $clientOrderId,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'lastTradeTimestamp' => $lastTradeTimestamp,
            'type' => $type,
            'timeInForce' => $timeInForce,
            'postOnly' => null,
            'reduceOnly' => $this->safe_value($order, 'R'),
            'side' => $side,
            'price' => $price,
            'stopPrice' => $stopPrice,
            'triggerPrice' => $stopPrice,
            'amount' => $amount,
            'cost' => $cost,
            'average' => $average,
            'filled' => $filled,
            'remaining' => null,
            'status' => $status,
            'fee' => $fee,
            'trades' => $trades,
        ));
    }

    public function handle_order_update(Client $client, $message) {
        //
        // spot
        //
        //     {
        //         "e" => "executionReport",        // Event type
        //         "E" => 1499405658658,            // Event time
        //         "s" => "ETHBTC",                 // Symbol
        //         "c" => "mUvoqJxFIILMdfAW5iGSOW", // Client order ID
        //         "S" => "BUY",                    // Side
        //         "o" => "LIMIT",                  // Order type
        //         "f" => "GTC",                    // Time in force
        //         "q" => "1.00000000",             // Order quantity
        //         "p" => "0.10264410",             // Order price
        //         "P" => "0.00000000",             // Stop price
        //         "F" => "0.00000000",             // Iceberg quantity
        //         "g" => -1,                       // OrderListId
        //         "C" => null,                     // Original $client order ID; This is the ID of the order being canceled
        //         "x" => "NEW",                    // Current execution type
        //         "X" => "NEW",                    // Current order status
        //         "r" => "NONE",                   // Order reject reason; will be an error code.
        //         "i" => 4293153,                  // Order ID
        //         "l" => "0.00000000",             // Last executed quantity
        //         "z" => "0.00000000",             // Cumulative filled quantity
        //         "L" => "0.00000000",             // Last executed price
        //         "n" => "0",                      // Commission amount
        //         "N" => null,                     // Commission asset
        //         "T" => 1499405658657,            // Transaction time
        //         "t" => -1,                       // Trade ID
        //         "I" => 8641984,                  // Ignore
        //         "w" => true,                     // Is the order on the book?
        //         "m" => false,                    // Is this trade the maker side?
        //         "M" => false,                    // Ignore
        //         "O" => 1499405658657,            // Order creation time
        //         "Z" => "0.00000000",             // Cumulative quote asset transacted quantity
        //         "Y" => "0.00000000"              // Last quote asset transacted quantity (i.e. lastPrice * lastQty),
        //         "Q" => "0.00000000"              // Quote Order Qty
        //     }
        //
        // future
        //
        //     {
        //         "e":"ORDER_TRADE_UPDATE",           // Event Type
        //         "E":1568879465651,                  // Event Time
        //         "T":1568879465650,                  // Trasaction Time
        //         "o" => {
        //             "s":"BTCUSDT",                  // Symbol
        //             "c":"TEST",                     // Client Order Id
        //                                             // special $client order id:
        //                                             // starts with "autoclose-" => liquidation order
        //                                             // "adl_autoclose" => ADL auto close order
        //             "S":"SELL",                     // Side
        //             "o":"TRAILING_STOP_MARKET",     // Order Type
        //             "f":"GTC",                      // Time in Force
        //             "q":"0.001",                    // Original Quantity
        //             "p":"0",                        // Original Price
        //             "ap":"0",                       // Average Price
        //             "sp":"7103.04",                 // Stop Price. Please ignore with TRAILING_STOP_MARKET order
        //             "x":"NEW",                      // Execution Type
        //             "X":"NEW",                      // Order Status
        //             "i":8886774,                    // Order Id
        //             "l":"0",                        // Order Last Filled Quantity
        //             "z":"0",                        // Order Filled Accumulated Quantity
        //             "L":"0",                        // Last Filled Price
        //             "N":"USDT",                     // Commission Asset, will not push if no commission
        //             "n":"0",                        // Commission, will not push if no commission
        //             "T":1568879465651,              // Order Trade Time
        //             "t":0,                          // Trade Id
        //             "b":"0",                        // Bids Notional
        //             "a":"9.91",                     // Ask Notional
        //             "m":false,                      // Is this trade the maker side?
        //             "R":false,                      // Is this reduce only
        //             "wt":"CONTRACT_PRICE",          // Stop Price Working Type
        //             "ot":"TRAILING_STOP_MARKET",    // Original Order Type
        //             "ps":"LONG",                    // Position Side
        //             "cp":false,                     // If Close-All, pushed with conditional order
        //             "AP":"7476.89",                 // Activation Price, only puhed with TRAILING_STOP_MARKET order
        //             "cr":"5.0",                     // Callback Rate, only puhed with TRAILING_STOP_MARKET order
        //             "rp":"0"                        // Realized Profit of the trade
        //         }
        //     }
        //
        $e = $this->safe_string($message, 'e');
        if ($e === 'ORDER_TRADE_UPDATE') {
            $message = $this->safe_value($message, 'o', $message);
        }
        $this->handle_my_trade($client, $message);
        $this->handle_order($client, $message);
    }

    public function watch_my_trades(?string $symbol = null, ?int $since = null, ?int $limit = null, $params = array ()) {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            /**
             * watches information on multiple $trades made by the user
             * @param {string} $symbol unified market $symbol of the market orders were made in
             * @param {int|null} $since the earliest time in ms to fetch orders for
             * @param {int|null} $limit the maximum number of  orde structures to retrieve
             * @param {array} $params extra parameters specific to the binance api endpoint
             * @return {[array]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure
             */
            Async\await($this->load_markets());
            $defaultType = $this->safe_string_2($this->options, 'watchMyTrades', 'defaultType', 'spot');
            $type = $this->safe_string($params, 'type', $defaultType);
            $subType = null;
            list($subType, $params) = $this->handle_sub_type_and_params('watchMyTrades', null, $params);
            if ($this->isLinear ($type, $subType)) {
                $type = 'future';
            } elseif ($this->isInverse ($type, $subType)) {
                $type = 'delivery';
            }
            $messageHash = 'myTrades';
            if ($symbol !== null) {
                $symbol = $this->symbol($symbol);
                $messageHash .= ':' . $symbol;
                $params = array_merge($params, array( 'symbol' => $symbol ));
            }
            Async\await($this->authenticate($params));
            $url = $this->urls['api']['ws'][$type] . '/' . $this->options[$type]['listenKey'];
            $client = $this->client($url);
            $this->set_balance_cache($client, $type);
            $message = null;
            $trades = Async\await($this->watch($url, $messageHash, $message, $type));
            if ($this->newUpdates) {
                $limit = $trades->getLimit ($symbol, $limit);
            }
            return $this->filter_by_symbol_since_limit($trades, $symbol, $since, $limit);
        }) ();
    }

    public function handle_my_trade(Client $client, $message) {
        $messageHash = 'myTrades';
        $executionType = $this->safe_string($message, 'x');
        if ($executionType === 'TRADE') {
            $trade = $this->parse_trade($message);
            $orderId = $this->safe_string($trade, 'order');
            $tradeFee = $this->safe_value($trade, 'fee');
            $symbol = $this->safe_string($trade, 'symbol');
            if ($orderId !== null && $tradeFee !== null && $symbol !== null) {
                $cachedOrders = $this->orders;
                if ($cachedOrders !== null) {
                    $orders = $this->safe_value($cachedOrders->hashmap, $symbol, array());
                    $order = $this->safe_value($orders, $orderId);
                    if ($order !== null) {
                        // accumulate $order $fees
                        $fees = $this->safe_value($order, 'fees');
                        $fee = $this->safe_value($order, 'fee');
                        if ($fees !== null) {
                            $insertNewFeeCurrency = true;
                            for ($i = 0; $i < count($fees); $i++) {
                                $orderFee = $fees[$i];
                                if ($orderFee['currency'] === $tradeFee['currency']) {
                                    $feeCost = $this->sum($tradeFee['cost'], $orderFee['cost']);
                                    $order['fees'][$i]['cost'] = floatval($this->currency_to_precision($tradeFee['currency'], $feeCost));
                                    $insertNewFeeCurrency = false;
                                    break;
                                }
                            }
                            if ($insertNewFeeCurrency) {
                                $order['fees'][] = $tradeFee;
                            }
                        } elseif ($fee !== null) {
                            if ($fee['currency'] === $tradeFee['currency']) {
                                $feeCost = $this->sum($fee['cost'], $tradeFee['cost']);
                                $order['fee']['cost'] = floatval($this->currency_to_precision($tradeFee['currency'], $feeCost));
                            } elseif ($fee['currency'] === null) {
                                $order['fee'] = $tradeFee;
                            } else {
                                $order['fees'] = array( $fee, $tradeFee );
                                $order['fee'] = null;
                            }
                        } else {
                            $order['fee'] = $tradeFee;
                        }
                        // save this $trade in the $order
                        $orderTrades = $this->safe_value($order, 'trades', array());
                        $orderTrades[] = $trade;
                        $order['trades'] = $orderTrades;
                        // don't append twice cause it breaks newUpdates mode
                        // this $order already exists in the cache
                    }
                }
            }
            if ($this->myTrades === null) {
                $limit = $this->safe_integer($this->options, 'tradesLimit', 1000);
                $this->myTrades = new ArrayCacheBySymbolById ($limit);
            }
            $myTrades = $this->myTrades;
            $myTrades->append ($trade);
            $client->resolve ($this->myTrades, $messageHash);
            $messageHashSymbol = $messageHash . ':' . $symbol;
            $client->resolve ($this->myTrades, $messageHashSymbol);
        }
    }

    public function handle_order(Client $client, $message) {
        $messageHash = 'orders';
        $parsed = $this->parse_ws_order($message);
        $symbol = $this->safe_string($parsed, 'symbol');
        $orderId = $this->safe_string($parsed, 'id');
        if ($symbol !== null) {
            if ($this->orders === null) {
                $limit = $this->safe_integer($this->options, 'ordersLimit', 1000);
                $this->orders = new ArrayCacheBySymbolById ($limit);
            }
            $cachedOrders = $this->orders;
            $orders = $this->safe_value($cachedOrders->hashmap, $symbol, array());
            $order = $this->safe_value($orders, $orderId);
            if ($order !== null) {
                $fee = $this->safe_value($order, 'fee');
                if ($fee !== null) {
                    $parsed['fee'] = $fee;
                }
                $fees = $this->safe_value($order, 'fees');
                if ($fees !== null) {
                    $parsed['fees'] = $fees;
                }
                $parsed['trades'] = $this->safe_value($order, 'trades');
                $parsed['timestamp'] = $this->safe_integer($order, 'timestamp');
                $parsed['datetime'] = $this->safe_string($order, 'datetime');
            }
            $cachedOrders->append ($parsed);
            $client->resolve ($this->orders, $messageHash);
            $messageHashSymbol = $messageHash . ':' . $symbol;
            $client->resolve ($this->orders, $messageHashSymbol);
        }
    }

    public function handle_message(Client $client, $message) {
        $methods = array(
            'depthUpdate' => array($this, 'handle_order_book'),
            'trade' => array($this, 'handle_trade'),
            'aggTrade' => array($this, 'handle_trade'),
            'kline' => array($this, 'handle_ohlcv'),
            'markPrice_kline' => array($this, 'handle_ohlcv'),
            'indexPrice_kline' => array($this, 'handle_ohlcv'),
            '24hrTicker@arr' => array($this, 'handle_tickers'),
            '24hrMiniTicker@arr' => array($this, 'handle_tickers'),
            '24hrTicker' => array($this, 'handle_ticker'),
            '24hrMiniTicker' => array($this, 'handle_ticker'),
            'bookTicker' => array($this, 'handle_ticker'),
            'outboundAccountPosition' => array($this, 'handle_balance'),
            'balanceUpdate' => array($this, 'handle_balance'),
            'ACCOUNT_UPDATE' => array($this, 'handle_balance'),
            'executionReport' => array($this, 'handle_order_update'),
            'ORDER_TRADE_UPDATE' => array($this, 'handle_order_update'),
        );
        $event = $this->safe_string($message, 'e');
        if (gettype($message) === 'array' && array_keys($message) === array_keys(array_keys($message))) {
            $data = $message[0];
            $event = $this->safe_string($data, 'e') . '@arr';
        }
        $method = $this->safe_value($methods, $event);
        if ($method === null) {
            $requestId = $this->safe_string($message, 'id');
            if ($requestId !== null) {
                return $this->handle_subscription_status($client, $message);
            }
            // special case for the real-time bookTicker, since it comes without an $event identifier
            //
            //     {
            //         u => 7488717758,
            //         s => 'BTCUSDT',
            //         b => '28621.74000000',
            //         B => '1.43278800',
            //         a => '28621.75000000',
            //         A => '2.52500800'
            //     }
            //
            if ($event === null) {
                $this->handle_ticker($client, $message);
            }
        } else {
            return $method($client, $message);
        }
    }
}
