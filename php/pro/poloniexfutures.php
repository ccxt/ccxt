<?php

namespace ccxt\pro;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

use Exception; // a common import
use ccxt\ExchangeError;
use ccxt\BadRequest;
use ccxt\AuthenticationError;
use React\Async;

class poloniexfutures extends \ccxt\async\poloniexfutures {

    public function describe() {
        return $this->deep_extend(parent::describe(), array(
            'has' => array(
                'ws' => true,
                'watchOHLCV' => false,
                'watchOrderBook' => true,
                'watchTicker' => true,
                'watchTickers' => false,
                'watchTrades' => true,
                'watchBalance' => true,
                'watchOrders' => true,
                'watchMyTrades' => false,
                'watchPosition' => null,
                'watchPositions' => false,
            ),
            'urls' => array(
                'api' => array(
                    'ws' => 'wss://futures-apiws.poloniex.com/endpoint',
                ),
            ),
            'options' => array(
                'tradesLimit' => 1000,
                'ordersLimit' => 1000,
                'watchTicker' => array(
                    'method' => '/contractMarket/ticker', // can also be /contractMarket/snapshot
                ),
                'watchOrders' => array(
                    'method' => '/contractMarket/tradeOrders', // can also be /contractMarket/advancedOrders
                ),
                'watchOrderBook' => array(
                    'method' => '/contractMarket/level2', // can also be '/contractMarket/level3v2'
                    'snapshotDelay' => 5,
                    'maxRetries' => 3,
                ),
                'streamLimit' => 5, // called tunnels by poloniexfutures docs
                'streamBySubscriptionsHash' => array(),
                'streamIndex' => -1,
            ),
            'streaming' => array(
                'keepAlive' => 30000,
                'maxPingPongMisses' => 2.0,
            ),
        ));
    }

    public function negotiate($privateChannel, $params = array ()) {
        $connectId = $privateChannel ? 'private' : 'public';
        $urls = $this->safe_value($this->options, 'urls', array());
        if (is_array($urls) && array_key_exists($connectId, $urls)) {
            return $urls[$connectId];
        }
        // we store an awaitable to the url
        // so that multiple calls don't asynchronously
        // fetch different $urls and overwrite each other
        $urls[$connectId] = $this->spawn(array($this, 'negotiate_helper'), $privateChannel, $params);
        $this->options['urls'] = $urls;
        return $urls[$connectId];
    }

    public function negotiate_helper($privateChannel, $params = array ()) {
        return Async\async(function () use ($privateChannel, $params) {
            $response = null;
            $connectId = $privateChannel ? 'private' : 'public';
            if ($privateChannel) {
                $response = Async\await($this->privatePostBulletPrivate ($params));
                //
                //     {
                //         code => "200000",
                //         $data => {
                //             $instanceServers => array(
                //                 {
                //                     $pingInterval =>  50000,
                //                     $endpoint => "wss://push-private.kucoin.com/endpoint",
                //                     protocol => "websocket",
                //                     encrypt => true,
                //                     pingTimeout => 10000
                //                 }
                //             ),
                //             $token => "2neAiuYvAU61ZDXANAGAsiL4-iAExhsBXZxftpOeh_55i3Ysy2q2LEsEWU64mdzUOPusi34M_wGoSf7iNyEWJ1UQy47YbpY4zVdzilNP-Bj3iXzrjjGlWtiYB9J6i9GjsxUuhPw3BlrzazF6ghq4Lzf7scStOz3KkxjwpsOBCH4=.WNQmhZQeUKIkh97KYgU0Lg=="
                //         }
                //     }
                //
            } else {
                $response = Async\await($this->publicPostBulletPublic ($params));
            }
            $data = $this->safe_value($response, 'data', array());
            $instanceServers = $this->safe_value($data, 'instanceServers', array());
            $firstInstanceServer = $this->safe_value($instanceServers, 0);
            $pingInterval = $this->safe_integer($firstInstanceServer, 'pingInterval');
            $endpoint = $this->safe_string($firstInstanceServer, 'endpoint');
            $token = $this->safe_string($data, 'token');
            $result = $endpoint . '?' . $this->urlencode(array(
                'token' => $token,
                'privateChannel' => $privateChannel,
                'connectId' => $connectId,
            ));
            $client = $this->client($result);
            $client->keepAlive = $pingInterval;
            return $result;
        }) ();
    }

    public function request_id() {
        $requestId = $this->sum($this->safe_integer($this->options, 'requestId', 0), 1);
        $this->options['requestId'] = $requestId;
        return $requestId;
    }

    public function subscribe(string $name, bool $isPrivate, ?string $symbol = null, $subscription = null, $params = array ()) {
        return Async\async(function () use ($name, $isPrivate, $symbol, $subscription, $params) {
            /**
             * @ignore
             * Connects to a websocket channel
             * @param {string} $name name of the channel and suscriptionHash
             * @param {bool} $isPrivate true for the authenticated $url, false for the public $url
             * @param {string|null} $symbol is required for all public channels, not required for private channels (except position)
             * @param {Object} $subscription subscription parameters
             * @param {Object} $params extra parameters specific to the poloniex api
             * @return {Object} data from the websocket stream
             */
            $url = Async\await($this->negotiate($isPrivate));
            if ($symbol !== null) {
                $market = $this->market($symbol);
                $marketId = $market['id'];
                $name .= ':' . $marketId;
            }
            $messageHash = $name;
            $tunnelId = Async\await($this->stream($url, $messageHash));
            $requestId = $this->request_id();
            $subscribe = array(
                'id' => $requestId,
                'type' => 'subscribe',
                'topic' => $name,                 // Subscribed topic. Some topics support $subscribe to the data of multiple trading pairs through ",".
                'privateChannel' => $isPrivate,   // Adopt the private channel or not. Set by default.
                'response' => true,              // Whether the server needs to return the receipt information of this $subscription or not. Set by default.
                'tunnelId' => $tunnelId,
            );
            $subscriptionRequest = array(
                'id' => $requestId,
            );
            if ($subscription === null) {
                $subscription = $subscriptionRequest;
            } else {
                $subscription = array_merge($subscriptionRequest, $subscription);
            }
            $request = array_merge($subscribe, $params);
            return Async\await($this->watch($url, $messageHash, $request, $name, $subscriptionRequest));
        }) ();
    }

    public function on_close($client, $error) {
        $this->options['streamBySubscriptionsHash'] = array();
        parent::on_close($client, $error);
    }

    public function stream($url, $subscriptionHash) {
        return Async\async(function () use ($url, $subscriptionHash) {
            $streamBySubscriptionsHash = $this->safe_value($this->options, 'streamBySubscriptionsHash', array());
            $stream = $this->safe_string($streamBySubscriptionsHash, $subscriptionHash);
            if ($stream === null) {
                $streamIndex = $this->safe_integer($this->options, 'streamIndex', -1);
                $streamLimit = $this->safe_value($this->options, 'streamLimit');
                $streamIndex = $streamIndex + 1;
                $normalizedIndex = fmod($streamIndex, $streamLimit);
                $this->options['streamIndex'] = $streamIndex;
                $streamIndexString = $this->number_to_string($normalizedIndex);
                $stream = 'stream-' . $streamIndexString;
                $this->options['streamBySubscriptionsHash'][$subscriptionHash] = $stream;
                $messageHash = 'tunnel:' . $stream;
                $request = array(
                    'id' => $messageHash,
                    'type' => 'openTunnel',
                    'newTunnelId' => $stream,
                    'response' => true,
                );
                $subscription = array(
                    'id' => $messageHash,
                    'method' => array($this, 'handle_new_stream'),
                );
                Async\await($this->watch($url, $messageHash, $request, $messageHash, $subscription));
            }
            return $stream;
        }) ();
    }

    public function handle_order_book_subscription(Client $client, $message, $subscription) {
        $symbol = $this->safe_string($subscription, 'symbol');
        $limit = $this->safe_integer($subscription, 'limit');
        $this->orderbooks[$symbol] = $this->order_book(array(), $limit);
    }

    public function handle_subscription_status(Client $client, $message) {
        //
        //     {
        //         $id => '1578090438322',
        //         type => 'ack'
        //     }
        //
        $id = $this->safe_string($message, 'id');
        $subscriptionsById = $this->index_by($client->subscriptions, 'id');
        $subscription = $this->safe_value($subscriptionsById, $id, array());
        $method = $this->safe_value($subscription, 'method');
        if ($method !== null) {
            $method($client, $message, $subscription);
        }
        return $message;
    }

    public function handle_new_stream(Client $client, $message, $subscription) {
        //
        //    {
        //        "id" => "1545910840805",
        //        "type" => "ack"
        //    }
        //
        $messageHash = $this->safe_string($message, 'id');
        $client->resolve ($message, $messageHash);
    }

    public function watch_ticker(string $symbol, $params = array ()) {
        return Async\async(function () use ($symbol, $params) {
            /**
             * watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
             * @see https://futures-docs.poloniex.com/#get-real-time-$symbol-ticker
             * @param {string} $symbol unified $symbol of the market to fetch the ticker for
             * @param {array} $params extra parameters specific to the poloniexfutures api endpoint
             * @return {array} a {@link https://docs.ccxt.com/en/latest/manual.html#ticker-structure ticker structure}
             */
            Async\await($this->load_markets());
            $symbol = $this->symbol($symbol);
            $name = '/contractMarket/ticker';
            return Async\await($this->subscribe($name, false, $symbol, null, $params));
        }) ();
    }

    public function watch_trades(string $symbol, ?int $since = null, ?int $limit = null, $params = array ()) {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            /**
             * get the list of most recent $trades for a particular $symbol
             * @see https://futures-docs.poloniex.com/#full-matching-engine-data-level-3
             * @param {string} $symbol unified $symbol of the market to fetch $trades for
             * @param {int|null} $since timestamp in ms of the earliest trade to fetch
             * @param {int|null} $limit the maximum amount of $trades to fetch
             * @param {array} $params extra parameters specific to the poloniexfutures api endpoint
             * @return {[array]} a list of ~@link https://docs.ccxt.com/en/latest/manual.html?#public-$trades trade structures~
             */
            Async\await($this->load_markets());
            $options = $this->safe_value($this->options, 'watchTrades');
            $name = $this->safe_string($options, 'method', '/contractMarket/execution'); // can also be /contractMarket/snapshot
            list($name, $params) = $this->handle_option_and_params($params, 'method', 'name', $name);
            $symbol = $this->symbol($symbol);
            $trades = Async\await($this->subscribe($name, false, $symbol, null, $params));
            if ($this->newUpdates) {
                $limit = $trades->getLimit ($symbol, $limit);
            }
            return $this->filter_by_since_limit($trades, $since, $limit, 'timestamp');
        }) ();
    }

    public function watch_order_book(string $symbol, ?int $limit = null, $params = array ()) {
        return Async\async(function () use ($symbol, $limit, $params) {
            /**
             * watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
             * @see https://futures-docs.poloniex.com/#level-2-market-data
             * @param {string} $symbol unified $symbol of the market to fetch the order book for
             * @param {int|null} $limit not used by poloniexfutures watchOrderBook
             * @param {array} $params extra parameters specific to the poloniexfutures api endpoint
             * @param {string} $params->method the method to use. Defaults to /contractMarket/level2 can also be /contractMarket/level3v2 to receive the raw stream of orders
             * @return {array} A dictionary of {@link https://docs.ccxt.com/en/latest/manual.html#order-book-structure order book structures} indexed by market symbols
             */
            Async\await($this->load_markets());
            $options = $this->safe_value($this->options, 'watchOrderBook');
            $name = $this->safe_string($options, 'method', '/contractMarket/level2'); // can also be /contractMarket/level2, /contractMarket/level2Depth5:{$symbol}, /contractMarket/level2Depth50:{$symbol}
            list($name, $params) = $this->handle_option_and_params($params, 'method', 'name', $name);
            if ($name === '/contractMarket/level2' && $limit !== null) {
                if ($limit !== 5 && $limit !== 50) {
                    throw new BadRequest($this->id . ' watchOrderBook $limit argument must be none, 5 or 50 if using method /contractMarket/level2');
                }
                $name .= 'Depth' . $this->number_to_string($limit);
            }
            $subscription = array(
                'symbol' => $symbol,
                'limit' => $limit,
                'method' => array($this, 'handle_order_book_subscription'),
            );
            $orderbook = Async\await($this->subscribe($name, false, $symbol, $subscription, $params));
            return $orderbook->limit ();
        }) ();
    }

    public function watch_orders(?string $symbol = null, ?int $since = null, ?int $limit = null, $params = array ()) {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            /**
             * watches information on multiple $orders made by the user
             * @see https://futures-docs.poloniex.com/#private-messages
             * @param {string|null} $symbol filter by unified market $symbol of the market $orders were made in
             * @param {int|null} $since the earliest time in ms to fetch $orders for
             * @param {int|null} $limit the maximum number of  orde structures to retrieve
             * @param {array} $params extra parameters specific to the poloniexfutures api endpoint
             * @param {string} $params->method the method to use will default to /contractMarket/tradeOrders. Set to /contractMarket/advancedOrders to watch stop $orders
             * @return {[array]} a list of {@link https://docs.ccxt.com/en/latest/manual.html#order-structure order structures}
             */
            Async\await($this->load_markets());
            $options = $this->safe_value($this->options, 'watchOrders');
            $name = $this->safe_string($options, 'method', '/contractMarket/tradeOrders');
            $orders = Async\await($this->subscribe($name, true, null, null, $params));
            if ($this->newUpdates) {
                $limit = $orders->getLimit ($symbol, $limit);
            }
            $orders = $this->filter_by_symbol_since_limit($orders, $symbol, $since, $limit);
            if (strlen($orders) === 0) {
                return Async\await($this->watch_orders($symbol, $since, $limit, $params));
            }
            return $orders;
        }) ();
    }

    public function watch_balance($params = array ()) {
        return Async\async(function () use ($params) {
            /**
             * watches information on multiple orders made by the user
             * @see https://futures-docs.poloniex.com/#account-balance-events
             * @param {string|null} symbol not used by poloniexfutures watchBalance
             * @param {int|null} since not used by poloniexfutures watchBalance
             * @param {int|null} limit not used by poloniexfutures watchBalance
             * @param {array} $params extra parameters specific to the poloniexfutures api endpoint
             * @return {[array]} a list of {@link https://docs.ccxt.com/en/latest/manual.html#order-structure order structures}
             */
            Async\await($this->load_markets());
            $name = '/contractAccount/wallet';
            return Async\await($this->subscribe($name, true, null, null, $params));
        }) ();
    }

    public function handle_trade(Client $client, $message) {
        //
        //    {
        //        $data => array(
        //            makerUserId => "1410336",
        //            $symbol => "BTCUSDTPERP",
        //            sequence => 267913,
        //            side => "buy",
        //            size => 2,
        //            price => 28409.5,
        //            takerOrderId => "6426f9f15782c8000776995f",
        //            makerOrderId => "6426f9f141406b0008df976e",
        //            takerUserId => "1410880",
        //            tradeId => "6426f9f1de029f0001e334dd",
        //            ts => 1680275953739092500,
        //        ),
        //        subject => "match",
        //        topic => "/contractMarket/execution:BTCUSDTPERP",
        //        type => "message",
        //    }
        //
        $data = $this->safe_value($message, 'data', array());
        $marketId = $this->safe_string($data, 'symbol');
        if ($marketId !== null) {
            $trade = $this->parse_ws_trade($data);
            $symbol = $trade['symbol'];
            $messageHash = '/contractMarket/execution:' . $marketId;
            $stored = $this->safe_value($this->trades, $symbol);
            if ($stored === null) {
                $tradesLimit = $this->safe_integer($this->options, 'tradesLimit', 1000);
                $stored = new ArrayCache ($tradesLimit);
                $this->trades[$symbol] = $stored;
            }
            $stored->append ($trade);
            $client->resolve ($stored, $messageHash);
        }
        return $message;
    }

    public function parse_ws_trade($trade, $market = null) {
        //
        // handleTrade
        //
        //    {
        //        makerUserId => '1410880',
        //        symbol => 'BTCUSDTPERP',
        //        sequence => 731390,
        //        side => 'sell',
        //        size => 2,
        //        price => 29372.4,
        //        takerOrderId => '644ef0fdd64748000759218a',
        //        makerOrderId => '644ef0fd25f4a50007f12fc5',
        //        takerUserId => '1410880',
        //        tradeId => '644ef0fdde029f0001eec346',
        //        ts => 1682895101923194000
        //    }
        //
        $marketId = $this->safe_string($trade, 'symbol');
        $market = $this->safe_market($marketId, $market);
        $timestamp = $this->safe_integer_product($trade, 'ts', 0.000001);
        return $this->safe_trade(array(
            'info' => $trade,
            'id' => $this->safe_string($trade, 'tradeId'),
            'symbol' => $this->safe_string($market, 'symbol'),
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'order' => $this->safe_string_2($trade, 'takerOrderId', 'makerOrderId'),
            'type' => null,
            'side' => $this->safe_string($trade, 'side'),
            'takerOrMaker' => null,
            'price' => $this->safe_string($trade, 'price'),
            'amount' => $this->safe_string_2($trade, 'matchSize', 'size'),
            'cost' => null,
            'fee' => null,
        ), $market);
    }

    public function parse_ws_order_trade($trade, $market = null) {
        //
        //    {
        //        "symbol" => "BTC_USDT",
        //        "type" => "LIMIT",
        //        "quantity" => "1",
        //        "orderId" => "32471407854219264",
        //        "tradeFee" => "0",
        //        "clientOrderId" => "",
        //        "accountType" => "SPOT",
        //        "feeCurrency" => "",
        //        "eventType" => "place",
        //        "source" => "API",
        //        "side" => "BUY",
        //        "filledQuantity" => "0",
        //        "filledAmount" => "0",
        //        "matchRole" => "MAKER",
        //        "state" => "NEW",
        //        "tradeTime" => 0,
        //        "tradeAmount" => "0",
        //        "orderAmount" => "0",
        //        "createTime" => 1648708186922,
        //        "price" => "47112.1",
        //        "tradeQty" => "0",
        //        "tradePrice" => "0",
        //        "tradeId" => "0",
        //        "ts" => 1648708187469
        //    }
        //
        $timestamp = $this->safe_integer($trade, 'tradeTime');
        $marketId = $this->safe_string($trade, 'symbol');
        return $this->safe_trade(array(
            'info' => $trade,
            'id' => $this->safe_string($trade, 'tradeId'),
            'symbol' => $this->safe_symbol($marketId, $market),
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'order' => $this->safe_string($trade, 'orderId'),
            'type' => $this->safe_string_lower($trade, 'type'),
            'side' => $this->safe_string($trade, 'side'),
            'takerOrMaker' => $this->safe_string_lower($trade, 'matchRole'),
            'price' => $this->safe_string($trade, 'price'),
            'amount' => $this->safe_string($trade, 'tradeAmount'), // ? tradeQty?
            'cost' => null,
            'fee' => array(
                'rate' => null,
                'cost' => $this->safe_string($trade, 'tradeFee'),
                'currency' => $this->safe_string($trade, 'feeCurrency'),
            ),
        ), $market);
    }

    public function handle_order(Client $client, $message) {
        //
        //    {
        //        $data => array(
        //          symbol => 'ADAUSDTPERP',
        //          orderType => 'limit',
        //          side => 'buy',
        //          canceledSize => '1',
        //          orderId => '642b4d4c0494cd0007c76813',
        //          type => 'canceled',
        //          orderTime => '1680559436101909048',
        //          size => '1',
        //          filledSize => '0',
        //          marginType => 1,
        //          price => '0.25',
        //          remainSize => '0',
        //          clientOid => '112cbbf1-95a3-4917-957c-d3a87d81f853',
        //          status => 'done',
        //          ts => 1680559677560686600
        //        ),
        //        subject => 'orderChange',
        //        topic => '/contractMarket/tradeOrders',
        //        channelType => 'private',
        //        type => 'message',
        //        userId => '1139790'
        //    }
        // stop order
        //    {
        //        $data => array(
        //            orderType => 'stop',
        //            symbol => 'BTCUSDTPERP',
        //            side => 'buy',
        //            stopPriceType => 'TP',
        //            orderId => '64514fe1850d2100074378f6',
        //            type => 'open',
        //            createdAt => 1683050465847,
        //            stopPrice => '29000',
        //            size => 2,
        //            stop => 'up',
        //            marginType => 0,
        //            orderPrice => '28552.9',
        //            ts => 1683050465847597300
        //        ),
        //        subject => 'stopOrder',
        //        topic => '/contractMarket/advancedOrders',
        //        channelType => 'private',
        //        id => '64514fe1850d2100074378fa',
        //        type => 'message',
        //        userId => '1160396'
        //    }
        //
        $data = $this->safe_value($message, 'data', array());
        $orders = $this->orders;
        if ($orders === null) {
            $limit = $this->safe_integer($this->options, 'ordersLimit');
            $orders = new ArrayCacheBySymbolById ($limit);
            $this->orders = $orders;
        }
        $messageHash = '/contractMarket/tradeOrders';
        $parsed = $this->parse_ws_order($data);
        $orders->append ($parsed);
        $client->resolve ($orders, $messageHash);
        return $message;
    }

    public function parse_order_status(string $status, string $type) {
        /**
         * @ignore
         * @param {string} $status "match", "open", "done"
         * @param {string} $type "open", "match", "filled", "canceled", "update"
         * @return {string}
         */
        $types = array(
            'canceled' => 'canceled',
            'cancel' => 'canceled',
            'filled' => 'closed',
        );
        $parsedStatus = $this->safe_string($types, $type);
        if ($parsedStatus === null) {
            $statuses = array(
                'open' => 'open',
                'match' => 'open',
                'done' => 'closed',
            );
            $parsedStatus = $this->safe_string($statuses, $status, $status);
        }
        return $parsedStatus;
    }

    public function parse_ws_order($order, $market = null) {
        //
        //    {
        //        symbol => 'ADAUSDTPERP',
        //        orderType => 'limit',
        //        side => 'buy',
        //        canceledSize => '1',
        //        orderId => '642b4d4c0494cd0007c76813',
        //        type => 'canceled',
        //        orderTime => '1680559436101909048',
        //        size => '1',
        //        filledSize => '0',
        //        marginType => 1,
        //        price => '0.25',
        //        remainSize => '0',
        //        clientOid => '112cbbf1-95a3-4917-957c-d3a87d81f853',
        //        $status => 'done',
        //        ts => 1680559677560686600
        //    }
        // stop
        //    {
        //        orderType => 'stop',
        //        symbol => 'BTCUSDTPERP',
        //        side => 'buy',
        //        stopPriceType => 'TP',
        //        orderId => '64514fe1850d2100074378f6',
        //        type => 'open',
        //        createdAt => 1683050465847,
        //        stopPrice => '29000',
        //        size => 2,
        //        stop => 'up',
        //        marginType => 0,
        //        orderPrice => '28552.9',
        //        ts => 1683050465847597300
        //    }
        //
        $id = $this->safe_string($order, 'orderId');
        $clientOrderId = $this->safe_string($order, 'clientOid');
        $marketId = $this->safe_string($order, 'symbol');
        $timestamp = $this->safe_integer_product_2($order, 'orderTime', 'ts', 0.000001);
        $status = $this->safe_string($order, 'status');
        $messageType = $this->safe_string($order, 'type');
        return $this->safe_order(array(
            'info' => $order,
            'symbol' => $this->safe_symbol($marketId, $market),
            'id' => $id,
            'clientOrderId' => $clientOrderId,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'lastTradeTimestamp' => null,
            'type' => $this->safe_string($order, 'orderType'),
            'timeInForce' => null,
            'postOnly' => null,
            'side' => $this->safe_string($order, 'side'),
            'price' => $this->safe_string_2($order, 'price', 'orderPrice'),
            'stopPrice' => $this->safe_string($order, 'stopPrice'),
            'triggerPrice' => null,
            'amount' => $this->safe_string($order, 'size'),
            'cost' => null,
            'average' => null,
            'filled' => $this->safe_string($order, 'filledSize'),
            'remaining' => $this->safe_string($order, 'remainSize'),
            'status' => $this->parse_order_status($status, $messageType),
            'fee' => null,
            'trades' => null,
        ));
    }

    public function handle_ticker(Client $client, $message) {
        //
        //    {
        //        "subject" => "ticker",
        //        "topic" => "/contractMarket/ticker:BTCUSDTPERP",
        //        "data" => array(
        //            "symbol" => "BTCUSDTPERP",                   // Market of the $symbol
        //            "sequence" => 45,                            // Sequence number which is used to judge the continuity of the pushed messages
        //            "side" => "sell",                            // Transaction side of the last traded taker order
        //            "price" => 3600.00,                          // Filled price
        //            "size" => 16,                                // Filled quantity
        //            "tradeId" => "5c9dcf4170744d6f5a3d32fb",     // Order ID
        //            "bestBidSize" => 795,                        // Best bid size
        //            "bestBidPrice" => 3200.00,                   // Best bid
        //            "bestAskPrice" => 3600.00,                   // Best ask size
        //            "bestAskSize" => 284,                        // Best ask
        //            "ts" => 1553846081210004941                  // Filled time - nanosecond
        //        ),
        //        "type" => "message",
        //    }
        //
        //    {
        //        "topic" => "/contractMarket/snapshot:BTCUSDTPERP",
        //        "subject" => "snapshot.24h",
        //        "data" => {
        //            "volume" => 30449670,            //24h Volume
        //            "turnover" => 845169919063,      //24h Turnover
        //            "lastPrice" => 3551,           //Last price
        //            "priceChgPct" => 0.0043,         //24h Change
        //            "ts" => 1547697294838004923      //Snapshot time (nanosecond)
        //        }
        //    }
        //
        $data = $this->safe_value($message, 'data', array());
        $messageHash = $this->safe_string($message, 'topic');
        $symbol = $this->get_symbol_from_topic($messageHash);
        if ($symbol !== null) {
            $ticker = $this->parse_ticker($data);
            $this->tickers[$symbol] = $ticker;
            $client->resolve ($ticker, $messageHash);
        }
        return $message;
    }

    public function handle_l3_order_book(Client $client, $message) {
        //
        //    {
        //        data => array(
        //            symbol => 'BTCUSDTPERP',
        //            sequence => 1679593048010,
        //            orderId => '6426fec8586b9500089d64d8',
        //            clientOid => '14e6ee8e-8757-462c-84db-ed12c2b62f55',
        //            ts => 1680277192127513900
        //        ),
        //        $subject => 'received',
        //        topic => '/contractMarket/level3v2:BTCUSDTPERP',
        //        type => 'message'
        //    }
        //
        //    {
        //        data => array(
        //            symbol => 'BTCUSDTPERP',
        //            sequence => 1679593047982,
        //            side => 'sell',
        //            orderTime => '1680277191900131371',
        //            size => '1',
        //            orderId => '6426fec7d32b6e000790268b',
        //            price => '28376.4',
        //            ts => 1680277191939042300
        //        ),
        //        $subject => 'open',
        //        topic => '/contractMarket/level3v2:BTCUSDTPERP',
        //        type => 'message'
        //    }
        //
        //    {
        //        data => array(
        //            symbol => 'BTCUSDTPERP',
        //            reason => 'canceled',   // or 'filled'
        //            sequence => 1679593047983,
        //            orderId => '6426fec74026fa0008e7046f',
        //            ts => 1680277191949842000
        //        ),
        //        $subject => 'done',
        //        topic => '/contractMarket/level3v2:BTCUSDTPERP',
        //        type => 'message'
        //    }
        //
        $messageHash = $this->safe_string($message, 'topic');
        $subject = $this->safe_string($message, 'subject');
        if ($subject === 'received') {
            return $message;
        }
        // At the time of writting this, there is no implementation to easily convert each order into the orderbook so raw messages are returned
        $client->resolve ($message, $messageHash);
    }

    public function handle_level_2(Client $client, $message) {
        //    {
        //        "subject" => "level2",
        //        "topic" => "/contractMarket/level2:BTCUSDTPERP",
        //        "type" => "message",
        //        "data" => {
        //            "sequence" => 18,                   // Sequence number which is used to judge the continuity of pushed messages
        //            "change" => "5000.0,sell,83"        // Price, side, quantity
        //            "timestamp" => 1551770400000
        //        }
        //    }
        $topic = $this->safe_string($message, 'topic');
        $isSnapshot = mb_strpos($topic, 'Depth') !== false;
        if ($isSnapshot) {
            return $this->hande_l2_snapshot($client, $message);
        }
        return $this->handle_l2_order_book($client, $message);
    }

    public function handle_l2_order_book(Client $client, $message) {
        //
        //    {
        //        "id" => 1545910660740,
        //        "type" => "subscribe",
        //        "topic" => "/contractMarket/level2:BTCUSDTPERP",
        //        "response" => true
        //    }
        //
        //    {
        //        "subject" => "level2",
        //        "topic" => "/contractMarket/level2:BTCUSDTPERP",
        //        "type" => "message",
        //        "data" => {
        //            "sequence" => 18,                   // Sequence number which is used to judge the continuity of pushed messages
        //            "change" => "5000.0,sell,83"        // Price, side, quantity
        //            "timestamp" => 1551770400000
        //        }
        //    }
        //
        $data = $this->safe_value($message, 'data', array());
        $messageHash = $this->safe_string($message, 'topic', '');
        $symbol = $this->get_symbol_from_topic($messageHash);
        $orderBook = $this->safe_value($this->orderbooks, $symbol);
        if ($orderBook === null) {
            $this->orderbooks[$symbol] = $this->order_book(array());
            $orderBook = $this->orderbooks[$symbol];
            $orderBook['symbol'] = $symbol;
        }
        $nonce = $this->safe_integer($orderBook, 'nonce');
        if ($nonce === null) {
            $cacheLength = count($orderBook->cache);
            $snapshotDelay = $this->handle_option('watchOrderBook', 'snapshotDelay', 5);
            if ($cacheLength === $snapshotDelay) {
                $limit = 0;
                $this->spawn(array($this, 'load_order_book'), $client, $messageHash, $symbol, $limit);
            }
            $orderBook->cache[] = $data;
            return;
        }
        try {
            $this->handle_delta($orderBook, $data);
            $client->resolve ($orderBook, $messageHash);
        } catch (Exception $e) {
            unset($this->orderbooks[$symbol]);
            $client->reject ($e, $messageHash);
        }
    }

    public function hande_l2_snapshot(Client $client, $message) {
        //
        //    {
        //        "type" => "message",
        //        "topic" => "/contractMarket/level2Depth5:BTCUSDTPERP",
        //        "subject" => "level2",
        //        "data" => {
        //            "asks" => [
        //                ["9993", "3"],
        //                ["9992", "3"],
        //                ["9991", "47"],
        //                ["9990", "32"],
        //                ["9989", "8"]
        //            ],
        //            "bids" => [
        //                ["9988", "56"],
        //                ["9987", "15"],
        //                ["9986", "100"],
        //                ["9985", "10"],
        //                ["9984", "10"]
        //            ],
        //            "timestamp" => 1682993050531,
        //        }
        //    }
        //
        $data = $this->safe_value($message, 'data', array());
        $messageHash = $this->safe_string($message, 'topic', '');
        $symbol = $this->get_symbol_from_topic($messageHash);
        $timestamp = $this->safe_integer($data, 'timestamp');
        $snapshot = $this->parse_order_book($data, $symbol, $timestamp, 'bids', 'asks');
        $orderbook = $this->order_book($snapshot);
        $this->orderbooks[$symbol] = $orderbook;
        $client->resolve ($orderbook, $messageHash);
    }

    public function get_symbol_from_topic(string $topic) {
        $splitTopic = explode(':', $topic);
        $marketId = $this->safe_string($splitTopic, 1);
        return $this->safe_symbol($marketId);
    }

    public function get_cache_index($orderbook, $cache) {
        $firstDelta = $this->safe_value($cache, 0);
        $nonce = $this->safe_integer($orderbook, 'nonce');
        $firstDeltaSequence = $this->safe_integer($firstDelta, 'sequence');
        if ($firstDeltaSequence > $nonce + 1) {
            return -1;
        }
        for ($i = 0; $i < count($cache); $i++) {
            $delta = $cache[$i];
            $sequence = $this->safe_integer($delta, 'sequence');
            if ($nonce === $sequence - 1) {
                return $i;
            }
        }
        return count($cache);
    }

    public function handle_delta($orderbook, $delta) {
        //
        //    {
        //        "sequence" => 18,                   // Sequence number which is used to judge the continuity of pushed messages
        //        "change" => "5000.0,sell,83"        // Price, $side, quantity
        //        "timestamp" => 1551770400000
        //    }
        //
        $sequence = $this->safe_integer($delta, 'sequence');
        $nonce = $this->safe_integer($orderbook, 'nonce');
        if ($nonce !== $sequence - 1) {
            throw new ExchangeError($this->id . ' watchOrderBook received an out-of-order nonce');
        }
        $change = $this->safe_string($delta, 'change');
        $splitChange = explode(',', $change);
        $price = $this->safe_number($splitChange, 0);
        $side = $this->safe_string($splitChange, 1);
        $size = $this->safe_number($splitChange, 2);
        $timestamp = $this->safe_integer($delta, 'timestamp');
        $orderbook['timestamp'] = $timestamp;
        $orderbook['datetime'] = $this->iso8601($timestamp);
        $orderbook['nonce'] = $sequence;
        $orderBookSide = ($side === 'buy') ? $orderbook['bids'] : $orderbook['asks'];
        $orderBookSide->store ($price, $size);
    }

    public function handle_balance(Client $client, $message) {
        //
        //    {
        //        $data => array(
        //          $currency => 'USDT',
        //          availableBalance => '4.0000000000',
        //          timestamp => '1680557568670'
        //        ),
        //        subject => 'availableBalance.change',
        //        topic => '/contractAccount/wallet',
        //        channelType => 'private',
        //        id => '642b4600cae86800074b5ab7',
        //        type => 'message',
        //        userId => '1139790'
        //    }
        //
        //    {
        //        $data => array(
        //          $currency => 'USDT',
        //          orderMargin => '0.0000000000',
        //          timestamp => '1680558743307'
        //        ),
        //        subject => 'orderMargin.change',
        //        topic => '/contractAccount/wallet',
        //        channelType => 'private',
        //        id => '642b4a97b58e360007c3a237',
        //        type => 'message',
        //        userId => '1139790'
        //    }
        //
        $data = $this->safe_value($message, 'data', array());
        $messageHash = '/contractAccount/wallet';
        $currencyId = $this->safe_string($data, 'currency');
        $currency = $this->currency($currencyId);
        $code = $currency['code'];
        $this->balance[$code] = $this->parse_ws_balance($data);
        $client->resolve ($this->balance[$code], $messageHash);
        return $message;
    }

    public function parse_ws_balance($response) {
        //
        //    {
        //        currency => 'USDT',
        //        availableBalance => '4.0000000000',
        //        $timestamp => '1680557568670'
        //    }
        //
        //    {
        //        currency => 'USDT',
        //        orderMargin => '0.0000000000',
        //        $timestamp => '1680558743307'
        //    }
        //
        $timestamp = $this->safe_integer($response, 'timestamp');
        $result = array(
            'info' => $response,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
        );
        $currencyId = $this->safe_string($response, 'currency');
        $code = $this->safe_currency_code($currencyId);
        $newAccount = $this->account();
        $newAccount['free'] = $this->safe_string($response, 'availableBalance');
        $result[$code] = $newAccount;
        return $this->safe_balance($result);
    }

    public function handle_system_status(Client $client, $message) {
        //
        //     {
        //         id => '1578090234088', // connectId
        //         type => 'welcome',
        //     }
        //
        return $message;
    }

    public function handle_subject(Client $client, $message) {
        $subject = $this->safe_string($message, 'subject');
        $methods = array(
            'auth' => array($this, 'handle_authenticate'),
            'received' => array($this, 'handle_l3_order_book'),
            'open' => array($this, 'handle_l3_order_book'),
            'update' => array($this, 'handle_l3_order_book'),
            'done' => array($this, 'handle_l3_order_book'),
            'level2' => array($this, 'handle_level_2'),
            'ticker' => array($this, 'handle_ticker'),
            'snapshot.24h' => array($this, 'handle_ticker'),
            'match' => array($this, 'handle_trade'),
            'orderChange' => array($this, 'handle_order'),
            'stopOrder' => array($this, 'handle_order'),
            'availableBalance.change' => array($this, 'handle_balance'),
            'orderMargin.change' => array($this, 'handle_balance'),
        );
        $method = $this->safe_value($methods, $subject);
        if ($method !== null) {
            return $method($client, $message);
        }
    }

    public function ping(Client $client) {
        $id = (string) $this->request_id();
        return array(
            'id' => $id,
            'type' => 'ping',
        );
    }

    public function handle_pong(Client $client, $message) {
        $client->lastPong = $this->milliseconds();
        return $message;
    }

    public function handle_error_message(Client $client, $message) {
        //
        //    {
        //        code => 404,
        //        data => 'tunnel stream-0 is not exist',
        //        id => '3',
        //        type => 'error'
        //    }
        //
        $client->reject ($message);
    }

    public function handle_message(Client $client, $message) {
        $type = $this->safe_string($message, 'type');
        $methods = array(
            'welcome' => array($this, 'handle_system_status'),
            'ack' => array($this, 'handle_subscription_status'),
            'message' => array($this, 'handle_subject'),
            'pong' => array($this, 'handle_pong'),
            'error' => array($this, 'handle_error_message'),
        );
        $method = $this->safe_value($methods, $type);
        if ($method !== null) {
            return $method($client, $message);
        }
    }

    public function handle_authenticate($client, $message) {
        //
        //    {
        //        $success => true,
        //        ret_msg => '',
        //        op => 'auth',
        //        conn_id => 'ce3dpomvha7dha97tvp0-2xh'
        //    }
        //
        $data = $this->safe_value($message, 'data');
        $success = $this->safe_value($data, 'success');
        $messageHash = 'authenticated';
        if ($success) {
            $client->resolve ($message, $messageHash);
        } else {
            $error = new AuthenticationError ($this->id . ' ' . $this->json($message));
            $client->reject ($error, $messageHash);
            if (is_array($client->subscriptions) && array_key_exists($messageHash, $client->subscriptions)) {
                unset($client->subscriptions[$messageHash]);
            }
        }
        return $message;
    }
}
