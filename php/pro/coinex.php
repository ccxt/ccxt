<?php

namespace ccxt\pro;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

use Exception; // a common import
use ccxt\ExchangeError;
use ccxt\NotSupported;
use ccxt\Precise;
use React\Async;
use React\Promise\PromiseInterface;

class coinex extends \ccxt\async\coinex {

    public function describe() {
        return $this->deep_extend(parent::describe(), array(
            'has' => array(
                'ws' => true,
                'watchBalance' => true,
                'watchTicker' => true,
                'watchTickers' => true,
                'watchTrades' => true,
                'watchMyTrades' => false, // can query but can't subscribe
                'watchOrders' => true,
                'watchOrderBook' => true,
                'watchOHLCV' => true, // only for swap markets
                'fetchOHLCVWs' => true,
            ),
            'urls' => array(
                'api' => array(
                    'ws' => array(
                        'spot' => 'wss://socket.coinex.com/',
                        'swap' => 'wss://perpetual.coinex.com/',
                    ),
                ),
            ),
            'options' => array(
                'watchOHLCVWarning' => true,
                'timeframes' => array(
                    '1m' => 60,
                    '3m' => 180,
                    '5m' => 300,
                    '15m' => 900,
                    '30m' => 1800,
                    '1h' => 3600,
                    '2h' => 7200,
                    '4h' => 14400,
                    '6h' => 21600,
                    '12h' => 43200,
                    '1d' => 86400,
                    '3d' => 259200,
                    '1w' => 604800,
                ),
                'account' => 'spot',
                'watchOrderBook' => array(
                    'limits' => array( 5, 10, 20, 50 ),
                    'defaultLimit' => 50,
                    'aggregations' => array( '10', '1', '0', '0.1', '0.01' ),
                    'defaultAggregation' => '0',
                ),
            ),
            'streaming' => array(
            ),
            'exceptions' => array(
                'codes' => array(
                    '1' => '\\ccxt\\BadRequest', // Parameter error
                    '2' => '\\ccxt\\ExchangeError', // Internal error
                    '3' => '\\ccxt\\ExchangeNotAvailable', // Service unavailable
                    '4' => '\\ccxt\\NotSupported', // Method unavailable
                    '5' => '\\ccxt\\RequestTimeout', // Service timeout
                    '6' => '\\ccxt\\AuthenticationError', // Permission denied
                ),
            ),
        ));
    }

    public function request_id() {
        $requestId = $this->sum($this->safe_integer($this->options, 'requestId', 0), 1);
        $this->options['requestId'] = $requestId;
        return $requestId;
    }

    public function handle_ticker(Client $client, $message) {
        //
        //  spot
        //
        //     {
        //         "method" => "state.update",
        //         "params" => [{
        //             "BTCUSDT" => array(
        //                 "last" => "31577.89",
        //                 "open" => "29318.36",
        //                 "close" => "31577.89",
        //                 "high" => "32222.19",
        //                 "low" => "29317.21",
        //                 "volume" => "630.43024965",
        //                 "sell_total" => "13.66143951",
        //                 "buy_total" => "2.76410939",
        //                 "period" => 86400,
        //                 "deal" => "19457487.84611409070000000000"
        //             }
        //         )]
        //     }
        //
        //  swap
        //
        //     {
        //         "method" => "state.update",
        //         "params" => [{
        //             "BTCUSDT" => array(
        //                 "period" => 86400,
        //                 "funding_time" => 422,
        //                 "position_amount" => "285.6246",
        //                 "funding_rate_last" => "-0.00097933",
        //                 "funding_rate_next" => "0.00022519",
        //                 "funding_rate_predict" => "0.00075190",
        //                 "insurance" => "17474289.49925859030905338270",
        //                 "last" => "31570.08",
        //                 "sign_price" => "31568.09",
        //                 "index_price" => "31561.85000000",
        //                 "open" => "29296.11",
        //                 "close" => "31570.08",
        //                 "high" => "32463.40",
        //                 "low" => "29296.11",
        //                 "volume" => "8774.7318",
        //                 "deal" => "270675177.827928219109030017258398",
        //                 "sell_total" => "19.2230",
        //                 "buy_total" => "25.7814"
        //             }
        //         )]
        //     }
        //
        $defaultType = $this->safe_string($this->options, 'defaultType');
        $params = $this->safe_value($message, 'params', array());
        $rawTickers = $this->safe_value($params, 0, array());
        $keys = is_array($rawTickers) ? array_keys($rawTickers) : array();
        $newTickers = array();
        for ($i = 0; $i < count($keys); $i++) {
            $marketId = $keys[$i];
            $rawTicker = $rawTickers[$marketId];
            $symbol = $this->safe_symbol($marketId, null, null, $defaultType);
            $market = $this->safe_market($marketId, null, null, $defaultType);
            $parsedTicker = $this->parse_ws_ticker($rawTicker, $market);
            $this->tickers[$symbol] = $parsedTicker;
            $newTickers[] = $parsedTicker;
        }
        $messageHashes = $this->find_message_hashes($client, 'tickers::');
        for ($i = 0; $i < count($messageHashes); $i++) {
            $messageHash = $messageHashes[$i];
            $parts = explode('::', $messageHash);
            $symbolsString = $parts[1];
            $symbols = explode(',', $symbolsString);
            $tickers = $this->filter_by_array($newTickers, 'symbol', $symbols);
            $tickersSymbols = is_array($tickers) ? array_keys($tickers) : array();
            $numTickers = count($tickersSymbols);
            if ($numTickers > 0) {
                $client->resolve ($tickers, $messageHash);
            }
        }
        $client->resolve ($newTickers, 'tickers');
    }

    public function parse_ws_ticker($ticker, $market = null) {
        //
        //  spot
        //
        //     {
        //         "last" => "31577.89",
        //         "open" => "29318.36",
        //         "close" => "31577.89",
        //         "high" => "32222.19",
        //         "low" => "29317.21",
        //         "volume" => "630.43024965",
        //         "sell_total" => "13.66143951",
        //         "buy_total" => "2.76410939",
        //         "period" => 86400,
        //         "deal" => "19457487.84611409070000000000"
        //     }
        //
        //  swap
        //
        //     {
        //         "period" => 86400,
        //         "funding_time" => 422,
        //         "position_amount" => "285.6246",
        //         "funding_rate_last" => "-0.00097933",
        //         "funding_rate_next" => "0.00022519",
        //         "funding_rate_predict" => "0.00075190",
        //         "insurance" => "17474289.49925859030905338270",
        //         "last" => "31570.08",
        //         "sign_price" => "31568.09",
        //         "index_price" => "31561.85000000",
        //         "open" => "29296.11",
        //         "close" => "31570.08",
        //         "high" => "32463.40",
        //         "low" => "29296.11",
        //         "volume" => "8774.7318",
        //         "deal" => "270675177.827928219109030017258398",
        //         "sell_total" => "19.2230",
        //         "buy_total" => "25.7814"
        //     }
        //
        $defaultType = $this->safe_string($this->options, 'defaultType');
        return $this->safe_ticker(array(
            'symbol' => $this->safe_symbol(null, $market, null, $defaultType),
            'timestamp' => null,
            'datetime' => null,
            'high' => $this->safe_string($ticker, 'high'),
            'low' => $this->safe_string($ticker, 'low'),
            'bid' => null,
            'bidVolume' => $this->safe_string($ticker, 'buy_total'),
            'ask' => null,
            'askVolume' => $this->safe_string($ticker, 'sell_total'),
            'vwap' => null,
            'open' => $this->safe_string($ticker, 'open'),
            'close' => $this->safe_string($ticker, 'close'),
            'last' => $this->safe_string($ticker, 'last'),
            'previousClose' => null,
            'change' => null,
            'percentage' => null,
            'average' => null,
            'baseVolume' => $this->safe_string($ticker, 'volume'),
            'quoteVolume' => $this->safe_string($ticker, 'deal'),
            'info' => $ticker,
        ), $market);
    }

    public function watch_balance($params = array ()): PromiseInterface {
        return Async\async(function () use ($params) {
            /**
             * watch balance and get the amount of funds available for trading or funds locked in orders
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} a ~@link https://docs.ccxt.com/#/?id=balance-structure balance structure~
             */
            Async\await($this->load_markets());
            Async\await($this->authenticate($params));
            $messageHash = 'balance';
            $type = null;
            list($type, $params) = $this->handle_market_type_and_params('watchBalance', null, $params);
            $url = $this->urls['api']['ws'][$type];
            $currencies = is_array($this->currencies_by_id) ? array_keys($this->currencies_by_id) : array();
            $subscribe = array(
                'method' => 'asset.subscribe',
                'params' => $currencies,
                'id' => $this->request_id(),
            );
            $request = $this->deep_extend($subscribe, $params);
            return Async\await($this->watch($url, $messageHash, $request, $messageHash));
        }) ();
    }

    public function handle_balance(Client $client, $message) {
        //
        //     {
        //         "method" => "asset.update",
        //         "params" => array(
        //             {
        //                 "BTC" => {
        //                     "available" => "250",
        //                     "frozen" => "10",
        //                 }
        //             }
        //         ),
        //         "id" => null
        //     }
        //
        $params = $this->safe_value($message, 'params', array());
        $first = $this->safe_value($params, 0, array());
        $this->balance['info'] = $first;
        $currencies = is_array($first) ? array_keys($first) : array();
        for ($i = 0; $i < count($currencies); $i++) {
            $currencyId = $currencies[$i];
            $code = $this->safe_currency_code($currencyId);
            $available = $this->safe_string($first[$currencyId], 'available');
            $frozen = $this->safe_string($first[$currencyId], 'frozen');
            $account = $this->account();
            $account['free'] = $available;
            $account['used'] = $frozen;
            $this->balance[$code] = $account;
            $this->balance = $this->safe_balance($this->balance);
        }
        $messageHash = 'balance';
        $client->resolve ($this->balance, $messageHash);
    }

    public function handle_trades(Client $client, $message) {
        //
        //     {
        //         "method" => "deals.update",
        //         "params" => [
        //             "BTCUSD",
        //             [array(
        //                 "type" => "sell",
        //                 "time" => 1496458040.059284,
        //                 "price " => "46444.74",
        //                 "id" => 29433,
        //                 "amount" => "0.00120000"
        //             )]
        //         ],
        //         "id" => null
        //     }
        //
        $params = $this->safe_value($message, 'params', array());
        $marketId = $this->safe_string($params, 0);
        $trades = $this->safe_value($params, 1, array());
        $defaultType = $this->safe_string($this->options, 'defaultType');
        $market = $this->safe_market($marketId, null, null, $defaultType);
        $symbol = $market['symbol'];
        $messageHash = 'trades:' . $symbol;
        $stored = $this->safe_value($this->trades, $symbol);
        if ($stored === null) {
            $limit = $this->safe_integer($this->options, 'tradesLimit', 1000);
            $stored = new ArrayCache ($limit);
            $this->trades[$symbol] = $stored;
        }
        for ($i = 0; $i < count($trades); $i++) {
            $trade = $trades[$i];
            $parsed = $this->parse_ws_trade($trade, $market);
            $stored->append ($parsed);
        }
        $this->trades[$symbol] = $stored;
        $client->resolve ($this->trades[$symbol], $messageHash);
    }

    public function parse_ws_trade($trade, $market = null) {
        //
        //     {
        //         "type" => "sell",
        //         "time" => 1496458040.059284,
        //         "price " => "46444.74",
        //         "id" => 29433,
        //         "amount" => "0.00120000"
        //     }
        //
        $timestamp = $this->safe_timestamp($trade, 'time');
        $defaultType = $this->safe_string($this->options, 'defaultType');
        return $this->safe_trade(array(
            'id' => $this->safe_string($trade, 'id'),
            'info' => $trade,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'symbol' => $this->safe_symbol(null, $market, null, $defaultType),
            'order' => null,
            'type' => null,
            'side' => $this->safe_string($trade, 'type'),
            'takerOrMaker' => null,
            'price' => $this->safe_string($trade, 'price'),
            'amount' => $this->safe_string($trade, 'amount'),
            'cost' => null,
            'fee' => null,
        ), $market);
    }

    public function handle_ohlcv(Client $client, $message) {
        //
        //  spot
        //     {
        //         "error" => null,
        //         "result" => array(
        //           array(
        //             1673846940,
        //             "21148.74",
        //             "21148.38",
        //             "21148.75",
        //             "21138.66",
        //             "1.57060173",
        //             "33214.9138778914"
        //           ),
        //         )
        //         "id" => 1,
        //     }
        //  swap
        //     {
        //         "method" => "kline.update",
        //         "params" => array(
        //             array(
        //                 1654019640,   // timestamp
        //                 "32061.99",   // open
        //                 "32061.28",   // close
        //                 "32061.99",   // high
        //                 "32061.28",   // low
        //                 "0.1285",     // amount base
        //                 "4119.943736" // amount quote
        //             )
        //         ),
        //         "id" => null
        //     }
        //
        $candles = $this->safe_value_2($message, 'params', 'result', array());
        $messageHash = 'ohlcv';
        $id = $this->safe_string($message, 'id');
        $ohlcvs = $this->parse_ohlcvs($candles);
        if ($id !== null) {
            // spot subscription response
            $client->resolve ($ohlcvs, $messageHash);
            return;
        }
        $keys = is_array($this->ohlcvs) ? array_keys($this->ohlcvs) : array();
        $keysLength = count($keys);
        if ($keysLength === 0) {
            $limit = $this->safe_integer($this->options, 'OHLCVLimit', 1000);
            $this->ohlcvs = new ArrayCacheByTimestamp ($limit);
        }
        for ($i = 0; $i < count($ohlcvs); $i++) {
            $candle = $ohlcvs[$i];
            $this->ohlcvs.append ($candle);
        }
        $client->resolve ($this->ohlcvs, $messageHash);
    }

    public function watch_ticker(string $symbol, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $params) {
            /**
             * @see https://viabtc.github.io/coinex_api_en_doc/spot/#docsspot004_websocket007_state_subscribe
             * watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
             * @param {string} $symbol unified $symbol of the market to fetch the ticker for
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} a ~@link https://docs.ccxt.com/#/?id=ticker-structure ticker structure~
             */
            $tickers = Async\await($this->watch_tickers(array( $symbol ), $params));
            return $this->safe_value($tickers, $symbol);
        }) ();
    }

    public function watch_tickers(?array $symbols = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbols, $params) {
            /**
             * @see https://viabtc.github.io/coinex_api_en_doc/spot/#docsspot004_websocket007_state_subscribe
             * watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for all markets of a specific list
             * @param {string[]} $symbols unified symbol of the market to fetch the ticker for
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} a dictionary of ~@link https://docs.ccxt.com/#/?id=ticker-structure ticker structures~
             */
            Async\await($this->load_markets());
            $symbols = $this->market_symbols($symbols);
            $type = null;
            list($type, $params) = $this->handle_market_type_and_params('watchTickers', null, $params);
            $url = $this->urls['api']['ws'][$type];
            $messageHash = 'tickers';
            if ($symbols !== null) {
                $messageHash = 'tickers::' . implode(',', $symbols);
            }
            $subscribe = array(
                'method' => 'state.subscribe',
                'id' => $this->request_id(),
                'params' => array(),
            );
            $request = $this->deep_extend($subscribe, $params);
            $newTickers = Async\await($this->watch($url, $messageHash, $request, $messageHash));
            if ($this->newUpdates) {
                return $newTickers;
            }
            return $this->filter_by_array($this->tickers, 'symbol', $symbols);
        }) ();
    }

    public function watch_trades(string $symbol, ?int $since = null, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            /**
             * @see https://viabtc.github.io/coinex_api_en_doc/spot/#docsspot004_websocket012_deal_subcribe
             * @see https://viabtc.github.io/coinex_api_en_doc/futures/#docsfutures002_websocket019_deal_subcribe
             * get the list of most recent $trades for a particular $symbol
             * @param {string} $symbol unified $symbol of the $market to fetch $trades for
             * @param {int} [$since] timestamp in ms of the earliest trade to fetch
             * @param {int} [$limit] the maximum amount of $trades to fetch
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array[]} a list of ~@link https://docs.ccxt.com/#/?id=public-$trades trade structures~
             */
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $type = null;
            list($type, $params) = $this->handle_market_type_and_params('watchTrades', $market, $params);
            $url = $this->urls['api']['ws'][$type];
            $messageHash = 'trades:' . $symbol;
            $subscriptionHash = 'trades';
            $subscribedSymbols = $this->safe_value($this->options, 'watchTradesSubscriptions', array());
            $subscribedSymbols[] = $market['id'];
            $message = array(
                'method' => 'deals.subscribe',
                'params' => $subscribedSymbols,
                'id' => $this->request_id(),
            );
            $this->options['watchTradesSubscriptions'] = $subscribedSymbols;
            $request = $this->deep_extend($message, $params);
            $trades = Async\await($this->watch($url, $messageHash, $request, $subscriptionHash));
            return $this->filter_by_since_limit($trades, $since, $limit, 'timestamp', true);
        }) ();
    }

    public function watch_order_book(string $symbol, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $limit, $params) {
            /**
             * @see https://viabtc.github.io/coinex_api_en_doc/spot/#docsspot004_websocket017_depth_subscribe_multi
             * @see https://viabtc.github.io/coinex_api_en_doc/futures/#docsfutures002_websocket011_depth_subscribe_multi
             * watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
             * @param {string} $symbol unified $symbol of the $market to fetch the order book for
             * @param {int} [$limit] the maximum amount of order book entries to return
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} A dictionary of ~@link https://docs.ccxt.com/#/?id=order-book-structure order book structures~ indexed by $market symbols
             */
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $symbol = $market['symbol'];
            $type = null;
            list($type, $params) = $this->handle_market_type_and_params('watchOrderBook', $market, $params);
            $url = $this->urls['api']['ws'][$type];
            $name = 'orderbook';
            $messageHash = $name . ':' . $symbol;
            $options = $this->safe_value($this->options, 'watchOrderBook', array());
            $limits = $this->safe_value($options, 'limits', array());
            if ($limit === null) {
                $limit = $this->safe_value($options, 'defaultLimit', 50);
            }
            if (!$this->in_array($limit, $limits)) {
                throw new NotSupported($this->id . ' watchOrderBook() $limit must be one of ' . implode(', ', $limits));
            }
            $defaultAggregation = $this->safe_string($options, 'defaultAggregation', '0');
            $aggregations = $this->safe_value($options, 'aggregations', array());
            $aggregation = $this->safe_string($params, 'aggregation', $defaultAggregation);
            if (!$this->in_array($aggregation, $aggregations)) {
                throw new NotSupported($this->id . ' watchOrderBook() $aggregation must be one of ' . implode(', ', $aggregations));
            }
            $params = $this->omit($params, 'aggregation');
            $watchOrderBookSubscriptions = $this->safe_value($this->options, 'watchOrderBookSubscriptions', array());
            $watchOrderBookSubscriptions[$symbol] = [ $market['id'], $limit, $aggregation, true ];
            $subscribe = array(
                'method' => 'depth.subscribe_multi',
                'id' => $this->request_id(),
                'params' => is_array($watchOrderBookSubscriptions) ? array_values($watchOrderBookSubscriptions) : array(),
            );
            $this->options['watchOrderBookSubscriptions'] = $watchOrderBookSubscriptions;
            $subscriptionHash = $this->hash($this->encode($this->json($watchOrderBookSubscriptions)), 'sha256');
            $request = $this->deep_extend($subscribe, $params);
            $orderbook = Async\await($this->watch($url, $messageHash, $request, $subscriptionHash, $request));
            return $orderbook->limit ();
        }) ();
    }

    public function watch_ohlcv(string $symbol, $timeframe = '1m', ?int $since = null, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $timeframe, $since, $limit, $params) {
            /**
             * @see https://viabtc.github.io/coinex_api_en_doc/futures/#docsfutures002_websocket023_kline_subscribe
             * watches historical candlestick data containing the open, high, low, and close price, and the volume of a $market
             * @param {string} $symbol unified $symbol of the $market to fetch OHLCV data for
             * @param {string} $timeframe the length of time each candle represents
             * @param {int} [$since] timestamp in ms of the earliest candle to fetch
             * @param {int} [$limit] the maximum amount of candles to fetch
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {int[][]} A list of candles ordered, open, high, low, close, volume
             */
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $symbol = $market['symbol'];
            $type = null;
            list($type, $params) = $this->handle_market_type_and_params('watchOHLCV', $market, $params);
            if ($type !== 'swap') {
                throw new NotSupported($this->id . ' watchOHLCV() is only supported for swap markets. Try using fetchOHLCV () instead');
            }
            $url = $this->urls['api']['ws'][$type];
            $messageHash = 'ohlcv';
            $watchOHLCVWarning = $this->safe_value($this->options, 'watchOHLCVWarning', true);
            $client = $this->safe_value($this->clients, $url, array());
            $clientSub = $this->safe_value($client, 'subscriptions', array());
            $existingSubscription = $this->safe_value($clientSub, $messageHash);
            $subSymbol = $this->safe_string($existingSubscription, 'symbol');
            $subTimeframe = $this->safe_string($existingSubscription, 'timeframe');
            // due to nature of coinex response can only watch one $symbol at a time
            if ($watchOHLCVWarning && $existingSubscription !== null && ($subSymbol !== $symbol || $subTimeframe !== $timeframe)) {
                throw new ExchangeError($this->id . ' watchOHLCV() can only watch one $symbol and $timeframe at a time. To supress this warning set $watchOHLCVWarning to false in options');
            }
            $timeframes = $this->safe_value($this->options, 'timeframes', array());
            $subscribe = array(
                'method' => 'kline.subscribe',
                'id' => $this->request_id(),
                'params' => [
                    $market['id'],
                    $this->safe_integer($timeframes, $timeframe),
                ],
            );
            $subscription = array(
                'symbol' => $symbol,
                'timeframe' => $timeframe,
            );
            $request = $this->deep_extend($subscribe, $params);
            $ohlcvs = Async\await($this->watch($url, $messageHash, $request, $messageHash, $subscription));
            if ($this->newUpdates) {
                $limit = $ohlcvs->getLimit ($symbol, $limit);
            }
            return $this->filter_by_since_limit($ohlcvs, $since, $limit, 0);
        }) ();
    }

    public function fetch_ohlcv_ws($symbol, $timeframe = '1m', $since = null, $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $timeframe, $since, $limit, $params) {
            /**
             * @see https://viabtc.github.io/coinex_api_en_doc/spot/#docsspot004_websocket005_kline_query
             * $query historical candlestick data containing the open, high, low, and close price, and the volume of a $market
             * @param {string} $symbol unified $symbol of the $market to $query OHLCV data for
             * @param {string} $timeframe the length of time each candle represents
             * @param {int|null} $since timestamp in ms of the earliest candle to fetch
             * @param {int|null} $limit the maximum amount of candles to fetch
             * @param {array} $params extra parameters specific to the exchange API endpoint
             * @param {int|null} $params->end the end time for spot markets, $this->seconds() is set
             * @return {int[][]} A list of candles ordered, open, high, low, close, volume
             */
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            list($type, $query) = $this->handle_market_type_and_params('fetchOHLCV', $market, $params);
            $url = $this->urls['api']['ws'][$type];
            $symbol = $market['symbol'];
            $messageHash = 'ohlcv';
            $timeframes = $this->safe_value($this->options, 'timeframes', array());
            $timeframe = $this->safe_string($timeframes, $timeframe, $timeframe);
            if ($since === null) {
                $since = 1640995200;  // January 1, 2022
            }
            $id = $this->request_id();
            $subscribe = array(
                'method' => 'kline.query',
                'params' => [
                    $market['id'],
                    $this->parse_to_int($since / 1000),
                    $this->safe_integer($params, 'end', $this->seconds()),
                    $this->parse_to_int($timeframe),
                ],
                'id' => $id,
            );
            $subscription = array(
                'id' => $id,
                'future' => $messageHash,
            );
            $subscriptionHash = $id;
            $request = $this->deep_extend($subscribe, $query);
            $ohlcvs = Async\await($this->watch($url, $messageHash, $request, $subscriptionHash, $subscription));
            return $this->filter_by_since_limit($ohlcvs, $since, $limit, 0);
        }) ();
    }

    public function handle_delta($bookside, $delta) {
        $bidAsk = $this->parse_bid_ask($delta, 0, 1);
        $bookside->storeArray ($bidAsk);
    }

    public function handle_deltas($bookside, $deltas) {
        for ($i = 0; $i < count($deltas); $i++) {
            $this->handle_delta($bookside, $deltas[$i]);
        }
    }

    public function handle_order_book(Client $client, $message) {
        //
        //     {
        //         "method" => "depth.update",
        //         "params" => [
        //             false,
        //             array(
        //                 "asks" => [
        //                     ["46350.52", "1.07871851"],
        //                     ...
        //                 ],
        //                 "bids" => [
        //                     ["46349.61", "0.04000000"],
        //                     ...
        //                 ],
        //                 "last" => "46349.93",
        //                 "time" => 1639987469166,
        //                 "checksum" => 1533284725
        //             ),
        //             "BTCUSDT"
        //         ],
        //         "id" => null
        //     }
        //
        $params = $this->safe_value($message, 'params', array());
        $fullOrderBook = $this->safe_value($params, 0);
        $orderBook = $this->safe_value($params, 1);
        $marketId = $this->safe_string($params, 2);
        $defaultType = $this->safe_string($this->options, 'defaultType');
        $market = $this->safe_market($marketId, null, null, $defaultType);
        $symbol = $market['symbol'];
        $name = 'orderbook';
        $messageHash = $name . ':' . $symbol;
        $timestamp = $this->safe_integer($orderBook, 'time');
        $currentOrderBook = $this->safe_value($this->orderbooks, $symbol);
        if ($fullOrderBook) {
            $snapshot = $this->parse_order_book($orderBook, $symbol, $timestamp);
            if ($currentOrderBook === null) {
                $orderBook = $this->order_book($snapshot);
                $this->orderbooks[$symbol] = $orderBook;
            } else {
                $orderBook = $this->orderbooks[$symbol];
                $orderBook->reset ($snapshot);
            }
        } else {
            $asks = $this->safe_value($orderBook, 'asks', array());
            $bids = $this->safe_value($orderBook, 'bids', array());
            $this->handle_deltas($currentOrderBook['asks'], $asks);
            $this->handle_deltas($currentOrderBook['bids'], $bids);
            $currentOrderBook['nonce'] = $timestamp;
            $currentOrderBook['timestamp'] = $timestamp;
            $currentOrderBook['datetime'] = $this->iso8601($timestamp);
            $this->orderbooks[$symbol] = $currentOrderBook;
        }
        // $this->checkOrderBookChecksum ($this->orderbooks[$symbol]);
        $client->resolve ($this->orderbooks[$symbol], $messageHash);
    }

    public function watch_orders(?string $symbol = null, ?int $since = null, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            Async\await($this->load_markets());
            Async\await($this->authenticate($params));
            $messageHash = 'orders';
            $market = null;
            list($type, $query) = $this->handle_market_type_and_params('watchOrders', $market, $params);
            $message = array(
                'method' => 'order.subscribe',
                'id' => $this->request_id(),
            );
            if ($symbol !== null) {
                $market = $this->market($symbol);
                $symbol = $market['symbol'];
                $message['params'] = [ $market['id'] ];
                $messageHash .= ':' . $symbol;
            } else {
                $message['params'] = array();
            }
            $url = $this->urls['api']['ws'][$type];
            $request = $this->deep_extend($message, $query);
            $orders = Async\await($this->watch($url, $messageHash, $request, $messageHash, $request));
            if ($this->newUpdates) {
                $limit = $orders->getLimit ($symbol, $limit);
            }
            return $this->filter_by_symbol_since_limit($orders, $symbol, $since, $limit, true);
        }) ();
    }

    public function handle_orders(Client $client, $message) {
        //
        //  spot
        //
        //      {
        //          "method" => "order.update",
        //          "params" => array(
        //              1,
        //              {
        //                  "id" => 77782469357,
        //                  "type" => 1,
        //                  "side" => 2,
        //                  "user" => 1849116,
        //                  "account" => 0,
        //                  "option" => 2,
        //                  "ctime" => 1653961043.048967,
        //                  "mtime" => 1653961043.048967,
        //                  "market" => "BTCUSDT",
        //                  "source" => "web",
        //                  "client_id" => '',
        //                  "price" => "1.00",
        //                  "amount" => "1.00000000",
        //                  "taker_fee" => "0.0020",
        //                  "maker_fee" => "0.0020",
        //                  "left" => "1.00000000",
        //                  "deal_stock" => "0",
        //                  "deal_money" => "0",
        //                  "money_fee" => "0",
        //                  "stock_fee" => "0",
        //                  "asset_fee" => "0",
        //                  "fee_discount" => "1",
        //                  "last_deal_amount" => "0",
        //                  "last_deal_price" => "0",
        //                  "last_deal_time" => 0,
        //                  "last_deal_id" => 0,
        //                  "last_role" => 0,
        //                  "fee_asset" => null,
        //                  "stop_id" => 0
        //              }
        //          ),
        //          "id" => null
        //      }
        //
        //  swap
        //
        //      {
        //          "method" => "order.update",
        //          "params" => array(
        //              1,
        //              {
        //                  "order_id" => 23423462821,
        //                  "position_id" => 0,
        //                  "stop_id" => 0,
        //                  "market" => "BTCUSDT",
        //                  "type" => 1,
        //                  "side" => 2,
        //                  "target" => 0,
        //                  "effect_type" => 1,
        //                  "user_id" => 1849116,
        //                  "create_time" => 1653961509.25049,
        //                  "update_time" => 1653961509.25049,
        //                  "source" => "web",
        //                  "price" => "1.00",
        //                  "amount" => "1.0000",
        //                  "taker_fee" => "0.00050",
        //                  "maker_fee" => "0.00030",
        //                  "left" => "1.0000",
        //                  "deal_stock" => "0.00000000000000000000",
        //                  "deal_fee" => "0.00000000000000000000",
        //                  "deal_profit" => "0.00000000000000000000",
        //                  "last_deal_amount" => "0.00000000000000000000",
        //                  "last_deal_price" => "0.00000000000000000000",
        //                  "last_deal_time" => 0,
        //                  "last_deal_id" => 0,
        //                  "last_deal_type" => 0,
        //                  "last_deal_role" => 0,
        //                  "client_id" => '',
        //                  "fee_asset" => '',
        //                  "fee_discount" => "0.00000000000000000000",
        //                  "deal_asset_fee" => "0.00000000000000000000",
        //                  "leverage" => "3",
        //                  "position_type" => 2
        //              }
        //          ),
        //          "id" => null
        //      }
        //
        $params = $this->safe_value($message, 'params', array());
        $order = $this->safe_value($params, 1, array());
        $parsedOrder = $this->parse_ws_order($order);
        if ($this->orders === null) {
            $limit = $this->safe_integer($this->options, 'ordersLimit', 1000);
            $this->orders = new ArrayCacheBySymbolById ($limit);
        }
        $orders = $this->orders;
        $orders->append ($parsedOrder);
        $messageHash = 'orders';
        $client->resolve ($this->orders, $messageHash);
        $messageHash .= ':' . $parsedOrder['symbol'];
        $client->resolve ($this->orders, $messageHash);
    }

    public function parse_ws_order($order, $market = null) {
        //
        //  spot
        //
        //       {
        //           "id" => 77782469357,
        //           "type" => 1,
        //           "side" => 2,
        //           "user" => 1849116,
        //           "account" => 0,
        //           "option" => 2,
        //           "ctime" => 1653961043.048967,
        //           "mtime" => 1653961043.048967,
        //           "market" => "BTCUSDT",
        //           "source" => "web",
        //           "client_id" => '',
        //           "price" => "1.00",
        //           "amount" => "1.00000000",
        //           "taker_fee" => "0.0020",
        //           "maker_fee" => "0.0020",
        //           "left" => "1.00000000",
        //           "deal_stock" => "0",
        //           "deal_money" => "0",
        //           "money_fee" => "0",
        //           "stock_fee" => "0",
        //           "asset_fee" => "0",
        //           "fee_discount" => "1",
        //           "last_deal_amount" => "0",
        //           "last_deal_price" => "0",
        //           "last_deal_time" => 0,
        //           "last_deal_id" => 0,
        //           "last_role" => 0,
        //           "fee_asset" => null,
        //           "stop_id" => 0
        //       }
        //
        //  swap
        //
        //      {
        //          "order_id" => 23423462821,
        //          "position_id" => 0,
        //          "stop_id" => 0,
        //          "market" => "BTCUSDT",
        //          "type" => 1,
        //          "side" => 2,
        //          "target" => 0,
        //          "effect_type" => 1,
        //          "user_id" => 1849116,
        //          "create_time" => 1653961509.25049,
        //          "update_time" => 1653961509.25049,
        //          "source" => "web",
        //          "price" => "1.00",
        //          "amount" => "1.0000",
        //          "taker_fee" => "0.00050",
        //          "maker_fee" => "0.00030",
        //          "left" => "1.0000",
        //          "deal_stock" => "0.00000000000000000000",
        //          "deal_fee" => "0.00000000000000000000",
        //          "deal_profit" => "0.00000000000000000000",
        //          "last_deal_amount" => "0.00000000000000000000",
        //          "last_deal_price" => "0.00000000000000000000",
        //          "last_deal_time" => 0,
        //          "last_deal_id" => 0,
        //          "last_deal_type" => 0,
        //          "last_deal_role" => 0,
        //          "client_id" => '',
        //          "fee_asset" => '',
        //          "fee_discount" => "0.00000000000000000000",
        //          "deal_asset_fee" => "0.00000000000000000000",
        //          "leverage" => "3",
        //          "position_type" => 2
        //      }
        //
        //  $order->update_stop
        //
        //       {
        //           "id" => 78006745870,
        //           "type" => 1,
        //           "side" => 2,
        //           "user" => 1849116,
        //           "account" => 1,
        //           "option" => 70,
        //           "direction" => 1,
        //           "ctime" => 1654171725.131976,
        //           "mtime" => 1654171725.131976,
        //           "market" => "BTCUSDT",
        //           "source" => "web",
        //           "client_id" => '',
        //           "stop_price" => "1.00",
        //           "price" => "1.00",
        //           "amount" => "1.00000000",
        //           "taker_fee" => "0.0020",
        //           "maker_fee" => "0.0020",
        //           "fee_discount" => "1",
        //           "fee_asset" => null,
        //           "status" => 0
        //       }
        //
        $timestamp = $this->safe_timestamp_2($order, 'update_time', 'mtime');
        $marketId = $this->safe_string($order, 'market');
        $typeCode = $this->safe_string($order, 'type');
        $type = $this->safe_string(array(
            '1' => 'limit',
            '2' => 'market',
        ), $typeCode);
        $sideCode = $this->safe_string($order, 'side');
        $side = $this->safe_string(array(
            '1' => 'sell',
            '2' => 'buy',
        ), $sideCode);
        $remaining = $this->safe_string($order, 'left');
        $amount = $this->safe_string($order, 'amount');
        $status = $this->safe_string($order, 'status');
        $defaultType = $this->safe_string($this->options, 'defaultType');
        $market = $this->safe_market($marketId, $market, null, $defaultType);
        $cost = $this->safe_string($order, 'deal_money');
        $filled = $this->safe_string($order, 'deal_stock');
        $average = null;
        if ($market['swap']) {
            $leverage = $this->safe_string($order, 'leverage');
            $cost = Precise::string_div($filled, $leverage);
            $average = Precise::string_div($filled, $amount);
            $filled = null;
        }
        $fee = null;
        $feeCost = $this->omit_zero($this->safe_string($order, 'money_fee'));
        if ($feeCost !== null) {
            $feeCurrencyId = $this->safe_string($order, 'fee_asset', $market['quote']);
            $fee = array(
                'currency' => $this->safe_currency_code($feeCurrencyId),
                'cost' => $feeCost,
            );
        }
        return $this->safe_order(array(
            'info' => $order,
            'id' => $this->safe_string_2($order, 'order_id', 'id'),
            'clientOrderId' => $this->safe_string($order, 'client_id'),
            'datetime' => $this->iso8601($timestamp),
            'timestamp' => $timestamp,
            'lastTradeTimestamp' => $this->safe_timestamp($order, 'last_deal_time'),
            'symbol' => $market['symbol'],
            'type' => $type,
            'timeInForce' => null,
            'postOnly' => null,
            'side' => $side,
            'price' => $this->safe_string($order, 'price'),
            'stopPrice' => $this->safe_string($order, 'stop_price'),
            'triggerPrice' => $this->safe_string($order, 'stop_price'),
            'amount' => $amount,
            'filled' => $filled,
            'remaining' => $remaining,
            'cost' => $cost,
            'average' => $average,
            'status' => $this->parse_ws_order_status($status),
            'fee' => $fee,
            'trades' => null,
        ), $market);
    }

    public function parse_ws_order_status($status) {
        $statuses = array(
            '0' => 'pending',
            '1' => 'ok',
        );
        return $this->safe_string($statuses, $status, $status);
    }

    public function handle_message(Client $client, $message) {
        $error = $this->safe_value($message, 'error');
        if ($error !== null) {
            throw new ExchangeError($this->id . ' ' . $this->json($error));
        }
        $method = $this->safe_string($message, 'method');
        $handlers = array(
            'state.update' => array($this, 'handle_ticker'),
            'asset.update' => array($this, 'handle_balance'),
            'deals.update' => array($this, 'handle_trades'),
            'depth.update' => array($this, 'handle_order_book'),
            'order.update' => array($this, 'handle_orders'),
            'kline.update' => array($this, 'handle_ohlcv'),
            'order.update_stop' => array($this, 'handle_orders'),
        );
        $handler = $this->safe_value($handlers, $method);
        if ($handler !== null) {
            return $handler($client, $message);
        }
        return $this->handle_subscription_status($client, $message);
    }

    public function handle_authentication_message(Client $client, $message) {
        //
        //     {
        //         "error" => null,
        //         "result" => array(
        //             "status" => "success"
        //         ),
        //         "id" => 1
        //     }
        //
        $messageHashSpot = 'authenticated:spot';
        $messageHashSwap = 'authenticated:swap';
        $client->resolve ($message, $messageHashSpot);
        $client->resolve ($message, $messageHashSwap);
        return $message;
    }

    public function handle_subscription_status(Client $client, $message) {
        $id = $this->safe_integer($message, 'id');
        $subscription = $this->safe_value($client->subscriptions, $id);
        if ($subscription !== null) {
            $futureIndex = $this->safe_string($subscription, 'future');
            if ($futureIndex === 'ohlcv') {
                return $this->handle_ohlcv($client, $message);
            }
            $future = $this->safe_value($client->futures, $futureIndex);
            if ($future !== null) {
                $future->resolve (true);
            }
            unset($client->subscriptions[$id]);
        }
    }

    public function authenticate($params = array ()) {
        $type = null;
        list($type, $params) = $this->handle_market_type_and_params('authenticate', null, $params);
        $url = $this->urls['api']['ws'][$type];
        $client = $this->client($url);
        $time = $this->milliseconds();
        if ($type === 'spot') {
            $messageHash = 'authenticated:spot';
            $future = $this->safe_value($client->subscriptions, $messageHash);
            if ($future !== null) {
                return $future;
            }
            $requestId = $this->request_id();
            $subscribe = array(
                'id' => $requestId,
                'future' => 'authenticated:spot',
            );
            $signData = 'access_id=' . $this->apiKey . '&tonce=' . $this->number_to_string($time) . '&secret_key=' . $this->secret;
            $hash = $this->hash($this->encode($signData), 'md5');
            $request = array(
                'method' => 'server.sign',
                'params' => array(
                    $this->apiKey,
                    strtoupper($hash),
                    $time,
                ),
                'id' => $requestId,
            );
            $future = $this->watch($url, $messageHash, $request, $requestId, $subscribe);
            $client->subscriptions[$messageHash] = $future;
            return $future;
        } else {
            $messageHash = 'authenticated:swap';
            $future = $this->safe_value($client->subscriptions, $messageHash);
            if ($future !== null) {
                return $future;
            }
            $requestId = $this->request_id();
            $subscribe = array(
                'id' => $requestId,
                'future' => 'authenticated:swap',
            );
            $signData = 'access_id=' . $this->apiKey . '&timestamp=' . $this->number_to_string($time) . '&secret_key=' . $this->secret;
            $hash = $this->hash($this->encode($signData), 'sha256', 'hex');
            $request = array(
                'method' => 'server.sign',
                'params' => array(
                    $this->apiKey,
                    strtolower($hash),
                    $time,
                ),
                'id' => $requestId,
            );
            $future = $this->watch($url, $messageHash, $request, $requestId, $subscribe);
            $client->subscriptions[$messageHash] = $future;
            return $future;
        }
    }
}
