<?php

namespace ccxt\pro;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

use Exception; // a common import
use ccxt\AuthenticationError;
use ccxt\ArgumentsRequired;
use ccxt\NotSupported;
use ccxt\Precise;
use React\Async;
use React\Promise\PromiseInterface;

class vertex extends \ccxt\async\vertex {

    public function describe() {
        return $this->deep_extend(parent::describe(), array(
            'has' => array(
                'ws' => true,
                'watchBalance' => false,
                'watchMyTrades' => true,
                'watchOHLCV' => false,
                'watchOrderBook' => true,
                'watchOrders' => true,
                'watchTicker' => true,
                'watchTickers' => false,
                'watchTrades' => true,
                'watchTradesForSymbols' => false,
                'watchPositions' => true,
            ),
            'urls' => array(
                'api' => array(
                    'ws' => 'wss://gateway.prod.vertexprotocol.com/v1/subscribe',
                ),
                'test' => array(
                    'ws' => 'wss://gateway.sepolia-test.vertexprotocol.com/v1/subscribe',
                ),
            ),
            'requiredCredentials' => array(
                'apiKey' => false,
                'secret' => false,
                'walletAddress' => true,
                'privateKey' => true,
            ),
            'options' => array(
                'tradesLimit' => 1000,
                'ordersLimit' => 1000,
                'requestId' => array(),
                'watchPositions' => array(
                    'fetchPositionsSnapshot' => true, // or false
                    'awaitPositionsSnapshot' => true, // whether to wait for the positions snapshot before providing updates
                ),
                'ws' => array(
                    'inflate' => true,
                ),
            ),
            'streaming' => array(
                // 'ping' => array($this, 'ping'),
                'keepAlive' => 30000,
            ),
            'exceptions' => array(
                'ws' => array(
                    'exact' => array(
                        'Auth is needed.' => '\\ccxt\\AuthenticationError',
                    ),
                ),
            ),
        ));
    }

    public function request_id($url) {
        $options = $this->safe_dict($this->options, 'requestId', array());
        $previousValue = $this->safe_integer($options, $url, 0);
        $newValue = $this->sum($previousValue, 1);
        $this->options['requestId'][$url] = $newValue;
        return $newValue;
    }

    public function watch_public($messageHash, $message) {
        return Async\async(function () use ($messageHash, $message) {
            $url = $this->urls['api']['ws'];
            $requestId = $this->request_id($url);
            $subscribe = array(
                'id' => $requestId,
            );
            $request = $this->extend($subscribe, $message);
            $wsOptions = array(
                'headers' => array(
                    'Sec-WebSocket-Extensions' => 'permessage-deflate',
                ),
            );
            $this->options['ws'] = array(
                'options' => $wsOptions,
            );
            return Async\await($this->watch($url, $messageHash, $request, $messageHash, $subscribe));
        }) ();
    }

    public function watch_trades(string $symbol, ?int $since = null, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            /**
             * watches information on multiple $trades made in a $market
             *
             * @see https://docs.vertexprotocol.com/developer-resources/api/subscriptions/streams
             *
             * @param {string} $symbol unified $market $symbol of the $market $trades were made in
             * @param {int} [$since] the earliest time in ms to fetch $trades for
             * @param {int} [$limit] the maximum number of trade structures to retrieve
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array[]} a list of ~@link https://docs.ccxt.com/#/?id=trade-structure trade structures~
             */
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $name = 'trade';
            $topic = $market['id'] . '@' . $name;
            $request = array(
                'method' => 'subscribe',
                'stream' => array(
                    'type' => $name,
                    'product_id' => $this->parse_to_numeric($market['id']),
                ),
            );
            $message = $this->extend($request, $params);
            $trades = Async\await($this->watch_public($topic, $message));
            if ($this->newUpdates) {
                $limit = $trades->getLimit ($market['symbol'], $limit);
            }
            return $this->filter_by_symbol_since_limit($trades, $symbol, $since, $limit, true);
        }) ();
    }

    public function handle_trade(Client $client, $message) {
        //
        // {
        //     "type" => "trade",
        //     "timestamp" => "1676151190656903000", // timestamp of the event in nanoseconds
        //     "product_id" => 1,
        //     "price" => "1000", // price the $trade happened at, multiplied by 1e18
        //     // both taker_qty and maker_qty have the same value;
        //     // set to filled amount (min amount of taker and maker) when matching against book
        //     // set to matched amm base amount when matching against amm
        //     "taker_qty" => "1000",
        //     "maker_qty" => "1000",
        //     "is_taker_buyer" => true,
        //     "is_maker_amm" => true // true when maker is amm
        // }
        //
        $topic = $this->safe_string($message, 'type');
        $marketId = $this->safe_string($message, 'product_id');
        $trade = $this->parse_ws_trade($message);
        $symbol = $trade['symbol'];
        if (!(is_array($this->trades) && array_key_exists($symbol, $this->trades))) {
            $limit = $this->safe_integer($this->options, 'tradesLimit', 1000);
            $stored = new ArrayCache ($limit);
            $this->trades[$symbol] = $stored;
        }
        $trades = $this->trades[$symbol];
        $trades->append ($trade);
        $this->trades[$symbol] = $trades;
        $client->resolve ($trades, $marketId . '@' . $topic);
    }

    public function watch_my_trades(?string $symbol = null, ?int $since = null, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            /**
             * watches information on multiple $trades made by the user
             *
             * @see https://docs.vertexprotocol.com/developer-resources/api/subscriptions/streams
             *
             * @param {string} $symbol unified $market $symbol of the $market orders were made in
             * @param {int} [$since] the earliest time in ms to fetch orders for
             * @param {int} [$limit] the maximum number of order structures to retrieve
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @param {string} [$params->user] user address, will default to $this->walletAddress if not provided
             * @return {array[]} a list of ~@link https://docs.ccxt.com/#/?id=order-structure order structures~
             */
            if ($symbol === null) {
                throw new ArgumentsRequired($this->id . ' watchMyTrades requires a $symbol->');
            }
            Async\await($this->load_markets());
            $userAddress = null;
            list($userAddress, $params) = $this->handlePublicAddress ('watchMyTrades', $params);
            $market = $this->market($symbol);
            $name = 'fill';
            $topic = $market['id'] . '@' . $name;
            $request = array(
                'method' => 'subscribe',
                'stream' => array(
                    'type' => $name,
                    'product_id' => $this->parse_to_numeric($market['id']),
                    'subaccount' => $this->convertAddressToSender ($userAddress),
                ),
            );
            $message = $this->extend($request, $params);
            $trades = Async\await($this->watch_public($topic, $message));
            if ($this->newUpdates) {
                $limit = $trades->getLimit ($symbol, $limit);
            }
            return $this->filter_by_symbol_since_limit($trades, $symbol, $since, $limit, true);
        }) ();
    }

    public function handle_my_trades(Client $client, $message) {
        //
        // {
        //     "type" => "fill",
        //     "timestamp" => "1676151190656903000", // timestamp of the event in nanoseconds
        //     "product_id" => 1,
        //     // the subaccount that placed this order
        //     "subaccount" => "0x7a5ec2748e9065794491a8d29dcf3f9edb8d7c43746573743000000000000000",
        //     // hash of the order that uniquely identifies it
        //     "order_digest" => "0xf4f7a8767faf0c7f72251a1f9e5da590f708fd9842bf8fcdeacbaa0237958fff",
        //     // the amount filled, multiplied by 1e18
        //     "filled_qty" => "1000",
        //     // the amount outstanding unfilled, multiplied by 1e18
        //     "remaining_qty" => "2000",
        //     // the original order amount, multiplied by 1e18
        //     "original_qty" => "3000",
        //     // fill price
        //     "price" => "24991000000000000000000",
        //     // true for `taker`, false for `maker`
        //     "is_taker" => true,
        //     "is_bid" => true,
        //     // true when matching against amm
        //     "is_against_amm" => true,
        //     // an optional `order id` that can be provided when placing an order
        //     "id" => 100
        // }
        //
        $topic = $this->safe_string($message, 'type');
        $marketId = $this->safe_string($message, 'product_id');
        if ($this->myTrades === null) {
            $limit = $this->safe_integer($this->options, 'tradesLimit', 1000);
            $this->myTrades = new ArrayCacheBySymbolById ($limit);
        }
        $trades = $this->myTrades;
        $parsed = $this->parse_ws_trade($message);
        $trades->append ($parsed);
        $client->resolve ($trades, $marketId . '@' . $topic);
    }

    public function parse_ws_trade($trade, $market = null) {
        //
        // watchTrades
        // {
        //     "type" => "trade",
        //     "timestamp" => "1676151190656903000", // $timestamp of the event in nanoseconds
        //     "product_id" => 1,
        //     "price" => "1000", // $price the $trade happened at, multiplied by 1e18
        //     // both taker_qty and maker_qty have the same value;
        //     // set to filled $amount (min $amount of taker and maker) when matching against book
        //     // set to matched amm base $amount when matching against amm
        //     "taker_qty" => "1000",
        //     "maker_qty" => "1000",
        //     "is_taker_buyer" => true,
        //     "is_maker_amm" => true // true when maker is amm
        // }
        // watchMyTrades
        // {
        //     "type" => "fill",
        //     "timestamp" => "1676151190656903000", // $timestamp of the event in nanoseconds
        //     "product_id" => 1,
        //     // the subaccount that placed this order
        //     "subaccount" => "0x7a5ec2748e9065794491a8d29dcf3f9edb8d7c43746573743000000000000000",
        //     // hash of the order that uniquely identifies it
        //     "order_digest" => "0xf4f7a8767faf0c7f72251a1f9e5da590f708fd9842bf8fcdeacbaa0237958fff",
        //     // the $amount filled, multiplied by 1e18
        //     "filled_qty" => "1000",
        //     // the $amount outstanding unfilled, multiplied by 1e18
        //     "remaining_qty" => "2000",
        //     // the original order $amount, multiplied by 1e18
        //     "original_qty" => "3000",
        //     // fill $price
        //     "price" => "24991000000000000000000",
        //     // true for `taker`, false for `maker`
        //     "is_taker" => true,
        //     "is_bid" => true,
        //     // true when matching against amm
        //     "is_against_amm" => true,
        //     // an optional `order id` that can be provided when placing an order
        //     "id" => 100
        // }
        //
        $marketId = $this->safe_string($trade, 'product_id');
        $market = $this->safe_market($marketId, $market);
        $symbol = $market['symbol'];
        $price = $this->convertFromX18 ($this->safe_string($trade, 'price'));
        $amount = $this->convertFromX18 ($this->safe_string_2($trade, 'taker_qty', 'filled_qty'));
        $cost = Precise::string_mul($price, $amount);
        $timestamp = $this->safe_integer_product($trade, 'timestamp', 0.000001);
        $takerOrMaker = null;
        $isTaker = $this->safe_bool($trade, 'is_taker');
        if ($isTaker !== null) {
            $takerOrMaker = ($isTaker) ? 'taker' : 'maker';
        }
        $side = null;
        $isBid = $this->safe_bool($trade, 'is_bid');
        if ($isBid !== null) {
            $side = ($isBid) ? 'buy' : 'sell';
        }
        return $this->safe_trade(array(
            'id' => null,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'symbol' => $symbol,
            'side' => $side,
            'price' => $price,
            'amount' => $amount,
            'cost' => $cost,
            'order' => $this->safe_string_2($trade, 'digest', 'id'),
            'takerOrMaker' => $takerOrMaker,
            'type' => null,
            'fee' => null,
            'info' => $trade,
        ), $market);
    }

    public function watch_ticker(string $symbol, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $params) {
            /**
             *
             * @see https://docs.vertexprotocol.com/developer-resources/api/subscriptions/streams
             *
             * watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific $market
             * @param {string} $symbol unified $symbol of the $market to fetch the ticker for
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} a ~@link https://docs.ccxt.com/#/?id=ticker-structure ticker structure~
             */
            Async\await($this->load_markets());
            $name = 'best_bid_offer';
            $market = $this->market($symbol);
            $topic = $market['id'] . '@' . $name;
            $request = array(
                'method' => 'subscribe',
                'stream' => array(
                    'type' => $name,
                    'product_id' => $this->parse_to_numeric($market['id']),
                ),
            );
            $message = $this->extend($request, $params);
            return Async\await($this->watch_public($topic, $message));
        }) ();
    }

    public function parse_ws_ticker($ticker, $market = null) {
        //
        // {
        //     "type" => "best_bid_offer",
        //     "timestamp" => "1676151190656903000", // $timestamp of the event in nanoseconds
        //     "product_id" => 1,
        //     "bid_price" => "1000", // the highest bid price, multiplied by 1e18
        //     "bid_qty" => "1000", // quantity at the huighest bid, multiplied by 1e18.
        //                        // i.e. if this is USDC with 6 decimals, one USDC
        //                        // would be 1e12
        //     "ask_price" => "1000", // lowest ask price
        //     "ask_qty" => "1000" // quantity at the lowest ask
        // }
        //
        $timestamp = $this->safe_integer_product($ticker, 'timestamp', 0.000001);
        return $this->safe_ticker(array(
            'symbol' => $this->safe_symbol(null, $market),
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'high' => $this->safe_string($ticker, 'high'),
            'low' => $this->safe_string($ticker, 'low'),
            'bid' => $this->convertFromX18 ($this->safe_string($ticker, 'bid_price')),
            'bidVolume' => $this->convertFromX18 ($this->safe_string($ticker, 'bid_qty')),
            'ask' => $this->convertFromX18 ($this->safe_string($ticker, 'ask_price')),
            'askVolume' => $this->convertFromX18 ($this->safe_string($ticker, 'ask_qty')),
            'vwap' => null,
            'open' => null,
            'close' => null,
            'last' => null,
            'previousClose' => null,
            'change' => null,
            'percentage' => null,
            'average' => null,
            'baseVolume' => null,
            'quoteVolume' => null,
            'info' => $ticker,
        ), $market);
    }

    public function handle_ticker(Client $client, $message) {
        //
        // {
        //     "type" => "best_bid_offer",
        //     "timestamp" => "1676151190656903000", // timestamp of the event in nanoseconds
        //     "product_id" => 1,
        //     "bid_price" => "1000", // the highest bid price, multiplied by 1e18
        //     "bid_qty" => "1000", // quantity at the huighest bid, multiplied by 1e18.
        //                        // i.e. if this is USDC with 6 decimals, one USDC
        //                        // would be 1e12
        //     "ask_price" => "1000", // lowest ask price
        //     "ask_qty" => "1000" // quantity at the lowest ask
        // }
        //
        $marketId = $this->safe_string($message, 'product_id');
        $market = $this->safe_market($marketId);
        $ticker = $this->parse_ws_ticker($message, $market);
        $ticker['symbol'] = $market['symbol'];
        $this->tickers[$market['symbol']] = $ticker;
        $client->resolve ($ticker, $marketId . '@best_bid_offer');
        return $message;
    }

    public function watch_order_book(string $symbol, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $limit, $params) {
            /**
             *
             * @see https://docs.vertexprotocol.com/developer-resources/api/subscriptions/streams
             *
             * watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
             * @param {string} $symbol unified $symbol of the $market to fetch the order book for
             * @param {int} [$limit] the maximum amount of order book entries to return.
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} A dictionary of ~@link https://docs.ccxt.com/#/?id=order-book-structure order book structures~ indexed by $market symbols
             */
            Async\await($this->load_markets());
            $name = 'book_depth';
            $market = $this->market($symbol);
            $messageHash = $market['id'] . '@' . $name;
            $url = $this->urls['api']['ws'];
            $requestId = $this->request_id($url);
            $request = array(
                'id' => $requestId,
                'method' => 'subscribe',
                'stream' => array(
                    'type' => $name,
                    'product_id' => $this->parse_to_numeric($market['id']),
                ),
            );
            $subscription = array(
                'id' => (string) $requestId,
                'name' => $name,
                'symbol' => $symbol,
                'method' => array($this, 'handle_order_book_subscription'),
                'limit' => $limit,
                'params' => $params,
            );
            $message = $this->extend($request, $params);
            $orderbook = Async\await($this->watch($url, $messageHash, $message, $messageHash, $subscription));
            return $orderbook->limit ();
        }) ();
    }

    public function handle_order_book_subscription(Client $client, $message, $subscription) {
        $defaultLimit = $this->safe_integer($this->options, 'watchOrderBookLimit', 1000);
        $limit = $this->safe_integer($subscription, 'limit', $defaultLimit);
        $symbol = $this->safe_string($subscription, 'symbol'); // watchOrderBook
        if (is_array($this->orderbooks) && array_key_exists($symbol, $this->orderbooks)) {
            unset($this->orderbooks[$symbol]);
        }
        $this->orderbooks[$symbol] = $this->order_book(array(), $limit);
        $this->spawn(array($this, 'fetch_order_book_snapshot'), $client, $message, $subscription);
    }

    public function fetch_order_book_snapshot($client, $message, $subscription) {
        return Async\async(function () use ($client, $message, $subscription) {
            $symbol = $this->safe_string($subscription, 'symbol');
            $market = $this->market($symbol);
            $messageHash = $market['id'] . '@book_depth';
            try {
                $defaultLimit = $this->safe_integer($this->options, 'watchOrderBookLimit', 1000);
                $limit = $this->safe_integer($subscription, 'limit', $defaultLimit);
                $params = $this->safe_value($subscription, 'params');
                $snapshot = Async\await($this->fetch_rest_order_book_safe($symbol, $limit, $params));
                if ($this->safe_value($this->orderbooks, $symbol) === null) {
                    // if the $orderbook is dropped before the $snapshot is received
                    return;
                }
                $orderbook = $this->orderbooks[$symbol];
                $orderbook->reset ($snapshot);
                $messages = $orderbook->cache;
                for ($i = 0; $i < count($messages); $i++) {
                    $messageItem = $messages[$i];
                    $lastTimestamp = $this->parse_to_int(Precise::string_div($this->safe_string($messageItem, 'last_max_timestamp'), '1000000'));
                    if ($lastTimestamp < $orderbook['timestamp']) {
                        continue;
                    } else {
                        $this->handle_order_book_message($client, $messageItem, $orderbook);
                    }
                }
                $this->orderbooks[$symbol] = $orderbook;
                $client->resolve ($orderbook, $messageHash);
            } catch (Exception $e) {
                unset($client->subscriptions[$messageHash]);
                $client->reject ($e, $messageHash);
            }
        }) ();
    }

    public function handle_order_book(Client $client, $message) {
        //
        //
        // the feed does not include a snapshot, just the deltas
        //
        // {
        //     "type":"book_depth",
        //     // book depth aggregates a number of events once every 50ms
        //     // these are the minimum and maximum timestamps from
        //     // events that contributed to this response
        //     "min_timestamp" => "1683805381879572835",
        //     "max_timestamp" => "1683805381879572835",
        //     // the max_timestamp of the last book_depth event for this product
        //     "last_max_timestamp" => "1683805381771464799",
        //     "product_id":1,
        //     // changes to the bid side of the book in the form of [[price, new_qty]]
        //     "bids":[["21594490000000000000000","51007390115411548"]],
        //     // changes to the ask side of the book in the form of [[price, new_qty]]
        //     "asks":[["21694490000000000000000","0"],["21695050000000000000000","0"]]
        // }
        //
        $marketId = $this->safe_string($message, 'product_id');
        $market = $this->safe_market($marketId);
        $symbol = $market['symbol'];
        if (!(is_array($this->orderbooks) && array_key_exists($symbol, $this->orderbooks))) {
            $this->orderbooks[$symbol] = $this->order_book();
        }
        $orderbook = $this->orderbooks[$symbol];
        $timestamp = $this->safe_integer($orderbook, 'timestamp');
        if ($timestamp === null) {
            // Buffer the events you receive from the stream.
            $orderbook->cache[] = $message;
        } else {
            $lastTimestamp = $this->parse_to_int(Precise::string_div($this->safe_string($message, 'last_max_timestamp'), '1000000'));
            if ($lastTimestamp > $timestamp) {
                $this->handle_order_book_message($client, $message, $orderbook);
                $client->resolve ($orderbook, $marketId . '@book_depth');
            }
        }
    }

    public function handle_order_book_message(Client $client, $message, $orderbook) {
        $timestamp = $this->parse_to_int(Precise::string_div($this->safe_string($message, 'last_max_timestamp'), '1000000'));
        // convert from X18
        $data = array(
            'bids' => array(),
            'asks' => array(),
        );
        $bids = $this->safe_list($message, 'bids', array());
        for ($i = 0; $i < count($bids); $i++) {
            $bid = $bids[$i];
            $data['bids'][] = [
                $this->convertFromX18 ($bid[0]),
                $this->convertFromX18 ($bid[1]),
            ];
        }
        $asks = $this->safe_list($message, 'asks', array());
        for ($i = 0; $i < count($asks); $i++) {
            $ask = $asks[$i];
            $data['asks'][] = [
                $this->convertFromX18 ($ask[0]),
                $this->convertFromX18 ($ask[1]),
            ];
        }
        $this->handle_deltas($orderbook['asks'], $this->safe_list($data, 'asks', array()));
        $this->handle_deltas($orderbook['bids'], $this->safe_list($data, 'bids', array()));
        $orderbook['timestamp'] = $timestamp;
        $orderbook['datetime'] = $this->iso8601($timestamp);
        return $orderbook;
    }

    public function handle_delta($bookside, $delta) {
        $price = $this->safe_float($delta, 0);
        $amount = $this->safe_float($delta, 1);
        $bookside->store ($price, $amount);
    }

    public function handle_deltas($bookside, $deltas) {
        for ($i = 0; $i < count($deltas); $i++) {
            $this->handle_delta($bookside, $deltas[$i]);
        }
    }

    public function handle_subscription_status(Client $client, $message) {
        //
        //     {
        //         "result" => null,
        //         "id" => 1574649734450
        //     }
        //
        $id = $this->safe_string($message, 'id');
        $subscriptionsById = $this->index_by($client->subscriptions, 'id');
        $subscription = $this->safe_value($subscriptionsById, $id, array());
        $method = $this->safe_value($subscription, 'method');
        if ($method !== null) {
            $method($client, $message, $subscription);
        }
        return $message;
    }

    public function watch_positions(?array $symbols = null, ?int $since = null, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbols, $since, $limit, $params) {
            /**
             *
             * @see https://docs.vertexprotocol.com/developer-resources/api/subscriptions/streams
             *
             * watch all open positions
             * @param {string[]|null} $symbols list of unified $market $symbols
             * @param $since
             * @param $limit
             * @param {array} $params extra parameters specific to the exchange API endpoint
             * @param {string} [$params->user] user address, will default to $this->walletAddress if not provided
             * @return {array[]} a list of {@link https://docs.ccxt.com/en/latest/manual.html#position-structure position structure}
             */
            Async\await($this->load_markets());
            $symbols = $this->market_symbols($symbols);
            if (!$this->is_empty($symbols)) {
                if (strlen($symbols) > 1) {
                    throw new NotSupported($this->id . ' watchPositions require only one symbol.');
                }
            } else {
                throw new ArgumentsRequired($this->id . ' watchPositions require one symbol.');
            }
            $userAddress = null;
            list($userAddress, $params) = $this->handlePublicAddress ('watchPositions', $params);
            $url = $this->urls['api']['ws'];
            $client = $this->client($url);
            $this->set_positions_cache($client, $symbols, $params);
            $fetchPositionsSnapshot = $this->handle_option('watchPositions', 'fetchPositionsSnapshot', true);
            $awaitPositionsSnapshot = $this->handle_option('watchPositions', 'awaitPositionsSnapshot', true);
            if ($fetchPositionsSnapshot && $awaitPositionsSnapshot && $this->positions === null) {
                $snapshot = Async\await($client->future ('fetchPositionsSnapshot'));
                return $this->filter_by_symbols_since_limit($snapshot, $symbols, $since, $limit, true);
            }
            $name = 'position_change';
            $market = $this->market($symbols[0]);
            $topic = $market['id'] . '@' . $name;
            $request = array(
                'method' => 'subscribe',
                'stream' => array(
                    'type' => $name,
                    'product_id' => $this->parse_to_numeric($market['id']),
                    'subaccount' => $this->convertAddressToSender ($userAddress),
                ),
            );
            $message = $this->extend($request, $params);
            $newPositions = Async\await($this->watch_public($topic, $message));
            if ($this->newUpdates) {
                $limit = $newPositions->getLimit ($symbols[0], $limit);
            }
            return $this->filter_by_symbols_since_limit($this->positions, $symbols, $since, $limit, true);
        }) ();
    }

    public function set_positions_cache(Client $client, ?array $symbols = null, $params = array ()) {
        $fetchPositionsSnapshot = $this->handle_option('watchPositions', 'fetchPositionsSnapshot', false);
        if ($fetchPositionsSnapshot) {
            $messageHash = 'fetchPositionsSnapshot';
            if (!(is_array($client->futures) && array_key_exists($messageHash, $client->futures))) {
                $client->future ($messageHash);
                $this->spawn(array($this, 'load_positions_snapshot'), $client, $messageHash, $symbols, $params);
            }
        } else {
            $this->positions = new ArrayCacheBySymbolBySide ();
        }
    }

    public function load_positions_snapshot($client, $messageHash, $symbols, $params) {
        return Async\async(function () use ($client, $messageHash, $symbols, $params) {
            $positions = Async\await($this->fetch_positions($symbols, $params));
            $this->positions = new ArrayCacheBySymbolBySide ();
            $cache = $this->positions;
            for ($i = 0; $i < count($positions); $i++) {
                $position = $positions[$i];
                $cache->append ($position);
            }
            // don't remove the $future from the .futures $cache
            $future = $client->futures[$messageHash];
            $future->resolve ($cache);
            $client->resolve ($cache, 'positions');
        }) ();
    }

    public function handle_positions($client, $message) {
        //
        // {
        //     "type":"position_change",
        //     "timestamp" => "1676151190656903000", // timestamp of event in nanoseconds
        //     "product_id":1,
        //      // whether this is a $position change for the LP token for this product
        //     "is_lp":false,
        //     // subaccount who's $position changed
        //     "subaccount":"0x7a5ec2748e9065794491a8d29dcf3f9edb8d7c43706d00000000000000000000",
        //     // new amount for this product
        //     "amount":"51007390115411548",
        //     // new quote balance for this product; zero for everything except non lp perps
        //     // the negative of the entry cost of the perp
        //     "v_quote_amount":"0"
        // }
        //
        if ($this->positions === null) {
            $this->positions = new ArrayCacheBySymbolBySide ();
        }
        $cache = $this->positions;
        $topic = $this->safe_string($message, 'type');
        $marketId = $this->safe_string($message, 'product_id');
        $market = $this->safe_market($marketId);
        $position = $this->parse_ws_position($message, $market);
        $cache->append ($position);
        $client->resolve ($position, $marketId . '@' . $topic);
    }

    public function parse_ws_position($position, $market = null) {
        //
        // {
        //     "type":"position_change",
        //     "timestamp" => "1676151190656903000", // $timestamp of event in nanoseconds
        //     "product_id":1,
        //      // whether this is a $position change for the LP token for this product
        //     "is_lp":false,
        //     // subaccount who's $position changed
        //     "subaccount":"0x7a5ec2748e9065794491a8d29dcf3f9edb8d7c43706d00000000000000000000",
        //     // new amount for this product
        //     "amount":"51007390115411548",
        //     // new quote balance for this product; zero for everything except non lp perps
        //     // the negative of the entry cost of the perp
        //     "v_quote_amount":"0"
        // }
        //
        $marketId = $this->safe_string($position, 'product_id');
        $market = $this->safe_market($marketId);
        $contractSize = $this->convertFromX18 ($this->safe_string($position, 'amount'));
        $side = 'buy';
        if (Precise::string_lt($contractSize, '1')) {
            $side = 'sell';
        }
        $timestamp = $this->parse_to_int(Precise::string_div($this->safe_string($position, 'timestamp'), '1000000'));
        return $this->safe_position(array(
            'info' => $position,
            'id' => null,
            'symbol' => $this->safe_string($market, 'symbol'),
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'lastUpdateTimestamp' => null,
            'initialMargin' => null,
            'initialMarginPercentage' => null,
            'maintenanceMargin' => null,
            'maintenanceMarginPercentage' => null,
            'entryPrice' => null,
            'notional' => null,
            'leverage' => null,
            'unrealizedPnl' => null,
            'contracts' => null,
            'contractSize' => $this->parse_number($contractSize),
            'marginRatio' => null,
            'liquidationPrice' => null,
            'markPrice' => null,
            'lastPrice' => null,
            'collateral' => null,
            'marginMode' => 'cross',
            'marginType' => null,
            'side' => $side,
            'percentage' => null,
            'hedged' => null,
            'stopLossPrice' => null,
            'takeProfitPrice' => null,
        ));
    }

    public function handle_auth(Client $client, $message) {
        //
        // array( result => null, id => 1 )
        //
        $messageHash = 'authenticated';
        $error = $this->safe_string($message, 'error');
        if ($error === null) {
            // $client->resolve ($message, $messageHash);
            $future = $this->safe_value($client->futures, 'authenticated');
            $future->resolve (true);
        } else {
            $authError = new AuthenticationError ($this->json($message));
            $client->reject ($authError, $messageHash);
            // allows further authentication attempts
            if (is_array($client->subscriptions) && array_key_exists($messageHash, $client->subscriptions)) {
                unset($client->subscriptions['authenticated']);
            }
        }
    }

    public function build_ws_authentication_sig($message, $chainId, $verifyingContractAddress) {
        $messageTypes = array(
            'StreamAuthentication' => array(
                array( 'name' => 'sender', 'type' => 'bytes32' ),
                array( 'name' => 'expiration', 'type' => 'uint64' ),
            ),
        );
        return $this->buildSig ($chainId, $messageTypes, $message, $verifyingContractAddress);
    }

    public function authenticate($params = array ()) {
        return Async\async(function () use ($params) {
            $this->check_required_credentials();
            $url = $this->urls['api']['ws'];
            $client = $this->client($url);
            $messageHash = 'authenticated';
            $future = $client->future ($messageHash);
            $authenticated = $this->safe_value($client->subscriptions, $messageHash);
            if ($authenticated === null) {
                $requestId = $this->request_id($url);
                $contracts = Async\await($this->queryContracts ());
                $chainId = $this->safe_string($contracts, 'chain_id');
                $verifyingContractAddress = $this->safe_string($contracts, 'endpoint_addr');
                $now = $this->nonce();
                $nonce = $now + 90000;
                $authentication = array(
                    'sender' => $this->convertAddressToSender ($this->walletAddress),
                    'expiration' => $nonce,
                );
                $request = array(
                    'id' => $requestId,
                    'method' => 'authenticate',
                    'tx' => array(
                        'sender' => $authentication['sender'],
                        'expiration' => $this->number_to_string($authentication['expiration']),
                    ),
                    'signature' => $this->build_ws_authentication_sig($authentication, $chainId, $verifyingContractAddress),
                );
                $message = $this->extend($request, $params);
                $this->watch($url, $messageHash, $message, $messageHash);
            }
            return Async\await($future);
        }) ();
    }

    public function watch_private($messageHash, $message, $params = array ()) {
        return Async\async(function () use ($messageHash, $message, $params) {
            Async\await($this->authenticate($params));
            $url = $this->urls['api']['ws'];
            $requestId = $this->request_id($url);
            $subscribe = array(
                'id' => $requestId,
            );
            $request = $this->extend($subscribe, $message);
            return Async\await($this->watch($url, $messageHash, $request, $messageHash, $subscribe));
        }) ();
    }

    public function watch_orders(?string $symbol = null, ?int $since = null, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            /**
             * watches information on multiple $orders made by the user
             *
             * @see https://docs.vertexprotocol.com/developer-resources/api/subscriptions/streams
             *
             * @param {string} $symbol unified $market $symbol of the $market $orders were made in
             * @param {int} [$since] the earliest time in ms to fetch $orders for
             * @param {int} [$limit] the maximum number of order structures to retrieve
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array[]} a list of ~@link https://docs.ccxt.com/#/?id=order-structure order structures~
             */
            if ($symbol === null) {
                throw new ArgumentsRequired($this->id . ' watchOrders requires a $symbol->');
            }
            $this->check_required_credentials();
            Async\await($this->load_markets());
            $name = 'order_update';
            $market = $this->market($symbol);
            $topic = $market['id'] . '@' . $name;
            $request = array(
                'method' => 'subscribe',
                'stream' => array(
                    'type' => $name,
                    'subaccount' => $this->convertAddressToSender ($this->walletAddress),
                    'product_id' => $this->parse_to_numeric($market['id']),
                ),
            );
            $message = $this->extend($request, $params);
            $orders = Async\await($this->watch_private($topic, $message));
            if ($this->newUpdates) {
                $limit = $orders->getLimit ($symbol, $limit);
            }
            return $this->filter_by_symbol_since_limit($orders, $symbol, $since, $limit, true);
        }) ();
    }

    public function parse_ws_order_status($status) {
        if ($status !== null) {
            $statuses = array(
                'filled' => 'open',
                'placed' => 'open',
                'cancelled' => 'canceled',
            );
            return $this->safe_string($statuses, $status, $status);
        }
        return $status;
    }

    public function parse_ws_order($order, ?array $market = null): array {
        //
        // {
        //     "type" => "order_update",
        //     // $timestamp of the event in nanoseconds
        //     "timestamp" => "1695081920633151000",
        //     "product_id" => 1,
        //     // $order digest
        //     "digest" => "0xf7712b63ccf70358db8f201e9bf33977423e7a63f6a16f6dab180bdd580f7c6c",
        //     // $remaining amount to be filled.
        //     // will be `0` if the $order is either fully filled or cancelled.
        //     "amount" => "82000000000000000",
        //     // any of => "filled", "cancelled", "placed"
        //     "reason" => "filled"
        //     // an optional `$order id` that can be provided when placing an $order
        //     "id" => 100
        // }
        //
        $marketId = $this->safe_string($order, 'product_id');
        $timestamp = $this->parse_to_int(Precise::string_div($this->safe_string($order, 'timestamp'), '1000000'));
        $remainingString = $this->convertFromX18 ($this->safe_string($order, 'amount'));
        $remaining = $this->parse_to_numeric($remainingString);
        $status = $this->parse_ws_order_status($this->safe_string($order, 'reason'));
        if (Precise::string_eq($remainingString, '0') && $status === 'open') {
            $status = 'closed';
        }
        $market = $this->safe_market($marketId, $market);
        $symbol = $market['symbol'];
        return $this->safe_order(array(
            'info' => $order,
            'id' => $this->safe_string_2($order, 'digest', 'id'),
            'clientOrderId' => null,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'lastTradeTimestamp' => null,
            'lastUpdateTimestamp' => null,
            'symbol' => $symbol,
            'type' => null,
            'timeInForce' => null,
            'postOnly' => null,
            'reduceOnly' => null,
            'side' => null,
            'price' => null,
            'triggerPrice' => null,
            'amount' => null,
            'cost' => null,
            'average' => null,
            'filled' => null,
            'remaining' => $remaining,
            'status' => $status,
            'fee' => null,
            'trades' => null,
        ), $market);
    }

    public function handle_order_update(Client $client, $message) {
        //
        // {
        //     "type" => "order_update",
        //     // timestamp of the event in nanoseconds
        //     "timestamp" => "1695081920633151000",
        //     "product_id" => 1,
        //     // $order digest
        //     "digest" => "0xf7712b63ccf70358db8f201e9bf33977423e7a63f6a16f6dab180bdd580f7c6c",
        //     // remaining amount to be filled.
        //     // will be `0` if the $order is either fully filled or cancelled.
        //     "amount" => "82000000000000000",
        //     // any of => "filled", "cancelled", "placed"
        //     "reason" => "filled"
        //     // an optional `$order id` that can be provided when placing an $order
        //     "id" => 100
        // }
        //
        $topic = $this->safe_string($message, 'type');
        $marketId = $this->safe_string($message, 'product_id');
        $parsed = $this->parse_ws_order($message);
        $symbol = $this->safe_string($parsed, 'symbol');
        $orderId = $this->safe_string($parsed, 'id');
        if ($symbol !== null) {
            if ($this->orders === null) {
                $limit = $this->safe_integer($this->options, 'ordersLimit', 1000);
                $this->orders = new ArrayCacheBySymbolById ($limit);
            }
            $cachedOrders = $this->orders;
            $orders = $this->safe_dict($cachedOrders->hashmap, $symbol, array());
            $order = $this->safe_dict($orders, $orderId);
            if ($order !== null) {
                $parsed['timestamp'] = $this->safe_integer($order, 'timestamp');
                $parsed['datetime'] = $this->safe_string($order, 'datetime');
            }
            $cachedOrders->append ($parsed);
            $client->resolve ($this->orders, $marketId . '@' . $topic);
        }
    }

    public function handle_error_message(Client $client, $message) {
        //
        // {
        //     result => null,
        //     $error => 'error parsing request => missing field `expiration`',
        //     id => 0
        // }
        //
        $errorMessage = $this->safe_string($message, 'error');
        try {
            if ($errorMessage !== null) {
                $feedback = $this->id . ' ' . $this->json($message);
                $this->throw_exactly_matched_exception($this->exceptions['exact'], $errorMessage, $feedback);
            }
            return false;
        } catch (Exception $error) {
            if ($error instanceof AuthenticationError) {
                $messageHash = 'authenticated';
                $client->reject ($error, $messageHash);
                if (is_array($client->subscriptions) && array_key_exists($messageHash, $client->subscriptions)) {
                    unset($client->subscriptions[$messageHash]);
                }
            } else {
                $client->reject ($error);
            }
            return true;
        }
    }

    public function handle_message(Client $client, $message) {
        if ($this->handle_error_message($client, $message)) {
            return;
        }
        $methods = array(
            'trade' => array($this, 'handle_trade'),
            'best_bid_offer' => array($this, 'handle_ticker'),
            'book_depth' => array($this, 'handle_order_book'),
            'fill' => array($this, 'handle_my_trades'),
            'position_change' => array($this, 'handle_positions'),
            'order_update' => array($this, 'handle_order_update'),
        );
        $event = $this->safe_string($message, 'type');
        $method = $this->safe_value($methods, $event);
        if ($method !== null) {
            $method($client, $message);
            return;
        }
        $requestId = $this->safe_string($message, 'id');
        if ($requestId !== null) {
            $this->handle_subscription_status($client, $message);
            return;
        }
        // check whether it's authentication
        $auth = $this->safe_value($client->futures, 'authenticated');
        if ($auth !== null) {
            $this->handle_auth($client, $message);
        }
    }
}
