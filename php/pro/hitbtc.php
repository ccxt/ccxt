<?php

namespace ccxt\pro;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

use Exception; // a common import
use ccxt\AuthenticationError;
use React\Async;

class hitbtc extends \ccxt\async\hitbtc {

    public function describe() {
        return $this->deep_extend(parent::describe(), array(
            'has' => array(
                'ws' => true,
                'watchTicker' => true,
                'watchTickers' => true,
                'watchTrades' => true,
                'watchOrderBook' => true,
                'watchBalance' => true,
                'watchOrders' => true,
                'watchOHLCV' => true,
                'watchMyTrades' => false,
            ),
            'urls' => array(
                'api' => array(
                    'ws' => array(
                        'public' => 'wss://api.hitbtc.com/api/3/ws/public',
                        'private' => 'wss://api.hitbtc.com/api/3/ws/trading',
                    ),
                ),
            ),
            'options' => array(
                'tradesLimit' => 1000,
                'watchTicker' => array(
                    'method' => 'ticker/{speed}',  // 'ticker/{speed}' or 'ticker/price/{speed}'
                ),
                'watchTickers' => array(
                    'method' => 'ticker/{speed}',  // 'ticker/{speed}','ticker/price/{speed}', 'ticker/{speed}/batch', or 'ticker/{speed}/price/batch''
                ),
                'watchOrderBook' => array(
                    'method' => 'orderbook/full',  // 'orderbook/full', 'orderbook/{depth}/{speed}', 'orderbook/{depth}/{speed}/batch', 'orderbook/top/{speed}', or 'orderbook/top/{speed}/batch'
                ),
            ),
            'timeframes' => array(
                '1m' => 'M1',
                '3m' => 'M3',
                '5m' => 'M5',
                '15m' => 'M15',
                '30m' => 'M30',
                '1h' => 'H1',
                '4h' => 'H4',
                '1d' => 'D1',
                '1w' => 'D7',
                '1M' => '1M',
            ),
            'streaming' => array(
                'keepAlive' => 4000,
            ),
        ));
    }

    public function authenticate() {
        /**
         * @ignore
         * authenticates the user to access private web socket channels
         * @see https://api.hitbtc.com/#socket-authentication
         * @return {array} response from exchange
         */
        $this->check_required_credentials();
        $url = $this->urls['api']['ws']['private'];
        $messageHash = 'authenticated';
        $client = $this->client($url);
        $future = $client->future ($messageHash);
        $authenticated = $this->safe_value($client->subscriptions, $messageHash);
        if ($authenticated === null) {
            $timestamp = $this->milliseconds();
            $signature = $this->hmac($this->encode($this->number_to_string($timestamp)), $this->encode($this->secret), 'sha256', 'hex');
            $request = array(
                'method' => 'login',
                'params' => array(
                    'type' => 'HS256',
                    'api_key' => $this->apiKey,
                    'timestamp' => $timestamp,
                    'signature' => $signature,
                ),
            );
            $this->watch($url, $messageHash, $request, $messageHash);
            //
            //    {
            //        jsonrpc => '2.0',
            //        result => true
            //    }
            //
            //    # Failure to return results
            //
            //    {
            //        jsonrpc => '2.0',
            //        error => {
            //            code => 1002,
            //            message => 'Authorization is required or has been failed',
            //            description => 'invalid $signature format'
            //        }
            //    }
            //
        }
        return $future;
    }

    public function subscribe_public(string $name, ?array $symbols = null, $params = array ()) {
        return Async\async(function () use ($name, $symbols, $params) {
            /**
             * @ignore
             * @param {string} $name websocket endpoint $name
             * @param {[string]} [$symbols] unified CCXT symbol(s)
             * @param {array} [$params] extra parameters specific to the hitbtc api
             * @return
             */
            Async\await($this->load_markets());
            $url = $this->urls['api']['ws']['public'];
            $messageHash = $name;
            if ($symbols !== null) {
                $messageHash = $messageHash . '::' . implode(',', $symbols);
            }
            $subscribe = array(
                'method' => 'subscribe',
                'id' => $this->nonce(),
                'ch' => $name,
            );
            $request = array_merge($subscribe, $params);
            return Async\await($this->watch($url, $messageHash, $request, $messageHash));
        }) ();
    }

    public function subscribe_private(string $name, ?string $symbol = null, $params = array ()) {
        return Async\async(function () use ($name, $symbol, $params) {
            /**
             * @ignore
             * @param {string} $name websocket endpoint $name
             * @param {string} [$symbol] unified CCXT $symbol
             * @param {array} [$params] extra parameters specific to the hitbtc api
             * @return
             */
            Async\await($this->load_markets());
            Async\await($this->authenticate());
            $url = $this->urls['api']['ws']['private'];
            $splitName = explode('_subscribe', $name);
            $messageHash = $this->safe_string($splitName, 0);
            if ($symbol !== null) {
                $messageHash = $messageHash . '::' . $symbol;
            }
            $subscribe = array(
                'method' => $name,
                'params' => $params,
                'id' => $this->nonce(),
            );
            return Async\await($this->watch($url, $messageHash, $subscribe, $messageHash));
        }) ();
    }

    public function watch_order_book(string $symbol, ?int $limit = null, $params = array ()) {
        return Async\async(function () use ($symbol, $limit, $params) {
            /**
             * watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
             * @see https://api.hitbtc.com/#subscribe-to-full-order-book
             * @see https://api.hitbtc.com/#subscribe-to-partial-order-book
             * @see https://api.hitbtc.com/#subscribe-to-partial-order-book-in-batches
             * @see https://api.hitbtc.com/#subscribe-to-top-of-book
             * @see https://api.hitbtc.com/#subscribe-to-top-of-book-in-batches
             * @param {string} $symbol unified $symbol of the $market to fetch the order book for
             * @param {int} [$limit] the maximum amount of order book entries to return
             * @param {array} [$params] extra parameters specific to the hitbtc api endpoint
             * @param {string} [$params->method] 'orderbook/full', 'orderbook/{$depth}/{$speed}', 'orderbook/{$depth}/{$speed}/batch', 'orderbook/top/{$speed}', or 'orderbook/top/{$speed}/batch'
             * @param {int} [$params->depth] 5 , 10, or 20 (default)
             * @param {int} [$params->speed] 100 (default), 500, or 1000
             * @return {array} A dictionary of ~@link https://docs.ccxt.com/#/?id=order-book-structure order book structures~ indexed by $market symbols
             */
            $options = $this->safe_value($this->options, 'watchOrderBook');
            $defaultMethod = $this->safe_string($options, 'method', 'orderbook/full');
            $name = $this->safe_string_2($params, 'method', 'defaultMethod', $defaultMethod);
            $depth = $this->safe_string($params, 'depth', '20');
            $speed = $this->safe_string($params, 'depth', '100');
            if ($name === 'orderbook/{$depth}/{$speed}') {
                $name = 'orderbook/D' . $depth . '/' . $speed . 'ms';
            } elseif ($name === 'orderbook/{$depth}/{$speed}/batch') {
                $name = 'orderbook/D' . $depth . '/' . $speed . 'ms/batch';
            } elseif ($name === 'orderbook/top/{$speed}') {
                $name = 'orderbook/top/' . $speed . 'ms';
            } elseif ($name === 'orderbook/top/{$speed}/batch') {
                $name = 'orderbook/top/' . $speed . 'ms/batch';
            }
            $market = $this->market($symbol);
            $request = array(
                'params' => array(
                    'symbols' => [ $market['id'] ],
                ),
            );
            $orderbook = Async\await($this->subscribe_public($name, array( $symbol ), $this->deep_extend($request, $params)));
            return $orderbook->limit ();
        }) ();
    }

    public function handle_order_book(Client $client, $message) {
        //
        //    {
        //        "ch" => "orderbook/full",                 // Channel
        //        "snapshot" => {
        //            "ETHBTC" => {
        //                "t" => 1626866578796,             // Timestamp in milliseconds
        //                "s" => 27617207,                  // Sequence number
        //                "a" => [                          // Asks
        //                    ["0.060506", "0"],
        //                    ["0.060549", "12.6431"],
        //                    ["0.060570", "0"],
        //                    ["0.060612", "0"]
        //                ],
        //                "b" => [                          // Bids
        //                    ["0.060439", "4.4095"],
        //                    ["0.060414", "0"],
        //                    ["0.060407", "7.3349"],
        //                    ["0.060390", "0"]
        //                ]
        //            }
        //        }
        //    }
        //
        $data = $this->safe_value_2($message, 'snapshot', 'update', array());
        $marketIds = is_array($data) ? array_keys($data) : array();
        $channel = $this->safe_string($message, 'ch');
        for ($i = 0; $i < count($marketIds); $i++) {
            $marketId = $marketIds[$i];
            $market = $this->safe_market($marketId);
            $symbol = $market['symbol'];
            $item = $data[$marketId];
            $messageHash = $channel . '::' . $symbol;
            if (!(is_array($this->orderbooks) && array_key_exists($symbol, $this->orderbooks))) {
                $subscription = $this->safe_value($client->subscriptions, $messageHash, array());
                $limit = $this->safe_integer($subscription, 'limit');
                $this->orderbooks[$symbol] = $this->order_book(array(), $limit);
            }
            $timestamp = $this->safe_integer($item, 't');
            $nonce = $this->safe_integer($item, 's');
            $orderbook = $this->orderbooks[$symbol];
            $asks = $this->safe_value($item, 'a', array());
            $bids = $this->safe_value($item, 'b', array());
            $this->handle_deltas($orderbook['asks'], $asks);
            $this->handle_deltas($orderbook['bids'], $bids);
            $orderbook['timestamp'] = $timestamp;
            $orderbook['datetime'] = $this->iso8601($timestamp);
            $orderbook['nonce'] = $nonce;
            $orderbook['symbol'] = $symbol;
            $this->orderbooks[$symbol] = $orderbook;
            $client->resolve ($orderbook, $messageHash);
        }
    }

    public function handle_delta($bookside, $delta) {
        $price = $this->safe_number($delta, 0);
        $amount = $this->safe_number($delta, 1);
        $bookside->store ($price, $amount);
    }

    public function handle_deltas($bookside, $deltas) {
        for ($i = 0; $i < count($deltas); $i++) {
            $this->handle_delta($bookside, $deltas[$i]);
        }
    }

    public function watch_ticker(string $symbol, $params = array ()) {
        return Async\async(function () use ($symbol, $params) {
            /**
             * watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific $market
             * @see https://api.hitbtc.com/#subscribe-to-ticker
             * @see https://api.hitbtc.com/#subscribe-to-ticker-in-batches
             * @see https://api.hitbtc.com/#subscribe-to-mini-ticker
             * @see https://api.hitbtc.com/#subscribe-to-mini-ticker-in-batches
             * @param {string} $symbol unified $symbol of the $market to fetch the ticker for
             * @param {array} [$params] extra parameters specific to the hitbtc api endpoint
             * @param {string} [$params->method] 'ticker/{$speed}' (default), or 'ticker/price/{$speed}'
             * @param {string} [$params->speed] '1s' (default), or '3s'
             * @return {array} a ~@link https://docs.ccxt.com/#/?id=ticker-structure ticker structure~
             */
            $options = $this->safe_value($this->options, 'watchTicker');
            $defaultMethod = $this->safe_string($options, 'method', 'ticker/{$speed}');
            $method = $this->safe_string_2($params, 'method', 'defaultMethod', $defaultMethod);
            $speed = $this->safe_string($params, 'speed', '1s');
            $name = $this->implode_params($method, array( 'speed' => $speed ));
            $params = $this->omit($params, array( 'method', 'speed' ));
            $market = $this->market($symbol);
            $request = array(
                'params' => array(
                    'symbols' => [ $market['id'] ],
                ),
            );
            return Async\await($this->subscribe_public($name, array( $symbol ), $this->deep_extend($request, $params)));
        }) ();
    }

    public function watch_tickers($symbols = null, $params = array ()) {
        return Async\async(function () use ($symbols, $params) {
            /**
             * watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
             * @param {string} symbol unified symbol of the market to fetch the ticker for
             * @param {array} $params extra parameters specific to the hitbtc api endpoint
             * @param {string} $params->method 'ticker/{$speed}' (default),'ticker/price/{$speed}', 'ticker/{$speed}/batch', or 'ticker/{$speed}/price/batch''
             * @param {string} $params->speed '1s' (default), or '3s'
             * @return {array} a {@link https://docs.ccxt.com/en/latest/manual.html#ticker-structure ticker structure}
             */
            Async\await($this->load_markets());
            $options = $this->safe_value($this->options, 'watchTicker');
            $defaultMethod = $this->safe_string($options, 'method', 'ticker/{$speed}');
            $method = $this->safe_string_2($params, 'method', 'defaultMethod', $defaultMethod);
            $speed = $this->safe_string($params, 'speed', '1s');
            $name = $this->implode_params($method, array( 'speed' => $speed ));
            $params = $this->omit($params, array( 'method', 'speed' ));
            $marketIds = array();
            if ($symbols === null) {
                $marketIds[] = '*';
            } else {
                for ($i = 0; $i < count($symbols); $i++) {
                    $marketId = $this->market_id($symbols[$i]);
                    $marketIds[] = $marketId;
                }
            }
            $request = array(
                'params' => array(
                    'symbols' => $marketIds,
                ),
            );
            $tickers = Async\await($this->subscribe_public($name, $symbols, $this->deep_extend($request, $params)));
            if ($this->newUpdates) {
                return $tickers;
            }
            return $this->filter_by_array($this->tickers, 'symbol', $symbols);
        }) ();
    }

    public function handle_ticker(Client $client, $message) {
        //
        //    {
        //        "ch" => "ticker/1s",
        //        "data" => {
        //            "ETHBTC" => {
        //                "t" => 1614815872000,             // Timestamp in milliseconds
        //                "a" => "0.031175",                // Best ask
        //                "A" => "0.03329",                 // Best ask quantity
        //                "b" => "0.031148",                // Best bid
        //                "B" => "0.10565",                 // Best bid quantity
        //                "c" => "0.031210",                // Last price
        //                "o" => "0.030781",                // Open price
        //                "h" => "0.031788",                // High price
        //                "l" => "0.030733",                // Low price
        //                "v" => "62.587",                  // Base asset volume
        //                "q" => "1.951420577",             // Quote asset volume
        //                "p" => "0.000429",                // Price change
        //                "P" => "1.39",                    // Price change percent
        //                "L" => 1182694927                 // Last trade identifier
        //            }
        //        }
        //    }
        //
        //    {
        //        "ch" => "ticker/price/1s",
        //        "data" => {
        //            "BTCUSDT" => {
        //                "t" => 1614815872030,
        //                "o" => "32636.79",
        //                "c" => "32085.51",
        //                "h" => "33379.92",
        //                "l" => "30683.28",
        //                "v" => "11.90667",
        //                "q" => "384081.1955629"
        //            }
        //        }
        //    }
        //
        $data = $this->safe_value($message, 'data', array());
        $marketIds = is_array($data) ? array_keys($data) : array();
        $channel = $this->safe_string($message, 'ch');
        $newTickers = array();
        for ($i = 0; $i < count($marketIds); $i++) {
            $marketId = $marketIds[$i];
            $market = $this->safe_market($marketId);
            $symbol = $market['symbol'];
            $ticker = $this->parse_ws_ticker($data[$marketId], $market);
            $this->tickers[$symbol] = $ticker;
            $newTickers[] = $ticker;
            $messageHash = $channel . '::' . $symbol;
            $client->resolve ($this->tickers[$symbol], $messageHash);
        }
        $messageHashes = $this->find_message_hashes($client, $channel . '::');
        for ($i = 0; $i < count($messageHashes); $i++) {
            $messageHash = $messageHashes[$i];
            $parts = explode('::', $messageHash);
            $symbolsString = $parts[1];
            $symbols = explode(',', $symbolsString);
            $tickers = $this->filter_by_array($newTickers, 'symbol', $symbols);
            $tickersSymbols = is_array($tickers) ? array_keys($tickers) : array();
            $numTickers = count($tickersSymbols);
            if ($numTickers > 0) {
                $client->resolve ($tickers, $messageHash);
            }
        }
        $client->resolve ($this->tickers, $channel);
        return $message;
    }

    public function parse_ws_ticker($ticker, $market = null) {
        //
        //    {
        //        "t" => 1614815872000,             // Timestamp in milliseconds
        //        "a" => "0.031175",                // Best ask
        //        "A" => "0.03329",                 // Best ask quantity
        //        "b" => "0.031148",                // Best bid
        //        "B" => "0.10565",                 // Best bid quantity
        //        "c" => "0.031210",                // Last price
        //        "o" => "0.030781",                // Open price
        //        "h" => "0.031788",                // High price
        //        "l" => "0.030733",                // Low price
        //        "v" => "62.587",                  // Base asset volume
        //        "q" => "1.951420577",             // Quote asset volume
        //        "p" => "0.000429",                // Price change
        //        "P" => "1.39",                    // Price change percent
        //        "L" => 1182694927                 // Last trade identifier
        //    }
        //
        //    {
        //        "t" => 1614815872030,
        //        "o" => "32636.79",
        //        "c" => "32085.51",
        //        "h" => "33379.92",
        //        "l" => "30683.28",
        //        "v" => "11.90667",
        //        "q" => "384081.1955629"
        //    }
        //
        $timestamp = $this->safe_integer($ticker, 't');
        $symbol = $this->safe_symbol(null, $market);
        $last = $this->safe_string($ticker, 'c');
        return $this->safe_ticker(array(
            'symbol' => $symbol,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'high' => $this->safe_string($ticker, 'h'),
            'low' => $this->safe_string($ticker, 'l'),
            'bid' => $this->safe_string($ticker, 'b'),
            'bidVolume' => $this->safe_string($ticker, 'B'),
            'ask' => $this->safe_string($ticker, 'a'),
            'askVolume' => $this->safe_string($ticker, 'A'),
            'vwap' => null,
            'open' => $this->safe_string($ticker, 'o'),
            'close' => $last,
            'last' => $last,
            'previousClose' => null,
            'change' => null,
            'percentage' => null,
            'average' => null,
            'baseVolume' => $this->safe_string($ticker, 'v'),
            'quoteVolume' => $this->safe_string($ticker, 'q'),
            'info' => $ticker,
        ), $market);
    }

    public function watch_trades(string $symbol, ?int $since = null, ?int $limit = null, $params = array ()) {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            /**
             * get the list of most recent $trades for a particular $symbol
             * @see https://api.hitbtc.com/#subscribe-to-$trades
             * @param {string} $symbol unified $symbol of the $market to fetch $trades for
             * @param {int} [$since] timestamp in ms of the earliest trade to fetch
             * @param {int} [$limit] the maximum amount of $trades to fetch
             * @param {array} [$params] extra parameters specific to the hitbtc api endpoint
             * @return {array[]} a list of {@link https://github.com/ccxt/ccxt/wiki/Manual#public-$trades trade structures}
             */
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $request = array(
                'params' => array(
                    'symbols' => [ $market['id'] ],
                ),
            );
            if ($limit !== null) {
                $request['limit'] = $limit;
            }
            $trades = Async\await($this->subscribe_public('trades', array( $symbol ), $this->deep_extend($request, $params)));
            if ($this->newUpdates) {
                $limit = $trades->getLimit ($symbol, $limit);
            }
            return $this->filter_by_since_limit($trades, $since, $limit, 'timestamp');
        }) ();
    }

    public function handle_trades(Client $client, $message) {
        //
        //    {
        //        "result" => array(
        //            "ch" => "trades",                           // Channel
        //            "subscriptions" => ["ETHBTC", "BTCUSDT"]
        //        ),
        //        "id" => 123
        //    }
        //
        // Notification snapshot
        //
        //    {
        //        "ch" => "trades",                               // Channel
        //        "snapshot" => {
        //            "BTCUSDT" => [array(
        //                "t" => 1626861109494,                   // Timestamp in milliseconds
        //                "i" => 1555634969,                      // Trade identifier
        //                "p" => "30881.96",                      // Price
        //                "q" => "12.66828",                      // Quantity
        //                "s" => "buy"                            // Side
        //            )]
        //        }
        //    }
        //
        // Notification update
        //
        //    {
        //        "ch" => "trades",
        //        "update" => {
        //            "BTCUSDT" => [array(
        //                "t" => 1626861123552,
        //                "i" => 1555634969,
        //                "p" => "30877.68",
        //                "q" => "0.00006",
        //                "s" => "sell"
        //            )]
        //        }
        //    }
        //
        $data = $this->safe_value_2($message, 'snapshot', 'update', array());
        $marketIds = is_array($data) ? array_keys($data) : array();
        for ($i = 0; $i < count($marketIds); $i++) {
            $marketId = $marketIds[$i];
            $market = $this->safe_market($marketId);
            $tradesLimit = $this->safe_integer($this->options, 'tradesLimit', 1000);
            $symbol = $market['symbol'];
            $stored = $this->safe_value($this->trades, $symbol);
            if ($stored === null) {
                $stored = new ArrayCache ($tradesLimit);
                $this->trades[$symbol] = $stored;
            }
            $trades = $this->parse_ws_trades($data[$marketId], $market);
            for ($i = 0; $i < count($trades); $i++) {
                $stored->append ($trades[$i]);
            }
            $messageHash = 'trades::' . $symbol;
            $client->resolve ($stored, $messageHash);
        }
        return $message;
    }

    public function parse_ws_trades($trades, ?array $market = null, ?int $since = null, ?int $limit = null, $params = array ()) {
        $trades = $this->to_array($trades);
        $result = array();
        for ($i = 0; $i < count($trades); $i++) {
            $trade = array_merge($this->parse_ws_trade($trades[$i], $market), $params);
            $result[] = $trade;
        }
        $result = $this->sort_by_2($result, 'timestamp', 'id');
        $symbol = $this->safe_string($market, 'symbol');
        return $this->filter_by_symbol_since_limit($result, $symbol, $since, $limit);
    }

    public function parse_ws_trade($trade, $market = null) {
        //
        //    {
        //        "t" => 1626861123552,       // Timestamp in milliseconds
        //        "i" => 1555634969,          // Trade identifier
        //        "p" => "30877.68",          // Price
        //        "q" => "0.00006",           // Quantity
        //        "s" => "sell"               // Side
        //    }
        //
        $timestamp = $this->safe_integer($trade, 't');
        return $this->safe_trade(array(
            'info' => $trade,
            'id' => $this->safe_string($trade, 'i'),
            'order' => null,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'symbol' => $this->safe_string($market, 'symbol'),
            'type' => null,
            'side' => $this->safe_string($trade, 's'),
            'takerOrMaker' => null,
            'price' => $this->safe_string($trade, 'p'),
            'amount' => $this->safe_string($trade, 'q'),
            'cost' => null,
            'fee' => null,
        ), $market);
    }

    public function watch_ohlcv(string $symbol, $timeframe = '1m', ?int $since = null, ?int $limit = null, $params = array ()) {
        return Async\async(function () use ($symbol, $timeframe, $since, $limit, $params) {
            /**
             * watches historical candlestick data containing the open, high, low, and close price, and the volume of a $market
             * @see https://api.hitbtc.com/#subscribe-to-candles
             * @param {string} $symbol unified $symbol of the $market to fetch OHLCV data for
             * @param {string} [$timeframe] the length of time each candle represents
             * @param {int} [$since] not used by hitbtc watchOHLCV
             * @param {int} [$limit] 0 â€“ 1000, default value = 0 (no history returned)
             * @param {array} [$params] extra parameters specific to the hitbtc api endpoint
             * @return {[[int]]} A list of candles ordered, open, high, low, close, volume
             */
            $period = $this->safe_string($this->timeframes, $timeframe, $timeframe);
            $name = 'candles/' . $period;
            $market = $this->market($symbol);
            $request = array(
                'params' => array(
                    'symbols' => [ $market['id'] ],
                ),
            );
            if ($limit !== null) {
                $request['params']['limit'] = $limit;
            }
            $ohlcv = Async\await($this->subscribe_public($name, array( $symbol ), $this->deep_extend($request, $params)));
            if ($this->newUpdates) {
                $limit = $ohlcv->getLimit ($symbol, $limit);
            }
            return $this->filter_by_since_limit($ohlcv, $since, $limit, 0);
        }) ();
    }

    public function handle_ohlcv(Client $client, $message) {
        //
        //    {
        //        "ch" => "candles/M1",                     // Channel
        //        "snapshot" => {
        //            "BTCUSDT" => [{
        //                "t" => 1626860340000,             // Message timestamp
        //                "o" => "30881.95",                // Open price
        //                "c" => "30890.96",                // Last price
        //                "h" => "30900.8",                 // High price
        //                "l" => "30861.27",                // Low price
        //                "v" => "1.27852",                 // Base asset volume
        //                "q" => "39493.9021811"            // Quote asset volume
        //            }
        //            ...
        //            ]
        //        }
        //    }
        //
        //    {
        //        "ch" => "candles/M1",
        //        "update" => {
        //            "ETHBTC" => [array(
        //                "t" => 1626860880000,
        //                "o" => "0.060711",
        //                "c" => "0.060749",
        //                "h" => "0.060749",
        //                "l" => "0.060711",
        //                "v" => "12.2800",
        //                "q" => "0.7455339675"
        //          )]
        //        }
        //    }
        //
        $data = $this->safe_value_2($message, 'snapshot', 'update', array());
        $marketIds = is_array($data) ? array_keys($data) : array();
        $channel = $this->safe_string($message, 'ch');
        $splitChannel = explode('/', $channel);
        $period = $this->safe_string($splitChannel, 1);
        $timeframe = $this->find_timeframe($period);
        for ($i = 0; $i < count($marketIds); $i++) {
            $marketId = $marketIds[$i];
            $market = $this->safe_market($marketId);
            $symbol = $market['symbol'];
            $this->ohlcvs[$symbol] = $this->safe_value($this->ohlcvs, $symbol, array());
            $stored = $this->safe_value($this->ohlcvs[$symbol], $timeframe);
            if ($stored === null) {
                $limit = $this->safe_integer($this->options, 'OHLCVLimit', 1000);
                $stored = new ArrayCacheByTimestamp ($limit);
                $this->ohlcvs[$symbol][$timeframe] = $stored;
            }
            $ohlcvs = $this->parse_ws_ohlcvs($data[$marketId], $market);
            for ($i = 0; $i < count($ohlcvs); $i++) {
                $stored->append ($ohlcvs[$i]);
            }
            $messageHash = $channel . '::' . $symbol;
            $client->resolve ($stored, $messageHash);
        }
        return $message;
    }

    public function parse_ws_ohlcv($ohlcv, $market = null) {
        //
        //    {
        //        "t" => 1626860340000,             // Message timestamp
        //        "o" => "30881.95",                // Open price
        //        "c" => "30890.96",                // Last price
        //        "h" => "30900.8",                 // High price
        //        "l" => "30861.27",                // Low price
        //        "v" => "1.27852",                 // Base asset volume
        //        "q" => "39493.9021811"            // Quote asset volume
        //    }
        //
        return array(
            $this->safe_integer($ohlcv, 't'),
            $this->safe_number($ohlcv, 'o'),
            $this->safe_number($ohlcv, 'h'),
            $this->safe_number($ohlcv, 'l'),
            $this->safe_number($ohlcv, 'c'),
            $this->safe_number($ohlcv, 'v'),
        );
    }

    public function watch_orders(?string $symbol = null, ?int $since = null, ?int $limit = null, $params = array ()) {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            /**
             * watches information on multiple $orders made by the user
             * @see https://api.hitbtc.com/#subscribe-to-reports
             * @see https://api.hitbtc.com/#subscribe-to-reports-2
             * @see https://api.hitbtc.com/#subscribe-to-reports-3
             * @param {string} [$symbol] unified CCXT $market $symbol
             * @param {int} [$since] timestamp in ms of the earliest order to fetch
             * @param {int} [$limit] the maximum amount of $orders to fetch
             * @param {array} [$params] extra parameters specific to the hitbtc api endpoint
             * @return {[array]} a list of {@link https://docs.ccxt.com/en/latest/manual.html#order-structure order structures}
             */
            Async\await($this->load_markets());
            $marketType = null;
            $market = null;
            if ($symbol !== null) {
                $market = $this->market($symbol);
            }
            list($marketType, $params) = $this->handle_market_type_and_params('watchOrders', $market, $params);
            $name = $this->get_supported_mapping($marketType, array(
                'spot' => 'spot_subscribe',
                'margin' => 'margin_subscribe',
                'swap' => 'futures_subscribe',
                'future' => 'futures_subscribe',
            ));
            $orders = Async\await($this->subscribe_private($name, $symbol, $params));
            if ($this->newUpdates) {
                $limit = $orders->getLimit ($symbol, $limit);
            }
            return $this->filter_by_since_limit($orders, $since, $limit, 'timestamp');
        }) ();
    }

    public function handle_order(Client $client, $message) {
        //
        //    {
        //        "jsonrpc" => "2.0",
        //        "method" => "spot_order",                            // "margin_order", "future_order"
        //        "params" => {
        //            "id" => 584244931496,
        //            "client_order_id" => "b5acd79c0a854b01b558665bcf379456",
        //            "symbol" => "BTCUSDT",
        //            "side" => "buy",
        //            "status" => "new",
        //            "type" => "limit",
        //            "time_in_force" => "GTC",
        //            "quantity" => "0.01000",
        //            "quantity_cumulative" => "0",
        //            "price" => "0.01",                              // only updates and snapshots
        //            "post_only" => false,
        //            "reduce_only" => false,                         // only margin and contract
        //            "display_quantity" => "0",                      // only updates and snapshot
        //            "created_at" => "2021-07-02T22:52:32.864Z",
        //            "updated_at" => "2021-07-02T22:52:32.864Z",
        //            "trade_id" => 1361977606,                       // only trades
        //            "trade_quantity" => "0.00001",                  // only trades
        //            "trade_price" => "49595.04",                    // only trades
        //            "trade_fee" => "0.001239876000",                // only trades
        //            "trade_taker" => true,                          // only trades, only spot
        //            "trade_position_id" => 485308,                  // only trades, only margin
        //            "report_type" => "new"                          // "trade", "status" (snapshot)
        //        }
        //    }
        //
        //    {
        //       "jsonrpc" => "2.0",
        //       "method" => "spot_orders",                            // "margin_orders", "future_orders"
        //       "params" => array(
        //            {
        //                "id" => 584244931496,
        //                "client_order_id" => "b5acd79c0a854b01b558665bcf379456",
        //                "symbol" => "BTCUSDT",
        //                "side" => "buy",
        //                "status" => "new",
        //                "type" => "limit",
        //                "time_in_force" => "GTC",
        //                "quantity" => "0.01000",
        //                "quantity_cumulative" => "0",
        //                "price" => "0.01",                              // only updates and snapshots
        //                "post_only" => false,
        //                "reduce_only" => false,                         // only margin and contract
        //                "display_quantity" => "0",                      // only updates and snapshot
        //                "created_at" => "2021-07-02T22:52:32.864Z",
        //                "updated_at" => "2021-07-02T22:52:32.864Z",
        //                "trade_id" => 1361977606,                       // only trades
        //                "trade_quantity" => "0.00001",                  // only trades
        //                "trade_price" => "49595.04",                    // only trades
        //                "trade_fee" => "0.001239876000",                // only trades
        //                "trade_taker" => true,                          // only trades, only spot
        //                "trade_position_id" => 485308,                  // only trades, only margin
        //                "report_type" => "new"                          // "trade", "status" (snapshot)
        //            }
        //        )
        //    }
        //
        if ($this->orders === null) {
            $limit = $this->safe_integer($this->options, 'ordersLimit');
            $this->orders = new ArrayCacheBySymbolById ($limit);
        }
        $data = $this->safe_value($message, 'params', array());
        if (gettype($data) === 'array' && array_keys($data) === array_keys(array_keys($data))) {
            for ($i = 0; $i < count($data); $i++) {
                $order = $data[$i];
                $this->handle_order_helper($client, $message, $order);
            }
        } else {
            $this->handle_order_helper($client, $message, $data);
        }
        return $message;
    }

    public function handle_order_helper(Client $client, $message, $order) {
        $orders = $this->orders;
        $marketId = $this->safe_string_lower_2($order, 'instrument', 'symbol');
        $method = $this->safe_string($message, 'method');
        $splitMethod = explode('_order', $method);
        $messageHash = $this->safe_string($splitMethod, 0);
        $symbol = $this->safe_symbol($marketId);
        $parsed = $this->parse_order($order);
        $orders->append ($parsed);
        $client->resolve ($orders, $messageHash);
        $client->resolve ($orders, $messageHash . '::' . $symbol);
    }

    public function parse_ws_order_trade($trade, $market = null) {
        //
        //    {
        //        "id" => 584244931496,
        //        "client_order_id" => "b5acd79c0a854b01b558665bcf379456",
        //        "symbol" => "BTCUSDT",
        //        "side" => "buy",
        //        "status" => "new",
        //        "type" => "limit",
        //        "time_in_force" => "GTC",
        //        "quantity" => "0.01000",
        //        "quantity_cumulative" => "0",
        //        "price" => "0.01",                              // only updates and snapshots
        //        "post_only" => false,
        //        "reduce_only" => false,                         // only margin and contract
        //        "display_quantity" => "0",                      // only updates and snapshot
        //        "created_at" => "2021-07-02T22:52:32.864Z",
        //        "updated_at" => "2021-07-02T22:52:32.864Z",
        //        "trade_id" => 1361977606,                       // only trades
        //        "trade_quantity" => "0.00001",                  // only trades
        //        "trade_price" => "49595.04",                    // only trades
        //        "trade_fee" => "0.001239876000",                // only trades
        //        "trade_taker" => true,                          // only trades, only spot
        //        "trade_position_id" => 485308,                  // only trades, only margin
        //        "report_type" => "new"                          // "trade", "status" (snapshot)
        //    }
        //
        $timestamp = $this->safe_integer($trade, 'created_at');
        $marketId = $this->safe_string($trade, 'symbol');
        return $this->safe_trade(array(
            'info' => $trade,
            'id' => $this->safe_string($trade, 'trade_id'),
            'order' => $this->safe_string($trade, 'id'),
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'symbol' => $this->safe_market($marketId, $market),
            'type' => null,
            'side' => $this->safe_string($trade, 'side'),
            'takerOrMaker' => $this->safe_string($trade, 'trade_taker'),
            'price' => $this->safe_string($trade, 'trade_price'),
            'amount' => $this->safe_string($trade, 'trade_quantity'),
            'cost' => null,
            'fee' => array(
                'cost' => $this->safe_string($trade, 'trade_fee'),
                'currency' => null,
                'rate' => null,
            ),
        ), $market);
    }

    public function parse_ws_order($order, $market = null) {
        //
        //    {
        //        "id" => 584244931496,
        //        "client_order_id" => "b5acd79c0a854b01b558665bcf379456",
        //        "symbol" => "BTCUSDT",
        //        "side" => "buy",
        //        "status" => "new",
        //        "type" => "limit",
        //        "time_in_force" => "GTC",
        //        "quantity" => "0.01000",
        //        "quantity_cumulative" => "0",
        //        "price" => "0.01",                              // only updates and snapshots
        //        "post_only" => false,
        //        "reduce_only" => false,                         // only margin and contract
        //        "display_quantity" => "0",                      // only updates and snapshot
        //        "created_at" => "2021-07-02T22:52:32.864Z",
        //        "updated_at" => "2021-07-02T22:52:32.864Z",
        //        "trade_id" => 1361977606,                       // only $trades
        //        "trade_quantity" => "0.00001",                  // only $trades
        //        "trade_price" => "49595.04",                    // only $trades
        //        "trade_fee" => "0.001239876000",                // only $trades
        //        "trade_taker" => true,                          // only $trades, only spot
        //        "trade_position_id" => 485308,                  // only $trades, only margin
        //        "report_type" => "new"                          // "trade", "status" (snapshot)
        //    }
        //
        $timestamp = $this->safe_string($order, 'created_at');
        $marketId = $this->safe_symbol($order, 'symbol');
        $market = $this->safe_market($marketId, $market);
        $tradeId = $this->safe_string($order, 'trade_id');
        $trades = null;
        if ($tradeId !== null) {
            $trade = $this->parse_ws_order_trade($order, $market);
            $trades = array( $trade );
        }
        return $this->safe_order(array(
            'info' => $order,
            'id' => $this->safe_string($order, 'id'),
            'clientOrderId' => $this->safe_string($order, 'client_order_id'),
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'lastTradeTimestamp' => null,
            'symbol' => $market['symbol'],
            'price' => $this->safe_string($order, 'price'),
            'amount' => $this->safe_string($order, 'quantity'),
            'type' => $this->safe_string($order, 'type'),
            'side' => $this->safe_string_upper($order, 'side'),
            'timeInForce' => $this->safe_string($order, 'time_in_force'),
            'postOnly' => $this->safe_string($order, 'post_only'),
            'reduceOnly' => $this->safe_value($order, 'reduce_only'),
            'filled' => null,
            'remaining' => null,
            'cost' => null,
            'status' => $this->parse_order_status($this->safe_string($order, 'status')),
            'average' => null,
            'trades' => $trades,
            'fee' => null,
        ), $market);
    }

    public function watch_balance($params = array ()) {
        return Async\async(function () use ($params) {
            /**
             * watches balance updates, cannot subscribe to margin account balances
             * @see https://api.hitbtc.com/#subscribe-to-spot-balances
             * @see https://api.hitbtc.com/#subscribe-to-futures-balances
             * @param {array} [$params] extra parameters specific to the hitbtc api endpoint
             * @param {string} [$params->type] 'spot', 'swap', or 'future'
             *
             * EXCHANGE SPECIFIC PARAMETERS
             * @param {string} [$params->mode] 'updates' or 'batches' (default), 'updates' = messages arrive after balance updates, 'batches' = messages arrive at equal intervals if there were any updates
             * @return {[array]} a list of ~@link https://docs.ccxt.com/#/?id=balance-structure balance structures~
             */
            Async\await($this->load_markets());
            $type = null;
            list($type, $params) = $this->handle_market_type_and_params('watchBalance', null, $params);
            $name = $this->get_supported_mapping($type, array(
                'spot' => 'spot_balance_subscribe',
                'swap' => 'futures_balance_subscribe',
                'future' => 'futures_balance_subscribe',
            ));
            $mode = $this->safe_string($params, 'mode', 'batches');
            $params = $this->omit($params, 'mode');
            $request = array(
                'mode' => $mode,
            );
            return Async\await($this->subscribe_private($name, null, array_merge($request, $params)));
        }) ();
    }

    public function handle_balance(Client $client, $message) {
        //
        //    {
        //        "jsonrpc" => "2.0",
        //        "method" => "futures_balance",
        //        "params" => array(
        //            array(
        //                "currency" => "BCN",
        //                "available" => "100.000000000000",
        //                "reserved" => "0",
        //                "reserved_margin" => "0"
        //            ),
        //            ...
        //        )
        //    }
        //
        $messageHash = $this->safe_string($message, 'method');
        $params = $this->safe_value($message, 'params');
        $balance = $this->parse_balance($params);
        $this->balance = $this->deep_extend($this->balance, $balance);
        $client->resolve ($this->balance, $messageHash);
    }

    public function handle_notification(Client $client, $message) {
        //
        //     array( jsonrpc => '2.0', result => true, id => null )
        //
        return $message;
    }

    public function handle_message(Client $client, $message) {
        $channel = $this->safe_string_2($message, 'ch', 'method');
        if ($channel !== null) {
            $splitChannel = explode('/', $channel);
            $channel = $this->safe_string($splitChannel, 0);
            $methods = array(
                'candles' => array($this, 'handle_ohlcv'),
                'ticker' => array($this, 'handle_ticker'),
                'trades' => array($this, 'handle_trades'),
                'orderbook' => array($this, 'handle_order_book'),
                'spot_order' => array($this, 'handle_order'),
                'spot_orders' => array($this, 'handle_order'),
                'margin_order' => array($this, 'handle_order'),
                'margin_orders' => array($this, 'handle_order'),
                'futures_order' => array($this, 'handle_order'),
                'futures_orders' => array($this, 'handle_order'),
                'spot_balance' => array($this, 'handle_balance'),
                'futures_balance' => array($this, 'handle_balance'),
            );
            $method = $this->safe_value($methods, $channel);
            if ($method !== null) {
                $method($client, $message);
            }
        } else {
            $success = $this->safe_value($message, 'result');
            if (($success === true) && !(is_array($message) && array_key_exists('id', $message))) {
                $this->handle_authenticate($client, $message);
            }
        }
    }

    public function handle_authenticate(Client $client, $message) {
        //
        //    {
        //        jsonrpc => '2.0',
        //        result => true
        //    }
        //
        $success = $this->safe_value($message, 'result');
        $messageHash = 'authenticated';
        if ($success) {
            $future = $this->safe_value($client->futures, $messageHash);
            $future->resolve (true);
        } else {
            $error = new AuthenticationError ($this->id . ' ' . $this->json($message));
            $client->reject ($error, $messageHash);
            if (is_array($client->subscriptions) && array_key_exists($messageHash, $client->subscriptions)) {
                unset($client->subscriptions[$messageHash]);
            }
        }
        return $message;
    }
}
