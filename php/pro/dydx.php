<?php

namespace ccxt\pro;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

use Exception; // a common import
use ccxt\ExchangeError;
use \React\Async;
use \React\Promise\PromiseInterface;

class dydx extends \ccxt\async\dydx {

    public function describe(): mixed {
        return $this->deep_extend(parent::describe(), array(
            'has' => array(
                'ws' => true,
                'watchBalance' => false,
                'watchTicker' => false,
                'watchTickers' => false,
                'watchTrades' => true,
                'watchOrderBook' => true,
                'watchOHLCV' => true,
            ),
            'urls' => array(
                'test' => array(
                    'ws' => 'wss://indexer.v4testnet.dydx.exchange/v4/ws',
                ),
                'api' => array(
                    'ws' => 'wss://indexer.dydx.trade/v4/ws',
                ),
            ),
            'options' => array(),
            'streaming' => array(),
            'exceptions' => array(),
        ));
    }

    public function watch_trades(string $symbol, ?int $since = null, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            /**
             * get the list of most recent $trades for a particular $symbol
             *
             * @see https://docs.dydx.xyz/indexer-client/websockets#$trades
             *
             * @param {string} $symbol unified $symbol of the $market to fetch $trades for
             * @param {int} [$since] timestamp in ms of the earliest trade to fetch
             * @param {int} [$limit] the maximum amount of $trades to fetch
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array[]} a list of {@link https://github.com/ccxt/ccxt/wiki/Manual#public-$trades trade structures}
             */
            Async\await($this->load_markets());
            $url = $this->urls['api']['ws'];
            $market = $this->market($symbol);
            $messageHash = 'trade:' . $market['symbol'];
            $request = array(
                'type' => 'subscribe',
                'channel' => 'v4_trades',
                'id' => $market['id'],
            );
            $trades = Async\await($this->watch($url, $messageHash, $this->extend($request, $params), $messageHash));
            if ($this->newUpdates) {
                $limit = $trades->getLimit ($symbol, $limit);
            }
            return $this->filter_by_since_limit($trades, $since, $limit, 'timestamp', true);
        }) ();
    }

    public function un_watch_trades(string $symbol, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $params) {
            /**
             * unsubscribes from the trades channel
             *
             * @see https://docs.dydx.xyz/indexer-client/websockets#trades
             *
             * @param {string} $symbol unified $symbol of the $market to fetch trades for
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array[]} a list of ~@link https://docs.ccxt.com/?id=public-trades trade structures~
             */
            Async\await($this->load_markets());
            $url = $this->urls['api']['ws'];
            $market = $this->market($symbol);
            $messageHash = 'trade:' . $market['symbol'];
            $request = array(
                'type' => 'unsubscribe',
                'channel' => 'v4_trades',
                'id' => $market['id'],
            );
            return Async\await($this->watch($url, $messageHash, $this->extend($request, $params), $messageHash));
        }) ();
    }

    public function handle_trades($client, $message) {
        //
        // {
        //     "type" => "subscribed",
        //     "connection_id" => "9011edff-d8f7-47fc-bbc6-0c7b5ba7dfae",
        //     "message_id" => 3,
        //     "channel" => "v4_trades",
        //     "id" => "BTC-USD",
        //     "contents" => {
        //         "trades" => array(
        //             {
        //                 "id" => "02b6148d0000000200000005",
        //                 "side" => "BUY",
        //                 "size" => "0.024",
        //                 "price" => "114581",
        //                 "type" => "LIMIT",
        //                 "createdAt" => "2025-08-04T00:42:07.119Z",
        //                 "createdAtHeight" => "45487245"
        //             }
        //         )
        //     }
        // }
        //
        $marketId = $this->safe_string($message, 'id');
        $market = $this->safe_market($marketId);
        $symbol = $market['symbol'];
        $content = $this->safe_dict($message, 'contents');
        $rawTrades = $this->safe_list($content, 'trades', array());
        $stored = $this->safe_value($this->trades, $symbol);
        if ($stored === null) {
            $limit = $this->safe_integer($this->options, 'tradesLimit', 1000);
            $stored = new ArrayCache ($limit);
            $this->trades[$symbol] = $stored;
        }
        $parsedTrades = $this->parse_trades($rawTrades, $market);
        for ($i = 0; $i < count($parsedTrades); $i++) {
            $parsed = $parsedTrades[$i];
            $stored->append ($parsed);
        }
        $messageHash = 'trade' . ':' . $symbol;
        $client->resolve ($stored, $messageHash);
    }

    public function parse_ws_trade($trade, $market = null) {
        //
        // {
        //     "id" => "02b6148d0000000200000003",
        //     "side" => "BUY",
        //     "size" => "0.024",
        //     "price" => "114581",
        //     "type" => "LIMIT",
        //     "createdAt" => "2025-08-04T00:42:07.118Z",
        //     "createdAtHeight" => "45487244"
        // }
        //
        $timestamp = $this->parse8601($this->safe_string($trade, 'createdAt'));
        return $this->safe_trade(array(
            'id' => $this->safe_string($trade, 'id'),
            'info' => $trade,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'symbol' => $this->safe_string($market, 'symbol'),
            'order' => null,
            'type' => $this->safe_string_lower($trade, 'type'),
            'side' => $this->safe_string_lower($trade, 'side'),
            'takerOrMaker' => null,
            'price' => $this->safe_string($trade, 'price'),
            'amount' => $this->safe_string($trade, 'size'),
            'cost' => null,
            'fee' => null,
        ), $market);
    }

    public function watch_order_book(string $symbol, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $limit, $params) {
            /**
             * watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
             *
             * @see https://docs.dydx.xyz/indexer-client/websockets#orders
             *
             * @param {string} $symbol unified $symbol of the $market to fetch the order book for
             * @param {int} [$limit] the maximum amount of order book entries to return
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} A dictionary of ~@link https://docs.ccxt.com/?id=order-book-structure order book structures~ indexed by $market symbols
             */
            Async\await($this->load_markets());
            $url = $this->urls['api']['ws'];
            $market = $this->market($symbol);
            $messageHash = 'orderbook:' . $market['symbol'];
            $request = array(
                'type' => 'subscribe',
                'channel' => 'v4_orderbook',
                'id' => $market['id'],
            );
            $orderbook = Async\await($this->watch($url, $messageHash, $this->extend($request, $params), $messageHash));
            return $orderbook->limit ();
        }) ();
    }

    public function un_watch_order_book(string $symbol, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $params) {
            /**
             * unWatches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
             *
             * @see https://docs.dydx.xyz/indexer-client/websockets#orders
             *
             * @param {string} $symbol unified array of symbols
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} A dictionary of ~@link https://docs.ccxt.com/?id=order-book-structure order book structures~ indexed by $market symbols
             */
            Async\await($this->load_markets());
            $url = $this->urls['api']['ws'];
            $market = $this->market($symbol);
            $messageHash = 'orderbook:' . $market['symbol'];
            $request = array(
                'type' => 'unsubscribe',
                'channel' => 'v4_orderbook',
                'id' => $market['id'],
            );
            return Async\await($this->watch($url, $messageHash, $this->extend($request, $params), $messageHash));
        }) ();
    }

    public function handle_order_book(Client $client, $message) {
        //
        // {
        //     "type" => "subscribed",
        //     "connection_id" => "7af140fb-b33d-4f0e-8f4c-30f16337b360",
        //     "message_id" => 1,
        //     "channel" => "v4_orderbook",
        //     "id" => "BTC-USD",
        //     "contents" => {
        //         "bids" => array(
        //             {
        //                 "price" => "114623",
        //                 "size" => "0.1112"
        //             }
        //         ),
        //         "asks" => array(
        //             {
        //                 "price" => "114624",
        //                 "size" => "0.0872"
        //             }
        //         )
        //     }
        // }
        //
        $marketId = $this->safe_string($message, 'id');
        $market = $this->safe_market($marketId);
        $symbol = $market['symbol'];
        $content = $this->safe_dict($message, 'contents');
        $orderbook = $this->safe_value($this->orderbooks, $symbol);
        if ($orderbook === null) {
            $orderbook = $this->order_book();
        }
        $orderbook['symbol'] = $symbol;
        $asks = $this->safe_list($content, 'asks', array());
        $bids = $this->safe_list($content, 'bids', array());
        $this->handle_deltas($orderbook['asks'], $asks);
        $this->handle_deltas($orderbook['bids'], $bids);
        $orderbook['nonce'] = $this->safe_integer($message, 'message_id');
        $messageHash = 'orderbook:' . $symbol;
        $this->orderbooks[$symbol] = $orderbook;
        $client->resolve ($orderbook, $messageHash);
    }

    public function handle_delta($bookside, $delta) {
        if ((gettype($delta) === 'array' && array_keys($delta) === array_keys(array_keys($delta)))) {
            $price = $this->safe_float($delta, 0);
            $amount = $this->safe_float($delta, 1);
            $bookside->store ($price, $amount);
        } else {
            $bidAsk = $this->parse_bid_ask($delta, 'price', 'size');
            $bookside->storeArray ($bidAsk);
        }
    }

    public function watch_ohlcv(string $symbol, $timeframe = '1m', ?int $since = null, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $timeframe, $since, $limit, $params) {
            /**
             * watches historical candlestick data containing the open, high, low, and close price, and the volume of a $market
             *
             * @see https://docs.dydx.xyz/indexer-client/websockets#candles
             *
             * @param {string} $symbol unified $symbol of the $market to fetch OHLCV data for
             * @param {string} $timeframe the length of time each candle represents
             * @param {int} [$since] timestamp in ms of the earliest candle to fetch
             * @param {int} [$limit] the maximum amount of candles to fetch
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {int[][]} A list of candles ordered, open, high, low, close, volume
             */
            Async\await($this->load_markets());
            $url = $this->urls['api']['ws'];
            $market = $this->market($symbol);
            $messageHash = 'ohlcv:' . $market['symbol'];
            $resolution = $this->safe_string($this->timeframes, $timeframe, $timeframe);
            $request = array(
                'type' => 'subscribe',
                'channel' => 'v4_candles',
                'id' => $market['id'] . '/' . $resolution,
            );
            $ohlcv = Async\await($this->watch($url, $messageHash, $this->extend($request, $params), $messageHash));
            if ($this->newUpdates) {
                $limit = $ohlcv->getLimit ($symbol, $limit);
            }
            return $this->filter_by_since_limit($ohlcv, $since, $limit, 0, true);
        }) ();
    }

    public function un_watch_ohlcv(string $symbol, $timeframe = '1m', $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $timeframe, $params) {
            /**
             * unWatches historical candlestick data containing the open, high, low, and close price, and the volume of a $market
             *
             * @see https://docs.dydx.xyz/indexer-client/websockets#candles
             *
             * @param {string} $symbol unified $symbol of the $market to fetch OHLCV data for
             * @param {string} $timeframe the length of time each candle represents
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @param {array} [$params->timezone] if provided, kline intervals are interpreted in that timezone instead of UTC, example '+08:00'
             * @return {int[][]} A list of candles ordered, open, high, low, close, volume
             */
            Async\await($this->load_markets());
            $url = $this->urls['api']['ws'];
            $market = $this->market($symbol);
            $messageHash = 'ohlcv:' . $market['symbol'];
            $resolution = $this->safe_string($this->timeframes, $timeframe, $timeframe);
            $request = array(
                'type' => 'unsubscribe',
                'channel' => 'v4_candles',
                'id' => $market['id'] . '/' . $resolution,
            );
            return Async\await($this->watch($url, $messageHash, $this->extend($request, $params), $messageHash));
        }) ();
    }

    public function handle_ohlcv(Client $client, $message) {
        //
        // {
        //     "type" => "subscribed",
        //     "connection_id" => "e00b6e27-590c-4e91-a24d-b0645289434b",
        //     "message_id" => 1,
        //     "channel" => "v4_candles",
        //     "id" => "BTC-USD/1MIN",
        //     "contents" => {
        //         "candles" => array(
        //             {
        //                 "startedAt" => "2025-08-05T03:40:00.000Z",
        //                 "ticker" => "BTC-USD",
        //                 "resolution" => "1MIN",
        //                 "low" => "114249",
        //                 "high" => "114256",
        //                 "open" => "114256",
        //                 "close" => "114249",
        //                 "baseTokenVolume" => "0.4726",
        //                 "usdVolume" => "53996.1818",
        //                 "trades" => 7,
        //                 "startingOpenInterest" => "501.7424",
        //                 "orderbookMidPriceOpen" => "114255.5",
        //                 "orderbookMidPriceClose" => "114255.5"
        //             }
        //         )
        //     }
        // }
        // {
        //     "type" => "channel_data",
        //     "connection_id" => "e00b6e27-590c-4e91-a24d-b0645289434b",
        //     "message_id" => 3,
        //     "id" => "BTC-USD/1MIN",
        //     "channel" => "v4_candles",
        //     "version" => "1.0.0",
        //     "contents" => {
        //         "startedAt" => "2025-08-05T03:40:00.000Z",
        //         "ticker" => "BTC-USD",
        //         "resolution" => "1MIN",
        //         "low" => "114249",
        //         "high" => "114262",
        //         "open" => "114256",
        //         "close" => "114261",
        //         "baseTokenVolume" => "0.4753",
        //         "usdVolume" => "54304.6873",
        //         "trades" => 9,
        //         "startingOpenInterest" => "501.7424",
        //         "orderbookMidPriceOpen" => "114255.5",
        //         "orderbookMidPriceClose" => "114255.5"
        //     }
        // }
        //
        $id = $this->safe_string($message, 'id');
        $part = explode('/', $id);
        $interval = $this->safe_string($part, 1);
        $timeframe = $this->find_timeframe($interval);
        $marketId = $this->safe_string($part, 0);
        $market = $this->safe_market($marketId);
        $symbol = $market['symbol'];
        $content = $this->safe_dict($message, 'contents');
        $candles = $this->safe_list($content, 'candles');
        $messageHash = 'ohlcv:' . $symbol;
        $ohlcv = $this->safe_dict($candles, 0, $content);
        $parsed = $this->parse_ohlcv($ohlcv, $market);
        $this->ohlcvs[$symbol] = $this->safe_value($this->ohlcvs, $symbol, array());
        $stored = $this->safe_value($this->ohlcvs[$symbol], $timeframe);
        if ($stored === null) {
            $limit = $this->safe_integer($this->options, 'OHLCVLimit', 1000);
            $stored = new ArrayCacheByTimestamp ($limit);
            $this->ohlcvs[$symbol][$timeframe] = $stored;
        }
        $stored->append ($parsed);
        $client->resolve ($stored, $messageHash);
    }

    public function handle_error_message(Client $client, $message) {
        //
        // {
        //     "type" => "error",
        //     "message" => "....",
        //     "connection_id" => "9011edff-d8f7-47fc-bbc6-0c7b5ba7dfae",
        //     "message_id" => 4
        // }
        //
        try {
            $msg = $this->safe_string($message, 'message');
            throw new ExchangeError($this->id . ' ' . $msg);
        } catch (Exception $e) {
            $client->reject ($e);
        }
        return true;
    }

    public function handle_message(Client $client, $message) {
        $type = $this->safe_string($message, 'type');
        if ($type === 'error') {
            $this->handle_error_message($client, $message);
            return;
        }
        if ($type !== null) {
            $topic = $this->safe_string($message, 'channel');
            $methods = array(
                'v4_trades' => array($this, 'handle_trades'),
                'v4_orderbook' => array($this, 'handle_order_book'),
                'v4_candles' => array($this, 'handle_ohlcv'),
            );
            $method = $this->safe_value($methods, $topic);
            if ($method !== null) {
                $method($client, $message);
            }
        }
    }
}
