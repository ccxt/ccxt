<?php

namespace ccxt\pro;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

use Exception; // a common import
use ccxt\ExchangeError;
use ccxt\AuthenticationError;
use ccxt\ArgumentsRequired;
use ccxt\NotSupported;
use ccxt\InvalidNonce;
use ccxt\Precise;
use React\Async;
use React\Promise\PromiseInterface;

class bitget extends \ccxt\async\bitget {

    public function describe() {
        return $this->deep_extend(parent::describe(), array(
            'has' => array(
                'ws' => true,
                'createOrderWs' => false,
                'editOrderWs' => false,
                'fetchOpenOrdersWs' => false,
                'fetchOrderWs' => false,
                'cancelOrderWs' => false,
                'cancelOrdersWs' => false,
                'cancelAllOrdersWs' => false,
                'watchBalance' => true,
                'watchMyTrades' => true,
                'watchOHLCV' => true,
                'watchOHLCVForSymbols' => false,
                'watchOrderBook' => true,
                'watchOrderBookForSymbols' => true,
                'watchOrders' => true,
                'watchTicker' => true,
                'watchTickers' => true,
                'watchTrades' => true,
                'watchTradesForSymbols' => true,
                'watchPositions' => true,
            ),
            'urls' => array(
                'api' => array(
                    'ws' => array(
                        'public' => 'wss://ws.bitget.com/v2/ws/public',
                        'private' => 'wss://ws.bitget.com/v2/ws/private',
                    ),
                ),
            ),
            'options' => array(
                'tradesLimit' => 1000,
                'OHLCVLimit' => 1000,
                // WS timeframes differ from REST timeframes
                'timeframes' => array(
                    '1m' => '1m',
                    '5m' => '5m',
                    '15m' => '15m',
                    '30m' => '30m',
                    '1h' => '1H',
                    '4h' => '4H',
                    '6h' => '6H',
                    '12h' => '12H',
                    '1d' => '1D',
                    '1w' => '1W',
                ),
            ),
            'streaming' => array(
                'ping' => array($this, 'ping'),
            ),
            'exceptions' => array(
                'ws' => array(
                    'exact' => array(
                        '30001' => '\\ccxt\\BadRequest', // array("event":"error","code":30001,"msg":"instType:sp,channel:candlenull,instId:BTCUSDT doesn't exist")
                        '30002' => '\\ccxt\\AuthenticationError', // illegal request
                        '30003' => '\\ccxt\\BadRequest', // invalid op
                        '30004' => '\\ccxt\\AuthenticationError', // requires login
                        '30005' => '\\ccxt\\AuthenticationError', // login failed
                        '30006' => '\\ccxt\\RateLimitExceeded', // too many requests
                        '30007' => '\\ccxt\\RateLimitExceeded', // request over limit,connection close
                        '30011' => '\\ccxt\\AuthenticationError', // invalid ACCESS_KEY
                        '30012' => '\\ccxt\\AuthenticationError', // invalid ACCESS_PASSPHRASE
                        '30013' => '\\ccxt\\AuthenticationError', // invalid ACCESS_TIMESTAMP
                        '30014' => '\\ccxt\\BadRequest', // Request timestamp expired
                        '30015' => '\\ccxt\\AuthenticationError', // array( event => 'error', code => 30015, msg => 'Invalid sign' )
                        '30016' => '\\ccxt\\BadRequest', // array( event => 'error', code => 30016, msg => 'Param error' )
                    ),
                    'broad' => array(),
                ),
            ),
        ));
    }

    public function get_inst_type($market, $params = array ()) {
        $instType = null;
        if ($market === null) {
            list($instType, $params) = $this->handleProductTypeAndParams (null, $params);
        } elseif (($market['swap']) || ($market['future'])) {
            list($instType, $params) = $this->handleProductTypeAndParams ($market, $params);
        } else {
            $instType = 'SPOT';
        }
        $instypeAux = null;
        list($instypeAux, $params) = $this->handle_option_and_params($params, 'getInstType', 'instType', $instType);
        $instType = $instypeAux;
        return array( $instType, $params );
    }

    public function watch_ticker(string $symbol, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $params) {
            /**
             * watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific $market
             * @see https://www.bitget.com/api-doc/spot/websocket/public/Tickers-Channel
             * @see https://www.bitget.com/api-doc/contract/websocket/public/Tickers-Channel
             * @param {string} $symbol unified $symbol of the $market to watch the ticker for
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} a ~@link https://docs.ccxt.com/#/?id=ticker-structure ticker structure~
             */
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $symbol = $market['symbol'];
            $messageHash = 'ticker:' . $symbol;
            $instType = null;
            list($instType, $params) = $this->get_inst_type($market, $params);
            $args = array(
                'instType' => $instType,
                'channel' => 'ticker',
                'instId' => $market['id'],
            );
            return Async\await($this->watch_public($messageHash, $args, $params));
        }) ();
    }

    public function watch_tickers(?array $symbols = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbols, $params) {
            /**
             * watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for all markets of a specific list
             * @see https://www.bitget.com/api-doc/spot/websocket/public/Tickers-Channel
             * @see https://www.bitget.com/api-doc/contract/websocket/public/Tickers-Channel
             * @param {string[]} $symbols unified $symbol of the $market to watch the $tickers for
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} a ~@link https://docs.ccxt.com/#/?id=ticker-structure ticker structure~
             */
            Async\await($this->load_markets());
            $symbols = $this->market_symbols($symbols, null, false);
            $market = $this->market($symbols[0]);
            $instType = null;
            list($instType, $params) = $this->get_inst_type($market, $params);
            $topics = array();
            $messageHashes = array();
            for ($i = 0; $i < count($symbols); $i++) {
                $symbol = $symbols[$i];
                $marketInner = $this->market($symbol);
                $args = array(
                    'instType' => $instType,
                    'channel' => 'ticker',
                    'instId' => $marketInner['id'],
                );
                $topics[] = $args;
                $messageHashes[] = 'ticker:' . $symbol;
            }
            $tickers = Async\await($this->watch_public_multiple($messageHashes, $topics, $params));
            if ($this->newUpdates) {
                $result = array();
                $result[$tickers['symbol']] = $tickers;
                return $result;
            }
            return $this->filter_by_array($this->tickers, 'symbol', $symbols);
        }) ();
    }

    public function handle_ticker(Client $client, $message) {
        //
        //     {
        //         "action" => "snapshot",
        //         "arg" => array(
        //             "instType" => "SPOT",
        //             "channel" => "ticker",
        //             "instId" => "BTCUSDT"
        //         ),
        //         "data" => array(
        //             {
        //                 "instId" => "BTCUSDT",
        //                 "lastPr" => "43528.19",
        //                 "open24h" => "42267.78",
        //                 "high24h" => "44490.00",
        //                 "low24h" => "41401.53",
        //                 "change24h" => "0.03879",
        //                 "bidPr" => "43528",
        //                 "askPr" => "43528.01",
        //                 "bidSz" => "0.0334",
        //                 "askSz" => "0.1917",
        //                 "baseVolume" => "15002.4216",
        //                 "quoteVolume" => "648006446.7164",
        //                 "openUtc" => "44071.18",
        //                 "changeUtc24h" => "-0.01232",
        //                 "ts" => "1701842994338"
        //             }
        //         ),
        //         "ts" => 1701842994341
        //     }
        //
        $ticker = $this->parse_ws_ticker($message);
        $symbol = $ticker['symbol'];
        $this->tickers[$symbol] = $ticker;
        $messageHash = 'ticker:' . $symbol;
        $client->resolve ($ticker, $messageHash);
    }

    public function parse_ws_ticker($message, $market = null) {
        //
        // spot
        //
        //     {
        //         "action" => "snapshot",
        //         "arg" => array(
        //             "instType" => "SPOT",
        //             "channel" => "ticker",
        //             "instId" => "BTCUSDT"
        //         ),
        //         "data" => array(
        //             {
        //                 "instId" => "BTCUSDT",
        //                 "lastPr" => "43528.19",
        //                 "open24h" => "42267.78",
        //                 "high24h" => "44490.00",
        //                 "low24h" => "41401.53",
        //                 "change24h" => "0.03879",
        //                 "bidPr" => "43528",
        //                 "askPr" => "43528.01",
        //                 "bidSz" => "0.0334",
        //                 "askSz" => "0.1917",
        //                 "baseVolume" => "15002.4216",
        //                 "quoteVolume" => "648006446.7164",
        //                 "openUtc" => "44071.18",
        //                 "changeUtc24h" => "-0.01232",
        //                 "ts" => "1701842994338"
        //             }
        //         ),
        //         "ts" => 1701842994341
        //     }
        //
        // contract
        //
        //     {
        //         "action" => "snapshot",
        //         "arg" => array(
        //             "instType" => "USDT-FUTURES",
        //             "channel" => "ticker",
        //             "instId" => "BTCUSDT"
        //         ),
        //         "data" => array(
        //             {
        //                 "instId" => "BTCUSDT",
        //                 "lastPr" => "43480.4",
        //                 "bidPr" => "43476.3",
        //                 "askPr" => "43476.8",
        //                 "bidSz" => "0.1",
        //                 "askSz" => "3.055",
        //                 "open24h" => "42252.3",
        //                 "high24h" => "44518.2",
        //                 "low24h" => "41387.0",
        //                 "change24h" => "0.03875",
        //                 "fundingRate" => "0.000096",
        //                 "nextFundingTime" => "1701849600000",
        //                 "markPrice" => "43476.4",
        //                 "indexPrice" => "43478.4",
        //                 "holdingAmount" => "50670.787",
        //                 "baseVolume" => "120187.104",
        //                 "quoteVolume" => "5167385048.693",
        //                 "openUtc" => "44071.4",
        //                 "symbolType" => "1",
        //                 "symbol" => "BTCUSDT",
        //                 "deliveryPrice" => "0",
        //                 "ts" => "1701843962811"
        //             }
        //         ),
        //         "ts" => 1701843962812
        //     }
        //
        $arg = $this->safe_value($message, 'arg', array());
        $data = $this->safe_value($message, 'data', array());
        $ticker = $this->safe_value($data, 0, array());
        $timestamp = $this->safe_integer($ticker, 'ts');
        $instType = $this->safe_string($arg, 'instType');
        $marketType = ($instType === 'SPOT') ? 'spot' : 'contract';
        $marketId = $this->safe_string($ticker, 'instId');
        $market = $this->safe_market($marketId, $market, null, $marketType);
        $close = $this->safe_string($ticker, 'lastPr');
        $changeDecimal = $this->safe_string($ticker, 'change24h');
        $change = Precise::string_mul($changeDecimal, '100');
        return $this->safe_ticker(array(
            'symbol' => $market['symbol'],
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'high' => $this->safe_string($ticker, 'high24h'),
            'low' => $this->safe_string($ticker, 'low24h'),
            'bid' => $this->safe_string($ticker, 'bidPr'),
            'bidVolume' => $this->safe_string($ticker, 'bidSz'),
            'ask' => $this->safe_string($ticker, 'askPr'),
            'askVolume' => $this->safe_string($ticker, 'askSz'),
            'vwap' => null,
            'open' => $this->safe_string($ticker, 'open24h'),
            'close' => $close,
            'last' => $close,
            'previousClose' => null,
            'change' => null,
            'percentage' => $change,
            'average' => null,
            'baseVolume' => $this->safe_string($ticker, 'baseVolume'),
            'quoteVolume' => $this->safe_string($ticker, 'quoteVolume'),
            'info' => $ticker,
        ), $market);
    }

    public function watch_ohlcv(string $symbol, $timeframe = '1m', ?int $since = null, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $timeframe, $since, $limit, $params) {
            /**
             * watches historical candlestick data containing the open, high, low, close price, and the volume of a $market
             * @see https://www.bitget.com/api-doc/spot/websocket/public/Candlesticks-Channel
             * @see https://www.bitget.com/api-doc/contract/websocket/public/Candlesticks-Channel
             * @param {string} $symbol unified $symbol of the $market to fetch OHLCV data for
             * @param {string} $timeframe the length of time each candle represents
             * @param {int} [$since] timestamp in ms of the earliest candle to fetch
             * @param {int} [$limit] the maximum amount of candles to fetch
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {int[][]} A list of candles ordered, open, high, low, close, volume
             */
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $symbol = $market['symbol'];
            $timeframes = $this->safe_value($this->options, 'timeframes');
            $interval = $this->safe_string($timeframes, $timeframe);
            $messageHash = 'candles:' . $timeframe . ':' . $symbol;
            $instType = null;
            list($instType, $params) = $this->get_inst_type($market, $params);
            $args = array(
                'instType' => $instType,
                'channel' => 'candle' . $interval,
                'instId' => $market['id'],
            );
            $ohlcv = Async\await($this->watch_public($messageHash, $args, $params));
            if ($this->newUpdates) {
                $limit = $ohlcv->getLimit ($symbol, $limit);
            }
            return $this->filter_by_since_limit($ohlcv, $since, $limit, 0, true);
        }) ();
    }

    public function handle_ohlcv(Client $client, $message) {
        //
        //     {
        //         "action" => "snapshot",
        //         "arg" => array(
        //             "instType" => "SPOT",
        //             "channel" => "candle1m",
        //             "instId" => "BTCUSDT"
        //         ),
        //         "data" => array(
        //             array(
        //                 "1701871620000",
        //                 "44080.23",
        //                 "44080.23",
        //                 "44028.5",
        //                 "44028.51",
        //                 "9.9287",
        //                 "437404.105512",
        //                 "437404.105512"
        //             ),
        //             array(
        //                 "1701871680000",
        //                 "44028.51",
        //                 "44108.11",
        //                 "44028.5",
        //                 "44108.11",
        //                 "17.139",
        //                 "755436.870643",
        //                 "755436.870643"
        //             ),
        //         ),
        //         "ts" => 1701901610417
        //     }
        //
        $arg = $this->safe_value($message, 'arg', array());
        $instType = $this->safe_string($arg, 'instType');
        $marketType = ($instType === 'SPOT') ? 'spot' : 'contract';
        $marketId = $this->safe_string($arg, 'instId');
        $market = $this->safe_market($marketId, null, null, $marketType);
        $symbol = $market['symbol'];
        $this->ohlcvs[$symbol] = $this->safe_value($this->ohlcvs, $symbol, array());
        $channel = $this->safe_string($arg, 'channel');
        $interval = str_replace('candle', '', $channel);
        $timeframes = $this->safe_value($this->options, 'timeframes');
        $timeframe = $this->find_timeframe($interval, $timeframes);
        $stored = $this->safe_value($this->ohlcvs[$symbol], $timeframe);
        if ($stored === null) {
            $limit = $this->safe_integer($this->options, 'OHLCVLimit', 1000);
            $stored = new ArrayCacheByTimestamp ($limit);
            $this->ohlcvs[$symbol][$timeframe] = $stored;
        }
        $data = $this->safe_value($message, 'data', array());
        for ($i = 0; $i < count($data); $i++) {
            $parsed = $this->parse_ws_ohlcv($data[$i], $market);
            $stored->append ($parsed);
        }
        $messageHash = 'candles:' . $timeframe . ':' . $symbol;
        $client->resolve ($stored, $messageHash);
    }

    public function parse_ws_ohlcv($ohlcv, $market = null): array {
        //
        //     array(
        //         "1701871620000",  // timestamp
        //         "44080.23", // open
        //         "44080.23", // high
        //         "44028.5", // low
        //         "44028.51", // close
        //         "9.9287", // base volume
        //         "437404.105512", // quote volume
        //         "437404.105512" // USDT volume
        //     )
        //
        $volumeIndex = ($market['inverse']) ? 6 : 5;
        return array(
            $this->safe_integer($ohlcv, 0),
            $this->safe_number($ohlcv, 1),
            $this->safe_number($ohlcv, 2),
            $this->safe_number($ohlcv, 3),
            $this->safe_number($ohlcv, 4),
            $this->safe_number($ohlcv, $volumeIndex),
        );
    }

    public function watch_order_book(string $symbol, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $limit, $params) {
            /**
             * watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
             * @see https://www.bitget.com/api-doc/spot/websocket/public/Depth-Channel
             * @see https://www.bitget.com/api-doc/contract/websocket/public/Order-Book-Channel
             * @param {string} $symbol unified $symbol of the market to fetch the order book for
             * @param {int} [$limit] the maximum amount of order book entries to return
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} A dictionary of ~@link https://docs.ccxt.com/#/?id=order-book-structure order book structures~ indexed by market symbols
             */
            return Async\await($this->watch_order_book_for_symbols(array( $symbol ), $limit, $params));
        }) ();
    }

    public function watch_order_book_for_symbols(array $symbols, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbols, $limit, $params) {
            /**
             * watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
             * @see https://www.bitget.com/api-doc/spot/websocket/public/Depth-Channel
             * @see https://www.bitget.com/api-doc/contract/websocket/public/Order-Book-Channel
             * @param {string[]} $symbols unified array of $symbols
             * @param {int} [$limit] the maximum amount of order book entries to return
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} A dictionary of ~@link https://docs.ccxt.com/#/?id=order-book-structure order book structures~ indexed by $market $symbols
             */
            Async\await($this->load_markets());
            $symbols = $this->market_symbols($symbols);
            $channel = 'books';
            $incrementalFeed = true;
            if (($limit === 1) || ($limit === 5) || ($limit === 15)) {
                $channel .= (string) $limit;
                $incrementalFeed = false;
            }
            $topics = array();
            $messageHashes = array();
            for ($i = 0; $i < count($symbols); $i++) {
                $symbol = $symbols[$i];
                $market = $this->market($symbol);
                $instType = null;
                list($instType, $params) = $this->get_inst_type($market, $params);
                $args = array(
                    'instType' => $instType,
                    'channel' => $channel,
                    'instId' => $market['id'],
                );
                $topics[] = $args;
                $messageHashes[] = 'orderbook:' . $symbol;
            }
            $orderbook = Async\await($this->watch_public_multiple($messageHashes, $topics, $params));
            if ($incrementalFeed) {
                return $orderbook->limit ();
            } else {
                return $orderbook;
            }
        }) ();
    }

    public function handle_order_book(Client $client, $message) {
        //
        //   {
        //       "action":"snapshot",
        //       "arg":array(
        //          "instType":"SPOT",
        //          "channel":"books5",
        //          "instId":"BTCUSDT"
        //       ),
        //       "data":[
        //          {
        //             "asks":[
        //                ["21041.11","0.0445"],
        //                ["21041.16","0.0411"],
        //                ["21041.21","0.0421"],
        //                ["21041.26","0.0811"],
        //                ["21041.65","1.9465"]
        //             ],
        //             "bids":[
        //                ["21040.76","0.0417"],
        //                ["21040.71","0.0434"],
        //                ["21040.66","0.1141"],
        //                ["21040.61","0.3004"],
        //                ["21040.60","1.3357"]
        //             ],
        //             "checksum" => -1367582038,
        //             "ts":"1656413855484"
        //          }
        //       ]
        //   }
        //
        $arg = $this->safe_value($message, 'arg');
        $channel = $this->safe_string($arg, 'channel');
        $instType = $this->safe_string($arg, 'instType');
        $marketType = ($instType === 'SPOT') ? 'spot' : 'contract';
        $marketId = $this->safe_string($arg, 'instId');
        $market = $this->safe_market($marketId, null, null, $marketType);
        $symbol = $market['symbol'];
        $messageHash = 'orderbook:' . $symbol;
        $data = $this->safe_value($message, 'data');
        $rawOrderBook = $this->safe_value($data, 0);
        $timestamp = $this->safe_integer($rawOrderBook, 'ts');
        $incrementalBook = $channel === 'books';
        if ($incrementalBook) {
            // $storedOrderBook = $this->safe_value($this->orderbooks, $symbol);
            if (!(is_array($this->orderbooks) && array_key_exists($symbol, $this->orderbooks))) {
                // $ob = $this->order_book(array());
                $ob = $this->counted_order_book(array());
                $ob['symbol'] = $symbol;
                $this->orderbooks[$symbol] = $ob;
            }
            $storedOrderBook = $this->orderbooks[$symbol];
            $asks = $this->safe_value($rawOrderBook, 'asks', array());
            $bids = $this->safe_value($rawOrderBook, 'bids', array());
            $this->handle_deltas($storedOrderBook['asks'], $asks);
            $this->handle_deltas($storedOrderBook['bids'], $bids);
            $storedOrderBook['timestamp'] = $timestamp;
            $storedOrderBook['datetime'] = $this->iso8601($timestamp);
            $checksum = $this->safe_bool($this->options, 'checksum', true);
            $isSnapshot = $this->safe_string($message, 'action') === 'snapshot'; // snapshot does not have a $checksum
            if (!$isSnapshot && $checksum) {
                $storedAsks = $storedOrderBook['asks'];
                $storedBids = $storedOrderBook['bids'];
                $asksLength = count($storedAsks);
                $bidsLength = count($storedBids);
                $payloadArray = array();
                for ($i = 0; $i < 25; $i++) {
                    if ($i < $bidsLength) {
                        $payloadArray[] = $storedBids[$i][2][0];
                        $payloadArray[] = $storedBids[$i][2][1];
                    }
                    if ($i < $asksLength) {
                        $payloadArray[] = $storedAsks[$i][2][0];
                        $payloadArray[] = $storedAsks[$i][2][1];
                    }
                }
                $payload = implode(':', $payloadArray);
                $calculatedChecksum = $this->crc32($payload, true);
                $responseChecksum = $this->safe_integer($rawOrderBook, 'checksum');
                if ($calculatedChecksum !== $responseChecksum) {
                    $error = new InvalidNonce ($this->id . ' invalid checksum');
                    unset($client->subscriptions[$messageHash]);
                    unset($this->orderbooks[$symbol]);
                    $client->reject ($error, $messageHash);
                    return;
                }
            }
        } else {
            $orderbook = $this->order_book(array());
            $parsedOrderbook = $this->parse_order_book($rawOrderBook, $symbol, $timestamp);
            $orderbook->reset ($parsedOrderbook);
            $this->orderbooks[$symbol] = $orderbook;
        }
        $client->resolve ($this->orderbooks[$symbol], $messageHash);
    }

    public function handle_delta($bookside, $delta) {
        $bidAsk = $this->parse_bid_ask($delta, 0, 1);
        // we store the string representations in the orderbook for checksum calculation
        // this simplifies the code for generating checksums do not need to do any complex number transformations
        $bidAsk[] = $delta;
        $bookside->storeArray ($bidAsk);
    }

    public function handle_deltas($bookside, $deltas) {
        for ($i = 0; $i < count($deltas); $i++) {
            $this->handle_delta($bookside, $deltas[$i]);
        }
    }

    public function watch_trades(string $symbol, ?int $since = null, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            /**
             * get the list of most recent trades for a particular $symbol
             * @see https://www.bitget.com/api-doc/spot/websocket/public/Trades-Channel
             * @see https://www.bitget.com/api-doc/contract/websocket/public/New-Trades-Channel
             * @param {string} $symbol unified $symbol of the market to fetch trades for
             * @param {int} [$since] timestamp in ms of the earliest trade to fetch
             * @param {int} [$limit] the maximum amount of trades to fetch
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array[]} a list of ~@link https://docs.ccxt.com/#/?id=public-trades trade structures~
             */
            return Async\await($this->watch_trades_for_symbols(array( $symbol ), $since, $limit, $params));
        }) ();
    }

    public function watch_trades_for_symbols(array $symbols, ?int $since = null, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbols, $since, $limit, $params) {
            /**
             * get the list of most recent $trades for a particular $symbol
             * @see https://www.bitget.com/api-doc/spot/websocket/public/Trades-Channel
             * @see https://www.bitget.com/api-doc/contract/websocket/public/New-Trades-Channel
             * @param {string} $symbol unified $symbol of the $market to fetch $trades for
             * @param {int} [$since] timestamp in ms of the earliest trade to fetch
             * @param {int} [$limit] the maximum amount of $trades to fetch
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array[]} a list of ~@link https://docs.ccxt.com/#/?id=public-$trades trade structures~
             */
            $symbolsLength = count($symbols);
            if ($symbolsLength === 0) {
                throw new ArgumentsRequired($this->id . ' watchTradesForSymbols() requires a non-empty array of symbols');
            }
            Async\await($this->load_markets());
            $symbols = $this->market_symbols($symbols);
            $topics = array();
            $messageHashes = array();
            for ($i = 0; $i < count($symbols); $i++) {
                $symbol = $symbols[$i];
                $market = $this->market($symbol);
                $instType = null;
                list($instType, $params) = $this->get_inst_type($market, $params);
                $args = array(
                    'instType' => $instType,
                    'channel' => 'trade',
                    'instId' => $market['id'],
                );
                $topics[] = $args;
                $messageHashes[] = 'trade:' . $symbol;
            }
            $trades = Async\await($this->watch_public_multiple($messageHashes, $topics, $params));
            if ($this->newUpdates) {
                $first = $this->safe_value($trades, 0);
                $tradeSymbol = $this->safe_string($first, 'symbol');
                $limit = $trades->getLimit ($tradeSymbol, $limit);
            }
            return $this->filter_by_since_limit($trades, $since, $limit, 'timestamp', true);
        }) ();
    }

    public function handle_trades(Client $client, $message) {
        //
        //     {
        //         "action" => "snapshot",
        //         "arg" => array( "instType" => "SPOT", "channel" => "trade", "instId" => "BTCUSDT" ),
        //         "data" => array(
        //             array(
        //                 "ts" => "1701910980366",
        //                 "price" => "43854.01",
        //                 "size" => "0.0535",
        //                 "side" => "buy",
        //                 "tradeId" => "1116461060594286593"
        //             ),
        //         ),
        //         "ts" => 1701910980730
        //     }
        //
        $arg = $this->safe_value($message, 'arg', array());
        $instType = $this->safe_string($arg, 'instType');
        $marketType = ($instType === 'SPOT') ? 'spot' : 'contract';
        $marketId = $this->safe_string($arg, 'instId');
        $market = $this->safe_market($marketId, null, null, $marketType);
        $symbol = $market['symbol'];
        $stored = $this->safe_value($this->trades, $symbol);
        if ($stored === null) {
            $limit = $this->safe_integer($this->options, 'tradesLimit', 1000);
            $stored = new ArrayCache ($limit);
            $this->trades[$symbol] = $stored;
        }
        $data = $this->safe_list($message, 'data', array());
        $length = count($data);
        // fix chronological order by reversing
        for ($i = 0; $i < $length; $i++) {
            $index = $length - $i - 1;
            $rawTrade = $data[$index];
            $parsed = $this->parse_ws_trade($rawTrade, $market);
            $stored->append ($parsed);
        }
        $messageHash = 'trade:' . $symbol;
        $client->resolve ($stored, $messageHash);
    }

    public function parse_ws_trade($trade, $market = null) {
        //
        //     {
        //         "ts" => "1701910980366",
        //         "price" => "43854.01",
        //         "size" => "0.0535",
        //         "side" => "buy",
        //         "tradeId" => "1116461060594286593"
        //     }
        // swap private
        //
        //            {
        //               "orderId" => "1169142761031114781",
        //               "tradeId" => "1169142761312637004",
        //               "symbol" => "LTCUSDT",
        //               "orderType" => "market",
        //               "side" => "buy",
        //               "price" => "80.87",
        //               "baseVolume" => "0.1",
        //               "quoteVolume" => "8.087",
        //               "profit" => "0",
        //               "tradeSide" => "open",
        //               "posMode" => "hedge_mode",
        //               "tradeScope" => "taker",
        //               "feeDetail" => array(
        //                  {
        //                     "feeCoin" => "USDT",
        //                     "deduction" => "no",
        //                     "totalDeductionFee" => "0",
        //                     "totalFee" => "-0.0048522"
        //                  }
        //               ),
        //               "cTime" => "1714471276596",
        //               "uTime" => "1714471276596"
        //            }
        // spot private
        //        {
        //           "orderId" => "1169142457356959747",
        //           "tradeId" => "1169142457636958209",
        //           "symbol" => "LTCUSDT",
        //           "orderType" => "market",
        //           "side" => "buy",
        //           "priceAvg" => "81.069",
        //           "size" => "0.074",
        //           "amount" => "5.999106",
        //           "tradeScope" => "taker",
        //           "feeDetail" => array(
        //              {
        //                 "feeCoin" => "LTC",
        //                 "deduction" => "no",
        //                 "totalDeductionFee" => "0",
        //                 "totalFee" => "0.000074"
        //              }
        //           ),
        //           "cTime" => "1714471204194",
        //           "uTime" => "1714471204194"
        //        }
        //
        $instId = $this->safe_string_2($trade, 'symbol', 'instId');
        $posMode = $this->safe_string($trade, 'posMode');
        $defaultType = ($posMode !== null) ? 'contract' : 'spot';
        if ($market === null) {
            $market = $this->safe_market($instId, null, null, $defaultType);
        }
        $timestamp = $this->safe_integer_n($trade, array( 'uTime', 'cTime', 'ts' ));
        $feeDetail = $this->safe_list($trade, 'feeDetail', array());
        $first = $this->safe_dict($feeDetail, 0);
        $fee = null;
        if ($first !== null) {
            $feeCurrencyId = $this->safe_string($first, 'feeCoin');
            $feeCurrencyCode = $this->safe_currency_code($feeCurrencyId);
            $fee = array(
                'cost' => Precise::string_abs($this->safe_string($first, 'totalFee')),
                'currency' => $feeCurrencyCode,
            );
        }
        return $this->safe_trade(array(
            'info' => $trade,
            'id' => $this->safe_string($trade, 'tradeId'),
            'order' => $this->safe_string($trade, 'orderId'),
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'symbol' => $market['symbol'],
            'type' => $this->safe_string($trade, 'orderType'),
            'side' => $this->safe_string($trade, 'side'),
            'takerOrMaker' => $this->safe_string($trade, 'tradeScope'),
            'price' => $this->safe_string_2($trade, 'priceAvg', 'price'),
            'amount' => $this->safe_string_2($trade, 'size', 'baseVolume'),
            'cost' => $this->safe_string_2($trade, 'amount', 'quoteVolume'),
            'fee' => $fee,
        ), $market);
    }

    public function watch_positions(?array $symbols = null, ?int $since = null, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbols, $since, $limit, $params) {
            /**
             * watch all open positions
             * @see https://www.bitget.com/api-doc/contract/websocket/private/Positions-Channel
             * @param {string[]|null} $symbols list of unified $market $symbols
             * @param {array} $params extra parameters specific to the exchange API endpoint
             * @param {string} [$params->instType] one of 'USDT-FUTURES', 'USDC-FUTURES', 'COIN-FUTURES', 'SUSDT-FUTURES', 'SUSDC-FUTURES' or 'SCOIN-FUTURES', default is 'USDT-FUTURES'
             * @return {array[]} a list of {@link https://docs.ccxt.com/en/latest/manual.html#position-structure position structure}
             */
            Async\await($this->load_markets());
            $market = null;
            $messageHash = '';
            $subscriptionHash = 'positions';
            $instType = 'USDT-FUTURES';
            $symbols = $this->market_symbols($symbols);
            if (!$this->is_empty($symbols)) {
                $market = $this->get_market_from_symbols($symbols);
                list($instType, $params) = $this->get_inst_type($market, $params);
            }
            $messageHash = $instType . ':positions' . $messageHash;
            $args = array(
                'instType' => $instType,
                'channel' => 'positions',
                'instId' => 'default',
            );
            $newPositions = Async\await($this->watch_private($messageHash, $subscriptionHash, $args, $params));
            if ($this->newUpdates) {
                return $newPositions;
            }
            return $this->filter_by_symbols_since_limit($newPositions, $symbols, $since, $limit, true);
        }) ();
    }

    public function handle_positions(Client $client, $message) {
        //
        //     {
        //         "action" => "snapshot",
        //         "arg" => array(
        //             "instType" => "USDT-FUTURES",
        //             "channel" => "positions",
        //             "instId" => "default"
        //         ),
        //         "data" => array(
        //             array(
        //                 "posId" => "926036334386778112",
        //                 "instId" => "BTCUSDT",
        //                 "marginCoin" => "USDT",
        //                 "marginSize" => "2.19245",
        //                 "marginMode" => "crossed",
        //                 "holdSide" => "long",
        //                 "posMode" => "hedge_mode",
        //                 "total" => "0.001",
        //                 "available" => "0.001",
        //                 "frozen" => "0",
        //                 "openPriceAvg" => "43849",
        //                 "leverage" => 20,
        //                 "achievedProfits" => "0",
        //                 "unrealizedPL" => "-0.0032",
        //                 "unrealizedPLR" => "-0.00145955438",
        //                 "liquidationPrice" => "17629.684814834",
        //                 "keepMarginRate" => "0.004",
        //                 "marginRate" => "0.007634649185",
        //                 "cTime" => "1652331666985",
        //                 "uTime" => "1701913016923",
        //                 "autoMargin" => "off"
        //             ),
        //             ...
        //         )
        //         "ts" => 1701913043767
        //     }
        //
        $arg = $this->safe_value($message, 'arg', array());
        $instType = $this->safe_string($arg, 'instType', '');
        if ($this->positions === null) {
            $this->positions = array();
        }
        if (!(is_array($this->positions) && array_key_exists($instType, $this->positions))) {
            $this->positions[$instType] = new ArrayCacheBySymbolBySide ();
        }
        $cache = $this->positions[$instType];
        $rawPositions = $this->safe_value($message, 'data', array());
        $dataLength = count($rawPositions);
        if ($dataLength === 0) {
            return;
        }
        $newPositions = array();
        for ($i = 0; $i < count($rawPositions); $i++) {
            $rawPosition = $rawPositions[$i];
            $marketId = $this->safe_string($rawPosition, 'instId');
            $market = $this->safe_market($marketId, null, null, 'contract');
            $position = $this->parse_ws_position($rawPosition, $market);
            $newPositions[] = $position;
            $cache->append ($position);
        }
        $messageHashes = $this->find_message_hashes($client, $instType . ':$positions::');
        for ($i = 0; $i < count($messageHashes); $i++) {
            $messageHash = $messageHashes[$i];
            $parts = explode('::', $messageHash);
            $symbolsString = $parts[1];
            $symbols = explode(',', $symbolsString);
            $positions = $this->filter_by_array($newPositions, 'symbol', $symbols, false);
            if (!$this->is_empty($positions)) {
                $client->resolve ($positions, $messageHash);
            }
        }
        $client->resolve ($newPositions, $instType . ':positions');
    }

    public function parse_ws_position($position, $market = null) {
        //
        //     {
        //         "posId" => "926036334386778112",
        //         "instId" => "BTCUSDT",
        //         "marginCoin" => "USDT",
        //         "marginSize" => "2.19245",
        //         "marginMode" => "crossed",
        //         "holdSide" => "long",
        //         "posMode" => "hedge_mode",
        //         "total" => "0.001",
        //         "available" => "0.001",
        //         "frozen" => "0",
        //         "openPriceAvg" => "43849",
        //         "leverage" => 20,
        //         "achievedProfits" => "0",
        //         "unrealizedPL" => "-0.0032",
        //         "unrealizedPLR" => "-0.00145955438",
        //         "liquidationPrice" => "17629.684814834",
        //         "keepMarginRate" => "0.004",
        //         "marginRate" => "0.007634649185",
        //         "cTime" => "1652331666985",
        //         "uTime" => "1701913016923",
        //         "autoMargin" => "off"
        //     }
        //
        $marketId = $this->safe_string($position, 'instId');
        $marginModeId = $this->safe_string($position, 'marginMode');
        $marginMode = $this->get_supported_mapping($marginModeId, array(
            'crossed' => 'cross',
            'isolated' => 'isolated',
        ));
        $hedgedId = $this->safe_string($position, 'posMode');
        $hedged = ($hedgedId === 'hedge_mode') ? true : false;
        $timestamp = $this->safe_integer_2($position, 'uTime', 'cTime');
        $percentageDecimal = $this->safe_string($position, 'unrealizedPLR');
        $percentage = Precise::string_mul($percentageDecimal, '100');
        $contractSize = null;
        if ($market !== null) {
            $contractSize = $market['contractSize'];
        }
        return $this->safe_position(array(
            'info' => $position,
            'id' => $this->safe_string($position, 'posId'),
            'symbol' => $this->safe_symbol($marketId, $market, null, 'contract'),
            'notional' => null,
            'marginMode' => $marginMode,
            'liquidationPrice' => $this->safe_number($position, 'liquidationPrice'),
            'entryPrice' => $this->safe_number($position, 'openPriceAvg'),
            'unrealizedPnl' => $this->safe_number($position, 'unrealizedPL'),
            'percentage' => $this->parse_number($percentage),
            'contracts' => $this->safe_number($position, 'total'),
            'contractSize' => $contractSize,
            'markPrice' => null,
            'side' => $this->safe_string($position, 'holdSide'),
            'hedged' => $hedged,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'maintenanceMargin' => null,
            'maintenanceMarginPercentage' => $this->safe_number($position, 'keepMarginRate'),
            'collateral' => null,
            'initialMargin' => null,
            'initialMarginPercentage' => null,
            'leverage' => $this->safe_number($position, 'leverage'),
            'marginRatio' => $this->safe_number($position, 'marginRate'),
        ));
    }

    public function watch_orders(?string $symbol = null, ?int $since = null, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            /**
             * watches information on multiple $orders made by the user
             * @see https://www.bitget.com/api-doc/spot/websocket/private/Order-Channel
             * @see https://www.bitget.com/api-doc/contract/websocket/private/Order-Channel
             * @see https://www.bitget.com/api-doc/contract/websocket/private/Plan-Order-Channel
             * @see https://www.bitget.com/api-doc/margin/cross/websocket/private/Cross-Orders
             * @see https://www.bitget.com/api-doc/margin/isolated/websocket/private/Isolate-Orders
             * @param {string} $symbol unified $market $symbol of the $market $orders were made in
             * @param {int} [$since] the earliest time in ms to fetch $orders for
             * @param {int} [$limit] the maximum number of order structures to retrieve
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @param {boolean} [$params->stop] *contract only* set to true for watching trigger $orders
             * @param {string} [$params->marginMode] 'isolated' or 'cross' for watching spot margin $orders
             * @return {array[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure
             */
            Async\await($this->load_markets());
            $market = null;
            $marketId = null;
            $isStop = $this->safe_bool($params, 'stop', false);
            $params = $this->omit($params, 'stop');
            $messageHash = ($isStop) ? 'triggerOrder' : 'order';
            $subscriptionHash = 'order:trades';
            if ($symbol !== null) {
                $market = $this->market($symbol);
                $symbol = $market['symbol'];
                $marketId = $market['id'];
                $messageHash = $messageHash . ':' . $symbol;
            }
            $type = null;
            list($type, $params) = $this->handle_market_type_and_params('watchOrders', $market, $params);
            if (($type === 'spot') && ($symbol === null)) {
                throw new ArgumentsRequired($this->id . ' watchOrders requires a $symbol argument for ' . $type . ' markets.');
            }
            if ($isStop && $type === 'spot') {
                throw new NotSupported($this->id . ' watchOrders does not support stop $orders for ' . $type . ' markets.');
            }
            $instType = null;
            list($instType, $params) = $this->get_inst_type($market, $params);
            if ($type === 'spot') {
                $subscriptionHash = $subscriptionHash . ':' . $symbol;
            }
            if ($isStop) {
                $subscriptionHash = $subscriptionHash . ':stop'; // we don't want to re-use the same subscription hash for stop $orders
            }
            $instId = ($type === 'spot') ? $marketId : 'default'; // different from other streams here the 'rest' id is required for spot markets, contract markets require default here
            $channel = $isStop ? 'orders-algo' : 'orders';
            $marginMode = null;
            list($marginMode, $params) = $this->handle_margin_mode_and_params('watchOrders', $params);
            if ($marginMode !== null) {
                $instType = 'MARGIN';
                if ($marginMode === 'isolated') {
                    $channel = 'orders-isolated';
                } else {
                    $channel = 'orders-crossed';
                }
            }
            $args = array(
                'instType' => $instType,
                'channel' => $channel,
                'instId' => $instId,
            );
            $orders = Async\await($this->watch_private($messageHash, $subscriptionHash, $args, $params));
            if ($this->newUpdates) {
                $limit = $orders->getLimit ($symbol, $limit);
            }
            return $this->filter_by_symbol_since_limit($orders, $symbol, $since, $limit, true);
        }) ();
    }

    public function handle_order(Client $client, $message) {
        //
        // spot
        //
        //     {
        //         "action" => "snapshot",
        //         "arg" => array( "instType" => "SPOT", "channel" => "orders", "instId" => "BTCUSDT" ),
        //         "data" => array(
        //             {
        //                 "instId" => "BTCUSDT",
        //                 "orderId" => "1116512721422422017",
        //                 "clientOid" => "798d1425-d31d-4ada-a51b-ec701e00a1d9",
        //                 "price" => "35000.00",
        //                 "size" => "7.0000",
        //                 "newSize" => "500.0000",
        //                 "notional" => "7.000000",
        //                 "orderType" => "limit",
        //                 "force" => "gtc",
        //                 "side" => "buy",
        //                 "accBaseVolume" => "0.0000",
        //                 "priceAvg" => "0.00",
        //                 "status" => "live",
        //                 "cTime" => "1701923297267",
        //                 "uTime" => "1701923297267",
        //                 "feeDetail" => array(),
        //                 "enterPointSource" => "WEB"
        //             }
        //         ),
        //         "ts" => 1701923297285
        //     }
        //
        // contract
        //
        //     {
        //         "action" => "snapshot",
        //         "arg" => array( "instType" => "USDT-FUTURES", "channel" => "orders", "instId" => "default" ),
        //         "data" => [
        //             {
        //                 "accBaseVolume" => "0",
        //                 "cTime" => "1701920553759",
        //                 "clientOid" => "1116501214318198793",
        //                 "enterPointSource" => "WEB",
        //                 "feeDetail" => [array(
        //                     "feeCoin" => "USDT",
        //                     "fee" => "-0.162003"
        //                 )],
        //                 "force" => "gtc",
        //                 "instId" => "BTCUSDT",
        //                 "leverage" => "20",
        //                 "marginCoin" => "USDT",
        //                 "marginMode" => "isolated",
        //                 "notionalUsd" => "105",
        //                 "orderId" => "1116501214293032964",
        //                 "orderType" => "limit",
        //                 "posMode" => "hedge_mode",
        //                 "posSide" => "long",
        //                 "price" => "35000",
        //                 "reduceOnly" => "no",
        //                 "side" => "buy",
        //                 "size" => "0.003",
        //                 "status" => "canceled",
        //                 "tradeSide" => "open",
        //                 "uTime" => "1701920595866"
        //             }
        //         ],
        //         "ts" => 1701920595879
        //     }
        //
        // trigger
        //
        //     {
        //         "action" => "snapshot",
        //         "arg" => array(
        //             "instType" => "USDT-FUTURES",
        //             "channel" => "orders-algo",
        //             "instId" => "default"
        //         ),
        //         "data" => array(
        //             {
        //                 "instId" => "BTCUSDT",
        //                 "orderId" => "1116508960750899201",
        //                 "clientOid" => "1116508960750899200",
        //                 "triggerPrice" => "35000.000000000",
        //                 "triggerType" => "mark_price",
        //                 "triggerTime" => "1701922464373",
        //                 "planType" => "pl",
        //                 "price" => "35000.000000000",
        //                 "size" => "0.001000000",
        //                 "actualSize" => "0.000000000",
        //                 "orderType" => "limit",
        //                 "side" => "buy",
        //                 "tradeSide" => "open",
        //                 "posSide" => "long",
        //                 "marginCoin" => "USDT",
        //                 "status" => "cancelled",
        //                 "posMode" => "hedge_mode",
        //                 "enterPointSource" => "api",
        //                 "stopSurplusTriggerType" => "fill_price",
        //                 "stopLossTriggerType" => "fill_price",
        //                 "cTime" => "1701922400653",
        //                 "uTime" => "1701922464373"
        //             }
        //         ),
        //         "ts" => 1701922464417
        //     }
        //
        // isolated and cross margin
        //
        //     {
        //         "action" => "snapshot",
        //         "arg" => array( "instType" => "MARGIN", "channel" => "orders-crossed", "instId" => "BTCUSDT" ),
        //         "data" => array(
        //             {
        //                 "enterPointSource" => "web",
        //                 "force" => "gtc",
        //                 "orderType" => "limit",
        //                 "price" => "35000.000000000",
        //                 "quoteSize" => "10.500000000",
        //                 "side" => "buy",
        //                 "status" => "live",
        //                 "baseSize" => "0.000300000",
        //                 "cTime" => "1701923982427",
        //                 "clientOid" => "4902047879864dc980c4840e9906db4e",
        //                 "fillPrice" => "0.000000000",
        //                 "baseVolume" => "0.000000000",
        //                 "fillTotalAmount" => "0.000000000",
        //                 "loanType" => "auto-loan-and-repay",
        //                 "orderId" => "1116515595178356737"
        //             }
        //         ),
        //         "ts" => 1701923982497
        //     }
        //
        $arg = $this->safe_value($message, 'arg', array());
        $channel = $this->safe_string($arg, 'channel');
        $instType = $this->safe_string($arg, 'instType');
        $marketType = null;
        if ($instType === 'SPOT') {
            $marketType = 'spot';
        } elseif ($instType === 'MARGIN') {
            $marketType = 'spot';
        } else {
            $marketType = 'contract';
        }
        $data = $this->safe_value($message, 'data', array());
        if ($this->orders === null) {
            $limit = $this->safe_integer($this->options, 'ordersLimit', 1000);
            $this->orders = new ArrayCacheBySymbolById ($limit);
            $this->triggerOrders = new ArrayCacheBySymbolById ($limit);
        }
        $stored = ($channel === 'ordersAlgo') ? $this->triggerOrders : $this->orders;
        $messageHash = ($channel === 'ordersAlgo') ? 'triggerOrder' : 'order';
        $marketSymbols = array();
        for ($i = 0; $i < count($data); $i++) {
            $order = $data[$i];
            $marketId = $this->safe_string($order, 'instId');
            $market = $this->safe_market($marketId, null, null, $marketType);
            $parsed = $this->parse_ws_order($order, $market);
            $stored->append ($parsed);
            $symbol = $parsed['symbol'];
            $marketSymbols[$symbol] = true;
        }
        $keys = is_array($marketSymbols) ? array_keys($marketSymbols) : array();
        for ($i = 0; $i < count($keys); $i++) {
            $symbol = $keys[$i];
            $innerMessageHash = $messageHash . ':' . $symbol;
            $client->resolve ($stored, $innerMessageHash);
        }
        $client->resolve ($stored, $messageHash);
    }

    public function parse_ws_order($order, $market = null) {
        //
        // spot
        //
        //     {
        //         "instId" => "BTCUSDT",
        //         "orderId" => "1116512721422422017",
        //         "clientOid" => "798d1425-d31d-4ada-a51b-ec701e00a1d9",
        //         "price" => "35000.00",
        //         "size" => "7.0000",
        //         "newSize" => "500.0000",
        //         "notional" => "7.000000",
        //         "orderType" => "limit",
        //         "force" => "gtc",
        //         "side" => "buy",
        //         "accBaseVolume" => "0.0000",
        //         "priceAvg" => "0.00",
        //         "status" => "live",
        //         "cTime" => "1701923297267",
        //         "uTime" => "1701923297267",
        //         "feeDetail" => array(),
        //         "enterPointSource" => "WEB"
        //     }
        //
        // contract
        //
        //     {
        //         "accBaseVolume" => "0",
        //         "cTime" => "1701920553759",
        //         "clientOid" => "1116501214318198793",
        //         "enterPointSource" => "WEB",
        //         "feeDetail" => [array(
        //             "feeCoin" => "USDT",
        //             "fee" => "-0.162003"
        //         )],
        //         "force" => "gtc",
        //         "instId" => "BTCUSDT",
        //         "leverage" => "20",
        //         "marginCoin" => "USDT",
        //         "marginMode" => "isolated",
        //         "notionalUsd" => "105",
        //         "orderId" => "1116501214293032964",
        //         "orderType" => "limit",
        //         "posMode" => "hedge_mode",
        //         "posSide" => "long",
        //         "price" => "35000",
        //         "reduceOnly" => "no",
        //         "side" => "buy",
        //         "size" => "0.003",
        //         "status" => "canceled",
        //         "tradeSide" => "open",
        //         "uTime" => "1701920595866"
        //     }
        //
        // trigger
        //
        //     {
        //         "instId" => "BTCUSDT",
        //         "orderId" => "1116508960750899201",
        //         "clientOid" => "1116508960750899200",
        //         "triggerPrice" => "35000.000000000",
        //         "triggerType" => "mark_price",
        //         "triggerTime" => "1701922464373",
        //         "planType" => "pl",
        //         "price" => "35000.000000000",
        //         "size" => "0.001000000",
        //         "actualSize" => "0.000000000",
        //         "orderType" => "limit",
        //         "side" => "buy",
        //         "tradeSide" => "open",
        //         "posSide" => "long",
        //         "marginCoin" => "USDT",
        //         "status" => "cancelled",
        //         "posMode" => "hedge_mode",
        //         "enterPointSource" => "api",
        //         "stopSurplusTriggerType" => "fill_price",
        //         "stopLossTriggerType" => "fill_price",
        //         "cTime" => "1701922400653",
        //         "uTime" => "1701922464373"
        //     }
        //
        // isolated and cross margin
        //
        //     {
        //         "enterPointSource" => "web",
        //         "force" => "gtc",
        //         "orderType" => "limit",
        //         "price" => "35000.000000000",
        //         "quoteSize" => "10.500000000",
        //         "side" => "buy",
        //         "status" => "live",
        //         "baseSize" => "0.000300000",
        //         "cTime" => "1701923982427",
        //         "clientOid" => "4902047879864dc980c4840e9906db4e",
        //         "fillPrice" => "0.000000000",
        //         "baseVolume" => "0.000000000",
        //         "fillTotalAmount" => "0.000000000",
        //         "loanType" => "auto-loan-and-repay",
        //         "orderId" => "1116515595178356737"
        //     }
        //
        $marketId = $this->safe_string($order, 'instId');
        $market = $this->safe_market($marketId, $market);
        $timestamp = $this->safe_integer($order, 'cTime');
        $symbol = $market['symbol'];
        $rawStatus = $this->safe_string($order, 'status');
        $orderFee = $this->safe_value($order, 'feeDetail', array());
        $fee = $this->safe_value($orderFee, 0);
        $feeAmount = $this->safe_string($fee, 'fee');
        $feeObject = null;
        if ($feeAmount !== null) {
            $feeCurrency = $this->safe_string($fee, 'feeCoin');
            $feeObject = array(
                'cost' => $this->parse_number(Precise::string_abs($feeAmount)),
                'currency' => $this->safe_currency_code($feeCurrency),
            );
        }
        $triggerPrice = $this->safe_number($order, 'triggerPrice');
        $price = $this->safe_string($order, 'price');
        $avgPrice = $this->omit_zero($this->safe_string_2($order, 'priceAvg', 'fillPrice'));
        $cost = $this->safe_string_n($order, array( 'notional', 'notionalUsd', 'quoteSize' ));
        $side = $this->safe_string($order, 'side');
        $type = $this->safe_string($order, 'orderType');
        if ($side === 'buy' && $market['spot'] && ($type === 'market')) {
            $cost = $this->safe_string($order, 'newSize', $cost);
        }
        $filled = $this->safe_string_2($order, 'accBaseVolume', 'baseVolume');
        // if ($market['spot'] && ($rawStatus !== 'live')) {
        //     $filled = Precise::string_div($cost, $avgPrice);
        // }
        $amount = $this->safe_string($order, 'baseVolume');
        if (!$market['spot'] || !($side === 'buy' && $type === 'market')) {
            $amount = $this->safe_string($order, 'newSize', $amount);
        }
        if ($market['swap'] && ($amount === null)) {
            $amount = $this->safe_string($order, 'size');
        }
        return $this->safe_order(array(
            'info' => $order,
            'symbol' => $symbol,
            'id' => $this->safe_string($order, 'orderId'),
            'clientOrderId' => $this->safe_string($order, 'clientOid'),
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'lastTradeTimestamp' => $this->safe_integer($order, 'uTime'),
            'type' => $type,
            'timeInForce' => $this->safe_string_upper($order, 'force'),
            'postOnly' => null,
            'side' => $side,
            'price' => $price,
            'stopPrice' => $triggerPrice,
            'triggerPrice' => $triggerPrice,
            'amount' => $amount,
            'cost' => $cost,
            'average' => $avgPrice,
            'filled' => $filled,
            'remaining' => null,
            'status' => $this->parse_ws_order_status($rawStatus),
            'fee' => $feeObject,
            'trades' => null,
        ), $market);
    }

    public function parse_ws_order_status($status) {
        $statuses = array(
            'live' => 'open',
            'partially_filled' => 'open',
            'filled' => 'closed',
            'cancelled' => 'canceled',
            'not_trigger' => 'open',
        );
        return $this->safe_string($statuses, $status, $status);
    }

    public function watch_my_trades(?string $symbol = null, ?int $since = null, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            /**
             * watches $trades made by the user
             * @see https://www.bitget.com/api-doc/contract/websocket/private/Order-Channel
             * @param {str} $symbol unified $market $symbol
             * @param {int} [$since] the earliest time in ms to fetch $trades for
             * @param {int} [$limit] the maximum number of $trades structures to retrieve
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array[]} a list of ~@link https://docs.ccxt.com/#/?id=trade-structure trade structures~
             */
            Async\await($this->load_markets());
            $market = null;
            $messageHash = 'myTrades';
            if ($symbol !== null) {
                $market = $this->market($symbol);
                $symbol = $market['symbol'];
                $messageHash = $messageHash . ':' . $symbol;
            }
            $instType = null;
            list($instType, $params) = $this->get_inst_type($market, $params);
            $subscriptionHash = 'fill:' . $instType;
            $args = array(
                'instType' => $instType,
                'channel' => 'fill',
                'instId' => 'default',
            );
            $trades = Async\await($this->watch_private($messageHash, $subscriptionHash, $args, $params));
            if ($this->newUpdates) {
                $limit = $trades->getLimit ($symbol, $limit);
            }
            return $this->filter_by_symbol_since_limit($trades, $symbol, $since, $limit, true);
        }) ();
    }

    public function handle_my_trades(Client $client, $message) {
        //
        // spot
        // {
        //     "action" => "snapshot",
        //     "arg" => array(
        //        "instType" => "SPOT",
        //        "channel" => "fill",
        //        "instId" => "default"
        //     ),
        //     "data" => array(
        //        {
        //           "orderId" => "1169142457356959747",
        //           "tradeId" => "1169142457636958209",
        //           "symbol" => "LTCUSDT",
        //           "orderType" => "market",
        //           "side" => "buy",
        //           "priceAvg" => "81.069",
        //           "size" => "0.074",
        //           "amount" => "5.999106",
        //           "tradeScope" => "taker",
        //           "feeDetail" => array(
        //              {
        //                 "feeCoin" => "LTC",
        //                 "deduction" => "no",
        //                 "totalDeductionFee" => "0",
        //                 "totalFee" => "0.000074"
        //              }
        //           ),
        //           "cTime" => "1714471204194",
        //           "uTime" => "1714471204194"
        //        }
        //     ),
        //     "ts" => 1714471204270
        // }
        // swap
        //     {
        //         "action" => "snapshot",
        //         "arg" => array(
        //            "instType" => "USDT-FUTURES",
        //            "channel" => "fill",
        //            "instId" => "default"
        //         ),
        //         "data" => array(
        //            {
        //               "orderId" => "1169142761031114781",
        //               "tradeId" => "1169142761312637004",
        //               "symbol" => "LTCUSDT",
        //               "orderType" => "market",
        //               "side" => "buy",
        //               "price" => "80.87",
        //               "baseVolume" => "0.1",
        //               "quoteVolume" => "8.087",
        //               "profit" => "0",
        //               "tradeSide" => "open",
        //               "posMode" => "hedge_mode",
        //               "tradeScope" => "taker",
        //               "feeDetail" => array(
        //                  {
        //                     "feeCoin" => "USDT",
        //                     "deduction" => "no",
        //                     "totalDeductionFee" => "0",
        //                     "totalFee" => "-0.0048522"
        //                  }
        //               ),
        //               "cTime" => "1714471276596",
        //               "uTime" => "1714471276596"
        //            }
        //         ),
        //         "ts" => 1714471276629
        //     }
        //
        if ($this->myTrades === null) {
            $limit = $this->safe_integer($this->options, 'tradesLimit', 1000);
            $this->myTrades = new ArrayCache ($limit);
        }
        $stored = $this->myTrades;
        $data = $this->safe_list($message, 'data', array());
        $length = count($data);
        $messageHash = 'myTrades';
        for ($i = 0; $i < $length; $i++) {
            $trade = $data[$i];
            $parsed = $this->parse_ws_trade($trade);
            $stored->append ($parsed);
            $symbol = $parsed['symbol'];
            $symbolSpecificMessageHash = 'myTrades:' . $symbol;
            $client->resolve ($stored, $symbolSpecificMessageHash);
        }
        $client->resolve ($stored, $messageHash);
    }

    public function watch_balance($params = array ()): PromiseInterface {
        return Async\async(function () use ($params) {
            /**
             * watch balance and get the amount of funds available for trading or funds locked in orders
             * @see https://www.bitget.com/api-doc/spot/websocket/private/Account-Channel
             * @see https://www.bitget.com/api-doc/contract/websocket/private/Account-Channel
             * @see https://www.bitget.com/api-doc/margin/cross/websocket/private/Margin-Cross-Account-Assets
             * @see https://www.bitget.com/api-doc/margin/isolated/websocket/private/Margin-isolated-account-assets
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @param {str} [$params->type] spot or contract if not provided $this->options['defaultType'] is used
             * @param {string} [$params->instType] one of 'SPOT', 'MARGIN', 'USDT-FUTURES', 'USDC-FUTURES', 'COIN-FUTURES', 'SUSDT-FUTURES', 'SUSDC-FUTURES' or 'SCOIN-FUTURES'
             * @param {string} [$params->marginMode] 'isolated' or 'cross' for watching spot margin balances
             * @return {array} a ~@link https://docs.ccxt.com/#/?id=balance-structure balance structure~
             */
            $type = null;
            list($type, $params) = $this->handle_market_type_and_params('watchBalance', null, $params);
            $marginMode = null;
            list($marginMode, $params) = $this->handle_margin_mode_and_params('watchBalance', $params);
            $instType = null;
            $channel = 'account';
            if (($type === 'swap') || ($type === 'future')) {
                $instType = 'USDT-FUTURES';
            } elseif ($marginMode !== null) {
                $instType = 'MARGIN';
                if ($marginMode === 'isolated') {
                    $channel = 'account-isolated';
                } else {
                    $channel = 'account-crossed';
                }
            } else {
                $instType = 'SPOT';
            }
            list($instType, $params) = $this->handle_option_and_params($params, 'watchBalance', 'instType', $instType);
            $args = array(
                'instType' => $instType,
                'channel' => $channel,
                'coin' => 'default',
            );
            $messageHash = 'balance:' . strtolower($instType);
            return Async\await($this->watch_private($messageHash, $messageHash, $args, $params));
        }) ();
    }

    public function handle_balance(Client $client, $message) {
        //
        // spot
        //
        //     {
        //         "action" => "snapshot",
        //         "arg" => array( "instType" => "SPOT", "channel" => "account", "coin" => "default" ),
        //         "data" => array(
        //             array(
        //                 "coin" => "USDT",
        //                 "available" => "19.1430952856087",
        //                 "frozen" => "7",
        //                 "locked" => "0",
        //                 "limitAvailable" => "0",
        //                 "uTime" => "1701931970487"
        //             ),
        //         ),
        //         "ts" => 1701931970487
        //     }
        //
        // swap
        //
        //     {
        //         "action" => "snapshot",
        //         "arg" => array( "instType" => "USDT-FUTURES", "channel" => "account", "coin" => "default" ),
        //         "data" => array(
        //             {
        //                 "marginCoin" => "USDT",
        //                 "frozen" => "5.36581500",
        //                 "available" => "26.14309528",
        //                 "maxOpenPosAvailable" => "20.77728028",
        //                 "maxTransferOut" => "20.77728028",
        //                 "equity" => "26.14309528",
        //                 "usdtEquity" => "26.143095285166"
        //             }
        //         ),
        //         "ts" => 1701932570822
        //     }
        //
        // margin
        //
        //     {
        //         "action" => "snapshot",
        //         "arg" => array( "instType" => "MARGIN", "channel" => "account-crossed", "coin" => "default" ),
        //         "data" => array(
        //             {
        //                 "uTime" => "1701933110544",
        //                 "id" => "1096916799926710272",
        //                 "coin" => "USDT",
        //                 "available" => "16.24309528",
        //                 "borrow" => "0.00000000",
        //                 "frozen" => "9.90000000",
        //                 "interest" => "0.00000000",
        //                 "coupon" => "0.00000000"
        //             }
        //         ),
        //         "ts" => 1701933110544
        //     }
        //
        $data = $this->safe_value($message, 'data', array());
        for ($i = 0; $i < count($data); $i++) {
            $rawBalance = $data[$i];
            $currencyId = $this->safe_string_2($rawBalance, 'coin', 'marginCoin');
            $code = $this->safe_currency_code($currencyId);
            $account = (is_array($this->balance) && array_key_exists($code, $this->balance)) ? $this->balance[$code] : $this->account();
            $borrow = $this->safe_string($rawBalance, 'borrow');
            if ($borrow !== null) {
                $interest = $this->safe_string($rawBalance, 'interest');
                $account['debt'] = Precise::string_add($borrow, $interest);
            }
            $freeQuery = (is_array($rawBalance) && array_key_exists('maxTransferOut', $rawBalance)) ? 'maxTransferOut' : 'available';
            $account['free'] = $this->safe_string($rawBalance, $freeQuery);
            $account['total'] = $this->safe_string($rawBalance, 'equity');
            $account['used'] = $this->safe_string($rawBalance, 'frozen');
            $this->balance[$code] = $account;
        }
        $this->balance = $this->safe_balance($this->balance);
        $arg = $this->safe_value($message, 'arg');
        $instType = $this->safe_string_lower($arg, 'instType');
        $messageHash = 'balance:' . $instType;
        $client->resolve ($this->balance, $messageHash);
    }

    public function watch_public($messageHash, $args, $params = array ()) {
        return Async\async(function () use ($messageHash, $args, $params) {
            $url = $this->urls['api']['ws']['public'];
            $request = array(
                'op' => 'subscribe',
                'args' => array( $args ),
            );
            $message = array_merge($request, $params);
            return Async\await($this->watch($url, $messageHash, $message, $messageHash));
        }) ();
    }

    public function watch_public_multiple($messageHashes, $argsArray, $params = array ()) {
        return Async\async(function () use ($messageHashes, $argsArray, $params) {
            $url = $this->urls['api']['ws']['public'];
            $request = array(
                'op' => 'subscribe',
                'args' => $argsArray,
            );
            $message = array_merge($request, $params);
            return Async\await($this->watch_multiple($url, $messageHashes, $message, $messageHashes));
        }) ();
    }

    public function authenticate($params = array ()) {
        return Async\async(function () use ($params) {
            $this->check_required_credentials();
            $url = $this->urls['api']['ws']['private'];
            $client = $this->client($url);
            $messageHash = 'authenticated';
            $future = $client->future ($messageHash);
            $authenticated = $this->safe_value($client->subscriptions, $messageHash);
            if ($authenticated === null) {
                $timestamp = (string) $this->seconds();
                $auth = $timestamp . 'GET' . '/user/verify';
                $signature = $this->hmac($this->encode($auth), $this->encode($this->secret), 'sha256', 'base64');
                $operation = 'login';
                $request = array(
                    'op' => $operation,
                    'args' => array(
                        array(
                            'apiKey' => $this->apiKey,
                            'passphrase' => $this->password,
                            'timestamp' => $timestamp,
                            'sign' => $signature,
                        ),
                    ),
                );
                $message = array_merge($request, $params);
                $this->watch($url, $messageHash, $message, $messageHash);
            }
            return Async\await($future);
        }) ();
    }

    public function watch_private($messageHash, $subscriptionHash, $args, $params = array ()) {
        return Async\async(function () use ($messageHash, $subscriptionHash, $args, $params) {
            Async\await($this->authenticate());
            $url = $this->urls['api']['ws']['private'];
            $request = array(
                'op' => 'subscribe',
                'args' => array( $args ),
            );
            $message = array_merge($request, $params);
            return Async\await($this->watch($url, $messageHash, $message, $subscriptionHash));
        }) ();
    }

    public function handle_authenticate(Client $client, $message) {
        //
        //  array( event => "login", code => 0 )
        //
        $messageHash = 'authenticated';
        $future = $this->safe_value($client->futures, $messageHash);
        $future->resolve (true);
    }

    public function handle_error_message(Client $client, $message) {
        //
        //    array( $event => "error", $code => 30015, $msg => "Invalid sign" )
        //
        $event = $this->safe_string($message, 'event');
        try {
            if ($event === 'error') {
                $code = $this->safe_string($message, 'code');
                $feedback = $this->id . ' ' . $this->json($message);
                $this->throw_exactly_matched_exception($this->exceptions['ws']['exact'], $code, $feedback);
                $msg = $this->safe_string($message, 'msg', '');
                $this->throw_broadly_matched_exception($this->exceptions['ws']['broad'], $msg, $feedback);
                throw new ExchangeError($feedback);
            }
            return false;
        } catch (Exception $e) {
            if ($e instanceof AuthenticationError) {
                $messageHash = 'authenticated';
                $client->reject ($e, $messageHash);
                if (is_array($client->subscriptions) && array_key_exists($messageHash, $client->subscriptions)) {
                    unset($client->subscriptions[$messageHash]);
                }
            } else {
                // Note => if error happens on a subscribe $event, user will have to close exchange to resubscribe. Issue #19041
                $client->reject ($e);
            }
            return true;
        }
    }

    public function handle_message(Client $client, $message) {
        //
        //   {
        //       "action" => "snapshot",
        //       "arg" => array( instType => 'SPOT', channel => "ticker", instId => "BTCUSDT" ),
        //       "data" => array(
        //         {
        //           "instId" => "BTCUSDT",
        //           "last" => "21150.53",
        //           "open24h" => "20759.65",
        //           "high24h" => "21202.29",
        //           "low24h" => "20518.82",
        //           "bestBid" => "21150.500000",
        //           "bestAsk" => "21150.600000",
        //           "baseVolume" => "25402.1961",
        //           "quoteVolume" => "530452554.2156",
        //           "ts" => 1656408934044,
        //           "labeId" => 0
        //         }
        //       )
        //   }
        // pong $message
        //    "pong"
        //
        // login
        //
        //     array( $event => "login", code => 0 )
        //
        // subscribe
        //
        //    {
        //        "event" => "subscribe",
        //        "arg" => array( instType => 'SPOT', channel => "account", instId => "default" )
        //    }
        //
        if ($this->handle_error_message($client, $message)) {
            return;
        }
        $content = $this->safe_string($message, 'message');
        if ($content === 'pong') {
            $this->handle_pong($client, $message);
            return;
        }
        if ($message === 'pong') {
            $this->handle_pong($client, $message);
            return;
        }
        $event = $this->safe_string($message, 'event');
        if ($event === 'login') {
            $this->handle_authenticate($client, $message);
            return;
        }
        if ($event === 'subscribe') {
            $this->handle_subscription_status($client, $message);
            return;
        }
        $methods = array(
            'ticker' => array($this, 'handle_ticker'),
            'trade' => array($this, 'handle_trades'),
            'fill' => array($this, 'handle_my_trades'),
            'orders' => array($this, 'handle_order'),
            'ordersAlgo' => array($this, 'handle_order'),
            'account' => array($this, 'handle_balance'),
            'positions' => array($this, 'handle_positions'),
            'account-isolated' => array($this, 'handle_balance'),
            'account-crossed' => array($this, 'handle_balance'),
        );
        $arg = $this->safe_value($message, 'arg', array());
        $topic = $this->safe_value($arg, 'channel', '');
        $method = $this->safe_value($methods, $topic);
        if ($method !== null) {
            $method($client, $message);
        }
        if (mb_strpos($topic, 'candle') !== false) {
            $this->handle_ohlcv($client, $message);
        }
        if (mb_strpos($topic, 'books') !== false) {
            $this->handle_order_book($client, $message);
        }
    }

    public function ping($client) {
        return 'ping';
    }

    public function handle_pong(Client $client, $message) {
        $client->lastPong = $this->milliseconds();
        return $message;
    }

    public function handle_subscription_status(Client $client, $message) {
        //
        //    {
        //        "event" => "subscribe",
        //        "arg" => array( instType => 'SPOT', channel => "account", instId => "default" )
        //    }
        //
        return $message;
    }
}
