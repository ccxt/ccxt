<?php

namespace ccxt\pro;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

use Exception; // a common import
use ccxt\ArgumentsRequired;
use \React\Async;
use \React\Promise\PromiseInterface;

class aster extends \ccxt\async\aster {

    public function describe(): mixed {
        return $this->deep_extend(parent::describe(), array(
            'has' => array(
                'ws' => true,
                'watchBalance' => false,
                'watchBidsAsks' => true,
                'watchTicker' => true,
                'watchTickers' => true,
                'watchMarkPrice' => true,
                'watchMarkPrices' => true,
                'watchTrades' => true,
                'watchTradesForSymbols' => true,
                'watchOrderBook' => true,
                'watchOrderBookForSymbols' => true,
                'watchOHLCV' => true,
                'watchOHLCVForSymbols' => true,
                'unWatchTicker' => true,
                'unWatchTickers' => true,
                'unWatchMarkPrice' => true,
                'unWatchMarkPrices' => true,
                'unWatchBidsAsks' => true,
                'unWatchTrades' => true,
                'unWatchTradesForSymbols' => true,
                'unWatchOrderBook' => true,
                'unWatchOrderBookForSymbols' => true,
                'unWatchOHLCV' => true,
                'unWatchOHLCVForSymbols' => true,
            ),
            'urls' => array(
                'api' => array(
                    'ws' => array(
                        'spot' => 'wss://sstream.asterdex.com/stream',
                        'swap' => 'wss://fstream.asterdex.com/stream',
                    ),
                ),
            ),
            'options' => array(),
            'streaming' => array(),
            'exceptions' => array(),
        ));
    }

    public function get_account_type_from_subscriptions(array $subscriptions): string {
        $accountType = '';
        for ($i = 0; $i < count($subscriptions); $i++) {
            $subscription = $subscriptions[$i];
            if (($subscription === 'spot') || ($subscription === 'swap')) {
                $accountType = $subscription;
                break;
            }
        }
        return $accountType;
    }

    public function watch_ticker(string $symbol, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $params) {
            /**
             * watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
             *
             * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-spot-api.md#full-ticker-per-$symbol
             * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-futures-api.md#individual-$symbol-ticker-streams
             *
             * @param {string} $symbol unified $symbol of the market to fetch the ticker for
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} a ~@link https://docs.ccxt.com/#/?id=ticker-structure ticker structure~
             */
            $params['callerMethodName'] = 'watchTicker';
            Async\await($this->load_markets());
            $symbol = $this->safe_symbol($symbol);
            $tickers = Async\await($this->watch_tickers(array( $symbol ), $params));
            return $tickers[$symbol];
        }) ();
    }

    public function un_watch_ticker(string $symbol, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $params) {
            /**
             * unWatches a price ticker
             *
             * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-spot-api.md#full-ticker-per-$symbol
             * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-futures-api.md#individual-$symbol-ticker-streams
             *
             * @param {string} $symbol unified $symbol of the market to fetch the ticker for
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} a ~@link https://docs.ccxt.com/#/?id=ticker-structure ticker structure~
             */
            $params['callerMethodName'] = 'unWatchTicker';
            return Async\await($this->un_watch_tickers(array( $symbol ), $params));
        }) ();
    }

    public function watch_tickers(?array $symbols = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbols, $params) {
            /**
             * watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for all markets of a specific list
             *
             * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-spot-api.md#full-ticker-per-$symbol
             * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-futures-api.md#individual-$symbol-ticker-streams
             *
             * @param {string[]} $symbols unified $symbol of the $market to fetch the ticker for
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} a ~@link https://docs.ccxt.com/#/?id=ticker-structure ticker structure~
             */
            Async\await($this->load_markets());
            $symbols = $this->market_symbols($symbols, null, true, true, true);
            $firstMarket = $this->get_market_from_symbols($symbols);
            $type = $this->safe_string($firstMarket, 'type', 'swap');
            $symbolsLength = count($symbols);
            $methodName = null;
            list($methodName, $params) = $this->handle_param_string($params, 'callerMethodName', 'watchTickers');
            $params = $this->omit($params, 'callerMethodName');
            if ($symbolsLength === 0) {
                throw new ArgumentsRequired($this->id . ' ' . $methodName . '() requires a non-empty array of symbols');
            }
            $url = $this->urls['api']['ws'][$type];
            $subscriptionArgs = array();
            $messageHashes = array();
            $request = array(
                'method' => 'SUBSCRIBE',
                'params' => $subscriptionArgs,
            );
            for ($i = 0; $i < count($symbols); $i++) {
                $symbol = $symbols[$i];
                $market = $this->market($symbol);
                $subscriptionArgs[] = $this->safe_string_lower($market, 'id') . '@ticker';
                $messageHashes[] = 'ticker:' . $market['symbol'];
            }
            $newTicker = Async\await($this->watch_multiple($url, $messageHashes, $this->extend($request, $params), array( $type )));
            if ($this->newUpdates) {
                $result = array();
                $result[$newTicker['symbol']] = $newTicker;
                return $result;
            }
            return $this->filter_by_array($this->tickers, 'symbol', $symbols);
        }) ();
    }

    public function un_watch_tickers(?array $symbols = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbols, $params) {
            /**
             * unWatches a price ticker, a statistical calculation with the information calculated over the past 24 hours for all markets of a specific list
             *
             * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-spot-api.md#full-ticker-per-$symbol
             * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-futures-api.md#individual-$symbol-ticker-streams
             *
             * @param {string[]} $symbols unified $symbol of the $market to fetch the ticker for
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} a ~@link https://docs.ccxt.com/#/?id=ticker-structure ticker structure~
             */
            Async\await($this->load_markets());
            $symbols = $this->market_symbols($symbols, null, true, true, true);
            $firstMarket = $this->get_market_from_symbols($symbols);
            $type = $this->safe_string($firstMarket, 'type', 'swap');
            $symbolsLength = count($symbols);
            $methodName = null;
            list($methodName, $params) = $this->handle_param_string($params, 'callerMethodName', 'unWatchTickers');
            $params = $this->omit($params, 'callerMethodName');
            if ($symbolsLength === 0) {
                throw new ArgumentsRequired($this->id . ' ' . $methodName . '() requires a non-empty array of symbols');
            }
            $url = $this->urls['api']['ws'][$type];
            $subscriptionArgs = array();
            $messageHashes = array();
            $request = array(
                'method' => 'UNSUBSCRIBE',
                'params' => $subscriptionArgs,
            );
            for ($i = 0; $i < count($symbols); $i++) {
                $symbol = $symbols[$i];
                $market = $this->market($symbol);
                $subscriptionArgs[] = $this->safe_string_lower($market, 'id') . '@ticker';
                $messageHashes[] = 'unsubscribe:ticker:' . $market['symbol'];
            }
            return Async\await($this->watch_multiple($url, $messageHashes, $this->extend($request, $params), array( $type )));
        }) ();
    }

    public function watch_mark_price(string $symbol, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $params) {
            /**
             * watches a mark price for a specific market
             *
             * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-futures-api.md#mark-price-stream
             *
             * @param {string} $symbol unified $symbol of the market to fetch the ticker for
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @param {boolean} [$params->use1sFreq] *default is true* if set to true, the mark price will be updated every second, otherwise every 3 seconds
             * @return {array} a ~@link https://docs.ccxt.com/#/?id=ticker-structure ticker structure~
             */
            $params['callerMethodName'] = 'watchMarkPrice';
            Async\await($this->load_markets());
            $symbol = $this->safe_symbol($symbol);
            $tickers = Async\await($this->watch_mark_prices(array( $symbol ), $params));
            return $tickers[$symbol];
        }) ();
    }

    public function un_watch_mark_price(string $symbol, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $params) {
            /**
             * unWatches a mark price for a specific market
             *
             * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-futures-api.md#mark-price-stream
             *
             * @param {string} $symbol unified $symbol of the market to fetch the ticker for
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @param {boolean} [$params->use1sFreq] *default is true* if set to true, the mark price will be updated every second, otherwise every 3 seconds
             * @return {array} a ~@link https://docs.ccxt.com/#/?id=ticker-structure ticker structure~
             */
            $params['callerMethodName'] = 'unWatchMarkPrice';
            return Async\await($this->un_watch_mark_prices(array( $symbol ), $params));
        }) ();
    }

    public function watch_mark_prices(?array $symbols = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbols, $params) {
            /**
             * watches the mark price for all markets
             *
             * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-futures-api.md#mark-price-stream
             *
             * @param {string[]} $symbols unified $symbol of the $market to fetch the ticker for
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @param {boolean} [$params->use1sFreq] *default is true* if set to true, the mark price will be updated every second, otherwise every 3 seconds
             * @return {array} a ~@link https://docs.ccxt.com/#/?id=ticker-structure ticker structure~
             */
            Async\await($this->load_markets());
            $symbols = $this->market_symbols($symbols, null, true, true, true);
            $firstMarket = $this->get_market_from_symbols($symbols);
            $type = $this->safe_string($firstMarket, 'type', 'swap');
            $symbolsLength = count($symbols);
            $methodName = null;
            list($methodName, $params) = $this->handle_param_string($params, 'callerMethodName', 'watchMarkPrices');
            $params = $this->omit($params, 'callerMethodName');
            if ($symbolsLength === 0) {
                throw new ArgumentsRequired($this->id . ' ' . $methodName . '() requires a non-empty array of symbols');
            }
            $url = $this->urls['api']['ws'][$type];
            $subscriptionArgs = array();
            $messageHashes = array();
            $request = array(
                'method' => 'SUBSCRIBE',
                'params' => $subscriptionArgs,
            );
            $use1sFreq = $this->safe_bool($params, 'use1sFreq', true);
            for ($i = 0; $i < count($symbols); $i++) {
                $symbol = $symbols[$i];
                $market = $this->market($symbol);
                $suffix = ($use1sFreq) ? '@1s' : '';
                $subscriptionArgs[] = $this->safe_string_lower($market, 'id') . '@markPrice' . $suffix;
                $messageHashes[] = 'ticker:' . $market['symbol'];
            }
            $newTicker = Async\await($this->watch_multiple($url, $messageHashes, $this->extend($request, $params), array( $type )));
            if ($this->newUpdates) {
                $result = array();
                $result[$newTicker['symbol']] = $newTicker;
                return $result;
            }
            return $this->filter_by_array($this->tickers, 'symbol', $symbols);
        }) ();
    }

    public function un_watch_mark_prices(?array $symbols = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbols, $params) {
            /**
             * watches the mark price for all markets
             *
             * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-futures-api.md#mark-price-stream
             *
             * @param {string[]} $symbols unified $symbol of the $market to fetch the ticker for
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @param {boolean} [$params->use1sFreq] *default is true* if set to true, the mark price will be updated every second, otherwise every 3 seconds
             * @return {array} a ~@link https://docs.ccxt.com/#/?id=ticker-structure ticker structure~
             */
            Async\await($this->load_markets());
            $symbols = $this->market_symbols($symbols, null, true, true, true);
            $firstMarket = $this->get_market_from_symbols($symbols);
            $type = $this->safe_string($firstMarket, 'type', 'swap');
            $symbolsLength = count($symbols);
            $methodName = null;
            list($methodName, $params) = $this->handle_param_string($params, 'callerMethodName', 'unWatchMarkPrices');
            $params = $this->omit($params, 'callerMethodName');
            if ($symbolsLength === 0) {
                throw new ArgumentsRequired($this->id . ' ' . $methodName . '() requires a non-empty array of symbols');
            }
            $url = $this->urls['api']['ws'][$type];
            $subscriptionArgs = array();
            $messageHashes = array();
            $request = array(
                'method' => 'UNSUBSCRIBE',
                'params' => $subscriptionArgs,
            );
            $use1sFreq = $this->safe_bool($params, 'use1sFreq', true);
            for ($i = 0; $i < count($symbols); $i++) {
                $symbol = $symbols[$i];
                $market = $this->market($symbol);
                $suffix = ($use1sFreq) ? '@1s' : '';
                $subscriptionArgs[] = $this->safe_string_lower($market, 'id') . '@markPrice' . $suffix;
                $messageHashes[] = 'unsubscribe:ticker:' . $market['symbol'];
            }
            return Async\await($this->watch_multiple($url, $messageHashes, $this->extend($request, $params), array( $type )));
        }) ();
    }

    public function handle_ticker(Client $client, $message) {
        //
        //     {
        //         "stream" => "trumpusdt@$ticker",
        //         "data" => {
        //             "e" => "24hrTicker",
        //             "E" => 1754451187277,
        //             "s" => "CAKEUSDT",
        //             "p" => "-0.08800",
        //             "P" => "-3.361",
        //             "w" => "2.58095",
        //             "c" => "2.53000",
        //             "Q" => "5",
        //             "o" => "2.61800",
        //             "h" => "2.64700",
        //             "l" => "2.52400",
        //             "v" => "15775",
        //             "q" => "40714.46000",
        //             "O" => 1754364780000,
        //             "C" => 1754451187274,
        //             "F" => 6571389,
        //             "L" => 6574507,
        //             "n" => 3119
        //         }
        //     }
        //     {
        //         "stream" => "btcusdt@markPrice",
        //         "data" => {
        //             "e" => "markPriceUpdate",
        //             "E" => 1754660466000,
        //             "s" => "BTCUSDT",
        //             "p" => "116809.60000000",
        //             "P" => "116595.54012838",
        //             "i" => "116836.93534884",
        //             "r" => "0.00010000",
        //             "T" => 1754668800000
        //         }
        //     }
        //
        $subscriptions = $client->subscriptions;
        $subscriptionsKeys = is_array($subscriptions) ? array_keys($subscriptions) : array();
        $marketType = $this->get_account_type_from_subscriptions($subscriptionsKeys);
        $ticker = $this->safe_dict($message, 'data');
        $parsed = $this->parse_ws_ticker($ticker, $marketType);
        $symbol = $parsed['symbol'];
        $messageHash = 'ticker:' . $symbol;
        $this->tickers[$symbol] = $parsed;
        $client->resolve ($this->tickers[$symbol], $messageHash);
    }

    public function parse_ws_ticker($message, $marketType) {
        $event = $this->safe_string($message, 'e');
        $part = explode('@', $event);
        $channel = $this->safe_string($part, 1);
        $marketId = $this->safe_string($message, 's');
        $timestamp = $this->safe_integer($message, 'E');
        $market = $this->safe_market($marketId, null, null, $marketType);
        $last = $this->safe_string($message, 'c');
        if ($channel === 'markPriceUpdate') {
            return $this->safe_ticker(array(
                'symbol' => $market['symbol'],
                'timestamp' => $timestamp,
                'datetime' => $this->iso8601($timestamp),
                'info' => $message,
                'markPrice' => $this->safe_string($message, 'p'),
                'indexPrice' => $this->safe_string($message, 'i'),
            ));
        }
        return $this->safe_ticker(array(
            'symbol' => $market['symbol'],
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'high' => $this->safe_string($message, 'h'),
            'low' => $this->safe_string($message, 'l'),
            'bid' => null,
            'bidVolume' => null,
            'ask' => null,
            'askVolume' => null,
            'vwap' => $this->safe_string($message, 'w'),
            'open' => $this->safe_string($message, 'o'),
            'close' => $last,
            'last' => $last,
            'previousClose' => null,
            'change' => $this->safe_string($message, 'p'),
            'percentage' => $this->safe_string($message, 'P'),
            'average' => null,
            'baseVolume' => $this->safe_string($message, 'v'),
            'quoteVolume' => $this->safe_string($message, 'q'),
            'info' => $message,
        ), $market);
    }

    public function watch_bids_asks(?array $symbols = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbols, $params) {
            /**
             * watches best bid & ask for $symbols
             *
             * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-spot-api.md#best-order-book-information-by-$symbol
             * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-futures-api.md#individual-$symbol-book-ticker-streams
             *
             * @param {string[]} $symbols unified $symbol of the $market to fetch the ticker for
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} a ~@link https://docs.ccxt.com/#/?id=ticker-structure ticker structure~
             */
            Async\await($this->load_markets());
            $symbols = $this->market_symbols($symbols, null, true, true, true);
            $firstMarket = $this->get_market_from_symbols($symbols);
            $type = $this->safe_string($firstMarket, 'type', 'swap');
            $symbolsLength = count($symbols);
            if ($symbolsLength === 0) {
                throw new ArgumentsRequired($this->id . ' watchBidsAsks() requires a non-empty array of symbols');
            }
            $url = $this->urls['api']['ws'][$type];
            $subscriptionArgs = array();
            $messageHashes = array();
            $request = array(
                'method' => 'SUBSCRIBE',
                'params' => $subscriptionArgs,
            );
            for ($i = 0; $i < count($symbols); $i++) {
                $symbol = $symbols[$i];
                $market = $this->market($symbol);
                $subscriptionArgs[] = $this->safe_string_lower($market, 'id') . '@bookTicker';
                $messageHashes[] = 'bidask:' . $market['symbol'];
            }
            $newTicker = Async\await($this->watch_multiple($url, $messageHashes, $this->extend($request, $params), array( $type )));
            if ($this->newUpdates) {
                $result = array();
                $result[$newTicker['symbol']] = $newTicker;
                return $result;
            }
            return $this->filter_by_array($this->bidsasks, 'symbol', $symbols);
        }) ();
    }

    public function un_watch_bids_asks(?array $symbols = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbols, $params) {
            /**
             * unWatches best bid & ask for $symbols
             *
             * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-spot-api.md#best-order-book-information-by-$symbol
             * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-futures-api.md#individual-$symbol-book-ticker-streams
             *
             * @param {string[]} $symbols unified $symbol of the $market to fetch the ticker for
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} a ~@link https://docs.ccxt.com/#/?id=ticker-structure ticker structure~
             */
            Async\await($this->load_markets());
            $symbols = $this->market_symbols($symbols, null, true, true, true);
            $firstMarket = $this->get_market_from_symbols($symbols);
            $type = $this->safe_string($firstMarket, 'type', 'swap');
            $symbolsLength = count($symbols);
            if ($symbolsLength === 0) {
                throw new ArgumentsRequired($this->id . ' unWatchBidsAsks() requires a non-empty array of symbols');
            }
            $url = $this->urls['api']['ws'][$type];
            $subscriptionArgs = array();
            $messageHashes = array();
            $request = array(
                'method' => 'UNSUBSCRIBE',
                'params' => $subscriptionArgs,
            );
            for ($i = 0; $i < count($symbols); $i++) {
                $symbol = $symbols[$i];
                $market = $this->market($symbol);
                $subscriptionArgs[] = $this->safe_string_lower($market, 'id') . '@bookTicker';
                $messageHashes[] = 'unsubscribe:bidask:' . $market['symbol'];
            }
            return Async\await($this->watch_multiple($url, $messageHashes, $this->extend($request, $params), array( $type )));
        }) ();
    }

    public function handle_bid_ask(Client $client, $message) {
        //
        //     {
        //         "stream" => "btcusdt@bookTicker",
        //         "data" => {
        //             "e" => "bookTicker",
        //             "u" => 157240846459,
        //             "s" => "BTCUSDT",
        //             "b" => "122046.7",
        //             "B" => "1.084",
        //             "a" => "122046.8",
        //             "A" => "0.001",
        //             "T" => 1754896692922,
        //             "E" => 1754896692926
        //         }
        //     }
        //
        $subscriptions = $client->subscriptions;
        $subscriptionsKeys = is_array($subscriptions) ? array_keys($subscriptions) : array();
        $marketType = $this->get_account_type_from_subscriptions($subscriptionsKeys);
        $data = $this->safe_dict($message, 'data', array());
        $marketId = $this->safe_string($data, 's');
        $market = $this->safe_market($marketId, null, null, $marketType);
        $ticker = $this->parse_ws_bid_ask($data, $market);
        $symbol = $ticker['symbol'];
        $this->bidsasks[$symbol] = $ticker;
        $messageHash = 'bidask:' . $symbol;
        $client->resolve ($ticker, $messageHash);
    }

    public function parse_ws_bid_ask($message, $market = null) {
        $timestamp = $this->safe_integer($message, 'T');
        return $this->safe_ticker(array(
            'symbol' => $market['symbol'],
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'ask' => $this->safe_string($message, 'a'),
            'askVolume' => $this->safe_string($message, 'A'),
            'bid' => $this->safe_string($message, 'b'),
            'bidVolume' => $this->safe_string($message, 'B'),
            'info' => $message,
        ), $market);
    }

    public function watch_trades(string $symbol, ?int $since = null, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            /**
             * watches information on multiple trades made in a market
             *
             * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-spot-api.md#collection-transaction-flow
             * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-futures-api.md#aggregate-trade-streams
             *
             * @param {string} $symbol unified market $symbol of the market trades were made in
             * @param {int} [$since] the earliest time in ms to fetch trades for
             * @param {int} [$limit] the maximum number of trade structures to retrieve
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array[]} a list of ~@link https://docs.ccxt.com/#/?id=trade-structure trade structures~
             */
            $params['callerMethodName'] = 'watchTrades';
            return Async\await($this->watch_trades_for_symbols(array( $symbol ), $since, $limit, $params));
        }) ();
    }

    public function un_watch_trades(string $symbol, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $params) {
            /**
             * unsubscribe from the trades channel
             *
             * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-spot-api.md#collection-transaction-flow
             * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-futures-api.md#aggregate-trade-streams
             *
             * @param {string} $symbol unified market $symbol of the market trades were made in
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array[]} a list of ~@link https://docs.ccxt.com/#/?id=trade-structure trade structures~
             */
            $params['callerMethodName'] = 'unWatchTrades';
            return Async\await($this->un_watch_trades_for_symbols(array( $symbol ), $params));
        }) ();
    }

    public function watch_trades_for_symbols(array $symbols, ?int $since = null, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbols, $since, $limit, $params) {
            /**
             * get the list of most recent $trades for a list of $symbols
             *
             * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-spot-api.md#collection-transaction-flow
             * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-futures-api.md#aggregate-trade-streams
             *
             * @param {string[]} $symbols unified $symbol of the $market to fetch $trades for
             * @param {int} [$since] timestamp in ms of the earliest trade to fetch
             * @param {int} [$limit] the maximum amount of $trades to fetch
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array[]} a list of ~@link https://docs.ccxt.com/#/?id=public-$trades trade structures~
             */
            Async\await($this->load_markets());
            $symbols = $this->market_symbols($symbols, null, true, true, true);
            $firstMarket = $this->get_market_from_symbols($symbols);
            $type = $this->safe_string($firstMarket, 'type', 'swap');
            $symbolsLength = count($symbols);
            $methodName = null;
            list($methodName, $params) = $this->handle_param_string($params, 'callerMethodName', 'watchTradesForSymbols');
            $params = $this->omit($params, 'callerMethodName');
            if ($symbolsLength === 0) {
                throw new ArgumentsRequired($this->id . ' ' . $methodName . '() requires a non-empty array of symbols');
            }
            $url = $this->urls['api']['ws'][$type];
            $subscriptionArgs = array();
            $messageHashes = array();
            $request = array(
                'method' => 'SUBSCRIBE',
                'params' => $subscriptionArgs,
            );
            for ($i = 0; $i < count($symbols); $i++) {
                $symbol = $symbols[$i];
                $market = $this->market($symbol);
                $subscriptionArgs[] = $this->safe_string_lower($market, 'id') . '@aggTrade';
                $messageHashes[] = 'trade:' . $market['symbol'];
            }
            $trades = Async\await($this->watch_multiple($url, $messageHashes, $this->extend($request, $params), array( $type )));
            if ($this->newUpdates) {
                $first = $this->safe_value($trades, 0);
                $tradeSymbol = $this->safe_string($first, 'symbol');
                $limit = $trades->getLimit ($tradeSymbol, $limit);
            }
            return $this->filter_by_since_limit($trades, $since, $limit, 'timestamp', true);
        }) ();
    }

    public function un_watch_trades_for_symbols(array $symbols, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbols, $params) {
            /**
             * unsubscribe from the trades channel
             *
             * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-spot-api.md#collection-transaction-flow
             * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-futures-api.md#aggregate-trade-streams
             *
             * @param {string[]} $symbols unified $symbol of the $market to fetch trades for
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array[]} a list of ~@link https://docs.ccxt.com/#/?id=public-trades trade structures~
             */
            Async\await($this->load_markets());
            $symbols = $this->market_symbols($symbols, null, true, true, true);
            $firstMarket = $this->get_market_from_symbols($symbols);
            $type = $this->safe_string($firstMarket, 'type', 'swap');
            $symbolsLength = count($symbols);
            $methodName = null;
            list($methodName, $params) = $this->handle_param_string($params, 'callerMethodName', 'unWatchTradesForSymbols');
            $params = $this->omit($params, 'callerMethodName');
            if ($symbolsLength === 0) {
                throw new ArgumentsRequired($this->id . ' ' . $methodName . '() requires a non-empty array of symbols');
            }
            $url = $this->urls['api']['ws'][$type];
            $subscriptionArgs = array();
            $messageHashes = array();
            $request = array(
                'method' => 'UNSUBSCRIBE',
                'params' => $subscriptionArgs,
            );
            for ($i = 0; $i < count($symbols); $i++) {
                $symbol = $symbols[$i];
                $market = $this->market($symbol);
                $subscriptionArgs[] = $this->safe_string_lower($market, 'id') . '@aggTrade';
                $messageHashes[] = 'unsubscribe:trade:' . $market['symbol'];
            }
            return Async\await($this->watch_multiple($url, $messageHashes, $this->extend($request, $params), array( $type )));
        }) ();
    }

    public function handle_trade(Client $client, $message) {
        //
        //     {
        //         "stream" => "btcusdt@aggTrade",
        //         "data" => {
        //             "e" => "aggTrade",
        //             "E" => 1754551358681,
        //             "a" => 20505890,
        //             "s" => "BTCUSDT",
        //             "p" => "114783.7",
        //             "q" => "0.020",
        //             "f" => 26024678,
        //             "l" => 26024682,
        //             "T" => 1754551358528,
        //             "m" => false
        //         }
        //     }
        //
        $subscriptions = $client->subscriptions;
        $subscriptionsKeys = is_array($subscriptions) ? array_keys($subscriptions) : array();
        $marketType = $this->get_account_type_from_subscriptions($subscriptionsKeys);
        $trade = $this->safe_dict($message, 'data');
        $marketId = $this->safe_string($trade, 's');
        $market = $this->safe_market($marketId, null, null, $marketType);
        $parsed = $this->parse_ws_trade($trade, $market);
        $symbol = $parsed['symbol'];
        $stored = $this->safe_value($this->trades, $symbol);
        if ($stored === null) {
            $limit = $this->safe_integer($this->options, 'tradesLimit', 1000);
            $stored = new ArrayCache ($limit);
            $this->trades[$symbol] = $stored;
        }
        $stored->append ($parsed);
        $messageHash = 'trade' . ':' . $symbol;
        $client->resolve ($stored, $messageHash);
    }

    public function parse_ws_trade(array $trade, ?array $market = null): array {
        $timestamp = $this->safe_integer($trade, 'T');
        $symbol = $market['symbol'];
        $amountString = $this->safe_string($trade, 'q');
        $priceString = $this->safe_string($trade, 'p');
        $isMaker = $this->safe_bool($trade, 'm');
        $takerOrMaker = null;
        if ($isMaker !== null) {
            $takerOrMaker = $isMaker ? 'maker' : 'taker';
        }
        return $this->safe_trade(array(
            'id' => $this->safe_string($trade, 'a'),
            'info' => $trade,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'symbol' => $symbol,
            'order' => null,
            'type' => null,
            'side' => null,
            'takerOrMaker' => $takerOrMaker,
            'price' => $priceString,
            'amount' => $amountString,
            'cost' => null,
            'fee' => null,
        ), $market);
    }

    public function watch_order_book(string $symbol, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $limit, $params) {
            /**
             * watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
             *
             * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-spot-api.md#limited-depth-information
             * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-futures-api.md#partial-book-depth-streams
             *
             * @param {string} $symbol unified $symbol of the market to fetch the order book for
             * @param {int} [$limit] the maximum amount of order book entries to return.
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} A dictionary of ~@link https://docs.ccxt.com/#/?id=order-book-structure order book structures~ indexed by market symbols
             */
            $params['callerMethodName'] = 'watchOrderBook';
            return Async\await($this->watch_order_book_for_symbols(array( $symbol ), $limit, $params));
        }) ();
    }

    public function un_watch_order_book(string $symbol, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $params) {
            /**
             * unsubscribe from the orderbook channel
             *
             * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-spot-api.md#limited-depth-information
             * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-futures-api.md#partial-book-depth-streams
             *
             * @param {string} $symbol symbol of the market to unwatch the trades for
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @param {int} [$params->limit] orderbook limit, default is null
             * @return {array} A dictionary of ~@link https://docs.ccxt.com/#/?id=order-book-structure order book structures~ indexed by market symbols
             */
            $params['callerMethodName'] = 'unWatchOrderBook';
            return Async\await($this->un_watch_order_book_for_symbols(array( $symbol ), $params));
        }) ();
    }

    public function watch_order_book_for_symbols(array $symbols, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbols, $limit, $params) {
            /**
             * watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
             *
             * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-spot-api.md#limited-depth-information
             * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-futures-api.md#partial-book-depth-streams
             *
             * @param {string[]} $symbols unified array of $symbols
             * @param {int} [$limit] the maximum amount of order book entries to return.
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} A dictionary of ~@link https://docs.ccxt.com/#/?id=order-book-structure order book structures~ indexed by $market $symbols
             */
            Async\await($this->load_markets());
            $symbols = $this->market_symbols($symbols, null, true, true, true);
            $firstMarket = $this->get_market_from_symbols($symbols);
            $type = $this->safe_string($firstMarket, 'type', 'swap');
            $symbolsLength = count($symbols);
            $methodName = null;
            list($methodName, $params) = $this->handle_param_string($params, 'callerMethodName', 'watchOrderBookForSymbols');
            $params = $this->omit($params, 'callerMethodName');
            if ($symbolsLength === 0) {
                throw new ArgumentsRequired($this->id . ' ' . $methodName . '() requires a non-empty array of symbols');
            }
            $url = $this->urls['api']['ws'][$type];
            $subscriptionArgs = array();
            $messageHashes = array();
            $request = array(
                'method' => 'SUBSCRIBE',
                'params' => $subscriptionArgs,
            );
            if ($limit === null || ($limit !== 5 && $limit !== 10 && $limit !== 20)) {
                $limit = 20;
            }
            for ($i = 0; $i < count($symbols); $i++) {
                $symbol = $symbols[$i];
                $market = $this->market($symbol);
                $subscriptionArgs[] = $this->safe_string_lower($market, 'id') . '@depth' . $limit;
                $messageHashes[] = 'orderbook:' . $market['symbol'];
            }
            $orderbook = Async\await($this->watch_multiple($url, $messageHashes, $this->extend($request, $params), array( $type )));
            return $orderbook->limit ();
        }) ();
    }

    public function un_watch_order_book_for_symbols(array $symbols, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbols, $params) {
            /**
             * unsubscribe from the orderbook channel
             *
             * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-spot-api.md#limited-depth-information
             * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-futures-api.md#partial-book-depth-streams
             *
             * @param {string[]} $symbols unified $symbol of the $market to unwatch the trades for
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @param {int} [$params->limit] orderbook $limit, default is null
             * @return {array} A dictionary of ~@link https://docs.ccxt.com/#/?id=order-book-structure order book structures~ indexed by $market $symbols
             */
            Async\await($this->load_markets());
            $symbols = $this->market_symbols($symbols, null, true, true, true);
            $firstMarket = $this->get_market_from_symbols($symbols);
            $type = $this->safe_string($firstMarket, 'type', 'swap');
            $symbolsLength = count($symbols);
            $methodName = null;
            list($methodName, $params) = $this->handle_param_string($params, 'callerMethodName', 'unWatchOrderBookForSymbols');
            $params = $this->omit($params, 'callerMethodName');
            if ($symbolsLength === 0) {
                throw new ArgumentsRequired($this->id . ' ' . $methodName . '() requires a non-empty array of symbols');
            }
            $url = $this->urls['api']['ws'][$type];
            $subscriptionArgs = array();
            $messageHashes = array();
            $request = array(
                'method' => 'UNSUBSCRIBE',
                'params' => $subscriptionArgs,
            );
            $limit = $this->safe_number($params, 'limit');
            $params = $this->omit($params, 'limit');
            if ($limit === null || ($limit !== 5 && $limit !== 10 && $limit !== 20)) {
                $limit = 20;
            }
            for ($i = 0; $i < count($symbols); $i++) {
                $symbol = $symbols[$i];
                $market = $this->market($symbol);
                $subscriptionArgs[] = $this->safe_string_lower($market, 'id') . '@depth' . $limit;
                $messageHashes[] = 'unsubscribe:orderbook:' . $market['symbol'];
            }
            return Async\await($this->watch_multiple($url, $messageHashes, $this->extend($request, $params), array( $type )));
        }) ();
    }

    public function handle_order_book(Client $client, $message) {
        //
        //     {
        //         "stream" => "btcusdt@depth20",
        //         "data" => {
        //             "e" => "depthUpdate",
        //             "E" => 1754556878284,
        //             "T" => 1754556878031,
        //             "s" => "BTCUSDT",
        //             "U" => 156391349814,
        //             "u" => 156391349814,
        //             "pu" => 156391348236,
        //             "b" => array(
        //                 array(
        //                     "114988.3",
        //                     "0.147"
        //                 )
        //             ),
        //             "a" => array(
        //                 array(
        //                     "114988.4",
        //                     "1.060"
        //                 )
        //             )
        //         }
        //     }
        //
        $subscriptions = $client->subscriptions;
        $subscriptionsKeys = is_array($subscriptions) ? array_keys($subscriptions) : array();
        $marketType = $this->get_account_type_from_subscriptions($subscriptionsKeys);
        $data = $this->safe_dict($message, 'data');
        $marketId = $this->safe_string($data, 's');
        $timestamp = $this->safe_integer($data, 'T');
        $market = $this->safe_market($marketId, null, null, $marketType);
        $symbol = $market['symbol'];
        if (!(is_array($this->orderbooks) && array_key_exists($symbol, $this->orderbooks))) {
            $this->orderbooks[$symbol] = $this->order_book();
        }
        $orderbook = $this->orderbooks[$symbol];
        $snapshot = $this->parse_order_book($data, $symbol, $timestamp, 'b', 'a');
        $orderbook->reset ($snapshot);
        $messageHash = 'orderbook' . ':' . $symbol;
        $this->orderbooks[$symbol] = $orderbook;
        $client->resolve ($orderbook, $messageHash);
    }

    public function watch_ohlcv(string $symbol, $timeframe = '1m', ?int $since = null, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $timeframe, $since, $limit, $params) {
            /**
             * watches historical candlestick data containing the open, high, low, and close price, and the volume of a market
             *
             * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-spot-api.md#k-line-streams
             * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-futures-api.md#klinecandlestick-streams
             *
             * @param {string} $symbol unified $symbol of the market to fetch OHLCV data for
             * @param {string} $timeframe the length of time each candle represents
             * @param {int} [$since] timestamp in ms of the earliest candle to fetch
             * @param {int} [$limit] the maximum amount of candles to fetch
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {int[][]} A list of candles ordered, open, high, low, close, volume
             */
            $params['callerMethodName'] = 'watchOHLCV';
            Async\await($this->load_markets());
            $symbol = $this->safe_symbol($symbol);
            $result = Async\await($this->watch_ohlcv_for_symbols(array( array( $symbol, $timeframe ) ), $since, $limit, $params));
            return $result[$symbol][$timeframe];
        }) ();
    }

    public function un_watch_ohlcv(string $symbol, $timeframe = '1m', $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $timeframe, $params) {
            /**
             * unWatches historical candlestick data containing the open, high, low, and close price, and the volume of a market
             *
             * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-spot-api.md#k-line-streams
             * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-futures-api.md#klinecandlestick-streams
             *
             * @param {string} $symbol unified $symbol of the market to fetch OHLCV data for
             * @param {string} $timeframe the length of time each candle represents
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {int[][]} A list of candles ordered, open, high, low, close, volume
             */
            $params['callerMethodName'] = 'unWatchOHLCV';
            return Async\await($this->un_watch_ohlcv_for_symbols(array( array( $symbol, $timeframe ) ), $params));
        }) ();
    }

    public function watch_ohlcv_for_symbols(array $symbolsAndTimeframes, ?int $since = null, ?int $limit = null, $params = array ()) {
        return Async\async(function () use ($symbolsAndTimeframes, $since, $limit, $params) {
            /**
             * watches historical candlestick $data containing the open, high, low, and close price, and the volume of a $market
             *
             * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-spot-api.md#k-line-streams
             * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-futures-api.md#klinecandlestick-streams
             *
             * @param {string[][]} $symbolsAndTimeframes array of arrays containing unified $symbols and timeframes to fetch OHLCV $data for, example [['BTC/USDT', '1m'], ['LTC/USDT', '5m']]
             * @param {int} [$since] timestamp in ms of the earliest candle to fetch
             * @param {int} [$limit] the maximum amount of candles to fetch
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} A list of candles ordered, open, high, low, close, volume
             */
            Async\await($this->load_markets());
            $symbolsLength = count($symbolsAndTimeframes);
            $methodName = null;
            list($methodName, $params) = $this->handle_param_string($params, 'callerMethodName', 'watchOHLCVForSymbols');
            $params = $this->omit($params, 'callerMethodName');
            if ($symbolsLength === 0) {
                throw new ArgumentsRequired($this->id . ' ' . $methodName . '() requires a non-empty array of symbols');
            }
            $symbols = $this->get_list_from_object_values($symbolsAndTimeframes, 0);
            $marketSymbols = $this->market_symbols($symbols, null, false, true, true);
            $firstMarket = $this->market($marketSymbols[0]);
            $type = $this->safe_string($firstMarket, 'type', 'swap');
            $url = $this->urls['api']['ws'][$type];
            $subscriptionArgs = array();
            $messageHashes = array();
            $request = array(
                'method' => 'SUBSCRIBE',
                'params' => $subscriptionArgs,
            );
            for ($i = 0; $i < count($symbolsAndTimeframes); $i++) {
                $data = $symbolsAndTimeframes[$i];
                $symbolString = $this->safe_string($data, 0);
                $market = $this->market($symbolString);
                $symbolString = $market['symbol'];
                $unfiedTimeframe = $this->safe_string($data, 1);
                $timeframeId = $this->safe_string($this->timeframes, $unfiedTimeframe, $unfiedTimeframe);
                $subscriptionArgs[] = $this->safe_string_lower($market, 'id') . '@kline_' . $timeframeId;
                $messageHashes[] = 'ohlcv:' . $market['symbol'] . ':' . $unfiedTimeframe;
            }
            list($symbol, $timeframe, $stored) = Async\await($this->watch_multiple($url, $messageHashes, $this->extend($request, $params), array( $type )));
            if ($this->newUpdates) {
                $limit = $stored->getLimit ($symbol, $limit);
            }
            $filtered = $this->filter_by_since_limit($stored, $since, $limit, 0, true);
            return $this->create_ohlcv_object($symbol, $timeframe, $filtered);
        }) ();
    }

    public function un_watch_ohlcv_for_symbols(array $symbolsAndTimeframes, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbolsAndTimeframes, $params) {
            /**
             * unWatches historical candlestick $data containing the open, high, low, and close price, and the volume of a $market
             *
             * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-spot-api.md#k-line-streams
             * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-futures-api.md#klinecandlestick-streams
             *
             * @param {string[][]} $symbolsAndTimeframes array of arrays containing unified $symbols and timeframes to fetch OHLCV $data for, example [['BTC/USDT', '1m'], ['LTC/USDT', '5m']]
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {int[][]} A list of candles ordered, open, high, low, close, volume
             */
            Async\await($this->load_markets());
            $symbolsLength = count($symbolsAndTimeframes);
            $methodName = null;
            list($methodName, $params) = $this->handle_param_string($params, 'callerMethodName', 'unWatchOHLCVForSymbols');
            $params = $this->omit($params, 'callerMethodName');
            if ($symbolsLength === 0) {
                throw new ArgumentsRequired($this->id . ' ' . $methodName . '() requires a non-empty array of symbols');
            }
            $symbols = $this->get_list_from_object_values($symbolsAndTimeframes, 0);
            $marketSymbols = $this->market_symbols($symbols, null, false, true, true);
            $firstMarket = $this->market($marketSymbols[0]);
            $type = $this->safe_string($firstMarket, 'type', 'swap');
            $url = $this->urls['api']['ws'][$type];
            $subscriptionArgs = array();
            $messageHashes = array();
            $request = array(
                'method' => 'UNSUBSCRIBE',
                'params' => $subscriptionArgs,
            );
            for ($i = 0; $i < count($symbolsAndTimeframes); $i++) {
                $data = $symbolsAndTimeframes[$i];
                $symbolString = $this->safe_string($data, 0);
                $market = $this->market($symbolString);
                $symbolString = $market['symbol'];
                $unfiedTimeframe = $this->safe_string($data, 1);
                $timeframeId = $this->safe_string($this->timeframes, $unfiedTimeframe, $unfiedTimeframe);
                $subscriptionArgs[] = $this->safe_string_lower($market, 'id') . '@kline_' . $timeframeId;
                $messageHashes[] = 'unsubscribe:ohlcv:' . $market['symbol'] . ':' . $unfiedTimeframe;
            }
            return Async\await($this->watch_multiple($url, $messageHashes, $this->extend($request, $params), array( $type )));
        }) ();
    }

    public function handle_ohlcv(Client $client, $message) {
        //
        //     {
        //         "stream" => "btcusdt@kline_1m",
        //         "data" => {
        //             "e" => "kline",
        //             "E" => 1754655777119,
        //             "s" => "BTCUSDT",
        //             "k" => {
        //                 "t" => 1754655720000,
        //                 "T" => 1754655779999,
        //                 "s" => "BTCUSDT",
        //                 "i" => "1m",
        //                 "f" => 26032629,
        //                 "L" => 26032629,
        //                 "o" => "116546.9",
        //                 "c" => "116546.9",
        //                 "h" => "116546.9",
        //                 "l" => "116546.9",
        //                 "v" => "0.011",
        //                 "n" => 1,
        //                 "x" => false,
        //                 "q" => "1282.0159",
        //                 "V" => "0.000",
        //                 "Q" => "0.0000",
        //                 "B" => "0"
        //             }
        //         }
        //     }
        //
        $subscriptions = $client->subscriptions;
        $subscriptionsKeys = is_array($subscriptions) ? array_keys($subscriptions) : array();
        $marketType = $this->get_account_type_from_subscriptions($subscriptionsKeys);
        $data = $this->safe_dict($message, 'data');
        $marketId = $this->safe_string($data, 's');
        $market = $this->safe_market($marketId, null, null, $marketType);
        $symbol = $market['symbol'];
        $kline = $this->safe_dict($data, 'k');
        $timeframeId = $this->safe_string($kline, 'i');
        $timeframe = $this->find_timeframe($timeframeId);
        $ohlcvsByTimeframe = $this->safe_value($this->ohlcvs, $symbol);
        if ($ohlcvsByTimeframe === null) {
            $this->ohlcvs[$symbol] = array();
        }
        if ($this->safe_value($ohlcvsByTimeframe, $timeframe) === null) {
            $limit = $this->safe_integer($this->options, 'OHLCVLimit', 1000);
            $this->ohlcvs[$symbol][$timeframe] = new ArrayCacheByTimestamp ($limit);
        }
        $stored = $this->ohlcvs[$symbol][$timeframe];
        $parsed = $this->parse_ws_ohlcv($kline);
        $stored->append ($parsed);
        $messageHash = 'ohlcv:' . $symbol . ':' . $timeframe;
        $resolveData = array( $symbol, $timeframe, $stored );
        $client->resolve ($resolveData, $messageHash);
    }

    public function parse_ws_ohlcv($ohlcv, $market = null): array {
        return array(
            $this->safe_integer($ohlcv, 't'),
            $this->safe_number($ohlcv, 'o'),
            $this->safe_number($ohlcv, 'h'),
            $this->safe_number($ohlcv, 'l'),
            $this->safe_number($ohlcv, 'c'),
            $this->safe_number($ohlcv, 'v'),
        );
    }

    public function handle_message(Client $client, $message) {
        $stream = $this->safe_string($message, 'stream');
        if ($stream !== null) {
            $part = explode('@', $stream);
            $topic = $this->safe_string($part, 1, '');
            $part2 = explode('_', $topic);
            $topic = $this->safe_string($part2, 0, '');
            $methods = array(
                'ticker' => array($this, 'handle_ticker'),
                'aggTrade' => array($this, 'handle_trade'),
                'depth5' => array($this, 'handle_order_book'),
                'depth10' => array($this, 'handle_order_book'),
                'depth20' => array($this, 'handle_order_book'),
                'kline' => array($this, 'handle_ohlcv'),
                'markPrice' => array($this, 'handle_ticker'),
                'bookTicker' => array($this, 'handle_bid_ask'),
            );
            $method = $this->safe_value($methods, $topic);
            if ($method !== null) {
                $method($client, $message);
            }
        }
    }
}
