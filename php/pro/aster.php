<?php

namespace ccxt\pro;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

use Exception; // a common import
use ccxt\ArgumentsRequired;
use ccxt\Precise;
use \React\Async;
use \React\Promise\PromiseInterface;

class aster extends \ccxt\async\aster {

    public function describe(): mixed {
        return $this->deep_extend(parent::describe(), array(
            'has' => array(
                'ws' => true,
                'watchBalance' => true,
                'watchBidsAsks' => true,
                'watchMarkPrice' => true,
                'watchMarkPrices' => true,
                'watchTrades' => true,
                'watchTradesForSymbols' => true,
                'watchOrders' => true,
                'watchOrderBook' => true,
                'watchOrderBookForSymbols' => true,
                'watchOHLCV' => true,
                'watchOHLCVForSymbols' => true,
                'watchPositions' => true,
                'watchTicker' => true,
                'watchTickers' => true,
                'watchMyTrades' => true,
                'unWatchTicker' => true,
                'unWatchTickers' => true,
                'unWatchMarkPrice' => true,
                'unWatchMarkPrices' => true,
                'unWatchBidsAsks' => true,
                'unWatchTrades' => true,
                'unWatchTradesForSymbols' => true,
                'unWatchOrderBook' => true,
                'unWatchOrderBookForSymbols' => true,
                'unWatchOHLCV' => true,
                'unWatchOHLCVForSymbols' => true,
            ),
            'urls' => array(
                'api' => array(
                    'ws' => array(
                        'public' => array(
                            'spot' => 'wss://sstream.asterdex.com/stream',
                            'swap' => 'wss://fstream.asterdex.com/stream',
                        ),
                        'private' => array(
                            'spot' => 'wss://sstream.asterdex.com/ws',
                            'swap' => 'wss://fstream.asterdex.com/ws',
                        ),
                    ),
                ),
            ),
            'options' => array(
                'listenKey' => array(
                    'spot' => null,
                    'swap' => null,
                ),
                'lastAuthenticatedTime' => array(
                    'spot' => 0,
                    'swap' => 0,
                ),
                'listenKeyRefreshRate' => array(
                    'spot' => 3600000, // 60 minutes
                    'swap' => 3600000,
                ),
                'watchBalance' => array(
                    'fetchBalanceSnapshot' => false, // or true
                    'awaitBalanceSnapshot' => true, // whether to wait for the balance snapshot before providing updates
                ),
                'wallet' => 'wb', // wb = wallet balance, cw = cross balance
                'watchPositions' => array(
                    'fetchPositionsSnapshot' => true, // or false
                    'awaitPositionsSnapshot' => true, // whether to wait for the positions snapshot before providing updates
                ),
            ),
            'streaming' => array(),
            'exceptions' => array(),
        ));
    }

    public function get_account_type_from_subscriptions(array $subscriptions): string {
        $accountType = '';
        for ($i = 0; $i < count($subscriptions); $i++) {
            $subscription = $subscriptions[$i];
            if (($subscription === 'spot') || ($subscription === 'swap')) {
                $accountType = $subscription;
                break;
            }
        }
        return $accountType;
    }

    public function watch_ticker(string $symbol, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $params) {
            /**
             * watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
             *
             * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-spot-api.md#full-ticker-per-$symbol
             * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-futures-api.md#individual-$symbol-ticker-streams
             *
             * @param {string} $symbol unified $symbol of the market to fetch the ticker for
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} a ~@link https://docs.ccxt.com/#/?id=ticker-structure ticker structure~
             */
            $params['callerMethodName'] = 'watchTicker';
            Async\await($this->load_markets());
            $symbol = $this->safe_symbol($symbol);
            $tickers = Async\await($this->watch_tickers(array( $symbol ), $params));
            return $tickers[$symbol];
        }) ();
    }

    public function un_watch_ticker(string $symbol, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $params) {
            /**
             * unWatches a price ticker
             *
             * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-spot-api.md#full-ticker-per-$symbol
             * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-futures-api.md#individual-$symbol-ticker-streams
             *
             * @param {string} $symbol unified $symbol of the market to fetch the ticker for
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} a ~@link https://docs.ccxt.com/#/?id=ticker-structure ticker structure~
             */
            $params['callerMethodName'] = 'unWatchTicker';
            return Async\await($this->un_watch_tickers(array( $symbol ), $params));
        }) ();
    }

    public function watch_tickers(?array $symbols = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbols, $params) {
            /**
             * watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for all markets of a specific list
             *
             * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-spot-api.md#full-ticker-per-$symbol
             * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-futures-api.md#individual-$symbol-ticker-streams
             *
             * @param {string[]} $symbols unified $symbol of the $market to fetch the ticker for
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} a ~@link https://docs.ccxt.com/#/?id=ticker-structure ticker structure~
             */
            Async\await($this->load_markets());
            $symbols = $this->market_symbols($symbols, null, true, true, true);
            $firstMarket = $this->get_market_from_symbols($symbols);
            $type = $this->safe_string($firstMarket, 'type', 'swap');
            $symbolsLength = count($symbols);
            $methodName = null;
            list($methodName, $params) = $this->handle_param_string($params, 'callerMethodName', 'watchTickers');
            $params = $this->omit($params, 'callerMethodName');
            if ($symbolsLength === 0) {
                throw new ArgumentsRequired($this->id . ' ' . $methodName . '() requires a non-empty array of symbols');
            }
            $url = $this->urls['api']['ws']['public'][$type];
            $subscriptionArgs = array();
            $messageHashes = array();
            $request = array(
                'method' => 'SUBSCRIBE',
                'params' => $subscriptionArgs,
            );
            for ($i = 0; $i < count($symbols); $i++) {
                $symbol = $symbols[$i];
                $market = $this->market($symbol);
                $subscriptionArgs[] = $this->safe_string_lower($market, 'id') . '@ticker';
                $messageHashes[] = 'ticker:' . $market['symbol'];
            }
            $newTicker = Async\await($this->watch_multiple($url, $messageHashes, $this->extend($request, $params), array( $type )));
            if ($this->newUpdates) {
                $result = array();
                $result[$newTicker['symbol']] = $newTicker;
                return $result;
            }
            return $this->filter_by_array($this->tickers, 'symbol', $symbols);
        }) ();
    }

    public function un_watch_tickers(?array $symbols = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbols, $params) {
            /**
             * unWatches a price ticker, a statistical calculation with the information calculated over the past 24 hours for all markets of a specific list
             *
             * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-spot-api.md#full-ticker-per-$symbol
             * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-futures-api.md#individual-$symbol-ticker-streams
             *
             * @param {string[]} $symbols unified $symbol of the $market to fetch the ticker for
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} a ~@link https://docs.ccxt.com/#/?id=ticker-structure ticker structure~
             */
            Async\await($this->load_markets());
            $symbols = $this->market_symbols($symbols, null, true, true, true);
            $firstMarket = $this->get_market_from_symbols($symbols);
            $type = $this->safe_string($firstMarket, 'type', 'swap');
            $symbolsLength = count($symbols);
            $methodName = null;
            list($methodName, $params) = $this->handle_param_string($params, 'callerMethodName', 'unWatchTickers');
            $params = $this->omit($params, 'callerMethodName');
            if ($symbolsLength === 0) {
                throw new ArgumentsRequired($this->id . ' ' . $methodName . '() requires a non-empty array of symbols');
            }
            $url = $this->urls['api']['ws']['public'][$type];
            $subscriptionArgs = array();
            $messageHashes = array();
            $request = array(
                'method' => 'UNSUBSCRIBE',
                'params' => $subscriptionArgs,
            );
            for ($i = 0; $i < count($symbols); $i++) {
                $symbol = $symbols[$i];
                $market = $this->market($symbol);
                $subscriptionArgs[] = $this->safe_string_lower($market, 'id') . '@ticker';
                $messageHashes[] = 'unsubscribe:ticker:' . $market['symbol'];
            }
            return Async\await($this->watch_multiple($url, $messageHashes, $this->extend($request, $params), array( $type )));
        }) ();
    }

    public function watch_mark_price(string $symbol, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $params) {
            /**
             * watches a mark price for a specific market
             *
             * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-futures-api.md#mark-price-stream
             *
             * @param {string} $symbol unified $symbol of the market to fetch the ticker for
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @param {boolean} [$params->use1sFreq] *default is true* if set to true, the mark price will be updated every second, otherwise every 3 seconds
             * @return {array} a ~@link https://docs.ccxt.com/#/?id=ticker-structure ticker structure~
             */
            $params['callerMethodName'] = 'watchMarkPrice';
            Async\await($this->load_markets());
            $symbol = $this->safe_symbol($symbol);
            $tickers = Async\await($this->watch_mark_prices(array( $symbol ), $params));
            return $tickers[$symbol];
        }) ();
    }

    public function un_watch_mark_price(string $symbol, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $params) {
            /**
             * unWatches a mark price for a specific market
             *
             * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-futures-api.md#mark-price-stream
             *
             * @param {string} $symbol unified $symbol of the market to fetch the ticker for
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @param {boolean} [$params->use1sFreq] *default is true* if set to true, the mark price will be updated every second, otherwise every 3 seconds
             * @return {array} a ~@link https://docs.ccxt.com/#/?id=ticker-structure ticker structure~
             */
            $params['callerMethodName'] = 'unWatchMarkPrice';
            return Async\await($this->un_watch_mark_prices(array( $symbol ), $params));
        }) ();
    }

    public function watch_mark_prices(?array $symbols = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbols, $params) {
            /**
             * watches the mark price for all markets
             *
             * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-futures-api.md#mark-price-stream
             *
             * @param {string[]} $symbols unified $symbol of the $market to fetch the ticker for
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @param {boolean} [$params->use1sFreq] *default is true* if set to true, the mark price will be updated every second, otherwise every 3 seconds
             * @return {array} a ~@link https://docs.ccxt.com/#/?id=ticker-structure ticker structure~
             */
            Async\await($this->load_markets());
            $symbols = $this->market_symbols($symbols, null, true, true, true);
            $firstMarket = $this->get_market_from_symbols($symbols);
            $type = $this->safe_string($firstMarket, 'type', 'swap');
            $symbolsLength = count($symbols);
            $methodName = null;
            list($methodName, $params) = $this->handle_param_string($params, 'callerMethodName', 'watchMarkPrices');
            $params = $this->omit($params, 'callerMethodName');
            if ($symbolsLength === 0) {
                throw new ArgumentsRequired($this->id . ' ' . $methodName . '() requires a non-empty array of symbols');
            }
            $url = $this->urls['api']['ws']['public'][$type];
            $subscriptionArgs = array();
            $messageHashes = array();
            $request = array(
                'method' => 'SUBSCRIBE',
                'params' => $subscriptionArgs,
            );
            $use1sFreq = $this->safe_bool($params, 'use1sFreq', true);
            for ($i = 0; $i < count($symbols); $i++) {
                $symbol = $symbols[$i];
                $market = $this->market($symbol);
                $suffix = ($use1sFreq) ? '@1s' : '';
                $subscriptionArgs[] = $this->safe_string_lower($market, 'id') . '@markPrice' . $suffix;
                $messageHashes[] = 'ticker:' . $market['symbol'];
            }
            $newTicker = Async\await($this->watch_multiple($url, $messageHashes, $this->extend($request, $params), array( $type )));
            if ($this->newUpdates) {
                $result = array();
                $result[$newTicker['symbol']] = $newTicker;
                return $result;
            }
            return $this->filter_by_array($this->tickers, 'symbol', $symbols);
        }) ();
    }

    public function un_watch_mark_prices(?array $symbols = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbols, $params) {
            /**
             * watches the mark price for all markets
             *
             * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-futures-api.md#mark-price-stream
             *
             * @param {string[]} $symbols unified $symbol of the $market to fetch the ticker for
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @param {boolean} [$params->use1sFreq] *default is true* if set to true, the mark price will be updated every second, otherwise every 3 seconds
             * @return {array} a ~@link https://docs.ccxt.com/#/?id=ticker-structure ticker structure~
             */
            Async\await($this->load_markets());
            $symbols = $this->market_symbols($symbols, null, true, true, true);
            $firstMarket = $this->get_market_from_symbols($symbols);
            $type = $this->safe_string($firstMarket, 'type', 'swap');
            $symbolsLength = count($symbols);
            $methodName = null;
            list($methodName, $params) = $this->handle_param_string($params, 'callerMethodName', 'unWatchMarkPrices');
            $params = $this->omit($params, 'callerMethodName');
            if ($symbolsLength === 0) {
                throw new ArgumentsRequired($this->id . ' ' . $methodName . '() requires a non-empty array of symbols');
            }
            $url = $this->urls['api']['ws']['public'][$type];
            $subscriptionArgs = array();
            $messageHashes = array();
            $request = array(
                'method' => 'UNSUBSCRIBE',
                'params' => $subscriptionArgs,
            );
            $use1sFreq = $this->safe_bool($params, 'use1sFreq', true);
            for ($i = 0; $i < count($symbols); $i++) {
                $symbol = $symbols[$i];
                $market = $this->market($symbol);
                $suffix = ($use1sFreq) ? '@1s' : '';
                $subscriptionArgs[] = $this->safe_string_lower($market, 'id') . '@markPrice' . $suffix;
                $messageHashes[] = 'unsubscribe:ticker:' . $market['symbol'];
            }
            return Async\await($this->watch_multiple($url, $messageHashes, $this->extend($request, $params), array( $type )));
        }) ();
    }

    public function handle_ticker(Client $client, $message) {
        //
        //     {
        //         "stream" => "trumpusdt@$ticker",
        //         "data" => {
        //             "e" => "24hrTicker",
        //             "E" => 1754451187277,
        //             "s" => "CAKEUSDT",
        //             "p" => "-0.08800",
        //             "P" => "-3.361",
        //             "w" => "2.58095",
        //             "c" => "2.53000",
        //             "Q" => "5",
        //             "o" => "2.61800",
        //             "h" => "2.64700",
        //             "l" => "2.52400",
        //             "v" => "15775",
        //             "q" => "40714.46000",
        //             "O" => 1754364780000,
        //             "C" => 1754451187274,
        //             "F" => 6571389,
        //             "L" => 6574507,
        //             "n" => 3119
        //         }
        //     }
        //     {
        //         "stream" => "btcusdt@markPrice",
        //         "data" => {
        //             "e" => "markPriceUpdate",
        //             "E" => 1754660466000,
        //             "s" => "BTCUSDT",
        //             "p" => "116809.60000000",
        //             "P" => "116595.54012838",
        //             "i" => "116836.93534884",
        //             "r" => "0.00010000",
        //             "T" => 1754668800000
        //         }
        //     }
        //
        $subscriptions = $client->subscriptions;
        $subscriptionsKeys = is_array($subscriptions) ? array_keys($subscriptions) : array();
        $marketType = $this->get_account_type_from_subscriptions($subscriptionsKeys);
        $ticker = $this->safe_dict($message, 'data');
        $parsed = $this->parse_ws_ticker($ticker, $marketType);
        $symbol = $parsed['symbol'];
        $messageHash = 'ticker:' . $symbol;
        $this->tickers[$symbol] = $parsed;
        $client->resolve ($this->tickers[$symbol], $messageHash);
    }

    public function parse_ws_ticker($message, $marketType) {
        $event = $this->safe_string($message, 'e');
        $part = explode('@', $event);
        $channel = $this->safe_string($part, 1);
        $marketId = $this->safe_string($message, 's');
        $timestamp = $this->safe_integer($message, 'E');
        $market = $this->safe_market($marketId, null, null, $marketType);
        $last = $this->safe_string($message, 'c');
        if ($channel === 'markPriceUpdate') {
            return $this->safe_ticker(array(
                'symbol' => $market['symbol'],
                'timestamp' => $timestamp,
                'datetime' => $this->iso8601($timestamp),
                'info' => $message,
                'markPrice' => $this->safe_string($message, 'p'),
                'indexPrice' => $this->safe_string($message, 'i'),
            ));
        }
        return $this->safe_ticker(array(
            'symbol' => $market['symbol'],
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'high' => $this->safe_string($message, 'h'),
            'low' => $this->safe_string($message, 'l'),
            'bid' => null,
            'bidVolume' => null,
            'ask' => null,
            'askVolume' => null,
            'vwap' => $this->safe_string($message, 'w'),
            'open' => $this->safe_string($message, 'o'),
            'close' => $last,
            'last' => $last,
            'previousClose' => null,
            'change' => $this->safe_string($message, 'p'),
            'percentage' => $this->safe_string($message, 'P'),
            'average' => null,
            'baseVolume' => $this->safe_string($message, 'v'),
            'quoteVolume' => $this->safe_string($message, 'q'),
            'info' => $message,
        ), $market);
    }

    public function watch_bids_asks(?array $symbols = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbols, $params) {
            /**
             * watches best bid & ask for $symbols
             *
             * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-spot-api.md#best-order-book-information-by-$symbol
             * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-futures-api.md#individual-$symbol-book-ticker-streams
             *
             * @param {string[]} $symbols unified $symbol of the $market to fetch the ticker for
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} a ~@link https://docs.ccxt.com/#/?id=ticker-structure ticker structure~
             */
            Async\await($this->load_markets());
            $symbols = $this->market_symbols($symbols, null, true, true, true);
            $firstMarket = $this->get_market_from_symbols($symbols);
            $type = $this->safe_string($firstMarket, 'type', 'swap');
            $symbolsLength = count($symbols);
            if ($symbolsLength === 0) {
                throw new ArgumentsRequired($this->id . ' watchBidsAsks() requires a non-empty array of symbols');
            }
            $url = $this->urls['api']['ws']['public'][$type];
            $subscriptionArgs = array();
            $messageHashes = array();
            $request = array(
                'method' => 'SUBSCRIBE',
                'params' => $subscriptionArgs,
            );
            for ($i = 0; $i < count($symbols); $i++) {
                $symbol = $symbols[$i];
                $market = $this->market($symbol);
                $subscriptionArgs[] = $this->safe_string_lower($market, 'id') . '@bookTicker';
                $messageHashes[] = 'bidask:' . $market['symbol'];
            }
            $newTicker = Async\await($this->watch_multiple($url, $messageHashes, $this->extend($request, $params), array( $type )));
            if ($this->newUpdates) {
                $result = array();
                $result[$newTicker['symbol']] = $newTicker;
                return $result;
            }
            return $this->filter_by_array($this->bidsasks, 'symbol', $symbols);
        }) ();
    }

    public function un_watch_bids_asks(?array $symbols = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbols, $params) {
            /**
             * unWatches best bid & ask for $symbols
             *
             * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-spot-api.md#best-order-book-information-by-$symbol
             * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-futures-api.md#individual-$symbol-book-ticker-streams
             *
             * @param {string[]} $symbols unified $symbol of the $market to fetch the ticker for
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} a ~@link https://docs.ccxt.com/#/?id=ticker-structure ticker structure~
             */
            Async\await($this->load_markets());
            $symbols = $this->market_symbols($symbols, null, true, true, true);
            $firstMarket = $this->get_market_from_symbols($symbols);
            $type = $this->safe_string($firstMarket, 'type', 'swap');
            $symbolsLength = count($symbols);
            if ($symbolsLength === 0) {
                throw new ArgumentsRequired($this->id . ' unWatchBidsAsks() requires a non-empty array of symbols');
            }
            $url = $this->urls['api']['ws']['public'][$type];
            $subscriptionArgs = array();
            $messageHashes = array();
            $request = array(
                'method' => 'UNSUBSCRIBE',
                'params' => $subscriptionArgs,
            );
            for ($i = 0; $i < count($symbols); $i++) {
                $symbol = $symbols[$i];
                $market = $this->market($symbol);
                $subscriptionArgs[] = $this->safe_string_lower($market, 'id') . '@bookTicker';
                $messageHashes[] = 'unsubscribe:bidask:' . $market['symbol'];
            }
            return Async\await($this->watch_multiple($url, $messageHashes, $this->extend($request, $params), array( $type )));
        }) ();
    }

    public function handle_bid_ask(Client $client, $message) {
        //
        //     {
        //         "stream" => "btcusdt@bookTicker",
        //         "data" => {
        //             "e" => "bookTicker",
        //             "u" => 157240846459,
        //             "s" => "BTCUSDT",
        //             "b" => "122046.7",
        //             "B" => "1.084",
        //             "a" => "122046.8",
        //             "A" => "0.001",
        //             "T" => 1754896692922,
        //             "E" => 1754896692926
        //         }
        //     }
        //
        $subscriptions = $client->subscriptions;
        $subscriptionsKeys = is_array($subscriptions) ? array_keys($subscriptions) : array();
        $marketType = $this->get_account_type_from_subscriptions($subscriptionsKeys);
        $data = $this->safe_dict($message, 'data', array());
        $marketId = $this->safe_string($data, 's');
        $market = $this->safe_market($marketId, null, null, $marketType);
        $ticker = $this->parse_ws_bid_ask($data, $market);
        $symbol = $ticker['symbol'];
        $this->bidsasks[$symbol] = $ticker;
        $messageHash = 'bidask:' . $symbol;
        $client->resolve ($ticker, $messageHash);
    }

    public function parse_ws_bid_ask($message, $market = null) {
        $timestamp = $this->safe_integer($message, 'T');
        return $this->safe_ticker(array(
            'symbol' => $market['symbol'],
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'ask' => $this->safe_string($message, 'a'),
            'askVolume' => $this->safe_string($message, 'A'),
            'bid' => $this->safe_string($message, 'b'),
            'bidVolume' => $this->safe_string($message, 'B'),
            'info' => $message,
        ), $market);
    }

    public function watch_trades(string $symbol, ?int $since = null, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            /**
             * watches information on multiple trades made in a market
             *
             * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-spot-api.md#collection-transaction-flow
             * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-futures-api.md#aggregate-trade-streams
             *
             * @param {string} $symbol unified market $symbol of the market trades were made in
             * @param {int} [$since] the earliest time in ms to fetch trades for
             * @param {int} [$limit] the maximum number of trade structures to retrieve
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array[]} a list of ~@link https://docs.ccxt.com/#/?id=trade-structure trade structures~
             */
            $params['callerMethodName'] = 'watchTrades';
            return Async\await($this->watch_trades_for_symbols(array( $symbol ), $since, $limit, $params));
        }) ();
    }

    public function un_watch_trades(string $symbol, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $params) {
            /**
             * unsubscribe from the trades channel
             *
             * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-spot-api.md#collection-transaction-flow
             * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-futures-api.md#aggregate-trade-streams
             *
             * @param {string} $symbol unified market $symbol of the market trades were made in
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array[]} a list of ~@link https://docs.ccxt.com/#/?id=trade-structure trade structures~
             */
            $params['callerMethodName'] = 'unWatchTrades';
            return Async\await($this->un_watch_trades_for_symbols(array( $symbol ), $params));
        }) ();
    }

    public function watch_trades_for_symbols(array $symbols, ?int $since = null, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbols, $since, $limit, $params) {
            /**
             * get the list of most recent $trades for a list of $symbols
             *
             * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-spot-api.md#collection-transaction-flow
             * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-futures-api.md#aggregate-trade-streams
             *
             * @param {string[]} $symbols unified $symbol of the $market to fetch $trades for
             * @param {int} [$since] timestamp in ms of the earliest trade to fetch
             * @param {int} [$limit] the maximum amount of $trades to fetch
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array[]} a list of ~@link https://docs.ccxt.com/#/?id=public-$trades trade structures~
             */
            Async\await($this->load_markets());
            $symbols = $this->market_symbols($symbols, null, true, true, true);
            $firstMarket = $this->get_market_from_symbols($symbols);
            $type = $this->safe_string($firstMarket, 'type', 'swap');
            $symbolsLength = count($symbols);
            $methodName = null;
            list($methodName, $params) = $this->handle_param_string($params, 'callerMethodName', 'watchTradesForSymbols');
            $params = $this->omit($params, 'callerMethodName');
            if ($symbolsLength === 0) {
                throw new ArgumentsRequired($this->id . ' ' . $methodName . '() requires a non-empty array of symbols');
            }
            $url = $this->urls['api']['ws']['public'][$type];
            $subscriptionArgs = array();
            $messageHashes = array();
            $request = array(
                'method' => 'SUBSCRIBE',
                'params' => $subscriptionArgs,
            );
            for ($i = 0; $i < count($symbols); $i++) {
                $symbol = $symbols[$i];
                $market = $this->market($symbol);
                $subscriptionArgs[] = $this->safe_string_lower($market, 'id') . '@aggTrade';
                $messageHashes[] = 'trade:' . $market['symbol'];
            }
            $trades = Async\await($this->watch_multiple($url, $messageHashes, $this->extend($request, $params), array( $type )));
            if ($this->newUpdates) {
                $first = $this->safe_value($trades, 0);
                $tradeSymbol = $this->safe_string($first, 'symbol');
                $limit = $trades->getLimit ($tradeSymbol, $limit);
            }
            return $this->filter_by_since_limit($trades, $since, $limit, 'timestamp', true);
        }) ();
    }

    public function un_watch_trades_for_symbols(array $symbols, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbols, $params) {
            /**
             * unsubscribe from the trades channel
             *
             * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-spot-api.md#collection-transaction-flow
             * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-futures-api.md#aggregate-trade-streams
             *
             * @param {string[]} $symbols unified $symbol of the $market to fetch trades for
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array[]} a list of ~@link https://docs.ccxt.com/#/?id=public-trades trade structures~
             */
            Async\await($this->load_markets());
            $symbols = $this->market_symbols($symbols, null, true, true, true);
            $firstMarket = $this->get_market_from_symbols($symbols);
            $type = $this->safe_string($firstMarket, 'type', 'swap');
            $symbolsLength = count($symbols);
            $methodName = null;
            list($methodName, $params) = $this->handle_param_string($params, 'callerMethodName', 'unWatchTradesForSymbols');
            $params = $this->omit($params, 'callerMethodName');
            if ($symbolsLength === 0) {
                throw new ArgumentsRequired($this->id . ' ' . $methodName . '() requires a non-empty array of symbols');
            }
            $url = $this->urls['api']['ws']['public'][$type];
            $subscriptionArgs = array();
            $messageHashes = array();
            $request = array(
                'method' => 'UNSUBSCRIBE',
                'params' => $subscriptionArgs,
            );
            for ($i = 0; $i < count($symbols); $i++) {
                $symbol = $symbols[$i];
                $market = $this->market($symbol);
                $subscriptionArgs[] = $this->safe_string_lower($market, 'id') . '@aggTrade';
                $messageHashes[] = 'unsubscribe:trade:' . $market['symbol'];
            }
            return Async\await($this->watch_multiple($url, $messageHashes, $this->extend($request, $params), array( $type )));
        }) ();
    }

    public function handle_trade(Client $client, $message) {
        //
        //     {
        //         "stream" => "btcusdt@aggTrade",
        //         "data" => {
        //             "e" => "aggTrade",
        //             "E" => 1754551358681,
        //             "a" => 20505890,
        //             "s" => "BTCUSDT",
        //             "p" => "114783.7",
        //             "q" => "0.020",
        //             "f" => 26024678,
        //             "l" => 26024682,
        //             "T" => 1754551358528,
        //             "m" => false
        //         }
        //     }
        //
        $subscriptions = $client->subscriptions;
        $subscriptionsKeys = is_array($subscriptions) ? array_keys($subscriptions) : array();
        $marketType = $this->get_account_type_from_subscriptions($subscriptionsKeys);
        $trade = $this->safe_dict($message, 'data');
        $marketId = $this->safe_string($trade, 's');
        $market = $this->safe_market($marketId, null, null, $marketType);
        $parsed = $this->parse_ws_trade($trade, $market);
        $symbol = $parsed['symbol'];
        $stored = $this->safe_value($this->trades, $symbol);
        if ($stored === null) {
            $limit = $this->safe_integer($this->options, 'tradesLimit', 1000);
            $stored = new ArrayCache ($limit);
            $this->trades[$symbol] = $stored;
        }
        $stored->append ($parsed);
        $messageHash = 'trade' . ':' . $symbol;
        $client->resolve ($stored, $messageHash);
    }

    public function parse_ws_trade($trade, $market = null): array {
        //
        // public watchTrades
        //
        //     {
        //         "e" => "trade",       // event $type
        //         "E" => 1579481530911, // event time
        //         "s" => "ETHBTC",      // $symbol
        //         "t" => 158410082,     // $trade $id
        //         "p" => "0.01914100",  // $price
        //         "q" => "0.00700000",  // quantity
        //         "b" => 586187049,     // buyer order $id
        //         "a" => 586186710,     // seller order $id
        //         "T" => 1579481530910, // $trade time
        //         "m" => false,         // is the buyer the $market maker
        //         "M" => true           // binance docs say it should be ignored
        //     }
        //
        //     {
        //        "e" => "aggTrade",  // Event $type
        //        "E" => 123456789,   // Event time
        //        "s" => "BNBBTC",    // Symbol
        //        "a" => 12345,       // Aggregate $trade ID
        //        "p" => "0.001",     // Price
        //        "q" => "100",       // Quantity
        //        "f" => 100,         // First $trade ID
        //        "l" => 105,         // Last $trade ID
        //        "T" => 123456785,   // Trade time
        //        "m" => true,        // Is the buyer the $market maker?
        //        "M" => true         // Ignore
        //     }
        //
        // private watchMyTrades spot
        //
        //     {
        //         "e" => "executionReport",
        //         "E" => 1611063861489,
        //         "s" => "BNBUSDT",
        //         "c" => "m4M6AD5MF3b1ERe65l4SPq",
        //         "S" => "BUY",
        //         "o" => "MARKET",
        //         "f" => "GTC",
        //         "q" => "2.00000000",
        //         "p" => "0.00000000",
        //         "P" => "0.00000000",
        //         "F" => "0.00000000",
        //         "g" => -1,
        //         "C" => '',
        //         "x" => "TRADE",
        //         "X" => "PARTIALLY_FILLED",
        //         "r" => "NONE",
        //         "i" => 1296882607,
        //         "l" => "0.33200000",
        //         "z" => "0.33200000",
        //         "L" => "46.86600000",
        //         "n" => "0.00033200",
        //         "N" => "BNB",
        //         "T" => 1611063861488,
        //         "t" => 109747654,
        //         "I" => 2696953381,
        //         "w" => false,
        //         "m" => false,
        //         "M" => true,
        //         "O" => 1611063861488,
        //         "Z" => "15.55951200",
        //         "Y" => "15.55951200",
        //         "Q" => "0.00000000"
        //     }
        //
        // private watchMyTrades future/delivery
        //
        //     {
        //         "s" => "BTCUSDT",
        //         "c" => "pb2jD6ZQHpfzSdUac8VqMK",
        //         "S" => "SELL",
        //         "o" => "MARKET",
        //         "f" => "GTC",
        //         "q" => "0.001",
        //         "p" => "0",
        //         "ap" => "33468.46000",
        //         "sp" => "0",
        //         "x" => "TRADE",
        //         "X" => "FILLED",
        //         "i" => 13351197194,
        //         "l" => "0.001",
        //         "z" => "0.001",
        //         "L" => "33468.46",
        //         "n" => "0.00027086",
        //         "N" => "BNB",
        //         "T" => 1612095165362,
        //         "t" => 458032604,
        //         "b" => "0",
        //         "a" => "0",
        //         "m" => false,
        //         "R" => false,
        //         "wt" => "CONTRACT_PRICE",
        //         "ot" => "MARKET",
        //         "ps" => "BOTH",
        //         "cp" => false,
        //         "rp" => "0.00335000",
        //         "pP" => false,
        //         "si" => 0,
        //         "ss" => 0
        //     }
        //
        $id = $this->safe_string_2($trade, 't', 'a');
        $timestamp = $this->safe_integer($trade, 'T');
        $price = $this->safe_string_2($trade, 'L', 'p');
        $amount = $this->safe_string_2($trade, 'q', 'l');
        $cost = $this->safe_string($trade, 'Y');
        if ($cost === null) {
            if (($price !== null) && ($amount !== null)) {
                $cost = Precise::string_mul($price, $amount);
            }
        }
        $marketId = $this->safe_string($trade, 's');
        $defaultType = ($market === null) ? $this->safe_string($this->options, 'defaultType', 'spot') : $market['type'];
        $symbol = $this->safe_symbol($marketId, $market, null, $defaultType);
        $side = $this->safe_string_lower($trade, 'S');
        $takerOrMaker = null;
        $orderId = $this->safe_string($trade, 'i');
        if (is_array($trade) && array_key_exists('m', $trade)) {
            if ($side === null) {
                $side = $trade['m'] ? 'sell' : 'buy'; // this is reversed intentionally
            }
            $takerOrMaker = $trade['m'] ? 'maker' : 'taker';
        }
        $fee = null;
        $feeCost = $this->safe_string($trade, 'n');
        if ($feeCost !== null) {
            $feeCurrencyId = $this->safe_string($trade, 'N');
            $feeCurrencyCode = $this->safe_currency_code($feeCurrencyId);
            $fee = array(
                'cost' => $feeCost,
                'currency' => $feeCurrencyCode,
            );
        }
        $type = $this->safe_string_lower($trade, 'o');
        return $this->safe_trade(array(
            'info' => $trade,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'symbol' => $symbol,
            'id' => $id,
            'order' => $orderId,
            'type' => $type,
            'takerOrMaker' => $takerOrMaker,
            'side' => $side,
            'price' => $price,
            'amount' => $amount,
            'cost' => $cost,
            'fee' => $fee,
        ));
    }

    public function watch_order_book(string $symbol, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $limit, $params) {
            /**
             * watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
             *
             * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-spot-api.md#limited-depth-information
             * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-futures-api.md#partial-book-depth-streams
             *
             * @param {string} $symbol unified $symbol of the market to fetch the order book for
             * @param {int} [$limit] the maximum amount of order book entries to return.
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} A dictionary of ~@link https://docs.ccxt.com/#/?id=order-book-structure order book structures~ indexed by market symbols
             */
            $params['callerMethodName'] = 'watchOrderBook';
            return Async\await($this->watch_order_book_for_symbols(array( $symbol ), $limit, $params));
        }) ();
    }

    public function un_watch_order_book(string $symbol, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $params) {
            /**
             * unsubscribe from the orderbook channel
             *
             * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-spot-api.md#limited-depth-information
             * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-futures-api.md#partial-book-depth-streams
             *
             * @param {string} $symbol symbol of the market to unwatch the trades for
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @param {int} [$params->limit] orderbook limit, default is null
             * @return {array} A dictionary of ~@link https://docs.ccxt.com/#/?id=order-book-structure order book structures~ indexed by market symbols
             */
            $params['callerMethodName'] = 'unWatchOrderBook';
            return Async\await($this->un_watch_order_book_for_symbols(array( $symbol ), $params));
        }) ();
    }

    public function watch_order_book_for_symbols(array $symbols, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbols, $limit, $params) {
            /**
             * watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
             *
             * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-spot-api.md#limited-depth-information
             * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-futures-api.md#partial-book-depth-streams
             *
             * @param {string[]} $symbols unified array of $symbols
             * @param {int} [$limit] the maximum amount of order book entries to return.
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} A dictionary of ~@link https://docs.ccxt.com/#/?id=order-book-structure order book structures~ indexed by $market $symbols
             */
            Async\await($this->load_markets());
            $symbols = $this->market_symbols($symbols, null, true, true, true);
            $firstMarket = $this->get_market_from_symbols($symbols);
            $type = $this->safe_string($firstMarket, 'type', 'swap');
            $symbolsLength = count($symbols);
            $methodName = null;
            list($methodName, $params) = $this->handle_param_string($params, 'callerMethodName', 'watchOrderBookForSymbols');
            $params = $this->omit($params, 'callerMethodName');
            if ($symbolsLength === 0) {
                throw new ArgumentsRequired($this->id . ' ' . $methodName . '() requires a non-empty array of symbols');
            }
            $url = $this->urls['api']['ws']['public'][$type];
            $subscriptionArgs = array();
            $messageHashes = array();
            $request = array(
                'method' => 'SUBSCRIBE',
                'params' => $subscriptionArgs,
            );
            if ($limit === null || ($limit !== 5 && $limit !== 10 && $limit !== 20)) {
                $limit = 20;
            }
            for ($i = 0; $i < count($symbols); $i++) {
                $symbol = $symbols[$i];
                $market = $this->market($symbol);
                $subscriptionArgs[] = $this->safe_string_lower($market, 'id') . '@depth' . (string) $limit;
                $messageHashes[] = 'orderbook:' . $market['symbol'];
            }
            $orderbook = Async\await($this->watch_multiple($url, $messageHashes, $this->extend($request, $params), array( $type )));
            return $orderbook->limit ();
        }) ();
    }

    public function un_watch_order_book_for_symbols(array $symbols, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbols, $params) {
            /**
             * unsubscribe from the orderbook channel
             *
             * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-spot-api.md#limited-depth-information
             * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-futures-api.md#partial-book-depth-streams
             *
             * @param {string[]} $symbols unified $symbol of the $market to unwatch the trades for
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @param {int} [$params->limit] orderbook $limit, default is null
             * @return {array} A dictionary of ~@link https://docs.ccxt.com/#/?id=order-book-structure order book structures~ indexed by $market $symbols
             */
            Async\await($this->load_markets());
            $symbols = $this->market_symbols($symbols, null, true, true, true);
            $firstMarket = $this->get_market_from_symbols($symbols);
            $type = $this->safe_string($firstMarket, 'type', 'swap');
            $symbolsLength = count($symbols);
            $methodName = null;
            list($methodName, $params) = $this->handle_param_string($params, 'callerMethodName', 'unWatchOrderBookForSymbols');
            $params = $this->omit($params, 'callerMethodName');
            if ($symbolsLength === 0) {
                throw new ArgumentsRequired($this->id . ' ' . $methodName . '() requires a non-empty array of symbols');
            }
            $url = $this->urls['api']['ws']['public'][$type];
            $subscriptionArgs = array();
            $messageHashes = array();
            $request = array(
                'method' => 'UNSUBSCRIBE',
                'params' => $subscriptionArgs,
            );
            $limit = $this->safe_number($params, 'limit');
            $params = $this->omit($params, 'limit');
            if ($limit === null || ($limit !== 5 && $limit !== 10 && $limit !== 20)) {
                $limit = 20;
            }
            for ($i = 0; $i < count($symbols); $i++) {
                $symbol = $symbols[$i];
                $market = $this->market($symbol);
                $subscriptionArgs[] = $this->safe_string_lower($market, 'id') . '@depth' . $limit;
                $messageHashes[] = 'unsubscribe:orderbook:' . $market['symbol'];
            }
            return Async\await($this->watch_multiple($url, $messageHashes, $this->extend($request, $params), array( $type )));
        }) ();
    }

    public function handle_order_book(Client $client, $message) {
        //
        //     {
        //         "stream" => "btcusdt@depth20",
        //         "data" => {
        //             "e" => "depthUpdate",
        //             "E" => 1754556878284,
        //             "T" => 1754556878031,
        //             "s" => "BTCUSDT",
        //             "U" => 156391349814,
        //             "u" => 156391349814,
        //             "pu" => 156391348236,
        //             "b" => array(
        //                 array(
        //                     "114988.3",
        //                     "0.147"
        //                 )
        //             ),
        //             "a" => array(
        //                 array(
        //                     "114988.4",
        //                     "1.060"
        //                 )
        //             )
        //         }
        //     }
        //
        $subscriptions = $client->subscriptions;
        $subscriptionsKeys = is_array($subscriptions) ? array_keys($subscriptions) : array();
        $marketType = $this->get_account_type_from_subscriptions($subscriptionsKeys);
        $data = $this->safe_dict($message, 'data');
        $marketId = $this->safe_string($data, 's');
        $timestamp = $this->safe_integer($data, 'T');
        $market = $this->safe_market($marketId, null, null, $marketType);
        $symbol = $market['symbol'];
        if (!(is_array($this->orderbooks) && array_key_exists($symbol, $this->orderbooks))) {
            $this->orderbooks[$symbol] = $this->order_book();
        }
        $orderbook = $this->orderbooks[$symbol];
        $snapshot = $this->parse_order_book($data, $symbol, $timestamp, 'b', 'a');
        $orderbook->reset ($snapshot);
        $messageHash = 'orderbook' . ':' . $symbol;
        $this->orderbooks[$symbol] = $orderbook;
        $client->resolve ($orderbook, $messageHash);
    }

    public function watch_ohlcv(string $symbol, $timeframe = '1m', ?int $since = null, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $timeframe, $since, $limit, $params) {
            /**
             * watches historical candlestick data containing the open, high, low, and close price, and the volume of a market
             *
             * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-spot-api.md#k-line-streams
             * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-futures-api.md#klinecandlestick-streams
             *
             * @param {string} $symbol unified $symbol of the market to fetch OHLCV data for
             * @param {string} $timeframe the length of time each candle represents
             * @param {int} [$since] timestamp in ms of the earliest candle to fetch
             * @param {int} [$limit] the maximum amount of candles to fetch
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {int[][]} A list of candles ordered, open, high, low, close, volume
             */
            $params['callerMethodName'] = 'watchOHLCV';
            Async\await($this->load_markets());
            $symbol = $this->safe_symbol($symbol);
            $result = Async\await($this->watch_ohlcv_for_symbols(array( array( $symbol, $timeframe ) ), $since, $limit, $params));
            return $result[$symbol][$timeframe];
        }) ();
    }

    public function un_watch_ohlcv(string $symbol, $timeframe = '1m', $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $timeframe, $params) {
            /**
             * unWatches historical candlestick data containing the open, high, low, and close price, and the volume of a market
             *
             * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-spot-api.md#k-line-streams
             * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-futures-api.md#klinecandlestick-streams
             *
             * @param {string} $symbol unified $symbol of the market to fetch OHLCV data for
             * @param {string} $timeframe the length of time each candle represents
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {int[][]} A list of candles ordered, open, high, low, close, volume
             */
            $params['callerMethodName'] = 'unWatchOHLCV';
            return Async\await($this->un_watch_ohlcv_for_symbols(array( array( $symbol, $timeframe ) ), $params));
        }) ();
    }

    public function watch_ohlcv_for_symbols(array $symbolsAndTimeframes, ?int $since = null, ?int $limit = null, $params = array ()) {
        return Async\async(function () use ($symbolsAndTimeframes, $since, $limit, $params) {
            /**
             * watches historical candlestick $data containing the open, high, low, and close price, and the volume of a $market
             *
             * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-spot-api.md#k-line-streams
             * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-futures-api.md#klinecandlestick-streams
             *
             * @param {string[][]} $symbolsAndTimeframes array of arrays containing unified $symbols and timeframes to fetch OHLCV $data for, example [['BTC/USDT', '1m'], ['LTC/USDT', '5m']]
             * @param {int} [$since] timestamp in ms of the earliest candle to fetch
             * @param {int} [$limit] the maximum amount of candles to fetch
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} A list of candles ordered, open, high, low, close, volume
             */
            Async\await($this->load_markets());
            $symbolsLength = count($symbolsAndTimeframes);
            $methodName = null;
            list($methodName, $params) = $this->handle_param_string($params, 'callerMethodName', 'watchOHLCVForSymbols');
            $params = $this->omit($params, 'callerMethodName');
            if ($symbolsLength === 0) {
                throw new ArgumentsRequired($this->id . ' ' . $methodName . '() requires a non-empty array of symbols');
            }
            $symbols = $this->get_list_from_object_values($symbolsAndTimeframes, 0);
            $marketSymbols = $this->market_symbols($symbols, null, false, true, true);
            $firstMarket = $this->market($marketSymbols[0]);
            $type = $this->safe_string($firstMarket, 'type', 'swap');
            $url = $this->urls['api']['ws']['public'][$type];
            $subscriptionArgs = array();
            $messageHashes = array();
            $request = array(
                'method' => 'SUBSCRIBE',
                'params' => $subscriptionArgs,
            );
            for ($i = 0; $i < count($symbolsAndTimeframes); $i++) {
                $data = $symbolsAndTimeframes[$i];
                $symbolString = $this->safe_string($data, 0);
                $market = $this->market($symbolString);
                $symbolString = $market['symbol'];
                $unfiedTimeframe = $this->safe_string($data, 1);
                $timeframeId = $this->safe_string($this->timeframes, $unfiedTimeframe, $unfiedTimeframe);
                $subscriptionArgs[] = $this->safe_string_lower($market, 'id') . '@kline_' . $timeframeId;
                $messageHashes[] = 'ohlcv:' . $market['symbol'] . ':' . $unfiedTimeframe;
            }
            list($symbol, $timeframe, $stored) = Async\await($this->watch_multiple($url, $messageHashes, $this->extend($request, $params), array( $type )));
            if ($this->newUpdates) {
                $limit = $stored->getLimit ($symbol, $limit);
            }
            $filtered = $this->filter_by_since_limit($stored, $since, $limit, 0, true);
            return $this->create_ohlcv_object($symbol, $timeframe, $filtered);
        }) ();
    }

    public function un_watch_ohlcv_for_symbols(array $symbolsAndTimeframes, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbolsAndTimeframes, $params) {
            /**
             * unWatches historical candlestick $data containing the open, high, low, and close price, and the volume of a $market
             *
             * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-spot-api.md#k-line-streams
             * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-futures-api.md#klinecandlestick-streams
             *
             * @param {string[][]} $symbolsAndTimeframes array of arrays containing unified $symbols and timeframes to fetch OHLCV $data for, example [['BTC/USDT', '1m'], ['LTC/USDT', '5m']]
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {int[][]} A list of candles ordered, open, high, low, close, volume
             */
            Async\await($this->load_markets());
            $symbolsLength = count($symbolsAndTimeframes);
            $methodName = null;
            list($methodName, $params) = $this->handle_param_string($params, 'callerMethodName', 'unWatchOHLCVForSymbols');
            $params = $this->omit($params, 'callerMethodName');
            if ($symbolsLength === 0) {
                throw new ArgumentsRequired($this->id . ' ' . $methodName . '() requires a non-empty array of symbols');
            }
            $symbols = $this->get_list_from_object_values($symbolsAndTimeframes, 0);
            $marketSymbols = $this->market_symbols($symbols, null, false, true, true);
            $firstMarket = $this->market($marketSymbols[0]);
            $type = $this->safe_string($firstMarket, 'type', 'swap');
            $url = $this->urls['api']['ws']['public'][$type];
            $subscriptionArgs = array();
            $messageHashes = array();
            $request = array(
                'method' => 'UNSUBSCRIBE',
                'params' => $subscriptionArgs,
            );
            for ($i = 0; $i < count($symbolsAndTimeframes); $i++) {
                $data = $symbolsAndTimeframes[$i];
                $symbolString = $this->safe_string($data, 0);
                $market = $this->market($symbolString);
                $symbolString = $market['symbol'];
                $unfiedTimeframe = $this->safe_string($data, 1);
                $timeframeId = $this->safe_string($this->timeframes, $unfiedTimeframe, $unfiedTimeframe);
                $subscriptionArgs[] = $this->safe_string_lower($market, 'id') . '@kline_' . $timeframeId;
                $messageHashes[] = 'unsubscribe:ohlcv:' . $market['symbol'] . ':' . $unfiedTimeframe;
            }
            return Async\await($this->watch_multiple($url, $messageHashes, $this->extend($request, $params), array( $type )));
        }) ();
    }

    public function handle_ohlcv(Client $client, $message) {
        //
        //     {
        //         "stream" => "btcusdt@kline_1m",
        //         "data" => {
        //             "e" => "kline",
        //             "E" => 1754655777119,
        //             "s" => "BTCUSDT",
        //             "k" => {
        //                 "t" => 1754655720000,
        //                 "T" => 1754655779999,
        //                 "s" => "BTCUSDT",
        //                 "i" => "1m",
        //                 "f" => 26032629,
        //                 "L" => 26032629,
        //                 "o" => "116546.9",
        //                 "c" => "116546.9",
        //                 "h" => "116546.9",
        //                 "l" => "116546.9",
        //                 "v" => "0.011",
        //                 "n" => 1,
        //                 "x" => false,
        //                 "q" => "1282.0159",
        //                 "V" => "0.000",
        //                 "Q" => "0.0000",
        //                 "B" => "0"
        //             }
        //         }
        //     }
        //
        $subscriptions = $client->subscriptions;
        $subscriptionsKeys = is_array($subscriptions) ? array_keys($subscriptions) : array();
        $marketType = $this->get_account_type_from_subscriptions($subscriptionsKeys);
        $data = $this->safe_dict($message, 'data');
        $marketId = $this->safe_string($data, 's');
        $market = $this->safe_market($marketId, null, null, $marketType);
        $symbol = $market['symbol'];
        $kline = $this->safe_dict($data, 'k');
        $timeframeId = $this->safe_string($kline, 'i');
        $timeframe = $this->find_timeframe($timeframeId);
        $ohlcvsByTimeframe = $this->safe_value($this->ohlcvs, $symbol);
        if ($ohlcvsByTimeframe === null) {
            $this->ohlcvs[$symbol] = array();
        }
        if ($this->safe_value($ohlcvsByTimeframe, $timeframe) === null) {
            $limit = $this->safe_integer($this->options, 'OHLCVLimit', 1000);
            $this->ohlcvs[$symbol][$timeframe] = new ArrayCacheByTimestamp ($limit);
        }
        $stored = $this->ohlcvs[$symbol][$timeframe];
        $parsed = $this->parse_ws_ohlcv($kline);
        $stored->append ($parsed);
        $messageHash = 'ohlcv:' . $symbol . ':' . $timeframe;
        $resolveData = array( $symbol, $timeframe, $stored );
        $client->resolve ($resolveData, $messageHash);
    }

    public function parse_ws_ohlcv($ohlcv, $market = null): array {
        return array(
            $this->safe_integer($ohlcv, 't'),
            $this->safe_number($ohlcv, 'o'),
            $this->safe_number($ohlcv, 'h'),
            $this->safe_number($ohlcv, 'l'),
            $this->safe_number($ohlcv, 'c'),
            $this->safe_number($ohlcv, 'v'),
        );
    }

    public function authenticate($type = 'spot', $params = array ()) {
        return Async\async(function () use ($type, $params) {
            $time = $this->milliseconds();
            $lastAuthenticatedTimeOptions = $this->safe_dict($this->options, 'lastAuthenticatedTime', array());
            $lastAuthenticatedTime = $this->safe_integer($lastAuthenticatedTimeOptions, $type, 0);
            $listenKeyRefreshRateOptions = $this->safe_dict($this->options, 'listenKeyRefreshRate', array());
            $listenKeyRefreshRate = $this->safe_integer($listenKeyRefreshRateOptions, $type, 3600000); // 1 hour
            if ($time - $lastAuthenticatedTime > $listenKeyRefreshRate) {
                $response = null;
                if ($type === 'spot') {
                    $response = Async\await($this->sapiPrivatePostV1ListenKey ($params));
                } else {
                    $response = Async\await($this->fapiPrivatePostV1ListenKey ($params));
                }
                $this->options['listenKey'][$type] = $this->safe_string($response, 'listenKey');
                $this->options['lastAuthenticatedTime'][$type] = $time;
                $params = $this->extend(array( 'type' => $type ), $params);
                $this->delay($listenKeyRefreshRate, array($this, 'keep_alive_listen_key'), $params);
            }
        }) ();
    }

    public function keep_alive_listen_key($params = array ()) {
        return Async\async(function () use ($params) {
            $type = $this->safe_string($params, 'type', 'spot');
            $listenKeyOptions = $this->safe_dict($this->options, 'listenKey', array());
            $listenKey = $this->safe_string($listenKeyOptions, $type);
            if ($listenKey === null) {
                return;
            }
            try {
                Async\await($this->sapiPrivatePutV1ListenKey ()); // extend the expiry
            } catch (Exception $error) {
                $url = $this->urls['api']['ws']['private'][$type] . '/' . $listenKey;
                $client = $this->client($url);
                $messageHashes = is_array($client->futures) ? array_keys($client->futures) : array();
                for ($i = 0; $i < count($messageHashes); $i++) {
                    $messageHash = $messageHashes[$i];
                    $client->reject ($error, $messageHash);
                }
                $this->options['listenKey'][$type] = null;
                $this->options['lastAuthenticatedTime'][$type] = 0;
                return;
            }
            // whether or not to schedule another $listenKey keepAlive request
            $listenKeyRefreshOptions = $this->safe_dict($this->options, 'listenKeyRefresh', array());
            $listenKeyRefreshRate = $this->safe_integer($listenKeyRefreshOptions, 'listenKeyRefreshRate', 3600000);
            $this->delay($listenKeyRefreshRate, array($this, 'keep_alive_listen_key'), $params);
        }) ();
    }

    public function get_private_url($type = 'spot') {
        $listenKeyOptions = $this->safe_dict($this->options, 'listenKey', array());
        $listenKey = $this->safe_string($listenKeyOptions, $type);
        $url = $this->urls['api']['ws']['private'][$type] . '/' . $listenKey;
        return $url;
    }

    public function watch_balance($params = array ()): PromiseInterface {
        return Async\async(function () use ($params) {
            /**
             * query for balance and get the amount of funds available for trading or funds locked in orders
             *
             * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-spot-api.md#payload-account_update
             * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-futures-api.md#event-balance-and-position-update
             *
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @param {string} [$params->type] 'spot' or 'swap', default is 'spot'
             * @return {array} a ~@link https://docs.ccxt.com/?id=balance-structure balance structure~
             */
            Async\await($this->load_markets());
            $type = null;
            list($type, $params) = $this->handle_market_type_and_params('watchBalance', null, $params, $type);
            Async\await($this->authenticate($type, $params));
            $url = $this->get_private_url($type);
            $client = $this->client($url);
            $this->set_balance_cache($client, $type);
            $options = $this->safe_dict($this->options, 'watchBalance');
            $fetchBalanceSnapshot = $this->safe_bool($options, 'fetchBalanceSnapshot', false);
            $awaitBalanceSnapshot = $this->safe_bool($options, 'awaitBalanceSnapshot', true);
            if ($fetchBalanceSnapshot && $awaitBalanceSnapshot) {
                Async\await($client->future ($type . ':fetchBalanceSnapshot'));
            }
            $messageHash = $type . ':balance';
            $message = null;
            return Async\await($this->watch($url, $messageHash, $message, $type));
        }) ();
    }

    public function set_balance_cache(Client $client, $type) {
        if ((is_array($client->subscriptions) && array_key_exists($type, $client->subscriptions)) && (is_array($this->balance) && array_key_exists($type, $this->balance))) {
            return;
        }
        $options = $this->safe_value($this->options, 'watchBalance');
        $fetchBalanceSnapshot = $this->safe_bool($options, 'fetchBalanceSnapshot', false);
        if ($fetchBalanceSnapshot) {
            $messageHash = $type . ':fetchBalanceSnapshot';
            if (!(is_array($client->futures) && array_key_exists($messageHash, $client->futures))) {
                $client->future ($messageHash);
                $this->spawn(array($this, 'load_balance_snapshot'), $client, $messageHash, $type);
            }
        } else {
            $this->balance[$type] = array();
        }
    }

    public function load_balance_snapshot($client, $messageHash, $type) {
        return Async\async(function () use ($client, $messageHash, $type) {
            $params = array(
                'type' => $type,
            );
            $response = Async\await($this->fetch_balance($params));
            $this->balance[$type] = $this->extend($response, $this->safe_value($this->balance, $type, array()));
            // don't remove the $future from the .futures cache
            if (is_array($client->futures) && array_key_exists($messageHash, $client->futures)) {
                $future = $client->futures[$messageHash];
                $future->resolve ();
                $client->resolve ($this->balance[$type], $type . ':balance');
            }
        }) ();
    }

    public function handle_balance(Client $client, $message) {
        //
        // spot balance update
        //     {
        //         "B" => array(
        //             array(
        //                 "a" => "USDT",
        //                 "f" => "16.29445191",
        //                 "l" => "0"
        //             ),
        //             {
        //                 "a" => "ETH",
        //                 "f" => "0.00199920",
        //                 "l" => "0"
        //             }
        //         ),
        //         "e" => "outboundAccountPosition",
        //         "T" => 1768547778317,
        //         "u" => 1768547778317,
        //         "E" => 1768547778321,
        //         "m" => "ORDER"
        //     }
        //
        // swap balance and position update
        //     {
        //         "e" => "ACCOUNT_UPDATE",
        //         "T" => 1768551627708,
        //         "E" => 1768551627710,
        //         "a" => {
        //             "B" => array(
        //                 {
        //                     "a" => "USDT",
        //                     "wb" => "39.41184271",
        //                     "cw" => "39.41184271",
        //                     "bc" => "0"
        //                 }
        //             ),
        //             "P" => array(
        //                 {
        //                     "s" => "ETHUSDT",
        //                     "pa" => "0",
        //                     "ep" => "0.00000000",
        //                     "cr" => "-0.59070000",
        //                     "up" => "0",
        //                     "mt" => "isolated",
        //                     "iw" => "0",
        //                     "ps" => "BOTH",
        //                     "ma" => "USDT"
        //                 }
        //             ),
        //             "m" => "ORDER"
        //         }
        //     }
        //
        $subscriptions = $client->subscriptions;
        $subscriptionsKeys = is_array($subscriptions) ? array_keys($subscriptions) : array();
        $accountType = $this->get_account_type_from_subscriptions($subscriptionsKeys);
        $messageHash = $accountType . ':balance';
        if ($this->balance[$accountType] === null) {
            $this->balance[$accountType] = array();
        }
        $this->balance[$accountType]['info'] = $message;
        $message = $this->safe_dict($message, 'a', $message);
        $B = $this->safe_list($message, 'B', array());
        $wallet = $this->safe_string($this->options, 'wallet', 'wb');
        for ($i = 0; $i < count($B); $i++) {
            $entry = $B[$i];
            $currencyId = $this->safe_string($entry, 'a');
            $code = $this->safe_currency_code($currencyId);
            $account = $this->account();
            $account['free'] = $this->safe_string($entry, 'f');
            $account['used'] = $this->safe_string($entry, 'l');
            $account['total'] = $this->safe_string($entry, $wallet);
            $this->balance[$accountType][$code] = $account;
        }
        $timestamp = $this->safe_integer($message, 'E');
        $this->balance[$accountType]['timestamp'] = $timestamp;
        $this->balance[$accountType]['datetime'] = $this->iso8601($timestamp);
        $this->balance[$accountType] = $this->safe_balance($this->balance[$accountType]);
        $client->resolve ($this->balance[$accountType], $messageHash);
    }

    public function watch_positions(?array $symbols = null, ?int $since = null, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbols, $since, $limit, $params) {
            /**
             * watch all open positions
             *
             * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-futures-api.md#event-balance-and-position-update
             *
             * @param {string[]|null} $symbols list of unified market $symbols
             * @param {number} [$since] $since timestamp
             * @param {number} [$limit] $limit
             * @param {array} $params extra parameters specific to the exchange API endpoint
             * @return {array[]} a list of {@link https://docs.ccxt.com/en/latest/manual.html#position-structure position structure}
             */
            Async\await($this->load_markets());
            $type = 'swap';
            Async\await($this->authenticate($type, $params));
            $url = $this->get_private_url($type);
            $client = $this->client($url);
            $this->set_positions_cache($client);
            $messageHashes = array();
            $messageHash = 'positions';
            $symbols = $this->market_symbols($symbols, 'swap', true, true);
            if ($symbols === null) {
                $messageHashes[] = $messageHash;
            } else {
                for ($i = 0; $i < count($symbols); $i++) {
                    $symbol = $symbols[$i];
                    $messageHashes[] = $messageHash . '::' . $symbol;
                }
            }
            $fetchPositionsSnapshot = $this->handle_option('watchPositions', 'fetchPositionsSnapshot', true);
            $awaitPositionsSnapshot = $this->handle_option('watchPositions', 'awaitPositionsSnapshot', true);
            $cache = $this->positions;
            if ($fetchPositionsSnapshot && $awaitPositionsSnapshot && $cache === null) {
                $snapshot = Async\await($client->future ('fetchPositionsSnapshot'));
                return $this->filter_by_symbols_since_limit($snapshot, $symbols, $since, $limit, true);
            }
            $newPositions = Async\await($this->watch_multiple($url, $messageHashes, null, array( $type )));
            if ($this->newUpdates) {
                return $newPositions;
            }
            return $this->filter_by_symbols_since_limit($cache, $symbols, $since, $limit, true);
        }) ();
    }

    public function set_positions_cache(Client $client) {
        if ($this->positions !== null) {
            return;
        }
        $fetchPositionsSnapshot = $this->handle_option('watchPositions', 'fetchPositionsSnapshot', false);
        if ($fetchPositionsSnapshot) {
            $messageHash = 'fetchPositionsSnapshot';
            if (!(is_array($client->futures) && array_key_exists($messageHash, $client->futures))) {
                $client->future ($messageHash);
                $this->spawn(array($this, 'load_positions_snapshot'), $client, $messageHash);
            }
        } else {
            $this->positions = new ArrayCacheBySymbolBySide ();
        }
    }

    public function load_positions_snapshot($client, $messageHash) {
        return Async\async(function () use ($client, $messageHash) {
            $positions = Async\await($this->fetch_positions());
            $this->positions = new ArrayCacheBySymbolBySide ();
            $cache = $this->positions;
            for ($i = 0; $i < count($positions); $i++) {
                $position = $positions[$i];
                $contracts = $this->safe_number($position, 'contracts', 0);
                if ($contracts > 0) {
                    $cache->append ($position);
                }
            }
            // don't remove the $future from the .futures $cache
            if (is_array($client->futures) && array_key_exists($messageHash, $client->futures)) {
                $future = $client->futures[$messageHash];
                $future->resolve ($cache);
                $client->resolve ($cache, 'positions');
            }
        }) ();
    }

    public function handle_positions($client, $message) {
        //
        //     {
        //         "e" => "ACCOUNT_UPDATE",
        //         "T" => 1768551627708,
        //         "E" => 1768551627710,
        //         "a" => {
        //             "B" => array(
        //                 {
        //                     "a" => "USDT",
        //                     "wb" => "39.41184271",
        //                     "cw" => "39.41184271",
        //                     "bc" => "0"
        //                 }
        //             ),
        //             "P" => array(
        //                 {
        //                     "s" => "ETHUSDT",
        //                     "pa" => "0",
        //                     "ep" => "0.00000000",
        //                     "cr" => "-0.59070000",
        //                     "up" => "0",
        //                     "mt" => "isolated",
        //                     "iw" => "0",
        //                     "ps" => "BOTH",
        //                     "ma" => "USDT"
        //                 }
        //             ),
        //             "m" => "ORDER"
        //         }
        //     }
        //
        $messageHash = 'positions';
        $messageHashes = $this->find_message_hashes($client, $messageHash);
        if (!$this->is_empty($messageHashes)) {
            if ($this->positions === null) {
                $this->positions = new ArrayCacheBySymbolBySide ();
            }
            $cache = $this->positions;
            $data = $this->safe_dict($message, 'a', array());
            $rawPositions = $this->safe_list($data, 'P', array());
            $newPositions = array();
            for ($i = 0; $i < count($rawPositions); $i++) {
                $rawPosition = $rawPositions[$i];
                $position = $this->parse_ws_position($rawPosition);
                $timestamp = $this->safe_integer($message, 'E');
                $position['timestamp'] = $timestamp;
                $position['datetime'] = $this->iso8601($timestamp);
                $newPositions[] = $position;
                $cache->append ($position);
                $symbol = $position['symbol'];
                $symbolMessageHash = $messageHash . '::' . $symbol;
                $client->resolve ($position, $symbolMessageHash);
            }
            $client->resolve ($newPositions, 'positions');
        }
    }

    public function parse_ws_position($position, $market = null) {
        //
        //     {
        //         "s" => "BTCUSDT", // Symbol
        //         "pa" => "0", // Position Amount
        //         "ep" => "0.00000", // Entry Price
        //         "cr" => "200", // (Pre-fee) Accumulated Realized
        //         "up" => "0", // Unrealized PnL
        //         "mt" => "isolated", // Margin Type
        //         "iw" => "0.00000000", // Isolated Wallet (if isolated $position)
        //         "ps" => "BOTH" // Position Side
        //     }
        //
        $marketId = $this->safe_string($position, 's');
        $contracts = $this->safe_string($position, 'pa');
        $contractsAbs = Precise::string_abs($this->safe_string($position, 'pa'));
        $positionSide = $this->safe_string_lower($position, 'ps');
        $hedged = true;
        if ($positionSide === 'both') {
            $hedged = false;
            if (!Precise::string_eq($contracts, '0')) {
                if (Precise::string_lt($contracts, '0')) {
                    $positionSide = 'short';
                } else {
                    $positionSide = 'long';
                }
            }
        }
        return $this->safe_position(array(
            'info' => $position,
            'id' => null,
            'symbol' => $this->safe_symbol($marketId, null, null, 'swap'),
            'notional' => null,
            'marginMode' => $this->safe_string($position, 'mt'),
            'liquidationPrice' => null,
            'entryPrice' => $this->safe_number($position, 'ep'),
            'unrealizedPnl' => $this->safe_number($position, 'up'),
            'percentage' => null,
            'contracts' => $this->parse_number($contractsAbs),
            'contractSize' => null,
            'markPrice' => null,
            'side' => $positionSide,
            'hedged' => $hedged,
            'timestamp' => null,
            'datetime' => null,
            'maintenanceMargin' => null,
            'maintenanceMarginPercentage' => null,
            'collateral' => null,
            'initialMargin' => null,
            'initialMarginPercentage' => null,
            'leverage' => null,
            'marginRatio' => null,
        ));
    }

    public function watch_orders(?string $symbol = null, ?int $since = null, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            /**
             * watches information on multiple $orders made by the user
             *
             * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-spot-api.md#payload-order-update
             * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-futures-api.md#event-order-update
             *
             * @param {string} [$symbol] unified $market $symbol of the $market $orders were made in
             * @param {int} [$since] the earliest time in ms to fetch $orders for
             * @param {int} [$limit] the maximum number of order structures to retrieve
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @param {string} [$params->type] 'spot' or 'swap', default is 'spot' if $symbol is not provided
             * @return {array[]} a list of ~@link https://docs.ccxt.com/?id=order-structure order structures~
             */
            Async\await($this->load_markets());
            $market = null;
            if ($symbol !== null) {
                $market = $this->market($symbol);
                $symbol = $market['symbol'];
            }
            $messageHash = 'orders';
            $type = null;
            list($type, $params) = $this->handle_market_type_and_params('watchOrders', $market, $params, $type);
            Async\await($this->authenticate($type, $params));
            if ($market !== null) {
                $messageHash .= '::' . $symbol;
            }
            $url = $this->get_private_url($type);
            $client = $this->client($url);
            $this->set_balance_cache($client, $type);
            $orders = Async\await($this->watch_multiple($url, array( $messageHash ), null, array( $type )));
            if ($this->newUpdates) {
                $limit = $orders->getLimit ($symbol, $limit);
            }
            return $this->filter_by_symbol_since_limit($orders, $symbol, $since, $limit, true);
        }) ();
    }

    public function watch_my_trades(?string $symbol = null, ?int $since = null, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            /**
             * watches information on multiple $trades made by the user
             *
             * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-spot-api.md#payload-order-update
             * @see https://github.com/asterdex/api-docs/blob/master/aster-finance-futures-api.md#event-order-update
             *
             * @param {string} [$symbol] unified $market $symbol of the $market orders were made in
             * @param {int} [$since] the earliest time in ms to fetch orders for
             * @param {int} [$limit] the maximum number of order structures to retrieve
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @param {string} [$params->type] 'spot' or 'swap', default is 'spot' if $symbol is not provided
             * @return {array[]} a list of ~@link https://docs.ccxt.com/?id=trade-structure trade structures~
             */
            Async\await($this->load_markets());
            $market = null;
            if ($symbol !== null) {
                $market = $this->market($symbol);
                $symbol = $market['symbol'];
            }
            $messageHash = 'myTrades';
            $type = null;
            list($type, $params) = $this->handle_market_type_and_params('watchOrders', $market, $params, $type);
            Async\await($this->authenticate($type, $params));
            if ($market !== null) {
                $messageHash .= '::' . $symbol;
            }
            $url = $this->get_private_url($type);
            $client = $this->client($url);
            $this->set_balance_cache($client, $type);
            $trades = Async\await($this->watch_multiple($url, array( $messageHash ), null, array( $type )));
            if ($this->newUpdates) {
                $limit = $trades->getLimit ($symbol, $limit);
            }
            return $this->filter_by_symbol_since_limit($trades, $symbol, $since, $limit, true);
        }) ();
    }

    public function handle_order_update(Client $client, $message) {
        $rawOrder = $this->safe_dict($message, 'o', $message);
        $e = $this->safe_string($message, 'e');
        if (($e === 'ORDER_TRADE_UPDATE') || ($e === 'ALGO_UPDATE')) {
            $message = $this->safe_dict($message, 'o', $message);
        }
        $this->handle_order($client, $rawOrder);
        $this->handle_my_trade($client, $message);
    }

    public function handle_my_trade(Client $client, $message) {
        $messageHash = 'myTrades';
        $executionType = $this->safe_string($message, 'x');
        if ($executionType === 'TRADE') {
            $isSwap = mb_strpos($client->url, 'fstream') !== false;
            $type = $isSwap ? 'swap' : 'spot';
            $fakeMarket = $this->safe_market_structure(array( 'type' => $type ));
            $trade = $this->parse_ws_trade($message, $fakeMarket);
            $orderId = $this->safe_string($trade, 'order');
            $tradeFee = $this->safe_dict($trade, 'fee', array());
            $tradeFee = $this->extend(array(), $tradeFee);
            $symbol = $this->safe_string($trade, 'symbol');
            if ($orderId !== null && $tradeFee !== null && $symbol !== null) {
                $cachedOrders = $this->orders;
                if ($cachedOrders !== null) {
                    $orders = $this->safe_value($cachedOrders->hashmap, $symbol, array());
                    $order = $this->safe_value($orders, $orderId);
                    if ($order !== null) {
                        // accumulate $order $fees
                        $fees = $this->safe_value($order, 'fees');
                        $fee = $this->safe_value($order, 'fee');
                        if (!$this->is_empty($fees)) {
                            $insertNewFeeCurrency = true;
                            for ($i = 0; $i < count($fees); $i++) {
                                $orderFee = $fees[$i];
                                if ($orderFee['currency'] === $tradeFee['currency']) {
                                    $feeCost = $this->sum($tradeFee['cost'], $orderFee['cost']);
                                    $order['fees'][$i]['cost'] = floatval($this->currency_to_precision($tradeFee['currency'], $feeCost));
                                    $insertNewFeeCurrency = false;
                                    break;
                                }
                            }
                            if ($insertNewFeeCurrency) {
                                $order['fees'][] = $tradeFee;
                            }
                        } elseif ($fee !== null) {
                            if ($fee['currency'] === $tradeFee['currency']) {
                                $feeCost = $this->sum($fee['cost'], $tradeFee['cost']);
                                $order['fee']['cost'] = floatval($this->currency_to_precision($tradeFee['currency'], $feeCost));
                            } elseif ($fee['currency'] === null) {
                                $order['fee'] = $tradeFee;
                            } else {
                                $order['fees'] = array( $fee, $tradeFee );
                                $order['fee'] = null;
                            }
                        } else {
                            $order['fee'] = $tradeFee;
                        }
                        // save this $trade in the $order
                        $orderTrades = $this->safe_list($order, 'trades', array());
                        $orderTrades[] = $trade;
                        $order['trades'] = $orderTrades;
                        // don't append twice cause it breaks newUpdates mode
                        // this $order already exists in the cache
                    }
                }
            }
            if ($this->myTrades === null) {
                $limit = $this->safe_integer($this->options, 'tradesLimit', 1000);
                $this->myTrades = new ArrayCacheBySymbolById ($limit);
            }
            $myTrades = $this->myTrades;
            $myTrades->append ($trade);
            $client->resolve ($this->myTrades, $messageHash);
            $messageHashSymbol = $messageHash . ':' . $symbol;
            $client->resolve ($this->myTrades, $messageHashSymbol);
        }
    }

    public function handle_order(Client $client, $message) {
        //
        // spot
        //     {
        //         "e" => "executionReport",        // Event type
        //         "E" => 1499405658658,            // Event time
        //         "s" => "ETHBTC",                 // Symbol
        //         "c" => "mUvoqJxFIILMdfAW5iGSOW", // Client order ID
        //         "S" => "BUY",                    // Side
        //         "o" => "LIMIT",                  // Order type
        //         "f" => "GTC",                    // Time in force
        //         "q" => "1.00000000",             // Order quantity
        //         "p" => "0.10264410",             // Order price
        //         "P" => "0.00000000",             // Stop price
        //         "F" => "0.00000000",             // Iceberg quantity
        //         "g" => -1,                       // OrderListId
        //         "C" => null,                     // Original $client order ID; This is the ID of the order being canceled
        //         "x" => "NEW",                    // Current execution type
        //         "X" => "NEW",                    // Current order status
        //         "r" => "NONE",                   // Order reject reason; will be an error code.
        //         "i" => 4293153,                  // Order ID
        //         "l" => "0.00000000",             // Last executed quantity
        //         "z" => "0.00000000",             // Cumulative filled quantity
        //         "L" => "0.00000000",             // Last executed price
        //         "n" => "0",                      // Commission amount
        //         "N" => null,                     // Commission asset
        //         "T" => 1499405658657,            // Transaction time
        //         "t" => -1,                       // Trade ID
        //         "I" => 8641984,                  // Ignore
        //         "w" => true,                     // Is the order on the book?
        //         "m" => false,                    // Is this trade the maker side?
        //         "M" => false,                    // Ignore
        //         "O" => 1499405658657,            // Order creation time
        //         "Z" => "0.00000000",             // Cumulative quote asset transacted quantity
        //         "Y" => "0.00000000"              // Last quote asset transacted quantity (i.e. lastPrice * lastQty),
        //         "Q" => "0.00000000"              // Quote Order Qty
        //     }
        //
        // swap
        //     {
        //         "s":"BTCUSDT",                 // Symbol
        //         "c":"TEST",                    // Client Order Id
        //                                        // special $client order id:
        //                                        // starts with "autoclose-" => liquidation order
        //                                        // "adl_autoclose" => ADL auto close order
        //         "S":"SELL",                    // Side
        //         "o":"TRAILING_STOP_MARKET",    // Order Type
        //         "f":"GTC",                     // Time in Force
        //         "q":"0.001",                   // Original Quantity
        //         "p":"0",                       // Original Price
        //         "ap":"0",                      // Average Price
        //         "sp":"7103.04",                // Stop Price. Please ignore with TRAILING_STOP_MARKET order
        //         "x":"NEW",                     // Execution Type
        //         "X":"NEW",                     // Order Status
        //         "i":8886774,                   // Order Id
        //         "l":"0",                       // Order Last Filled Quantity
        //         "z":"0",                       // Order Filled Accumulated Quantity
        //         "L":"0",                       // Last Filled Price
        //         "N":"USDT",                    // Commission Asset, will not push if no commission
        //         "n":"0",                       // Commission, will not push if no commission
        //         "T":1568879465651,             // Order Trade Time
        //         "t":0,                         // Trade Id
        //         "b":"0",                       // Bids Notional
        //         "a":"9.91",                    // Ask Notional
        //         "m":false,                     // Is this trade the maker side?
        //         "R":false,                     // Is this reduce only
        //         "wt":"CONTRACT_PRICE",         // Stop Price Working Type
        //         "ot":"TRAILING_STOP_MARKET",   // Original Order Type
        //         "ps":"LONG",                   // Position Side
        //         "cp":false,                    // If Close-All, pushed with conditional order
        //         "AP":"7476.89",                // Activation Price, only puhed with TRAILING_STOP_MARKET order
        //         "cr":"5.0",                    // Callback Rate, only puhed with TRAILING_STOP_MARKET order
        //         "rp":"0"                       // Realized Profit of the trade
        //     }
        //
        $messageHash = 'orders';
        $messageHashes = $this->find_message_hashes($client, $messageHash);
        if (!$this->is_empty($messageHashes)) {
            $market = $this->get_market_from_order($client, $message);
            if ($this->orders === null) {
                $limit = $this->safe_integer($this->options, 'ordersLimit', 1000);
                $this->orders = new ArrayCacheBySymbolById ($limit);
            }
            $cache = $this->orders;
            $parsed = $this->parse_ws_order($message, $market);
            $symbol = $market['symbol'];
            $symbolMessageHash = $messageHash . '::' . $symbol;
            $cache->append ($parsed);
            $client->resolve ($cache, $symbolMessageHash);
            $client->resolve ($cache, $messageHash);
        }
    }

    public function parse_ws_order($order, $market = null) {
        $executionType = $this->safe_string($order, 'x');
        $marketId = $this->safe_string($order, 's');
        $market = $this->safe_market($marketId, $market);
        $timestamp = $this->safe_integer($order, 'O');
        $T = $this->safe_integer($order, 'T');
        $lastTradeTimestamp = null;
        if ($executionType === 'NEW' || $executionType === 'AMENDMENT' || $executionType === 'CANCELED') {
            if ($timestamp === null) {
                $timestamp = $T;
            }
        } elseif ($executionType === 'TRADE') {
            $lastTradeTimestamp = $T;
        }
        $lastUpdateTimestamp = $T;
        $fee = null;
        $feeCost = $this->safe_string($order, 'n');
        if (($feeCost !== null) && (Precise::string_gt($feeCost, '0'))) {
            $feeCurrencyId = $this->safe_string($order, 'N');
            $feeCurrency = $this->safe_currency_code($feeCurrencyId);
            $fee = array(
                'cost' => $feeCost,
                'currency' => $feeCurrency,
            );
        }
        $rawStatus = $this->safe_string($order, 'X');
        $status = $this->parse_order_status($rawStatus);
        $clientOrderId = $this->safe_string_2($order, 'C', 'caid');
        if (($clientOrderId === null) || (strlen($clientOrderId) === 0)) {
            $clientOrderId = $this->safe_string($order, 'c');
        }
        $stopPrice = $this->safe_string_n($order, array( 'P', 'sp', 'tp' ));
        $timeInForce = $this->safe_string($order, 'f');
        if ($timeInForce === 'GTX') {
            // GTX means "Good Till Crossing" and is an equivalent way of saying Post Only
            $timeInForce = 'PO';
        }
        return $this->safe_order(array(
            'info' => $order,
            'symbol' => $market['symbol'],
            'id' => $this->safe_string_2($order, 'i', 'aid'),
            'clientOrderId' => $clientOrderId,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'lastTradeTimestamp' => $lastTradeTimestamp,
            'lastUpdateTimestamp' => $lastUpdateTimestamp,
            'type' => $this->parseOrderType ($this->safe_string_lower($order, 'o')),
            'timeInForce' => $timeInForce,
            'postOnly' => null,
            'reduceOnly' => $this->safe_bool($order, 'R'),
            'side' => $this->safe_string_lower($order, 'S'),
            'price' => $this->safe_string($order, 'p'),
            'stopPrice' => $stopPrice,
            'triggerPrice' => $stopPrice,
            'amount' => $this->safe_string($order, 'q'),
            'cost' => $this->safe_string($order, 'Z'),
            'average' => $this->safe_string($order, 'ap'),
            'filled' => $this->safe_string($order, 'z'),
            'remaining' => null,
            'status' => $status,
            'fee' => $fee,
            'trades' => null,
        ));
    }

    public function get_market_from_order(Client $client, $order) {
        $marketId = $this->safe_string($order, 's');
        $subscriptions = $client->subscriptions;
        $subscriptionsKeys = is_array($subscriptions) ? array_keys($subscriptions) : array();
        $marketType = $this->get_account_type_from_subscriptions($subscriptionsKeys);
        return $this->safe_market($marketId, null, null, $marketType);
    }

    public function handle_message(Client $client, $message) {
        $stream = $this->safe_string($message, 'stream');
        if ($stream !== null) {
            $part = explode('@', $stream);
            $topic = $this->safe_string($part, 1, '');
            $part2 = explode('_', $topic);
            $topic = $this->safe_string($part2, 0, '');
            $methods = array(
                'ticker' => array($this, 'handle_ticker'),
                'aggTrade' => array($this, 'handle_trade'),
                'depth5' => array($this, 'handle_order_book'),
                'depth10' => array($this, 'handle_order_book'),
                'depth20' => array($this, 'handle_order_book'),
                'kline' => array($this, 'handle_ohlcv'),
                'markPrice' => array($this, 'handle_ticker'),
                'bookTicker' => array($this, 'handle_bid_ask'),
            );
            $method = $this->safe_value($methods, $topic);
            if ($method !== null) {
                $method($client, $message);
            }
        } else {
            // private messages
            $event = $this->safe_string($message, 'e');
            if ($event === 'outboundAccountPosition') {
                $this->handle_balance($client, $message);
            } elseif ($event === 'ACCOUNT_UPDATE') {
                $this->handle_balance($client, $message);
                $this->handle_positions($client, $message);
            } elseif (($event === 'ORDER_TRADE_UPDATE') || ($event === 'executionReport')) {
                $this->handle_order_update($client, $message);
            }
        }
    }
}
