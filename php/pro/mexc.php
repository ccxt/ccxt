<?php

namespace ccxt\pro;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

use Exception; // a common import
use ccxt\ExchangeError;
use ccxt\AuthenticationError;
use React\Async;
use React\Promise\PromiseInterface;

class mexc extends \ccxt\async\mexc {

    public function describe() {
        return $this->deep_extend(parent::describe(), array(
            'has' => array(
                'ws' => true,
                'cancelAllOrdersWs' => false,
                'cancelOrdersWs' => false,
                'cancelOrderWs' => false,
                'createOrderWs' => false,
                'editOrderWs' => false,
                'fetchBalanceWs' => false,
                'fetchOpenOrdersWs' => false,
                'fetchOrderWs' => false,
                'fetchTradesWs' => false,
                'watchBalance' => true,
                'watchMyTrades' => true,
                'watchOHLCV' => true,
                'watchOrderBook' => true,
                'watchOrders' => true,
                'watchTicker' => true,
                'watchTickers' => false,
                'watchTrades' => true,
            ),
            'urls' => array(
                'api' => array(
                    'ws' => array(
                        'spot' => 'wss://wbs.mexc.com/ws',
                        'swap' => 'wss://contract.mexc.com/ws',
                    ),
                ),
            ),
            'options' => array(
                'listenKeyRefreshRate' => 1200000,
                // TODO add reset connection after #16754 is merged
                'timeframes' => array(
                    '1m' => 'Min1',
                    '5m' => 'Min5',
                    '15m' => 'Min15',
                    '30m' => 'Min30',
                    '1h' => 'Min60',
                    '4h' => 'Hour4',
                    '8h' => 'Hour8',
                    '1d' => 'Day1',
                    '1w' => 'Week1',
                    '1M' => 'Month1',
                ),
                'watchOrderBook' => array(
                    'snapshotDelay' => 25,
                    'snapshotMaxRetries' => 3,
                ),
                'listenKey' => null,
            ),
            'streaming' => array(
                'ping' => array($this, 'ping'),
                'keepAlive' => 10000,
            ),
            'exceptions' => array(
            ),
        ));
    }

    public function watch_ticker(string $symbol, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $params) {
            /**
             * watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific $market
             * @param {string} $symbol unified $symbol of the $market to fetch the ticker for
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} a ~@link https://docs.ccxt.com/#/?id=ticker-structure ticker structure~
             */
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $messageHash = 'ticker:' . $market['symbol'];
            if ($market['spot']) {
                $channel = 'spot@public.bookTicker.v3.api@' . $market['id'];
                return Async\await($this->watch_spot_public($channel, $messageHash, $params));
            } else {
                $channel = 'sub.ticker';
                $requestParams = array(
                    'symbol' => $market['id'],
                );
                return Async\await($this->watch_swap_public($channel, $messageHash, $requestParams, $params));
            }
        }) ();
    }

    public function handle_ticker(Client $client, $message) {
        //
        //    {
        //        "c" => "spot@public.bookTicker.v3.api@BTCUSDT",
        //        "d" => array(
        //            "A" => "4.70432",
        //            "B" => "6.714863",
        //            "a" => "20744.54",
        //            "b" => "20744.17"
        //        ),
        //        "s" => "BTCUSDT",
        //        "t" => 1678643605721
        //    }
        //
        $rawTicker = $this->safe_value_2($message, 'd', 'data');
        $marketId = $this->safe_string_2($message, 's', 'symbol');
        $timestamp = $this->safe_integer($message, 't');
        $market = $this->safe_market($marketId);
        $symbol = $market['symbol'];
        $ticker = null;
        if ($market['spot']) {
            $ticker = $this->parse_ws_ticker($rawTicker, $market);
            $ticker['timestamp'] = $timestamp;
            $ticker['datetime'] = $this->iso8601($timestamp);
        } else {
            $ticker = $this->parse_ticker($rawTicker, $market);
        }
        $this->tickers[$symbol] = $ticker;
        $messageHash = 'ticker:' . $symbol;
        $client->resolve ($ticker, $messageHash);
    }

    public function parse_ws_ticker($ticker, $market = null) {
        //
        // spot
        //    {
        //        "A" => "4.70432",
        //        "B" => "6.714863",
        //        "a" => "20744.54",
        //        "b" => "20744.17"
        //    }
        //
        return $this->safe_ticker(array(
            'symbol' => $this->safe_symbol(null, $market),
            'timestamp' => null,
            'datetime' => null,
            'open' => null,
            'high' => null,
            'low' => null,
            'close' => null,
            'bid' => $this->safe_number($ticker, 'b'),
            'bidVolume' => $this->safe_number($ticker, 'B'),
            'ask' => $this->safe_number($ticker, 'a'),
            'askVolume' => $this->safe_number($ticker, 'A'),
            'vwap' => null,
            'previousClose' => null,
            'change' => null,
            'percentage' => null,
            'average' => null,
            'baseVolume' => null,
            'quoteVolume' => null,
            'info' => $ticker,
        ), $market);
    }

    public function watch_spot_public($channel, $messageHash, $params = array ()) {
        return Async\async(function () use ($channel, $messageHash, $params) {
            $url = $this->urls['api']['ws']['spot'];
            $request = array(
                'method' => 'SUBSCRIPTION',
                'params' => array( $channel ),
            );
            return Async\await($this->watch($url, $messageHash, array_merge($request, $params), $channel));
        }) ();
    }

    public function watch_spot_private($channel, $messageHash, $params = array ()) {
        return Async\async(function () use ($channel, $messageHash, $params) {
            $this->check_required_credentials();
            $listenKey = Async\await($this->authenticate($channel));
            $url = $this->urls['api']['ws']['spot'] . '?$listenKey=' . $listenKey;
            $request = array(
                'method' => 'SUBSCRIPTION',
                'params' => array( $channel ),
            );
            return Async\await($this->watch($url, $messageHash, array_merge($request, $params), $channel));
        }) ();
    }

    public function watch_swap_public($channel, $messageHash, $requestParams, $params = array ()) {
        return Async\async(function () use ($channel, $messageHash, $requestParams, $params) {
            $url = $this->urls['api']['ws']['swap'];
            $request = array(
                'method' => $channel,
                'param' => $requestParams,
            );
            $message = array_merge($request, $params);
            return Async\await($this->watch($url, $messageHash, $message, $messageHash));
        }) ();
    }

    public function watch_swap_private($messageHash, $params = array ()) {
        return Async\async(function () use ($messageHash, $params) {
            $this->check_required_credentials();
            $channel = 'login';
            $url = $this->urls['api']['ws']['swap'];
            $timestamp = (string) $this->milliseconds();
            $payload = $this->apiKey . $timestamp;
            $signature = $this->hmac($this->encode($payload), $this->encode($this->secret), 'sha256');
            $request = array(
                'method' => $channel,
                'param' => array(
                    'apiKey' => $this->apiKey,
                    'signature' => $signature,
                    'reqTime' => $timestamp,
                ),
            );
            $message = array_merge($request, $params);
            return Async\await($this->watch($url, $messageHash, $message, $channel));
        }) ();
    }

    public function watch_ohlcv(string $symbol, $timeframe = '1m', ?int $since = null, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $timeframe, $since, $limit, $params) {
            /**
             * @see https://mxcdevelop.github.io/apidocs/spot_v3_en/#kline-streams
             * watches historical candlestick data containing the open, high, low, and close price, and the volume of a $market
             * @param {string} $symbol unified $symbol of the $market to fetch OHLCV data for
             * @param {string} $timeframe the length of time each candle represents
             * @param {int} [$since] timestamp in ms of the earliest candle to fetch
             * @param {int} [$limit] the maximum amount of candles to fetch
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {int[][]} A list of candles ordered, open, high, low, close, volume
             */
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $symbol = $market['symbol'];
            $timeframes = $this->safe_value($this->options, 'timeframes', array());
            $timeframeId = $this->safe_string($timeframes, $timeframe);
            $messageHash = 'candles:' . $symbol . ':' . $timeframe;
            $ohlcv = null;
            if ($market['spot']) {
                $channel = 'spot@public.kline.v3.api@' . $market['id'] . '@' . $timeframeId;
                $ohlcv = Async\await($this->watch_spot_public($channel, $messageHash, $params));
            } else {
                $channel = 'sub.kline';
                $requestParams = array(
                    'symbol' => $market['id'],
                    'interval' => $timeframeId,
                );
                $ohlcv = Async\await($this->watch_swap_public($channel, $messageHash, $requestParams, $params));
            }
            if ($this->newUpdates) {
                $limit = $ohlcv->getLimit ($symbol, $limit);
            }
            return $this->filter_by_since_limit($ohlcv, $since, $limit, 0, true);
        }) ();
    }

    public function handle_ohlcv(Client $client, $message) {
        //
        // spot
        //
        //    {
        //        "d" => {
        //            "e" => "spot@public.kline.v3.api",
        //            "k" => array(
        //                "t" => 1678642260,
        //                "o" => 20626.94,
        //                "c" => 20599.69,
        //                "h" => 20626.94,
        //                "l" => 20597.06,
        //                "v" => 27.678686,
        //                "a" => 570332.77,
        //                "T" => 1678642320,
        //                "i" => "Min1"
        //            }
        //        ),
        //        "c" => "spot@public.kline.v3.api@BTCUSDT@Min1",
        //        "t" => 1678642276459,
        //        "s" => "BTCUSDT"
        //    }
        //
        // swap
        //
        //   {
        //       "channel" => "push.kline",
        //       "data" => array(
        //         "a" => 325653.3287,
        //         "c" => 38839,
        //         "h" => 38909.5,
        //         "interval" => "Min1",
        //         "l" => 38833,
        //         "o" => 38901.5,
        //         "q" => 83808,
        //         "rc" => 38839,
        //         "rh" => 38909.5,
        //         "rl" => 38833,
        //         "ro" => 38909.5,
        //         "symbol" => "BTC_USDT",
        //         "t" => 1651230660
        //       ),
        //       "symbol" => "BTC_USDT",
        //       "ts" => 1651230713067
        //   }
        //
        $d = $this->safe_value_2($message, 'd', 'data', array());
        $rawOhlcv = $this->safe_value($d, 'k', $d);
        $timeframeId = $this->safe_string_2($rawOhlcv, 'i', 'interval');
        $timeframes = $this->safe_value($this->options, 'timeframes', array());
        $timeframe = $this->find_timeframe($timeframeId, $timeframes);
        $marketId = $this->safe_string_2($message, 's', 'symbol');
        $market = $this->safe_market($marketId);
        $symbol = $market['symbol'];
        $messageHash = 'candles:' . $symbol . ':' . $timeframe;
        $parsed = $this->parse_ws_ohlcv($rawOhlcv, $market);
        $this->ohlcvs[$symbol] = $this->safe_value($this->ohlcvs, $symbol, array());
        $stored = $this->safe_value($this->ohlcvs[$symbol], $timeframe);
        if ($stored === null) {
            $limit = $this->safe_integer($this->options, 'OHLCVLimit', 1000);
            $stored = new ArrayCacheByTimestamp ($limit);
            $this->ohlcvs[$symbol][$timeframe] = $stored;
        }
        $stored->append ($parsed);
        $client->resolve ($stored, $messageHash);
    }

    public function parse_ws_ohlcv($ohlcv, $market = null): array {
        //
        // spot
        //
        //    {
        //        "t" => 1678642260,
        //        "o" => 20626.94,
        //        "c" => 20599.69,
        //        "h" => 20626.94,
        //        "l" => 20597.06,
        //        "v" => 27.678686,
        //        "a" => 570332.77,
        //        "T" => 1678642320,
        //        "i" => "Min1"
        //    }
        //
        // swap
        //    {
        //       "symbol" => "BTC_USDT",
        //       "interval" => "Min1",
        //       "t" => 1680055080,
        //       "o" => 27301.9,
        //       "c" => 27301.8,
        //       "h" => 27301.9,
        //       "l" => 27301.8,
        //       "a" => 8.19054,
        //       "q" => 3,
        //       "ro" => 27301.8,
        //       "rc" => 27301.8,
        //       "rh" => 27301.8,
        //       "rl" => 27301.8
        //     }
        //
        return array(
            $this->safe_timestamp($ohlcv, 't'),
            $this->safe_number($ohlcv, 'o'),
            $this->safe_number($ohlcv, 'h'),
            $this->safe_number($ohlcv, 'l'),
            $this->safe_number($ohlcv, 'c'),
            $this->safe_number_2($ohlcv, 'v', 'q'),
        );
    }

    public function watch_order_book(string $symbol, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $limit, $params) {
            /**
             * @see https://mxcdevelop.github.io/apidocs/spot_v3_en/#diff-depth-stream
             * watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
             * @param {string} $symbol unified $symbol of the $market to fetch the order book for
             * @param {int} [$limit] the maximum amount of order book entries to return
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} A dictionary of ~@link https://docs.ccxt.com/#/?id=order-book-structure order book structures~ indexed by $market symbols
             */
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $symbol = $market['symbol'];
            $messageHash = 'orderbook:' . $symbol;
            $orderbook = null;
            if ($market['spot']) {
                $channel = 'spot@public.increase.depth.v3.api@' . $market['id'];
                $orderbook = Async\await($this->watch_spot_public($channel, $messageHash, $params));
            } else {
                $channel = 'sub.depth';
                $requestParams = array(
                    'symbol' => $market['id'],
                );
                $orderbook = Async\await($this->watch_swap_public($channel, $messageHash, $requestParams, $params));
            }
            return $orderbook->limit ();
        }) ();
    }

    public function handle_order_book_subscription(Client $client, $message) {
        // spot
        //     array( id => 0, code => 0, $msg => "spot@public.increase.depth.v3.api@BTCUSDT" )
        //
        $msg = $this->safe_string($message, 'msg');
        $parts = explode('@', $msg);
        $marketId = $this->safe_string($parts, 2);
        $symbol = $this->safe_symbol($marketId);
        $this->orderbooks[$symbol] = $this->order_book(array());
    }

    public function get_cache_index($orderbook, $cache) {
        // return the first index of the $cache that can be applied to the $orderbook or -1 if not possible
        $nonce = $this->safe_integer($orderbook, 'nonce');
        $firstDelta = $this->safe_value($cache, 0);
        $firstDeltaNonce = $this->safe_integer_2($firstDelta, 'r', 'version');
        if ($nonce < $firstDeltaNonce - 1) {
            return -1;
        }
        for ($i = 0; $i < count($cache); $i++) {
            $delta = $cache[$i];
            $deltaNonce = $this->safe_integer_2($delta, 'r', 'version');
            if ($deltaNonce >= $nonce) {
                return $i;
            }
        }
        return count($cache);
    }

    public function handle_order_book(Client $client, $message) {
        //
        // spot
        //    {
        //        "c" => "spot@public.increase.depth.v3.api@BTCUSDT",
        //        "d" => array(
        //            "asks" => [array(
        //                "p" => "20290.89",
        //                "v" => "0.000000"
        //            )],
        //            "e" => "spot@public.increase.depth.v3.api",
        //            "r" => "3407459756"
        //        ),
        //        "s" => "BTCUSDT",
        //        "t" => 1661932660144
        //    }
        //
        //
        //
        // swap
        //  {
        //      "channel":"push.depth",
        //      "data":array(
        //         "asks":array(
        //            array(
        //               39146.5,
        //               11264,
        //               1
        //            )
        //         ),
        //         "bids":array(
        //            array(
        //               39144,
        //               35460,
        //               1
        //            )
        //         ),
        //         "end":4895965272,
        //         "begin":4895965271
        //      ),
        //      "symbol":"BTC_USDT",
        //      "ts":1651239652372
        //  }
        //
        $data = $this->safe_value_2($message, 'd', 'data');
        $marketId = $this->safe_string_2($message, 's', 'symbol');
        $symbol = $this->safe_symbol($marketId);
        $messageHash = 'orderbook:' . $symbol;
        $subscription = $this->safe_value($client->subscriptions, $messageHash);
        if ($subscription === true) {
            // we set $client->subscriptions[$messageHash] to 1
            // once we have received the first delta and initialized the orderbook
            $client->subscriptions[$messageHash] = 1;
            $this->orderbooks[$symbol] = $this->counted_order_book(array());
        }
        $storedOrderBook = $this->safe_value($this->orderbooks, $symbol);
        $nonce = $this->safe_integer($storedOrderBook, 'nonce');
        if ($nonce === null) {
            $cacheLength = count($storedOrderBook->cache);
            $snapshotDelay = $this->handle_option('watchOrderBook', 'snapshotDelay', 25);
            if ($cacheLength === $snapshotDelay) {
                $this->spawn(array($this, 'load_order_book'), $client, $messageHash, $symbol);
            }
            $storedOrderBook->cache[] = $data;
            return;
        }
        try {
            $this->handle_delta($storedOrderBook, $data);
            $timestamp = $this->safe_integer($message, 't');
            $storedOrderBook['timestamp'] = $timestamp;
            $storedOrderBook['datetime'] = $this->iso8601($timestamp);
        } catch (Exception $e) {
            unset($client->subscriptions[$messageHash]);
            $client->reject ($e, $messageHash);
        }
        $client->resolve ($storedOrderBook, $messageHash);
    }

    public function handle_bookside_delta($bookside, $bidasks) {
        //
        //    [array(
        //        "p" => "20290.89",
        //        "v" => "0.000000"
        //    )]
        //
        for ($i = 0; $i < count($bidasks); $i++) {
            $bidask = $bidasks[$i];
            if (gettype($bidask) === 'array' && array_keys($bidask) === array_keys(array_keys($bidask))) {
                $bookside->storeArray ($bidask);
            } else {
                $price = $this->safe_float($bidask, 'p');
                $amount = $this->safe_float($bidask, 'v');
                $bookside->store ($price, $amount);
            }
        }
    }

    public function handle_delta($orderbook, $delta) {
        $nonce = $this->safe_integer($orderbook, 'nonce');
        $deltaNonce = $this->safe_integer_2($delta, 'r', 'version');
        if ($deltaNonce !== $nonce && $deltaNonce !== $nonce + 1) {
            throw new ExchangeError($this->id . ' handleOrderBook received an out-of-order nonce');
        }
        $orderbook['nonce'] = $deltaNonce;
        $asks = $this->safe_value($delta, 'asks', array());
        $bids = $this->safe_value($delta, 'bids', array());
        $asksOrderSide = $orderbook['asks'];
        $bidsOrderSide = $orderbook['bids'];
        $this->handle_bookside_delta($asksOrderSide, $asks);
        $this->handle_bookside_delta($bidsOrderSide, $bids);
    }

    public function watch_trades(string $symbol, ?int $since = null, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            /**
             * @see https://mxcdevelop.github.io/apidocs/spot_v3_en/#trade-streams
             * get the list of most recent $trades for a particular $symbol
             * @param {string} $symbol unified $symbol of the $market to fetch $trades for
             * @param {int} [$since] timestamp in ms of the earliest trade to fetch
             * @param {int} [$limit] the maximum amount of $trades to fetch
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array[]} a list of ~@link https://docs.ccxt.com/#/?id=public-$trades trade structures~
             */
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $symbol = $market['symbol'];
            $messageHash = 'trades:' . $symbol;
            $trades = null;
            if ($market['spot']) {
                $channel = 'spot@public.deals.v3.api@' . $market['id'];
                $trades = Async\await($this->watch_spot_public($channel, $messageHash, $params));
            } else {
                $channel = 'sub.deal';
                $requestParams = array(
                    'symbol' => $market['id'],
                );
                $trades = Async\await($this->watch_swap_public($channel, $messageHash, $requestParams, $params));
            }
            if ($this->newUpdates) {
                $limit = $trades->getLimit ($symbol, $limit);
            }
            return $this->filter_by_since_limit($trades, $since, $limit, 'timestamp', true);
        }) ();
    }

    public function handle_trades(Client $client, $message) {
        //
        //    {
        //        "c" => "spot@public.deals.v3.api@BTCUSDT",
        //        "d" => array(
        //            "deals" => [array(
        //                "p" => "20382.70",
        //                "v" => "0.043800",
        //                "S" => 1,
        //                "t" => 1678593222456,
        //            ), ],
        //            "e" => "spot@public.deals.v3.api",
        //        ),
        //        "s" => "BTCUSDT",
        //        "t" => 1678593222460,
        //    }
        //
        // swap
        //     {
        //         "symbol" => "BTC_USDT",
        //         "data" => array(
        //             "p" => 27307.3,
        //             "v" => 5,
        //             "T" => 2,
        //             "O" => 3,
        //             "M" => 1,
        //             "t" => 1680055941870
        //         ),
        //         "channel" => "push.deal",
        //         "ts" => 1680055941870
        //     }
        //
        $marketId = $this->safe_string_2($message, 's', 'symbol');
        $market = $this->safe_market($marketId);
        $symbol = $market['symbol'];
        $messageHash = 'trades:' . $symbol;
        $stored = $this->safe_value($this->trades, $symbol);
        if ($stored === null) {
            $limit = $this->safe_integer($this->options, 'tradesLimit', 1000);
            $stored = new ArrayCache ($limit);
            $this->trades[$symbol] = $stored;
        }
        $d = $this->safe_value_2($message, 'd', 'data');
        $trades = $this->safe_value($d, 'deals', array( $d ));
        for ($j = 0; $j < count($trades); $j++) {
            $parsedTrade = null;
            if ($market['spot']) {
                $parsedTrade = $this->parse_ws_trade($trades[$j], $market);
            } else {
                $parsedTrade = $this->parse_trade($trades[$j], $market);
            }
            $stored->append ($parsedTrade);
        }
        $client->resolve ($stored, $messageHash);
    }

    public function watch_my_trades(?string $symbol = null, ?int $since = null, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            /**
             * @see https://mxcdevelop.github.io/apidocs/spot_v3_en/#spot-account-deals
             * watches information on multiple $trades made by the user
             * @param {string} $symbol unified $market $symbol of the $market $trades were made in
             * @param {int} [$since] the earliest time in ms to fetch $trades for
             * @param {int} [$limit] the maximum number of trade structures to retrieve
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure
             */
            Async\await($this->load_markets());
            $messageHash = 'myTrades';
            $market = null;
            if ($symbol !== null) {
                $market = $this->market($symbol);
                $symbol = $market['symbol'];
                $messageHash = $messageHash . ':' . $symbol;
            }
            $type = null;
            list($type, $params) = $this->handle_market_type_and_params('watchMyTrades', $market, $params);
            $trades = null;
            if ($type === 'spot') {
                $channel = 'spot@private.deals.v3.api';
                $trades = Async\await($this->watch_spot_private($channel, $messageHash, $params));
            } else {
                $trades = Async\await($this->watch_swap_private($messageHash, $params));
            }
            if ($this->newUpdates) {
                $limit = $trades->getLimit ($symbol, $limit);
            }
            return $this->filter_by_symbol_since_limit($trades, $symbol, $since, $limit, true);
        }) ();
    }

    public function handle_my_trade(Client $client, $message, $subscription = null) {
        //
        //    {
        //        "c" => "spot@private.deals.v3.api",
        //        "d" => array(
        //            "p" => "22339.99",
        //            "v" => "0.000235",
        //            "S" => 1,
        //            "T" => 1678670940695,
        //            "t" => "9f6a47fb926442e496c5c4c104076ae3",
        //            "c" => '',
        //            "i" => "e2b9835d1b6745f8a10ab74a81a16d50",
        //            "m" => 0,
        //            "st" => 0
        //        ),
        //        "s" => "BTCUSDT",
        //        "t" => 1678670940700
        //    }
        //
        $messageHash = 'myTrades';
        $data = $this->safe_value_2($message, 'd', 'data');
        $futuresMarketId = $this->safe_string($data, 'symbol');
        $marketId = $this->safe_string($message, 's', $futuresMarketId);
        $market = $this->safe_market($marketId);
        $symbol = $market['symbol'];
        $trade = null;
        if ($market['spot']) {
            $trade = $this->parse_ws_trade($data, $market);
        } else {
            $trade = $this->parse_trade($data, $market);
        }
        $trades = $this->myTrades;
        if ($trades === null) {
            $limit = $this->safe_integer($this->options, 'tradesLimit', 1000);
            $trades = new ArrayCacheBySymbolById ($limit);
            $this->myTrades = $trades;
        }
        $trades->append ($trade);
        $client->resolve ($trades, $messageHash);
        $symbolSpecificMessageHash = $messageHash . ':' . $symbol;
        $client->resolve ($trades, $symbolSpecificMessageHash);
    }

    public function parse_ws_trade($trade, $market = null) {
        //
        // public $trade
        //    {
        //        "p" => "20382.70",
        //        "v" => "0.043800",
        //        "S" => 1,
        //        "t" => 1678593222456,
        //    }
        // private $trade
        //    {
        //        "S" => 1,
        //        "T" => 1661938980268,
        //        "c" => "",
        //        "i" => "c079b0fcb80a46e8b128b281ce4e4f38",
        //        "m" => 1,
        //        "p" => "1.008",
        //        "st" => 0,
        //        "t" => "4079b1522a0b40e7919f609e1ea38d44",
        //        "v" => "5"
        //    }
        //
        $timestamp = $this->safe_integer($trade, 'T');
        $tradeId = $this->safe_string($trade, 't');
        if ($timestamp === null) {
            $timestamp = $this->safe_integer($trade, 't');
            $tradeId = null;
        }
        $priceString = $this->safe_string($trade, 'p');
        $amountString = $this->safe_string($trade, 'v');
        $rawSide = $this->safe_string($trade, 'S');
        $side = ($rawSide === '1') ? 'buy' : 'sell';
        $isMaker = $this->safe_integer($trade, 'm');
        return $this->safe_trade(array(
            'info' => $trade,
            'id' => $tradeId,
            'order' => $this->safe_string($trade, 'i'),
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'symbol' => $this->safe_symbol(null, $market),
            'type' => null,
            'side' => $side,
            'takerOrMaker' => ($isMaker) ? 'maker' : 'taker',
            'price' => $priceString,
            'amount' => $amountString,
            'cost' => null,
            'fee' => null,
        ), $market);
    }

    public function watch_orders(?string $symbol = null, ?int $since = null, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            /**
             * @see https://mxcdevelop.github.io/apidocs/spot_v3_en/#spot-account-$orders
             * @see https://mxcdevelop.github.io/apidocs/spot_v3_en/#margin-account-$orders
             * watches information on multiple $orders made by the user
             * @param {string} $symbol unified $market $symbol of the $market $orders were made in
             * @param {int} [$since] the earliest time in ms to fetch $orders for
             * @param {int} [$limit] the maximum number of order structures to retrieve
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @param {string|null} $params->type the $type of $orders to retrieve, can be 'spot' or 'margin'
             * @return {array[]} a list of ~@link https://docs.ccxt.com/#/?id=order-structure order structures~
             */
            Async\await($this->load_markets());
            $params = $this->omit($params, 'type');
            $messageHash = 'orders';
            $market = null;
            if ($symbol !== null) {
                $market = $this->market($symbol);
                $symbol = $market['symbol'];
                $messageHash = $messageHash . ':' . $symbol;
            }
            $type = null;
            list($type, $params) = $this->handle_market_type_and_params('watchOrders', $market, $params);
            $orders = null;
            if ($type === 'spot') {
                $channel = $type . '@private.orders.v3.api';
                $orders = Async\await($this->watch_spot_private($channel, $messageHash, $params));
            } else {
                $orders = Async\await($this->watch_swap_private($messageHash, $params));
            }
            if ($this->newUpdates) {
                $limit = $orders->getLimit ($symbol, $limit);
            }
            return $this->filter_by_symbol_since_limit($orders, $symbol, $since, $limit, true);
        }) ();
    }

    public function handle_order(Client $client, $message) {
        //
        // spot
        //    {
        //        "c" => "spot@private.orders.v3.api",
        //        "d" => array(
        //              "A":8.0,
        //              "O":1661938138000,
        //              "S":1,
        //              "V":10,
        //              "a":8,
        //              "c":"",
        //              "i":"e03a5c7441e44ed899466a7140b71391",
        //              "m":0,
        //              "o":1,
        //              "p":0.8,
        //              "s":1,
        //              "v":10,
        //              "ap":0,
        //              "cv":0,
        //              "ca":0
        //        ),
        //        "s" => "MXUSDT",
        //        "t" => 1661938138193
        //    }
        // spot - stop
        //    {
        //        "c" => "spot@private.orders.v3.api",
        //        "d" => array(
        //              "N":"USDT",
        //              "O":1661938853715,
        //              "P":0.9,
        //              "S":1,
        //              "T":"LE",
        //              "i":"f6d82e5f41d745f59fe9d3cafffd80b5",
        //              "o":100,
        //              "p":1.01,
        //              "s":"NEW",
        //              "v":6
        //        ),
        //        "s" => "MXUSDT",
        //        "t" => 1661938853727
        //    }
        // margin
        //    {
        //        "c" => "margin@private.orders.v3.api",
        //        "d":array(
        //             "O":1661938138000,
        //             "p":"0.8",
        //             "a":"8",
        //             "v":"10",
        //            "da":"0",
        //            "dv":"0",
        //             "A":"8.0",
        //             "V":"10",
        //             "n" => "0",
        //             "N" => "USDT",
        //             "S":1,
        //             "o":1,
        //             "s":1,
        //             "i":"e03a5c7441e44ed899466a7140b71391",
        //        ),
        //        "s" => "MXUSDT",
        //        "t":1661938138193
        //    }
        //
        $messageHash = 'orders';
        $data = $this->safe_value_2($message, 'd', 'data');
        $futuresMarketId = $this->safe_string($data, 'symbol');
        $marketId = $this->safe_string($message, 's', $futuresMarketId);
        $market = $this->safe_market($marketId);
        $symbol = $market['symbol'];
        $parsed = null;
        if ($market['spot']) {
            $parsed = $this->parse_ws_order($data, $market);
        } else {
            $parsed = $this->parse_order($data, $market);
        }
        $orders = $this->orders;
        if ($orders === null) {
            $limit = $this->safe_integer($this->options, 'ordersLimit', 1000);
            $orders = new ArrayCacheBySymbolById ($limit);
            $this->orders = $orders;
        }
        $orders->append ($parsed);
        $client->resolve ($orders, $messageHash);
        $symbolSpecificMessageHash = $messageHash . ':' . $symbol;
        $client->resolve ($orders, $symbolSpecificMessageHash);
    }

    public function parse_ws_order($order, $market = null) {
        //
        // spot
        //     {
        //          "A":8.0,
        //          "O":1661938138000,
        //          "S":1,
        //          "V":10,
        //          "a":8,
        //          "c":"",
        //          "i":"e03a5c7441e44ed899466a7140b71391",
        //          "m":0,
        //          "o":1,
        //          "p":0.8,
        //          "s":1,
        //          "v":10,
        //          "ap":0,
        //          "cv":0,
        //          "ca":0
        //    }
        // spot - stop
        //    {
        //        "N":"USDT",
        //        "O":1661938853715,
        //        "P":0.9,
        //        "S":1,
        //        "T":"LE",
        //        "i":"f6d82e5f41d745f59fe9d3cafffd80b5",
        //        "o":100,
        //        "p":1.01,
        //        "s":"NEW",
        //        "v":6
        //    }
        // margin
        //    {
        //        "O":1661938138000,
        //        "p":"0.8",
        //        "a":"8",
        //        "v":"10",
        //       "da":"0",
        //       "dv":"0",
        //        "A":"8.0",
        //        "V":"10",
        //        "n" => "0",
        //        "N" => "USDT",
        //        "S":1,
        //        "o":1,
        //        "s":1,
        //        "i":"e03a5c7441e44ed899466a7140b71391",
        //    }
        //
        $timestamp = $this->safe_integer($order, 'O');
        $side = $this->safe_string($order, 'S');
        $status = $this->safe_string($order, 's');
        $type = $this->safe_string($order, 'o');
        $fee = null;
        $feeCurrency = $this->safe_string($order, 'N');
        if ($feeCurrency !== null) {
            $fee = array(
                'currency' => $feeCurrency,
                'cost' => null,
            );
        }
        return $this->safe_order(array(
            'id' => $this->safe_string($order, 'i'),
            'clientOrderId' => $this->safe_string($order, 'c'),
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'lastTradeTimestamp' => null,
            'status' => $this->parse_ws_order_status($status, $market),
            'symbol' => $this->safe_symbol(null, $market),
            'type' => $this->parse_ws_order_type($type),
            'timeInForce' => $this->parse_ws_time_in_force($type),
            'side' => ($side === '1') ? 'buy' : 'sell',
            'price' => $this->safe_string($order, 'p'),
            'stopPrice' => null,
            'triggerPrice' => $this->safe_number($order, 'P'),
            'average' => $this->safe_string($order, 'ap'),
            'amount' => $this->safe_string($order, 'v'),
            'cost' => $this->safe_string($order, 'a'),
            'filled' => $this->safe_string($order, 'cv'),
            'remaining' => $this->safe_string($order, 'V'),
            'fee' => $fee,
            'trades' => null,
            'info' => $order,
        ), $market);
    }

    public function parse_ws_order_status($status, $market = null) {
        $statuses = array(
            '1' => 'open',     // new order
            '2' => 'closed',   // filled
            '3' => 'open',     // partially filled
            '4' => 'canceled', // canceled
            '5' => 'open',     // order partially filled
            '6' => 'closed',   // partially filled then canceled
            'NEW' => 'open',
            'CANCELED' => 'canceled',
            'EXECUTED' => 'closed',
            'FAILED' => 'rejected',
        );
        return $this->safe_string($statuses, $status, $status);
    }

    public function parse_ws_order_type($type) {
        $types = array(
            '1' => 'limit',   // LIMIT_ORDER
            '2' => null, // POST_ONLY
            '3' => null, // IMMEDIATE_OR_CANCEL
            '4' => null, // FILL_OR_KILL
            '5' => 'market',  // MARKET_ORDER
            '100' => 'limit', // STOP_LIMIT
        );
        return $this->safe_string($types, $type);
    }

    public function parse_ws_time_in_force($timeInForce) {
        $timeInForceIds = array(
            '1' => 'GTC',   // LIMIT_ORDER
            '2' => 'PO', // POST_ONLY
            '3' => 'IOC', // IMMEDIATE_OR_CANCEL
            '4' => 'FOK', // FILL_OR_KILL
            '5' => 'GTC',  // MARKET_ORDER
            '100' => 'GTC', // STOP_LIMIT
        );
        return $this->safe_string($timeInForceIds, $timeInForce);
    }

    public function watch_balance($params = array ()): PromiseInterface {
        return Async\async(function () use ($params) {
            /**
             * @see https://mxcdevelop.github.io/apidocs/spot_v3_en/#spot-account-upadte
             * watch balance and get the amount of funds available for trading or funds locked in orders
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} a ~@link https://docs.ccxt.com/#/?id=balance-structure balance structure~
             */
            Async\await($this->load_markets());
            $type = null;
            list($type, $params) = $this->handle_market_type_and_params('watchBalance', null, $params);
            $messageHash = 'balance:' . $type;
            if ($type === 'spot') {
                $channel = 'spot@private.account.v3.api';
                return Async\await($this->watch_spot_private($channel, $messageHash, $params));
            } else {
                return Async\await($this->watch_swap_private($messageHash, $params));
            }
        }) ();
    }

    public function handle_balance(Client $client, $message) {
        //
        // spot
        //    {
        //        "c" => "spot@private.account.v3.api",
        //        "d" => array(
        //            "a" => "USDT",
        //            "c" => 1678185928428,
        //            "f" => "302.185113007893322435",
        //            "fd" => "-4.990689704",
        //            "l" => "4.990689704",
        //            "ld" => "4.990689704",
        //            "o" => "ENTRUST_PLACE"
        //        ),
        //        "t" => 1678185928435
        //    }
        //
        //
        // swap balance
        //
        //     {
        //         "channel" => "push.personal.asset",
        //         "data" => array(
        //             "availableBalance" => 67.2426683348,
        //             "bonus" => 0,
        //             "currency" => "USDT",
        //             "frozenBalance" => 0,
        //             "positionMargin" => 1.36945756
        //         ),
        //         "ts" => 1680059188190
        //     }
        //
        $c = $this->safe_string($message, 'c');
        $type = ($c === null) ? 'swap' : 'spot';
        $messageHash = 'balance:' . $type;
        $data = $this->safe_value_2($message, 'd', 'data');
        $futuresTimestamp = $this->safe_integer($message, 'ts');
        $timestamp = $this->safe_integer($data, 'c', $futuresTimestamp);
        if (!(is_array($this->balance) && array_key_exists($type, $this->balance))) {
            $this->balance[$type] = array();
        }
        $this->balance[$type]['info'] = $data;
        $this->balance[$type]['timestamp'] = $timestamp;
        $this->balance[$type]['datetime'] = $this->iso8601($timestamp);
        $currencyId = $this->safe_string_2($data, 'a', 'currency');
        $code = $this->safe_currency_code($currencyId);
        $account = $this->account();
        $account['free'] = $this->safe_string_2($data, 'f', 'availableBalance');
        $account['used'] = $this->safe_string_2($data, 'l', 'frozenBalance');
        $this->balance[$type][$code] = $account;
        $this->balance[$type] = $this->safe_balance($this->balance[$type]);
        $client->resolve ($this->balance[$type], $messageHash);
    }

    public function authenticate($subscriptionHash, $params = array ()) {
        return Async\async(function () use ($subscriptionHash, $params) {
            // we only need one $listenKey since ccxt shares connections
            $listenKey = $this->safe_string($this->options, 'listenKey');
            if ($listenKey !== null) {
                return $listenKey;
            }
            $response = Async\await($this->spotPrivatePostUserDataStream ($params));
            //
            //    {
            //        "listenKey" => "pqia91ma19a5s61cv6a81va65sdf19v8a65a1a5s61cv6a81va65sdf19v8a65a1"
            //    }
            //
            $listenKey = $this->safe_string($response, 'listenKey');
            $this->options['listenKey'] = $listenKey;
            $listenKeyRefreshRate = $this->safe_integer($this->options, 'listenKeyRefreshRate', 1200000);
            $this->delay($listenKeyRefreshRate, array($this, 'keep_alive_listen_key'), $listenKey, $params);
            return $listenKey;
        }) ();
    }

    public function keep_alive_listen_key($listenKey, $params = array ()) {
        return Async\async(function () use ($listenKey, $params) {
            if ($listenKey === null) {
                return;
            }
            $request = array(
                'listenKey' => $listenKey,
            );
            try {
                Async\await($this->spotPrivatePutUserDataStream (array_merge($request, $params)));
                $listenKeyRefreshRate = $this->safe_integer($this->options, 'listenKeyRefreshRate', 1200000);
                $this->delay($listenKeyRefreshRate, array($this, 'keep_alive_listen_key'), $listenKey, $params);
            } catch (Exception $error) {
                $url = $this->urls['api']['ws']['spot'] . '?$listenKey=' . $listenKey;
                $client = $this->client($url);
                $this->options['listenKey'] = null;
                $client->reject ($error);
                unset($this->clients[$url]);
            }
        }) ();
    }

    public function handle_pong(Client $client, $message) {
        $client->lastPong = $this->milliseconds();
        return $message;
    }

    public function handle_subscription_status(Client $client, $message) {
        //
        //    {
        //        "id" => 0,
        //        "code" => 0,
        //        "msg" => "spot@public.increase.depth.v3.api@BTCUSDT"
        //    }
        //
        $msg = $this->safe_string($message, 'msg');
        if ($msg === 'PONG') {
            return $this->handle_pong($client, $message);
        } elseif (mb_strpos($msg, '@') > -1) {
            $parts = explode('@', $msg);
            $channel = $this->safe_string($parts, 1);
            $methods = array(
                'public.increase.depth.v3.api' => array($this, 'handle_order_book_subscription'),
            );
            $method = $this->safe_value($methods, $channel);
            if ($method !== null) {
                $method($client, $message);
            }
        }
    }

    public function handle_message(Client $client, $message) {
        if (gettype($message) === 'string') {
            if ($message === 'Invalid listen key') {
                $error = new AuthenticationError ($this->id . ' invalid listen key');
                $client->reject ($error);
            }
            return;
        }
        if (is_array($message) && array_key_exists('msg', $message)) {
            return $this->handle_subscription_status($client, $message);
        }
        $c = $this->safe_string($message, 'c');
        $channel = null;
        if ($c === null) {
            $channel = $this->safe_string($message, 'channel');
        } else {
            $parts = explode('@', $c);
            $channel = $this->safe_string($parts, 1);
        }
        $methods = array(
            'public.deals.v3.api' => array($this, 'handle_trades'),
            'push.deal' => array($this, 'handle_trades'),
            'public.kline.v3.api' => array($this, 'handle_ohlcv'),
            'push.kline' => array($this, 'handle_ohlcv'),
            'public.bookTicker.v3.api' => array($this, 'handle_ticker'),
            'push.ticker' => array($this, 'handle_ticker'),
            'public.increase.depth.v3.api' => array($this, 'handle_order_book'),
            'push.depth' => array($this, 'handle_order_book'),
            'private.orders.v3.api' => array($this, 'handle_order'),
            'push.personal.order' => array($this, 'handle_order'),
            'private.account.v3.api' => array($this, 'handle_balance'),
            'push.personal.asset' => array($this, 'handle_balance'),
            'private.deals.v3.api' => array($this, 'handle_my_trade'),
            'push.personal.order.deal' => array($this, 'handle_my_trade'),
            'pong' => array($this, 'handle_pong'),
        );
        if (is_array($methods) && array_key_exists($channel, $methods)) {
            $method = $methods[$channel];
            $method($client, $message);
        }
    }

    public function ping($client) {
        return array( 'method' => 'ping' );
    }
}
