<?php

namespace ccxt\pro;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

use Exception; // a common import
use ccxt\AuthenticationError;
use ccxt\BadRequest;
use ccxt\NotSupported;
use React\Async;

class mexc extends \ccxt\async\mexc {

    use ClientTrait;

    public function describe() {
        return $this->deep_extend(parent::describe(), array(
            'has' => array(
                'ws' => true,
                'watchBalance' => true,
                'watchMyTrades' => true,
                'watchOHLCV' => true,
                'watchOrderBook' => true,
                'watchOrders' => true,
                'watchTicker' => true,
                'watchTickers' => false, // for now
                'watchTrades' => true,
            ),
            'urls' => array(
                'api' => array(
                    'ws' => array(
                        'spot' => 'wss://wbs.mexc.com/raw/ws',
                        'swap' => 'wss://contract.mexc.com/ws',
                    ),
                ),
            ),
            'options' => array(
                'timeframes' => array(
                    '1m' => 'Min1',
                    '5m' => 'Min5',
                    '15m' => 'Min15',
                    '30m' => 'Min30',
                    '1h' => 'Min60',
                    '4h' => 'Hour4',
                    '8h' => 'Hour8',
                    '1d' => 'Day1',
                    '1w' => 'Week1',
                    '1M' => 'Month1',
                ),
            ),
            'streaming' => array(
                'ping' => array($this, 'ping'),
                'keepAlive' => 10000,
            ),
            'exceptions' => array(
                'ws' => array(
                    'exact' => array(
                        'signature validation failed' => '\\ccxt\\AuthenticationError', // array( channel => 'sub.personal', msg => 'signature validation failed')
                    ),
                    'broad' => array(
                        'Contract not exists' => '\\ccxt\\BadSymbol', // array( channel => 'rs.error', data => 'Contract not exists', ts => 1651509181535)
                    ),
                ),
            ),
        ));
    }

    public function watch_ticker($symbol, $params = array ()) {
        return Async\async(function () use ($symbol, $params) {
            /**
             * watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific $market
             * @param {string} $symbol unified $symbol of the $market to fetch the ticker for
             * @param {array} $params extra parameters specific to the mexc api endpoint
             * @return {array} a {@link https://docs.ccxt.com/en/latest/manual.html#ticker-structure ticker structure}
             */
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $symbol = $market['symbol'];
            $channel = 'sub.ticker';
            $messageHash = 'ticker' . ':' . $symbol;
            $requestParams = array(
                'symbol' => $market['id'],
            );
            if ($market['type'] === 'spot') {
                throw new NotSupported($this->id . ' watchTicker does not support spot markets');
            } else {
                return Async\await($this->watch_swap_public($messageHash, $channel, $requestParams, $params));
            }
        }) ();
    }

    public function handle_ticker($client, $message) {
        //
        //     {
        //         channel => 'push.ticker',
        //         $data => array(
        //           amount24 => 491939387.90105,
        //           ask1 => 39530.5,
        //           bid1 => 39530,
        //           contractId => 10,
        //           fairPrice => 39533.4,
        //           fundingRate => 0.00015,
        //           high24Price => 40310.5,
        //           holdVol => 187680157,
        //           indexPrice => 39538.5,
        //           lastPrice => 39530,
        //           lower24Price => 38633,
        //           maxBidPrice => 43492,
        //           minAskPrice => 35584.5,
        //           riseFallRate => 0.0138,
        //           riseFallValue => 539.5,
        //           $symbol => 'BTC_USDT',
        //           timestamp => 1651160401009,
        //           volume24 => 125171687
        //         ),
        //         $symbol => 'BTC_USDT',
        //         ts => 1651160401009
        //     }
        //
        $data = $this->safe_value($message, 'data', array());
        $marketId = $this->safe_string($message, 'symbol');
        $market = $this->safe_market($marketId);
        $symbol = $market['symbol'];
        $ticker = $this->parse_ticker($data, $market);
        $this->tickers[$symbol] = $ticker;
        $messageHash = 'ticker:' . $symbol;
        $client->resolve ($ticker, $messageHash);
        return $message;
    }

    public function watch_ohlcv($symbol, $timeframe = '1m', $since = null, $limit = null, $params = array ()) {
        return Async\async(function () use ($symbol, $timeframe, $since, $limit, $params) {
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $requestParams = array();
            $symbol = $market['symbol'];
            $type = $market['type'];
            $timeframes = $this->safe_value($this->options, 'timeframes', array());
            $timeframeValue = $this->safe_string($timeframes, $timeframe);
            $channel = 'sub.kline';
            $messageHash = 'kline' . ':' . $timeframeValue . ':' . $symbol;
            $requestParams['symbol'] = $market['id'];
            $requestParams['interval'] = $timeframeValue;
            if ($since !== null) {
                $requestParams['start'] = $since;
            }
            $ohlcv = null;
            if ($type === 'spot') {
                $ohlcv = Async\await($this->watch_spot_public($messageHash, $channel, $requestParams, $params));
            } else {
                $ohlcv = Async\await($this->watch_swap_public($messageHash, $channel, $requestParams, $params));
            }
            if ($this->newUpdates) {
                $limit = $ohlcv->getLimit ($symbol, $limit);
            }
            return $this->filter_by_since_limit($ohlcv, $since, $limit, 0, true);
        }) ();
    }

    public function handle_ohlcv($client, $message) {
        // spot
        //   {
        //       $symbol => 'BTC_USDT',
        //       $data => array(
        //         $symbol => 'BTC_USDT',
        //         $interval => 'Min1',
        //         t => 1651230720,
        //         o => 38870.18,
        //         c => 38867.55,
        //         h => 38873.19,
        //         l => 38867.05,
        //         v => 71031.87886502,
        //         q => 1.827357,
        //         e => 38867.05,
        //         rh => 38873.19,
        //         rl => 38867.05
        //       ),
        //       channel => 'push.kline',
        //       symbol_display => 'BTC_USDT'
        //   }
        //
        // swap
        //
        //   {
        //       channel => 'push.kline',
        //       $data => array(
        //         a => 325653.3287,
        //         c => 38839,
        //         h => 38909.5,
        //         $interval => 'Min1',
        //         l => 38833,
        //         o => 38901.5,
        //         q => 83808,
        //         rc => 38839,
        //         rh => 38909.5,
        //         rl => 38833,
        //         ro => 38909.5,
        //         $symbol => 'BTC_USDT',
        //         t => 1651230660
        //       ),
        //       $symbol => 'BTC_USDT',
        //       ts => 1651230713067
        //   }
        //
        $marketId = $this->safe_string($message, 'symbol');
        $market = $this->safe_market($marketId);
        $symbol = $market['symbol'];
        $data = $this->safe_value($message, 'data', array());
        $interval = $this->safe_string($data, 'interval');
        $messageHash = 'kline' . ':' . $interval . ':' . $symbol;
        $timeframes = $this->safe_value($this->options, 'timeframes', array());
        $timeframe = $this->find_timeframe($interval, $timeframes);
        $parsed = $this->parse_ws_ohlcv($data, $market);
        $this->ohlcvs[$symbol] = $this->safe_value($this->ohlcvs, $symbol, array());
        $stored = $this->safe_value($this->ohlcvs[$symbol], $timeframe);
        if ($stored === null) {
            $limit = $this->safe_integer($this->options, 'OHLCVLimit', 1000);
            $stored = new ArrayCacheByTimestamp ($limit);
            $this->ohlcvs[$symbol][$timeframe] = $stored;
        }
        $stored->append ($parsed);
        $client->resolve ($stored, $messageHash);
        return $message;
    }

    public function parse_ws_ohlcv($ohlcv, $market = null) {
        //
        // spot
        //    {
        //       symbol => 'BTC_USDT',
        //       interval => 'Min1',
        //       t => 1651230720,
        //       o => 38870.18,
        //       c => 38867.55,
        //       h => 38873.19,
        //       l => 38867.05,
        //       v => 71031.87886502,
        //       q => 1.827357,
        //       e => 38867.05,
        //       rh => 38873.19,
        //       rl => 38867.05
        //     }
        //
        // swap
        //
        //   {
        //        a => 325653.3287,
        //        c => 38839,
        //        h => 38909.5,
        //        interval => 'Min1',
        //        l => 38833,
        //        o => 38901.5,
        //        q => 83808,
        //        rc => 38839,
        //        rh => 38909.5,
        //        rl => 38833,
        //        ro => 38909.5,
        //        symbol => 'BTC_USDT',
        //        t => 1651230660
        //    }
        //
        return array(
            $this->safe_integer_product($ohlcv, 't', 1000),
            $this->safe_number($ohlcv, 'o'),
            $this->safe_number($ohlcv, 'h'),
            $this->safe_number($ohlcv, 'l'),
            $this->safe_number($ohlcv, 'c'),
            $this->safe_number_2($ohlcv, 'v', 'q'),
        );
    }

    public function watch_order_book($symbol, $limit = null, $params = array ()) {
        return Async\async(function () use ($symbol, $limit, $params) {
            /**
             * watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
             * @param {string} $symbol unified $symbol of the $market to fetch the order book for
             * @param {int|null} $limit the maximum amount of order book entries to return
             * @param {array} $params extra parameters specific to the mexc api endpoint
             * @return {array} A dictionary of {@link https://docs.ccxt.com/en/latest/manual.html#order-book-structure order book structures} indexed by $market symbols
             */
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $symbol = $market['symbol'];
            $messageHash = 'orderbook' . ':' . $symbol;
            $requestParams = array(
                'symbol' => $market['id'],
            );
            if ($limit !== null) {
                if ($limit !== 5 && $limit !== 10 && $limit !== 20) {
                    throw new BadRequest($this->id . ' watchOrderBook $limit parameter cannot be different from 5, 10 or 20');
                }
            } else {
                $limit = 20;
            }
            $orderbook = null;
            if ($market['type'] === 'swap') {
                $channel = 'sub.depth';
                $requestParams['compress'] = true;
                $requestParams['limit'] = $limit;
                $orderbook = Async\await($this->watch_swap_public($messageHash, $channel, $requestParams, $params));
            } else {
                $channel = 'sub.limit.depth';
                $requestParams['depth'] = $limit;
                $orderbook = Async\await($this->watch_spot_public($messageHash, $channel, $requestParams, $params));
            }
            return $orderbook->limit ($limit);
        }) ();
    }

    public function handle_order_book($client, $message) {
        //
        // swap
        //  {
        //      "channel":"push.depth",
        //      "data":array(
        //         "asks":array(
        //            array(
        //               39146.5,
        //               11264,
        //               1
        //            )
        //         ),
        //         "bids":array(
        //            array(
        //               39144,
        //               35460,
        //               1
        //            )
        //         ),
        //         "end":4895965272,
        //         "begin":4895965271
        //      ),
        //      "symbol":"BTC_USDT",
        //      "ts":1651239652372
        //  }
        //
        // spot
        // {
        //     "channel":"push.limit.depth",
        //     "symbol":"BTC_USDT",
        //     "data":array(
        //        "asks":array(
        //           array(
        //              "38694.68",
        //              "2.250996"
        //           ),
        //        ),
        //        "bids":array(
        //           array(
        //              "38694.65",
        //              "0.783084"
        //           ),
        //        )
        //     ),
        //     "depth":5,
        //     "version":"1170951528"
        //  }
        //
        $marketId = $this->safe_string($message, 'symbol');
        $market = $this->safe_market($marketId);
        $symbol = $market['symbol'];
        $data = $this->safe_value($message, 'data');
        $timestamp = $this->safe_integer($message, 'ts');
        $snapshot = $this->parse_order_book($data, $symbol, $timestamp);
        $nonce = $this->safe_number($data, 'end');
        if ($nonce === null) {
            $nonce = $this->safe_number($message, 'version');
        }
        $snapshot['nonce'] = $nonce;
        $orderbook = $this->safe_value($this->orderbooks, $symbol);
        if ($orderbook === null) {
            $orderbook = $this->order_book($snapshot);
            $this->orderbooks[$symbol] = $orderbook;
        } else {
            // spot channels always return entire snapshots
            // whereas swap channels return incremental updates
            // after the first $message
            if ($market['type'] === 'spot') {
                $orderbook->reset ($snapshot);
            } else {
                $this->handle_order_book_message($client, $message, $orderbook);
            }
        }
        $messageHash = 'orderbook' . ':' . $symbol;
        $client->resolve ($orderbook, $messageHash);
    }

    public function handle_order_book_message($client, $message, $orderbook) {
        //
        //  {
        //      "channel":"push.depth",
        //      "data":array(
        //         "asks":array(
        //            array(
        //               39146.5,
        //               11264,
        //               1
        //            )
        //         ),
        //         "bids":array(
        //            array(
        //               39144,
        //               35460,
        //               1
        //            )
        //         ),
        //         "end":4895965272,
        //         "begin":4895965271
        //      ),
        //      "symbol":"BTC_USDT",
        //      "ts":1651239652372
        //
        $data = $this->safe_value($message, 'data', array());
        $nonce = $this->safe_number($data, 'end');
        $asks = $this->safe_value($data, 'asks', array());
        $bids = $this->safe_value($data, 'bids', array());
        $this->handle_deltas($orderbook['asks'], $asks);
        $this->handle_deltas($orderbook['bids'], $bids);
        $timestamp = $this->safe_integer($message, 'ts');
        $marketId = $this->safe_string($message, 'symbol');
        $symbol = $this->safe_symbol($marketId);
        $orderbook['nonce'] = $nonce;
        $orderbook['symbol'] = $symbol;
        $orderbook['timestamp'] = $timestamp;
        $orderbook['datetime'] = $this->iso8601($timestamp);
        return $orderbook;
    }

    public function handle_delta($bookside, $delta) {
        //
        //  array(
        //     39146.5,
        //     11264,
        //     1
        //  )
        //
        $price = $this->safe_float($delta, 0);
        $amount = $this->safe_float($delta, 1);
        $bookside->store ($price, $amount);
    }

    public function handle_deltas($bookside, $deltas) {
        for ($i = 0; $i < count($deltas); $i++) {
            $this->handle_delta($bookside, $deltas[$i]);
        }
    }

    public function watch_trades($symbol, $since = null, $limit = null, $params = array ()) {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            /**
             * get the list of most recent $trades for a particular $symbol
             * @param {string} $symbol unified $symbol of the $market to fetch $trades for
             * @param {int|null} $since timestamp in ms of the earliest trade to fetch
             * @param {int|null} $limit the maximum amount of $trades to fetch
             * @param {array} $params extra parameters specific to the mexc api endpoint
             * @return {[array]} a list of ~@link https://docs.ccxt.com/en/latest/manual.html?#public-$trades trade structures~
             */
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $symbol = $market['symbol'];
            $channel = 'sub.deal';
            $messageHash = 'trades' . ':' . $symbol;
            $requestParams = array(
                'symbol' => $market['id'],
            );
            $trades = null;
            if ($market['type'] === 'spot') {
                $trades = Async\await($this->watch_spot_public($messageHash, $channel, $requestParams, $params));
            } else {
                $trades = Async\await($this->watch_swap_public($messageHash, $channel, $requestParams, $params));
            }
            if ($this->newUpdates) {
                $limit = $trades->getLimit ($symbol, $limit);
            }
            return $this->filter_by_since_limit($trades, $since, $limit, 'timestamp', true);
        }) ();
    }

    public function handle_trades($client, $message) {
        //
        // swap $trades
        //     {
        //         "channel":"push.deal",
        //         "data":array(
        //             "M":1,
        //             "O":1,
        //             "T":1,
        //             "p":6866.5,
        //             "t":1587442049632,
        //             "v":2096
        //         ),
        //         "symbol":"BTC_USDT",
        //         "ts":1587442022003
        //     }
        //
        // spot $trades
        //
        //    {
        //        "symbol":"BTC_USDT",
        //        "data":{
        //           "deals":array(
        //              array(
        //                 "t":1651227552839,
        //                 "p":"39190.01",
        //                 "q":"0.001357",
        //                 "T":2
        //              }
        //           )
        //        ),
        //        "channel":"push.deal"
        //     }
        //
        $marketId = $this->safe_string($message, 'symbol');
        $market = $this->safe_market($marketId);
        $symbol = $market['symbol'];
        $stored = $this->safe_value($this->trades, $symbol);
        if ($stored === null) {
            $limit = $this->safe_integer($this->options, 'tradesLimit', 1000);
            $stored = new ArrayCache ($limit);
            $this->trades[$symbol] = $stored;
        }
        $data = $this->safe_value($message, 'data', array());
        $trades = null;
        if (is_array($data) && array_key_exists('deals', $data)) {
            $trades = $this->safe_value($data, 'deals', array());
        } else {
            $trades = array( $data );
        }
        for ($j = 0; $j < count($trades); $j++) {
            $parsedTrade = $this->parse_ws_trade($trades[$j], $market);
            $stored->append ($parsedTrade);
        }
        $messageHash = 'trades' . ':' . $symbol;
        $client->resolve ($stored, $messageHash);
    }

    public function watch_my_trades($symbol = null, $since = null, $limit = null, $params = array ()) {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            /**
             * watches information on multiple $trades made by the user
             * @param {string} $symbol unified $market $symbol of the $market orders were made in
             * @param {int|null} $since the earliest time in ms to fetch orders for
             * @param {int|null} $limit the maximum number of  orde structures to retrieve
             * @param {array} $params extra parameters specific to the mexc api endpoint
             * @return {[array]} a list of [order structures]{@link https://docs.ccxt.com/en/latest/manual.html#order-structure
             */
            Async\await($this->load_markets());
            $messageHash = 'trade';
            $market = null;
            if ($symbol !== null) {
                $market = $this->market($symbol);
                $symbol = $market['symbol'];
                $messageHash .= ':' . $market['symbol'];
            }
            $type = null;
            list($type, $params) = $this->handle_market_type_and_params('watchMyTrades', $market, $params);
            $trades = null;
            if ($type === 'spot') {
                throw new NotSupported($this->id . ' watchMyTrades does not support spot markets');
            } else {
                $trades = Async\await($this->watch_swap_private($messageHash, $params));
            }
            if ($this->newUpdates) {
                $limit = $trades->getLimit ($symbol, $limit);
            }
            return $this->filter_by_symbol_since_limit($trades, $symbol, $since, $limit, true);
        }) ();
    }

    public function handle_my_trade($client, $message, $subscription = null) {
        //
        // swap trade
        //    {
        //        $channel => 'push.personal.order.deal',
        //        $data => array(
        //          category => 1,
        //          fee => 0.00060288,
        //          feeCurrency => 'USDT',
        //          id => '311655369',
        //          isSelf => false,
        //          orderId => '276461245253669888',
        //          positionMode => 1,
        //          price => 100.48,
        //          profit => 0.0003,
        //          side => 4,
        //          symbol => 'LTC_USDT',
        //          taker => true,
        //          timestamp => 1651583897276,
        //          vol => 1
        //        ),
        //        ts => 1651583897291
        //    }
        //
        $data = $this->safe_value($message, 'data', array());
        $marketId = $this->safe_string($data, 'symbol');
        $market = $this->safe_market($marketId);
        $parsed = $this->parse_ws_trade($data, $market);
        if ($this->myTrades === null) {
            $limit = $this->safe_integer($this->options, 'tradesLimit', 1000);
            $this->myTrades = new ArrayCacheBySymbolById ($limit);
        }
        $trades = $this->myTrades;
        $trades->append ($parsed);
        $channel = 'trade';
        // non-symbol specific
        $client->resolve ($trades, $channel);
        $channel .= ':' . $market['symbol'];
        $client->resolve ($trades, $channel);
    }

    public function parse_ws_trade($trade, $market = null) {
        //
        // public spot
        //    {
        //       "t":1651227552839,
        //       "p":"39190.01",
        //       "q":"0.001357",
        //       "T":2
        //    }
        //
        // public swap
        //
        //   {
        //     "M":1,
        //     "O":1,
        //     "T":1,
        //     "p":6866.5,
        //     "t":1587442049632,
        //     "v":2096
        //   }
        //
        // private swap
        //   {
        //       category => 1,
        //       $fee => 0.00060288,2
        //       feeCurrency => 'USDT',
        //       $id => '311655369',
        //       isSelf => false,
        //       $orderId => '276461245253669888',
        //       positionMode => 1,
        //       price => 100.48,
        //       profit => 0.0003,
        //       $side => 4,
        //       $symbol => 'LTC_USDT',
        //       taker => true,
        //       $timestamp => 1651583897276,
        //       vol => 1
        //   }
        //
        $timestamp = $this->safe_integer_2($trade, 'timestamp', 't');
        $marketId = $this->safe_string($trade, 'symbol');
        $market = $this->safe_market($marketId, $market, '_');
        $symbol = $market['symbol'];
        $priceString = $this->safe_string_2($trade, 'price', 'p');
        $amountString = $this->safe_string_2($trade, 'vol', 'q');
        if ($amountString === null) {
            $amountString = $this->safe_string($trade, 'v');
        }
        $rawSide = $this->safe_string($trade, 'T');
        $side = null;
        if ($rawSide === null) {
            $rawSide = $this->safe_string($trade, 'side');
            $side = $this->parse_swap_side($rawSide);
        } else {
            $side = ($rawSide === '1') ? 'buy' : 'sell';
        }
        $id = $this->safe_string($trade, 'id');
        if ($id === null) {
            $id = (string) $timestamp . '-' . $market['id'] . '-' . $amountString;
        }
        $feeCostString = $this->safe_string($trade, 'fee');
        $fee = null;
        if ($feeCostString !== null) {
            $feeCurrencyId = $this->safe_string($trade, 'feeCurrency');
            $feeCurrencyCode = $this->safe_currency_code($feeCurrencyId);
            $fee = array(
                'cost' => $feeCostString,
                'currency' => $feeCurrencyCode,
            );
        }
        $orderId = $this->safe_string($trade, 'orderId');
        $isTaker = $this->safe_value($trade, 'taker', true);
        $takerOrMaker = $isTaker ? 'taker' : 'maker';
        return $this->safe_trade(array(
            'info' => $trade,
            'id' => $id,
            'order' => $orderId,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'symbol' => $symbol,
            'type' => null,
            'side' => $side,
            'takerOrMaker' => $takerOrMaker,
            'price' => $priceString,
            'amount' => $amountString,
            'cost' => null,
            'fee' => $fee,
        ), $market);
    }

    public function watch_orders($symbol = null, $since = null, $limit = null, $params = array ()) {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            /**
             * watches information on multiple $orders made by the user
             * @param {string|null} $symbol unified $market $symbol of the $market $orders were made in
             * @param {int|null} $since the earliest time in ms to fetch $orders for
             * @param {int|null} $limit the maximum number of  orde structures to retrieve
             * @param {array} $params extra parameters specific to the mexc api endpoint
             * @return {[array]} a list of {@link https://docs.ccxt.com/en/latest/manual.html#order-structure order structures}
             */
            Async\await($this->load_markets());
            $messageHash = 'order';
            $market = null;
            if ($symbol !== null) {
                $market = $this->market($symbol);
                $symbol = $market['symbol'];
                $messageHash .= ':' . $market['symbol'];
            }
            $type = null;
            list($type, $params) = $this->handle_market_type_and_params('watchOrders', $market, $params);
            $orders = null;
            if ($type === 'spot') {
                $orders = Async\await($this->watch_spot_private($messageHash, $params));
            } else {
                $orders = Async\await($this->watch_swap_private($messageHash, $params));
            }
            if ($this->newUpdates) {
                $limit = $orders->getLimit ($symbol, $limit);
            }
            return $this->filter_by_symbol_since_limit($orders, $symbol, $since, $limit, true);
        }) ();
    }

    public function handle_order($client, $message, $subscription = null) {
        //
        // spot order
        //     {
        //         symbol => 'LTC_USDT',
        //         $data => array(
        //           price => 100.25,
        //           quantity => 0.0498,
        //           amount => 4.99245,
        //           remainAmount => 0.01245,
        //           remainQuantity => 0,
        //           remainQ => 0,
        //           remainA => 0,
        //           id => '0b1bf3a33916499f8d1a711a7d5a6fc4',
        //           status => 2,
        //           tradeType => 1,
        //           orderType => 3,
        //           createTime => 1651499416000,
        //           isTaker => 1,
        //           symbolDisplay => 'LTC_USDT',
        //           clientOrderId => ''
        //         ),
        //         $channel => 'push.personal.order',
        //         eventTime => 1651499416639,
        //         symbol_display => 'LTC_USDT'
        //     }
        //
        // spot trigger
        //
        //   {
        //       symbol => 'LTC_USDT',
        //       $data => array(
        //         id => '048dddc31b9a451084b8db8b561a0e33',
        //         $market => 'USDT',
        //         currency => 'LTC',
        //         triggerType => 'LE',
        //         triggerPrice => 80,
        //         tradeType => 'BUY',
        //         orderType => 100,
        //         price => 70,
        //         quantity => 0.0857,
        //         state => 'NEW',
        //         createTime => 1651578450223,
        //         currencyDisplay => 'LTC'
        //       ),
        //       $channel => 'push.personal.trigger.order',
        //       symbol_display => 'LTC_USDT'
        //     }
        //
        //  swap order
        // {
        //     $channel => 'push.personal.order',
        //     $data => array(
        //       category => 1,
        //       createTime => 1651500368131,
        //       dealAvgPrice => 0,
        //       dealVol => 0,
        //       errorCode => 0,
        //       externalOid => '_m_4a78c91ca8be4c4580d94e637b1f70d1',
        //       feeCurrency => 'USDT',
        //       leverage => 1,
        //       makerFee => 0,
        //       openType => 2,
        //       orderId => '276110898672819715',
        //       orderMargin => 0.5006,
        //       orderType => 1,
        //       positionId => 0,
        //       positionMode => 1,
        //       price => 50,
        //       profit => 0,
        //       remainVol => 1,
        //       side => 1,
        //       state => 2,
        //       symbol => 'LTC_USDT',
        //       takerFee => 0,
        //       updateTime => 1651500368142,
        //       usedMargin => 0,
        //       version => 1,
        //       vol => 1
        //     ),
        //     ts => 1651500368149
        //   }
        //
        $data = $this->safe_value($message, 'data', array());
        $marketId = $this->safe_string($message, 'symbol');
        if ($marketId === null) {
            $marketId = $this->safe_string($data, 'symbol');
        }
        $market = $this->safe_market($marketId);
        $parsed = $this->parse_ws_order($data, $market);
        if ($this->orders === null) {
            $limit = $this->safe_integer($this->options, 'ordersLimit', 1000);
            $this->orders = new ArrayCacheBySymbolById ($limit);
        }
        $orders = $this->orders;
        $orders->append ($parsed);
        $channel = 'order';
        // non-symbol specific
        $client->resolve ($orders, $channel);
        $channel .= ':' . $market['symbol'];
        $client->resolve ($orders, $channel);
    }

    public function parse_ws_order($order, $market = null) {
        //
        // spot $order
        //     {
        //           $price => 100.25,
        //           quantity => 0.0498,
        //           $amount => 4.99245,
        //           remainAmount => 0.01245,
        //           remainQuantity => 0,
        //           remainQ => 0,
        //           remainA => 0,
        //           $id => '0b1bf3a33916499f8d1a711a7d5a6fc4',
        //           $status => 2,
        //           $tradeType => 1, // 1 = buy, 2 = sell
        //           orderType => 3, // 1 = limit, 3 = $market, 100 = 'limit
        //           createTime => 1651499416000,
        //           isTaker => 1,
        //           symbolDisplay => 'LTC_USDT',
        //           $clientOrderId => ''
        //     }
        //
        // spot trigger $order
        //    {
        //        $id => '048dddc31b9a451084b8db8b561a0e33',
        //        $market => 'USDT',
        //        currency => 'LTC',
        //        triggerType => 'LE',
        //        triggerPrice => 80,
        //        $tradeType => 'BUY',
        //        orderType => 100,
        //        $price => 70,
        //        quantity => 0.0857,
        //        $state => 'NEW',
        //        createTime => 1651578450223,
        //        currencyDisplay => 'LTC'
        //    }
        //
        //  swap $order
        //   {
        //       category => 1,
        //       createTime => 1651500368131,
        //       dealAvgPrice => 0,
        //       dealVol => 0,
        //       errorCode => 0,
        //       externalOid => '_m_4a78c91ca8be4c4580d94e637b1f70d1',
        //       feeCurrency => 'USDT',
        //       leverage => 1,
        //       makerFee => 0,
        //       openType => 2,
        //       orderId => '276110898672819715',
        //       orderMargin => 0.5006,
        //       orderType => 1, // 5 = $market, 1 = limit,
        //       positionId => 0,
        //       positionMode => 1,
        //       $price => 50,
        //       profit => 0,
        //       remainVol => 1,
        //       $side => 1,
        //       $state => 2,
        //       $symbol => 'LTC_USDT',
        //       takerFee => 0,
        //       updateTime => 1651500368142,
        //       usedMargin => 0,
        //       version => 1,
        //       vol => 1
        //     }
        //
        $id = $this->safe_string_2($order, 'orderId', 'id');
        $state = $this->safe_string_2($order, 'state', 'status');
        $timestamp = $this->safe_integer($order, 'createTime');
        $price = $this->safe_string($order, 'price');
        $amount = $this->safe_string_2($order, 'quantity', 'vol');
        $remaining = $this->safe_string($order, 'remainQuantity');
        $filled = $this->safe_string($order, 'dealVol');
        $cost = $this->safe_string($order, 'amount');
        $avgPrice = $this->safe_string($order, 'dealAvgPrice');
        $marketId = $this->safe_string_2($order, 'symbol', 'symbolDisplay');
        $symbol = $this->safe_symbol($marketId, $market, '_');
        $sideCheck = $this->safe_string($order, 'side');
        $side = $this->parse_swap_side($sideCheck);
        if ($side === null) {
            $tradeType = $this->safe_string_lower($order, 'tradeType');
            if (($tradeType === 'ask') || ($tradeType === '2')) {
                $side = 'sell';
            } elseif (($tradeType === 'bid') || ($tradeType === '1')) {
                $side = 'buy';
            } else {
                $side = $tradeType;
            }
        }
        $status = $this->parse_ws_order_status($state, $market);
        $clientOrderId = $this->safe_string_2($order, 'client_order_id', 'orderId');
        if ($clientOrderId === '') {
            $clientOrderId = null;
        }
        $rawType = $this->safe_string($order, 'orderType');
        $isMarket = ($rawType === '3') || ($rawType === '5');
        $type = $isMarket ? 'market' : 'limit';
        return $this->safe_order(array(
            'id' => $id,
            'clientOrderId' => $clientOrderId,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'lastTradeTimestamp' => $this->safe_integer($order, 'updateTime'),
            'status' => $status,
            'symbol' => $symbol,
            'type' => $type,
            'timeInForce' => null,
            'side' => $side,
            'price' => $price,
            'stopPrice' => null,
            'average' => $avgPrice,
            'amount' => $amount,
            'cost' => $cost,
            'filled' => $filled,
            'remaining' => $remaining,
            'fee' => null,
            'trades' => null,
            'info' => $order,
        ), $market);
    }

    public function parse_swap_side($side) {
        $sides = array(
            '1' => 'open long',
            '2' => 'close short',
            '3' => 'open short',
            '4' => 'close long',
        );
        return $this->safe_string($sides, $side);
    }

    public function parse_ws_order_status($status, $market = null) {
        $statuses = array();
        if ($market['type'] === 'spot') {
            $statuses = array(
                // spot limit/market
                '1' => 'open',
                '2' => 'closed',
                '3' => 'open',
                '4' => 'canceled',
                '5' => 'open',
                // spot trigger only
                'NEW' => 'open',
                'FILLED' => 'closed',
                'PARTIALLY_FILLED' => 'open',
                'CANCELED' => 'canceled',
                'PARTIALLY_CANCELED' => 'canceled',
            );
        } else {
            $statuses = array(
                '2' => 'open',
                '3' => 'closed',
                '4' => 'canceled',
            );
        }
        return $this->safe_string($statuses, $status, $status);
    }

    public function watch_balance($params = array ()) {
        return Async\async(function () use ($params) {
            /**
             * query for balance and get the amount of funds available for trading or funds locked in orders
             * @param {array} $params extra parameters specific to the mexc api endpoint
             * @return {array} a ~@link https://docs.ccxt.com/en/latest/manual.html?#balance-structure balance structure~
             */
            Async\await($this->load_markets());
            $messageHash = 'balance';
            $type = null;
            list($type, $params) = $this->handle_market_type_and_params('watchBalance', null, $params);
            if ($type === 'spot') {
                throw new NotSupported($this->id . ' watchBalance does not support spot markets');
            } else {
                return $this->watch_swap_private($messageHash, $params);
            }
        }) ();
    }

    public function handle_balance($client, $message) {
        //
        // swap balance
        //
        // {
        //     channel => 'push.personal.asset',
        //     $data => array(
        //       availableBalance => 49.2076809226,
        //       bonus => 0,
        //       currency => 'USDT',
        //       frozenBalance => 0.5006,
        //       positionMargin => 0
        //     ),
        //     ts => 1651501676430
        // }
        //
        $data = $this->safe_value($message, 'data');
        $currencyId = $this->safe_string($data, 'currency');
        $code = $this->safe_currency_code($currencyId);
        $account = $this->account();
        $account['free'] = $this->safe_string($data, 'availableBalance');
        $account['used'] = $this->safe_string($data, 'frozenBalance');
        $this->balance[$code] = $account;
        $this->balance = $this->safe_balance($this->balance);
        $messageHash = 'balance';
        $client->resolve ($this->balance, $messageHash);
    }

    public function watch_swap_public($messageHash, $channel, $requestParams, $params = array ()) {
        return Async\async(function () use ($messageHash, $channel, $requestParams, $params) {
            $url = $this->urls['api']['ws']['swap'];
            $request = array(
                'method' => $channel,
                'param' => $requestParams,
            );
            $message = array_merge($request, $params);
            return Async\await($this->watch($url, $messageHash, $message, $messageHash));
        }) ();
    }

    public function watch_spot_public($messageHash, $channel, $requestParams, $params = array ()) {
        return Async\async(function () use ($messageHash, $channel, $requestParams, $params) {
            $url = $this->urls['api']['ws']['spot'];
            $request = array(
                'op' => $channel,
            );
            $extendedRequest = array_merge($request, $requestParams);
            $message = array_merge($extendedRequest, $params);
            return Async\await($this->watch($url, $messageHash, $message, $messageHash));
        }) ();
    }

    public function watch_spot_private($messageHash, $params = array ()) {
        return Async\async(function () use ($messageHash, $params) {
            $this->check_required_credentials();
            $channel = 'sub.personal';
            $url = $this->urls['api']['ws']['spot'];
            $timestamp = (string) $this->milliseconds();
            $request = array(
                'op' => $channel,
                'api_key' => $this->apiKey,
                'req_time' => $timestamp,
            );
            $sortedParams = $this->keysort($request);
            $sortedParams['api_secret'] = $this->secret;
            $encodedParams = $this->urlencode($sortedParams);
            $hash = $this->hash($this->encode($encodedParams), 'md5');
            $request['sign'] = $hash;
            $extendedRequest = array_merge($request, $params);
            return Async\await($this->watch($url, $messageHash, $extendedRequest, $channel));
        }) ();
    }

    public function watch_swap_private($messageHash, $params = array ()) {
        return Async\async(function () use ($messageHash, $params) {
            $this->check_required_credentials();
            $channel = 'login';
            $url = $this->urls['api']['ws']['swap'];
            $timestamp = (string) $this->milliseconds();
            $payload = $this->apiKey . $timestamp;
            $signature = $this->hmac($this->encode($payload), $this->encode($this->secret), 'sha256');
            $request = array(
                'method' => $channel,
                'param' => array(
                    'apiKey' => $this->apiKey,
                    'signature' => $signature,
                    'reqTime' => $timestamp,
                ),
            );
            $extendedRequest = array_merge($request, $params);
            $message = array_merge($extendedRequest, $params);
            return Async\await($this->watch($url, $messageHash, $message, $channel));
        }) ();
    }

    public function handle_error_message($client, $message) {
        //
        //   array( $channel => 'sub.personal', $msg => 'signature validation failed' )
        //
        //   {
        //       $channel => 'rs.error',
        //       $data => 'Contract not exists',
        //       ts => 1651509181535
        //   }
        //
        $channel = $this->safe_string($message, 'channel');
        try {
            $feedback = $this->id . ' ' . $this->json($message);
            if (mb_strpos($channel, 'error') !== false) {
                $data = $this->safe_value($message, 'data');
                if (gettype($data) === 'string') {
                    $this->throw_exactly_matched_exception($this->exceptions['ws']['exact'], $data, $feedback);
                    $this->throw_broadly_matched_exception($this->exceptions['ws']['broad'], $data, $feedback);
                }
            }
            if ($channel === 'sub.personal') {
                $msg = $this->safe_string($message, 'msg');
                $this->throw_exactly_matched_exception($this->exceptions['ws']['exact'], $msg, $feedback);
            }
        } catch (Exception $e) {
            if ($e instanceof AuthenticationError) {
                return false;
            }
        }
        return $message;
    }

    public function handle_authenticate($client, $message) {
        //
        //  array( channel => 'rs.login', data => 'success', ts => 1651486643082 )
        //
        //  array( channel => 'sub.personal', msg => 'OK' )
        //
        return $message;
    }

    public function handle_message($client, $message) {
        //
        // spot pong
        //
        //  "ping"
        //
        // swap pong
        //  array( $channel => 'pong', data => 1651570941402, ts => 1651570941402 )
        //
        // auth spot
        //
        //  array( $channel => 'sub.personal', msg => 'OK' )
        //
        // auth swap
        //
        //  array( $channel => 'rs.login', data => 'success', ts => 1651486643082 )
        //
        // subscription
        //
        //  array( $channel => 'rs.sub.depth', data => 'success', ts => 1651239594401 )
        //
        // swap ohlcv
        //     {
        //         "channel":"push.kline",
        //         "data":array(
        //             "a":233.740269343644737245,
        //             "c":6885,
        //             "h":6910.5,
        //             "interval":"Min60",
        //             "l":6885,
        //             "o":6894.5,
        //             "q":1611754,
        //             "symbol":"BTC_USDT",
        //             "t":1587448800
        //         ),
        //         "symbol":"BTC_USDT",
        //         "ts":1587442022003
        //     }
        //
        // swap ticker
        //     {
        //         $channel => 'push.ticker',
        //         data => array(
        //           amount24 => 491939387.90105,
        //           ask1 => 39530.5,
        //           bid1 => 39530,
        //           contractId => 10,
        //           fairPrice => 39533.4,
        //           fundingRate => 0.00015,
        //           high24Price => 40310.5,
        //           holdVol => 187680157,
        //           indexPrice => 39538.5,
        //           lastPrice => 39530,
        //           lower24Price => 38633,
        //           maxBidPrice => 43492,
        //           minAskPrice => 35584.5,
        //           riseFallRate => 0.0138,
        //           riseFallValue => 539.5,
        //           symbol => 'BTC_USDT',
        //           timestamp => 1651160401009,
        //           volume24 => 125171687
        //         ),
        //         symbol => 'BTC_USDT',
        //         ts => 1651160401009
        //       }
        //
        // swap trades
        //     {
        //         "channel":"push.deal",
        //         "data":array(
        //             "M":1,
        //             "O":1,
        //             "T":1,
        //             "p":6866.5,
        //             "t":1587442049632,
        //             "v":2096
        //         ),
        //         "symbol":"BTC_USDT",
        //         "ts":1587442022003
        //     }
        //
        // spot trades
        //
        //    {
        //        "symbol":"BTC_USDT",
        //        "data":{
        //           "deals":array(
        //              array(
        //                 "t":1651227552839,
        //                 "p":"39190.01",
        //                 "q":"0.001357",
        //                 "T":2
        //              }
        //           )
        //        ),
        //        "channel":"push.deal"
        //     }
        //
        // spot order
        //     {
        //         symbol => 'LTC_USDT',
        //         data => array(
        //           price => 100.25,
        //           quantity => 0.0498,
        //           amount => 4.99245,
        //           remainAmount => 0.01245,
        //           remainQuantity => 0,
        //           remainQ => 0,
        //           remainA => 0,
        //           id => '0b1bf3a33916499f8d1a711a7d5a6fc4',
        //           status => 2,
        //           tradeType => 1,
        //           orderType => 3,
        //           createTime => 1651499416000,
        //           isTaker => 1,
        //           symbolDisplay => 'LTC_USDT',
        //           clientOrderId => ''
        //         ),
        //         $channel => 'push.personal.order',
        //         eventTime => 1651499416639,
        //         symbol_display => 'LTC_USDT'
        //     }
        //
        if (!$this->handle_error_message($client, $message)) {
            return;
        }
        if ($message === 'pong') {
            $this->handle_pong($client, $message);
            return;
        }
        $channel = $this->safe_string($message, 'channel');
        $methods = array(
            'pong' => array($this, 'handle_pong'),
            'rs.login' => array($this, 'handle_authenticate'),
            'push.deal' => array($this, 'handle_trades'),
            'orderbook' => array($this, 'handle_order_book'),
            'push.kline' => array($this, 'handle_ohlcv'),
            'push.ticker' => array($this, 'handle_ticker'),
            'push.depth' => array($this, 'handle_order_book'),
            'push.limit.depth' => array($this, 'handle_order_book'),
            'push.personal.order' => array($this, 'handle_order'),
            'push.personal.trigger.order' => array($this, 'handle_order'),
            'push.personal.plan.order' => array($this, 'handle_order'),
            'push.personal.order.deal' => array($this, 'handle_my_trade'),
            'push.personal.asset' => array($this, 'handle_balance'),
        );
        $method = $this->safe_value($methods, $channel);
        if ($method !== null) {
            $method($client, $message);
        }
    }

    public function ping($client) {
        $type = $this->safe_string($this->options, 'defaultType', 'spot');
        if ($type === 'spot') {
            return 'ping';
        }
        return array( 'method' => 'ping' );
    }

    public function handle_pong($client, $message) {
        //
        // array( channel => 'pong', data => 1651570941402, ts => 1651570941402 )
        //
        $client->lastPong = $this->milliseconds();
        return $message;
    }
}
