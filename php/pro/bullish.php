<?php

namespace ccxt\pro;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

use Exception; // a common import
use ccxt\ExchangeError;
use \React\Async;
use \React\Promise\PromiseInterface;

class bullish extends \ccxt\async\bullish {

    public function describe(): mixed {
        return $this->deep_extend(parent::describe(), array(
            'has' => array(
                'ws' => true,
                'watchTicker' => true,
                'watchTickers' => false,
                'watchOrderBook' => true,
                'watchOrders' => true,
                'watchTrades' => true,
                'watchPositions' => true,
                'watchMyTrades' => true,
                'watchBalance' => true,
                'watchOHLCV' => false,
            ),
            'urls' => array(
                'api' => array(
                    'ws' => array(
                        'public' => 'wss://api.exchange.bullish.com',
                        'private' => 'wss://api.exchange.bullish.com/trading-api/v1/private-data',
                    ),
                ),
                'test' => array(
                    'ws' => array(
                        'public' => 'wss://api.simnext.bullish-test.com',
                        'private' => 'wss://api.simnext.bullish-test.com/trading-api/v1/private-data',
                    ),
                ),
            ),
            'options' => array(
                'ws' => array(
                    'cookies' => array(),
                ),
            ),
            'streaming' => array(
                'ping' => array($this, 'ping'),
                'keepAlive' => 99000, // disconnect after 100 seconds of inactivity
            ),
        ));
    }

    public function request_id() {
        $requestId = $this->sum($this->safe_integer($this->options, 'requestId', 0), 1);
        $this->options['requestId'] = $requestId;
        return $requestId;
    }

    public function ping(Client $client) {
        // bullish does not support built-in ws protocol-level ping-pong
        // https://api.exchange.bullish.com/docs/api/rest/trading-api/v2/#overview--keep-websocket-open
        $id = (string) $this->request_id();
        return array(
            'jsonrpc' => '2.0',
            'type' => 'command',
            'method' => 'keepalivePing',
            'params' => array(),
            'id' => $id,
        );
    }

    public function handle_pong(Client $client, $message) {
        //
        //     {
        //         "id" => "7",
        //         "jsonrpc" => "2.0",
        //         "result" => {
        //             "responseCodeName" => "OK",
        //             "responseCode" => "200",
        //             "message" => "Keep alive pong"
        //         }
        //     }
        //
        $client->lastPong = $this->milliseconds();
        return $message; // current line is for transpilation compatibility
    }

    public function watch_public(string $url, string $messageHash, $request = array (), $params = array ()): PromiseInterface {
        return Async\async(function () use ($url, $messageHash, $request, $params) {
            $id = (string) $this->request_id();
            $message = array(
                'jsonrpc' => '2.0',
                'type' => 'command',
                'method' => 'subscribe',
                'params' => $request,
                'id' => $id,
            );
            $fullUrl = $this->urls['api']['ws']['public'] . $url;
            return Async\await($this->watch($fullUrl, $messageHash, $this->deep_extend($message, $params), $messageHash));
        }) ();
    }

    public function watch_private(string $messageHash, string $subscribeHash, $request = array (), $params = array ()): PromiseInterface {
        return Async\async(function () use ($messageHash, $subscribeHash, $request, $params) {
            $url = $this->urls['api']['ws']['private'];
            $token = Async\await($this->handleToken ());
            $cookies = array(
                'JWT_COOKIE' => $token,
            );
            $this->options['ws']['cookies'] = $cookies;
            $id = (string) $this->request_id();
            $message = array(
                'jsonrpc' => '2.0',
                'type' => 'command',
                'method' => 'subscribe',
                'params' => $request,
                'id' => $id,
            );
            $result = Async\await($this->watch($url, $messageHash, $this->deep_extend($message, $params), $subscribeHash));
            return $result;
        }) ();
    }

    public function watch_trades(string $symbol, ?int $since = null, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            /**
             * get the list of most recent $trades for a particular $symbol
             *
             * @see https://api.exchange.bullish.com/docs/api/rest/trading-api/v2/#overview--unified-anonymous-$trades-websocket-unauthenticated
             *
             * @param {string} $symbol unified $symbol of the $market to fetch $trades for
             * @param {int} [$since] timestamp in ms of the earliest trade to fetch
             * @param {int} [$limit] the maximum amount of $trades to fetch
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array[]} a list of ~@link https://docs.ccxt.com/?id=public-$trades trade structures~
             */
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $messageHash = 'trades::' . $market['symbol'];
            $url = '/trading-api/v1/market-data/trades';
            $request = array(
                'topic' => 'anonymousTrades',
                'symbol' => $market['id'],
            );
            $trades = Async\await($this->watch_public($url, $messageHash, $request, $params));
            if ($this->newUpdates) {
                $limit = $trades->getLimit ($symbol, $limit);
            }
            return $this->filter_by_since_limit($trades, $since, $limit, 'timestamp', true);
        }) ();
    }

    public function handle_trades(Client $client, $message) {
        //
        //     {
        //         "type" => "snapshot",
        //         "dataType" => "V1TAAnonymousTradeUpdate",
        //         "data" => {
        //             "trades" => array(
        //                 {
        //                     "tradeId" => "100086000000609304",
        //                     "isTaker" => true,
        //                     "price" => "104889.2063",
        //                     "createdAtTimestamp" => "1749124509118",
        //                     "quantity" => "0.01000000",
        //                     "publishedAtTimestamp" => "1749124531466",
        //                     "side" => "BUY",
        //                     "createdAtDatetime" => "2025-06-05T11:55:09.118Z",
        //                     "symbol" => "BTCUSDC"
        //                 }
        //             ),
        //             "createdAtTimestamp" => "1749124509118",
        //             "publishedAtTimestamp" => "1749124531466",
        //             "symbol" => "BTCUSDC"
        //         }
        //     }
        //
        $data = $this->safe_dict($message, 'data', array());
        $marketId = $this->safe_string($data, 'symbol');
        $symbol = $this->safe_symbol($marketId);
        $market = $this->market($symbol);
        $rawTrades = $this->safe_list($data, 'trades', array());
        $trades = $this->parse_trades($rawTrades, $market);
        if (!(is_array($this->trades) && array_key_exists($symbol, $this->trades))) {
            $limit = $this->safe_integer($this->options, 'tradesLimit', 1000);
            $tradesArrayCache = new ArrayCache ($limit);
            $this->trades[$symbol] = $tradesArrayCache;
        }
        $tradesArray = $this->trades[$symbol];
        for ($i = 0; $i < count($trades); $i++) {
            $tradesArray->append ($trades[$i]);
        }
        $this->trades[$symbol] = $tradesArray;
        $messageHash = 'trades::' . $market['symbol'];
        $client->resolve ($tradesArray, $messageHash);
    }

    public function watch_ticker(string $symbol, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $params) {
            /**
             * watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific $market
             *
             * @see https://api.exchange.bullish.com/docs/api/rest/trading-api/v2/#overview--anonymous-$market-data-price-tick-unauthenticated
             *
             * @param {string} $symbol unified $symbol of the $market to fetch the ticker for
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} a ~@link https://docs.ccxt.com/?id=ticker-structure ticker structure~
             */
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $symbol = $market['symbol'];
            $url = $this->urls['api']['ws']['public'] . '/trading-api/v1/market-data/tick/' . $market['id'];
            $messageHash = 'ticker::' . $symbol;
            return Async\await($this->watch($url, $messageHash, $params, $messageHash)); // no need to send a subscribe message, the server sends a ticker update on connect
        }) ();
    }

    public function handle_ticker(Client $client, $message) {
        //
        //     {
        //         "type" => "update",
        //         "dataType" => "V1TATickerResponse",
        //         "data" => {
        //             "askVolume" => "0.00100822",
        //             "average" => "104423.1806",
        //             "baseVolume" => "472.83799258",
        //             "bestAsk" => "104324.6000",
        //             "bestBid" => "104324.5000",
        //             "bidVolume" => "0.00020146",
        //             "change" => "-198.4864",
        //             "close" => "104323.9374",
        //             "createdAtTimestamp" => "1749132838951",
        //             "publishedAtTimestamp" => "1749132838955",
        //             "high" => "105966.6577",
        //             "last" => "104323.9374",
        //             "lastTradeDatetime" => "2025-06-05T14:13:56.111Z",
        //             "lastTradeSize" => "0.02396100",
        //             "low" => "104246.6662",
        //             "open" => "104522.4238",
        //             "percentage" => "-0.19",
        //             "quoteVolume" => "49662592.6712",
        //             "symbol" => "BTC-USDC-PERP",
        //             "type" => "ticker",
        //             "vwap" => "105030.6996",
        //             "currentPrice" => "104324.7747",
        //             "ammData" => array(
        //                 {
        //                     "feeTierId" => "1",
        //                     "currentPrice" => "104324.7747",
        //                     "baseReservesQuantity" => "8.27911366",
        //                     "quoteReservesQuantity" => "1067283.0234",
        //                     "bidSpreadFee" => "0.00000000",
        //                     "askSpreadFee" => "0.00000000"
        //                 }
        //             ),
        //             "createdAtDatetime" => "2025-06-05T14:13:58.951Z",
        //             "markPrice" => "104289.6884",
        //             "fundingRate" => "-0.000192",
        //             "openInterest" => "92.24146651"
        //         }
        //     }
        //
        $updateType = $this->safe_string($message, 'type', '');
        $data = $this->safe_dict($message, 'data', array());
        $marketId = $this->safe_string($data, 'symbol');
        $market = $this->safe_market($marketId);
        $symbol = $market['symbol'];
        $parsed = null;
        if (($updateType === 'snapshot')) {
            $parsed = $this->parse_ticker($data, $market);
        } elseif ($updateType === 'update') {
            $ticker = $this->safe_dict($this->tickers, $symbol, array());
            $rawTicker = $this->safe_dict($ticker, 'info', array());
            $merged = $this->extend($rawTicker, $data);
            $parsed = $this->parse_ticker($merged, $market);
        }
        $this->tickers[$symbol] = $parsed;
        $messageHash = 'ticker::' . $symbol;
        $client->resolve ($this->tickers[$symbol], $messageHash);
    }

    public function watch_order_book(string $symbol, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $limit, $params) {
            /**
             * watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
             *
             * @see https://api.exchange.bullish.com/docs/api/rest/trading-api/v2/#overview--multi-$orderbook-websocket-unauthenticated
             *
             * @param {string} $symbol unified $symbol of the $market to fetch the order book for
             * @param {int} [$limit] the maximum amount of order book entries to return
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} A dictionary of ~@link https://docs.ccxt.com/?id=order-book-structure order book structures~ indexed by $market symbols
             */
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $url = '/trading-api/v1/market-data/orderbook';
            $messageHash = 'orderbook::' . $market['symbol'];
            $request = array(
                'topic' => 'l2Orderbook', // 'l2Orderbook' returns only snapshots while 'l1Orderbook' returns only updates
                'symbol' => $market['id'],
            );
            $orderbook = Async\await($this->watch_public($url, $messageHash, $request, $params));
            return $orderbook->limit ();
        }) ();
    }

    public function handle_order_book(Client $client, $message) {
        //
        //     {
        //         "type" => "snapshot",
        //         "dataType" => "V1TALevel2",
        //         "data" => {
        //             "timestamp" => "1749372632028",
        //             "bids" => array(
        //                 "105523.3000",
        //                 "0.00046045",
        //             ),
        //             "asks" => array(
        //                 "105523.4000",
        //                 "0.00117112",
        //             ),
        //             "publishedAtTimestamp" => "1749372632073",
        //             "datetime" => "2025-06-08T08:50:32.028Z",
        //             "sequenceNumberRange" => array( 1967862061, 1967862062 ),
        //             "symbol" => "BTCUSDC"
        //         }
        //     }
        //
        // current channel is 'l2Orderbook' which returns only snapshots
        $data = $this->safe_dict($message, 'data', array());
        $marketId = $this->safe_string($data, 'symbol');
        $symbol = $this->safe_symbol($marketId);
        $messageHash = 'orderbook::' . $symbol;
        $timestamp = $this->safe_integer($data, 'timestamp');
        if (!(is_array($this->orderbooks) && array_key_exists($symbol, $this->orderbooks))) {
            $this->orderbooks[$symbol] = $this->order_book();
        }
        $orderbook = $this->orderbooks[$symbol];
        $bids = $this->separate_bids_or_asks($this->safe_list($data, 'bids', array()));
        $asks = $this->separate_bids_or_asks($this->safe_list($data, 'asks', array()));
        $snapshot = array(
            'bids' => $bids,
            'asks' => $asks,
        );
        $parsed = $this->parse_order_book($snapshot, $symbol, $timestamp);
        $sequenceNumberRange = $this->safe_list($data, 'sequenceNumberRange', array());
        if (strlen($sequenceNumberRange) > 0) {
            $lastIndex = strlen($sequenceNumberRange) - 1;
            $parsed['nonce'] = $this->safe_integer($sequenceNumberRange, $lastIndex);
        }
        $orderbook->reset ($parsed);
        $this->orderbooks[$symbol] = $orderbook;
        $client->resolve ($orderbook, $messageHash);
    }

    public function separate_bids_or_asks($entry) {
        $result = array();
        // 300 = '54885.0000000'
        // 301 = '0.06141566'
        // 302 ='53714.0000000'
        for ($i = 0; $i < count($entry); $i++) {
            if (fmod($i, 2) !== 0) {
                continue;
            }
            $price = $this->safe_string($entry, $i);
            $amount = $this->safe_string($entry, $i + 1);
            $result[] = array( $price, $amount );
        }
        return $result;
    }

    public function watch_orders(?string $symbol = null, ?int $since = null, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            /**
             * watches information on multiple $orders made by the user
             *
             * @see https://api.exchange.bullish.com/docs/api/rest/trading-api/v2/#overview--private-data-websocket-authenticated
             *
             * @param {string} $symbol unified market $symbol of the market $orders were made in
             * @param {int} [$since] the earliest time in ms to fetch $orders for
             * @param {int} [$limit] the maximum number of order structures to retrieve
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @param {string} [$params->tradingAccountId] the trading account id to fetch entries for
             * @return {array[]} a list of ~@link https://docs.ccxt.com/?id=order-structure order structures~
             */
            Async\await($this->load_markets());
            $subscribeHash = 'orders';
            $messageHash = $subscribeHash;
            if ($symbol !== null) {
                $symbol = $this->symbol($symbol);
                $messageHash = $messageHash . '::' . $symbol;
            }
            $request = array(
                'topic' => 'orders',
            );
            $tradingAccountId = $this->safe_string($params, 'tradingAccountId');
            if ($tradingAccountId !== null) {
                $request['tradingAccountId'] = $tradingAccountId;
                $params = $this->omit($params, 'tradingAccountId');
            }
            $orders = Async\await($this->watch_private($messageHash, $subscribeHash, $request, $params));
            if ($this->newUpdates) {
                $limit = $orders->getLimit ($symbol, $limit);
            }
            return $this->filter_by_symbol_since_limit($orders, $symbol, $since, $limit, true);
        }) ();
    }

    public function handle_orders(Client $client, $message) {
        // snapshot
        //     {
        //         "type" => "snapshot",
        //         "tradingAccountId" => "111309424211255",
        //         "dataType" => "V1TAOrder",
        //         "data" => array( ... ) // could be an empty list or a list of $orders
        //     }
        //
        // update
        //     {
        //         "type" => "update",
        //         "tradingAccountId" => "111309424211255",
        //         "dataType" => "V1TAOrder",
        //         "data" => {
        //             "status" => "OPEN",
        //             "createdAtTimestamp" => "1751893427971",
        //             "quoteFee" => "0.000000",
        //             "stopPrice" => null,
        //             "quantityFilled" => "0.00000000",
        //             "handle" => null,
        //             "clientOrderId" => null,
        //             "quantity" => "0.10000000",
        //             "margin" => false,
        //             "side" => "BUY",
        //             "createdAtDatetime" => "2025-07-07T13:03:47.971Z",
        //             "isLiquidation" => false,
        //             "borrowedQuoteQuantity" => null,
        //             "borrowedBaseQuantity" => null,
        //             "timeInForce" => "GTC",
        //             "borrowedQuantity" => null,
        //             "baseFee" => "0.000000",
        //             "quoteAmount" => "0.0000000",
        //             "price" => "0.0000000",
        //             "statusReason" => "Order accepted",
        //             "type" => "MKT",
        //             "statusReasonCode" => 6014,
        //             "allowBorrow" => false,
        //             "orderId" => "862317981870850049",
        //             "publishedAtTimestamp" => "1751893427975",
        //             "symbol" => "ETHUSDT",
        //             "averageFillPrice" => null
        //         }
        //     }
        //
        $type = $this->safe_string($message, 'type');
        $rawOrders = array();
        if ($type === 'update') {
            $data = $this->safe_dict($message, 'data', array());
            $rawOrders[] = $data; // update is a single order
        } else {
            $rawOrders = $this->safe_list($message, 'data', array()); // snapshot is a list of $orders
        }
        if (strlen($rawOrders) > 0) {
            if ($this->orders === null) {
                $limit = $this->safe_integer($this->options, 'ordersLimit', 1000);
                $this->orders = new ArrayCacheBySymbolById ($limit);
            }
            $orders = $this->orders;
            $symbols = array();
            for ($i = 0; $i < count($rawOrders); $i++) {
                $rawOrder = $rawOrders[$i];
                $parsedOrder = $this->parse_order($rawOrder);
                $orders->append ($parsedOrder);
                $symbol = $this->safe_string($parsedOrder, 'symbol');
                $symbols[$symbol] = true;
            }
            $messageHash = 'orders';
            $client->resolve ($orders, $messageHash);
            $keys = is_array($symbols) ? array_keys($symbols) : array();
            for ($i = 0; $i < count($keys); $i++) {
                $hashSymbol = $keys[$i];
                $symbolMessageHash = $messageHash . '::' . $hashSymbol;
                $client->resolve ($this->orders, $symbolMessageHash);
            }
        }
    }

    public function watch_my_trades(?string $symbol = null, ?int $since = null, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            /**
             * watches information on multiple $trades made by the user
             *
             * @see https://api.exchange.bullish.com/docs/api/rest/trading-api/v2/#overview--private-data-websocket-authenticated
             *
             * @param {string} $symbol unified market $symbol of the market $trades were made in
             * @param {int} [$since] the earliest time in ms to fetch $trades for
             * @param {int} [$limit] the maximum number of trade structures to retrieve
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @param {string} [$params->tradingAccountId] the trading account id to fetch entries for
             * @return {array[]} a list of ~@link https://docs.ccxt.com/?id=trade-structure trade structures~
             */
            Async\await($this->load_markets());
            $subscribeHash = 'myTrades';
            $messageHash = $subscribeHash;
            if ($symbol !== null) {
                $symbol = $this->symbol($symbol);
                $messageHash .= '::' . $symbol;
            }
            $request = array(
                'topic' => 'trades',
            );
            $tradingAccountId = $this->safe_string($params, 'tradingAccountId');
            if ($tradingAccountId !== null) {
                $request['tradingAccountId'] = $tradingAccountId;
                $params = $this->omit($params, 'tradingAccountId');
            }
            $trades = Async\await($this->watch_private($messageHash, $subscribeHash, $request, $params));
            if ($this->newUpdates) {
                $limit = $trades->getLimit ($symbol, $limit);
            }
            return $this->filter_by_since_limit($trades, $since, $limit, 'timestamp', true);
        }) ();
    }

    public function handle_my_trades(Client $client, $message) {
        //
        // snapshot
        //     {
        //         "type" => "snapshot",
        //         "tradingAccountId" => "111309424211255",
        //         "dataType" => "V1TATrade",
        //         "data" => array( ... ) // could be an empty list or a list of $trades
        //     }
        //
        // update
        //     {
        //         "type" => "update",
        //         "tradingAccountId" => "111309424211255",
        //         "dataType" => "V1TATrade",
        //         "data" => {
        //             "clientOtcTradeId" => null,
        //             "tradeId" => "100203000003940164",
        //             "baseFee" => "0.00000000",
        //             "isTaker" => true,
        //             "quoteAmount" => "253.6012195",
        //             "price" => "2536.0121950",
        //             "createdAtTimestamp" => "1751914859840",
        //             "quoteFee" => "0.0000000",
        //             "tradeRebateAmount" => null,
        //             "tradeRebateAssetSymbol" => null,
        //             "handle" => null,
        //             "otcTradeId" => null,
        //             "otcMatchId" => null,
        //             "orderId" => "862407873644725249",
        //             "quantity" => "0.10000000",
        //             "publishedAtTimestamp" => "1751914859843",
        //             "side" => "SELL",
        //             "createdAtDatetime" => "2025-07-07T19:00:59.840Z",
        //             "symbol" => "ETHUSDT"
        //         }
        //     }
        //
        $type = $this->safe_string($message, 'type');
        $rawTrades = array();
        if ($type === 'update') {
            $data = $this->safe_dict($message, 'data', array());
            $rawTrades[] = $data; // update is a single trade
        } else {
            $rawTrades = $this->safe_list($message, 'data', array()); // snapshot is a list of $trades
        }
        if (strlen($rawTrades) > 0) {
            if ($this->myTrades === null) {
                $limit = $this->safe_integer($this->options, 'tradesLimit', 1000);
                $this->myTrades = new ArrayCacheBySymbolById ($limit);
            }
            $trades = $this->myTrades;
            $symbols = array();
            for ($i = 0; $i < count($rawTrades); $i++) {
                $rawTrade = $rawTrades[$i];
                $parsedTrade = $this->parse_trade($rawTrade);
                $trades->append ($parsedTrade);
                $symbol = $this->safe_string($parsedTrade, 'symbol');
                $symbols[$symbol] = true;
            }
            $messageHash = 'myTrades';
            $client->resolve ($trades, $messageHash);
            $keys = is_array($symbols) ? array_keys($symbols) : array();
            for ($i = 0; $i < count($keys); $i++) {
                $hashSymbol = $keys[$i];
                $symbolMessageHash = $messageHash . '::' . $hashSymbol;
                $client->resolve ($this->myTrades, $symbolMessageHash);
            }
        }
    }

    public function watch_balance($params = array ()): PromiseInterface {
        return Async\async(function () use ($params) {
            /**
             * watch balance and get the amount of funds available for trading or funds locked in orders
             *
             * @see https://api.exchange.bullish.com/docs/api/rest/trading-api/v2/#overview--private-data-websocket-authenticated
             *
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @param {string} [$params->tradingAccountId] the trading account id to fetch entries for
             * @return {array} a ~@link https://docs.ccxt.com/?id=balance-structure balance structure~
             */
            Async\await($this->load_markets());
            $request = array(
                'topic' => 'assetAccounts',
            );
            $messageHash = 'balance';
            $tradingAccountId = $this->safe_string($params, 'tradingAccountId');
            if ($tradingAccountId !== null) {
                $params = $this->omit($params, 'tradingAccountId');
                $request['tradingAccountId'] = $tradingAccountId;
                $messageHash .= '::' . $tradingAccountId;
            }
            return Async\await($this->watch_private($messageHash, $messageHash, $request, $params));
        }) ();
    }

    public function handle_balance(Client $client, $message) {
        //
        // snapshot
        //     {
        //         "type" => "snapshot",
        //         "tradingAccountId" => "111309424211255",
        //         "dataType" => "V1TAAssetAccount",
        //         "data" => array(
        //             {
        //                 "updatedAtTimestamp" => "1751989627509",
        //                 "borrowedQuantity" => "0.0000",
        //                 "tradingAccountId" => "111309424211255",
        //                 "loanedQuantity" => "0.0000",
        //                 "lockedQuantity" => "0.0000",
        //                 "assetId" => "5",
        //                 "assetSymbol" => "USDC",
        //                 "publishedAtTimestamp" => "1751989627512",
        //                 "availableQuantity" => "999672939.8767",
        //                 "updatedAtDatetime" => "2025-07-08T15:47:07.509Z"
        //             }
        //         )
        //     }
        //
        // update
        //     {
        //         "type" => "update",
        //         "tradingAccountId" => "111309424211255",
        //         "dataType" => "V1TAAssetAccount",
        //         "data" => {
        //             "updatedAtTimestamp" => "1751989627509",
        //             "borrowedQuantity" => "0.0000",
        //             "tradingAccountId" => "111309424211255",
        //             "loanedQuantity" => "0.0000",
        //             "lockedQuantity" => "0.0000",
        //             "assetId" => "5",
        //             "assetSymbol" => "USDC",
        //             "publishedAtTimestamp" => "1751989627512",
        //             "availableQuantity" => "999672939.8767",
        //             "updatedAtDatetime" => "2025-07-08T15:47:07.509Z"
        //         }
        //     }
        //
        $tradingAccountId = $this->safe_string($message, 'tradingAccountId');
        if (!(is_array($this->balance) && array_key_exists($tradingAccountId, $this->balance))) {
            $this->balance[$tradingAccountId] = array();
        }
        $messageType = $this->safe_string($message, 'type');
        if ($messageType === 'snapshot') {
            $data = $this->safe_list($message, 'data', array());
            $this->balance[$tradingAccountId] = $this->parse_balance($data);
        } else {
            $data = $this->safe_dict($message, 'data', array());
            $assetId = $this->safe_string($data, 'assetSymbol');
            $account = $this->account();
            $account['total'] = $this->safe_string($data, 'availableQuantity');
            $account['used'] = $this->safe_string($data, 'lockedQuantity');
            $code = $this->safe_currency_code($assetId);
            $this->balance[$tradingAccountId][$code] = $account;
            $this->balance[$tradingAccountId]['info'] = $message;
            $this->balance[$tradingAccountId] = $this->safe_balance($this->balance[$tradingAccountId]);
        }
        $messageHash = 'balance';
        $tradingAccountIdHash = '::' . $tradingAccountId;
        $client->resolve ($this->balance[$tradingAccountId], $messageHash);
        $client->resolve ($this->balance[$tradingAccountId], $messageHash . $tradingAccountIdHash);
    }

    public function watch_positions(?array $symbols = null, ?int $since = null, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbols, $since, $limit, $params) {
            /**
             *
             * @see https://api.exchange.bullish.com/docs/api/rest/trading-api/v2/#overview--private-data-websocket-authenticated
             *
             * watch all open $positions
             * @param {string[]} [$symbols] list of unified market $symbols
             * @param {int} [$since] the earliest time in ms to fetch $positions for
             * @param {int} [$limit] the maximum number of $positions to retrieve
             * @param {array} $params extra parameters specific to the exchange API endpoint
             * @return {array[]} a list of {@link https://docs.ccxt.com/en/latest/manual.html#position-structure position structure}
             */
            Async\await($this->load_markets());
            $subscribeHash = 'positions';
            $messageHash = $subscribeHash;
            if (!$this->is_empty($symbols)) {
                $symbols = $this->market_symbols($symbols);
                $messageHash .= '::' . implode(',', $symbols);
            }
            $request = array(
                'topic' => 'derivativesPositionsV2',
            );
            $positions = Async\await($this->watch_private($messageHash, $subscribeHash, $request, $params));
            if ($this->newUpdates) {
                return $positions;
            }
            return $this->filter_by_symbols_since_limit($positions, $symbols, $since, $limit, true);
        }) ();
    }

    public function handle_positions(Client $client, $message) {
        // exchange does not return messages for sandbox mode
        // current method is implemented blindly
        // todo => check if this works with not-sandbox mode
        $messageType = $this->safe_string($message, 'type');
        $rawPositions = array();
        if ($messageType === 'update') {
            $data = $this->safe_dict($message, 'data', array());
            $rawPositions[] = $data;
        } else {
            $rawPositions = $this->safe_list($message, 'data', array());
        }
        if ($this->positions === null) {
            $this->positions = new ArrayCacheBySymbolBySide ();
        }
        $positions = $this->positions;
        $newPositions = array();
        for ($i = 0; $i < count($rawPositions); $i++) {
            $rawPosition = $rawPositions[$i];
            $position = $this->parse_position($rawPosition);
            $positions->append ($position);
            $newPositions[] = $position;
        }
        $messageHashes = $this->find_message_hashes($client, 'positions::');
        for ($i = 0; $i < count($messageHashes); $i++) {
            $messageHash = $messageHashes[$i];
            $parts = explode('::', $messageHash);
            $symbolsString = $parts[1];
            $symbols = explode(',', $symbolsString);
            $symbolPositions = $this->filter_by_array($newPositions, 'symbol', $symbols, false);
            if (!$this->is_empty($symbolPositions)) {
                $client->resolve ($symbolPositions, $messageHash);
            }
        }
        $client->resolve ($positions, 'positions');
    }

    public function handle_error_message(Client $client, $message) {
        //
        //     {
        //         "data" => array(
        //             "errorCode" => 401,
        //             "errorCodeName" => "UNAUTHORIZED",
        //             "message" => "Unable to authenticate; JWT is missing/invalid or unauthorised to access account"
        //         ),
        //         "dataType" => "V1TAErrorResponse",
        //         "type" => "error"
        //     }
        //
        $data = $this->safe_dict($message, 'data', array());
        $feedback = $this->id . ' ' . $this->json($data);
        try {
            $errorCode = $this->safe_string($data, 'errorCode');
            $errorCodeName = $this->safe_string($data, 'errorCodeName');
            $this->throw_exactly_matched_exception($this->exceptions['exact'], $errorCode, $feedback);
            $this->throw_broadly_matched_exception($this->exceptions['broad'], $errorCodeName, $feedback);
            throw new ExchangeError($feedback); // unknown $message
        } catch (Exception $e) {
            $client->reject ($e);
        }
    }

    public function handle_message(Client $client, $message) {
        $dataType = $this->safe_string($message, 'dataType');
        $result = $this->safe_dict($message, 'result');
        if ($result !== null) {
            $response = $this->safe_string($result, 'message');
            if ($response === 'Keep alive pong') {
                $this->handle_pong($client, $message);
            }
        } elseif ($dataType !== null) {
            if ($dataType === 'V1TAAnonymousTradeUpdate') {
                $this->handle_trades($client, $message);
            }
            if ($dataType === 'V1TATickerResponse') {
                $this->handle_ticker($client, $message);
            }
            if ($dataType === 'V1TALevel2') {
                $this->handle_order_book($client, $message);
            }
            if ($dataType === 'V1TAOrder') {
                $this->handle_orders($client, $message);
            }
            if ($dataType === 'V1TATrade') {
                $this->handle_my_trades($client, $message);
            }
            if ($dataType === 'V1TAAssetAccount') {
                $this->handle_balance($client, $message);
            }
            if ($dataType === 'V1TAErrorResponse') {
                $this->handle_error_message($client, $message);
            }
        }
    }
}
