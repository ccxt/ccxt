<?php

namespace ccxt\pro;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

use Exception; // a common import
use ccxt\BadRequest;
use ccxt\NetworkError;
use ccxt\Precise;
use React\Async;
use React\Promise\PromiseInterface;

class bingx extends \ccxt\async\bingx {

    public function describe() {
        return $this->deep_extend(parent::describe(), array(
            'has' => array(
                'ws' => true,
                'watchTrades' => true,
                'watchOrderBook' => true,
                'watchOHLCV' => true,
                'watchOrders' => true,
                'watchMyTrades' => true,
                'watchTicker' => false,
                'watchTickers' => false,
                'watchBalance' => true,
            ),
            'urls' => array(
                'api' => array(
                    'ws' => array(
                        'spot' => 'wss://open-api-ws.bingx.com/market',
                        'swap' => 'wss://open-api-swap.bingx.com/swap-market',
                    ),
                ),
            ),
            'options' => array(
                'listenKeyRefreshRate' => 3540000, // 1 hour (59 mins so we have 1min to renew the token)
                'ws' => array(
                    'gunzip' => true,
                ),
                'swap' => array(
                    'timeframes' => array(
                        '1m' => '1m',
                        '3m' => '3m',
                        '5m' => '5m',
                        '15m' => '15m',
                        '30m' => '30m',
                        '1h' => '1h',
                        '2h' => '2h',
                        '4h' => '4h',
                        '6h' => '6h',
                        '12h' => '12h',
                        '1d' => '1d',
                        '3d' => '3d',
                        '1w' => '1w',
                        '1M' => '1M',
                    ),
                ),
                'spot' => array(
                    'timeframes' => array(
                        '1m' => '1min',
                        '5m' => '5min',
                        '15m' => '15min',
                        '30m' => '30min',
                        '1h' => '60min',
                        '1d' => '1day',
                    ),
                ),
                'watchBalance' => array(
                    'fetchBalanceSnapshot' => true, // needed to be true to keep track of used and free balance
                    'awaitBalanceSnapshot' => false, // whether to wait for the balance snapshot before providing updates
                ),
            ),
            'streaming' => array(
                'keepAlive' => 1800000, // 30 minutes
            ),
        ));
    }

    public function watch_trades(string $symbol, ?int $since = null, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            /**
             * watches information on multiple $trades made in a $market
             * @see https://bingx-api.github.io/docs/#/spot/socket/market->html#Subscribe%20to%20tick-by-tick
             * @see https://bingx-api.github.io/docs/#/swapV2/socket/market->html#Subscribe%20the%20Latest%20Trade%20Detail
             * @param {string} $symbol unified $market $symbol of the $market orders were made in
             * @param {int} [$since] the earliest time in ms to fetch orders for
             * @param {int} [$limit] the maximum number of order structures to retrieve
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure
             */
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            list($marketType, $query) = $this->handle_market_type_and_params('watchTrades', $market, $params);
            $url = $this->safe_value($this->urls['api']['ws'], $marketType);
            if ($url === null) {
                throw new BadRequest($this->id . ' watchTrades is not supported for ' . $marketType . ' markets.');
            }
            $messageHash = $market['id'] . '@trade';
            $uuid = $this->uuid();
            $request = array(
                'id' => $uuid,
                'dataType' => $messageHash,
            );
            if ($marketType === 'swap') {
                $request['reqType'] = 'sub';
            }
            $trades = Async\await($this->watch($url, $messageHash, array_merge($request, $query), $messageHash));
            if ($this->newUpdates) {
                $limit = $trades->getLimit ($symbol, $limit);
            }
            return $this->filter_by_since_limit($trades, $since, $limit, 'timestamp', true);
        }) ();
    }

    public function handle_trades(Client $client, $message) {
        //
        // spot
        // first snapshot
        //
        //    {
        //      "id" => "d83b78ce-98be-4dc2-b847-12fe471b5bc5",
        //      "code" => 0,
        //      "msg" => "SUCCESS",
        //      "timestamp" => 1690214699854
        //    }
        //
        // subsequent updates
        //
        //     {
        //         "code" => 0,
        //         "data" => array(
        //           "E" => 1690214529432,
        //           "T" => 1690214529386,
        //           "e" => "trade",
        //           "m" => true,
        //           "p" => "29110.19",
        //           "q" => "0.1868",
        //           "s" => "BTC-USDT",
        //           "t" => "57903921"
        //         ),
        //         "dataType" => "BTC-USDT@trade",
        //         "success" => true
        //     }
        //
        //
        // swap
        // first snapshot
        //
        //    {
        //        "id" => "2aed93b1-6e1e-4038-aeba-f5eeaec2ca48",
        //        "code" => 0,
        //        "msg" => '',
        //        "dataType" => '',
        //        "data" => null
        //    }
        //
        // subsequent updates
        //
        //
        //    {
        //        "code" => 0,
        //        "dataType" => "BTC-USDT@trade",
        //        "data" => array(
        //            array(
        //                "q" => "0.0421",
        //                "p" => "29023.5",
        //                "T" => 1690221401344,
        //                "m" => false,
        //                "s" => "BTC-USDT"
        //            ),
        //            ...
        //        )
        //    }
        //
        $data = $this->safe_value($message, 'data', array());
        $messageHash = $this->safe_string($message, 'dataType');
        $marketId = explode('@', $messageHash)[0];
        $isSwap = mb_strpos($client->url, 'swap') !== false;
        $marketType = $isSwap ? 'swap' : 'spot';
        $market = $this->safe_market($marketId, null, null, $marketType);
        $symbol = $market['symbol'];
        $trades = null;
        if (gettype($data) === 'array' && array_keys($data) === array_keys(array_keys($data))) {
            $trades = $this->parse_trades($data, $market);
        } else {
            $trades = array( $this->parse_trade($data, $market) );
        }
        $stored = $this->safe_value($this->trades, $symbol);
        if ($stored === null) {
            $limit = $this->safe_integer($this->options, 'tradesLimit', 1000);
            $stored = new ArrayCache ($limit);
            $this->trades[$symbol] = $stored;
        }
        for ($j = 0; $j < count($trades); $j++) {
            $stored->append ($trades[$j]);
        }
        $client->resolve ($stored, $messageHash);
    }

    public function watch_order_book(string $symbol, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $limit, $params) {
            /**
             * watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
             * @see https://bingx-api.github.io/docs/#/spot/socket/market->html#Subscribe%20Market%20Depth%20Data
             * @see https://bingx-api.github.io/docs/#/swapV2/socket/market->html#Subscribe%20Market%20Depth%20Data
             * @param {string} $symbol unified $symbol of the $market to fetch the order book for
             * @param {int} [$limit] the maximum amount of order book entries to return
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} A dictionary of ~@link https://docs.ccxt.com/#/?id=order-book-structure order book structures~ indexed by $market symbols
             */
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            list($marketType, $query) = $this->handle_market_type_and_params('watchOrderBook', $market, $params);
            if ($limit === null) {
                $limit = 100;
            } else {
                if ($marketType === 'swap') {
                    if (($limit !== 5) && ($limit !== 10) && ($limit !== 20) && ($limit !== 50) && ($limit !== 100)) {
                        throw new BadRequest($this->id . ' watchOrderBook() (swap) only supports $limit 5, 10, 20, 50, and 100');
                    }
                } elseif ($marketType === 'spot') {
                    if (($limit !== 20) && ($limit !== 100)) {
                        throw new BadRequest($this->id . ' watchOrderBook() (spot) only supports $limit 20, and 100');
                    }
                }
            }
            $url = $this->safe_value($this->urls['api']['ws'], $marketType);
            if ($url === null) {
                throw new BadRequest($this->id . ' watchOrderBook is not supported for ' . $marketType . ' markets.');
            }
            $messageHash = $market['id'] . '@depth' . (string) $limit;
            $uuid = $this->uuid();
            $request = array(
                'id' => $uuid,
                'dataType' => $messageHash,
            );
            if ($marketType === 'swap') {
                $request['reqType'] = 'sub';
            }
            $orderbook = Async\await($this->watch($url, $messageHash, $this->deep_extend($request, $query), $messageHash));
            return $orderbook->limit ();
        }) ();
    }

    public function handle_delta($bookside, $delta) {
        $price = $this->safe_float($delta, 0);
        $amount = $this->safe_float($delta, 1);
        $bookside->store ($price, $amount);
    }

    public function handle_order_book(Client $client, $message) {
        //
        // spot
        //
        //
        //    {
        //        "code" => 0,
        //        "dataType" => "BTC-USDT@depth20",
        //        "data" => array(
        //          "bids" => array(
        //            array( '28852.9', "34.2621" ),
        //            ...
        //          ),
        //          "asks" => array(
        //            array( '28864.9', "23.4079" ),
        //            ...
        //          )
        //        ),
        //        "dataType" => "BTC-USDT@depth20",
        //        "success" => true
        //    }
        //
        // swap
        //
        //
        //    {
        //        "code" => 0,
        //        "dataType" => "BTC-USDT@depth20",
        //        "data" => {
        //          "bids" => array(
        //            array( '28852.9', "34.2621" ),
        //            ...
        //          ),
        //          "asks" => array(
        //            array( '28864.9', "23.4079" ),
        //            ...
        //          )
        //        }
        //    }
        //
        $data = $this->safe_value($message, 'data', array());
        $messageHash = $this->safe_string($message, 'dataType');
        $marketId = explode('@', $messageHash)[0];
        $isSwap = mb_strpos($client->url, 'swap') !== false;
        $marketType = $isSwap ? 'swap' : 'spot';
        $market = $this->safe_market($marketId, null, null, $marketType);
        $symbol = $market['symbol'];
        $orderbook = $this->safe_value($this->orderbooks, $symbol);
        if ($orderbook === null) {
            $orderbook = $this->order_book();
        }
        $snapshot = $this->parse_order_book($data, $symbol, null, 'bids', 'asks', 0, 1);
        $orderbook->reset ($snapshot);
        $this->orderbooks[$symbol] = $orderbook;
        $client->resolve ($orderbook, $messageHash);
    }

    public function parse_ws_ohlcv($ohlcv, $market = null): array {
        //
        //    {
        //        "c" => "28909.0",
        //        "o" => "28915.4",
        //        "h" => "28915.4",
        //        "l" => "28896.1",
        //        "v" => "27.6919",
        //        "T" => 1696687499999,
        //        "t" => 1696687440000
        //    }
        //
        // for spot, opening-time (t) is used instead of closing-time (T), to be compatible with fetchOHLCV
        // for swap, (T) is the opening time
        $timestamp = ($market['spot']) ? 't' : 'T';
        return array(
            $this->safe_integer($ohlcv, $timestamp),
            $this->safe_number($ohlcv, 'o'),
            $this->safe_number($ohlcv, 'h'),
            $this->safe_number($ohlcv, 'l'),
            $this->safe_number($ohlcv, 'c'),
            $this->safe_number($ohlcv, 'v'),
        );
    }

    public function handle_ohlcv(Client $client, $message) {
        //
        // spot
        //
        //   {
        //       "code" => 0,
        //       "data" => array(
        //         "E" => 1696687498608,
        //         "K" => array(
        //           "T" => 1696687499999,
        //           "c" => "27917.829",
        //           "h" => "27918.427",
        //           "i" => "1min",
        //           "l" => "27917.7",
        //           "n" => 262,
        //           "o" => "27917.91",
        //           "q" => "25715.359197",
        //           "s" => "BTC-USDT",
        //           "t" => 1696687440000,
        //           "v" => "0.921100"
        //         ),
        //         "e" => "kline",
        //         "s" => "BTC-USDT"
        //       ),
        //       "dataType" => "BTC-USDT@kline_1min",
        //       "success" => true
        //   }
        //
        // swap
        //    {
        //        "code" => 0,
        //        "dataType" => "BTC-USDT@kline_1m",
        //        "s" => "BTC-USDT",
        //        "data" => array(
        //            {
        //            "c" => "28909.0",
        //            "o" => "28915.4",
        //            "h" => "28915.4",
        //            "l" => "28896.1",
        //            "v" => "27.6919",
        //            "T" => 1690907580000
        //            }
        //        )
        //    }
        //
        $data = $this->safe_value($message, 'data', array());
        $candles = null;
        if (gettype($data) === 'array' && array_keys($data) === array_keys(array_keys($data))) {
            $candles = $data;
        } else {
            $candles = array( $this->safe_value($data, 'K', array()) );
        }
        $messageHash = $this->safe_string($message, 'dataType');
        $timeframeId = explode('_', $messageHash)[1];
        $marketId = explode('@', $messageHash)[0];
        $isSwap = mb_strpos($client->url, 'swap') !== false;
        $marketType = $isSwap ? 'swap' : 'spot';
        $market = $this->safe_market($marketId, null, null, $marketType);
        $symbol = $market['symbol'];
        $this->ohlcvs[$symbol] = $this->safe_value($this->ohlcvs, $symbol, array());
        $stored = $this->safe_value($this->ohlcvs[$symbol], $timeframeId);
        if ($stored === null) {
            $limit = $this->safe_integer($this->options, 'OHLCVLimit', 1000);
            $stored = new ArrayCacheByTimestamp ($limit);
            $this->ohlcvs[$symbol][$timeframeId] = $stored;
        }
        for ($i = 0; $i < count($candles); $i++) {
            $candle = $candles[$i];
            $parsed = $this->parse_ws_ohlcv($candle, $market);
            $stored->append ($parsed);
        }
        $client->resolve ($stored, $messageHash);
    }

    public function watch_ohlcv(string $symbol, $timeframe = '1m', ?int $since = null, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $timeframe, $since, $limit, $params) {
            /**
             * watches historical candlestick data containing the open, high, low, and close price, and the volume of a $market
             * @see https://bingx-api.github.io/docs/#/spot/socket/market->html#K%E7%BA%BF%20Streams
             * @see https://bingx-api.github.io/docs/#/swapV2/socket/market->html#Subscribe%20K-Line%20Data
             * @param {string} $symbol unified $symbol of the $market to fetch OHLCV data for
             * @param {string} $timeframe the length of time each candle represents
             * @param {int} [$since] timestamp in ms of the earliest candle to fetch
             * @param {int} [$limit] the maximum amount of candles to fetch
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {int[][]} A list of candles ordered, open, high, low, close, volume
             */
            $market = $this->market($symbol);
            list($marketType, $query) = $this->handle_market_type_and_params('watchOHLCV', $market, $params);
            $url = $this->safe_value($this->urls['api']['ws'], $marketType);
            if ($url === null) {
                throw new BadRequest($this->id . ' watchOHLCV is not supported for ' . $marketType . ' markets.');
            }
            $options = $this->safe_value($this->options, $marketType, array());
            $timeframes = $this->safe_value($options, 'timeframes', array());
            $interval = $this->safe_string($timeframes, $timeframe, $timeframe);
            $messageHash = $market['id'] . '@kline_' . $interval;
            $uuid = $this->uuid();
            $request = array(
                'id' => $uuid,
                'dataType' => $messageHash,
            );
            if ($marketType === 'swap') {
                $request['reqType'] = 'sub';
            }
            $ohlcv = Async\await($this->watch($url, $messageHash, array_merge($request, $query), $messageHash));
            if ($this->newUpdates) {
                $limit = $ohlcv->getLimit ($symbol, $limit);
            }
            return $this->filter_by_since_limit($ohlcv, $since, $limit, 0, true);
        }) ();
    }

    public function watch_orders(?string $symbol = null, ?int $since = null, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            /**
             * @see https://bingx-api.github.io/docs/#/spot/socket/account.html#Subscription%20order%20update%20data
             * @see https://bingx-api.github.io/docs/#/swapV2/socket/account.html#Account%20balance%20and%20position%20update%20push
             * watches information on multiple $orders made by the user
             * @param {string} $symbol unified $market $symbol of the $market $orders were made in
             * @param {int} [$since] the earliest time in ms to fetch $orders for
             * @param {int} [$limit] the maximum number of order structures to retrieve
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array[]} a list of ~@link https://docs.ccxt.com/#/?id=order-structure order structures~
             */
            Async\await($this->load_markets());
            Async\await($this->authenticate());
            $type = null;
            $market = null;
            if ($symbol !== null) {
                $market = $this->market($symbol);
                $symbol = $market['symbol'];
            }
            list($type, $params) = $this->handle_market_type_and_params('watchOrders', $market, $params);
            $isSpot = ($type === 'spot');
            $spotHash = 'spot:private';
            $swapHash = 'swap:private';
            $subscriptionHash = $isSpot ? $spotHash : $swapHash;
            $spotMessageHash = 'spot:order';
            $swapMessageHash = 'swap:order';
            $messageHash = $isSpot ? $spotMessageHash : $swapMessageHash;
            if ($market !== null) {
                $messageHash .= ':' . $symbol;
            }
            $url = $this->urls['api']['ws'][$type] . '?listenKey=' . $this->options['listenKey'];
            $request = null;
            $uuid = $this->uuid();
            if ($isSpot) {
                $request = array(
                    'id' => $uuid,
                    'dataType' => 'spot.executionReport',
                );
            }
            $orders = Async\await($this->watch($url, $messageHash, $request, $subscriptionHash));
            if ($this->newUpdates) {
                $limit = $orders->getLimit ($symbol, $limit);
            }
            return $this->filter_by_symbol_since_limit($orders, $symbol, $since, $limit, true);
        }) ();
    }

    public function watch_my_trades(?string $symbol = null, ?int $since = null, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            /**
             * @see https://bingx-api.github.io/docs/#/spot/socket/account.html#Subscription%20order%20update%20data
             * @see https://bingx-api.github.io/docs/#/swapV2/socket/account.html#Account%20balance%20and%20position%20update%20push
             * watches information on multiple $trades made by the user
             * @param {string} $symbol unified $market $symbol of the $market $trades were made in
             * @param {int} [$since] the earliest time in ms to $trades orders for
             * @param {int} [$limit] the maximum number of $trades structures to retrieve
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure
             */
            Async\await($this->load_markets());
            Async\await($this->authenticate());
            $type = null;
            $market = null;
            if ($symbol !== null) {
                $market = $this->market($symbol);
                $symbol = $market['symbol'];
            }
            list($type, $params) = $this->handle_market_type_and_params('watchOrders', $market, $params);
            $isSpot = ($type === 'spot');
            $spotSubHash = 'spot:private';
            $swapSubHash = 'swap:private';
            $subscriptionHash = $isSpot ? $spotSubHash : $swapSubHash;
            $spotMessageHash = 'spot:mytrades';
            $swapMessageHash = 'swap:mytrades';
            $messageHash = $isSpot ? $spotMessageHash : $swapMessageHash;
            if ($market !== null) {
                $messageHash .= ':' . $symbol;
            }
            $url = $this->urls['api']['ws'][$type] . '?listenKey=' . $this->options['listenKey'];
            $request = null;
            $uuid = $this->uuid();
            if ($isSpot) {
                $request = array(
                    'id' => $uuid,
                    'dataType' => 'spot.executionReport',
                );
            }
            $trades = Async\await($this->watch($url, $messageHash, $request, $subscriptionHash));
            if ($this->newUpdates) {
                $limit = $trades->getLimit ($symbol, $limit);
            }
            return $this->filter_by_symbol_since_limit($trades, $symbol, $since, $limit, true);
        }) ();
    }

    public function watch_balance($params = array ()): PromiseInterface {
        return Async\async(function () use ($params) {
            /**
             * @see https://bingx-api.github.io/docs/#/spot/socket/account.html#Subscription%20order%20update%20data
             * @see https://bingx-api.github.io/docs/#/swapV2/socket/account.html#Account%20balance%20and%20position%20update%20push
             * query for balance and get the amount of funds available for trading or funds locked in orders
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} a ~@link https://docs.ccxt.com/#/?id=balance-structure balance structure~
             */
            Async\await($this->load_markets());
            Async\await($this->authenticate());
            $type = null;
            list($type, $params) = $this->handle_market_type_and_params('watchBalance', null, $params);
            $isSpot = ($type === 'spot');
            $spotSubHash = 'spot:balance';
            $swapSubHash = 'swap:private';
            $spotMessageHash = 'spot:balance';
            $swapMessageHash = 'swap:balance';
            $messageHash = $isSpot ? $spotMessageHash : $swapMessageHash;
            $subscriptionHash = $isSpot ? $spotSubHash : $swapSubHash;
            $url = $this->urls['api']['ws'][$type] . '?listenKey=' . $this->options['listenKey'];
            $request = null;
            $uuid = $this->uuid();
            if ($type === 'spot') {
                $request = array(
                    'id' => $uuid,
                    'dataType' => 'ACCOUNT_UPDATE',
                );
            }
            $client = $this->client($url);
            $this->set_balance_cache($client, $type, $subscriptionHash, $params);
            $fetchBalanceSnapshot = null;
            $awaitBalanceSnapshot = null;
            list($fetchBalanceSnapshot, $params) = $this->handle_option_and_params($params, 'watchBalance', 'fetchBalanceSnapshot', true);
            list($awaitBalanceSnapshot, $params) = $this->handle_option_and_params($params, 'watchBalance', 'awaitBalanceSnapshot', false);
            if ($fetchBalanceSnapshot && $awaitBalanceSnapshot) {
                Async\await($client->future ($type . ':fetchBalanceSnapshot'));
            }
            return Async\await($this->watch($url, $messageHash, $request, $subscriptionHash));
        }) ();
    }

    public function set_balance_cache(Client $client, $type, $subscriptionHash, $params) {
        if (is_array($client->subscriptions) && array_key_exists($subscriptionHash, $client->subscriptions)) {
            return null;
        }
        $fetchBalanceSnapshot = $this->handle_option_and_params($params, 'watchBalance', 'fetchBalanceSnapshot', true);
        if ($fetchBalanceSnapshot) {
            $messageHash = $type . ':fetchBalanceSnapshot';
            if (!(is_array($client->futures) && array_key_exists($messageHash, $client->futures))) {
                $client->future ($messageHash);
                $this->spawn(array($this, 'load_balance_snapshot'), $client, $messageHash, $type);
            }
        } else {
            $this->balance[$type] = array();
        }
    }

    public function load_balance_snapshot($client, $messageHash, $type) {
        return Async\async(function () use ($client, $messageHash, $type) {
            $response = Async\await($this->fetch_balance(array( 'type' => $type )));
            $this->balance[$type] = array_merge($response, $this->safe_value($this->balance, $type, array()));
            // don't remove the $future from the .futures cache
            $future = $client->futures[$messageHash];
            $future->resolve ();
            $client->resolve ($this->balance[$type], $type . ':balance');
        }) ();
    }

    public function handle_error_message($client, $message) {
        //
        // array( $code => 100400, msg => '', timestamp => 1696245808833 )
        //
        // {
        //     "code" => 100500,
        //     "id" => "9cd37d32-da98-440b-bd04-37e7dbcf51ad",
        //     "msg" => '',
        //     "timestamp" => 1696245842307
        // }
        $code = $this->safe_string($message, 'code');
        try {
            if ($code !== null) {
                $feedback = $this->id . ' ' . $this->json($message);
                $this->throw_exactly_matched_exception($this->exceptions['exact'], $code, $feedback);
            }
        } catch (Exception $e) {
            $client->reject ($e);
        }
        return true;
    }

    public function authenticate($params = array ()) {
        return Async\async(function () use ($params) {
            $time = $this->milliseconds();
            $listenKey = $this->safe_string($this->options, 'listenKey');
            if ($listenKey === null) {
                $response = Async\await($this->userAuthPrivatePostUserDataStream ());
                $this->options['listenKey'] = $this->safe_string($response, 'listenKey');
                $this->options['lastAuthenticatedTime'] = $time;
                return;
            }
            $lastAuthenticatedTime = $this->safe_integer($this->options, 'lastAuthenticatedTime', 0);
            $listenKeyRefreshRate = $this->safe_integer($this->options, 'listenKeyRefreshRate', 3600000); // 1 hour
            if ($time - $lastAuthenticatedTime > $listenKeyRefreshRate) {
                $response = Async\await($this->userAuthPrivatePutUserDataStream (array( 'listenKey' => $listenKey ))); // extend the expiry
                $this->options['listenKey'] = $this->safe_string($response, 'listenKey');
                $this->options['lastAuthenticatedTime'] = $time;
            }
        }) ();
    }

    public function pong($client, $message) {
        return Async\async(function () use ($client, $message) {
            //
            // spot
            // {
            //     "ping" => "5963ba3db76049b2870f9a686b2ebaac",
            //     "time" => "2023-10-02T18:51:55.089+0800"
            // }
            // swap
            // Ping
            //
            try {
                if ($message === 'Ping') {
                    Async\await($client->send ('Pong'));
                } else {
                    $ping = $this->safe_string($message, 'ping');
                    $time = $this->safe_string($message, 'time');
                    Async\await($client->send (array(
                        'pong' => $ping,
                        'time' => $time,
                    )));
                }
            } catch (Exception $e) {
                $error = new NetworkError ($this->id . ' pong failed with $error ' . $this->json($e));
                $client->reset ($error);
            }
        }) ();
    }

    public function handle_order($client, $message) {
        //
        //     {
        //         "code" => 0,
        //         "dataType" => "spot.executionReport",
        //         "data" => {
        //            "e" => "executionReport",
        //            "E" => 1694680212947,
        //            "s" => "LTC-USDT",
        //            "S" => "BUY",
        //            "o" => "LIMIT",
        //            "q" => 0.1,
        //            "p" => 50,
        //            "x" => "NEW",
        //            "X" => "PENDING",
        //            "i" => 1702238305204043800,
        //            "l" => 0,
        //            "z" => 0,
        //            "L" => 0,
        //            "n" => 0,
        //            "N" => "",
        //            "T" => 0,
        //            "t" => 0,
        //            "O" => 1694680212676,
        //            "Z" => 0,
        //            "Y" => 0,
        //            "Q" => 0,
        //            "m" => false
        //         }
        //      }
        //
        //      {
        //         "code" => 0,
        //         "dataType" => "spot.executionReport",
        //         "data" => {
        //           "e" => "executionReport",
        //           "E" => 1694681809302,
        //           "s" => "LTC-USDT",
        //           "S" => "BUY",
        //           "o" => "MARKET",
        //           "q" => 0,
        //           "p" => 62.29,
        //           "x" => "TRADE",
        //           "X" => "FILLED",
        //           "i" => "1702245001712369664",
        //           "l" => 0.0802,
        //           "z" => 0.0802,
        //           "L" => 62.308,
        //           "n" => -0.0000802,
        //           "N" => "LTC",
        //           "T" => 1694681809256,
        //           "t" => 38259147,
        //           "O" => 1694681809248,
        //           "Z" => 4.9971016,
        //           "Y" => 4.9971016,
        //           "Q" => 5,
        //           "m" => false
        //         }
        //       }
        // swap
        //    {
        //        "e" => "ORDER_TRADE_UPDATE",
        //        "E" => 1696843635475,
        //        "o" => {
        //           "s" => "LTC-USDT",
        //           "c" => "",
        //           "i" => "1711312357852147712",
        //           "S" => "BUY",
        //           "o" => "MARKET",
        //           "q" => "0.10000000",
        //           "p" => "64.35010000",
        //           "ap" => "64.36000000",
        //           "x" => "TRADE",
        //           "X" => "FILLED",
        //           "N" => "USDT",
        //           "n" => "-0.00321800",
        //           "T" => 0,
        //           "wt" => "MARK_PRICE",
        //           "ps" => "LONG",
        //           "rp" => "0.00000000",
        //           "z" => "0.10000000"
        //        }
        //    }
        //
        $isSpot = (is_array($message) && array_key_exists('dataType', $message));
        $data = $this->safe_value_2($message, 'data', 'o', array());
        if ($this->orders === null) {
            $limit = $this->safe_integer($this->options, 'ordersLimit', 1000);
            $this->orders = new ArrayCacheBySymbolById ($limit);
        }
        $stored = $this->orders;
        $parsedOrder = $this->parse_order($data);
        $stored->append ($parsedOrder);
        $symbol = $parsedOrder['symbol'];
        $spotHash = 'spot:order';
        $swapHash = 'swap:order';
        $messageHash = ($isSpot) ? $spotHash : $swapHash;
        $client->resolve ($stored, $messageHash);
        $client->resolve ($stored, $messageHash . ':' . $symbol);
    }

    public function handle_my_trades(Client $client, $message) {
        //
        //
        //      {
        //         "code" => 0,
        //         "dataType" => "spot.executionReport",
        //         "data" => {
        //           "e" => "executionReport",
        //           "E" => 1694681809302,
        //           "s" => "LTC-USDT",
        //           "S" => "BUY",
        //           "o" => "MARKET",
        //           "q" => 0,
        //           "p" => 62.29,
        //           "x" => "TRADE",
        //           "X" => "FILLED",
        //           "i" => "1702245001712369664",
        //           "l" => 0.0802,
        //           "z" => 0.0802,
        //           "L" => 62.308,
        //           "n" => -0.0000802,
        //           "N" => "LTC",
        //           "T" => 1694681809256,
        //           "t" => 38259147,
        //           "O" => 1694681809248,
        //           "Z" => 4.9971016,
        //           "Y" => 4.9971016,
        //           "Q" => 5,
        //           "m" => false
        //         }
        //       }
        //
        //  swap
        //    {
        //        "e" => "ORDER_TRADE_UPDATE",
        //        "E" => 1696843635475,
        //        "o" => {
        //           "s" => "LTC-USDT",
        //           "c" => "",
        //           "i" => "1711312357852147712",
        //           "S" => "BUY",
        //           "o" => "MARKET",
        //           "q" => "0.10000000",
        //           "p" => "64.35010000",
        //           "ap" => "64.36000000",
        //           "x" => "TRADE",
        //           "X" => "FILLED",
        //           "N" => "USDT",
        //           "n" => "-0.00321800",
        //           "T" => 0,
        //           "wt" => "MARK_PRICE",
        //           "ps" => "LONG",
        //           "rp" => "0.00000000",
        //           "z" => "0.10000000"
        //        }
        //    }
        //
        $isSpot = (is_array($message) && array_key_exists('dataType', $message));
        $result = $this->safe_value_2($message, 'data', 'o', array());
        $cachedTrades = $this->myTrades;
        if ($cachedTrades === null) {
            $limit = $this->safe_integer($this->options, 'tradesLimit', 1000);
            $cachedTrades = new ArrayCacheBySymbolById ($limit);
            $this->myTrades = $cachedTrades;
        }
        $parsed = $this->parse_trade($result);
        $symbol = $parsed['symbol'];
        $spotHash = 'spot:mytrades';
        $swapHash = 'swap:mytrades';
        $messageHash = $isSpot ? $spotHash : $swapHash;
        $cachedTrades->append ($parsed);
        $client->resolve ($cachedTrades, $messageHash);
        $client->resolve ($cachedTrades, $messageHash . ':' . $symbol);
    }

    public function handle_balance(Client $client, $message) {
        // spot
        //     {
        //         "e":"ACCOUNT_UPDATE",
        //         "E":1696242817000,
        //         "T":1696242817142,
        //         "a":{
        //            "B":array(
        //               {
        //                  "a":"USDT",
        //                  "bc":"-1.00000000000000000000",
        //                  "cw":"86.59497382000000050000",
        //                  "wb":"86.59497382000000050000"
        //               }
        //            ),
        //            "m":"ASSET_TRANSFER"
        //         }
        //     }
        // swap
        //     {
        //         "e":"ACCOUNT_UPDATE",
        //         "E":1696244249320,
        //         "a":{
        //            "m":"WITHDRAW",
        //            "B":array(
        //               {
        //                  "a":"USDT",
        //                  "wb":"49.81083984",
        //                  "cw":"49.81083984",
        //                  "bc":"-1.00000000"
        //               }
        //            ),
        //            "P":array(
        //            )
        //         }
        //     }
        //
        $a = $this->safe_value($message, 'a', array());
        $data = $this->safe_value($a, 'B', array());
        $timestamp = $this->safe_integer_2($message, 'T', 'E');
        $type = (is_array($a) && array_key_exists('P', $a)) ? 'swap' : 'spot';
        $this->balance[$type]['info'] = $data;
        $this->balance[$type]['timestamp'] = $timestamp;
        $this->balance[$type]['datetime'] = $this->iso8601($timestamp);
        for ($i = 0; $i < count($data); $i++) {
            $balance = $data[$i];
            $currencyId = $this->safe_string($balance, 'a');
            $code = $this->safe_currency_code($currencyId);
            $account = (is_array($this->balance[$type]) && array_key_exists($code, $this->balance[$type])) ? $this->balance[$type][$code] : $this->account();
            $account['free'] = $this->safe_string($balance, 'wb');
            $balanceChange = $this->safe_string($balance, 'bc');
            if ($account['used'] !== null) {
                $account['used'] = Precise::string_sub($this->safe_string($account, 'used'), $balanceChange);
            }
            $this->balance[$type][$code] = $account;
        }
        $this->balance[$type] = $this->safe_balance($this->balance[$type]);
        $client->resolve ($this->balance[$type], $type . ':balance');
    }

    public function handle_message(Client $client, $message) {
        if (!$this->handle_error_message($client, $message)) {
            return;
        }
        // public subscriptions
        if (($message === 'Ping') || (is_array($message) && array_key_exists('ping', $message))) {
            $this->spawn(array($this, 'pong'), $client, $message);
            return;
        }
        $dataType = $this->safe_string($message, 'dataType', '');
        if (mb_strpos($dataType, '@depth') !== false) {
            $this->handle_order_book($client, $message);
            return;
        }
        if (mb_strpos($dataType, '@trade') !== false) {
            $this->handle_trades($client, $message);
            return;
        }
        if (mb_strpos($dataType, '@kline') !== false) {
            $this->handle_ohlcv($client, $message);
            return;
        }
        if (mb_strpos($dataType, 'executionReport') !== false) {
            $data = $this->safe_value($message, 'data', array());
            $type = $this->safe_string($data, 'x');
            if ($type === 'TRADE') {
                $this->handle_my_trades($client, $message);
            }
            $this->handle_order($client, $message);
            return;
        }
        $e = $this->safe_string($message, 'e');
        if ($e === 'ACCOUNT_UPDATE') {
            $this->handle_balance($client, $message);
        }
        if ($e === 'ORDER_TRADE_UPDATE') {
            $this->handle_order($client, $message);
            $data = $this->safe_value($message, 'o', array());
            $type = $this->safe_string($data, 'x');
            $status = $this->safe_string($data, 'X');
            if (($type === 'TRADE') && ($status === 'FILLED')) {
                $this->handle_my_trades($client, $message);
            }
        }
    }
}
