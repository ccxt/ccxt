<?php

namespace ccxt\pro;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

use Exception; // a common import
use ccxt\ExchangeError;
use ccxt\ArgumentsRequired;
use ccxt\Precise;
use \React\Async;
use \React\Promise\PromiseInterface;

class bydfi extends \ccxt\async\bydfi {

    public function describe(): mixed {
        return $this->deep_extend(parent::describe(), array(
            'has' => array(
                'ws' => true,
                'watchBalance' => true,
                'watchBidsAsks' => false,
                'watchMyTrades' => false,
                'watchOHLCV' => true,
                'watchOHLCVForSymbols' => true,
                'watchOrderBook' => true,
                'watchOrderBookForSymbols' => true,
                'watchOrders' => true,
                'watchOrdersForSymbols' => true,
                'watchPositions' => true,
                'watchTicker' => true,
                'watchTickers' => true,
                'watchTrades' => false,
                'watchTradesForSymbols' => false,
                'unwatchBidsAsks' => false,
                'unwatchOHLCV' => true,
                'unwatchOHLCVForSymbols' => true,
                'unwatchOrderBook' => true,
                'unwatchOrderBookForSymbols' => true,
                'unwatchTicker' => true,
                'unwatchTickers' => true,
                'unWatchTrades' => false,
                'unWatchTradesForSymbols' => false,
                'unWatchOrders' => false,
                'unWatchOrdersForSymbols' => false,
                'unWatchPositions' => false,
            ),
            'urls' => array(
                'api' => array(
                    'ws' => 'wss://stream.bydfi.com/v1/public/swap',
                ),
            ),
            'options' => array(
                'watchOrderBookForSymbols' => array(
                    'depth' => '100', // 10, 50, 100
                    'frequency' => '1000ms', // 100ms, 1000ms
                ),
                'watchBalance' => array(
                    'fetchBalanceSnapshot' => false, // or true
                    'awaitBalanceSnapshot' => true, // whether to wait for the balance snapshot before providing updates
                ),
                'timeframes' => array(
                    '1m' => '1m',
                    '3m' => '3m',
                    '5m' => '5m',
                    '15m' => '15m',
                    '30m' => '30m',
                    '1h' => '1h',
                    '2h' => '2h',
                    '4h' => '4h',
                    '6h' => '6h',
                    '8h' => '8h',
                    '12h' => '12h',
                    '1d' => '1d',
                    '1w' => '1w',
                    '1M' => '1M',
                ),
            ),
            'streaming' => array(
                'ping' => array($this, 'ping'),
                'keepAlive' => 119000, // 2 minutes
            ),
        ));
    }

    public function ping(Client $client) {
        return array(
            'id' => $this->request_id(),
            'method' => 'ping',
        );
    }

    public function request_id() {
        $this->lock_id();
        $reqid = $this->sum($this->safe_integer($this->options, 'reqid', 0), 1);
        $this->options['reqid'] = $reqid;
        $this->unlock_id();
        return $reqid;
    }

    public function watch_public($messageHashes, $channels, $params = array (), $subscription = array ()) {
        return Async\async(function () use ($messageHashes, $channels, $params, $subscription) {
            $url = $this->urls['api']['ws'];
            $id = $this->request_id();
            $subscriptionParams = array(
                'id' => $id,
            );
            $unsubscribe = $this->safe_bool($params, 'unsubscribe', false);
            $method = 'SUBSCRIBE';
            if ($unsubscribe) {
                $method = 'UNSUBSCRIBE';
                $params = $this->omit($params, 'unsubscribe');
                $subscriptionParams['unsubscribe'] = true;
                $subscriptionParams['messageHashes'] = $messageHashes;
            }
            $message = array(
                'id' => $id,
                'method' => $method,
                'params' => $channels,
            );
            return Async\await($this->watch_multiple($url, $messageHashes, $this->deep_extend($message, $params), $messageHashes, $this->extend($subscriptionParams, $subscription)));
        }) ();
    }

    public function watch_private($messageHashes, $params = array ()) {
        return Async\async(function () use ($messageHashes, $params) {
            $this->check_required_credentials();
            $url = $this->urls['api']['ws'];
            $subHash = 'private';
            $client = $this->client($url);
            $privateSubscription = $this->safe_value($client->subscriptions, $subHash);
            $subscription = array();
            if ($privateSubscription === null) {
                $id = $this->request_id();
                $timestamp = (string) $this->milliseconds();
                $payload = $this->apiKey . $timestamp;
                $signature = $this->hmac($this->encode($payload), $this->encode($this->secret), 'sha256', 'hex');
                $request = array(
                    'id' => $id,
                    'method' => 'LOGIN',
                    'params' => array(
                        'apiKey' => $this->apiKey,
                        'timestamp' => $timestamp,
                        'sign' => $signature,
                    ),
                );
                $params = $this->deep_extend($request, $params);
                $subscription['id'] = $id;
            }
            return Async\await($this->watch_multiple($url, $messageHashes, $params, array( 'private' ), $subscription));
        }) ();
    }

    public function watch_ticker(string $symbol, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $params) {
            /**
             * watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific $market
             *
             * @see https://developers.bydfi.com/en/swap/websocket-$market#ticker-by-$symbol
             *
             * @param {string} $symbol unified $symbol of the $market to fetch the ticker for
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} a ~@link https://docs.ccxt.com/?id=ticker-structure ticker structure~
             */
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $marketId = $market['id'];
            $messageHash = 'ticker::' . $symbol;
            $channel = $marketId . '@ticker';
            return Async\await($this->watch_public(array( $messageHash ), array( $channel ), $params));
        }) ();
    }

    public function un_watch_ticker(string $symbol, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $params) {
            /**
             * unWatches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
             *
             * @see https://developers.bydfi.com/en/swap/websocket-market#ticker-by-$symbol
             *
             * @param {string} $symbol unified $symbol of the market to fetch the ticker for
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} a ~@link https://docs.ccxt.com/?id=ticker-structure ticker structure~
             */
            return Async\await($this->un_watch_tickers(array( $symbol ), $params));
        }) ();
    }

    public function watch_tickers(?array $symbols = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbols, $params) {
            /**
             * watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for all markets of a specific list
             *
             * @see https://developers.bydfi.com/en/swap/websocket-market#ticker-by-$symbol
             * @see https://developers.bydfi.com/en/swap/websocket-market#market-wide-ticker
             *
             * @param {string[]} $symbols unified $symbol of the market to fetch the ticker for
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} a ~@link https://docs.ccxt.com/?id=ticker-structure ticker structure~
             */
            Async\await($this->load_markets());
            $symbols = $this->market_symbols($symbols, null, true);
            $messageHashes = array();
            $messageHash = 'ticker::';
            $channels = array();
            $channel = '@ticker';
            if ($symbols === null) {
                $messageHashes[] = $messageHash . 'all';
                $channels[] = '!ticker@arr';
            } else {
                for ($i = 0; $i < count($symbols); $i++) {
                    $symbol = $symbols[$i];
                    $marketId = $this->market_id($symbol);
                    $messageHashes[] = $messageHash . $symbol;
                    $channels[] = $marketId . $channel;
                }
            }
            Async\await($this->watch_public($messageHashes, $channels, $params));
            return $this->filter_by_array($this->tickers, 'symbol', $symbols);
        }) ();
    }

    public function un_watch_tickers(?array $symbols = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbols, $params) {
            /**
             * unWatches a price ticker, a statistical calculation with the information calculated over the past 24 hours for all markets of a specific list
             *
             * @see https://developers.bydfi.com/en/swap/websocket-market#ticker-by-$symbol
             * @see https://developers.bydfi.com/en/swap/websocket-market#market-wide-ticker
             *
             * @param {string[]} $symbols unified $symbol of the market to fetch the ticker for
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} a ~@link https://docs.ccxt.com/?id=ticker-structure ticker structure~
             */
            $symbols = $this->market_symbols($symbols, null, true);
            $messageHashes = array();
            $messageHash = 'unsubscribe::ticker::';
            $channels = array();
            $channel = '@ticker';
            $subscription = array(
                'topic' => 'ticker',
            );
            if ($symbols === null) {
                // all tickers and tickers for specific $symbols are different $channels
                // we need to unsubscribe from all ticker $channels
                $subHashes = $this->get_message_hashes_for_tickers_unsubscription();
                $subscription['subHashIsPrefix'] = true;
                for ($i = 0; $i < count($subHashes); $i++) {
                    $subHash = $this->safe_string($subHashes, $i);
                    if ($subHash !== null) {
                        $parts = explode('::', $subHash);
                        $symbol = $this->safe_string($parts, 1);
                        if ($symbol === 'all') {
                            continue;
                        }
                        $marketId = $this->market_id($symbol);
                        $channels[] = $marketId . $channel;
                    }
                }
                $messageHashes[] = $messageHash;
                $channels[] = '!ticker@arr';
            } else {
                for ($i = 0; $i < count($symbols); $i++) {
                    $symbol = $symbols[$i];
                    $marketId = $this->market_id($symbol);
                    $messageHashes[] = $messageHash . $symbol;
                    $channels[] = $marketId . $channel;
                }
                $subscription['symbols'] = $symbols;
            }
            $params = $this->extend($params, array( 'unsubscribe' => true ));
            return Async\await($this->watch_public($messageHashes, $channels, $params, $subscription));
        }) ();
    }

    public function get_message_hashes_for_tickers_unsubscription() {
        $url = $this->urls['api']['ws']['public'];
        $client = $this->client($url);
        $subscriptions = $client->subscriptions;
        $messageHashes = array();
        $keys = is_array($subscriptions) ? array_keys($subscriptions) : array();
        for ($i = 0; $i < count($keys); $i++) {
            $key = $keys[$i];
            if (mb_strpos($key, 'ticker::') === 0) {
                $messageHashes[] = $key;
            }
        }
        return $messageHashes;
    }

    public function handle_ticker(Client $client, $message) {
        //
        //     {
        //         "s" => "KAS-USDT",
        //         "c" => 0.04543,
        //         "e" => "24hrTicker",
        //         "E" => 1766528295905,
        //         "v" => 98278925,
        //         "h" => 0.04685,
        //         "l" => 0.04404,
        //         "o" => 0.04657
        //     }
        //
        $ticker = $this->parse_ticker($message);
        $symbol = $ticker['symbol'];
        $messageHash = 'ticker::' . $symbol;
        $this->tickers[$symbol] = $ticker;
        $client->resolve ($this->tickers[$symbol], $messageHash);
        $client->resolve ($this->tickers, 'ticker::all');
    }

    public function watch_ohlcv(string $symbol, $timeframe = '1m', ?int $since = null, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $timeframe, $since, $limit, $params) {
            /**
             * watches historical candlestick data containing the open, high, low, close price, and the volume of a market
             *
             * @see https://developers.bydfi.com/en/swap/websocket-market#candlestick-data
             *
             * @param {string} $symbol unified $symbol of the market to fetch OHLCV data for
             * @param {string} $timeframe the length of time each candle represents
             * @param {int} [$since] timestamp in ms of the earliest candle to fetch
             * @param {int} [$limit] the maximum amount of candles to fetch
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {int[][]} A list of candles ordered, open, high, low, close, volume
             */
            $result = Async\await($this->watch_ohlcv_for_symbols(array( array( $symbol, $timeframe ) ), $since, $limit, $params));
            return $result[$symbol][$timeframe];
        }) ();
    }

    public function un_watch_ohlcv(string $symbol, string $timeframe = '1m', $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $timeframe, $params) {
            /**
             * watches historical candlestick data containing the open, high, low, and close price, and the volume of a market
             *
             * @see https://developers.bydfi.com/en/swap/websocket-market#candlestick-data
             *
             * @param {string} $symbol unified $symbol of the market to fetch OHLCV data for
             * @param {string} $timeframe the length of time each candle represents
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {int[][]} A list of candles ordered, open, high, low, close, volume
             */
            return Async\await($this->un_watch_ohlcv_for_symbols(array( array( $symbol, $timeframe ) ), $params));
        }) ();
    }

    public function watch_ohlcv_for_symbols(array $symbolsAndTimeframes, ?int $since = null, ?int $limit = null, $params = array ()) {
        return Async\async(function () use ($symbolsAndTimeframes, $since, $limit, $params) {
            /**
             * watches historical candlestick data containing the open, high, low, close price, and the volume of a $market
             *
             * @see https://developers.bydfi.com/en/swap/websocket-$market#candlestick-data
             *
             * @param {string[][]} $symbolsAndTimeframes array of arrays containing unified symbols and $timeframes to fetch OHLCV data for, example [['BTC/USDT', '1m'], ['LTC/USDT', '5m']]
             * @param {int} [$since] timestamp in ms of the earliest candle to fetch
             * @param {int} [$limit] the maximum amount of $candles to fetch
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {int[][]} A list of $candles ordered, open, high, low, close, volume
             */
            $symbolsLength = count($symbolsAndTimeframes);
            if ($symbolsLength === 0 || (gettype($symbolsAndTimeframes[0]) !== 'array' || array_keys($symbolsAndTimeframes[0]) !== array_keys(array_keys($symbolsAndTimeframes[0])))) {
                throw new ArgumentsRequired($this->id . " watchOHLCVForSymbols() requires a an array of symbols and $timeframes, like  ['ETH/USDC', '1m']");
            }
            Async\await($this->load_markets());
            $channels = array();
            $messageHashes = array();
            for ($i = 0; $i < count($symbolsAndTimeframes); $i++) {
                $symbolAndTimeframe = $symbolsAndTimeframes[$i];
                $marketId = $this->safe_string($symbolAndTimeframe, 0);
                $market = $this->market($marketId);
                $tf = $this->safe_string($symbolAndTimeframe, 1);
                $timeframes = $this->safe_dict($this->options, 'timeframes', array());
                $interval = $this->safe_string($timeframes, $tf, $tf);
                $channels[] = $market['id'] . '@kline_' . $interval;
                $messageHashes[] = 'ohlcv::' . $market['symbol'] . '::' . $interval;
            }
            list($symbol, $timeframe, $candles) = Async\await($this->watch_public($messageHashes, $channels, $params));
            if ($this->newUpdates) {
                $limit = $candles->getLimit ($symbol, $limit);
            }
            $filtered = $this->filter_by_since_limit($candles, $since, $limit, 0, true);
            return $this->create_ohlcv_object($symbol, $timeframe, $filtered);
        }) ();
    }

    public function un_watch_ohlcv_for_symbols(array $symbolsAndTimeframes, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbolsAndTimeframes, $params) {
            /**
             * unWatches historical candlestick data containing the open, high, low, and close price, and the volume of a $market
             *
             * @see https://developers.bydfi.com/en/swap/websocket-$market#candlestick-data
             *
             * @param {string[][]} $symbolsAndTimeframes array of arrays containing unified symbols and timeframes to fetch OHLCV data for, example [['BTC/USDT', '1m'], ['LTC/USDT', '5m']]
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {int[][]} A list of candles ordered, open, high, low, close, volume
             */
            $symbolsLength = count($symbolsAndTimeframes);
            if ($symbolsLength === 0 || (gettype($symbolsAndTimeframes[0]) !== 'array' || array_keys($symbolsAndTimeframes[0]) !== array_keys(array_keys($symbolsAndTimeframes[0])))) {
                throw new ArgumentsRequired($this->id . " unWatchOHLCVForSymbols() requires a an array of symbols and timeframes, like  ['ETH/USDC', '1m']");
            }
            Async\await($this->load_markets());
            $channels = array();
            $messageHashes = array();
            for ($i = 0; $i < count($symbolsAndTimeframes); $i++) {
                $symbolAndTimeframe = $symbolsAndTimeframes[$i];
                $marketId = $this->safe_string($symbolAndTimeframe, 0);
                $market = $this->market($marketId);
                $tf = $this->safe_string($symbolAndTimeframe, 1);
                $interval = $this->safe_string($this->timeframes, $tf, $tf);
                $channels[] = $market['id'] . '@kline_' . $interval;
                $messageHashes[] = 'unsubscribe::ohlcv::' . $market['symbol'] . '::' . $interval;
            }
            $params = $this->extend($params, array( 'unsubscribe' => true ));
            $subscription = array(
                'topic' => 'ohlcv',
                'symbolsAndTimeframes' => $symbolsAndTimeframes,
            );
            return Async\await($this->watch_public($messageHashes, $channels, $params, $subscription));
        }) ();
    }

    public function handle_ohlcv(Client $client, $message) {
        //
        //     {
        //         "s" => "ETH-USDC",
        //         "c" => 2956.13,
        //         "t" => 1766506860000,
        //         "T" => 1766506920000,
        //         "e" => "kline",
        //         "v" => 3955,
        //         "h" => 2956.41,
        //         "i" => "1m",
        //         "l" => 2956.05,
        //         "o" => 2956.05
        //     }
        //
        $marketId = $this->safe_string($message, 's');
        $market = $this->safe_market($marketId);
        $symbol = $market['symbol'];
        $interval = $this->safe_string($message, 'i');
        $timeframes = $this->safe_dict($this->options, 'timeframes', array());
        $timeframe = $this->find_timeframe($interval, $timeframes);
        if (!(is_array($this->ohlcvs) && array_key_exists($symbol, $this->ohlcvs))) {
            $this->ohlcvs[$symbol] = array();
        }
        if (!(is_array($this->ohlcvs[$symbol]) && array_key_exists($timeframe, $this->ohlcvs[$symbol]))) {
            $limit = $this->safe_integer($this->options, 'OHLCVLimit', 1000);
            $stored = new ArrayCacheByTimestamp ($limit);
            $this->ohlcvs[$symbol][$timeframe] = $stored;
        }
        $ohlcv = $this->ohlcvs[$symbol][$timeframe];
        $parsed = $this->parse_ws_ohlcv($message);
        $ohlcv->append ($parsed);
        $messageHash = 'ohlcv::' . $symbol . '::' . $timeframe;
        $client->resolve (array( $symbol, $timeframe, $ohlcv ), $messageHash);
    }

    public function watch_order_book(string $symbol, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $limit, $params) {
            /**
             * watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
             *
             * @see https://developers.bydfi.com/en/swap/websocket-market#limited-depth-information
             *
             * @param {string} $symbol unified $symbol of the market to fetch the order book for
             * @param {int} [$limit] the maximum amount of order book entries to return (default and maxi is 100)
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} A dictionary of ~@link https://docs.ccxt.com/?id=order-book-structure order book structures~ indexed by market symbols
             */
            return Async\await($this->watch_order_book_for_symbols(array( $symbol ), $limit, $params));
        }) ();
    }

    public function un_watch_order_book(string $symbol, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $params) {
            /**
             * unWatches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
             *
             * @see https://developers.bydfi.com/en/swap/websocket-market#limited-depth-information
             *
             * @param {string} $symbol unified array of symbols
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} A dictionary of ~@link https://docs.ccxt.com/?id=order-book-structure order book structures~ indexed by market symbols
             */
            return Async\await($this->un_watch_order_book_for_symbols(array( $symbol ), $params));
        }) ();
    }

    public function watch_order_book_for_symbols(array $symbols, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbols, $limit, $params) {
            /**
             * watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
             *
             * @see https://developers.bydfi.com/en/swap/websocket-$market#limited-$depth-information
             *
             * @param {string[]} $symbols unified array of $symbols
             * @param {int} [$limit] the maximum amount of order book entries to return (default and max is 100)
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} A dictionary of ~@link https://docs.ccxt.com/?id=order-book-structure order book structures~ indexed by $market $symbols
             */
            Async\await($this->load_markets());
            $symbols = $this->market_symbols($symbols, null, false);
            $depth = '100';
            list($depth, $params) = $this->handle_option_and_params($params, 'watchOrderBookForSymbols', 'depth', $depth);
            $frequency = '100ms';
            list($frequency, $params) = $this->handle_option_and_params($params, 'watchOrderBookForSymbols', 'frequency', $frequency);
            $channelSuffix = '';
            if ($frequency === '100ms') {
                $channelSuffix = '@100ms';
            }
            $channels = array();
            $messageHashes = array();
            for ($i = 0; $i < count($symbols); $i++) {
                $symbol = $symbols[$i];
                $market = $this->market($symbol);
                $channels[] = $market['id'] . '@depth' . $depth . $channelSuffix;
                $messageHashes[] = 'orderbook::' . $symbol;
            }
            $orderbook = Async\await($this->watch_public($messageHashes, $channels, $params));
            return $orderbook->limit ();
        }) ();
    }

    public function un_watch_order_book_for_symbols(array $symbols, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbols, $params) {
            /**
             * unWatches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
             *
             * @see https://developers.bydfi.com/en/swap/websocket-$market#limited-$depth-information
             *
             * @param {string[]} $symbols unified array of $symbols
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @param {string} [$params->method] either '/market/level2' or '/spotMarket/level2Depth5' or '/spotMarket/level2Depth50' default is '/market/level2'
             * @return {array} A dictionary of ~@link https://docs.ccxt.com/?id=order-book-structure order book structures~ indexed by $market $symbols
             */
            Async\await($this->load_markets());
            $symbols = $this->market_symbols($symbols, null, false);
            $depth = '100';
            list($depth, $params) = $this->handle_option_and_params($params, 'watchOrderBookForSymbols', 'depth', $depth);
            $frequency = '100ms';
            list($frequency, $params) = $this->handle_option_and_params($params, 'watchOrderBookForSymbols', 'frequency', $frequency);
            $channelSuffix = '';
            if ($frequency === '100ms') {
                $channelSuffix = '@100ms';
            }
            $channels = array();
            $messageHashes = array();
            for ($i = 0; $i < count($symbols); $i++) {
                $symbol = $symbols[$i];
                $market = $this->market($symbol);
                $channels[] = $market['id'] . '@depth' . $depth . $channelSuffix;
                $messageHashes[] = 'unsubscribe::orderbook::' . $symbol;
            }
            $subscription = array(
                'topic' => 'orderbook',
                'symbols' => $symbols,
            );
            $params = $this->extend($params, array( 'unsubscribe' => true ));
            return Async\await($this->watch_public($messageHashes, $channels, $params, $subscription));
        }) ();
    }

    public function handle_order_book(Client $client, $message) {
        //
        //     {
        //         "a" => array( array( 150000, 15 ), ... ),
        //         "b" => array( array( 90450.7, 3615 ), ... ),
        //         "s" => "BTC-USDT",
        //         "e" => "depthUpdate",
        //         "E" => 1766577624512
        //     }
        //
        $marketId = $this->safe_string($message, 's');
        $symbol = $this->safe_symbol($marketId);
        $timestamp = $this->safe_integer($message, 'E');
        if (!(is_array($this->orderbooks) && array_key_exists($symbol, $this->orderbooks))) {
            $this->orderbooks[$symbol] = $this->order_book();
        }
        $orderbook = $this->orderbooks[$symbol];
        $parsed = $this->parse_order_book($message, $symbol, $timestamp, 'b', 'a');
        $orderbook->reset ($parsed);
        $messageHash = 'orderbook::' . $symbol;
        $this->orderbooks[$symbol] = $orderbook;
        $client->resolve ($orderbook, $messageHash);
    }

    public function watch_orders(?string $symbol = null, ?int $since = null, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            /**
             * watches information on multiple orders made by the user
             *
             * @see https://developers.bydfi.com/en/swap/websocket-account#order-trade-update-push
             *
             * @param {string} $symbol unified market $symbol of the market orders were made in
             * @param {int} [$since] the earliest time in ms to fetch orders for
             * @param {int} [$limit] the maximum number of order structures to retrieve
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array[]} a list of ~@link https://docs.ccxt.com/?id=order-structure order structures~
             */
            $symbols = null;
            if ($symbol !== null) {
                $symbols = array( $symbol );
            }
            return Async\await($this->watch_orders_for_symbols($symbols, $since, $limit, $params));
        }) ();
    }

    public function watch_orders_for_symbols(array $symbols, ?int $since = null, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbols, $since, $limit, $params) {
            /**
             * watches information on multiple $orders made by the user
             *
             * @see https://developers.bydfi.com/en/swap/websocket-account#order-trade-update-push
             *
             * @param {string[]} $symbols unified $symbol of the market to fetch $orders for
             * @param {int} [$since] the earliest time in ms to fetch $orders for
             * @param {int} [$limit] the maximum number of trade structures to retrieve
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array[]} a list of ~@link https://docs.ccxt.com/?id=order-structure order structures~
             */
            Async\await($this->load_markets());
            $symbols = $this->market_symbols($symbols, null, true);
            $messageHashes = array();
            if ($symbols === null) {
                $messageHashes[] = 'orders';
            } else {
                for ($i = 0; $i < count($symbols); $i++) {
                    $symbol = $symbols[$i];
                    $messageHashes[] = 'orders::' . $symbol;
                }
            }
            $orders = Async\await($this->watch_private($messageHashes, $params));
            if ($this->newUpdates) {
                $first = $this->safe_value($orders, 0);
                $tradeSymbol = $this->safe_string($first, 'symbol');
                $limit = $orders->getLimit ($tradeSymbol, $limit);
            }
            return $this->filter_by_since_limit($orders, $since, $limit, 'timestamp', true);
        }) ();
    }

    public function handle_order(Client $client, $message) {
        //
        //     {
        //         "T" => 1766588450558,
        //         "E" => 1766588450685,
        //         "e" => "ORDER_TRADE_UPDATE",
        //         "o" => {
        //             "S" => "BUY",
        //             "ap" => "0",
        //             "cpt" => false,
        //             "ct" => "future",
        //             "ev" => "0",
        //             "fee" => "0",
        //             "lv" => 2,
        //             "mt" => "isolated",
        //             "o" => "7409609004526010368",
        //             "p" => "1000",
        //             "ps" => "BOTH",
        //             "pt" => "ONE_WAY",
        //             "ro" => false,
        //             "s" => "ETH-USDC",
        //             "st" => "NEW",
        //             "t" => "LIMIT",
        //             "tp" => "0",
        //             "u" => "0.001",
        //             "v" => "2"
        //         }
        //     }
        //
        $rawOrder = $this->safe_dict($message, 'o', array());
        $marketId = $this->safe_string($rawOrder, 's');
        $market = $this->safe_market($marketId);
        $symbol = $market['symbol'];
        $messageHash = 'orders';
        $symbolMessageHash = $messageHash . '::' . $symbol;
        if ($this->orders === null) {
            $limit = $this->safe_integer($this->options, 'ordersLimit', 1000);
            $this->orders = new ArrayCacheBySymbolById ($limit);
        }
        $orders = $this->orders;
        $order = $this->parse_ws_order($rawOrder, $market);
        $lastUpdateTimestamp = $this->safe_integer($message, 'T');
        $order['lastUpdateTimestamp'] = $lastUpdateTimestamp;
        $orders->append ($order);
        $client->resolve ($orders, $messageHash);
        $client->resolve ($orders, $symbolMessageHash);
    }

    public function parse_ws_order(array $order, ?array $market = null): array {
        //
        //     {
        //         "S" => "BUY",
        //         "ap" => "0",
        //         "cpt" => false,
        //         "ct" => "future",
        //         "ev" => "0",
        //         "fee" => "0",
        //         "lv" => 2,
        //         "mt" => "isolated",
        //         "o" => "7409609004526010368",
        //         "p" => "1000",
        //         "ps" => "BOTH",
        //         "pt" => "ONE_WAY",
        //         "ro" => false,
        //         "s" => "ETH-USDC",
        //         "st" => "NEW",
        //         "t" => "LIMIT",
        //         "tp" => "0",
        //         "u" => "0.001",
        //         "v" => "2"
        //     }
        //
        $marketId = $this->safe_string($order, 's');
        $market = $this->safe_market($marketId, $market);
        $rawStatus = $this->safe_string($order, 'st');
        $rawType = $this->safe_string($order, 't');
        $fee = null;
        $feeCost = $this->safe_string($order, 'fee');
        if ($feeCost !== null) {
            $fee = array(
                'cost' => Precise::string_abs($feeCost),
                'currency' => $market['quote'],
            );
        }
        return $this->safe_order(array(
            'info' => $order,
            'id' => $this->safe_string($order, 'o'),
            'clientOrderId' => $this->safe_string($order, 'cid'),
            'timestamp' => null,
            'datetime' => null,
            'lastTradeTimestamp' => null,
            'lastUpdateTimestamp' => null,
            'status' => $this->parse_order_status($rawStatus),
            'symbol' => $market['symbol'],
            'type' => $this->parseOrderType ($rawType),
            'timeInForce' => null,
            'postOnly' => null,
            'reduceOnly' => $this->safe_bool($order, 'ro'),
            'side' => $this->safe_string_lower($order, 'S'),
            'price' => $this->safe_string($order, 'p'),
            'triggerPrice' => null,
            'stopLossPrice' => null,
            'takeProfitPrice' => null,
            'amount' => $this->safe_string($order, 'v'),
            'filled' => $this->safe_string($order, 'ev'),
            'remaining' => $this->safe_string($order, 'qty'),
            'cost' => null,
            'trades' => null,
            'fee' => $fee,
            'average' => $this->omit_zero($this->safe_string($order, 'ap')),
        ), $market);
    }

    public function watch_positions(?array $symbols = null, ?int $since = null, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbols, $since, $limit, $params) {
            /**
             * watch all open $positions
             *
             * @see https://developers.bydfi.com/en/swap/websocket-account#balance-and-position-update-push
             *
             * @param {string[]} [$symbols] list of unified market $symbols
             * @param {int} [$since] the earliest time in ms to fetch $positions for
             * @param {int} [$limit] the maximum number of $positions to retrieve
             * @param {array} $params extra parameters specific to the exchange API endpoint
             * @return {array[]} a list of {@link https://docs.ccxt.com/en/latest/manual.html#position-structure position structure}
             */
            Async\await($this->load_markets());
            $symbols = $this->market_symbols($symbols, null, true);
            $messageHashes = array();
            $messageHash = 'positions';
            if ($symbols === null) {
                $messageHashes[] = $messageHash;
            } else {
                for ($i = 0; $i < count($symbols); $i++) {
                    $symbol = $symbols[$i];
                    $messageHashes[] = $messageHash . '::' . $symbol;
                }
            }
            $positions = Async\await($this->watch_private($messageHashes, $params));
            if ($this->newUpdates) {
                return $positions;
            }
            return $this->filter_by_symbols_since_limit($this->positions, $symbols, $since, $limit, true);
        }) ();
    }

    public function handle_positions($client, $message) {
        //
        //     {
        //         "a" => {
        //             "B" => array(
        //                 {
        //                     "a" => "USDC",
        //                     "ba" => "0",
        //                     "im" => "1.46282986",
        //                     "om" => "0",
        //                     "tfm" => "1.46282986",
        //                     "wb" => "109.86879703"
        //                 }
        //             ),
        //             "m" => "ORDER",
        //             "p" => array(
        //                 array(
        //                     "S" => "1",
        //                     "ap" => "2925.81666667",
        //                     "c" => "USDC",
        //                     "ct" => "FUTURE",
        //                     "l" => 2,
        //                     "lq" => "1471.1840621072728637",
        //                     "lv" => "0",
        //                     "ma" => "0",
        //                     "mt" => "ISOLATED",
        //                     "pm" => "1.4628298566666665",
        //                     "pt" => "ONEWAY",
        //                     "rp" => "-0.00036721",
        //                     "s" => "ETH-USDC",
        //                     "t" => "0",
        //                     "uq" => "0.001",
        //                     "v" => "1"
        //                 }
        //             )
        //         ),
        //         "T" => 1766592694451,
        //         "E" => 1766592694554,
        //         "e" => "ACCOUNT_UPDATE"
        //     }
        //
        $data = $this->safe_dict($message, 'a', array());
        $positionsData = $this->safe_list($data, 'p', array());
        $rawPosition = $this->safe_dict($positionsData, 0, array());
        $marketId = $this->safe_string($rawPosition, 's');
        $market = $this->safe_market($marketId);
        $symbol = $market['symbol'];
        $messageHash = 'positions';
        $symbolMessageHash = $messageHash . '::' . $symbol;
        if ($this->positions === null) {
            $this->positions = new ArrayCacheBySymbolBySide ();
        }
        $cache = $this->positions;
        $parsedPosition = $this->parse_ws_position($rawPosition, $market);
        $timestamp = $this->safe_integer($message, 'T');
        $parsedPosition['timestamp'] = $timestamp;
        $parsedPosition['datetime'] = $this->iso8601($timestamp);
        $cache->append ($parsedPosition);
        $client->resolve (array( $parsedPosition ), $messageHash);
        $client->resolve (array( $parsedPosition ), $symbolMessageHash);
    }

    public function parse_ws_position($position, $market = null) {
        //
        //     {
        //         "S" => "1",
        //         "ap" => "2925.81666667",
        //         "c" => "USDC",
        //         "ct" => "FUTURE",
        //         "l" => 2,
        //         "lq" => "1471.1840621072728637",
        //         "lv" => "0",
        //         "ma" => "0",
        //         "mt" => "ISOLATED",
        //         "pm" => "1.4628298566666665",
        //         "pt" => "ONEWAY",
        //         "rp" => "-0.00036721",
        //         "s" => "ETH-USDC",
        //         "t" => "0",
        //         "uq" => "0.001",
        //         "v" => "1"
        //     }
        //
        $marketId = $this->safe_string($position, 's');
        $market = $this->safe_market($marketId, $market);
        $rawPositionSide = $this->safe_string($position, 'S');
        $positionMode = $this->safe_string($position, 'pt');
        return $this->safe_position(array(
            'info' => $position,
            'id' => $this->safe_string($position, 'id'),
            'symbol' => $market['symbol'],
            'entryPrice' => $this->parse_number($this->safe_string($position, 'ap')),
            'markPrice' => null,
            'lastPrice' => null,
            'notional' => null,
            'collateral' => null,
            'unrealizedPnl' => null,
            'realizedPnl' => $this->parse_number($this->safe_string($position, 'rp')),
            'side' => $this->parse_ws_position_side($rawPositionSide),
            'contracts' => $this->parse_number($this->safe_string($position, 'v')),
            'contractSize' => $this->parse_number($this->safe_string($position, 'uq')),
            'timestamp' => null,
            'datetime' => null,
            'lastUpdateTimestamp' => null,
            'hedged' => ($positionMode !== 'ONEWAY'),
            'maintenanceMargin' => null,
            'maintenanceMarginPercentage' => null,
            'initialMargin' => $this->parse_number($this->safe_string($position, 'pm')),
            'initialMarginPercentage' => null,
            'leverage' => $this->safe_integer($position, 'l'),
            'liquidationPrice' => $this->parse_number($this->safe_string($position, 'lq')),
            'marginRatio' => null,
            'marginMode' => $this->safe_string_lower($position, 'mt'),
            'percentage' => null,
        ));
    }

    public function parse_ws_position_side(?string $rawPositionSide): ?string {
        $sides = array(
            '1' => 'long',
            '2' => 'short',
        );
        return $this->safe_string($sides, $rawPositionSide, $rawPositionSide);
    }

    public function watch_balance($params = array ()): PromiseInterface {
        return Async\async(function () use ($params) {
            /**
             * watch balance and get the amount of funds available for trading or funds locked in orders
             *
             * @see https://developers.bydfi.com/en/swap/websocket-account#balance-and-position-update-push
             *
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} a ~@link https://docs.ccxt.com/?id=balance-structure balance structure~
             */
            Async\await($this->load_markets());
            $url = $this->urls['api']['ws'];
            $client = $this->client($url);
            $this->fetch_balance_snapshot($client);
            $options = $this->safe_dict($this->options, 'watchBalance');
            $fetchBalanceSnapshot = $this->safe_bool($options, 'fetchBalanceSnapshot', false);
            $awaitBalanceSnapshot = $this->safe_bool($options, 'awaitBalanceSnapshot', true);
            if ($fetchBalanceSnapshot && $awaitBalanceSnapshot) {
                Async\await($client->future ('fetchBalanceSnapshot'));
            }
            $messageHash = 'balance';
            return Async\await($this->watch_private(array( $messageHash ), $params));
        }) ();
    }

    public function fetch_balance_snapshot(Client $client) {
        $options = $this->safe_value($this->options, 'watchBalance');
        $fetchBalanceSnapshot = $this->safe_bool($options, 'fetchBalanceSnapshot', false);
        if ($fetchBalanceSnapshot) {
            $messageHash = 'fetchBalanceSnapshot';
            if (!(is_array($client->futures) && array_key_exists($messageHash, $client->futures))) {
                $client->future ($messageHash);
                $this->spawn(array($this, 'load_balance_snapshot'), $client, $messageHash);
            }
        }
    }

    public function load_balance_snapshot($client, $messageHash) {
        return Async\async(function () use ($client, $messageHash) {
            $params = array(
                'type' => 'swap',
            );
            $response = Async\await($this->fetch_balance($params));
            $this->balance = $this->extend($response, $this->balance);
            // don't remove the $future from the .futures cache
            $future = $client->futures[$messageHash];
            $future->resolve ();
            $client->resolve ($this->balance, 'balance');
        }) ();
    }

    public function handle_balance(Client $client, $message) {
        //
        //     {
        //         "a" => {
        //             "B" => array(
        //                 {
        //                     "a" => "USDC",
        //                     "ba" => "0",
        //                     "im" => "1.46282986",
        //                     "om" => "0",
        //                     "tfm" => "1.46282986",
        //                     "wb" => "109.86879703"
        //                 }
        //             ),
        //             "m" => "ORDER",
        //             "p" => array(
        //                 array(
        //                     "S" => "1",
        //                     "ap" => "2925.81666667",
        //                     "c" => "USDC",
        //                     "ct" => "FUTURE",
        //                     "l" => 2,
        //                     "lq" => "1471.1840621072728637",
        //                     "lv" => "0",
        //                     "ma" => "0",
        //                     "mt" => "ISOLATED",
        //                     "pm" => "1.4628298566666665",
        //                     "pt" => "ONEWAY",
        //                     "rp" => "-0.00036721",
        //                     "s" => "ETH-USDC",
        //                     "t" => "0",
        //                     "uq" => "0.001",
        //                     "v" => "1"
        //                 }
        //             )
        //         ),
        //         "T" => 1766592694451,
        //         "E" => 1766592694554,
        //         "e" => "ACCOUNT_UPDATE"
        //     }
        //
        $messageHash = 'balance';
        if (is_array($client->futures) && array_key_exists($messageHash, $client->futures)) {
            $data = $this->safe_dict($message, 'a', array());
            $balances = $this->safe_list($data, 'B', array());
            $timestamp = $this->safe_integer($message, 'T');
            $result = array(
                'info' => $message,
                'timestamp' => $timestamp,
                'datetime' => $this->iso8601($timestamp),
            );
            for ($i = 0; $i < count($balances); $i++) {
                $balance = $balances[$i];
                $currencyId = $this->safe_string($balance, 'a');
                $code = $this->safe_currency_code($currencyId);
                $account = $this->account();
                $account['total'] = $this->safe_string($balance, 'wb');
                $account['used'] = $this->safe_string($balance, 'tfm');
                $result[$code] = $account;
            }
            $parsedBalance = $this->safe_balance($result);
            $this->balance = $this->extend($this->balance, $parsedBalance);
            $client->resolve ($this->balance, $messageHash);
        }
    }

    public function handle_subscription_status(Client $client, $message) {
        //
        //     {
        //         "result" => true,
        //         "id" => 1
        //     }
        //
        $id = $this->safe_string($message, 'id');
        $subscriptionsById = $this->index_by($client->subscriptions, 'id');
        $subscription = $this->safe_dict($subscriptionsById, $id, array());
        $isUnSubMessage = $this->safe_bool($subscription, 'unsubscribe', false);
        if ($isUnSubMessage) {
            $this->handle_un_subscription($client, $subscription);
        }
        return $message;
    }

    public function handle_un_subscription(Client $client, array $subscription) {
        $messageHashes = $this->safe_list($subscription, 'messageHashes', array());
        $subHashIsPrefix = $this->safe_bool($subscription, 'subHashIsPrefix', false);
        for ($i = 0; $i < count($messageHashes); $i++) {
            $unsubHash = $messageHashes[$i];
            $subHash = str_replace('unsubscribe::', '', $unsubHash);
            $this->clean_unsubscription($client, $subHash, $unsubHash, $subHashIsPrefix);
        }
        $this->clean_cache($subscription);
    }

    public function handle_pong(Client $client, $message) {
        //
        //     {
        //         "id" => 1,
        //         "result" => "pong"
        //     }
        //
        $client->lastPong = $this->milliseconds();
        return $message;
    }

    public function handle_error_message(Client $client, $message) {
        //
        //     {
        //         "msg" => "Service error",
        //         "code" => "-1"
        //     }
        //
        $code = $this->safe_string($message, 'code');
        $msg = $this->safe_string($message, 'msg');
        $feedback = $this->id . ' ' . $this->json($message);
        $this->throw_exactly_matched_exception($this->exceptions['exact'], $msg, $feedback);
        $this->throw_broadly_matched_exception($this->exceptions['broad'], $msg, $feedback);
        $this->throw_exactly_matched_exception($this->exceptions['exact'], $code, $feedback);
        throw new ExchangeError($feedback);
    }

    public function handle_message(Client $client, $message) {
        $code = $this->safe_string($message, 'code');
        if ($code !== null && ($code !== '0')) {
            $this->handle_error_message($client, $message);
        }
        $result = $this->safe_string($message, 'result');
        if ($result === 'pong') {
            $this->handle_pong($client, $message);
        } elseif ($result !== null) {
            $this->handle_subscription_status($client, $message);
        } else {
            $event = $this->safe_string($message, 'e');
            if ($event === '24hrTicker') {
                $this->handle_ticker($client, $message);
            } elseif ($event === 'kline') {
                $this->handle_ohlcv($client, $message);
            } elseif ($event === 'depthUpdate') {
                $this->handle_order_book($client, $message);
            } elseif ($event === 'ORDER_TRADE_UPDATE') {
                $this->handle_order($client, $message);
            } elseif ($event === 'ACCOUNT_UPDATE') {
                $account = $this->safe_dict($message, 'a', array());
                $balances = $this->safe_list($account, 'B', array());
                $balancesLength = count($balances);
                if ($balancesLength > 0) {
                    $this->handle_balance($client, $message);
                }
                $positions = $this->safe_list($account, 'p', array());
                $positionsLength = count($positions);
                if ($positionsLength > 0) {
                    $this->handle_positions($client, $message);
                }
            }
        }
    }
}
