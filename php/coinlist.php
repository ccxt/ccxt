<?php

namespace ccxt;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

use Exception; // a common import
use ccxt\abstract\coinlist as Exchange;

class coinlist extends Exchange {

    public function describe(): mixed {
        return $this->deep_extend(parent::describe(), array(
            'id' => 'coinlist',
            'name' => 'Coinlist',
            'countries' => array( 'US' ), // United States
            'version' => 'v1',
            'rateLimit' => 300, // 1000 per 5 minutes
            'certified' => false,
            'pro' => false,
            'has' => array(
                'CORS' => null,
                'spot' => true,
                'margin' => false,
                'swap' => false,
                'future' => false,
                'option' => false,
                'addMargin' => false,
                'cancelAllOrders' => true,
                'cancelOrder' => true,
                'cancelOrders' => true,
                'closeAllPositions' => false,
                'closePosition' => false,
                'createDepositAddress' => false,
                'createOrder' => true,
                'createPostOnlyOrder' => true,
                'createReduceOnlyOrder' => false,
                'createStopLimitOrder' => true,
                'createStopMarketOrder' => true,
                'createStopOrder' => true,
                'deposit' => false,
                'editOrder' => true,
                'fetchAccounts' => true,
                'fetchBalance' => true,
                'fetchBidsAsks' => false,
                'fetchBorrowInterest' => false,
                'fetchBorrowRateHistories' => false,
                'fetchBorrowRateHistory' => false,
                'fetchCanceledOrders' => true,
                'fetchClosedOrder' => false,
                'fetchClosedOrders' => true,
                'fetchCrossBorrowRate' => false,
                'fetchCrossBorrowRates' => false,
                'fetchCurrencies' => true,
                'fetchDeposit' => false,
                'fetchDepositAddress' => false,
                'fetchDepositAddresses' => false,
                'fetchDepositAddressesByNetwork' => false,
                'fetchDeposits' => false,
                'fetchDepositsWithdrawals' => true,
                'fetchDepositWithdrawFee' => false,
                'fetchDepositWithdrawFees' => false,
                'fetchFundingHistory' => false,
                'fetchFundingRate' => true,
                'fetchFundingRateHistory' => false,
                'fetchFundingRates' => false,
                'fetchIndexOHLCV' => false,
                'fetchIsolatedBorrowRate' => false,
                'fetchIsolatedBorrowRates' => false,
                'fetchL3OrderBook' => false,
                'fetchLedger' => true,
                'fetchLeverage' => false,
                'fetchLeverageTiers' => false,
                'fetchMarketLeverageTiers' => false,
                'fetchMarkets' => true,
                'fetchMarkOHLCV' => false,
                'fetchMyTrades' => true,
                'fetchOHLCV' => true,
                'fetchOpenInterestHistory' => false,
                'fetchOpenOrder' => false,
                'fetchOpenOrders' => true,
                'fetchOrder' => true,
                'fetchOrderBook' => true,
                'fetchOrderBooks' => false,
                'fetchOrders' => true,
                'fetchOrderTrades' => true,
                'fetchPosition' => false,
                'fetchPositionHistory' => false,
                'fetchPositionMode' => false,
                'fetchPositions' => false,
                'fetchPositionsForSymbol' => false,
                'fetchPositionsHistory' => false,
                'fetchPositionsRisk' => false,
                'fetchPremiumIndexOHLCV' => false,
                'fetchStatus' => false,
                'fetchTicker' => true,
                'fetchTickers' => true,
                'fetchTime' => true,
                'fetchTrades' => true,
                'fetchTradingFee' => false,
                'fetchTradingFees' => true,
                'fetchTradingLimits' => false,
                'fetchTransactionFee' => false,
                'fetchTransactionFees' => false,
                'fetchTransactions' => true,
                'fetchTransfers' => true,
                'fetchWithdrawal' => false,
                'fetchWithdrawals' => false,
                'fetchWithdrawalWhitelist' => false,
                'reduceMargin' => false,
                'repayCrossMargin' => false,
                'repayIsolatedMargin' => false,
                'setLeverage' => false,
                'setMargin' => false,
                'setMarginMode' => false,
                'setPositionMode' => false,
                'signIn' => false,
                'transfer' => true,
                'withdraw' => true,
                'ws' => false,
            ),
            'timeframes' => array(
                '1m' => '1m',
                '5m' => '5m',
                '30m' => '30m',
            ),
            'urls' => array(
                'logo' => 'https://github-production-user-asset-6210df.s3.amazonaws.com/1294454/281108917-eff2ae1d-ce8a-4b2a-950d-8678b12da965.jpg',
                'api' => array(
                    'public' => 'https://trade-api.coinlist.co',
                    'private' => 'https://trade-api.coinlist.co',
                ),
                'www' => 'https://coinlist.co',
                'doc' => array(
                    'https://trade-docs.coinlist.co',
                ),
                'fees' => 'https://coinlist.co/fees',
            ),
            'api' => array(
                'public' => array(
                    'get' => array(
                        'v1/symbols' => 1,
                        'v1/symbols/summary' => 1,
                        'v1/symbols/{symbol}' => 1, // not unified
                        'v1/symbols/{symbol}/summary' => 1,
                        'v1/symbols/{symbol}/book' => 1,
                        'v1/symbols/{symbol}/quote' => 1, // not unified
                        'v1/symbols/{symbol}/candles' => 1,
                        'v1/symbols/{symbol}/auctions' => 1,
                        'v1/symbols/{symbol}/auctions/{auction_code}' => 1, // not unified
                        'v1/time' => 1,
                        'v1/assets' => 1,
                        'v1/leaderboard' => 1,
                        'v1/affiliate/{competition_code}' => 1,
                        'v1/competition/{competition_id}' => 1,
                        'v1/symbols/{symbol}/funding' => 1,
                    ),
                ),
                'private' => array(
                    'get' => array(
                        'v1/fees' => 1,
                        'v1/accounts' => 1,
                        'v1/accounts/{trader_id}' => 1, // not unified
                        'v1/accounts/{trader_id}/alias' => 1,
                        'v1/accounts/{trader_id}/ledger' => 1,
                        'v1/accounts/{trader_id}/wallets' => 1, // not unified
                        'v1/accounts/{trader_id}/wallet-ledger' => 1,
                        'v1/accounts/{trader_id}/ledger-summary' => 1, // not unified
                        'v1/keys' => 1, // not unified
                        'v1/fills' => 1,
                        'v1/orders' => 1,
                        'v1/orders/{order_id}' => 1,
                        'v1/reports' => 1, // not unified
                        'v1/balances' => 1,
                        'v1/transfers' => 1,
                        'v1/user' => 1, // not unified
                        'v1/credits' => 1, // not unified
                        'v1/positions' => 1,
                        'v1/accounts/{trader_id}/competitions' => 1,
                        'v1/closedPositions' => 1,
                    ),
                    'post' => array(
                        'v1/keys' => 1, // not unified
                        'v1/orders' => 1,
                        'v1/orders/cancel-all-after' => 1, // not unified
                        'v1/reports' => 1, // not unified
                        'v1/transfers/to-wallet' => 1,
                        'v1/transfers/from-wallet' => 1,
                        'v1/transfers/internal-transfer' => 1,
                        'v1/transfers/withdrawal-request' => 1,
                        'v1/orders/bulk' => 1, // not unified
                        'v1/accounts/{trader_id}/competitions' => 1,
                        'v1/accounts/{trader_id}/create-competition' => 1,
                    ),
                    'patch' => array(
                        'v1/orders/{order_id}' => 1,
                        'v1/orders/bulk' => 1, // not unified
                    ),
                    'put' => array(
                        'v1/accounts/{trader_id}/alias' => 1,
                    ),
                    'delete' => array(
                        'v1/keys/{key}' => 1,  // not unified
                        'v1/orders' => 1,
                        'v1/orders/{order_id}' => 1,
                        'v1/orders/bulk' => 1,
                    ),
                ),
            ),
            'features' => array(
                'default' => array(
                    'sandbox' => false,
                    'createOrder' => array(
                        'marginMode' => false,
                        'triggerPrice' => true,
                        'triggerPriceType' => array(
                            'last' => true,
                            'mark' => true,
                            'index' => true,
                        ),
                        'triggerDirection' => false,
                        'stopLossPrice' => false, // todo
                        'takeProfitPrice' => false, // todo
                        'attachedStopLossTakeProfit' => null,
                        'timeInForce' => array(
                            'IOC' => false,
                            'FOK' => false,
                            'PO' => true,
                            'GTD' => false,
                        ),
                        'hedged' => false,
                        'trailing' => true, // todo implement
                        'leverage' => false,
                        'marketBuyByCost' => false,
                        'marketBuyRequiresPrice' => false,
                        'selfTradePrevention' => true, // todo implement
                        'iceberg' => false,
                    ),
                    'createOrders' => null,
                    'fetchMyTrades' => array(
                        'marginMode' => false,
                        'limit' => 500,
                        'daysBack' => 100000,
                        'untilDays' => 100000,
                        'symbolRequired' => false,
                    ),
                    'fetchOrder' => array(
                        'marginMode' => false,
                        'trigger' => false,
                        'trailing' => false,
                        'symbolRequired' => false,
                    ),
                    'fetchOpenOrders' => array(
                        'marginMode' => false,
                        'limit' => 500,
                        'trigger' => false,
                        'trailing' => false,
                        'symbolRequired' => false,
                    ),
                    'fetchOrders' => array(
                        'marginMode' => false,
                        'limit' => 500,
                        'daysBack' => 100000,
                        'untilDays' => 100000,
                        'trigger' => false,
                        'trailing' => false,
                        'symbolRequired' => false,
                    ),
                    'fetchClosedOrders' => array(
                        'marginMode' => false,
                        'limit' => 500,
                        'daysBack' => 100000,
                        'daysBackCanceled' => null,
                        'untilDays' => 100000,
                        'trigger' => false,
                        'trailing' => false,
                        'symbolRequired' => false,
                    ),
                    'fetchOHLCV' => array(
                        'limit' => 300,
                    ),
                ),
                'swap' => array(
                    'linear' => null,
                    'inverse' => null,
                ),
                'future' => array(
                    'linear' => null,
                    'inverse' => null,
                ),
            ),
            'fees' => array(
                'trading' => array(
                    'feeSide' => 'get',
                    'tierBased' => true,
                    'percentage' => true,
                    'taker' => $this->parse_number('0.0045'),
                    'maker' => $this->parse_number('0.0025'),
                    'tiers' => array(
                        'taker' => array(
                            array( $this->parse_number('0'), $this->parse_number('0.0045') ),
                            array( $this->parse_number('20000'), $this->parse_number('0.003') ),
                            array( $this->parse_number('50000'), $this->parse_number('0.0025') ),
                            array( $this->parse_number('100000'), $this->parse_number('0.002') ),
                            array( $this->parse_number('500000'), $this->parse_number('0.0018') ),
                            array( $this->parse_number('750000'), $this->parse_number('0.0018') ),
                            array( $this->parse_number('1000000'), $this->parse_number('0.0016') ),
                            array( $this->parse_number('2500000'), $this->parse_number('0.0013') ),
                            array( $this->parse_number('5000000'), $this->parse_number('0.0012') ),
                            array( $this->parse_number('10000000'), $this->parse_number('0.001') ),
                            array( $this->parse_number('50000000'), $this->parse_number('0.0005') ),
                            array( $this->parse_number('100000000'), $this->parse_number('0.0005') ),
                        ),
                        'maker' => array(
                            array( $this->parse_number('0'), $this->parse_number('0.0025') ),
                            array( $this->parse_number('20000'), $this->parse_number('0.0025') ),
                            array( $this->parse_number('50000'), $this->parse_number('0.0025') ),
                            array( $this->parse_number('100000'), $this->parse_number('0.002') ),
                            array( $this->parse_number('500000'), $this->parse_number('0.0015') ),
                            array( $this->parse_number('750000'), $this->parse_number('0.0012') ),
                            array( $this->parse_number('1000000'), $this->parse_number('0.001') ),
                            array( $this->parse_number('2500000'), $this->parse_number('0.0008') ),
                            array( $this->parse_number('5000000'), $this->parse_number('0.0007') ),
                            array( $this->parse_number('10000000'), $this->parse_number('0.0006') ),
                            array( $this->parse_number('50000000'), $this->parse_number('0.0000') ),
                            array( $this->parse_number('100000000'), $this->parse_number('0.00') ),
                        ),
                    ),
                ),
            ),
            'precisionMode' => TICK_SIZE,
            // exchange-specific options
            'options' => array(
                'accountsByType' => array(
                    'CoinList Pro' => 'trading',
                    'CoinList Pro trading account' => 'trading',
                    'Pro' => 'trading',
                    'pro' => 'trading',
                    'trade' => 'trading',
                    'trading' => 'trading',
                    'CoinList' => 'funding',
                    'CoinList wallet' => 'funding',
                    'Wallet' => 'funding',
                    'wallet' => 'funding',
                    'fund' => 'funding',
                    'funding' => 'funding',
                ),
            ),
            'exceptions' => array(
                // https://trade-docs.coinlist.co/?javascript--nodejs#message-codes
                'exact' => array(
                    'AUTH_SIG_INVALID' => '\\ccxt\\AuthenticationError', // array("status":400,"message":"invalid signature","message_code":"AUTH_SIG_INVALID")
                    'DENIED_MAINTENANCE' => '\\ccxt\\OnMaintenance', // The system is under active maintenance.
                    'ORDER_REJECT_BAD_STATUS' => '\\ccxt\\InvalidOrder', // The order has a status that makes it not cancelable or modifyable.
                    'ORDER_REJECT_INVALID_POST_ONLY' => '\\ccxt\\InvalidOrder',
                    'ORDER_REJECT_INVALID_CLOSE_ONLY' => '\\ccxt\\InvalidOrder',
                    'ORDER_REJECT_POST_ONLY_REQUIRED' => '\\ccxt\\InvalidOrder', // The market currently allows only post-only orders.
                    'ORDER_REJECT_FROZEN_ORDER' => '\\ccxt\\InvalidOrder', // This operation is currently not allowed on this order at this time.
                    'ORDER_REJECT_LIMIT_PRICE_PROTECTION_VIOLATION' => '\\ccxt\\InvalidOrder', // The limit price violates the price protection range for this symbol.
                    'ORDER_REJECT_CLOSED' => '\\ccxt\\NotSupported', // The market is closed for order operations.
                    'ORDER_REJECT_MAX_ORDERS' => '\\ccxt\\BadRequest', // You have violated the 25 orders per symbol limit.
                    'ORDER_REJECT_NOT_FOUND' => '\\ccxt\\OrderNotFound', // The order to modify or cancel was not found.
                    'ORDER_REJECT_PARSE_ERROR' => '\\ccxt\\BadRequest', // The request failed to parse. Check data types. (strings vs. numbers)
                    'ORDER_REJECT_PRICE_INVALID' => '\\ccxt\\InvalidOrder', // Prices must be positive and aligned with the tick size defined for the symbol.
                    'ORDER_REJECT_QUANTITY_ZERO' => '\\ccxt\\InvalidOrder', // Quantity may not be zero.
                    'ORDER_REJECT_TOKEN_LIMIT' => '\\ccxt\\InsufficientFunds', // Your current token balance is not enough to back this order.
                    'ORDER_REJECT_TOKEN_LIMIT_OTHER' => '\\ccxt\\InvalidOrder',
                    'ORDER_REJECT_SELF_TRADE' => '\\ccxt\\InvalidOrder', // This order would have been involved in a self-trade.
                    'ORDER_VALIDATE_BAD_SIZE_ALIGNMENT' => '\\ccxt\\InvalidOrder', // array("message":"size is not aligned to 0.0001 minimum increment","message_code":"ORDER_VALIDATE_BAD_SIZE_ALIGNMENT","message_details":array("minimum_size_increment":"0.0001"))
                    'ORDER_VALIDATE_BAD_TICK_ALIGNMENT' => '\\ccxt\\InvalidOrder', // array("message":"price is not aligned to 0.01 tick size","message_code":"ORDER_VALIDATE_BAD_TICK_ALIGNMENT","message_details":array("minimum_price_increment":array("s":1,"e":-2,"c":[1000000000000])))
                    'ORDER_VALIDATE_SYMBOL_NOT_FOUND' => '\\ccxt\\BadSymbol', // array("message":"symbol asdfsdfs not found","message_code":"ORDER_VALIDATE_SYMBOL_NOT_FOUND")
                    'TRANSFERS_WITHDRAWAL_REQUEST_TOO_LARGE' => '\\ccxt\\InsufficientFunds', // array("message":"Withdrawal request too large. 0.000000000000000000 ETH available for withdrawal.","message_code":"TRANSFERS_WITHDRAWAL_REQUEST_TOO_LARGE","message_details":array("token_code":"ETH","amount":"0.010000000000000000","withdrawable_balance":"0.000000000000000000"))
                    'WITHDRAWAL_REQUEST_NOT_ALLOWED' => '\\ccxt\\PermissionDenied', // array("message":"Withdrawal from CoinList not allowed for trader.","message_code":"WITHDRAWAL_REQUEST_NOT_ALLOWED","message_details":array("asset":"USDT","amount":"5","trader_id":"9c6f737e-a829-4843-87b1-b1ce86f2853b","destination_address":"0x9050dfA063D1bE7cA711c750b18D51fDD13e90Ee"))
                ),
                'broad' => array(
                    'A destinationAddress is required for non-USD withdrawals' => '\\ccxt\\InvalidAddress', // array("status":400,"message":"400 - array(\"message\":\"A destinationAddress is required for non-USD withdrawals.\")")
                    'fails to match the JsonSchema date-time format pattern' => '\\ccxt\\BadRequest', // array("status":401,"message":"\"end_time\" with value \"1698862680000\" fails to match the JsonSchema date-time format pattern")
                    'is required' => '\\ccxt\\ArgumentsRequired', // array("status":400,"message":"\"type\" is required")
                    'must be a string' => '\\ccxt\\BadRequest', // array("status":400,"message":"\"destination_address\" must be a string")
                    'must be a valid GUID' => '\\ccxt\\BadRequest', // array("status":400,"message":"\"order_id\" must be a valid GUID")
                    'must be greater than or equal to' => '\\ccxt\\BadRequest', // array("status":401,"message":"\"count\" must be greater than or equal to 1")
                    'must be less than or equal to' => '\\ccxt\\BadRequest', // array("status":401,"message":"\"count\" must be less than or equal to 500")
                    'must be one of' => '\\ccxt\\BadRequest', // array("status":401,"message":"\"granularity\" must be one of [1m, 5m, 30m]")
                    'Symbol not found' => '\\ccxt\\BadSymbol', // array("message":"Symbol not found => {symbol}")
                ),
            ),
        ));
    }

    public function calculate_rate_limiter_cost($api, $method, $path, $params, $config = array ()) {
        if (gettype($params) === 'array' && array_keys($params) === array_keys(array_keys($params))) {
            $length = count($params);
            return (int) ceil($length / 2);
        }
        return 1;
    }

    public function fetch_time($params = array ()): ?int {
        /**
         * fetches the current integer timestamp in milliseconds from the exchange server
         *
         * @see https://trade-docs.coinlist.co/?javascript--nodejs#get-system-time
         *
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @return {int} the current integer timestamp in milliseconds from the exchange server
         */
        $response = $this->publicGetV1Time ($params);
        //
        //     {
        //         "epoch" => 1698087996.039,
        //         "iso" => "2023-10-23T19:06:36.039Z"
        //     }
        //
        $string = $this->safe_string($response, 'iso');
        return $this->parse8601($string);
    }

    public function fetch_currencies($params = array ()): ?array {
        /**
         * fetches all available $currencies on an exchange
         *
         * @see https://trade-docs.coinlist.co/?javascript--nodejs#list-supported-assets
         *
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @return {array} an associative dictionary of $currencies
         */
        $response = $this->publicGetV1Assets ($params);
        //
        //     {
        //         "assets" => array(
        //             array(
        //                 "asset" => "AAVE",
        //                 "index_code" => ".AAVEUSD",
        //                 "decimal_places" => 18,
        //                 "min_withdrawal" => "1.0000",
        //                 "is_transferable" => true,
        //                 "is_visible" => true
        //             ),
        //             {
        //                 "asset" => "ALGO",
        //                 "index_code" => ".ALGOUSD",
        //                 "decimal_places" => 6,
        //                 "min_withdrawal" => "1.0000",
        //                 "is_transferable" => true,
        //                 "is_visible" => true
        //             }
        //         )
        //     }
        //
        $currencies = $this->safe_value($response, 'assets', array());
        $result = array();
        for ($i = 0; $i < count($currencies); $i++) {
            $currency = $currencies[$i];
            $id = $this->safe_string($currency, 'asset');
            $code = $this->safe_currency_code($id);
            $isFiat = $code === 'USD';
            $isTransferable = $this->safe_bool($currency, 'is_transferable', false);
            $result[$code] = $this->safe_currency_structure(array(
                'id' => $id,
                'code' => $code,
                'name' => $code,
                'info' => $currency,
                'active' => null,
                'deposit' => $isTransferable,
                'withdraw' => $isTransferable,
                'fee' => null,
                'precision' => $this->parse_number($this->parse_precision($this->safe_string($currency, 'decimal_places'))),
                'limits' => array(
                    'amount' => array(
                        'min' => null,
                        'max' => null,
                    ),
                    'withdraw' => array(
                        'min' => $this->safe_number($currency, 'min_withdrawal'),
                        'max' => null,
                    ),
                ),
                'networks' => array(), // todo
                'type' => $isFiat ? 'fiat' : 'crypto',
            ));
        }
        return $result;
    }

    public function fetch_markets($params = array ()): array {
        /**
         * retrieves data on all $markets for coinlist
         *
         * @see https://trade-docs.coinlist.co/?javascript--nodejs#list-symbols
         *
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @return {array[]} an array of objects representing market data
         */
        $response = $this->publicGetV1Symbols ($params);
        //
        //     {
        //         "symbols" => array(
        //             array(
        //                 "symbol" => "CQT-USDT", // spot
        //                 "base_currency" => "CQT",
        //                 "is_trader_geofenced" => false,
        //                 "list_time" => "2021-06-15T00:00:00.000Z",
        //                 "type" => "spot",
        //                 "series_code" => "CQT-USDT-SPOT",
        //                 "long_name" => "Covalent",
        //                 "asset_class" => "CRYPTO",
        //                 "minimum_price_increment" => "0.0001",
        //                 "minimum_size_increment" => "0.0001",
        //                 "quote_currency" => "USDT",
        //                 "index_code" => null,
        //                 "price_band_threshold_market" => "0.05",
        //                 "price_band_threshold_limit" => "0.25",
        //                 "last_price" => "0.12160000",
        //                 "fair_price" => "0.12300000",
        //                 "index_price" => null
        //             ),
        //         )
        //     }
        //
        $markets = $this->safe_value($response, 'symbols', array());
        return $this->parse_markets($markets);
    }

    public function parse_market(array $market): array {
        // perp
        //   {
        //       "symbol":"BTC-PERP",
        //       "base_currency":"BTC",
        //       "is_trader_geofenced":false,
        //       "expiry_name":null,
        //       "expiry_time":null,
        //       "list_time":"2024-09-16T00:00:00.000Z",
        //       "type":"perp-swap",
        //       "series_code":"BTC",
        //       "long_name":"Bitcoin",
        //       "asset_class":"CRYPTO",
        //       "minimum_price_increment":"0.01",
        //       "minimum_size_increment":"0.0001",
        //       "quote_currency":"USDT",
        //       "multiplier":"1",
        //       "contract_frequency":"FGHJKMNQUVXZ",
        //       "index_code":".BTC-USDT",
        //       "price_band_threshold_market":"0.05",
        //       "price_band_threshold_limit":"0.25",
        //       "maintenance_initial_ratio":"0.500000000000000000",
        //       "liquidation_initial_ratio":"0.500000000000000000",
        //       "last_price":"75881.36000000",
        //       "fair_price":"76256.00000000",
        //       "index_price":"77609.90000000",
        //       "mark_price":"76237.75000000",
        //       "mark_price_dollarizer":"0.99950000",
        //       "funding_interval":array(
        //          "hours":"8"
        //       ),
        //       "funding_rate_index_code":".BTC-USDT-FR8H",
        //       "initial_margin_base":"0.200000000000000000",
        //       "initial_margin_per_contract":"0.160000000000000000",
        //       "position_limit":"5.0000"
        //   }
        // spot
        //    {
        //        "symbol" => "CQT-USDT", // spot
        //        "base_currency" => "CQT",
        //        "is_trader_geofenced" => false,
        //        "list_time" => "2021-06-15T00:00:00.000Z",
        //        "type" => "spot",
        //        "series_code" => "CQT-USDT-SPOT",
        //        "long_name" => "Covalent",
        //        "asset_class" => "CRYPTO",
        //        "minimum_price_increment" => "0.0001",
        //        "minimum_size_increment" => "0.0001",
        //        "quote_currency" => "USDT",
        //        "index_code" => null,
        //        "price_band_threshold_market" => "0.05",
        //        "price_band_threshold_limit" => "0.25",
        //        "last_price" => "0.12160000",
        //        "fair_price" => "0.12300000",
        //        "index_price" => null
        //    }
        $isSwap = $this->safe_string($market, 'type') === 'perp-swap';
        $id = $this->safe_string($market, 'symbol');
        $baseId = $this->safe_string($market, 'base_currency');
        $quoteId = $this->safe_string($market, 'quote_currency');
        $base = $this->safe_currency_code($baseId);
        $quote = $this->safe_currency_code($quoteId);
        $amountPrecision = $this->safe_string($market, 'minimum_size_increment');
        $pricePrecision = $this->safe_string($market, 'minimum_price_increment');
        $created = $this->safe_string($market, 'list_time');
        $settledId = null;
        $settled = null;
        $linear = null;
        $inverse = null;
        $contractSize = null;
        $symbol = $base . '/' . $quote;
        if ($isSwap) {
            $contractSize = $this->parse_number('1');
            $linear = true;
            $inverse = false;
            $settledId = $quoteId;
            $settled = $quote;
            $symbol = $symbol . ':' . $quote;
        }
        $type = $isSwap ? 'swap' : 'spot';
        return array(
            'id' => $id,
            'symbol' => $symbol,
            'base' => $base,
            'quote' => $quote,
            'settle' => $settled,
            'baseId' => $baseId,
            'quoteId' => $quoteId,
            'settleId' => $settledId,
            'type' => $type,
            'spot' => !$isSwap,
            'margin' => false,
            'swap' => $isSwap,
            'future' => false,
            'option' => false,
            'active' => true,
            'contract' => $isSwap,
            'linear' => $linear,
            'inverse' => $inverse,
            'contractSize' => $contractSize,
            'expiry' => null,
            'expiryDatetime' => null,
            'strike' => null,
            'optionType' => null,
            'precision' => array(
                'amount' => $this->parse_number($amountPrecision),
                'price' => $this->parse_number($pricePrecision),
            ),
            'limits' => array(
                'leverage' => array(
                    'min' => null,
                    'max' => null,
                ),
                'amount' => array(
                    'min' => null,
                    'max' => null,
                ),
                'price' => array(
                    'min' => null,
                    'max' => null,
                ),
                'cost' => array(
                    'min' => null,
                    'max' => null,
                ),
            ),
            'created' => $this->parse8601($created),
            'info' => $market,
        );
    }

    public function fetch_tickers(?array $symbols = null, $params = array ()): array {
        /**
         * fetches price $tickers for multiple markets, statistical information calculated over the past 24 hours for each market
         *
         * @see https://trade-docs.coinlist.co/?javascript--nodejs#get-symbol-summaries
         *
         * @param {string[]} [$symbols] unified $symbols of the markets to fetch the ticker for, all market $tickers are returned if not assigned
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @return {array} a dictionary of ~@link https://docs.ccxt.com/#/?id=ticker-structure ticker structures~
         */
        $this->load_markets();
        $request = array();
        $tickers = $this->publicGetV1SymbolsSummary ($this->extend($request, $params));
        //
        //     {
        //         "MATIC-USD" => array(
        //             "type":"spot",
        //             "last_price":"0.60990000",
        //             "lowest_ask":"0.61190000",
        //             "highest_bid":"0.60790000",
        //             "last_trade" => array(
        //                 "price":"0.60000000",
        //                 "volume":"2.0000",
        //                 "imbalance":"198.0000",
        //                 "logicalTime":"2023-10-22T23:02:25.000Z",
        //                 "auctionCode":"MATIC-USD-2023-10-22T23:02:25.000Z"
        //         ),
        //             "volume_base_24h":"34.0555",
        //             "volume_quote_24h":"19.9282",
        //             "price_change_percent_24h":"7.50925436",
        //             "highest_price_24h":"0.68560000",
        //             "lowest_price_24h":"0.55500000"
        //         ),
        //     }
        //
        return $this->parse_tickers($tickers, $symbols, $params);
    }

    public function fetch_ticker(string $symbol, $params = array ()): array {
        /**
         * fetches a price $ticker, a statistical calculation with the information calculated over the past 24 hours for a specific $market
         *
         * @see https://trade-docs.coinlist.co/?javascript--nodejs#get-$market-summary
         *
         * @param {string} $symbol unified $symbol of the $market to fetch the $ticker for
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @return {array} a ~@link https://docs.ccxt.com/#/?id=$ticker-structure $ticker structure~
         */
        $this->load_markets();
        $market = $this->market($symbol);
        $request = array(
            'symbol' => $market['id'],
        );
        $ticker = $this->publicGetV1SymbolsSymbolSummary ($this->extend($request, $params));
        //
        //     {
        //         "type":"spot",
        //         "last_price":"31125.00000000",
        //         "lowest_ask":"31349.99000000",
        //         "highest_bid":"30900.00000000",
        //         "last_trade" => array(
        //             "price":"31000.00000000",
        //             "volume":"0.0003",
        //             "imbalance":"0.0000",
        //             "logicalTime":"2023-10-23T16:57:15.000Z",
        //             "auctionCode":"BTC-USDT-2023-10-23T16:57:15.000Z"
        //         ),
        //         "volume_base_24h":"0.3752",
        //         "volume_quote_24h":"11382.7181",
        //         "price_change_percent_24h":"3.66264694",
        //         "highest_price_24h":"31225.12000000",
        //         "lowest_price_24h":"29792.81000000"
        //     }
        //
        return $this->parse_ticker($ticker, $market);
    }

    public function parse_ticker(array $ticker, ?array $market = null): array {
        //
        //     {
        //         "type":"spot",
        //         "last_price":"0.60990000",
        //         "lowest_ask":"0.61190000",
        //         "highest_bid":"0.60790000",
        //         "last_trade" => array(
        //             "price":"0.60000000",
        //             "volume":"2.0000",
        //             "imbalance":"198.0000",
        //             "logicalTime":"2023-10-22T23:02:25.000Z",
        //             "auctionCode":"MATIC-USD-2023-10-22T23:02:25.000Z"
        //          ),
        //         "volume_base_24h":"34.0555",
        //         "volume_quote_24h":"19.9282",
        //         "price_change_percent_24h":"7.50925436",
        //         "highest_price_24h":"0.68560000",
        //         "lowest_price_24h":"0.55500000"
        //     }
        //
        $lastTrade = $this->safe_value($ticker, 'last_trade', array());
        $timestamp = $this->parse8601($this->safe_string($lastTrade, 'logicalTime'));
        $bid = $this->safe_string($ticker, 'highest_bid');
        $ask = $this->safe_string($ticker, 'lowest_ask');
        $baseVolume = $this->safe_string($ticker, 'volume_base_24h');
        $quoteVolume = $this->safe_string($ticker, 'volume_quote_24h');
        $high = $this->safe_string($ticker, 'highest_price_24h');
        $low = $this->safe_string($ticker, 'lowest_price_24h');
        $close = $this->safe_string($ticker, 'last_price');
        $changePcnt = $this->safe_string($ticker, 'price_change_percent_24h');
        return $this->safe_ticker(array(
            'symbol' => $market['symbol'],
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'open' => null,
            'high' => $high,
            'low' => $low,
            'close' => $close,
            'bid' => $bid,
            'bidVolume' => null,
            'ask' => $ask,
            'askVolume' => null,
            'vwap' => null,
            'previousClose' => null,
            'change' => null,
            'percentage' => $changePcnt,
            'average' => null,
            'baseVolume' => $baseVolume,
            'quoteVolume' => $quoteVolume,
            'info' => $ticker,
        ), $market);
    }

    public function fetch_order_book(string $symbol, ?int $limit = null, $params = array ()): array {
        /**
         * fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
         *
         * @see https://trade-docs.coinlist.co/?javascript--nodejs#get-order-book-level-2
         *
         * @param {string} $symbol unified $symbol of the $market to fetch the order book for
         * @param {int} [$limit] the maximum amount of order book entries to return (default 100, max 200)
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @return {array} A dictionary of ~@link https://docs.ccxt.com/#/?id=order-book-structure order book structures~ indexed by $market symbols
         */
        $this->load_markets();
        $market = $this->market($symbol);
        $request = array(
            'symbol' => $market['id'],
        );
        $response = $this->publicGetV1SymbolsSymbolBook ($this->extend($request, $params));
        //
        //     {
        //         "bids" => array(
        //             array( "30900.00000000", "0.0001" ),
        //             array( "30664.21000000", "0.0172" ),
        //             array( "30664.20000000", "0.0906" ),
        //         ),
        //         "asks" => array(
        //             array( "31349.99000000", "0.0003" ),
        //             array( "31350.00000000", "0.0023" ),
        //             array( "31359.33000000", "0.0583" ),
        //         ),
        //         "after_auction_code" => "BTC-USDT-2023-10-23T18:40:51.000Z",
        //         "call_time" => "2023-10-23T18:40:51.068Z",
        //         "logical_time" => "2023-10-23T18:40:51.000Z"
        //     }
        //
        $logical_time = $this->parse8601($this->safe_string($response, 'logical_time'));
        $orderbook = $this->parse_order_book($response, $symbol, $logical_time);
        $orderbook['nonce'] = null;
        return $orderbook;
    }

    public function fetch_ohlcv(string $symbol, $timeframe = '1m', ?int $since = null, ?int $limit = null, $params = array ()): array {
        /**
         * fetches historical candlestick data containing the open, high, low, and close price, and the volume of a $market
         *
         * @see https://trade-docs.coinlist.co/?javascript--nodejs#get-$candles
         *
         * @param {string} $symbol unified $symbol of the $market to fetch OHLCV data for
         * @param {string} $timeframe the length of time each candle represents
         * @param {int} [$since] timestamp in ms of the earliest candle to fetch
         * @param {int} [$limit] the maximum amount of $candles to fetch
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @param {int} [$params->until] the latest time in ms to fetch entries for
         * @return {int[][]} A list of $candles ordered, open, high, low, close, volume
         */
        $this->load_markets();
        $market = $this->market($symbol);
        $granularity = $this->safe_string($this->timeframes, $timeframe);
        $request = array(
            'symbol' => $market['id'],
            'granularity' => $granularity,
        );
        if ($since !== null) {
            $request['start_time'] = $this->iso8601($since);
            if ($limit !== null) {
                $duration = $this->parse_timeframe($timeframe) * 1000;
                $request['end_time'] = $this->iso8601($this->sum($since, $duration * ($limit)));
            } else {
                $request['end_time'] = $this->iso8601($this->milliseconds());
            }
        }
        $until = $this->safe_integer($params, 'until');
        if ($until !== null) {
            $params = $this->omit($params, array( 'until' ));
            $request['end_time'] = $this->iso8601($until);
        }
        $response = $this->publicGetV1SymbolsSymbolCandles ($this->extend($request, $params));
        //
        //     {
        //         "candles" => array(
        //             array(
        //                 "2023-10-17T15:00:00.000Z",
        //                 "28522.96000000",
        //                 "28522.96000000",
        //                 "28522.96000000",
        //                 "28522.96000000",
        //                 "0.1881",
        //                 null
        //             ),
        //             array(
        //                 "2023-10-17T15:30:00.000Z",
        //                 "28582.64000000",
        //                 "28582.64000000",
        //                 "28582.64000000",
        //                 "28582.64000000",
        //                 "0.0050",
        //                 null
        //             )
        //         )
        //     }
        //
        $candles = $this->safe_list($response, 'candles', array());
        return $this->parse_ohlcvs($candles, $market, $timeframe, $since, $limit);
    }

    public function parse_ohlcv($ohlcv, ?array $market = null): array {
        //
        //     array(
        //         "2023-10-17T15:30:00.000Z",
        //         "28582.64000000",
        //         "28582.64000000",
        //         "28582.64000000",
        //         "28582.64000000",
        //         "0.0050",
        //         null
        //     )
        //
        return array(
            $this->parse8601($this->safe_string($ohlcv, 0)),
            $this->safe_number($ohlcv, 1),
            $this->safe_number($ohlcv, 2),
            $this->safe_number($ohlcv, 3),
            $this->safe_number($ohlcv, 4),
            $this->safe_number($ohlcv, 5),
        );
    }

    public function fetch_trades(string $symbol, ?int $since = null, ?int $limit = null, $params = array ()): array {
        /**
         * get the list of most recent trades for a particular $symbol
         *
         * @see https://trade-docs.coinlist.co/?javascript--nodejs#list-$auctions
         *
         * @param {string} $symbol unified $symbol of the $market to fetch trades for
         * @param {int} [$since] timestamp in ms of the earliest trade to fetch
         * @param {int} [$limit] the maximum amount of trades to fetch (default 200, max 500)
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @param {int} [$params->until] the latest time in ms to fetch entries for
         * @return {Trade[]} a list of ~@link https://docs.ccxt.com/#/?id=public-trades trade structures~
         */
        $this->load_markets();
        $market = $this->market($symbol);
        $request = array(
            'symbol' => $market['id'],
        );
        if ($since !== null) {
            $request['start_time'] = $this->iso8601($since);
        }
        if ($limit !== null) {
            $request['count'] = min ($limit, 500);
        }
        $until = $this->safe_integer($params, 'until');
        if ($until !== null) {
            $params = $this->omit($params, array( 'until' ));
            $request['end_time'] = $this->iso8601($until);
        }
        $response = $this->publicGetV1SymbolsSymbolAuctions ($this->extend($request, $params));
        //
        //     {
        //         "auctions" => array(
        //             array(
        //                 "symbol":"BTC-USDT",
        //                 "auction_code":"BTC-USDT-2023-10-01T08:05:56.000Z",
        //                 "price":"27241.53000000",
        //                 "volume":"0.0052",
        //                 "imbalance":"-1.0983",
        //                 "logical_time":"2023-10-01T08:05:56.000Z",
        //                 "call_time":"2023-10-01T08:05:56.068Z"
        //             ),
        //             {
        //                 "symbol":"BTC-USDT",
        //                 "auction_code":"BTC-USDT-2023-10-01T08:09:09.000Z",
        //                 "price":"27236.83000000",
        //                 "volume":"0.0283",
        //                 "imbalance":"-1.0754",
        //                 "logical_time":"2023-10-01T08:09:09.000Z",
        //                 "call_time":"2023-10-01T08:09:09.078Z"
        //             }
        //         )
        //     }
        //
        $auctions = $this->safe_list($response, 'auctions', array());
        return $this->parse_trades($auctions, $market, $since, $limit);
    }

    public function parse_trade(array $trade, ?array $market = null): array {
        //
        // fetchTrades
        //     {
        //         "symbol" => "BTC-USDT",
        //         "auction_code" => "BTC-USDT-2023-10-01T08:05:56.000Z",
        //         "price" => "27241.53000000",
        //         "volume" => "0.0052",
        //         "imbalance" => "-1.0983",
        //         "logical_time" => "2023-10-01T08:05:56.000Z",
        //         "call_time" => "2023-10-01T08:05:56.068Z"
        //     }
        //
        // fetchMyTrades
        //     {
        //         "symbol" => "ETH-USDT",
        //         "auction_code" => "ETH-USDT-2023-10-20T13:22:14.000Z",
        //         "order_id" => "83ed365f-497d-433b-96c1-9d08c1a12842",
        //         "quantity" => "0.0008",
        //         "price" => "1615.24000000",
        //         "fee" => "0.005815",
        //         "fee_type" => "taker",
        //         "fee_currency" => "USDT",
        //         "logical_time" => "2023-10-20T13:22:14.000Z"
        //     }
        //
        $marketId = $this->safe_string($trade, 'symbol');
        $market = $this->safe_market($marketId, $market);
        $symbol = $market['symbol'];
        $id = $this->safe_string($trade, 'auction_code');
        $timestamp = $this->parse8601($this->safe_string($trade, 'logical_time'));
        $priceString = $this->safe_string($trade, 'price');
        $amountString = $this->safe_string_2($trade, 'volume', 'quantity');
        $order = $this->safe_string($trade, 'order_id');
        $fee = null;
        $side = null;
        $feeCost = $this->safe_string($trade, 'fee');
        if ($feeCost !== null) {
            // only in fetchMyTrades
            $amountIsNegative = Precise::string_lt($amountString, '0');
            if ($amountIsNegative) {
                $side = 'sell';
                $amountString = Precise::string_neg($amountString);
            } else {
                $side = 'buy';
            }
            $fee = array(
                'cost' => $feeCost,
                'currency' => $this->safe_string($trade, 'fee_currency'),
            );
        } else {
            $imbalance = $this->safe_string($trade, 'imbalance');
            if (Precise::string_lt($imbalance, '0')) {
                $side = 'buy';
            } else {
                $side = 'sell';
            }
        }
        $takerOrMaker = $this->safe_string($trade, 'fee_type');
        return $this->safe_trade(array(
            'id' => $id,
            'order' => $order,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'symbol' => $symbol,
            'type' => null,
            'side' => $side,
            'takerOrMaker' => $takerOrMaker,
            'price' => $priceString,
            'amount' => $amountString,
            'cost' => null,
            'fee' => $fee,
            'info' => $trade,
        ), $market);
    }

    public function fetch_trading_fees($params = array ()): array {
        /**
         * fetch the trading $fees for multiple markets
         *
         * @see https://trade-docs.coinlist.co/?javascript--nodejs#list-$fees
         *
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @return {array} a dictionary of ~@link https://docs.ccxt.com/#/?$id=fee-structure fee structures~ indexed by $market symbols
         */
        $this->load_markets();
        $response = $this->privateGetV1Fees ($params);
        //
        //     {
        //         fees_by_symbols => {
        //             'BTC-USD,BTC-USDT,ETH-USD,ETH-USDT,ETH-BTC,AAVE-USD,AAVE-USDT,ALGO-USD,ALGO-USDT,AVAX-USD,AVAX-USDT,BICO-USD,BICO-USDT,BLD-USD,BLD-USDT,BTRST-USDT,BZZ-USDT,CELO-USD,CELO-BTC,CFG-USD,CFG-USDT,CLV-USDT,COMP-USD,COMP-USDT,CYBER-USDT,CQT-USDT,CSPR-USD,CSPR-USDT,CUSD-USD,CUSD-USDC,DOGE-USD,DOGE-USDT,DOT-USD,DOT-USDT,EFI-USDT,FIL-USD,FIL-USDT,FLOW-USD,FLOW-USDT,GAL-USD,GAL-USDT,GODS-USDT,GOG-USDT,HMT-USD,HMT-USDT,ICP-USD,ICP-USDT,IMX-USD,IMX-USDT,LINK-USD,LINK-USDT,MATIC-USD,MATIC-USDT,MINA-USD,MINA-USDT,MKR-USD,MKR-USDT,NEON-USDT,NYM-USD,NYM-USDT,OCEAN-USD,OXT-USD,ROSE-USD,ROSE-USDT,SKL-USD,SKL-USDT,SOL-USD,SOL-USDT,STX-USDT,SUI-USDT,T-USDT,UNI-USD,UNI-USDT,USDT-USD,VEGA-USDT,WAXL-USD,WAXL-USDT,WBTC-BTC,WCFG-USD,WCFG-USDT,XTZ-USD' => {
        //                 base => array(
        //                     $fees => array( maker => '0', taker => '0.0045', liquidation => '0' ),
        //                     floors => array( maker => null, taker => null )
        //                 ),
        //                 volume_tier_1 => array(
        //                     $fees => array( maker => '0', taker => '0.003', liquidation => '0' ),
        //                     floors => array( maker => null, taker => null )
        //                 ),
        //                 volume_tier_2 => array(
        //                     $fees => array( maker => '0', taker => '0.0025', liquidation => '0' ),
        //                     floors => array( maker => null, taker => null )
        //                 ),
        //                 volume_tier_3 => array(
        //                     $fees => array( maker => '0', taker => '0.002', liquidation => '0' ),
        //                     floors => array( maker => null, taker => null )
        //                 ),
        //                 volume_tier_4 => array(
        //                     $fees => array( maker => '0', taker => '0.0018', liquidation => '0' ),
        //                     floors => array( maker => null, taker => null )
        //                 ),
        //                 volume_tier_5 => array(
        //                     $fees => array( maker => '0', taker => '0.0018', liquidation => '0' ),
        //                     floors => array( maker => null, taker => null )
        //                 ),
        //                 volume_tier_6 => array(
        //                     $fees => array( maker => '0', taker => '0.0016', liquidation => '0' ),
        //                     floors => array( maker => null, taker => null )
        //                 ),
        //                 volume_tier_7 => array(
        //                     $fees => array( maker => '0', taker => '0.0013', liquidation => '0' ),
        //                     floors => array( maker => null, taker => null )
        //                 ),
        //                 volume_tier_8 => array(
        //                     $fees => array( maker => '0', taker => '0.0012', liquidation => '0' ),
        //                     floors => array( maker => null, taker => null )
        //                 ),
        //                 volume_tier_9 => {
        //                     $fees => array( maker => '0', taker => '0.001', liquidation => '0' ),
        //                     floors => array( maker => null, taker => null )
        //                 }
        //                 volume_tier_10 => array(
        //                     $fees => array( maker => '0', taker => '0.0005', liquidation => '0' ),
        //                     floors => array( maker => null, taker => null )
        //                 ),
        //                 volume_tier_11 => array(
        //                     $fees => array( maker => '0', taker => '0.0005', liquidation => '0' ),
        //                     floors => array( maker => null, taker => null )
        //                 ),
        //             }
        //         }
        //     }
        //
        $fees = $this->safe_value($response, 'fees_by_symbols', array());
        $result = array();
        $groupsOfSymbols = is_array($fees) ? array_keys($fees) : array();
        for ($i = 0; $i < count($groupsOfSymbols); $i++) {
            $group = $groupsOfSymbols[$i];
            $feeTiers = $this->safe_value($fees, $group, array());
            $tiers = $this->parse_fee_tiers($feeTiers);
            $firstTier = $this->safe_value($feeTiers, 'base', array());
            $firstTierFees = $this->safe_value($firstTier, 'fees', array());
            $ids = explode(',', $group);
            for ($j = 0; $j < count($ids); $j++) {
                $id = $ids[$j];
                $market = $this->safe_market($id);
                $symbol = $market['symbol'];
                $info = array();
                $info[$group] = $feeTiers;
                $result[$symbol] = array(
                    'info' => $info,
                    'symbol' => $symbol,
                    'maker' => $this->safe_number($firstTierFees, 'maker'),
                    'taker' => $this->safe_number($firstTierFees, 'taker'),
                    'percentage' => true,
                    'tierBased' => true,
                    'tiers' => $tiers,
                );
            }
        }
        return $result;
    }

    public function parse_fee_tiers($feeTiers, ?array $market = null) {
        //
        //     base => array(
        //         fees => array( $maker => '0', $taker => '0.0045', liquidation => '0' ),
        //         floors => array( $maker => null, $taker => null )
        //     ),
        //     volume_tier_1 => array(
        //         fees => array( $maker => '0', $taker => '0.003', liquidation => '0' ),
        //         floors => array( $maker => null, $taker => null )
        //     ),
        //     volume_tier_2 => array(
        //         fees => array( $maker => '0', $taker => '0.0025', liquidation => '0' ),
        //         floors => array( $maker => null, $taker => null )
        //     ),
        //     volume_tier_3 => array(
        //         fees => array( $maker => '0', $taker => '0.002', liquidation => '0' ),
        //         floors => array( $maker => null, $taker => null )
        //     ),
        //     volume_tier_4 => array(
        //         fees => array( $maker => '0', $taker => '0.0018', liquidation => '0' ),
        //         floors => array( $maker => null, $taker => null )
        //     ),
        //     volume_tier_5 => array(
        //         fees => array( $maker => '0', $taker => '0.0018', liquidation => '0' ),
        //         floors => array( $maker => null, $taker => null )
        //     ),
        //     volume_tier_6 => array(
        //         fees => array( $maker => '0', $taker => '0.0016', liquidation => '0' ),
        //         floors => array( $maker => null, $taker => null )
        //     ),
        //     volume_tier_7 => array(
        //         fees => array( $maker => '0', $taker => '0.0013', liquidation => '0' ),
        //         floors => array( $maker => null, $taker => null )
        //     ),
        //     volume_tier_8 => array(
        //         fees => array( $maker => '0', $taker => '0.0012', liquidation => '0' ),
        //         floors => array( $maker => null, $taker => null )
        //     ),
        //     volume_tier_9 => {
        //         fees => array( $maker => '0', $taker => '0.001', liquidation => '0' ),
        //         floors => array( $maker => null, $taker => null )
        //     }
        //     volume_tier_10 => array(
        //         fees => array( $maker => '0', $taker => '0.0005', liquidation => '0' ),
        //         floors => array( $maker => null, $taker => null )
        //     ),
        //     volume_tier_11 => array(
        //         fees => array( $maker => '0', $taker => '0.0005', liquidation => '0' ),
        //         floors => array( $maker => null, $taker => null )
        //     ),
        //
        $takerFees = array();
        $makerFees = array();
        $keys = is_array($feeTiers) ? array_keys($feeTiers) : array();
        $keysLength = count($keys);
        if ($keysLength > 0) {
            for ($i = 0; $i < $keysLength; $i++) {
                $key = $keys[$i];
                $tier = $this->safe_value($feeTiers, $key, array());
                $tierFees = $this->safe_value($tier, 'fees', array());
                $taker = $this->safe_string($tierFees, 'taker');
                $maker = $this->safe_string($tierFees, 'maker');
                $makerFees[] = array( null, $this->parse_number($maker) );
                $takerFees[] = array( null, $this->parse_number($taker) );
            }
            $takerFees = $this->sort_by($takerFees, 1, true);
            $makerFees = $this->sort_by($makerFees, 1, true);
            $firstTier = $this->safe_dict($takerFees, 0, array());
            $exchangeFees = $this->safe_dict($this, 'fees', array());
            $exchangeFeesTrading = $this->safe_dict($exchangeFees, 'trading', array());
            $exchangeFeesTradingTiers = $this->safe_dict($exchangeFeesTrading, 'tiers', array());
            $exchangeFeesTradingTiersTaker = $this->safe_list($exchangeFeesTradingTiers, 'taker', array());
            $exchangeFeesTradingTiersMaker = $this->safe_list($exchangeFeesTradingTiers, 'maker', array());
            $exchangeFeesTradingTiersTakerLength = count($exchangeFeesTradingTiersTaker);
            $firstTierLength = count($firstTier);
            if (($keysLength === $exchangeFeesTradingTiersTakerLength) && ($firstTierLength > 0)) {
                for ($i = 0; $i < $keysLength; $i++) {
                    $takerFees[$i][0] = $exchangeFeesTradingTiersTaker[$i][0];
                    $makerFees[$i][0] = $exchangeFeesTradingTiersMaker[$i][0];
                }
            }
        }
        return array(
            'maker' => $makerFees,
            'taker' => $takerFees,
        );
    }

    public function fetch_accounts($params = array ()): array {
        /**
         * fetch all the $accounts associated with a profile
         *
         * @see https://trade-docs.coinlist.co/?javascript--nodejs#list-$accounts
         *
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @return {array} a dictionary of ~@link https://docs.ccxt.com/#/?id=account-structure account structures~ indexed by the account type
         */
        $this->load_markets();
        $response = $this->privateGetV1Accounts ($params);
        //
        //     {
        //         "accounts" => array(
        //             {
        //                 "trader_id" => "b18507ce-7d55-4bf1-b12a-0ccca5b90936",
        //                 "name" => "string"
        //             }
        //         )
        //     }
        //
        $accounts = $this->safe_value($response, 'accounts', array());
        return $this->parse_accounts($accounts, $params);
    }

    public function parse_account($account) {
        //
        //     {
        //         "trader_id" => "b18507ce-7d55-4bf1-b12a-0ccca5b90936",
        //         "name" => "string"
        //     }
        //
        return array(
            'id' => $this->safe_string($account, 'trader_id'),
            'type' => 'trading',
            'code' => null,
            'info' => $account,
        );
    }

    public function fetch_balance($params = array ()): array {
        /**
         * query for balance and get the amount of funds available for trading or funds locked in orders
         *
         * @see https://trade-docs.coinlist.co/?javascript--nodejs#list-balances
         *
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @return {array} a ~@link https://docs.ccxt.com/#/?id=balance-structure balance structure~
         */
        $this->load_markets();
        $response = $this->privateGetV1Balances ($params);
        return $this->parse_balance($response);
    }

    public function parse_balance($response): array {
        //
        //     {
        //         "asset_balances" => array(
        //             "BTC" => "0.00308696",
        //             "ETH" => "20.000000000000000000"
        //         ),
        //         "asset_holds" => array(
        //             "BTC" => "0.00000000",
        //             "ETH" => "1.000000000000000000"
        //         ),
        //         "net_liquidation_value_usd" => "string"
        //     }
        //
        $result = array(
            'info' => $response,
            'timestamp' => null,
            'datetime' => null,
        );
        $totalBalances = $this->safe_value($response, 'asset_balances', array());
        $usedBalances = $this->safe_value($response, 'asset_holds', array());
        $currencyIds = is_array($totalBalances) ? array_keys($totalBalances) : array();
        for ($i = 0; $i < count($currencyIds); $i++) {
            $currencyId = $currencyIds[$i];
            $code = $this->safe_currency_code($currencyId);
            $account = $this->account();
            $account['total'] = $this->safe_string($totalBalances, $currencyId);
            $account['used'] = $this->safe_string($usedBalances, $currencyId, '0');
            $result[$code] = $account;
        }
        return $this->safe_balance($result);
    }

    public function fetch_my_trades(?string $symbol = null, ?int $since = null, ?int $limit = null, $params = array ()) {
        /**
         * fetch all trades made by the user
         *
         * @see https://trade-docs.coinlist.co/?javascript--nodejs#list-$fills
         *
         * @param {string} $symbol unified $market $symbol
         * @param {int} [$since] the earliest time in ms to fetch trades for
         * @param {int} [$limit] the maximum number of trades structures to retrieve (default 200, max 500)
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @param {int} [$params->until] the latest time in ms to fetch entries for
         * @return {Trade[]} a list of ~@link https://docs.ccxt.com/#/?id=trade-structure trade structures~
         */
        $this->load_markets();
        $request = array();
        $market = null;
        if ($symbol !== null) {
            $market = $this->market($symbol);
            $request['symbol'] = $market['id'];
        }
        if ($since !== null) {
            $request['start_time'] = $this->iso8601($since);
        }
        if ($limit !== null) {
            $request['count'] = $limit;
        }
        $until = $this->safe_integer($params, 'until');
        if ($until !== null) {
            $params = $this->omit($params, array( 'until' ));
            $request['end_time'] = $this->iso8601($until);
        }
        $response = $this->privateGetV1Fills ($this->extend($request, $params));
        //
        //     {
        //         "fills" => array(
        //             array(
        //                 "symbol" => "ETH-USDT",
        //                 "auction_code" => "ETH-USDT-2023-10-20T13:16:30.000Z",
        //                 "order_id" => "39911d5f-c789-4a7d-ad34-820a804d1da6",
        //                 "quantity" => "-0.0009",
        //                 "price" => "1608.83000000",
        //                 "fee" => "0.006516",
        //                 "fee_type" => "taker",
        //                 "fee_currency" => "USDT",
        //                 "logical_time" => "2023-10-20T13:16:30.000Z"
        //             ),
        //             array(
        //                 "symbol" => "ETH-USDT",
        //                 "auction_code" => "ETH-USDT-2023-10-20T13:22:14.000Z",
        //                 "order_id" => "83ed365f-497d-433b-96c1-9d08c1a12842",
        //                 "quantity" => "0.0008",
        //                 "price" => "1615.24000000",
        //                 "fee" => "0.005815",
        //                 "fee_type" => "taker",
        //                 "fee_currency" => "USDT",
        //                 "logical_time" => "2023-10-20T13:22:14.000Z"
        //             ),
        //         )
        //     }
        //
        $fills = $this->safe_list($response, 'fills', array());
        return $this->parse_trades($fills, $market, $since, $limit);
    }

    public function fetch_order_trades(string $id, ?string $symbol = null, ?int $since = null, ?int $limit = null, $params = array ()): array {
        /**
         * fetch all the trades made from a single order
         *
         * @see https://trade-docs.coinlist.co/?javascript--nodejs#list-fills
         *
         * @param {string} $id order $id
         * @param {string} $symbol unified market $symbol
         * @param {int} [$since] the earliest time in ms to fetch trades for
         * @param {int} [$limit] the maximum number of trades to retrieve
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @return {array[]} a list of ~@link https://docs.ccxt.com/#/?$id=trade-structure trade structures~
         */
        $request = array(
            'order_id' => $id,
        );
        return $this->fetch_my_trades($symbol, $since, $limit, $this->extend($request, $params));
    }

    public function fetch_orders(?string $symbol = null, ?int $since = null, ?int $limit = null, $params = array ()): array {
        /**
         * fetches information on multiple $orders made by the user
         *
         * @see https://trade-docs.coinlist.co/?javascript--nodejs#list-$orders
         *
         * @param {string} $symbol unified $market $symbol of the $market $orders were made in
         * @param {int} [$since] the earliest time in ms to fetch $orders for
         * @param {int} [$limit] the maximum number of order structures to retrieve (default 200, max 500)
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @param {int} [$params->until] the latest time in ms to fetch entries for
         * @param {string|string[]} [$params->status] the $status of the order - 'accepted', 'done', 'canceled', 'rejected', 'pending' (default array( 'accepted', 'done', 'canceled', 'rejected', 'pending' ))
         * @return {Order[]} a list of ~@link https://docs.ccxt.com/#/?id=order-structure order structures~
         */
        $this->load_markets();
        $status = $this->safe_string($params, 'status');
        if ($status === null) {
            $status = array( 'accepted', 'done', 'canceled', 'rejected', 'pending' );
        }
        $request = array(
            'status' => $status,
        );
        $market = null;
        if ($symbol !== null) {
            $market = $this->market($symbol);
            $request['symbol'] = $market['id'];
        }
        if ($since !== null) {
            $request['start_time'] = $this->iso8601($since);
        }
        if ($limit !== null) {
            $request['count'] = $limit;
        }
        $until = $this->safe_integer($params, 'until');
        if ($until !== null) {
            $params = $this->omit($params, array( 'until' ));
            $request['end_time'] = $this->iso8601($until);
        }
        $response = $this->privateGetV1Orders ($this->extend($request, $params));
        //
        //     {
        //         "orders":array(
        //             {
        //                 "order_id":"913ea6e7-9fc9-43fb-9db1-f195d3baa93f",
        //                 "price":"35800.00000000",
        //                 "stop_price":null,
        //                 "cost":"0.00000000",
        //                 "fill_fees":"0.00000000",
        //                 "trader_id":"9c6f737e-a829-4843-87b1-b1ce86f2853b",
        //                 "status":"accepted",
        //                 "epoch_timestamp":"2023-10-26T08:20:56.307Z",
        //                 "origin":"web",
        //                 "self_trade_prevention":null,
        //                 "client_id":null,
        //                 "created_at":"2023-10-26T08:20:56.307Z",
        //                 "symbol":"BTC-USDT",
        //                 "size":"0.0003",
        //                 "side":"sell",
        //                 "type":"limit",
        //                 "post_only":false,
        //                 "size_filled":"0.0000"
        //             }
        //         )
        //     }
        //
        $orders = $this->safe_list($response, 'orders', array());
        return $this->parse_orders($orders, $market, $since, $limit);
    }

    public function fetch_order(string $id, ?string $symbol = null, $params = array ()) {
        /**
         * fetches information on an order made by the user
         *
         * @see https://trade-docs.coinlist.co/?javascript--nodejs#get-specific-order-by-$id
         *
         * @param {int|string} $id order $id
         * @param {string} $symbol not used by coinlist fetchOrder ()
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @return {array} An ~@link https://docs.ccxt.com/#/?$id=order-structure order structure~
         */
        $this->load_markets();
        $request = array(
            'order_id' => $id,
        );
        $response = $this->privateGetV1OrdersOrderId ($this->extend($request, $params));
        //
        //     {
        //         "order_id" => "93101167-9065-4b9c-b98b-5d789a3ed9fe",
        //         "client_id" => "string",
        //         "symbol" => "string",
        //         "type" => "market",
        //         "side" => "buy",
        //         "size" => "string",
        //         "price" => "string",
        //         "stop_price" => "string",
        //         "stop_trigger" => "last",
        //         "self_trade_prevention" => "keep-newest",
        //         "average_fill_price" => "string",
        //         "fill_fees" => "string",
        //         "size_filled" => "string",
        //         "created_at" => "2019-08-24T14:15:22Z",
        //         "epoch_timestamp" => "2019-08-24T14:15:22Z",
        //         "post_only" => true,
        //         "peg_price_type" => "trailing-stop",
        //         "peg_offset_value" => "string",
        //         "origin" => "web",
        //         "status" => "pending"
        //     }
        //
        return $this->parse_order($response);
    }

    public function fetch_open_orders(?string $symbol = null, ?int $since = null, ?int $limit = null, $params = array ()): array {
        /**
         * fetch all unfilled currently open orders
         *
         * @see https://trade-docs.coinlist.co/?javascript--nodejs#list-orders
         *
         * @param {string} $symbol unified market $symbol
         * @param {int} [$since] the earliest time in ms to fetch open orders for
         * @param {int} [$limit] the maximum number of open order structures to retrieve (default 200, max 500)
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @param {int} [$params->until] the latest time in ms to fetch entries for
         * @return {Order[]} a list of ~@link https://docs.ccxt.com/#/?id=order-structure order structures~
         */
        $this->load_markets();
        $request = array(
            'status' => 'accepted',
        );
        return $this->fetch_orders($symbol, $since, $limit, $this->extend($request, $params));
    }

    public function fetch_closed_orders(?string $symbol = null, ?int $since = null, ?int $limit = null, $params = array ()): array {
        /**
         * fetches information on multiple closed orders made by the user
         *
         * @see https://trade-docs.coinlist.co/?javascript--nodejs#list-orders
         *
         * @param {string} $symbol unified market $symbol of the market orders were made in
         * @param {int} [$since] the earliest time in ms to fetch orders for
         * @param {int} [$limit] the maximum number of closed order structures to retrieve (default 200, max 500)
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @param {int} [$params->until] the latest time in ms to fetch entries for
         * @return {Order[]} a list of ~@link https://docs.ccxt.com/#/?id=order-structure order structures~
         */
        $this->load_markets();
        $request = array(
            'status' => 'done',
        );
        return $this->fetch_orders($symbol, $since, $limit, $this->extend($request, $params));
    }

    public function fetch_canceled_orders(?string $symbol = null, ?int $since = null, ?int $limit = null, $params = array ()) {
        /**
         * fetches information on multiple canceled orders made by the user
         *
         * @see https://trade-docs.coinlist.co/?javascript--nodejs#list-orders
         *
         * @param {string} $symbol unified market $symbol of the market orders were made in
         * @param {int} [$since] the earliest time in ms to fetch orders for
         * @param {int} [$limit] the maximum number of canceled order structures to retrieve (default 200, max 500)
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @param {int} [$params->until] the latest time in ms to fetch entries for
         * @return {array} a list of ~@link https://docs.ccxt.com/#/?id=order-structure order structures~
         */
        $this->load_markets();
        $request = array(
            'status' => 'canceled',
        );
        return $this->fetch_orders($symbol, $since, $limit, $this->extend($request, $params));
    }

    public function cancel_all_orders(?string $symbol = null, $params = array ()) {
        /**
         * cancel open $orders of $market
         *
         * @see https://trade-docs.coinlist.co/?javascript--nodejs#cancel-all-$orders
         *
         * @param {string} $symbol unified $market $symbol
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @return {array[]} a list of ~@link https://docs.ccxt.com/#/?id=order-structure order structures~
         */
        $this->load_markets();
        $market = null;
        $request = array();
        if ($symbol !== null) {
            $market = $this->market($symbol);
            $request['symbol'] = $market['id'];
        }
        $response = $this->privateDeleteV1Orders ($this->extend($request, $params));
        //
        //     {
        //         "message" => "Order cancellation $request received.",
        //         "timestamp" => "2023-10-26T10:29:28.652Z"
        //     }
        //
        $orders = array( $response );
        return $this->parse_orders($orders, $market);
    }

    public function cancel_order(string $id, ?string $symbol = null, $params = array ()) {
        /**
         * cancels an open order
         *
         * @see https://trade-docs.coinlist.co/?javascript--nodejs#cancel-specific-order-by-$id
         *
         * @param {string} $id order $id
         * @param {string} $symbol not used by coinlist cancelOrder ()
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @return {array} An ~@link https://docs.ccxt.com/#/?$id=order-structure order structure~
         */
        $this->load_markets();
        $request = array(
            'order_id' => $id,
        );
        $response = $this->privateDeleteV1OrdersOrderId ($this->extend($request, $params));
        //
        //     {
        //         "message" => "Cancel order $request received.",
        //         "order_id" => "d36e7588-6525-485c-b768-8ad8b3f745f9",
        //         "timestamp" => "2023-10-26T14:36:37.559Z"
        //     }
        //
        return $this->parse_order($response);
    }

    public function cancel_orders($ids, ?string $symbol = null, $params = array ()) {
        /**
         * cancel multiple $orders
         *
         * @see https://trade-docs.coinlist.co/?javascript--nodejs#cancel-specific-$orders
         *
         * @param {string[]} $ids order $ids
         * @param {string} $symbol not used by coinlist cancelOrders ()
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @return {array} an list of ~@link https://docs.ccxt.com/#/?id=order-structure order structures~
         */
        $this->load_markets();
        $params = $ids;
        $response = $this->privateDeleteV1OrdersBulk ($params);
        //
        //    {
        //        "message" => "Cancel order requests received.",
        //        "order_ids" => array(
        //            "ff132955-43bc-4fe5-9d9c-5ba226cc89a0"
        //        ),
        //        "timestamp" => "2024-06-01T02:32:30.305Z"
        //    }
        //
        $orderIds = $this->safe_list($response, 'order_ids', array());
        $orders = array();
        $datetime = $this->safe_string($response, 'timestamp');
        for ($i = 0; $i < count($orderIds); $i++) {
            $orders[] = $this->safe_order(array(
                'info' => $orderIds[$i],
                'id' => $orderIds[$i],
                'lastUpdateTimestamp' => $this->parse8601($datetime),
            ));
        }
        return $orders;
    }

    public function create_order(string $symbol, string $type, string $side, float $amount, ?float $price = null, $params = array ()) {
        /**
         * create a trade $order
         *
         * @see https://trade-docs.coinlist.co/?javascript--nodejs#create-new-$order
         *
         * @param {string} $symbol unified $symbol of the $market to create an $order in
         * @param {string} $type 'market' or 'limit' or 'stop_market' or 'stop_limit' or 'take_market' or 'take_limit'
         * @param {string} $side 'buy' or 'sell'
         * @param {float} $amount how much of currency you want to trade in units of base currency
         * @param {float} [$price] the $price at which the $order is to be fulfilled, in units of the quote currency, ignored in $market orders
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @param {bool} [$params->postOnly] if true, the $order will only be posted to the $order book and not executed immediately (default false)
         * @param {float} [$params->triggerPrice] only for the 'stop_market', 'stop_limit', 'take_market' or 'take_limit' orders (the $price at which an $order is triggered)
         * @param {string} [$params->clientOrderId] client $order id (default null)
         * @return {array} an ~@link https://docs.ccxt.com/#/?id=$order-structure $order structure~
         */
        $this->load_markets();
        $market = $this->market($symbol);
        $request = array(
            'symbol' => $market['id'],
            'type' => $type,
            'side' => $side,
            'size' => $this->amount_to_precision($symbol, $amount),
        );
        $isMarket = false;
        if (($type === 'limit') || ($type === 'stop_limit') || ($type === 'take_limit')) {
            if ($price === null) {
                throw new ArgumentsRequired($this->id . ' createOrder() requires a $price argument for a ' . $type . ' order');
            }
            $request['price'] = $this->price_to_precision($symbol, $price);
        } else {
            $isMarket = true;
        }
        $postOnly = null;
        list($postOnly, $params) = $this->handle_post_only($isMarket, false, $params);
        if ($postOnly) {
            $request['post_only'] = true;
        }
        $triggerPrice = $this->safe_number_n($params, array( 'triggerPrice', 'trigger_price', 'stopPrice', 'stop_price' ));
        if ($triggerPrice !== null) {
            $params = $this->omit($params, array( 'triggerPrice', 'trigger_price', 'stopPrice' ));
            $request['stop_price'] = $this->price_to_precision($symbol, $triggerPrice);
            if ($type === 'market') {
                $request['type'] = 'stop_market';
            } elseif ($type === 'limit') {
                $request['type'] = 'stop_limit';
            }
        } elseif (($type === 'stop_market') || ($type === 'stop_limit') || ($type === 'take_market') || ($type === 'take_limit')) {
            throw new ArgumentsRequired($this->id . ' createOrder() requires a $triggerPrice parameter for stop-loss and take-profit orders');
        }
        $clientOrderId = $this->safe_string_2($params, 'clientOrderId', 'client_id');
        if ($clientOrderId !== null) {
            $request['client_id'] = $clientOrderId;
            $params = $this->omit($params, array( 'clientOrderId', 'client_id' ));
        }
        $response = $this->privatePostV1Orders ($this->extend($request, $params));
        //
        //     {
        //         "message" => "New $order $request received.",
        //         "order" => array(
        //             "symbol" => "BTC-USDT",
        //             "type" => "market",
        //             "side" => "sell",
        //             "size" => "0.0003",
        //             "order_id" => "cad67c0f-9aec-4ac8-ac03-aaf5db299ff7",
        //             "trader_id" => "9c6f737e-a829-4843-87b1-b1ce86f2853b"
        //         ),
        //         "timestamp" => "2023-10-26T11:30:55.376Z"
        //     }
        //
        $order = $this->safe_dict($response, 'order', array());
        return $this->parse_order($order, $market);
    }

    public function edit_order(string $id, string $symbol, string $type, string $side, ?float $amount = null, ?float $price = null, $params = array ()) {
        /**
         * create a trade order
         *
         * @see https://trade-docs.coinlist.co/?javascript--nodejs#modify-existing-order
         *
         * @param {string} $id order $id
         * @param {string} $symbol unified $symbol of the $market to create an order in
         * @param {string} $type 'market' or 'limit' or 'stop_market' or 'stop_limit' or 'take_market' or 'take_limit'
         * @param {string} $side 'buy' or 'sell'
         * @param {float} $amount how much of currency you want to trade in units of base currency
         * @param {float} [$price] the $price at which the order is to be fulfilled, in units of the quote currency, ignored in $market orders
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @return {array} an ~@link https://docs.ccxt.com/#/?$id=order-structure order structure~
         */
        $this->load_markets();
        if ($amount === null) {
            throw new ArgumentsRequired($this->id . ' editOrder() requires an $amount argument');
        }
        $market = $this->market($symbol);
        $request = array(
            'order_id' => $id,
            'type' => $type,
            'side' => $side,
            'size' => $this->amount_to_precision($symbol, $amount),
        );
        if ($price !== null) {
            $request['price'] = $this->price_to_precision($symbol, $price);
        }
        $response = $this->privatePatchV1OrdersOrderId ($this->extend($request, $params));
        return $this->parse_order($response, $market);
    }

    public function parse_order(array $order, ?array $market = null): array {
        //
        // fetchOrder
        //     {
        //         "order_id" => "913ea6e7-9fc9-43fb-9db1-f195d3baa93f",
        //         "price" => "35800.00000000",
        //         "stop_price":null,
        //         "cost" => "0.00000000",
        //         "fill_fees" => "0.00000000",
        //         "trader_id" => "9c6f737e-a829-4843-87b1-b1ce86f2853b",
        //         "status" => "canceled",
        //         "epoch_timestamp" => "2023-10-26T08:20:56.307Z",
        //         "origin" => "web",
        //         "self_trade_prevention":null,
        //         "client_id":null,
        //         "symbol" => "BTC-USDT",
        //         "size" => "0.0003",
        //         "side" => "sell",
        //         "type" => "limit",
        //         "post_only":false,
        //         "size_filled" => "0.0000"
        //     }
        //
        // fetchOrders
        //     {
        //         "order_id":"913ea6e7-9fc9-43fb-9db1-f195d3baa93f",
        //         "price":"35800.00000000",
        //         "stop_price":null,
        //         "cost":"0.00000000",
        //         "fill_fees":"0.00000000",
        //         "trader_id":"9c6f737e-a829-4843-87b1-b1ce86f2853b",
        //         "status":"accepted",
        //         "epoch_timestamp":"2023-10-26T08:20:56.307Z",
        //         "origin":"web",
        //         "self_trade_prevention":null,
        //         "client_id":null,
        //         "created_at":"2023-10-26T08:20:56.307Z",
        //         "symbol":"BTC-USDT",
        //         "size":"0.0003",
        //         "side":"sell",
        //         "type":"limit",
        //         "post_only":false,
        //         "size_filled":"0.0000"
        //     }
        //
        // createOrder
        //     array(
        //         "symbol" => "BTC-USDT",
        //         "type" => "market",
        //         "side" => "sell",
        //         "size" => "0.0003",
        //         "order_id" => "cad67c0f-9aec-4ac8-ac03-aaf5db299ff7",
        //         "trader_id" => "9c6f737e-a829-4843-87b1-b1ce86f2853b"
        //     ),
        //
        // cancelOrder
        //     {
        //         "message" => "Cancel $order request received.",
        //         "order_id" => "d36e7588-6525-485c-b768-8ad8b3f745f9",
        //         "timestamp" => "2023-10-26T14:36:37.559Z"
        //     }
        //
        // cancelOrders
        //     {
        //         "message" => "Order cancellation request received.",
        //         "timestamp" => "2023-10-26T10:29:28.652Z"
        //     }
        //
        // cancelAllOrders
        //     {
        //         "message" => "Order cancellation request received.",
        //         "timestamp" => "2023-10-26T10:29:28.652Z"
        //     }
        //
        $id = $this->safe_string($order, 'order_id');
        $marketId = $this->safe_string($order, 'symbol');
        $market = $this->safe_market($marketId, $market);
        $clientOrderId = $this->safe_string($order, 'client_id');
        $timestampString = $this->safe_string_2($order, 'created_at', 'epoch_timestamp');
        if ($timestampString === null) {
            $timestampString = $this->safe_string($order, 'timestamp');
        }
        $timestamp = $this->parse8601($timestampString);
        $status = $this->parse_order_status($this->safe_string($order, 'status'));
        $type = $this->parse_order_type($this->safe_string($order, 'type'));
        $side = $this->safe_string($order, 'side');
        $price = $this->safe_string($order, 'price');
        $triggerPrice = $this->safe_string($order, 'stop_price');
        $average = $this->safe_string($order, 'average_fill_price'); // from documentation
        $amount = $this->safe_string($order, 'size');
        $filled = $this->safe_string($order, 'size_filled');
        $feeCost = $this->safe_string($order, 'fill_fees');
        $postOnly = $this->safe_value($order, 'post_only');
        $fee = null;
        if ($feeCost !== null) {
            $fee = array(
                'currency' => $market['quote'],
                'cost' => $feeCost,
                'rate' => null,
            );
        }
        return $this->safe_order(array(
            'id' => $id,
            'clientOrderId' => $clientOrderId,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'lastTradeTimestamp' => null,
            'status' => $status,
            'symbol' => $market['symbol'],
            'type' => $type,
            'timeInForce' => 'GTC',
            'side' => $side,
            'price' => $price,
            'triggerPrice' => $triggerPrice,
            'average' => $average,
            'amount' => $amount,
            'cost' => null,
            'filled' => $filled,
            'remaining' => null,
            'fee' => $fee,
            'trades' => null,
            'info' => $order,
            'postOnly' => $postOnly,
        ), $market);
    }

    public function parse_order_status(?string $status) {
        $statuses = array(
            'pending' => 'open',
            'accepted' => 'open',
            'rejected' => 'rejected',
            'done' => 'closed',
            'canceled' => 'canceled',
        );
        return $this->safe_string($statuses, $status, $status);
    }

    public function parse_order_type($status) {
        $statuses = array(
            'market' => 'market',
            'limit' => 'limit',
            'stop_market' => 'market',
            'stop_limit' => 'limit',
            'take_market' => 'market',
            'take_limit' => 'limit',
        );
        return $this->safe_string($statuses, $status, $status);
    }

    public function transfer(string $code, float $amount, string $fromAccount, string $toAccount, $params = array ()): array {
        /**
         * $transfer $currency internally between wallets on the same account
         *
         * @see https://trade-docs.coinlist.co/?javascript--nodejs#$transfer-funds-between-entities
         * @see https://trade-docs.coinlist.co/?javascript--nodejs#$transfer-funds-from-wallet-to-pro
         * @see https://trade-docs.coinlist.co/?javascript--nodejs#$transfer-funds-from-pro-to-wallet
         *
         * @param {string} $code unified $currency $code
         * @param {float} $amount amount to $transfer
         * @param {string} $fromAccount account to $transfer from
         * @param {string} $toAccount account to $transfer to
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @return {array} a ~@link https://docs.ccxt.com/#/?id=$transfer-structure $transfer structure~
         */
        $this->load_markets();
        $currency = $this->currency($code);
        $request = array(
            'asset' => $currency['id'],
            'amount' => $this->currency_to_precision($code, $amount),
        );
        $accountsByType = $this->safe_value($this->options, 'accountsByType', array());
        $fromAcc = $this->safe_string($accountsByType, $fromAccount, $fromAccount);
        $toAcc = $this->safe_string($accountsByType, $toAccount, $toAccount);
        $response = null;
        if (($fromAcc === 'funding') && ($toAcc === 'trading')) {
            $response = $this->privatePostV1TransfersFromWallet ($this->extend($request, $params));
        } elseif (($fromAcc === 'trading') && ($toAcc === 'funding')) {
            $response = $this->privatePostV1TransfersToWallet ($this->extend($request, $params));
        } else {
            $request['from_trader_id'] = $fromAcc;
            $request['to_trader_id'] = $toAcc;
            $response = $this->privatePostV1TransfersInternalTransfer ($this->extend($request, $params));
        }
        //
        // privatePostV1TransfersInternalTransfer
        //     {
        //         "from_trader_id" => "1f494ace-b3ed-4324-b202-55526ed06381",
        //         "to_trader_id" => "d32c7a40-cc24-44b0-8597-f9edb3da989f",
        //         "asset" => "string",
        //         "amount" => "string"
        //     }
        //
        // privatePostV1TransfersFromWallet, privatePostV1TransfersToWallet
        //     {
        //         "transfer_id" => "bb34f528-d9b0-47c6-b11f-4d4840b86ee3"
        //     }
        //
        $transfer = $this->parse_transfer($response, $currency);
        return $transfer;
    }

    public function fetch_transfers(?string $code = null, ?int $since = null, ?int $limit = null, $params = array ()): array {
        /**
         * fetch a history of internal $transfers between CoinList.co and CoinList Pro. It does not return external deposits or withdrawals
         *
         * @see https://trade-docs.coinlist.co/?javascript--nodejs#list-$transfers
         *
         * @param {string} $code unified $currency $code
         * @param {int} [$since] the earliest time in ms to fetch $transfers for
         * @param {int} [$limit] the maximum number of transfer structures to retrieve (default 200, max 500)
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @param {int} [$params->until] the latest time in ms to fetch entries for
         * @return {array[]} a list of ~@link https://docs.ccxt.com/#/?id=transfer-structure transfer structures~
         */
        $this->load_markets();
        $currency = null;
        if ($code !== null) {
            $currency = $this->currency($code);
        }
        $request = array();
        if ($since !== null) {
            $request['start_time'] = $this->iso8601($since);
        }
        if ($limit !== null) {
            $request['count'] = $limit;
        }
        $until = $this->safe_integer($params, 'until');
        if ($until !== null) {
            $params = $this->omit($params, array( 'until' ));
            $request['end_time'] = $this->iso8601($until);
        }
        $response = $this->privateGetV1Transfers ($this->extend($request, $params));
        //
        //     {
        //         "transfers" => array(
        //             array(
        //                 "transfer_id" => "2c02db25-e8f2-4271-8222-e110bfd0aa2a",
        //                 "created_at" => "2023-10-20T13:15:37.000Z",
        //                 "confirmed_at" => "2023-10-20T13:15:37.000Z",
        //                 "asset" => "ETH",
        //                 "amount" => "0.010000000000000000",
        //                 "status" => "confirmed"
        //             ),
        //             {
        //                 "transfer_id" => "890694db-156c-4e93-a3ef-4db61685aca7",
        //                 "created_at" => "2023-10-26T14:32:22.000Z",
        //                 "confirmed_at" => "2023-10-26T14:32:22.000Z",
        //                 "asset" => "USD",
        //                 "amount" => "-3.00",
        //                 "status" => "confirmed"
        //             }
        //         )
        //     }
        //
        $transfers = $this->safe_list($response, 'transfers', array());
        return $this->parse_transfers($transfers, $currency, $since, $limit);
    }

    public function parse_transfer(array $transfer, ?array $currency = null): array {
        //
        // fetchTransfers
        //     {
        //         "transfer_id" => "890694db-156c-4e93-a3ef-4db61685aca7",
        //         "created_at" => "2023-10-26T14:32:22.000Z",
        //         "confirmed_at" => "2023-10-26T14:32:22.000Z",
        //         "asset" => "USD",
        //         "amount" => "-3.00",
        //         "status" => "confirmed"
        //     }
        //
        // $transfer - privatePostV1TransfersInternalTransfer
        //     {
        //         "from_trader_id" => "1f494ace-b3ed-4324-b202-55526ed06381",
        //         "to_trader_id" => "d32c7a40-cc24-44b0-8597-f9edb3da989f",
        //         "asset" => "string",
        //         "amount" => "string"
        //     }
        //
        // $transfer - privatePostV1TransfersFromWallet, privatePostV1TransfersToWallet
        //     {
        //         "transfer_id" => "bb34f528-d9b0-47c6-b11f-4d4840b86ee3"
        //     }
        //
        $currencyId = $this->safe_string($transfer, 'asset');
        $confirmedAt = $this->safe_string($transfer, 'confirmed_at');
        $timetstamp = $this->parse8601($confirmedAt);
        $status = $this->safe_string($transfer, 'status');
        $amountString = $this->safe_string($transfer, 'amount');
        $fromAccount = null;
        $toAccount = null;
        $amount = null;
        if ($amountString !== null) {
            $amountIsNegative = Precise::string_lt($amountString, '0');
            if ($amountIsNegative) {
                $fromAccount = 'trading';
                $toAccount = 'funding';
                $amountString = Precise::string_neg($amountString);
            } else {
                $fromAccount = 'funding';
                $toAccount = 'trading';
            }
            $amount = $this->parse_number($amountString);
        }
        return array(
            'info' => $transfer,
            'id' => $this->safe_string($transfer, 'transfer_id'),
            'timestamp' => $timetstamp,
            'datetime' => $this->iso8601($timetstamp),
            'currency' => $this->safe_currency_code($currencyId, $currency),
            'amount' => $amount,
            'fromAccount' => $fromAccount,
            'toAccount' => $toAccount,
            'status' => $this->parse_transfer_status($status),
        );
    }

    public function parse_transfer_status(?string $status): ?string {
        $statuses = array(
            'confirmed' => 'ok',
        );
        return $this->safe_string($statuses, $status, $status);
    }

    public function fetch_deposits_withdrawals(?string $code = null, ?int $since = null, ?int $limit = null, $params = array ()): array {
        /**
         * fetch history of deposits and withdrawals from external wallets and between CoinList Pro trading account and CoinList wallet
         *
         * @see https://trade-docs.coinlist.co/?javascript--nodejs#get-coinlist-wallet-ledger
         *
         * @param {string} [$code] unified $currency $code for the $currency of the deposit/withdrawals
         * @param {int} [$since] timestamp in ms of the earliest deposit/withdrawal
         * @param {int} [$limit] max number of deposit/withdrawals to return (default 200, max 500)
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @return {array} a list of ~@link https://docs.ccxt.com/#/?id=transaction-structure transaction structure~
         */
        if ($code === null) {
            throw new ArgumentsRequired($this->id . ' fetchDepositsWithdrawals() requires a $code argument');
        }
        $traderId = $this->safe_string_2($params, 'trader_id', 'traderId');
        if ($traderId === null) {
            throw new ArgumentsRequired($this->id . ' fetchDepositsWithdrawals() requires a $traderId argument in the params');
        }
        $this->load_markets();
        $currency = $this->currency($code);
        $request = array(
            'asset' => $currency['id'],
            'trader_id' => $traderId,
        );
        if ($limit !== null) {
            $request['count'] = $limit;
        }
        $params = $this->omit($params, array( 'trader_id', 'traderId' ));
        $response = $this->privateGetV1AccountsTraderIdWalletLedger ($this->extend($request, $params));
        //
        //     array(
        //         array(
        //             "id" => "2c02db25-e8f2-4271-8222-e110bfd0aa2a",
        //             "asset" => "ETH",
        //             "amount" => "0.01",
        //             "created_at" => "2023-10-20T13:15:37.000Z",
        //             "description" => "Transfer to CoinList Pro",
        //             "type" => "PRO_TRANSFER",
        //             "delta" => "-0.010000000000000000"
        //         ),
        //         array(
        //             "id" => "7139384d-6cec-479e-a19c-d498647ccb47",
        //             "asset" => "ETH",
        //             "amount" => "0.01",
        //             "created_at" => "2023-10-20T13:10:55.000Z",
        //             "description" => "CRYPTO_DEPOSIT",
        //             "type" => "CRYPTO_DEPOSIT",
        //             "delta" => "0.010000000000000000"
        //         ),
        //
        //         ...
        //
        //         array(
        //             "id" => "91bbbb22-5ede-4e9a-81ef-3f9318aa83d2",
        //             "asset" => "USDT",
        //             "amount" => "4.169654",
        //             "withdrawal_fee_amount" => "8.830346000000000000",
        //             "created_at" => "2023-10-27T16:14:11.000Z",
        //             "description" => "CRYPTO_WITHDRAWAL",
        //             "type" => "CRYPTO_WITHDRAWAL",
        //             "delta" => "-4.169654000000000000"
        //         ),
        //         {
        //             "id" => "830261bd-cda9-401f-b6df-105f4da3b37c",
        //             "asset" => "USDT",
        //             "amount" => "13",
        //             "created_at" => "2023-10-27T14:52:05.000Z",
        //             "description" => "Transfer from CoinList Pro",
        //             "type" => "PRO_TRANSFER",
        //             "delta" => "13.000000000000000000"
        //         }
        //     )
        //
        // coinlist returns both internal transfers and blockchain transactions
        return $this->parse_transactions($response, $currency, $since, $limit);
    }

    public function withdraw(string $code, float $amount, string $address, $tag = null, $params = array ()): array {
        /**
         * $request a withdrawal from CoinList wallet. (Disabled by default. Contact CoinList to apply for an exception.)
         *
         * @see https://trade-docs.coinlist.co/?javascript--nodejs#$request-withdrawal-from-wallet
         *
         * @param {string} $code unified $currency $code
         * @param {float} $amount the $amount to withdraw
         * @param {string} $address the $address to withdraw to
         * @param {string} $tag
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @return {array} a ~@link https://docs.ccxt.com/#/?id=transaction-structure transaction structure~
         */
        $this->load_markets();
        $currency = $this->currency($code);
        $request = array(
            'asset' => $currency['id'],
            'amount' => $this->currency_to_precision($code, $amount),
            'destination_address' => $address,
        );
        $response = $this->privatePostV1TransfersWithdrawalRequest ($this->extend($request, $params));
        //
        //     {
        //         "transfer_id" => "d4a2d8dd-7def-4545-a062-761683b9aa05"
        //     }
        //
        $data = $this->safe_dict($response, 'data', array());
        return $this->parse_transaction($data, $currency);
    }

    public function parse_transaction(array $transaction, ?array $currency = null): array {
        // withdraw
        //
        //     {
        //         "transfer_id" => "d4a2d8dd-7def-4545-a062-761683b9aa05"
        //     }
        //
        // fetchDepositsWithdrawals
        //     array(
        //         "id" => "91bbbb22-5ede-4e9a-81ef-3f9318aa83d2",
        //         "asset" => "USDT",
        //         "amount" => "4.169654",
        //         "withdrawal_fee_amount" => "8.830346000000000000",
        //         "created_at" => "2023-10-27T16:14:11.000Z",
        //         "description" => "CRYPTO_WITHDRAWAL",
        //         "type" => "CRYPTO_WITHDRAWAL",
        //         "delta" => "-4.169654000000000000"
        //     ),
        //
        $currencyId = $this->safe_string($transaction, 'asset');
        $code = $this->safe_currency_code($currencyId, $currency);
        $id = $this->safe_string_2($transaction, 'id', 'transfer_id');
        $amount = $this->safe_number($transaction, 'amount');
        $timestamp = $this->parse8601($this->safe_string($transaction, 'created_at'));
        $type = $this->safe_string($transaction, 'type', null);
        if ($type === null) {
            $type = 'withdrawal'; // null only in withdraw() method
        } else {
            $type = $this->parse_transaction_type($type);
        }
        $fee = null;
        $feeCost = $this->safe_string($transaction, 'withdrawal_fee_amount');
        if ($feeCost !== null) {
            $fee = array(
                'cost' => $feeCost,
                'currency' => $code,
            );
        }
        return array(
            'info' => $transaction,
            'id' => $id,
            'txid' => null,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'network' => null,
            'addressFrom' => null,
            'address' => null,
            'addressTo' => null,
            'tagFrom' => null,
            'tag' => null,
            'tagTo' => null,
            'type' => $type,
            'amount' => $amount,
            'currency' => $code,
            'status' => null,
            'updated' => null,
            'fee' => $fee,
            'comment' => $this->safe_string($transaction, 'description'),
            'internal' => null,
        );
    }

    public function parse_transaction_type($type) {
        $types = array(
            'CRYPTO_DEPOSIT' => 'deposit',
            'CRYPTO_WITHDRAWAL' => 'withdrawal',
            'PRO_TRANSFER' => 'transfer',
        );
        return $this->safe_string($types, $type, $type);
    }

    public function fetch_ledger(?string $code = null, ?int $since = null, ?int $limit = null, $params = array ()): array {
        /**
         * fetch the history of changes, actions done by the user or operations that altered the balance of the user
         *
         * @see https://trade-docs.coinlist.co/?javascript--nodejs#get-account-history
         *
         * @param {string} [$code] unified $currency $code, default is null
         * @param {int} [$since] timestamp in ms of the earliest $ledger entry, default is null
         * @param {int} [$limit] max number of $ledger entries to return (default 200, max 500)
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @param {int} [$params->until] the latest time in ms to fetch entries for
         * @return {array} a ~@link https://docs.ccxt.com/#/?id=$ledger ledger structure~
         */
        $traderId = $this->safe_string_2($params, 'trader_id', 'traderId');
        if ($traderId === null) {
            throw new ArgumentsRequired($this->id . ' fetchLedger() requires a $traderId argument in the params');
        }
        $this->load_markets();
        $request = array(
            'trader_id' => $traderId,
        );
        $currency = null;
        if ($code !== null) {
            $currency = $this->currency($code);
        }
        if ($since !== null) {
            $request['start_time'] = $this->iso8601($since);
        }
        if ($limit !== null) {
            $request['count'] = $limit;
        }
        $until = $this->safe_integer($params, 'until');
        if ($until !== null) {
            $params = $this->omit($params, array( 'until' ));
            $request['end_time'] = $this->iso8601($until);
        }
        $params = $this->omit($params, array( 'trader_id', 'traderId' ));
        $response = $this->privateGetV1AccountsTraderIdLedger ($this->extend($request, $params));
        //
        //     {
        //         "transactions" => array(
        //             array(
        //                 "transaction_id" => "0288634e-49bd-494d-b04a-18fd1832d394",
        //                 "transaction_type" => "XFER",
        //                 "type" => "deposit",
        //                 "asset" => "ETH",
        //                 "symbol" => null,
        //                 "amount" => "0.010000000000000000",
        //                 "details" => null,
        //                 "created_at" => "2023-10-20T13:15:39.443Z"
        //             ),
        //             array(
        //                 "transaction_id" => "47a45928-abcd-4c12-8bd6-587c3028025f",
        //                 "transaction_type" => "SWAP",
        //                 "type" => "atomic token swap",
        //                 "asset" => "USDT",
        //                 "symbol" => "ETH-USDT",
        //                 "amount" => "1.447947",
        //                 "details" => null,
        //                 "created_at" => "2023-10-20T13:16:30.373Z"
        //             ),
        //             {
        //                 "transaction_id" => "1ffe3a54-916e-41f0-b957-3a01309eb009",
        //                 "transaction_type" => "FEE",
        //                 "type" => "fee",
        //                 "asset" => "USDT",
        //                 "symbol" => "ETH-USDT",
        //                 "amount" => "-0.006516",
        //                 "details" => array(
        //                     "fee_details" => array(
        //                         array(
        //                             "insurance_fee" => "0",
        //                             "order_id" => "39911d5f-c789-4a7d-ad34-820a804d1da6",
        //                             "fee_type" => "taker",
        //                             "fee_currency" => "USDT"
        //                         }
        //                     )
        //                 ),
        //                 "created_at" => "2023-10-20T13:16:30.373Z"
        //             ),
        //             array(
        //                 "transaction_id" => "3930e8a3-2218-481f-8c3c-2219287e205e",
        //                 "transaction_type" => "SWAP",
        //                 "type" => "atomic token swap",
        //                 "asset" => "ETH",
        //                 "symbol" => "ETH-USDT",
        //                 "amount" => "-0.000900000000000000",
        //                 "details" => null,
        //                 "created_at" => "2023-10-20T13:16:30.373Z"
        //             ),
        //             {
        //                 "transaction_id" => "a6c65cb3-95d0-44e2-8202-f70581d6e55c",
        //                 "transaction_type" => "XFER",
        //                 "type" => "withdrawal",
        //                 "asset" => "USD",
        //                 "symbol" => null,
        //                 "amount" => "-3.00",
        //                 "details" => null,
        //                 "created_at" => "2023-10-26T14:32:24.887Z"
        //             }
        //         )
        //     }
        //
        $ledger = $this->safe_value($response, 'transactions', array());
        return $this->parse_ledger($ledger, $currency, $since, $limit);
    }

    public function parse_ledger_entry(array $item, ?array $currency = null): array {
        //
        // deposit transaction from wallet (funding) to pro (trading)
        //     {
        //         "transaction_id" => "0288634e-49bd-494d-b04a-18fd1832d394",
        //         "transaction_type" => "XFER",
        //         "type" => "deposit",
        //         "asset" => "ETH",
        //         "symbol" => null,
        //         "amount" => "0.010000000000000000",
        //         "details" => null,
        //         "created_at" => "2023-10-20T13:15:39.443Z"
        //     }
        //
        // withdrawal transaction from pro (trading) to wallet (funding)
        //     {
        //         "transaction_id" => "a6c65cb3-95d0-44e2-8202-f70581d6e55c",
        //         "transaction_type" => "XFER",
        //         "type" => "withdrawal",
        //         "asset" => "USD",
        //         "symbol" => null,
        //         "amount" => "-3.00",
        //         "details" => null,
        //         "created_at" => "2023-10-26T14:32:24.887Z"
        //     }
        //
        // sell trade
        //     {
        //         "transaction_id" => "47a45928-abcd-4c12-8bd6-587c3028025f",
        //         "transaction_type" => "SWAP",
        //         "type" => "atomic token swap",
        //         "asset" => "USDT",
        //         "symbol" => "ETH-USDT",
        //         "amount" => "1.447947",
        //         "details" => null,
        //         "created_at" => "2023-10-20T13:16:30.373Z"
        //     }
        //
        // buy trade
        //     array(
        //         "transaction_id" => "46d20a93-45c4-4441-a238-f89602eb8c8c",
        //         "transaction_type" => "SWAP",
        //         "type" => "atomic token swap",
        //         "asset" => "ETH",
        //         "symbol" => "ETH-USDT",
        //         "amount" => "0.000800000000000000",
        //         "details" => null,
        //         "created_at" => "2023-10-20T13:22:14.256Z"
        //     ),
        //
        //  fee
        //     {
        //         "transaction_id" => "57fd526c-36b1-4721-83ce-42aadcb1e953",
        //         "transaction_type" => "FEE",
        //         "type" => "fee",
        //         "asset" => "USDT",
        //         "symbol" => "BTC-USDT",
        //         "amount" => "-0.047176",
        //         "details" => {
        //             "fee_details" => array(
        //                 array(
        //                     "insurance_fee" => "0",
        //                     "order_id" => "c0bc33cd-eeb9-40a0-ab5f-2d99f323ef58",
        //                     "fee_type" => "taker",
        //                     "fee_currency" => "USDT"
        //                 }
        //             )
        //         ),
        //         "created_at" => "2023-10-25T16:46:24.294Z"
        //     }
        //
        $id = $this->safe_string($item, 'transaction_id');
        $createdAt = $this->safe_string($item, 'created_at');
        $timestamp = $this->parse8601($createdAt);
        $amount = $this->safe_string($item, 'amount');
        $amountIsNegative = Precise::string_lt($amount, '0');
        $direction = null;
        if ($amountIsNegative) {
            $direction = 'out';
            $amount = Precise::string_neg($amount);
        } else {
            $direction = 'in';
        }
        $currencyId = $this->safe_string($item, 'asset');
        $code = $this->safe_currency_code($currencyId, $currency);
        $currency = $this->safe_currency($currencyId, $currency);
        $type = $this->parse_ledger_entry_type($this->safe_string($item, 'type'));
        return $this->safe_ledger_entry(array(
            'info' => $item,
            'id' => $id,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'direction' => $direction,
            'account' => 'trading',
            'referenceId' => null,
            'referenceAccount' => null,
            'type' => $type,
            'currency' => $code,
            'amount' => $this->parse_number($amount),
            'before' => null,
            'after' => null,
            'status' => 'ok',
            'fee' => null,
        ), $currency);
    }

    public function parse_ledger_entry_type($type) {
        $types = array(
            'atomic token swap' => 'trade',
            'fee' => 'fee',
            'deposit' => 'transfer',
            'withdrawal' => 'transfer',
        );
        return $this->safe_string($types, $type, $type);
    }

    public function fetch_funding_rate(string $symbol, $params = array ()): array {
        /**
         * fetch the current funding rate
         *
         * @see https://trade-docs.coinlist.co/#coinlist-pro-api-Funding-Rates
         *
         * @param {string} $symbol unified $market $symbol
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @return {array} a ~@link https://docs.ccxt.com/#/?id=funding-rate-structure funding rate structure~
         */
        $this->load_markets();
        $market = $this->market($symbol);
        if (!$market['swap']) {
            throw new BadSymbol($this->id . ' fetchFundingRate() supports swap contracts only');
        }
        $request = array(
            'symbol' => $market['id'],
        );
        $response = $this->publicGetV1SymbolsSymbolFunding ($this->extend($request, $params));
        //
        //     {
        //         "last" => array(
        //             "funding_rate" => "-0.00043841",
        //             "funding_time" => "2025-04-15T04:00:00.000Z"
        //         ),
        //         "next" => array(
        //             "funding_rate" => "-0.00046952",
        //             "funding_time" => "2025-04-15T12:00:00.000Z"
        //         ),
        //         "indicative" => array(
        //             "funding_rate" => "-0.00042517",
        //             "funding_time" => "2025-04-15T20:00:00.000Z"
        //         ),
        //         "timestamp" => "2025-04-15T07:01:15.219Z"
        //     }
        //
        return $this->parse_funding_rate($response, $market);
    }

    public function parse_funding_rate($contract, ?array $market = null): array {
        //
        //     {
        //         "last" => array(
        //             "funding_rate" => "-0.00043841",
        //             "funding_time" => "2025-04-15T04:00:00.000Z"
        //         ),
        //         "next" => array(
        //             "funding_rate" => "-0.00046952",
        //             "funding_time" => "2025-04-15T12:00:00.000Z"
        //         ),
        //         "indicative" => array(
        //             "funding_rate" => "-0.00042517",
        //             "funding_time" => "2025-04-15T20:00:00.000Z"
        //         ),
        //         "timestamp" => "2025-04-15T07:01:15.219Z"
        //     }
        //
        $previous = $this->safe_dict($contract, 'last', array());
        $current = $this->safe_dict($contract, 'next', array());
        $next = $this->safe_dict($contract, 'indicative', array());
        $previousDatetime = $this->safe_string($previous, 'funding_time');
        $currentDatetime = $this->safe_string($current, 'funding_time');
        $nextDatetime = $this->safe_string($next, 'funding_time');
        $datetime = $this->safe_string($contract, 'timestamp');
        return array(
            'info' => $contract,
            'symbol' => $this->safe_symbol(null, $market),
            'markPrice' => null,
            'indexPrice' => null,
            'interestRate' => null,
            'estimatedSettlePrice' => null,
            'timestamp' => $this->parse8601($datetime),
            'datetime' => $datetime,
            'fundingRate' => $this->safe_number($current, 'funding_rate'),
            'fundingTimestamp' => $this->parse8601($currentDatetime),
            'fundingDatetime' => $currentDatetime,
            'nextFundingRate' => $this->safe_number($next, 'funding_rate'),
            'nextFundingTimestamp' => $this->parse8601($nextDatetime),
            'nextFundingDatetime' => $nextDatetime,
            'previousFundingRate' => $this->safe_number($previous, 'funding_rate'),
            'previousFundingTimestamp' => $this->parse8601($previousDatetime),
            'previousFundingDatetime' => $previousDatetime,
            'interval' => '8h',
        );
    }

    public function sign($path, $api = 'public', $method = 'GET', $params = array (), $headers = null, $body = null) {
        $request = $this->omit($params, $this->extract_params($path));
        $endpoint = '/' . $this->implode_params($path, $params);
        $url = $this->urls['api'][$api] . $endpoint;
        $isBulk = gettype($params) === 'array' && array_keys($params) === array_keys(array_keys($params));
        $query = null;
        if (!$isBulk) {
            $query = $this->urlencode($request);
        }
        if ($api === 'private') {
            $this->check_required_credentials();
            $timestamp = (string) $this->seconds();
            $auth = $timestamp . $method . $endpoint;
            if (($method === 'POST') || ($method === 'PATCH') || $isBulk) {
                $body = $this->json($request);
                $auth .= $body;
            } elseif ($query !== null && strlen($query) !== 0) {
                $auth .= '?' . $query;
                $url .= '?' . $query;
            }
            $signature = $this->hmac($this->encode($auth), base64_decode($this->secret), 'sha256', 'base64');
            $headers = array(
                'CL-ACCESS-KEY' => $this->apiKey,
                'CL-ACCESS-SIG' => $signature,
                'CL-ACCESS-TIMESTAMP' => $timestamp,
                'Content-Type' => 'application/json',
            );
        } elseif ($query !== null && strlen($query) !== 0) {
            $url .= '?' . $query;
        }
        return array( 'url' => $url, 'method' => $method, 'body' => $body, 'headers' => $headers );
    }

    public function handle_errors(int $code, string $reason, string $url, string $method, array $headers, string $body, $response, $requestHeaders, $requestBody) {
        if ($response === null) {
            // In some cases the exchange returns 202 Accepted for bad orders.
            // The $body of that $response contains order_id of the order.
            // Some bad orders will get status 'rejected' and could be fetched later (by using fetchOrders() or fetchOrder(order_id)).
            // While others don't get any status, they simply disappear, but the $response is still 202 Accepted and contains their order_id.
            // When using fechOrder(order_id) for such disappeared orders, the exchange returns an empty $response with $code 404.
            if (($code === 404) && (mb_strpos($url, '/orders/') !== false) && ($method === 'GET')) {
                $parts = explode('/orders/', $url);
                $orderId = $this->safe_string($parts, 1);
                throw new OrderNotFound($this->id . ' order ' . $orderId . ' not found (or rejected on the exchange side)');
            }
            return null;
        }
        $responseCode = $this->safe_string($response, 'status');
        $messageCode = $this->safe_string($response, 'message_code');
        if (($messageCode !== null) || (($responseCode !== null) && ($code !== 200) && ($code !== 202) && ($responseCode !== '200') && ($responseCode !== '202'))) {
            $feedback = $this->id . ' ' . $body;
            $message = $this->safe_string($response, 'message');
            $this->throw_broadly_matched_exception($this->exceptions['broad'], $message, $feedback);
            $this->throw_exactly_matched_exception($this->exceptions['exact'], $messageCode, $feedback);
            throw new ExchangeError($feedback);
        }
        return null;
    }
}
