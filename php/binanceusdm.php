<?php

namespace ccxt;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

use Exception; // a common import
use \ccxt\BadRequest;

class binanceusdm extends binance {

    public function describe() {
        return $this->deep_extend(parent::describe (), array(
            'id' => 'binanceusdm',
            'name' => 'Binance USDⓈ-M',
            'urls' => array(
                'logo' => 'https://user-images.githubusercontent.com/1294454/117738721-668c8d80-b205-11eb-8c49-3fad84c4a07f.jpg',
            ),
            'has' => array(
                'fetchPositions' => true,
                'fetchIsolatedPositions' => true,
                'fetchFundingRate' => true,
                'fetchFundingHistory' => true,
                'setLeverage' => true,
                'setMarginMode' => true,
            ),
            'options' => array(
                'defaultType' => 'future',
                // https://www.binance.com/en/support/faq/360033162192
                // tier amount, maintenance margin, initial margin
                'leverageBrackets' => null,
                'marginTypes' => array(),
            ),
            // https://www.binance.com/en/fee/futureFee
            'fees' => array(
                'trading' => array(
                    'tierBased' => true,
                    'percentage' => true,
                    'taker' => $this->parse_number('0.000400'),
                    'maker' => $this->parse_number('0.000200'),
                    'tiers' => array(
                        'taker' => array(
                            array( $this->parse_number('0'), $this->parse_number('0.000400') ),
                            array( $this->parse_number('250'), $this->parse_number('0.000400') ),
                            array( $this->parse_number('2500'), $this->parse_number('0.000350') ),
                            array( $this->parse_number('7500'), $this->parse_number('0.000320') ),
                            array( $this->parse_number('22500'), $this->parse_number('0.000300') ),
                            array( $this->parse_number('50000'), $this->parse_number('0.000270') ),
                            array( $this->parse_number('100000'), $this->parse_number('0.000250') ),
                            array( $this->parse_number('200000'), $this->parse_number('0.000220') ),
                            array( $this->parse_number('400000'), $this->parse_number('0.000200') ),
                            array( $this->parse_number('750000'), $this->parse_number('0.000170') ),
                        ),
                        'maker' => array(
                            array( $this->parse_number('0'), $this->parse_number('0.000200') ),
                            array( $this->parse_number('250'), $this->parse_number('0.000160') ),
                            array( $this->parse_number('2500'), $this->parse_number('0.000140') ),
                            array( $this->parse_number('7500'), $this->parse_number('0.000120') ),
                            array( $this->parse_number('22500'), $this->parse_number('0.000100') ),
                            array( $this->parse_number('50000'), $this->parse_number('0.000080') ),
                            array( $this->parse_number('100000'), $this->parse_number('0.000060') ),
                            array( $this->parse_number('200000'), $this->parse_number('0.000040') ),
                            array( $this->parse_number('400000'), $this->parse_number('0.000020') ),
                            array( $this->parse_number('750000'), $this->parse_number('0') ),
                        ),
                    ),
                ),
            ),
        ));
    }

    public function fetch_trading_fees($params = array ()) {
        $this->load_markets();
        $marketSymbols = is_array($this->markets) ? array_keys($this->markets) : array();
        $fees = array();
        $accountInfo = $this->fapiPrivateGetAccount ($params);
        // {
        //     "$feeTier" => 0,       // account commisssion tier
        //     "canTrade" => true,   // if can trade
        //     "canDeposit" => true,     // if can transfer in asset
        //     "canWithdraw" => true,    // if can transfer out asset
        //     "updateTime" => 0,
        //     "totalInitialMargin" => "0.00000000",    // total initial margin required with current mark price (useless with isolated positions), only for USDT asset
        //     "totalMaintMargin" => "0.00000000",     // total maintenance margin required, only for USDT asset
        //     "totalWalletBalance" => "23.72469206",     // total wallet balance, only for USDT asset
        //     "totalUnrealizedProfit" => "0.00000000",   // total unrealized profit, only for USDT asset
        //     "totalMarginBalance" => "23.72469206",     // total margin balance, only for USDT asset
        //     "totalPositionInitialMargin" => "0.00000000",    // initial margin required for positions with current mark price, only for USDT asset
        //     "totalOpenOrderInitialMargin" => "0.00000000",   // initial margin required for open orders with current mark price, only for USDT asset
        //     "totalCrossWalletBalance" => "23.72469206",      // crossed wallet balance, only for USDT asset
        //     "totalCrossUnPnl" => "0.00000000",      // unrealized profit of crossed positions, only for USDT asset
        //     "availableBalance" => "23.72469206",       // available balance, only for USDT asset
        //     "maxWithdrawAmount" => "23.72469206"     // maximum amount for transfer out, only for USDT asset
        //     ...
        // }
        $feeTier = $this->safe_integer($accountInfo, 'feeTier');
        $feeTiers = $this->fees['trading']['tiers'];
        $maker = $feeTiers['maker'][$feeTier][1];
        $taker = $feeTiers['taker'][$feeTier][1];
        for ($i = 0; $i < count($marketSymbols); $i++) {
            $symbol = $marketSymbols[$i];
            $fees[$symbol] = array(
                'info' => array(
                    'feeTier' => $feeTier,
                ),
                'symbol' => $symbol,
                'maker' => $maker,
                'taker' => $taker,
            );
        }
        return $fees;
    }

    public function transfer_in($code, $amount, $params = array ()) {
        // transfer from spot wallet to usdm futures wallet
        return $this->futuresTransfer ($code, $amount, 1, $params);
    }

    public function transfer_out($code, $amount, $params = array ()) {
        // transfer from usdm futures wallet to spot wallet
        return $this->futuresTransfer ($code, $amount, 2, $params);
    }

    public function fetch_funding_rate($symbol, $params = array ()) {
        $this->load_markets();
        $market = $this->market($symbol);
        $request = array(
            'symbol' => $market['id'],
        );
        $response = $this->fapiPublicGetPremiumIndex (array_merge($request, $params));
        //
        //   {
        //     "$symbol" => "BTCUSDT",
        //     "markPrice" => "45802.81129892",
        //     "indexPrice" => "45745.47701915",
        //     "estimatedSettlePrice" => "45133.91753671",
        //     "lastFundingRate" => "0.00063521",
        //     "interestRate" => "0.00010000",
        //     "nextFundingTime" => "1621267200000",
        //     "time" => "1621252344001"
        //  }
        //
        return $this->parse_funding_rate ($response);
    }

    public function fetch_funding_rates($symbols = null, $params = array ()) {
        $this->load_markets();
        $response = $this->fapiPublicGetPremiumIndex ($params);
        $result = array();
        for ($i = 0; $i < count($response); $i++) {
            $entry = $response[$i];
            $parsed = $this->parse_funding_rate ($entry);
            $result[] = $parsed;
        }
        return $this->filter_by_array($result, 'symbol', $symbols);
    }

    public function load_leverage_brackets($reload = false, $params = array ()) {
        $this->load_markets();
        // by default cache the leverage $bracket
        // it contains useful stuff like the maintenance margin and initial margin for positions
        $leverageBrackets = $this->safe_value($this->options, 'leverageBrackets');
        if (($leverageBrackets === null) || ($reload)) {
            $response = $this->fapiPrivateGetLeverageBracket ($params);
            $this->options['leverageBrackets'] = array();
            for ($i = 0; $i < count($response); $i++) {
                $entry = $response[$i];
                $marketId = $this->safe_string($entry, 'symbol');
                $symbol = $this->safe_symbol($marketId);
                $brackets = $this->safe_value($entry, 'brackets');
                $result = array();
                for ($j = 0; $j < count($brackets); $j++) {
                    $bracket = $brackets[$j];
                    // we use floats here internally on purpose
                    $notionalFloor = $this->safe_float($bracket, 'notionalFloor');
                    $maintenanceMarginPercentage = $this->safe_string($bracket, 'maintMarginRatio');
                    $result[] = array( $notionalFloor, $maintenanceMarginPercentage );
                }
                $this->options['leverageBrackets'][$symbol] = $result;
            }
        }
        return $this->options['leverageBrackets'];
    }

    public function fetch_positions($symbols = null, $params = array ()) {
        $this->load_markets();
        $this->load_leverage_brackets();
        $account = $this->fapiPrivateGetAccount ($params);
        $result = $this->parse_account_positions ($account);
        return $this->filter_by_array($result, 'symbol', $symbols, false);
    }

    public function fetch_isolated_positions($symbol = null, $params = array ()) {
        // only supported in usdm futures
        $this->load_markets();
        $this->load_leverage_brackets();
        $request = array();
        $market = null;
        if ($symbol !== null) {
            $market = $this->market($symbol);
            $request['symbol'] = $market['id'];
        }
        $response = $this->fapiPrivateGetPositionRisk (array_merge($request, $params));
        if ($symbol === null) {
            $result = array();
            for ($i = 0; $i < count($response); $i++) {
                $parsed = $this->parse_position_risk ($response[$i], $market);
                if ($parsed['marginType'] === 'isolated') {
                    $result[] = $parsed;
                }
            }
            return $result;
        } else {
            return $this->parse_position_risk ($this->safe_value($response, 0), $market);
        }
    }

    public function fetch_funding_history($symbol = null, $since = null, $limit = null, $params = array ()) {
        $this->load_markets();
        $market = null;
        // "TRANSFER"，"WELCOME_BONUS", "REALIZED_PNL"，"FUNDING_FEE", "COMMISSION" and "INSURANCE_CLEAR"
        $request = array(
            'incomeType' => 'FUNDING_FEE',
        );
        if ($symbol !== null) {
            $market = $this->market($symbol);
            $request['symbol'] = $market['id'];
        }
        if ($since !== null) {
            $request['startTime'] = $since;
        }
        if ($limit !== null) {
            $request['limit'] = $limit;
        }
        $response = $this->fapiPrivateGetIncome (array_merge($request, $params));
        return $this->parse_incomes ($response, $market, $since, $limit);
    }

    public function set_leverage($symbol, $leverage, $params = array ()) {
        // WARNING => THIS WILL INCREASE LIQUIDATION PRICE FOR OPEN ISOLATED LONG POSITIONS
        // AND DECREASE LIQUIDATION PRICE FOR OPEN ISOLATED SHORT POSITIONS
        if (($leverage < 1) || ($leverage > 125)) {
            throw new BadRequest($this->id . ' $leverage should be between 1 and 125');
        }
        $this->load_markets();
        $market = $this->market($symbol);
        $request = array(
            'symbol' => $market['id'],
            'leverage' => $leverage,
        );
        return $this->fapiPrivatePostLeverage (array_merge($request, $params));
    }

    public function set_margin_mode($symbol, $marginType, $params = array ()) {
        //
        // array( "code" => -4048 , "msg" => "Margin type cannot be changed if there exists position." )
        //
        // or
        //
        // array( "code" => 200, "msg" => "success" )
        //
        $marginType = strtoupper($marginType);
        if (($marginType !== 'ISOLATED') && ($marginType !== 'CROSSED')) {
            throw new BadRequest($this->id . ' $marginType must be either isolated or crossed');
        }
        $this->load_markets();
        $market = $this->market($symbol);
        $request = array(
            'symbol' => $market['id'],
            'marginType' => $marginType,
        );
        return $this->fapiPrivatePostMarginType (array_merge($request, $params));
    }
}
